-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GraphQL API over Postgres
--   
--   GraphQL API over Postgres
@package graphql-engine
@version 1.0.0

module Control.Arrow.Trans
class (Arrow arr, Arrow (t arr)) => ArrowTrans t arr
liftA :: ArrowTrans t arr => arr a b -> t arr a b
class (Arrow arr) => ArrowError e arr | arr -> e
throwA :: ArrowError e arr => arr e a
catchA :: ArrowError e arr => arr (a, s) b -> arr (a, (e, s)) b -> arr (a, s) b
liftEitherA :: (ArrowChoice arr, ArrowError e arr) => arr (Either e a) a
mapErrorA :: ArrowError e arr => arr (a, s) b -> arr (a, (e -> e, s)) b
class (Arrow arr) => ArrowReader r arr | arr -> r
askA :: ArrowReader r arr => arr a r
localA :: ArrowReader r arr => arr (a, s) b -> arr (a, (r, s)) b
class (Monoid w, Arrow arr) => ArrowWriter w arr | arr -> w
tellA :: ArrowWriter w arr => arr w ()
listenA :: ArrowWriter w arr => arr a b -> arr a (b, w)
newtype ErrorA e arr a b
ErrorA :: arr a (Either e b) -> ErrorA e arr a b
[runErrorA] :: ErrorA e arr a b -> arr a (Either e b)
sequenceFirst :: Functor f => (f a, b) -> f (a, b)
reassociateEither :: Either (Either a b) c -> Either a (Either b c)
newtype ReaderA r arr a b
ReaderA :: arr (a, r) b -> ReaderA r arr a b
[runReaderA] :: ReaderA r arr a b -> arr (a, r) b
newtype WriterA w arr a b
MkWriterA :: arr (a, w) (b, w) -> WriterA w arr a b
pattern WriterA :: (Monoid w, Arrow arr) => arr a (b, w) -> WriterA w arr a b
instance GHC.Base.Functor (arr a) => GHC.Base.Functor (Control.Arrow.Trans.ErrorA e arr a)
instance Control.Category.Category arr => Control.Category.Category (Control.Arrow.Trans.WriterA w arr)
instance Control.Arrow.Arrow arr => Control.Arrow.Arrow (Control.Arrow.Trans.WriterA w arr)
instance Control.Arrow.ArrowChoice arr => Control.Arrow.ArrowChoice (Control.Arrow.Trans.WriterA w arr)
instance Control.Arrow.ArrowApply arr => Control.Arrow.ArrowApply (Control.Arrow.Trans.WriterA w arr)
instance Control.Arrow.Arrow arr => Control.Arrow.Trans.ArrowTrans (Control.Arrow.Trans.WriterA w) arr
instance (GHC.Base.Monoid w, Control.Arrow.Arrow arr) => Control.Arrow.Trans.ArrowWriter w (Control.Arrow.Trans.WriterA w arr)
instance Control.Arrow.Trans.ArrowError e arr => Control.Arrow.Trans.ArrowError e (Control.Arrow.Trans.WriterA w arr)
instance Control.Arrow.Trans.ArrowReader r arr => Control.Arrow.Trans.ArrowReader r (Control.Arrow.Trans.WriterA w arr)
instance Control.Arrow.Arrow arr => Control.Category.Category (Control.Arrow.Trans.ReaderA r arr)
instance Control.Arrow.Arrow arr => Control.Arrow.Arrow (Control.Arrow.Trans.ReaderA r arr)
instance Control.Arrow.ArrowChoice arr => Control.Arrow.ArrowChoice (Control.Arrow.Trans.ReaderA r arr)
instance Control.Arrow.ArrowApply arr => Control.Arrow.ArrowApply (Control.Arrow.Trans.ReaderA r arr)
instance Control.Arrow.Arrow arr => Control.Arrow.Trans.ArrowTrans (Control.Arrow.Trans.ReaderA r) arr
instance Control.Arrow.Arrow arr => Control.Arrow.Trans.ArrowReader r (Control.Arrow.Trans.ReaderA r arr)
instance Control.Arrow.Trans.ArrowError e arr => Control.Arrow.Trans.ArrowError e (Control.Arrow.Trans.ReaderA r arr)
instance Control.Arrow.Trans.ArrowWriter w arr => Control.Arrow.Trans.ArrowWriter w (Control.Arrow.Trans.ReaderA r arr)
instance Control.Arrow.ArrowChoice arr => Control.Category.Category (Control.Arrow.Trans.ErrorA e arr)
instance Control.Arrow.ArrowChoice arr => Control.Arrow.Arrow (Control.Arrow.Trans.ErrorA e arr)
instance Control.Arrow.ArrowChoice arr => Control.Arrow.ArrowChoice (Control.Arrow.Trans.ErrorA e arr)
instance (Control.Arrow.ArrowChoice arr, Control.Arrow.ArrowApply arr) => Control.Arrow.ArrowApply (Control.Arrow.Trans.ErrorA e arr)
instance Control.Arrow.ArrowChoice arr => Control.Arrow.Trans.ArrowTrans (Control.Arrow.Trans.ErrorA e) arr
instance Control.Arrow.ArrowChoice arr => Control.Arrow.Trans.ArrowError e (Control.Arrow.Trans.ErrorA e arr)
instance (Control.Arrow.Trans.ArrowReader r arr, Control.Arrow.ArrowChoice arr) => Control.Arrow.Trans.ArrowReader r (Control.Arrow.Trans.ErrorA e arr)
instance (Control.Arrow.Trans.ArrowWriter w arr, Control.Arrow.ArrowChoice arr) => Control.Arrow.Trans.ArrowWriter w (Control.Arrow.Trans.ErrorA e arr)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Arrow.Trans.ArrowWriter w (Control.Arrow.Kleisli m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Arrow.Trans.ArrowReader r (Control.Arrow.Kleisli m)
instance Control.Monad.Error.Class.MonadError e m => Control.Arrow.Trans.ArrowError e (Control.Arrow.Kleisli m)


-- | The missing standard library for arrows. Some of the functionality in
--   this module is similar to Paterson’s original <tt>arrows</tt> library,
--   but it has been modernized to work with recent versions of GHC.
module Control.Arrow.Extended

-- | The analog to <a>&gt;&gt;=</a> for arrow commands. In <tt>proc</tt>
--   notation, <a>&gt;-&gt;</a> can be used to chain the output of one
--   command into the input of another.
--   
--   See also Note [Weird control operator types].
(>->) :: Arrow arr => arr (e, s) a -> arr (e, (a, s)) b -> arr (e, s) b
infixl 1 >->
(<-<) :: Arrow arr => arr (e, (a, s)) b -> arr (e, s) a -> arr (e, s) b
infixr 1 <-<
dup :: Arrow arr => arr a (a, a)
bothA :: Arrow arr => arr a b -> arr (a, a) (b, b)
orA :: ArrowChoice arr => arr a Bool -> arr b Bool -> arr (a, b) Bool

-- | <a>foldl'</a> lifted to arrows. See also Note [Weird control operator
--   types].
foldlA' :: (ArrowChoice arr, Foldable t) => arr (e, (b, (a, s))) b -> arr (e, (b, (t a, s))) b
traverseA_ :: (ArrowChoice arr, Foldable t) => arr (e, (a, s)) b -> arr (e, (t a, s)) ()

-- | An indexed version of Twan van Laarhoven’s <tt>FunList</tt> type (see
--   <a>https://twanvl.nl/blog/haskell/non-regular1</a>). A value of type
--   <tt><a>Traversal</a> a b (t b)</tt> is a concrete representation of a
--   traversal applied to a data structure of type <tt>t a</tt> and
--   producing a value of type <tt>t b</tt>. This explicit representation
--   is used to implement <a>traverseA</a> using only <a>ArrowChoice</a>.
data Traversal a r b
Done :: b -> Traversal a r b
Yield :: a -> !r -> Traversal a r b -> Traversal a r b
traversal :: Traversable t => t a -> Traversal a b (t b)

-- | <a>traverse</a> lifted to arrows. See also Note [Weird control
--   operator types].
traverseA :: (ArrowChoice arr, Traversable t) => arr (e, (a, s)) b -> arr (e, (t a, s)) (t b)
traverseA_Maybe :: ArrowChoice arr => arr (e, (a, s)) b -> arr (e, (Maybe a, s)) (Maybe b)
onNothingA :: ArrowChoice arr => arr (e, s) a -> arr (e, (Maybe a, s)) a

-- | The class of <i>Kleisli arrows</i>, arrows made from monadic
--   functions. Instances should satisfy the following laws:
--   
--   <ul>
--   <li><tt><a>arrM</a> (<a>pure</a> <a>.</a> <i>f</i>)</tt> ≡
--   <tt><a>arr</a> <i>f</i></tt></li>
--   <li><tt>(<a>arrM</a> <i>f</i> <a>&gt;&gt;&gt;</a> <a>arrM</a>
--   <i>g</i>)</tt> ≡ <tt><a>arrM</a> (<i>f</i> <a>&gt;=&gt;</a>
--   <i>g</i>)</tt>.</li>
--   </ul>
class (Monad m, Arrow arr) => ArrowKleisli m arr | arr -> m
arrM :: ArrowKleisli m arr => (a -> m b) -> arr a b

-- | A combinator that serves a similar role to <a>returnA</a> in arrow
--   notation, except that the argument is a monadic action instead of a
--   pure value. Just as <a>returnA</a> is actually just <tt><a>arr</a>
--   <a>id</a></tt>, <a>bindA</a> is just <tt><a>arrM</a> <a>id</a></tt>,
--   but it is provided as a separate function for clarity.
--   
--   <a>bindA</a> is useful primarily because it allows executing a monadic
--   action using arrow inputs currently in scope. For example:
--   
--   <pre>
--   proc (a, b) -&gt; do
--     x &lt;- foo -&lt; a
--     y &lt;- bar -&lt; b
--     <a>bindA</a> -&lt; f x y
--   </pre>
--   
--   The last statement is equivalent to <tt><a>arrM</a> (<a>uncurry</a> f)
--   -&lt; (x, y)</tt>, but the use of <a>bindA</a> allows it to be
--   expressed more directly.
bindA :: ArrowKleisli m arr => arr (m a) a
instance GHC.Base.Monad m => Control.Arrow.Extended.ArrowKleisli m (Control.Arrow.Kleisli m)
instance (Control.Arrow.Extended.ArrowKleisli m arr, Control.Arrow.ArrowChoice arr) => Control.Arrow.Extended.ArrowKleisli m (Control.Arrow.Trans.ErrorA e arr)
instance Control.Arrow.Extended.ArrowKleisli m arr => Control.Arrow.Extended.ArrowKleisli m (Control.Arrow.Trans.ReaderA r arr)
instance Control.Arrow.Extended.ArrowKleisli m arr => Control.Arrow.Extended.ArrowKleisli m (Control.Arrow.Trans.WriterA w arr)
instance GHC.Base.Functor (Control.Arrow.Extended.Traversal a r)
instance GHC.Base.Applicative (Control.Arrow.Extended.Traversal a r)


-- | <h1>TL;DR</h1>
--   
--   We go from this:
--   
--   <pre>
--   (|
--     withRecordInconsistency
--       ( (|
--           modifyErrA
--             ( do
--                 (info, dependencies) &lt;- liftEitherA -&lt; buildRelInfo relDef
--                 recordDependencies -&lt; (metadataObject, schemaObject, dependencies)
--                 returnA -&lt; info
--             )
--         |) (addTableContext @b table . addRelationshipContext)
--       )
--     |) metadataObject
--   </pre>
--   
--   to this:
--   
--   <pre>
--   withRecordInconsistencyM metadataObject $ do
--     modifyErr (addTableContext @b table . addRelationshipContext) $ do
--       (info, dependencies) &lt;- liftEither $ buildRelInfo relDef
--       recordDependenciesM metadataObject schemaObject dependencies
--       return info
--   </pre>
--   
--   <h1>Background</h1>
--   
--   We use Haskell's <tt>Arrows</tt> language extension to gain some
--   syntactic sugar when working with <a>Arrow</a>s. <a>Arrow</a>s are a
--   programming abstraction comparable to <tt>Monad</tt>s.
--   
--   Unfortunately the syntactic sugar provided by this language extension
--   is not very sweet.
--   
--   This module allows us to sometimes avoid using <tt>Arrows</tt> syntax
--   altogether, without loss of functionality or correctness. It is a demo
--   of a technique that can be used to cut down the amount of
--   <tt>Arrows</tt>-based code in our codebase by about half.
--   
--   <h1>Approach</h1>
--   
--   Although <i>in general</i> not every <tt>Monad</tt> is an
--   <a>Arrow</a>, specific <a>Arrow</a> instantiations are exactly as
--   powerful as their <tt>Monad</tt> equivalents. Otherwise they wouldn't
--   be very equivalent, would they?
--   
--   Just like <tt>liftEither</tt> interprets the <tt><tt>Either</tt>
--   e</tt> monad into an arbitrary monad implementing
--   <tt><tt>MonadError</tt> e</tt>, we add interpret certain concrete
--   monads such as <tt><a>Writer</a> w</tt> into arrows satisfying
--   constraints, in this example the ones satisfying
--   <tt><a>ArrowWriter</a> w</tt>. This means that the part of the code
--   that only uses such interpretable arrow effects can be written
--   <i>monadically</i>, and then used in <i>arrow</i> constructions down
--   the line.
--   
--   This approach cannot be used for arrow effects which do not have a
--   monadic equivalent. In our codebase, the only instance of this is
--   <tt><a>ArrowCache</a> m</tt>, implemented by the <tt><a>Rule</a>
--   m</tt> arrow. So code written with <tt><a>ArrowCache</a> m</tt> in the
--   context cannot be rewritten monadically using this technique.
module Control.Arrow.Interpret

-- | Translate a monadic writer effect stack of a computation into
--   arrow-based effects.
--   
--   NB: This is conceptually different from <a>ArrowKleisli</a>, which
--   <i>inserts</i> a single monadic effect into an arrow-based effect
--   stack.
--   
--   NB: This is conceptually different from <a>ArrowApply</a>, which
--   expresses that a given <a>Arrow</a> <i>is</i> a Kleisli arrow.
--   <tt>ArrowInterpret</tt> has no such condition on <tt>arr</tt>.
interpretWriter :: ArrowWriter w arr => Writer w a `arr` a


-- | Knot-tying monad transformer for recursive graph building.
--   
--   Some operations, such as building a graph, are inherently
--   self-recursive; consider the following graph:
--   
--   <pre>
--   a -&gt; b
--   b -&gt; a
--   </pre>
--   
--   To construct in Haskell, we might want to use the following type:
--   
--   <pre>
--   data Node = Node
--     { nodeName :: Text
--     , nodeNeighbours :: [Node]
--     }
--   </pre>
--   
--   To construct our trivial graph, we need <tt>a</tt> to know about
--   <tt>b</tt> and <tt>b</tt> to know about <tt>a</tt>: this is fine as
--   long as we can build them both at the same time:
--   
--   <pre>
--   graph = [nodeA, nodeB]
--     where
--       nodeA = Node "a" [nodeB]
--       nodeB = Node "b" [nodeA]
--   </pre>
--   
--   But this falls apart as soon as building the nodes becomes more
--   complicated; for instance, if it becomes monadic. This causes an
--   infinite recursion:
--   
--   <pre>
--   graph = do
--     a &lt;- buildA
--     b &lt;- buildB
--     pure [a,b]
--     where
--       buildA = do
--         b &lt;- buildB
--         pure $ Node "a" [b]
--       buildB = do
--         a &lt;- buildA
--         pure $ Node "b" [a]
--   </pre>
--   
--   The reason why the non-monadic version works is laziness; and there is
--   a way to retrieve this laziness in a monadic context: it's what
--   <a>MonadFix</a> is for. (https:/<i>wiki.haskell.org</i>MonadFix)
--   
--   However, <a>MonadFix</a> is both powerful and unintuitive; the goal of
--   this module is to use its power, but to give it a more restricted
--   interface, to make it easier to use. Using <a>CircularT</a>, the graph
--   above can be built monadically like so:
--   
--   <pre>
--   graph = runCircularT do
--     a &lt;- buildA
--     b &lt;- buildB
--     pure [a,b]
--     where
--       buildA = withCircular "a" do
--         b &lt;- buildB
--         pure $ Node "a" [b]
--       buildB = withCircular "b" do
--         a &lt;- buildA
--         pure $ Node "b" [a]
--   </pre>
--   
--   It allows each part of a recursive process to be given a name (the
--   type of which is of the user's choosing), and it automatically breaks
--   cycles. The only caveat is that we cannot violate temporal causality:
--   if we attempt to make a cache-building decision based on the value
--   obtained from the cache, then no amount of laziness can save us:
--   
--   <pre>
--   broken = runCircularT go
--     where
--       go = withCircular () do
--         x &lt;- go
--         pure $ if odd x then 1 else 0
--   </pre>
--   
--   <a>CircularT</a> is somewhat similar to <tt>TardisT</tt> from
--   <tt>Control.Monad.Tardis</tt> and <tt>SchemaT</tt> from
--   <tt>Hasura.GraphQL.Parser.Monad</tt>, but simpler than both.
module Control.Monad.Circular

-- | CircularT is implemented as a state monad containing a lazy HashMap.
--   
--   We use this state to both determine wether we have already encountered
--   a given key and to track the associated result. We use laziness and
--   MonadFix to tie the knot for us (see <a>withCircular</a>).
--   
--   <ul>
--   <li>type <tt>k</tt> is the type of cache key, to which a given action
--   is associated.</li>
--   <li>type <tt>v</tt> is the values we wish to cache in our
--   process.</li>
--   <li>type <tt>m</tt> is the underlying monad on which this transformer
--   operates.</li>
--   <li>type <tt>a</tt> is the result of the computation</li>
--   </ul>
newtype CircularT k v m a
CircularT :: StateT (HashMap k v) m a -> CircularT k v m a

-- | Runs a computation in <a>CircularT</a>.
runCircularT :: (Eq k, Hashable k, MonadFix m) => CircularT k v m a -> m a

-- | Cache a computation under a given key.
--   
--   For a given key <tt>k</tt>, and a computation in <a>CircularT</a> that
--   yields a value of type <tt>v</tt>, return an action that builds said
--   value <tt>v</tt> but that prevents cycles by looking into and
--   populating a stateful cache.
withCircular :: (Eq k, Hashable k, MonadFix m) => k -> CircularT k v m v -> CircularT k v m v
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Circular.CircularT k v m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Circular.CircularT k v m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Circular.CircularT k v m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Circular.CircularT k v m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Circular.CircularT k v m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Circular.CircularT k v m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Circular.CircularT k v)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Circular.CircularT k v m)

module Control.Monad.Memoize
class Monad m => MonadMemoize m

-- | Memoizes a parser constructor function for the extent of a single
--   schema construction process. This is mostly useful for recursive
--   parsers; see Note [Tying the knot] for more details.
--   
--   The generality of the type here allows us to use this with multiple
--   concrete parser types:
--   
--   <pre>
--   <a>memoizeOn</a> :: (<a>MonadMemoize</a> m, MonadParse n) =&gt; <a>Name</a> -&gt; a -&gt; m (Parser n b) -&gt; m (Parser n b)
--   <a>memoizeOn</a> :: (<a>MonadMemoize</a> m, MonadParse n) =&gt; <a>Name</a> -&gt; a -&gt; m (FieldParser n b) -&gt; m (FieldParser n b)
--   </pre>
memoizeOn :: forall a p. (MonadMemoize m, Ord a, Typeable a, Typeable p) => Name -> a -> m p -> m p

-- | A wrapper around <a>memoizeOn</a> that memoizes a function by using
--   its argument as the key.
memoize :: (MonadMemoize m, Ord a, Typeable a, Typeable p) => Name -> (a -> m p) -> a -> m p
newtype MemoizeT m a
MemoizeT :: StateT (DMap MemoizationKey Identity) m a -> MemoizeT m a
[unMemoizeT] :: MemoizeT m a -> StateT (DMap MemoizationKey Identity) m a
runMemoizeT :: forall m a. Monad m => MemoizeT m a -> m a

-- | A key used to distinguish calls to <a>memoize</a>d functions. The
--   <a>Name</a> distinguishes calls to completely different parsers, and
--   the <tt>a</tt> value records the arguments.
data MemoizationKey (t :: Type)
[MemoizationKey] :: (Ord a, Typeable a, Typeable p) => Name -> a -> MemoizationKey p
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Memoize.MemoizeT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Memoize.MemoizeT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Memoize.MemoizeT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Memoize.MemoizeT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Memoize.MemoizeT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.Memoize.MonadMemoize (Control.Monad.Memoize.MemoizeT m)
instance Data.GADT.Internal.GEq Control.Monad.Memoize.MemoizationKey
instance Data.GADT.Internal.GCompare Control.Monad.Memoize.MemoizationKey
instance Control.Monad.Memoize.MonadMemoize m => Control.Monad.Memoize.MonadMemoize (Control.Monad.Trans.Reader.ReaderT a m)

module Control.Monad.Stateless
class (MonadBaseControl b m, forall a. StatelessProof m a) => MonadStateless b m | m -> b
liftWithStateless :: MonadStateless b m => ((forall a. m a -> b a) -> b c) -> m c
class (StM m a ~ a) => StatelessProof m a
statelessProof :: StatelessProof m a => StM m a :~: a
instance (Control.Monad.Trans.Control.MonadBaseControl b m, forall a. Control.Monad.Stateless.StatelessProof m a) => Control.Monad.Stateless.MonadStateless b m
instance (Control.Monad.Trans.Control.StM m a GHC.Types.~ a) => Control.Monad.Stateless.StatelessProof m a

module Control.Monad.Trans.Managed

-- | This type is like a transformer version of the <tt>Managed</tt> monad
--   from the <tt>managed</tt> library. It can be used to manage resources
--   by pairing together their allocation with their finalizers.
--   
--   The documentation for the <tt>managed</tt> library is an excellent
--   introduction to the idea here.
--   
--   We could use <a>Codensity</a> directly, but we'd have to define an
--   orphan instance for <a>MonadFix</a>. This also gives us the
--   opportunity to give it a slightly more friendly name.
--   
--   We could also have used <tt>ResourceT</tt>, but that would have
--   involved writing instances for <tt>MonadUnliftIO</tt>. That could
--   still be a good option to consider later, however.
newtype ManagedT m a
ManagedT :: (forall r. (a -> m r) -> m r) -> ManagedT m a
[runManagedT] :: ManagedT m a -> forall r. (a -> m r) -> m r

-- | Allocate a resource by providing setup and finalizer actions.
allocate :: MonadBaseControl IO m => m a -> (a -> m b) -> ManagedT m a

-- | Allocate a resource but do not return a reference to it.
allocate_ :: MonadBaseControl IO m => m a -> m b -> ManagedT m ()

-- | Run the provided computation by returning its result, and run any
--   finalizers. Watch out: this function might leak finalized resources.
lowerManagedT :: Monad m => ManagedT m a -> m a
hoistManagedTReaderT :: Monad m => r -> ManagedT (ReaderT r m) a -> ManagedT m a
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.Managed.ManagedT
instance Control.Monad.Reader.Class.MonadReader s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Managed.ManagedT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Managed.ManagedT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Managed.ManagedT m)
instance GHC.Base.Monad (Control.Monad.Trans.Managed.ManagedT m)
instance GHC.Base.Applicative (Control.Monad.Trans.Managed.ManagedT m)
instance GHC.Base.Functor (Control.Monad.Trans.Managed.ManagedT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Managed.ManagedT m)

module Data.HashMap.Strict.Extended
fromListOn :: (Eq k, Hashable k) => (v -> k) -> [v] -> HashMap k v

-- | Given a <a>Foldable</a> sequence of values and a function that
--   extracts a key from each value, returns a <a>HashMap</a> that maps
--   each key to a list of all values in the sequence for which the given
--   function produced it.
--   
--   <pre>
--   &gt;&gt;&gt; groupOn (take 1) ["foo", "bar", "baz"]
--   fromList [("f", ["foo"]), ("b", ["bar", "baz"])]
--   </pre>
groupOn :: (Eq k, Hashable k, Foldable t) => (v -> k) -> t v -> HashMap k [v]
groupOnNE :: (Eq k, Hashable k, Foldable t) => (v -> k) -> t v -> HashMap k (NonEmpty v)
differenceOn :: (Eq k, Hashable k, Foldable t) => (v -> k) -> t v -> t v -> HashMap k v

-- | Monadic version of
--   <a>https://hackage.haskell.org/package/unordered-containers-0.2.18.0/docs/Data-HashMap-Internal.html#v:insertWith</a>
insertWithM :: (Monad m, Hashable k, Eq k) => (v -> v -> m v) -> k -> v -> HashMap k v -> m (HashMap k v)

-- | Determines whether the left-hand-side and the right-hand-side are
--   inverses of each other.
--   
--   More specifically, for two maps <tt>A</tt> and <tt>B</tt>,
--   <a>isInverseOf</a> is satisfied when both of the following are true:
--   1. <tt>∀ key ∈ A. A[key] ∈ B ∧ B[A[key]] == key</tt> 2. <tt>∀ key ∈ B.
--   B[key] ∈ A ∧ A[B[key]] == key</tt>
isInverseOf :: (Eq k, Hashable k, Eq v, Hashable v) => HashMap k v -> HashMap v k -> Bool

-- | The union of two maps.
--   
--   If a key occurs in both maps, the provided function (first argument)
--   will be used to compute the result. Unlike <a>unionWith</a>,
--   <a>unionWithM</a> performs the computation in an arbitratry monad.
unionWithM :: (Monad m, Eq k, Hashable k) => (k -> v -> v -> m v) -> HashMap k v -> HashMap k v -> m (HashMap k v)

-- | Like <a>unions</a>, but keeping all elements in the result.
unionsAll :: (Eq k, Hashable k, Foldable t) => t (HashMap k v) -> HashMap k (NonEmpty v)

-- | Homogenise maps, such that all maps range over the full set of keys,
--   inserting a default value as needed.
homogenise :: (Hashable a, Eq a) => b -> [HashMap a b] -> (HashSet a, [HashMap a b])

module Data.HashMap.Strict.InsOrd.Extended
catMaybes :: InsOrdHashMap k (Maybe v) -> InsOrdHashMap k v
partition :: (Eq k, Hashable k) => (v -> Bool) -> InsOrdHashMap k v -> (InsOrdHashMap k v, InsOrdHashMap k v)

-- | Alter a hashmap using a function that can fail, in which case the
--   entire operation fails. (Maybe a version with the key also being
--   passed to the function could be useful.)
alterF :: (Functor f, Eq k, Hashable k) => (Maybe v -> f (Maybe v)) -> k -> InsOrdHashMap k v -> f (InsOrdHashMap k v)


-- | HashMap to multiple values.
module Data.HashMap.Strict.Multi

-- | Map from keys to sets of values
newtype MultiMap k v
MultiMap :: HashMap k (Set v) -> MultiMap k v
[unMultiMap] :: MultiMap k v -> HashMap k (Set v)

-- | Construct a <tt>MmultiMap</tt> with a single key, to which only one
--   value is associated.
singleton :: Hashable k => k -> v -> MultiMap k v

-- | Construct a <a>MultiMap</a> with the supplied mappings.
fromMap :: HashMap k (Set v) -> MultiMap k v

-- | Convert a <a>MultiMap</a> to a <tt>HashMap</tt>.
toMap :: MultiMap k v -> HashMap k (Set v)

-- | Creates a <a>MultiMap</a> from an association list.
--   
--   If the provided list constains duplicate mappings, the resulting
--   <a>MultiMap</a> will store the set of all mapped values for each
--   duplicate key.
fromList :: (Eq k, Hashable k, Ord v) => [(k, v)] -> MultiMap k v

-- | Creates an association list from a <a>MultiMap</a>.
--   
--   Each set of values associated with a given key is transformed back
--   into a list.
toList :: MultiMap k v -> [(k, [v])]

-- | Return the value to which the specified key is mapped, or
--   <a>Nothing</a> if this map contains no mapping for the key.
lookup :: (Eq k, Hashable k) => k -> MultiMap k v -> Set v

-- | Associate the specified value with the specified key in this map.
--   
--   If this map previously contained a mapping for the key, the new value
--   is inserted in the set, and does not replace the previous mapping.
insert :: (Eq k, Hashable k, Ord v) => k -> v -> MultiMap k v -> MultiMap k v

-- | Returns a list of this map's keys.
keys :: MultiMap k v -> [k]

-- | Returns a list of this map's set of values.
elems :: MultiMap k v -> [Set v]
instance (Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSONKey k) => Data.Aeson.Types.ToJSON.ToJSON (Data.HashMap.Strict.Multi.MultiMap k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Data.HashMap.Strict.Multi.MultiMap k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.HashMap.Strict.Multi.MultiMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, GHC.Classes.Ord v) => GHC.Base.Semigroup (Data.HashMap.Strict.Multi.MultiMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, GHC.Classes.Ord v) => GHC.Base.Monoid (Data.HashMap.Strict.Multi.MultiMap k v)


-- | Non-empty hash maps.
module Data.HashMap.Strict.NonEmpty

-- | A non-empty hashmap is a wrapper around a normal hashmap, that only
--   provides a restricted set of functionalities. It doesn't provide a
--   <a>Monoid</a> instance, nor an <tt>empty</tt> function.
newtype NEHashMap k v
NEHashMap :: HashMap k v -> NEHashMap k v
[unNEHashMap] :: NEHashMap k v -> HashMap k v

-- | Construct a non-empty map with a single element.
singleton :: Hashable k => k -> v -> NEHashMap k v

-- | Construct a non-empty map with the supplied mappings. Returns
--   <a>Nothing</a> if the provided <a>HashMap</a> is empty.
fromHashMap :: HashMap k v -> Maybe (NEHashMap k v)

-- | Construct a non-empty map with the supplied mappings as follows:
--   
--   <ul>
--   <li>if the provided list contains duplicate mappings, the later
--   mappings take precedence;</li>
--   <li>if the provided list is empty, returns <a>Nothing</a>.</li>
--   </ul>
fromList :: (Eq k, Hashable k) => [(k, v)] -> Maybe (NEHashMap k v)

-- | A variant of <a>fromList</a> that uses <a>NonEmpty</a> inputs.
fromNonEmpty :: (Eq k, Hashable k) => NonEmpty (k, v) -> NEHashMap k v

-- | Convert a non-empty map to a <a>HashMap</a>.
toHashMap :: NEHashMap k v -> HashMap k v

-- | Convert a non-empty map to a non-empty list of key/value pairs. The
--   closed operations of <a>NEHashMap</a> guarantee that this operation
--   won't fail.
toNonEmpty :: NEHashMap k v -> NonEmpty (k, v)

-- | Convert a non-empty map to a list of key/value pairs.
toList :: NEHashMap k v -> [(k, v)]

-- | Return the value to which the specified key is mapped, or
--   <a>Nothing</a> if this map contains no mapping for the key.
lookup :: (Eq k, Hashable k) => k -> NEHashMap k v -> Maybe v

-- | Return the value to which the specified key is mapped, or
--   <a>Nothing</a> if this map contains no mapping for the key.
--   
--   This is a flipped version of <a>lookup</a>.
(!?) :: (Eq k, Hashable k) => NEHashMap k v -> k -> Maybe v

-- | Return a list of this map's keys.
keys :: NEHashMap k v -> [k]

-- | The union of two maps.
--   
--   If a key occurs in both maps, the left map <tt>m1</tt> (first
--   argument) will be preferred.
union :: (Eq k, Hashable k) => NEHashMap k v -> NEHashMap k v -> NEHashMap k v

-- | The union of two maps using a given value-wise union function.
--   
--   If a key occurs in both maps, the provided function (first argument)
--   will be used to compute the result.
unionWith :: (Eq k, Hashable k) => (v -> v -> v) -> NEHashMap k v -> NEHashMap k v -> NEHashMap k v

-- | <tt><a>mapKeys</a> f s</tt> is the map obtained by applying <tt>f</tt>
--   to each key of <tt>s</tt>.
--   
--   The size of the result may be smaller if f maps two or more distinct
--   keys to the same new key. In this case there is no guarantee which of
--   the associated values is chosen for the conflicting key.
mapKeys :: (Eq k2, Hashable k2) => (k1 -> k2) -> NEHashMap k1 v -> NEHashMap k2 v

-- | Determines whether the left-hand-side and the right-hand-side are
--   inverses of each other.
--   
--   More specifically, for two maps <tt>A</tt> and <tt>B</tt>,
--   <a>isInverseOf</a> is satisfied when both of the following are true:
--   1. <tt>∀ key ∈ A. A[key] ∈ B ∧ B[A[key]] == key</tt> 2. <tt>∀ key ∈ B.
--   B[key] ∈ A ∧ A[B[key]] == key</tt>
isInverseOf :: (Eq k, Hashable k, Eq v, Hashable v) => NEHashMap k v -> NEHashMap v k -> Bool
instance Data.Traversable.Traversable (Data.HashMap.Strict.NonEmpty.NEHashMap k)
instance Data.Foldable.Foldable (Data.HashMap.Strict.NonEmpty.NEHashMap k)
instance GHC.Base.Functor (Data.HashMap.Strict.NonEmpty.NEHashMap k)
instance (Data.Aeson.Types.ToJSON.ToJSON v, Data.Aeson.Types.ToJSON.ToJSONKey k) => Data.Aeson.Types.ToJSON.ToJSON (Data.HashMap.Strict.NonEmpty.NEHashMap k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => GHC.Base.Semigroup (Data.HashMap.Strict.NonEmpty.NEHashMap k v)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (Data.HashMap.Strict.NonEmpty.NEHashMap k v)
instance (Control.DeepSeq.NFData k, Control.DeepSeq.NFData v) => Control.DeepSeq.NFData (Data.HashMap.Strict.NonEmpty.NEHashMap k v)
instance (Data.Hashable.Class.Hashable k, Data.Hashable.Class.Hashable v) => Data.Hashable.Class.Hashable (Data.HashMap.Strict.NonEmpty.NEHashMap k v)
instance (Data.Aeson.Types.FromJSON.FromJSON v, Data.Aeson.Types.FromJSON.FromJSONKey k, GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Aeson.Types.FromJSON.FromJSON (Data.HashMap.Strict.NonEmpty.NEHashMap k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.HashMap.Strict.NonEmpty.NEHashMap k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Data.HashMap.Strict.NonEmpty.NEHashMap k v)

module Data.List.Extended
duplicates :: (Eq a, Hashable a) => [a] -> HashSet a
uniques :: Ord a => [a] -> [a]
getDifference :: (Eq a, Hashable a) => [a] -> [a] -> HashSet a
getDifferenceOn :: (Eq k, Hashable k) => (v -> k) -> [v] -> [v] -> [v]
getOverlapWith :: (Eq k, Hashable k) => (v -> k) -> [v] -> [v] -> [(v, v)]

-- | Returns the longest prefix common to all given lists. Returns an empty
--   list on an empty list.
--   
--   <pre>
--   &gt;&gt;&gt; longestCommonPrefix ["abcd", "abce", "abgh"]
--   "ab"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; longestCommonPrefix []
--   []
--   </pre>
longestCommonPrefix :: Eq a => [[a]] -> [a]
appendToNonEmpty :: NonEmpty a -> [a] -> NonEmpty a

module Data.SerializableBlob

-- | A JSON-serializable type for either text or raw binary data, encoded
--   with base-64.
data SerializableBlob
SerializableText :: Text -> SerializableBlob
SerializableBytes :: ByteString -> SerializableBlob
fromText :: Text -> SerializableBlob
fromBS :: ByteString -> SerializableBlob
fromLBS :: ByteString -> SerializableBlob
toBS :: SerializableBlob -> ByteString
toLBS :: SerializableBlob -> ByteString
instance GHC.Show.Show Data.SerializableBlob.SerializableBlob
instance Data.Aeson.Types.ToJSON.ToJSON Data.SerializableBlob.SerializableBlob
instance Data.String.IsString Data.SerializableBlob.SerializableBlob


-- | Types for time intervals of various units. Each newtype wraps
--   <a>DiffTime</a>, but they have different <a>Num</a> instances. The
--   intent is to use the record selectors to write literals with
--   particular units, like this:
--   
--   <pre>
--   &gt;&gt;&gt; <a>milliseconds</a> 500
--   0.5s
--   &gt;&gt;&gt; <a>hours</a> 3
--   10800s
--   &gt;&gt;&gt; <a>minutes</a> 1.5 + <a>seconds</a> 30
--   120s
--   </pre>
--   
--   You can also go the other way using the constructors rather than the
--   selectors:
--   
--   <pre>
--   &gt;&gt;&gt; <a>toRational</a> <a>$</a> <a>Minutes</a> (<a>seconds</a> 17)
--   17 % 60
--   &gt;&gt;&gt; <a>realToFrac</a> (<a>Days</a> (<a>hours</a> 12)) :: <a>Double</a>
--   0.5
--   </pre>
--   
--   NOTE: the <a>Real</a> and <a>Fractional</a> instances just essentially
--   add or strip the unit label (as above), so you can't use
--   <a>realToFrac</a> to convert between the units types here. Instead try
--   <a>convertDuration</a> which is less of a foot-gun.
--   
--   The <a>Read</a> instances for these types mirror the behavior of the
--   <a>RealFrac</a> instance wrt numeric literals for convenient
--   serialization (e.g. when working with env vars):
--   
--   <pre>
--   &gt;&gt;&gt; read "1.2" :: Milliseconds
--   Milliseconds {milliseconds = 0.0012s}
--   </pre>
--   
--   Generally, if you need to pass around a duration between functions you
--   should use <a>DiffTime</a> directly. However if storing a duration in
--   a type that will be serialized, e.g. one having a <a>ToJSON</a>
--   instance, it is better to use one of these explicit wrapper types so
--   that it's obvious what units will be used.
module Data.Time.Clock.Units
newtype Seconds
Seconds :: DiffTime -> Seconds
[seconds] :: Seconds -> DiffTime
newtype Days
Days :: DiffTime -> Days
[days] :: Days -> DiffTime
newtype Hours
Hours :: DiffTime -> Hours
[hours] :: Hours -> DiffTime
newtype Minutes
Minutes :: DiffTime -> Minutes
[minutes] :: Minutes -> DiffTime
newtype Milliseconds
Milliseconds :: DiffTime -> Milliseconds
[milliseconds] :: Milliseconds -> DiffTime
newtype Microseconds
Microseconds :: DiffTime -> Microseconds
[microseconds] :: Microseconds -> DiffTime
newtype Nanoseconds
Nanoseconds :: DiffTime -> Nanoseconds
[nanoseconds] :: Nanoseconds -> DiffTime
newtype TimeUnit (picosPerUnit :: Nat)
TimeUnit :: DiffTime -> TimeUnit (picosPerUnit :: Nat)
type SecondsP n = n * 1000000000000
natNum :: forall n a. (KnownNat n, Num a) => a

-- | Duration types isomorphic to <a>DiffTime</a>, powering
--   <a>convertDuration</a>.
class Duration d
fromDiffTime :: Duration d => DiffTime -> d
toDiffTime :: Duration d => d -> DiffTime

-- | Safe conversion between duration units.
convertDuration :: (Duration x, Duration y) => x -> y
diffTimeToMicroSeconds :: DiffTime -> Integer
instance GHC.Classes.Ord (Data.Time.Clock.Units.TimeUnit picosPerUnit)
instance GHC.Classes.Eq (Data.Time.Clock.Units.TimeUnit picosPerUnit)
instance GHC.Show.Show (Data.Time.Clock.Units.TimeUnit picosPerUnit)
instance GHC.Real.RealFrac Data.Time.Clock.Units.Nanoseconds
instance Data.Hashable.Class.Hashable Data.Time.Clock.Units.Nanoseconds
instance GHC.Real.Real Data.Time.Clock.Units.Nanoseconds
instance GHC.Real.Fractional Data.Time.Clock.Units.Nanoseconds
instance GHC.Num.Num Data.Time.Clock.Units.Nanoseconds
instance GHC.Read.Read Data.Time.Clock.Units.Nanoseconds
instance GHC.Classes.Ord Data.Time.Clock.Units.Nanoseconds
instance GHC.Classes.Eq Data.Time.Clock.Units.Nanoseconds
instance GHC.Show.Show Data.Time.Clock.Units.Nanoseconds
instance Data.Time.Clock.Units.Duration Data.Time.Clock.Units.Nanoseconds
instance GHC.Real.RealFrac Data.Time.Clock.Units.Microseconds
instance Data.Hashable.Class.Hashable Data.Time.Clock.Units.Microseconds
instance GHC.Real.Real Data.Time.Clock.Units.Microseconds
instance GHC.Real.Fractional Data.Time.Clock.Units.Microseconds
instance GHC.Num.Num Data.Time.Clock.Units.Microseconds
instance GHC.Read.Read Data.Time.Clock.Units.Microseconds
instance GHC.Classes.Ord Data.Time.Clock.Units.Microseconds
instance GHC.Classes.Eq Data.Time.Clock.Units.Microseconds
instance GHC.Show.Show Data.Time.Clock.Units.Microseconds
instance Data.Time.Clock.Units.Duration Data.Time.Clock.Units.Microseconds
instance GHC.Real.RealFrac Data.Time.Clock.Units.Milliseconds
instance Data.Hashable.Class.Hashable Data.Time.Clock.Units.Milliseconds
instance GHC.Real.Real Data.Time.Clock.Units.Milliseconds
instance GHC.Real.Fractional Data.Time.Clock.Units.Milliseconds
instance GHC.Num.Num Data.Time.Clock.Units.Milliseconds
instance GHC.Read.Read Data.Time.Clock.Units.Milliseconds
instance GHC.Classes.Ord Data.Time.Clock.Units.Milliseconds
instance GHC.Classes.Eq Data.Time.Clock.Units.Milliseconds
instance GHC.Show.Show Data.Time.Clock.Units.Milliseconds
instance Data.Time.Clock.Units.Duration Data.Time.Clock.Units.Milliseconds
instance GHC.Real.RealFrac Data.Time.Clock.Units.Minutes
instance Data.Hashable.Class.Hashable Data.Time.Clock.Units.Minutes
instance GHC.Real.Real Data.Time.Clock.Units.Minutes
instance GHC.Real.Fractional Data.Time.Clock.Units.Minutes
instance GHC.Num.Num Data.Time.Clock.Units.Minutes
instance GHC.Read.Read Data.Time.Clock.Units.Minutes
instance GHC.Classes.Ord Data.Time.Clock.Units.Minutes
instance GHC.Classes.Eq Data.Time.Clock.Units.Minutes
instance GHC.Show.Show Data.Time.Clock.Units.Minutes
instance Data.Time.Clock.Units.Duration Data.Time.Clock.Units.Minutes
instance GHC.Real.RealFrac Data.Time.Clock.Units.Hours
instance Data.Hashable.Class.Hashable Data.Time.Clock.Units.Hours
instance GHC.Real.Real Data.Time.Clock.Units.Hours
instance GHC.Real.Fractional Data.Time.Clock.Units.Hours
instance GHC.Num.Num Data.Time.Clock.Units.Hours
instance GHC.Read.Read Data.Time.Clock.Units.Hours
instance GHC.Classes.Ord Data.Time.Clock.Units.Hours
instance GHC.Classes.Eq Data.Time.Clock.Units.Hours
instance GHC.Show.Show Data.Time.Clock.Units.Hours
instance Data.Time.Clock.Units.Duration Data.Time.Clock.Units.Hours
instance GHC.Real.RealFrac Data.Time.Clock.Units.Days
instance Data.Hashable.Class.Hashable Data.Time.Clock.Units.Days
instance GHC.Real.Real Data.Time.Clock.Units.Days
instance GHC.Real.Fractional Data.Time.Clock.Units.Days
instance GHC.Num.Num Data.Time.Clock.Units.Days
instance GHC.Read.Read Data.Time.Clock.Units.Days
instance GHC.Classes.Ord Data.Time.Clock.Units.Days
instance GHC.Classes.Eq Data.Time.Clock.Units.Days
instance GHC.Show.Show Data.Time.Clock.Units.Days
instance Data.Time.Clock.Units.Duration Data.Time.Clock.Units.Days
instance GHC.Real.RealFrac Data.Time.Clock.Units.Seconds
instance Data.Hashable.Class.Hashable Data.Time.Clock.Units.Seconds
instance GHC.Real.Real Data.Time.Clock.Units.Seconds
instance GHC.Real.Fractional Data.Time.Clock.Units.Seconds
instance GHC.Num.Num Data.Time.Clock.Units.Seconds
instance GHC.Read.Read Data.Time.Clock.Units.Seconds
instance Data.Aeson.Types.FromJSON.FromJSON Data.Time.Clock.Units.Seconds
instance Data.Aeson.Types.ToJSON.ToJSON Data.Time.Clock.Units.Seconds
instance GHC.Classes.Ord Data.Time.Clock.Units.Seconds
instance GHC.Classes.Eq Data.Time.Clock.Units.Seconds
instance GHC.Show.Show Data.Time.Clock.Units.Seconds
instance Data.Time.Clock.Units.Duration Data.Time.Clock.Units.Seconds
instance Data.Aeson.Types.ToJSON.ToJSON Data.Time.Clock.Units.Milliseconds
instance Data.Aeson.Types.FromJSON.FromJSON Data.Time.Clock.Units.Milliseconds
instance Data.Time.Clock.Units.Duration Data.Time.Clock.Internal.DiffTime.DiffTime
instance Data.Time.Clock.Units.Duration Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance GHC.TypeNats.KnownNat picosPerUnit => GHC.Num.Num (Data.Time.Clock.Units.TimeUnit picosPerUnit)
instance GHC.TypeNats.KnownNat picosPerUnit => GHC.Read.Read (Data.Time.Clock.Units.TimeUnit picosPerUnit)
instance GHC.TypeNats.KnownNat picosPerUnit => GHC.Real.Fractional (Data.Time.Clock.Units.TimeUnit picosPerUnit)
instance GHC.TypeNats.KnownNat picosPerUnit => GHC.Real.Real (Data.Time.Clock.Units.TimeUnit picosPerUnit)
instance GHC.TypeNats.KnownNat picosPerUnit => GHC.Real.RealFrac (Data.Time.Clock.Units.TimeUnit picosPerUnit)
instance Data.Hashable.Class.Hashable (Data.Time.Clock.Units.TimeUnit a)


-- | Prefix trees on arbitrary keys.
module Data.Trie

-- | Data structure for storing a value <tt>v</tt> keyed on a sequence of
--   <tt>k</tt>s
data Trie k v
Trie :: HashMap k (Trie k v) -> Maybe v -> Trie k v
[trieMap] :: Trie k v -> HashMap k (Trie k v)
[trieData] :: Trie k v -> Maybe v

-- | Construct an empty trie.
empty :: Trie k v

-- | Creates a trie from a path and a value
--   
--   <pre>
--   &gt;&gt;&gt; singleton ["a", "b"] 5
--   Trie (fromList [("a", Trie (fromList [("b", Trie (fromList []) (Just 5))]) Nothing)]) Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; singleton [] 5
--   Trie (fromList []) (Just 5)
--   </pre>
singleton :: Hashable k => [k] -> v -> Trie k v

-- | Find a value at the given path, if any.
lookup :: (Eq k, Hashable k) => [k] -> Trie k v -> Maybe v

-- | Insert the given value at the given path.
--   
--   If there's already a value at the given path, it is replaced.
insert :: (Eq k, Hashable k) => [k] -> v -> Trie k v -> Trie k v

-- | Insert the value at the given path.
--   
--   If there's already a value at the given path, the old value is
--   replaced by the result of applying the given function to the new and
--   old value.
insertWith :: (Eq k, Hashable k) => (v -> v -> v) -> [k] -> v -> Trie k v -> Trie k v

-- | Extract all values of the trie, discarding any path information.
elems :: Trie k v -> [v]
instance GHC.Generics.Generic (Data.Trie.Trie k v)
instance (GHC.Classes.Ord k, GHC.Classes.Ord v) => GHC.Classes.Ord (Data.Trie.Trie k v)
instance (GHC.Show.Show k, GHC.Show.Show v) => GHC.Show.Show (Data.Trie.Trie k v)
instance (GHC.Classes.Eq k, GHC.Classes.Eq v) => GHC.Classes.Eq (Data.Trie.Trie k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, GHC.Base.Semigroup v) => GHC.Base.Semigroup (Data.Trie.Trie k v)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k, GHC.Base.Semigroup v) => GHC.Base.Monoid (Data.Trie.Trie k v)
instance (Data.Aeson.Types.ToJSON.ToJSONKey a, Data.Aeson.Types.ToJSON.ToJSON v) => Data.Aeson.Types.ToJSON.ToJSON (Data.Trie.Trie a v)

module GHC.Generics.Extended

-- | Return the constructor name of some data with a Generic instance, as a
--   string. Useful when constructing error or trace messages, or
--   debugging.
constrName :: (HasConstructor (Rep a), Generic a) => a -> String
class HasConstructor (f :: Type -> Type)
genericConstrName :: HasConstructor f => f x -> String
instance GHC.Generics.Extended.HasConstructor f => GHC.Generics.Extended.HasConstructor (GHC.Generics.D1 c f)
instance (GHC.Generics.Extended.HasConstructor x, GHC.Generics.Extended.HasConstructor y) => GHC.Generics.Extended.HasConstructor (x GHC.Generics.:+: y)
instance GHC.Generics.Constructor c => GHC.Generics.Extended.HasConstructor (GHC.Generics.C1 c f)


-- | A convenience wrapper around <a>GHC.Stats</a>, which makes RTS stats
--   available (when the program is run with +RTS -T)
module GHC.Stats.Extended
instance Data.Aeson.Types.ToJSON.ToJSON GHC.Stats.RTSStats
instance Data.Aeson.Types.ToJSON.ToJSON GHC.Stats.GCDetails

module Hasura.Backends.BigQuery.Name
_Bytes :: Name
_Date :: Name
_Datetime :: Name
_Geography :: Name
_Time :: Name
_Timestamp :: Name


-- | QuasiQuoted GraphQL constants used througout the codebase. By moving
--   all the Quasiquotes here we can eliminate extraneous rebuilds of
--   larger modules.
--   
--   See:
--   <a>https://www.parsonsmatt.org/2021/07/12/template_haskell_performance_tips.html#recompilation-avoidance</a>
module Hasura.Name
__ :: Name
_no_queries_available :: Name
__mutation_backend :: Name
__mutation_frontend :: Name
__query :: Name
__subscription :: Name
_preset :: Name
_static :: Name
_value :: Name
_Bool :: Name
_Double :: Name
_float8 :: Name
_Number :: Name
_numeric :: Name
_mutation_root :: Name
_query_root :: Name
_subscription_root :: Name
__enum :: Name
__scalar :: Name
_id :: Name
_session_variables :: Name
__remote_rel_ :: Name
__bool_exp :: Name
__comparison_exp :: Name
__BigQuery_comparison_exp :: Name
__MSSQL_comparison_exp :: Name
__MySQL_comparison_exp :: Name
__cast :: Name
__cast_exp :: Name
__is_null :: Name
__eq :: Name
__neq :: Name
__in :: Name
__nin :: Name
__gt :: Name
__gte :: Name
__lt :: Name
__lte :: Name
__contains :: Name
__matches :: Name
__ancestor :: Name
__descendant :: Name
__like :: Name
__ilike :: Name
__nlike :: Name
__nilike :: Name
__similar :: Name
__nsimilar :: Name
__regex :: Name
__nregex :: Name
__niregex :: Name
__iregex :: Name
__and :: Name
__not :: Name
__or :: Name
_aggregate :: Name
_column :: Name
_columns :: Name
_nodes :: Name
_avg :: Name
_count :: Name
_stddev :: Name
_stddev_pop :: Name
_stddev_samp :: Name
_sum :: Name
_var_pop :: Name
_var_samp :: Name
_variance :: Name
__aggregate :: Name
__aggregate_fields :: Name
__fields :: Name
_path :: Name
_args :: Name
__args :: Name
_distinct :: Name
_distinct_on :: Name
__select_column :: Name
_where :: Name
_order_by :: Name
_ASC :: Name
_asc :: Name
_asc_nulls_first :: Name
_asc_nulls_last :: Name
_DESC :: Name
_desc :: Name
_desc_nulls_first :: Name
_desc_nulls_last :: Name
_first :: Name
_last :: Name
_before :: Name
_after :: Name
__aggregate_order_by :: Name
__order_by :: Name
_limit :: Name
_offset :: Name
_distance :: Name
_from :: Name
_geommin :: Name
_nband :: Name
_st_d_within_geography_input :: Name
_st_d_within_input :: Name
_st_intersects_geom_nband_input :: Name
_st_intersects_nband_geom_input :: Name
_st_dwithin_input :: Name
_use_spheroid :: Name
__st_3d_d_within :: Name
__st_3d_intersects :: Name
__st_contains :: Name
__st_crosses :: Name
__st_d_within :: Name
__st_equals :: Name
__st_intersects_geom_nband :: Name
__st_intersects_nband_geom :: Name
__st_intersects_rast :: Name
__st_intersects :: Name
__st_overlaps :: Name
__st_touches :: Name
__st_within :: Name
_constraint :: Name
_if_matched :: Name
_match_columns :: Name
_on_conflict :: Name
_update_columns :: Name
__constraint :: Name
__if_matched :: Name
__on_conflict :: Name
__update_column :: Name
__PLACEHOLDER :: Name
_insert :: Name
_update :: Name
_updates :: Name
_delete :: Name
_affected_rows :: Name
_data :: Name
_object :: Name
_objects :: Name
_one :: Name
_many :: Name
_returning :: Name
_transaction :: Name
__append :: Name
__arr_rel_insert_input :: Name
__delete_at_path :: Name
__delete_elem :: Name
__delete_key :: Name
__insert_input :: Name
__insert_match_column :: Name
__mutation_response :: Name
__prepend :: Name
__obj_rel_insert_input :: Name
_created_at :: Name
_errors :: Name
_output :: Name
_Connection :: Name
_Edge :: Name
_PageInfo :: Name
_batch_size :: Name
_connection :: Name
_cursor :: Name
_cursor_ordering :: Name
_edges :: Name
_initial_value :: Name
_node :: Name
_ordering :: Name
_pageInfo :: Name
_stream :: Name
_startCursor :: Name
_endCursor :: Name
_hasNextPage :: Name
_hasPreviousPage :: Name
__connection :: Name
__stream_cursor_input :: Name
__stream_cursor_value_input :: Name
_Node :: Name
___hasura_internal_typename :: Name
__service :: Name
_key :: Name
_fields :: Name
_representations :: Name
__Any :: Name
_sdl :: Name
__Service :: Name
__Entity :: Name
__entities :: Name
_arguments :: Name
_predicate :: Name
_filter :: Name

module Hasura.Prelude
alphabet :: String
alphaNumerics :: String
onNothing :: Applicative m => Maybe a -> m a -> m a
onNothingM :: Monad m => m (Maybe a) -> m a -> m a
onJust :: Applicative m => Maybe a -> (a -> m ()) -> m ()
withJust :: Applicative m => Maybe a -> (a -> m (Maybe b)) -> m (Maybe b)

-- | Transform a <a>Maybe</a> into an <a>Either</a> given a default value.
--   
--   <pre>
--   maybeToEither def Nothing == Left def
--   maybeToEither _def (Just b) == Right b
--   </pre>
maybeToEither :: a -> Maybe b -> Either a b

-- | Convert an <a>Either</a> to a <a>Maybe</a>, forgetting the <a>Left</a>
--   values.
--   
--   <pre>
--   eitherToMaybe (Left a) == Nothing
--   eitherToMaybe (Right b) == Just b
--   </pre>
eitherToMaybe :: Either a b -> Maybe b
onLeft :: Applicative m => Either e a -> (e -> m a) -> m a
mapLeft :: (e1 -> e2) -> Either e1 a -> Either e2 a
whenMaybe :: Applicative m => Bool -> m a -> m (Maybe a)
choice :: Alternative f => [f a] -> f a
afold :: (Foldable t, Alternative f) => t a -> f a
bsToTxt :: ByteString -> Text
lbsToTxt :: ByteString -> Text
txtToBs :: Text -> ByteString
base64Decode :: Text -> ByteString
liftEitherM :: MonadError e m => m (Either e a) -> m a
spanMaybeM :: (Foldable f, Monad m) => (a -> m (Maybe b)) -> f a -> m ([b], [a])
findWithIndex :: (a -> Bool) -> [a] -> Maybe (a, Int)
mapFromL :: (Eq k, Hashable k) => (a -> k) -> [a] -> HashMap k a
oMapFromL :: (Eq k, Hashable k) => (a -> k) -> [a] -> InsOrdHashMap k a

-- | Time an IO action, returning the time with microsecond precision. The
--   result of the input action will be evaluated to WHNF.
--   
--   The result <a>DiffTime</a> is guarenteed to be &gt;= 0.
withElapsedTime :: MonadIO m => m a -> m (DiffTime, a)

-- | Start timing and return an action to return the elapsed time since
--   <a>startTimer</a> was called.
--   
--   <pre>
--   timer &lt;- startTimer
--   someStuffToTime
--   elapsed &lt;- timer
--   moreStuff
--   elapsedBoth &lt;- timer
--   </pre>
startTimer :: (MonadIO m, MonadIO n) => m (n DiffTime)

-- | Upgrade a <a>Maybe</a> to a <a>MaybeT</a>.
--   
--   cf.
--   <a>http://hackage.haskell.org/package/errors-2.3.0/docs/src/Control.Error.Util.html#hoistMaybe</a>
hoistMaybe :: Applicative m => Maybe b -> MaybeT m b

-- | Upgrade an <a>Either</a> to an <a>ExceptT</a>.
--   
--   cf.
--   <a>http://hackage.haskell.org/package/errors-2.3.0/docs/src/Control.Error.Util.html#hoistEither</a>
hoistEither :: Applicative m => Either e a -> ExceptT e m a
tshow :: Show a => a -> Text
readJson :: FromJSON a => String -> Either String a

-- | Customized <a>Options</a> which apply "snake case" to Generic or
--   Template Haskell JSON derivations.
--   
--   For example, a Haskell field <tt>fooBar</tt> would be de<i>serialized
--   from</i>to JSON as <tt>foo_bar</tt>.
hasuraJSON :: Options

-- | Labeled, prettified traceShowId

-- | <i>Warning: ltrace left in code</i>
ltrace :: Show a => String -> a -> a

-- | Labeled, prettified traceShowM

-- | <i>Warning: ltraceM left in code</i>
ltraceM :: Applicative m => Show a => String -> a -> m ()

-- | Trace a prettified value to a file

-- | <i>Warning: traceToFile left in code</i>
traceToFile :: Show a => FilePath -> a -> a

-- | Trace a prettified value to a file in an Applicative context

-- | <i>Warning: traceToFileM left in code</i>
traceToFileM :: Applicative m => Show a => FilePath -> a -> m ()

-- | Remove duplicates from a list. Like <tt>nub</tt> but runs in <tt>O(n *
--   log_16(n))</tt> time and requires <a>Hashable</a> and <a>Eq</a>
--   instances. hashNub is faster than ordNub when there're not so many
--   different values in the list.
--   
--   <pre>
--   &gt;&gt;&gt; hashNub [1,3,2,9,4,1,5,7,3,3,1,2,5,4,3,2,1,0]
--   [0,1,2,3,4,5,7,9]
--   </pre>
hashNub :: (Hashable a, Eq a) => [a] -> [a]

-- | Convert a non-empty sequence to a non-empty list.
nonEmptySeqToNonEmptyList :: NESeq a -> NonEmpty a


-- | Utility functions for use defining autodocodec codecs.
module Hasura.Metadata.DTO.Utils

-- | Defines a required object field named <tt>version</tt> that must have
--   the given integer value. On serialization the field will have the
--   given value automatically. On deserialization parsing will fail unless
--   the field has the exact given value.
versionField :: Integer -> ObjectCodec a Scientific

-- | Defines an optional object field named <tt>version</tt> that must have
--   the given integer value if the field is present. On serialization the
--   field will have the given value automatically. On deserialization
--   parsing will fail unless the field has the exact given value, or is
--   absent.
optionalVersionField :: Integer -> ObjectCodec a (Maybe Scientific)


-- | We are in the process of building DTO types incrementally. We use
--   placeholder types in positions in data structures that are not
--   fully-defined yet. For example <a>PlaceholderObject</a> represents
--   some unspecified JSON object, and <a>PlaceholderArray</a> represents
--   an array whose contents are not yet specified.
--   
--   We are transitioning from converting <a>Metadata</a> directly to JSON
--   to converting it to <a>MetadataDTO</a> instead. Serialization and
--   deserialization for placeholder values is delegated to the old JSON
--   serialization code.
module Hasura.Metadata.DTO.Placeholder

-- | Stands in for an array that we have not had time to fully specify yet.
--   Generated OpenAPI documentation for <a>PlaceholderArray</a> will
--   permit an array of values of any type, and a note will be appended to
--   the documentation string for the value explaining that this is a
--   temporary placeholder.
newtype PlaceholderArray
PlaceholderArray :: Array -> PlaceholderArray

-- | Stands in for an object that we have not had time to fully specify
--   yet. Generated OpenAPI documentation for <a>PlaceholderObject</a> will
--   permit an object with any keys with any types of values. A note will
--   be appended to the documentation string for the value explaining that
--   this is a temporary placeholder.
newtype PlaceholderObject
PlaceholderObject :: Object -> PlaceholderObject
class IsPlaceholder p a | a -> p

-- | Use this function to mark an Aeson type (Array or Object) as a
--   temporary placeholder in a larger data structure.
placeholder :: IsPlaceholder p a => a -> p
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance GHC.Generics.Generic Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance GHC.Classes.Eq Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance GHC.Show.Show Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance GHC.Generics.Generic Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance GHC.Classes.Eq Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance GHC.Show.Show Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderArray Data.Aeson.Types.Internal.Array
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderObject Data.Aeson.Types.Internal.Object
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderArray Data.Aeson.Ordered.Array
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderObject Data.Aeson.Ordered.Object
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.Placeholder.PlaceholderArray

module Hasura.Metadata.DTO.MetadataV3

-- | Revision 3 of the Metadata export format. Note that values of the
--   types, <a>PlaceholderArray</a> and <a>PlaceholderObject</a> are
--   placeholders that will eventually be expanded to represent more
--   detail.
data MetadataV3
MetadataV3 :: PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderObject -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderObject -> Maybe PlaceholderObject -> Maybe PlaceholderArray -> Maybe PlaceholderObject -> Maybe PlaceholderObject -> Maybe PlaceholderObject -> MetadataV3
[metaV3Sources] :: MetadataV3 -> PlaceholderArray
[metaV3RemoteSchemas] :: MetadataV3 -> Maybe PlaceholderArray
[metaV3QueryCollections] :: MetadataV3 -> Maybe PlaceholderArray
[metaV3Allowlist] :: MetadataV3 -> Maybe PlaceholderArray
[metaV3Actions] :: MetadataV3 -> Maybe PlaceholderArray
[metaV3CustomTypes] :: MetadataV3 -> Maybe PlaceholderObject
[metaV3CronTriggers] :: MetadataV3 -> Maybe PlaceholderArray
[metaV3RestEndpoints] :: MetadataV3 -> Maybe PlaceholderArray
[metaV3ApiLimits] :: MetadataV3 -> Maybe PlaceholderObject
[metaV3MetricsConfig] :: MetadataV3 -> Maybe PlaceholderObject
[metaV3InheritedRoles] :: MetadataV3 -> Maybe PlaceholderArray
[metaV3GraphqlSchemaIntrospection] :: MetadataV3 -> Maybe PlaceholderObject
[metaV3Network] :: MetadataV3 -> Maybe PlaceholderObject
[metaV3BackendConfigs] :: MetadataV3 -> Maybe PlaceholderObject
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance GHC.Generics.Generic Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance GHC.Classes.Eq Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance GHC.Show.Show Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.MetadataV3.MetadataV3

module Hasura.Metadata.DTO.MetadataV2

-- | Revision 2 of the Metadata export format. Note that values of the
--   types, <a>PlaceholderArray</a> and <a>PlaceholderObject</a> are
--   placeholders that will eventually be expanded to represent more
--   detail.
data MetadataV2
MetadataV2 :: Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderObject -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> PlaceholderArray -> MetadataV2
[metaV2Actions] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2Allowlist] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2CronTriggers] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2CustomTypes] :: MetadataV2 -> Maybe PlaceholderObject
[metaV2Functions] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2QueryCollections] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2RemoteSchemas] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2Tables] :: MetadataV2 -> PlaceholderArray
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance GHC.Generics.Generic Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance GHC.Classes.Eq Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance GHC.Show.Show Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.MetadataV2.MetadataV2

module Hasura.Metadata.DTO.MetadataV1

-- | Revision 1 of the Metadata export format. Note that values of the
--   types, <a>PlaceholderArray</a> and <tt>PlaceholderObject</tt> are
--   placeholders that will eventually be expanded to represent more
--   detail.
data MetadataV1
MetadataV1 :: Maybe PlaceholderArray -> Maybe PlaceholderArray -> PlaceholderArray -> MetadataV1
[metaV1Functions] :: MetadataV1 -> Maybe PlaceholderArray
[metaV1RemoteSchemas] :: MetadataV1 -> Maybe PlaceholderArray
[metaV1Tables] :: MetadataV1 -> PlaceholderArray
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance GHC.Generics.Generic Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance GHC.Classes.Eq Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance GHC.Show.Show Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.MetadataV1.MetadataV1

module Hasura.Metadata.DTO.Metadata

-- | Exported representation of the GraphQL Engine metadata configuration
--   format.
--   
--   The OpenAPI specification for metadata is experimental and incomplete.
--   Please do not incorporate it into essential workflows at this time.
data MetadataDTO
V1 :: MetadataV1 -> MetadataDTO
V2 :: MetadataV2 -> MetadataDTO
V3 :: MetadataV3 -> MetadataDTO
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.Metadata.MetadataDTO
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.Metadata.MetadataDTO
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.Metadata.MetadataDTO
instance GHC.Generics.Generic Hasura.Metadata.DTO.Metadata.MetadataDTO
instance GHC.Classes.Eq Hasura.Metadata.DTO.Metadata.MetadataDTO
instance GHC.Show.Show Hasura.Metadata.DTO.Metadata.MetadataDTO
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.Metadata.MetadataDTO

module Hasura.Logging
newtype FormattedTime
FormattedTime :: Text -> FormattedTime
[_unFormattedTime] :: FormattedTime -> Text

-- | Typeclass representing any type which can be parsed into a list of
--   enabled log types, and has a <tt>Set</tt> of default enabled log
--   types, and can find out if a log type is enabled
class (Eq (EngineLogType impl), Hashable (EngineLogType impl)) => EnabledLogTypes impl
parseEnabledLogTypes :: EnabledLogTypes impl => String -> Either String [EngineLogType impl]
defaultEnabledLogTypes :: EnabledLogTypes impl => HashSet (EngineLogType impl)
isLogTypeEnabled :: EnabledLogTypes impl => HashSet (EngineLogType impl) -> EngineLogType impl -> Bool

-- | A family of EngineLogType types
data family EngineLogType impl
data Hasura
data InternalLogTypes

-- | mostly for debug logs - see <tt>debugT</tt>, <tt>debugBS</tt> and
--   <tt>debugLBS</tt> functions
ILTUnstructured :: InternalLogTypes
ILTEventTrigger :: InternalLogTypes
ILTScheduledTrigger :: InternalLogTypes

-- | internal logs for the websocket server
ILTWsServer :: InternalLogTypes
ILTPgClient :: InternalLogTypes

-- | log type for logging metadata related actions; currently used in
--   logging inconsistent metadata
ILTMetadata :: InternalLogTypes
ILTJwkRefreshLog :: InternalLogTypes
ILTTelemetry :: InternalLogTypes
ILTSchemaSyncThread :: InternalLogTypes
ILTSourceCatalogMigration :: InternalLogTypes
defaultEnabledEngineLogTypes :: HashSet (EngineLogType Hasura)
isEngineLogTypeEnabled :: HashSet (EngineLogType Hasura) -> EngineLogType Hasura -> Bool
readLogTypes :: String -> Either String [EngineLogType Hasura]
userAllowedLogTypes :: [EngineLogType Hasura]
data LogLevel
LevelDebug :: LogLevel
LevelInfo :: LogLevel
LevelWarn :: LogLevel
LevelError :: LogLevel
LevelOther :: Text -> LogLevel
data EngineLog impl
EngineLog :: !FormattedTime -> !LogLevel -> !EngineLogType impl -> !Value -> EngineLog impl
[_elTimestamp] :: EngineLog impl -> !FormattedTime
[_elLevel] :: EngineLog impl -> !LogLevel
[_elType] :: EngineLog impl -> !EngineLogType impl
[_elDetail] :: EngineLog impl -> !Value

-- | Typeclass representing any data type that can be converted to
--   <tt>EngineLog</tt> for the purpose of logging
class EnabledLogTypes impl => ToEngineLog a impl
toEngineLog :: ToEngineLog a impl => a -> (LogLevel, EngineLogType impl, Value)
data UnstructuredLog
UnstructuredLog :: !LogLevel -> !SerializableBlob -> UnstructuredLog
[_ulLevel] :: UnstructuredLog -> !LogLevel
[_ulPayload] :: UnstructuredLog -> !SerializableBlob
debugT :: Text -> UnstructuredLog
debugBS :: ByteString -> UnstructuredLog
debugLBS :: ByteString -> UnstructuredLog
data LoggerCtx impl
LoggerCtx :: !LoggerSet -> !LogLevel -> !IO FormattedTime -> !HashSet (EngineLogType impl) -> LoggerCtx impl
[_lcLoggerSet] :: LoggerCtx impl -> !LoggerSet
[_lcLogLevel] :: LoggerCtx impl -> !LogLevel
[_lcTimeGetter] :: LoggerCtx impl -> !IO FormattedTime
[_lcEnabledLogTypes] :: LoggerCtx impl -> !HashSet (EngineLogType impl)
data LoggerSettings
LoggerSettings :: !Bool -> !Maybe TimeZone -> !LogLevel -> LoggerSettings

-- | should current time be cached (refreshed every sec)
[_lsCachedTimestamp] :: LoggerSettings -> !Bool
[_lsTimeZone] :: LoggerSettings -> !Maybe TimeZone
[_lsLevel] :: LoggerSettings -> !LogLevel
defaultLoggerSettings :: Bool -> LogLevel -> LoggerSettings
getFormattedTime :: Maybe TimeZone -> IO FormattedTime
mkLoggerCtx :: (MonadIO io, MonadBaseControl IO io) => LoggerSettings -> HashSet (EngineLogType impl) -> ManagedT io (LoggerCtx impl)
cleanLoggerCtx :: LoggerCtx a -> IO ()
newtype Logger impl
Logger :: (forall a m. (ToEngineLog a impl, MonadIO m) => a -> m ()) -> Logger impl
[unLogger] :: Logger impl -> forall a m. (ToEngineLog a impl, MonadIO m) => a -> m ()
mkLogger :: LoggerCtx Hasura -> Logger Hasura
nullLogger :: Logger Hasura
eventTriggerLogType :: EngineLogType Hasura
scheduledTriggerLogType :: EngineLogType Hasura
sourceCatalogMigrationLogType :: EngineLogType Hasura
instance GHC.Show.Show Hasura.Logging.UnstructuredLog
instance GHC.Classes.Eq Hasura.Logging.LoggerSettings
instance GHC.Show.Show Hasura.Logging.LoggerSettings
instance Hasura.Logging.ToEngineLog Hasura.Logging.UnstructuredLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Logging.EngineLogType impl) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Logging.EngineLog impl)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.FormattedTime
instance GHC.Classes.Eq Hasura.Logging.FormattedTime
instance GHC.Show.Show Hasura.Logging.FormattedTime
instance GHC.Generics.Generic Hasura.Logging.InternalLogTypes
instance GHC.Classes.Eq Hasura.Logging.InternalLogTypes
instance GHC.Show.Show Hasura.Logging.InternalLogTypes
instance GHC.Generics.Generic (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance GHC.Classes.Eq (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance GHC.Show.Show (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance GHC.Classes.Ord Hasura.Logging.LogLevel
instance GHC.Classes.Eq Hasura.Logging.LogLevel
instance GHC.Show.Show Hasura.Logging.LogLevel
instance GHC.Show.Show (Hasura.Logging.EngineLogType impl) => GHC.Show.Show (Hasura.Logging.EngineLog impl)
instance GHC.Classes.Eq (Hasura.Logging.EngineLogType impl) => GHC.Classes.Eq (Hasura.Logging.EngineLog impl)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.LogLevel
instance Data.Hashable.Class.Hashable Hasura.Logging.InternalLogTypes
instance Witch.From.From Hasura.Logging.InternalLogTypes Data.Text.Internal.Text
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.InternalLogTypes
instance Data.Hashable.Class.Hashable (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance Witch.From.From (Hasura.Logging.EngineLogType Hasura.Logging.Hasura) Data.Text.Internal.Text
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance Hasura.Logging.EnabledLogTypes Hasura.Logging.Hasura

module Control.Concurrent.Extended

-- | Like <a>threadDelay</a>, but takes a <a>DiffTime</a> instead of an
--   <a>Int</a> microseconds.
--   
--   NOTE: you cannot simply replace e.g. <tt>threadDelay 1000</tt> with
--   <tt>sleep 1000</tt> since those literals have different meanings!
sleep :: DiffTime -> IO ()

-- | Note: Please consider using <a>forkManagedT</a> instead to ensure
--   reliable resource cleanup.
forkImmortal :: ForkableMonadIO m => String -> Logger Hasura -> m Void -> m Thread
data ThreadState
ThreadForked :: ThreadState
ThreadBlocking :: ThreadState
ThreadShutdownInitiated :: ThreadState

-- | <tt>ThreadShutdown</tt> is a newtype wrapper over an action which is
--   intended to execute when a thread's shutdown is initiated before
--   killing the thread
newtype ThreadShutdown m
ThreadShutdown :: m () -> ThreadShutdown m
[tsThreadShutdown] :: ThreadShutdown m -> m ()

-- | This function pairs a call to <a>forkImmortal</a> with a finalizer
--   which stops the immortal thread.
forkManagedT :: ForkableMonadIO m => String -> Logger Hasura -> m Void -> ManagedT m Thread

-- | The <tt>Forever</tt> type defines an infinite looping monadic action
--   (like <tt>m void</tt>), but allows the caller to control the recursion
--   or insert code before each iteration. The <tt>a</tt> is the initial
--   argument, and subsequent iterations will be fed the argument returned
--   by the previous one. See <tt>forkManagedTWithGracefulShutdown</tt> to
--   see how it's used
data Forever m
Forever :: a -> (a -> m a) -> Forever m

-- | <tt>forkManagedTWithGracefulShutdown</tt> is an extension of the
--   <tt>forkManagedT</tt> function this function also attempts to
--   gracefully shutdown the thread. This function accepts a `m (Forever
--   m)` argument. The <tt>Forever</tt> type contains a function and an
--   argument to the function. The function supplied will be run repeatedly
--   until shutdown is initiated. The response of the function will be the
--   argument to the next iteration.
--   
--   For reference, this function is used to run the async actions
--   processor. Check <tt>asyncActionsProcessor</tt>
forkManagedTWithGracefulShutdown :: ForkableMonadIO m => String -> Logger Hasura -> ThreadShutdown m -> m (Forever m) -> ManagedT m Thread
data ImmortalThreadLog

-- | Synchronous Exception
ImmortalThreadUnexpectedException :: String -> SomeException -> ImmortalThreadLog

-- | Asynchronous Exception about to be sent
ImmortalThreadStopping :: String -> ImmortalThreadLog
ImmortalThreadRestarted :: String -> ImmortalThreadLog

-- | Like <a>MonadIO</a> but constrained to stacks in which forking a new
--   thread is reasonable/safe. In particular <tt>StateT</tt> causes
--   problems.
--   
--   This is the constraint you can use for functions that call
--   <a>async</a>, or <tt>immortal</tt>.
type ForkableMonadIO m = (MonadIO m, MonadBaseControl IO m, Forall (Pure m))

-- | A somewhat wonky function for parallelizing <tt>for xs f</tt> where
--   <tt>f</tt> is <tt>(MonadIO m, MonadError e m)</tt>. This is equivalent
--   to <tt>for xs f</tt> modulo the IO effects (i.e. when the IO has no
--   real side effects we care about).
--   
--   This also takes a <tt>chunkSize</tt> argument so you can manipulate
--   the amount of work given to each thread.
forConcurrentlyEIO :: (MonadIO m, MonadError e m) => Int -> [a] -> (a -> ExceptT e IO b) -> m [b]
instance GHC.Classes.Eq Control.Concurrent.Extended.ThreadState
instance GHC.Show.Show Control.Concurrent.Extended.ThreadState
instance Hasura.Logging.ToEngineLog Control.Concurrent.Extended.ImmortalThreadLog Hasura.Logging.Hasura

module Hasura.GraphQL.Schema.Typename

-- | Type name customization
newtype MkTypename
MkTypename :: (Name -> Name) -> MkTypename
[runMkTypename] :: MkTypename -> Name -> Name

-- | Inject a new <tt>MkTypename</tt> customization function into the
--   environment. This can be used by schema-building code (with
--   <tt>MonadBuildSchema</tt> constraint) to ensure the correct type name
--   customizations are applied.
withTypenameCustomization :: forall m r a. (MonadReader r m, Has MkTypename r) => MkTypename -> m a -> m a

-- | Apply the type name customization function from the current
--   environment.
mkTypename :: (MonadReader r m, Has MkTypename r) => Name -> m Name
instance GHC.Base.Monoid Hasura.GraphQL.Schema.Typename.MkTypename
instance GHC.Base.Semigroup Hasura.GraphQL.Schema.Typename.MkTypename


-- | Definitions for schema building configuration.
module Hasura.GraphQL.Schema.Options

-- | The record of options required to build the schema. This includes
--   options that can be enabled with <a>ExperimentalFeature</a> flags.
data SchemaOptions
SchemaOptions :: StringifyNumbers -> DangerouslyCollapseBooleans -> InferFunctionPermissions -> OptimizePermissionFilters -> SchemaOptions
[soStringifyNumbers] :: SchemaOptions -> StringifyNumbers
[soDangerousBooleanCollapse] :: SchemaOptions -> DangerouslyCollapseBooleans
[soInferFunctionPermissions] :: SchemaOptions -> InferFunctionPermissions
[soOptimizePermissionFilters] :: SchemaOptions -> OptimizePermissionFilters

-- | Should we represent numbers in our responses as numbers, or strings?
--   Some backends can return numbers that exceed the bounds of JSON's own
--   number type. In these cases, we can use stringified versions of these
--   numbers to avoid this problem.
data StringifyNumbers
StringifyNumbers :: StringifyNumbers
Don'tStringifyNumbers :: StringifyNumbers

-- | Should Boolean fields be collapsed to <a>True</a> when a null value is
--   given? This was the behaviour of Hasura V1, and is now discouraged.
data DangerouslyCollapseBooleans
DangerouslyCollapseBooleans :: DangerouslyCollapseBooleans
Don'tDangerouslyCollapseBooleans :: DangerouslyCollapseBooleans

-- | Should we infer function permissions? If this flag is set to
--   <a>InferFunctionPermissions</a>, we may fail to build expression
--   parsers in <tt>buildQueryAndSubscriptionFields</tt> for users with
--   unrecognised roles.
data InferFunctionPermissions
InferFunctionPermissions :: InferFunctionPermissions
Don'tInferFunctionPermissions :: InferFunctionPermissions

-- | Should we enable remote schema permissions? If so, these permissions
--   will influence <a>buildGQLContext</a>.
data RemoteSchemaPermissions
EnableRemoteSchemaPermissions :: RemoteSchemaPermissions
DisableRemoteSchemaPermissions :: RemoteSchemaPermissions

-- | Should we attempt to deduplicate permission filters? This flag is used
--   in <a>relationshipField</a> to determine whether certain row-level
--   permission filters can be dropped in certain cases.
data OptimizePermissionFilters
OptimizePermissionFilters :: OptimizePermissionFilters
Don'tOptimizePermissionFilters :: OptimizePermissionFilters
instance GHC.Show.Show Hasura.GraphQL.Schema.Options.StringifyNumbers
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Options.StringifyNumbers
instance GHC.Show.Show Hasura.GraphQL.Schema.Options.DangerouslyCollapseBooleans
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Options.DangerouslyCollapseBooleans
instance GHC.Show.Show Hasura.GraphQL.Schema.Options.InferFunctionPermissions
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Options.InferFunctionPermissions
instance GHC.Show.Show Hasura.GraphQL.Schema.Options.RemoteSchemaPermissions
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Options.RemoteSchemaPermissions
instance GHC.Show.Show Hasura.GraphQL.Schema.Options.OptimizePermissionFilters
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Options.OptimizePermissionFilters
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Schema.Options.RemoteSchemaPermissions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Schema.Options.RemoteSchemaPermissions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Schema.Options.InferFunctionPermissions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Schema.Options.InferFunctionPermissions

module Hasura.GraphQL.Execute.Types
data GraphQLQueryType
QueryHasura :: GraphQLQueryType
QueryRelay :: GraphQLQueryType
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance GHC.Classes.Ord Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance GHC.Show.Show Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Types.GraphQLQueryType

module Hasura.GraphQL.Execute.Subscription.TMap

-- | A coarse-grained transactional map implemented by simply wrapping a
--   <a>HashMap</a> in a <a>TVar</a>. Compared to <a>StmContainers.Map</a>,
--   this provides much faster iteration over the elements at the cost of
--   significantly increased contention on writes.
newtype TMap k v
TMap :: TVar (HashMap k v) -> TMap k v
[unTMap] :: TMap k v -> TVar (HashMap k v)
new :: STM (TMap k v)
reset :: TMap k v -> STM ()
null :: TMap k v -> STM Bool
lookup :: (Eq k, Hashable k) => k -> TMap k v -> STM (Maybe v)
insert :: (Eq k, Hashable k) => v -> k -> TMap k v -> STM ()
delete :: (Eq k, Hashable k) => k -> TMap k v -> STM ()
toList :: TMap k v -> STM [(k, v)]
filterWithKey :: (k -> v -> Bool) -> TMap k v -> STM ()
replace :: TMap k v -> HashMap k v -> STM ()
union :: (Eq k, Hashable k) => TMap k v -> TMap k v -> STM (TMap k v)
getMap :: TMap k v -> STM (HashMap k v)


-- | Tools to analyze the structure of a GraphQL request.
module Hasura.GraphQL.Analyse

-- | Overall structure of a given query. We extract the tree of fields in
--   the output, and the graph of input variables.
data Structure
Structure :: HashMap Name FieldInfo -> HashMap Name VariableInfo -> Structure
[_stSelection] :: Structure -> HashMap Name FieldInfo
[_stVariables] :: Structure -> HashMap Name VariableInfo

-- | Information about the type of an output field; whether the base type
--   is an object or a scalar, we store the correspoding <tt>GType</tt> to
--   keep track of the modifiers applied to it (list or non-nullability).
data FieldInfo
FieldObjectInfo :: GType -> ObjectInfo -> FieldInfo
FieldScalarInfo :: GType -> ScalarInfo -> FieldInfo
FieldEnumInfo :: GType -> EnumInfo -> FieldInfo
data ScalarInfo
ScalarInfo :: ScalarTypeDefinition -> ScalarInfo
[_siTypeDefinition] :: ScalarInfo -> ScalarTypeDefinition
data EnumInfo
EnumInfo :: EnumTypeDefinition -> EnumInfo
[_eiTypeDefinition] :: EnumInfo -> EnumTypeDefinition
data ObjectInfo
ObjectInfo :: ObjectTypeDefinition InputValueDefinition -> HashMap Name FieldInfo -> ObjectInfo
[_oiTypeDefinition] :: ObjectInfo -> ObjectTypeDefinition InputValueDefinition
[_oiSelection] :: ObjectInfo -> HashMap Name FieldInfo

-- | Information about a single variable of the query.
data VariableInfo
VariableInfo :: GType -> InputFieldInfo -> Maybe (Value Void) -> VariableInfo
[_viType] :: VariableInfo -> GType
[_viTypeInfo] :: VariableInfo -> InputFieldInfo
[_viDefaultValue] :: VariableInfo -> Maybe (Value Void)

-- | Information about the type of an input field; whether the base type is
--   an object or a scalar, we store the correspoding <tt>GType</tt> to
--   keep track of the modifiers applied to it (list or non-nullability).
data InputFieldInfo
InputFieldScalarInfo :: ScalarInfo -> InputFieldInfo
InputFieldEnumInfo :: EnumInfo -> InputFieldInfo
InputFieldObjectInfo :: InputObjectInfo -> InputFieldInfo
data InputObjectInfo
InputObjectInfo :: InputObjectTypeDefinition InputValueDefinition -> ~HashMap Name (GType, InputFieldInfo) -> InputObjectInfo
[_ioiTypeDefinition] :: InputObjectInfo -> InputObjectTypeDefinition InputValueDefinition

-- | lazy for knot-tying, as we build a graph
[_ioiFields] :: InputObjectInfo -> ~HashMap Name (GType, InputFieldInfo)

-- | Given the schema's definition, and a query, validate that the query is
--   consistent. We do this by running the analysis, but discarding the
--   result: we do not care about the structure, only about the validity of
--   the query.
--   
--   Returns <a>Nothing</a> if the query is valid, or a list of messages
--   otherwise.
diagnoseGraphQLQuery :: SchemaIntrospection -> TypedOperationDefinition NoFragments Name -> Maybe [Text]

-- | Given the schema's definition, and a query, run the analysis.
--   
--   We process all possible fields, and return a partially filled
--   structure if necessary. Given the following query:
--   
--   <pre>
--   query {
--     foo {
--       bar
--     }
--     does_not_exist {
--       ghsdflgh
--     }
--   }
--   </pre>
--   
--   We would return a structure containing:
--   
--   <pre>
--   foo: {
--     bar: {
--     }
--   }
--   </pre>
--   
--   AND an error about "does_not_exist" not existing.
--   
--   In some cases, however, we might not be able to produce a structure at
--   all, in which case we return <a>Nothing</a>. This either indicates
--   that something was fundamentally wrong with the structure of the query
--   (such as not finding an object at the top level), or that a
--   recoverable error was not caught properly (see
--   <a>withCatchAndRecord</a>).
analyzeGraphQLQuery :: SchemaIntrospection -> TypedOperationDefinition NoFragments Name -> (Maybe Structure, [Text])

-- | Analyze the fields of an object selection set against its definition,
--   and emit the corresponding <tt>Selection</tt>. We ignore the fields
--   that fail, and we continue accumulating the others.
analyzeObjectSelectionSet :: ObjectTypeDefinition InputValueDefinition -> SelectionSet NoFragments Name -> Analysis (HashMap Name FieldInfo)

-- | Analyze a given field, and attempt to build a corresponding
--   <a>FieldInfo</a>.
analyzeField :: GType -> TypeDefinition [Name] InputValueDefinition -> Field NoFragments Name -> Analysis (Maybe FieldInfo)

-- | Analyzes the variables in the given query. This builds the graph of
--   input types associated with the variable. This process is, like any
--   GraphQL schema operation, inherently self-recursive, and we use
--   <a>CircularT</a> (a lesser <tt>SchemaT</tt>) to tie the knot.
analyzeVariables :: [VariableDefinition] -> Analysis (HashMap Name VariableInfo)

-- | Builds an <a>InputFieldInfo</a> for a given typename.
--   
--   This function is "memoized" using <a>withCircular</a> to prevent
--   processing the same type more than once in case the input types are
--   self-recursive.
analyzeInputField :: Name -> TypeDefinition [Name] InputValueDefinition -> CircularT Name InputFieldInfo Analysis InputFieldInfo

-- | The monad in which we run our analysis.
--   
--   Has three capabilities: - reader carries the current path, and the
--   full schema for lookups - writer logs all errors we have caught -
--   except allows for short-circuiting errors
newtype Analysis a
Analysis :: ExceptT AnalysisError (ReaderT (Path, SchemaIntrospection) (Writer [AnalysisError])) a -> Analysis a
runAnalysis :: SchemaIntrospection -> Analysis a -> (Maybe a, [Text])

-- | Look up a type in the schema.
lookupType :: MonadReader (Path, SchemaIntrospection) m => Name -> m (Maybe (TypeDefinition [Name] InputValueDefinition))

-- | Add the current field to the error path.
withField :: MonadReader (Path, SchemaIntrospection) m => Name -> m a -> m a

-- | Throws an <a>AnalysisError</a> by combining the given diagnosis with
--   the current path. This interrupts the computation in the given branch,
--   and must be caught for the analysis to resume.
throwDiagnosis :: (MonadReader (Path, SchemaIntrospection) m, MonadError AnalysisError m) => Diagnosis -> m a

-- | Runs the given computation. if it fails, cacthes the error, records it
--   in the monad, and return <a>Nothing</a>. This allows for a clean
--   recovery.
withCatchAndRecord :: (MonadReader (Path, SchemaIntrospection) m, MonadWriter [AnalysisError] m, MonadError AnalysisError m) => m a -> m (Maybe a)
data AnalysisError
AnalysisError :: Path -> Diagnosis -> AnalysisError
[_aePath] :: AnalysisError -> Path
[_aeDiagnosis] :: AnalysisError -> Diagnosis
type Path = Seq Text
data Diagnosis
RootTypeNotAnObject :: Diagnosis
TypeNotFound :: Name -> Diagnosis
EnumSelectionSet :: Name -> Diagnosis
ScalarSelectionSet :: Name -> Diagnosis
InputObjectInOutput :: Name -> Diagnosis
UnionInInput :: Name -> Diagnosis
ObjectInInput :: Name -> Diagnosis
InterfaceInInput :: Name -> Diagnosis
ObjectFieldNotFound :: Name -> Name -> Diagnosis
ObjectMissingSelectionSet :: Name -> Diagnosis
MismatchedFields :: Name -> GType -> GType -> Diagnosis
render :: AnalysisError -> Text
queryRootName :: Name
mutationRootName :: Name
subscriptionRootName :: Name
typenameField :: FieldDefinition InputValueDefinition
schemaField :: FieldDefinition InputValueDefinition
typeField :: FieldDefinition InputValueDefinition
mkReservedField :: Name -> Name -> FieldDefinition InputValueDefinition
instance Control.Monad.Fix.MonadFix Hasura.GraphQL.Analyse.Analysis
instance Control.Monad.Error.Class.MonadError Hasura.GraphQL.Analyse.AnalysisError Hasura.GraphQL.Analyse.Analysis
instance Control.Monad.Writer.Class.MonadWriter [Hasura.GraphQL.Analyse.AnalysisError] Hasura.GraphQL.Analyse.Analysis
instance Control.Monad.Reader.Class.MonadReader (Hasura.GraphQL.Analyse.Path, Language.GraphQL.Draft.Syntax.SchemaIntrospection) Hasura.GraphQL.Analyse.Analysis
instance GHC.Base.Monad Hasura.GraphQL.Analyse.Analysis
instance GHC.Base.Applicative Hasura.GraphQL.Analyse.Analysis
instance GHC.Base.Functor Hasura.GraphQL.Analyse.Analysis

module Hasura.GC

-- | The RTS's idle GC doesn't work for us:
--   
--   <ul>
--   <li>when `-I` is too low it may fire continuously causing scary high
--   CPU when idle among other issues (see #2565)</li>
--   <li>when we set it higher it won't run at all leading to memory being
--   retained when idle (especially noticeable when users are benchmarking
--   and see memory stay high after finishing). In the theoretical worst
--   case there is such low haskell heap pressure that we never run
--   finalizers to free the foreign data from e.g. libpq.</li>
--   <li>as of GHC 8.10.2 we have access to `-Iw`, but those two knobs
--   still don’t give us a guarantee that a major GC will always run at
--   some minumum frequency (e.g. for finalizers)</li>
--   </ul>
--   
--   ...so we hack together our own using GHC.Stats, which should have
--   insignificant runtime overhead.
ourIdleGC :: Logger Hasura -> DiffTime -> DiffTime -> DiffTime -> IO void


-- | graphql-engine used to have a query plan cache, which cached the
--   execution plan for a given graphql query (sans JSON variable values).
--   After the PDV refactor (see <a>hasura/graphql-engine#4111</a>), this
--   query plan cache was not needed anymore. For backwards compatibility
--   reasons, we still need to parse the configuration options from the
--   CLI, although the CLI option gets ignored.
--   
--   Eventually, we can decide to stop parsing the CLI option
--   --query-plan-cache-size, at which point this module can be removed.
module Hasura.Cache.Bounded
newtype CacheSize
CacheSize :: Word16 -> CacheSize
[unCacheSize] :: CacheSize -> Word16
parseCacheSize :: String -> Either String CacheSize
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Cache.Bounded.CacheSize
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Cache.Bounded.CacheSize
instance GHC.Enum.Enum Hasura.Cache.Bounded.CacheSize
instance GHC.Real.Integral Hasura.Cache.Bounded.CacheSize
instance GHC.Real.Real Hasura.Cache.Bounded.CacheSize
instance GHC.Num.Num Hasura.Cache.Bounded.CacheSize
instance GHC.Enum.Bounded Hasura.Cache.Bounded.CacheSize
instance GHC.Classes.Ord Hasura.Cache.Bounded.CacheSize
instance GHC.Classes.Eq Hasura.Cache.Bounded.CacheSize
instance GHC.Read.Read Hasura.Cache.Bounded.CacheSize
instance GHC.Show.Show Hasura.Cache.Bounded.CacheSize


-- | Postgres SQL Error
--   
--   Functions and datatypes for interpreting Postgres errors.
module Hasura.Backends.Postgres.SQL.Error

-- | The top-level error code type. Errors in Postgres are divided into
--   different <i>classes</i>, which are further subdivided into individual
--   error codes. Even if a particular status code is not known to the
--   application, it’s possible to determine its class and handle it
--   appropriately.
data PGErrorType
PGDataException :: Maybe (PGErrorCode PGDataException) -> PGErrorType
PGIntegrityConstraintViolation :: Maybe (PGErrorCode PGIntegrityConstraintViolation) -> PGErrorType
PGSyntaxErrorOrAccessRuleViolation :: Maybe (PGErrorCode PGSyntaxErrorOrAccessRuleViolation) -> PGErrorType
PGTransactionRollback :: Maybe (PGErrorCode PGTransactionRollback) -> PGErrorType
data PGErrorCode a

-- | represents errors that have the non-specific <tt>000</tt> status code
PGErrorGeneric :: PGErrorCode a

-- | represents errors with a known, more specific status code
PGErrorSpecific :: a -> PGErrorCode a
data PGDataException
PGInvalidDatetimeFormat :: PGDataException
PGInvalidParameterValue :: PGDataException
PGInvalidEscapeSequence :: PGDataException
PGInvalidTextRepresentation :: PGDataException
data PGIntegrityConstraintViolation
PGRestrictViolation :: PGIntegrityConstraintViolation
PGNotNullViolation :: PGIntegrityConstraintViolation
PGForeignKeyViolation :: PGIntegrityConstraintViolation
PGUniqueViolation :: PGIntegrityConstraintViolation
PGCheckViolation :: PGIntegrityConstraintViolation
PGExclusionViolation :: PGIntegrityConstraintViolation
data PGSyntaxErrorOrAccessRuleViolation
PGUndefinedObject :: PGSyntaxErrorOrAccessRuleViolation
PGInvalidColumnReference :: PGSyntaxErrorOrAccessRuleViolation
data PGTransactionRollback
PGSerializationFailure :: PGTransactionRollback
_PGTransactionRollback :: Prism' PGErrorType (Maybe (PGErrorCode PGTransactionRollback))
_PGSyntaxErrorOrAccessRuleViolation :: Prism' PGErrorType (Maybe (PGErrorCode PGSyntaxErrorOrAccessRuleViolation))
_PGIntegrityConstraintViolation :: Prism' PGErrorType (Maybe (PGErrorCode PGIntegrityConstraintViolation))
_PGDataException :: Prism' PGErrorType (Maybe (PGErrorCode PGDataException))
_PGErrorSpecific :: forall a_a1Ykh a_a1XxP. Prism (PGErrorCode a_a1Ykh) (PGErrorCode a_a1XxP) a_a1Ykh a_a1XxP
_PGErrorGeneric :: forall a_a1XxP. Prism' (PGErrorCode a_a1XxP) ()
pgErrorType :: PGStmtErrDetail -> Maybe PGErrorType
instance GHC.Base.Functor Hasura.Backends.Postgres.SQL.Error.PGErrorCode
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.SQL.Error.PGErrorCode a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.Postgres.SQL.Error.PGErrorCode a)
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGDataException
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Error.PGDataException
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGIntegrityConstraintViolation
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Error.PGIntegrityConstraintViolation
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGSyntaxErrorOrAccessRuleViolation
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Error.PGSyntaxErrorOrAccessRuleViolation
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGTransactionRollback
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Error.PGTransactionRollback
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGErrorType
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Error.PGErrorType


-- | GHC.AssertNF.CPP localizes our use of CPP around calls to
--   <a>assertNFHere</a>, primarily to give tooling (e.g. ormolu) an easier
--   time.
--   
--   We disable the <tt>assertNF</tt>-related code because it is provided
--   by the package ghc-heap-view, which can't be built using profiling.
module GHC.AssertNF.CPP
assertNFHere :: Q Exp
disableAssertNF :: IO ()


-- | MSSQL Connection Pooling
module Database.MSSQL.Pool

-- | ODBC connection string for MSSQL server
newtype ConnectionString
ConnectionString :: Text -> ConnectionString
[unConnectionString] :: ConnectionString -> Text
data ConnectionOptions
ConnectionOptions :: Int -> Int -> Int -> ConnectionOptions
[_coConnections] :: ConnectionOptions -> Int
[_coStripes] :: ConnectionOptions -> Int
[_coIdleTime] :: ConnectionOptions -> Int

-- | ODBC connection pool
newtype MSSQLPool
MSSQLPool :: Pool Connection -> MSSQLPool

-- | Initialize an MSSQL pool with given connection configuration
initMSSQLPool :: ConnectionString -> ConnectionOptions -> IO MSSQLPool

-- | Destroy all pool resources
drainMSSQLPool :: MSSQLPool -> IO ()
withMSSQLPool :: MonadBaseControl IO m => MSSQLPool -> (Connection -> m a) -> m (Either ODBCException a)
instance GHC.Generics.Generic Database.MSSQL.Pool.ConnectionString
instance Data.Aeson.Types.FromJSON.FromJSON Database.MSSQL.Pool.ConnectionString
instance Data.Aeson.Types.ToJSON.ToJSON Database.MSSQL.Pool.ConnectionString
instance GHC.Classes.Eq Database.MSSQL.Pool.ConnectionString
instance GHC.Show.Show Database.MSSQL.Pool.ConnectionString
instance GHC.Classes.Eq Database.MSSQL.Pool.ConnectionOptions
instance GHC.Show.Show Database.MSSQL.Pool.ConnectionOptions

module Database.MSSQL.Transaction

-- | The transaction command to run, parameterised over: e - the exception
--   type (usually <a>MSSQLTxError</a>) m - some Monad, (usually some
--   <a>MonadIO</a>) a - the successful result type
newtype TxET e m a
TxET :: ReaderT Connection (ExceptT e m) a -> TxET e m a
[txHandler] :: TxET e m a -> ReaderT Connection (ExceptT e m) a

-- | Error type generally used in <a>TxET</a>.
data MSSQLTxError
MSSQLQueryError :: !Query -> !ODBCException -> MSSQLTxError
MSSQLConnError :: !ODBCException -> MSSQLTxError
MSSQLInternal :: !Text -> MSSQLTxError
type TxE e a = TxET e IO a

-- | The transaction command to run, returning an MSSQLTxError or the
--   result.
type TxT m a = TxET MSSQLTxError m a

-- | Run a command on the given connection wrapped in a transaction.
--   
--   See <a>runTxE</a> if you need to map the error type as well.
runTx :: (MonadIO m, MonadBaseControl IO m) => TxT m a -> MSSQLPool -> ExceptT MSSQLTxError m a

-- | Run a command on the given connection wrapped in a transaction.
runTxE :: (MonadIO m, MonadBaseControl IO m) => (MSSQLTxError -> e) -> TxET e m a -> MSSQLPool -> ExceptT e m a

-- | Useful for building transactions which return no data.
--   
--   <pre>
--   insertId :: TxT m ()
--   insertId = unitQuery "INSERT INTO some_table VALUES (1, "hello")"
--   </pre>
--   
--   See <a>unitQueryE</a> if you need to map the error type as well.
unitQuery :: MonadIO m => Query -> TxT m ()

-- | Useful for building transactions which return no data.
unitQueryE :: MonadIO m => (MSSQLTxError -> e) -> Query -> TxET e m ()

-- | Useful for building query transactions which return a single one row.
--   
--   <pre>
--   returnOne :: TxT m Int
--   returnOne = singleRowQuery "SELECT 1"
--   </pre>
--   
--   See <a>singleRowQueryE</a> if you need to map the error type as well.
singleRowQuery :: forall a m. (MonadIO m, FromRow a) => Query -> TxT m a

-- | Useful for building query transactions which return a single one row.
singleRowQueryE :: forall m a e. (MonadIO m, FromRow a) => (MSSQLTxError -> e) -> Query -> TxET e m a

-- | MSSQL splits up results that have a <tt>SELECT .. FOR JSON</tt> at the
--   top-level into multiple rows with a single column, see
--   <a>https://docs.microsoft.com/en-us/sql/relational-databases/json/format-query-results-as-json-with-for-json-sql-server?view=sql-server-ver15#output-of-the-for-json-clause</a>
--   
--   This function simply concatenates each single-column row into one long
--   <a>Text</a> string.
forJsonQueryE :: forall m e. MonadIO m => (MSSQLTxError -> e) -> Query -> TxET e m Text

-- | Useful for building query transactions which return multiple rows.
--   
--   <pre>
--   selectIds :: TxT m [Int]
--   selectIds = multiRowQuery "SELECT id FROM author"
--   </pre>
--   
--   See <a>multiRowQueryE</a> if you need to map the error type as well.
multiRowQuery :: forall a m. (MonadIO m, FromRow a) => Query -> TxT m [a]

-- | Useful for building query transactions which return multiple rows.
multiRowQueryE :: forall m a e. (MonadIO m, FromRow a) => (MSSQLTxError -> e) -> Query -> TxET e m [a]

-- | Build a generic transaction out of an IO action.
buildGenericQueryTxE :: MonadIO m => (MSSQLTxError -> e) -> query -> (query -> Query) -> (Connection -> query -> IO a) -> TxET e m a

-- | Map the error type for a <a>TxET</a>.
withTxET :: Monad m => (e1 -> e2) -> TxET e1 m a -> TxET e2 m a

-- | A successful result from a query is a list of rows where each row
--   contains list of column values
newtype MSSQLResult
MSSQLResult :: [[Value]] -> MSSQLResult

-- | Packs a query, along with result and error converters into a
--   <a>TxET</a>.
--   
--   Used by <a>unitQueryE</a>, <a>singleRowQueryE</a>, and
--   <a>multiRowQueryE</a>.
rawQueryE :: MonadIO m => (MSSQLTxError -> e) -> (MSSQLResult -> Either String a) -> Query -> TxET e m a

-- | Combinator for abstracting over the query type and ensuring we catch
--   exceptions.
--   
--   Used by <a>buildGenericQueryTxE</a>.
execQuery :: forall m a query. MonadIO m => query -> (query -> Query) -> (query -> IO a) -> ExceptT MSSQLTxError m a

-- | Run a <a>TxET</a> with the given connection.
--   
--   Used by <a>runTxE</a> and <a>asTransaction</a>.
execTx :: Connection -> TxET e m a -> ExceptT e m a

-- | The transaction state of the current connection
data TransactionState

-- | Has an active transaction.
TSActive :: TransactionState

-- | Has no active transaction.
TSNoActive :: TransactionState

-- | An error occurred that caused the transaction to be uncommittable. We
--   cannot commit or rollback to a savepoint; we can only do a full
--   rollback of the transaction.
TSUncommittable :: TransactionState

-- | Wraps an action in a transaction. Rolls back on errors.
asTransaction :: forall e a m. MonadIO m => (MSSQLTxError -> e) -> (Connection -> ExceptT e m a) -> Connection -> ExceptT e m a
beginTx :: MonadIO m => TxT m ()
commitTx :: MonadIO m => TxT m ()
rollbackTx :: MonadIO m => TxT m ()

-- | Get the @<a>TransactionState</a> of current connection For more
--   details, refer to
--   <a>https://docs.microsoft.com/en-us/sql/t-sql/functions/xact-state-transact-sql?view=sql-server-ver15</a>
getTransactionState :: MonadIO m => TxT m TransactionState
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Database.MSSQL.Transaction.TxET e m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Database.ODBC.Internal.Connection (Database.MSSQL.Transaction.TxET e m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Database.MSSQL.Transaction.TxET e m)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError e (Database.MSSQL.Transaction.TxET e m)
instance GHC.Base.Monad m => GHC.Base.Monad (Database.MSSQL.Transaction.TxET e m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Database.MSSQL.Transaction.TxET e m)
instance GHC.Base.Functor m => GHC.Base.Functor (Database.MSSQL.Transaction.TxET e m)
instance GHC.Show.Show Database.MSSQL.Transaction.MSSQLTxError
instance GHC.Classes.Eq Database.MSSQL.Transaction.MSSQLTxError
instance GHC.Show.Show Database.MSSQL.Transaction.MSSQLResult
instance GHC.Classes.Eq Database.MSSQL.Transaction.MSSQLResult
instance Control.Monad.Morph.MFunctor (Database.MSSQL.Transaction.TxET e)
instance Control.Monad.Trans.Class.MonadTrans (Database.MSSQL.Transaction.TxET e)

module Data.Text.Extended
class ToTxt a
toTxt :: ToTxt a => a -> Text
bquote :: ToTxt t => t -> Text
squote :: ToTxt t => t -> Text
dquote :: ToTxt t => t -> Text
paren :: ToTxt t => t -> Text
parenB :: Builder -> Builder
dquoteList :: (ToTxt t, Foldable f) => f t -> Text
commaSeparated :: (ToTxt t, Foldable f) => f t -> Text
(<>>) :: ToTxt t => Text -> t -> Text
infixr 6 <>>
(<<>) :: ToTxt t => t -> Text -> Text
infixr 6 <<>
(<~>) :: Builder -> Builder -> Builder
infixr 6 <~>
instance Data.Text.Extended.ToTxt Language.GraphQL.Draft.Syntax.EnumValue
instance Data.Text.Extended.ToTxt Data.Text.Internal.Text
instance Data.Text.Extended.ToTxt GHC.Types.Char
instance Data.Text.Extended.ToTxt Language.GraphQL.Draft.Syntax.Name
instance Data.Text.Extended.ToTxt ()
instance Data.Text.Extended.ToTxt Data.Void.Void
instance Data.Text.Extended.ToTxt (Language.GraphQL.Draft.Syntax.Value Data.Void.Void)
instance Data.Text.Extended.ToTxt Database.ODBC.SQLServer.Query

module Data.Text.NonEmpty
newtype NonEmptyText
NonEmptyText :: Text -> NonEmptyText
[unNonEmptyText] :: NonEmptyText -> Text
mkNonEmptyText :: Text -> Maybe NonEmptyText
mkNonEmptyTextUnsafe :: Text -> NonEmptyText
parseNonEmptyText :: MonadFail m => Text -> m NonEmptyText
nonEmptyText :: Text -> Q (TExp NonEmptyText)

-- | Construct <a>NonEmptyText</a> literals at compile-time via
--   quasiquotation.
nonEmptyTextQQ :: QuasiQuoter
instance Control.DeepSeq.NFData Data.Text.NonEmpty.NonEmptyText
instance GHC.Generics.Generic Data.Text.NonEmpty.NonEmptyText
instance Data.Text.Extended.ToTxt Data.Text.NonEmpty.NonEmptyText
instance Database.PG.Query.Class.ToPrepArg Data.Text.NonEmpty.NonEmptyText
instance Language.Haskell.TH.Syntax.Lift Data.Text.NonEmpty.NonEmptyText
instance Data.Aeson.Types.ToJSON.ToJSONKey Data.Text.NonEmpty.NonEmptyText
instance Data.Aeson.Types.ToJSON.ToJSON Data.Text.NonEmpty.NonEmptyText
instance Data.Hashable.Class.Hashable Data.Text.NonEmpty.NonEmptyText
instance GHC.Classes.Ord Data.Text.NonEmpty.NonEmptyText
instance GHC.Classes.Eq Data.Text.NonEmpty.NonEmptyText
instance GHC.Show.Show Data.Text.NonEmpty.NonEmptyText
instance Test.QuickCheck.Arbitrary.Arbitrary Data.Text.NonEmpty.NonEmptyText
instance Data.Aeson.Types.FromJSON.FromJSON Data.Text.NonEmpty.NonEmptyText
instance Data.Aeson.Types.FromJSON.FromJSONKey Data.Text.NonEmpty.NonEmptyText
instance Database.PG.Query.Class.FromCol Data.Text.NonEmpty.NonEmptyText

module Hasura.EncJSON
newtype EncJSON
EncJSON :: Builder -> EncJSON
[unEncJSON] :: EncJSON -> Builder
encJToLBS :: EncJSON -> ByteString
encJToBS :: EncJSON -> ByteString
encJFromBuilder :: Builder -> EncJSON
encJFromBS :: ByteString -> EncJSON
encJFromLBS :: ByteString -> EncJSON
encJFromJValue :: ToJSON a => a -> EncJSON
encJFromChar :: Char -> EncJSON
encJFromText :: Text -> EncJSON
encJFromNonEmptyText :: NonEmptyText -> EncJSON
encJFromBool :: Bool -> EncJSON
encJFromList :: [EncJSON] -> EncJSON
encJFromAssocList :: [(Text, EncJSON)] -> EncJSON
encJFromInsOrdHashMap :: InsOrdHashMap Text EncJSON -> EncJSON

-- | Encode a <a>Value</a> as <a>EncJSON</a>.
encJFromOrderedValue :: Value -> EncJSON


-- | This module is inspired by <tt>casing</tt> package. Instead of
--   <tt>String</tt> this package uses <tt>Data.Text.Text</tt>
--   
--   <ul>
--   <li><tt>PascalCase</tt> - no spacing between words, first letter in
--   word is uppercase, all others are lowercase.</li>
--   <li><tt>camelCase</tt> - like <tt>PascalCase</tt>, but the very first
--   letter is lowercase.</li>
--   <li><tt>snake_Case</tt> - underscores delimit words, case is
--   unrestricted.</li>
--   </ul>
module Data.Text.Casing
type NameWithOrigin = (Name, NameOrigin)
type NameSuffixWithOrigin = (NameSuffix, NameOrigin)

-- | An opaque type, representing a parsed identifier with prefix and
--   suffixes.
data GQLNameIdentifier
GQLNameIdentifier :: NameWithOrigin -> [NameSuffixWithOrigin] -> GQLNameIdentifier
[namePrefix] :: GQLNameIdentifier -> NameWithOrigin
[nameSuffixes] :: GQLNameIdentifier -> [NameSuffixWithOrigin]

-- | Represents the origin of a name entity.
--   
--   <ul>
--   <li><a>CustomName</a> represents a custom user provided name</li>
--   <li><a>AutogeneratedName</a> represents a name which is generated by
--   Hasura</li>
--   </ul>
--   
--   For a custom table name <tt>foo</tt>, the select by pk field name
--   elements:
--   
--   <ul>
--   <li><tt>foo</tt> is a <a>CustomName</a></li>
--   <li><tt>by</tt> is an <a>AutogeneratedName</a></li>
--   <li><tt>pk</tt> is an <a>AutogeneratedName</a></li>
--   </ul>
--   
--   However, for a table name <tt>foo_bar</tt>, the select by pk field
--   name elements <tt>foo</tt>, <tt>bar</tt>, <tt>by</tt> and <tt>pk</tt>
--   are all <a>AutogeneratedName</a>
data NameOrigin
CustomName :: NameOrigin
AutogeneratedName :: NameOrigin
fromTupleWith :: NameOrigin -> (Name, [NameSuffix]) -> GQLNameIdentifier
fromNameWith :: NameOrigin -> Name -> GQLNameIdentifier
fromAutogeneratedName :: Name -> GQLNameIdentifier
fromCustomName :: Name -> GQLNameIdentifier
fromAutogeneratedTuple :: (Name, [NameSuffix]) -> GQLNameIdentifier
fromCustomTuple :: (Name, [NameSuffix]) -> GQLNameIdentifier
fromNonEmptyList :: NonEmpty NameWithOrigin -> GQLNameIdentifier

-- | transforms a graphql name with a transforming function
--   
--   Note: This will return the graphql name without transformation if the
--   transformed name is not a valid GraphQL identifier
transformNameWith :: (Text -> Text) -> Name -> Name

-- | same as <a>transformNameWith</a> but will not transform if the name is
--   a custom name
transformNameAndOriginWith :: (Text -> Text) -> NameWithOrigin -> NameWithOrigin

-- | similar to <tt>transformNameWith</tt> but transforms
--   <tt>NameSuffix</tt> instead of <tt>Name</tt>
transformGQLSuffixWith :: (Text -> Text) -> NameSuffix -> NameSuffix

-- | This is essentially same as <tt>second transformGQLSuffixWith</tt>
transformGQLSuffixAndOriginWith :: (Text -> Text) -> NameSuffixWithOrigin -> NameSuffixWithOrigin

-- | transforms a <a>GQLNameIdentifier</a>; this will apply the
--   transformations on prefix as well as suffixes
transformGQLIdentifierWith :: (Text -> Text) -> GQLNameIdentifier -> GQLNameIdentifier

-- | converts identifiers to <tt>Text</tt> (i.e. <tt>unName</tt>s and
--   <tt>unNameSuffix</tt>s identifiers)
identifierToList :: GQLNameIdentifier -> [Text]

-- | To <tt>snake_case</tt> for <tt>Data.Text</tt>
--   
--   <pre>
--   &gt;&gt;&gt; toSnakeT ["my","random","text","list"]
--   "my_random_text_list"
--   </pre>
toSnakeT :: [Text] -> Text

-- | To <tt>PascalCase</tt> for <tt>Data.Text</tt>
--   
--   <pre>
--   &gt;&gt;&gt; toPascalT ["my","random","text","list"]
--   "MyRandomTextList"
--   </pre>
toPascalT :: [Text] -> Text

-- | To <tt>camelCase</tt> for <tt>Data.Text</tt>
--   
--   <pre>
--   &gt;&gt;&gt; toCamelT ["my","random","text","list"]
--   "myRandomTextList"
--   </pre>
toCamelT :: [Text] -> Text

-- | To <tt>snake_case</tt> for <tt>GQLNameIdentifier</tt>
toSnakeG :: GQLNameIdentifier -> Name

-- | To <tt>PascalCase</tt> for <tt>GQLNameIdentifier</tt>
toPascalG :: GQLNameIdentifier -> Name

-- | To <tt>camelCase</tt> for <tt>GQLNameIdentifier</tt>
toCamelG :: GQLNameIdentifier -> Name

-- | Transforms <tt>GQLNameIdentifier</tt> and returns a <tt>G.Name</tt>
transformPrefixAndSuffixAndConcat :: GQLNameIdentifier -> (Text -> Text) -> (Text -> Text) -> Name

-- | Convert from <tt>snake_cased</tt>
--   
--   <pre>
--   &gt;&gt;&gt; fromSnake "_hello_world_foo"
--   ["_hello","world","foo"]
--   </pre>
fromSnake :: Text -> [Text]

-- | Directly convert to <tt>PascalCase</tt> through <a>fromSnake</a>
snakeToPascal :: Text -> Text

-- | Directly convert to <tt>camelCase</tt> through <a>fromSnake</a>
snakeToCamel :: Text -> Text

-- | An internal helper function to lowercase the first character
lowerFirstChar :: Text -> Text

-- | An internal helper function to uppercase the first character
upperFirstChar :: Text -> Text
instance GHC.Show.Show Data.Text.Casing.NameOrigin
instance GHC.Show.Show Data.Text.Casing.GQLNameIdentifier
instance GHC.Base.Semigroup Data.Text.Casing.GQLNameIdentifier

module Data.Parser.JSONPath

-- | Encodes a JSON path as text that looks like code you would write in
--   order to traverse that path in JavaScript.
encodeJSONPath :: JSONPath -> Text
parseJSONPath :: Text -> Either Text JSONPath
element :: Parser JSONPathElement
name :: Parser Key

-- | Parses a JSON property key or index in square bracket format, e.g.
--   &gt; [42] &gt; ["hello"] &gt; [<tt>你好</tt>]
bracketElement :: Parser JSONPathElement

module Hasura.Base.Error
data Code
AccessDenied :: Code
ActionWebhookCode :: !Text -> Code
AlreadyExists :: Code
AlreadyTracked :: Code
AlreadyUntracked :: Code
BadRequest :: Code
BigQueryError :: Code
Busy :: Code
ConcurrentUpdate :: Code
CoercionError :: Code
Conflict :: Code
ConstraintError :: Code
ConstraintViolation :: Code

-- | Custom code for extending this sum-type easily
CustomCode :: !Text -> Code
CyclicDependency :: Code
DataException :: Code
DataConnectorError :: Code
DependencyError :: Code
InvalidConfiguration :: Code
InvalidHeaders :: Code
InvalidJSON :: Code
InvalidParams :: Code
JWTInvalid :: Code
JWTInvalidClaims :: Code
JWTRoleClaimMissing :: Code
MSSQLError :: Code
MethodNotAllowed :: Code
NotExists :: Code
NotFound :: Code
NotSupported :: Code
ParseFailed :: Code
PermissionDenied :: Code
PermissionError :: Code
PostgresError :: Code
PostgresMaxConnectionsError :: Code
RemoteSchemaConflicts :: Code
RemoteSchemaError :: Code

-- | Websockets
StartFailed :: Code
Unexpected :: Code
UnexpectedPayload :: Code
ValidationFailed :: Code
data QErr
QErr :: JSONPath -> Status -> Text -> Code -> Maybe QErrExtra -> QErr
[qePath] :: QErr -> JSONPath
[qeStatus] :: QErr -> Status
[qeError] :: QErr -> Text
[qeCode] :: QErr -> Code
[qeInternal] :: QErr -> Maybe QErrExtra

-- | Extra context for a QErr, which can either be information from an
--   internal error (e.g. from Postgres, or from a network operation timing
--   out), or context provided when an external service or operation fails,
--   for instance, a webhook error response may provide additional context
--   in the <tt>extensions</tt> key.
data QErrExtra
ExtraExtensions :: Value -> QErrExtra
ExtraInternal :: Value -> QErrExtra

-- | Overrides the status and code of a QErr while retaining all other
--   fields.
overrideQErrStatus :: Status -> Code -> QErr -> QErr

-- | Prefixes the message of a QErr while retaining all other fields.
prefixQErr :: Text -> QErr -> QErr
showQErr :: QErr -> Text
noInternalQErrEnc :: QErr -> Value
encodeGQLErr :: Bool -> QErr -> Value
encodeQErr :: Bool -> QErr -> Value
err400 :: Code -> Text -> QErr
err404 :: Code -> Text -> QErr
err405 :: Code -> Text -> QErr
err401 :: Code -> Text -> QErr
err409 :: Code -> Text -> QErr
err429 :: Code -> Text -> QErr
err500 :: Code -> Text -> QErr
type QErrM m = (MonadError QErr m)
throw400 :: QErrM m => Code -> Text -> m a
throw404 :: QErrM m => Text -> m a

-- | MethodNotAllowed
throw405 :: QErrM m => Text -> m a

-- | AccessDenied
throw401 :: QErrM m => Text -> m a

-- | Conflict
throw409 :: QErrM m => Text -> m a
throw429 :: QErrM m => Code -> Text -> m a
throw500 :: QErrM m => Text -> m a
internalError :: Text -> QErr
throw500WithDetail :: QErrM m => Text -> Value -> m a
modifyQErr :: QErrM m => (QErr -> QErr) -> m a -> m a
modifyErr :: QErrM m => (Text -> Text) -> m a -> m a
modifyErrA :: ArrowError QErr arr => arr (e, s) a -> arr (e, (Text -> Text, s)) a
liftTxtMod :: (Text -> Text) -> QErr -> QErr
modifyErrAndSet500 :: QErrM m => (Text -> Text) -> m a -> m a
liftTxtMod500 :: (Text -> Text) -> QErr -> QErr
withPathE :: ArrowError QErr arr => arr (e, s) a -> arr (e, (JSONPathElement, s)) a
withPathKA :: ArrowError QErr arr => arr (e, s) a -> arr (e, (Text, s)) a
withPathK :: QErrM m => Text -> m a -> m a
withPathIA :: ArrowError QErr arr => arr (e, s) a -> arr (e, (Int, s)) a
withPathI :: QErrM m => Int -> m a -> m a
indexedFoldlA' :: (ArrowChoice arr, ArrowError QErr arr, Foldable t) => arr (e, (b, (a, s))) b -> arr (e, (b, (t a, s))) b
indexedTraverseA_ :: (ArrowChoice arr, ArrowError QErr arr, Foldable t) => arr (e, (a, s)) b -> arr (e, (t a, s)) ()
indexedMapM_ :: (QErrM m, Foldable t) => (a -> m b) -> t a -> m ()
indexedForM_ :: (QErrM m, Foldable t) => t a -> (a -> m b) -> m ()
indexedMapM :: QErrM m => (a -> m b) -> [a] -> m [b]
indexedForM :: QErrM m => [a] -> (a -> m b) -> m [b]
liftIResult :: QErrM m => IResult a -> m a
iResultToMaybe :: IResult a -> Maybe a
formatMsg :: String -> String
runAesonParser :: QErrM m => (v -> Parser a) -> v -> m a
decodeValue :: (FromJSON a, QErrM m) => Value -> m a
instance GHC.Classes.Eq Hasura.Base.Error.Code
instance GHC.Show.Show Hasura.Base.Error.Code
instance GHC.Classes.Eq Hasura.Base.Error.QErrExtra
instance GHC.Classes.Eq Hasura.Base.Error.QErr
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Base.Error.QErr
instance Database.PG.Query.Pool.FromPGConnErr Hasura.Base.Error.QErr
instance Database.PG.Query.Pool.FromPGTxErr Hasura.Base.Error.QErr
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Base.Error.QErrExtra
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Base.Error.Code


-- | Functions and datatypes for interpreting MSSQL database errors.
module Hasura.Backends.MSSQL.SQL.Error

-- | The top-level error class. Errors in MSSQL are divided into different
--   <i>classes</i>, which are further subdivided into individual error
--   subclasses. It is useful to determine the class of database exception
--   and handle it appropriately.
data ErrorClass
DataException :: ErrorSubclass DataExceptionSubclass -> ErrorClass
IntegrityConstraintViolation :: ErrorClass
SyntaxErrorOrAccessViolation :: ErrorSubclass SyntaxErrorOrAccessViolationSubclass -> ErrorClass
data ErrorSubclass a

-- | represents non-specific <tt>000</tt> subclass code
NoSubclass :: ErrorSubclass a

-- | represents known, more specific sub class
Subclass :: a -> ErrorSubclass a
data DataExceptionSubclass
StringDataRightTruncated :: DataExceptionSubclass
NumericValueOutOfRange :: DataExceptionSubclass
InvalidDatetimeFormat :: DataExceptionSubclass
DatetimeFieldOverflow :: DataExceptionSubclass
IntervalFieldOverflow :: DataExceptionSubclass
InvalidEscapeCharacter :: DataExceptionSubclass
InvalidEscapeSequence :: DataExceptionSubclass
data SyntaxErrorOrAccessViolationSubclass
TableOrViewAlreadyExists :: SyntaxErrorOrAccessViolationSubclass
TableOrViewNotFound :: SyntaxErrorOrAccessViolationSubclass
IndexAlreadyExists :: SyntaxErrorOrAccessViolationSubclass
IndexNotFound :: SyntaxErrorOrAccessViolationSubclass
ColumnAlreadyExists :: SyntaxErrorOrAccessViolationSubclass
ColumnNotFound :: SyntaxErrorOrAccessViolationSubclass

-- | Assign each error class' subclasses an appropriate API error code
errorClassCode :: ErrorClass -> Code

-- | Parsing error class and subclass information from a SQLSTATE code.
--   SQLSTATE provides detailed information about the cause of a warning or
--   error. A SQLSTATE consists of 5 chars. They are divided into two
--   parts: the first and second chars contain a class and the following
--   three a subclass.
parseErrorClass :: String -> Maybe ErrorClass

-- | A default transaction error handler where all errors are unexpected.
defaultMSSQLTxErrorHandler :: MSSQLTxError -> QErr

-- | A transaction error handler to be used in constructing mutation
--   transactions, i.e INSERT, UPDATE and DELETE. We expect data exception
--   and integrity constraint violation.
mutationMSSQLTxErrorHandler :: MSSQLTxError -> QErr

-- | Constructs a transaction error handler given a predicate that
--   determines which error classes (and subclasses) are expected and
--   should be reported to the user. All other errors are considered
--   internal errors. Example:- Consider a insert mutation where we insert
--   some data into columns of a table. Except for the basic data type,
--   such as Boolean, String, Float, Int etc. we cannot invalidate data any
--   further, such as validating timestamp string format. In this case, a
--   @<a>DataException</a> is expected from the database and it is handled
--   and thrown with proper error message.
mkMSSQLTxErrorHandler :: (ErrorClass -> Bool) -> MSSQLTxError -> QErr

-- | The <tt><a>ODBCException</a> type has no </tt><a>ToJSON</a> instance.
--   This is an attempt to convert the odbc exception to a JSON
--   @<a>Value</a>
odbcExceptionToJSONValue :: ODBCException -> Value
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.MSSQL.SQL.Error.ErrorSubclass a)
instance GHC.Classes.Eq Hasura.Backends.MSSQL.SQL.Error.DataExceptionSubclass
instance GHC.Classes.Eq Hasura.Backends.MSSQL.SQL.Error.SyntaxErrorOrAccessViolationSubclass
instance GHC.Classes.Eq Hasura.Backends.MSSQL.SQL.Error.ErrorClass
instance GHC.Show.Show Hasura.Backends.MSSQL.SQL.Error.ErrorClass
instance GHC.Show.Show Hasura.Backends.MSSQL.SQL.Error.SyntaxErrorOrAccessViolationSubclass
instance GHC.Show.Show Hasura.Backends.MSSQL.SQL.Error.DataExceptionSubclass

module Data.Parser.Expires

-- | Extracts an absolute expiration time from a Expires header.
parseExpirationTime :: MonadError String m => Text -> m UTCTime

module Data.Environment

-- | Server process environment variables
newtype Environment
Environment :: Map String String -> Environment
getEnvironment :: IO Environment
maybeEnvironment :: Maybe Environment -> Environment
mkEnvironment :: [(String, String)] -> Environment
emptyEnvironment :: Environment
lookupEnv :: Environment -> String -> Maybe String
toList :: Environment -> [(String, String)]
redactEnv :: Environment -> Environment
instance GHC.Base.Monoid Data.Environment.Environment
instance GHC.Base.Semigroup Data.Environment.Environment
instance Data.Aeson.Types.ToJSON.ToJSON Data.Environment.Environment
instance GHC.Generics.Generic Data.Environment.Environment
instance GHC.Show.Show Data.Environment.Environment
instance GHC.Classes.Eq Data.Environment.Environment
instance Data.Aeson.Types.FromJSON.FromJSON Data.Environment.Environment


-- | A simple URL templating that enables interpolating environment
--   variables
module Data.URL.Template
newtype Variable
Variable :: Text -> Variable
[unVariable] :: Variable -> Text
printVariable :: Variable -> Text
data TemplateItem
TIText :: !Text -> TemplateItem
TIVariable :: !Variable -> TemplateItem
printTemplateItem :: TemplateItem -> Text

-- | A String with environment variables enclosed in '{{' and '}}'
--   <a>http://{{APP_HOST}}:{{APP_PORT}}/v1/api</a>
newtype URLTemplate
URLTemplate :: [TemplateItem] -> URLTemplate
[unURLTemplate] :: URLTemplate -> [TemplateItem]
printURLTemplate :: URLTemplate -> Text
mkPlainURLTemplate :: Text -> URLTemplate
parseURLTemplate :: Text -> Either String URLTemplate
renderURLTemplate :: Environment -> URLTemplate -> Either String Text
instance Data.Hashable.Class.Hashable Data.URL.Template.Variable
instance GHC.Generics.Generic Data.URL.Template.Variable
instance GHC.Classes.Eq Data.URL.Template.Variable
instance GHC.Show.Show Data.URL.Template.Variable
instance GHC.Generics.Generic Data.URL.Template.TemplateItem
instance GHC.Classes.Eq Data.URL.Template.TemplateItem
instance GHC.Show.Show Data.URL.Template.TemplateItem
instance Data.Hashable.Class.Hashable Data.URL.Template.URLTemplate
instance GHC.Generics.Generic Data.URL.Template.URLTemplate
instance GHC.Classes.Eq Data.URL.Template.URLTemplate
instance GHC.Show.Show Data.URL.Template.URLTemplate
instance Test.QuickCheck.Arbitrary.Arbitrary Data.URL.Template.URLTemplate
instance Data.Hashable.Class.Hashable Data.URL.Template.TemplateItem
instance Test.QuickCheck.Arbitrary.Arbitrary Data.URL.Template.Variable


-- | This module defines all missing instances of third party libraries.
module Hasura.Base.Instances
instance Language.Haskell.TH.Syntax.Lift Text.Regex.TDFA.Common.CompOption
instance Language.Haskell.TH.Syntax.Lift Text.Regex.TDFA.Common.DoPa
instance Language.Haskell.TH.Syntax.Lift Text.Regex.TDFA.Common.ExecOption
instance Language.Haskell.TH.Syntax.Lift Text.Regex.TDFA.Pattern.Pattern
instance Language.Haskell.TH.Syntax.Lift Text.Regex.TDFA.Pattern.PatternSet
instance Language.Haskell.TH.Syntax.Lift Text.Regex.TDFA.Pattern.PatternSetCharacterClass
instance Language.Haskell.TH.Syntax.Lift Text.Regex.TDFA.Pattern.PatternSetCollatingElement
instance Language.Haskell.TH.Syntax.Lift Text.Regex.TDFA.Pattern.PatternSetEquivalenceClass
instance (GHC.Base.Monoid d, Control.Monad.Fix.MonadFix m) => Control.Monad.Fix.MonadFix (Data.OpenApi.Declare.DeclareT d m)
instance Control.DeepSeq.NFData Data.URL.Template.Variable
instance Control.DeepSeq.NFData Data.URL.Template.TemplateItem
instance Control.DeepSeq.NFData Data.URL.Template.URLTemplate
instance Control.DeepSeq.NFData System.Cron.Types.StepField
instance Control.DeepSeq.NFData System.Cron.Types.RangeField
instance Control.DeepSeq.NFData System.Cron.Types.SpecificField
instance Control.DeepSeq.NFData System.Cron.Types.BaseField
instance Control.DeepSeq.NFData System.Cron.Types.CronField
instance Control.DeepSeq.NFData System.Cron.Types.MonthSpec
instance Control.DeepSeq.NFData System.Cron.Types.DayOfMonthSpec
instance Control.DeepSeq.NFData System.Cron.Types.DayOfWeekSpec
instance Control.DeepSeq.NFData System.Cron.Types.HourSpec
instance Control.DeepSeq.NFData System.Cron.Types.MinuteSpec
instance Control.DeepSeq.NFData System.Cron.Types.CronSchedule
instance (Language.Haskell.TH.Syntax.Lift k, Language.Haskell.TH.Syntax.Lift v) => Language.Haskell.TH.Syntax.Lift (Data.HashMap.Internal.HashMap k v)
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Data.HashSet.Internal.HashSet a)
instance (Data.GADT.Internal.GCompare f, Data.GADT.Internal.GCompare g) => Data.GADT.Internal.GCompare (Data.Functor.Product.Product f g)
instance Data.Aeson.Types.FromJSON.FromJSON System.Cron.Types.CronSchedule
instance Data.Aeson.Types.ToJSON.ToJSON System.Cron.Types.CronSchedule
instance Data.Aeson.Types.ToJSON.ToJSONKey Data.Void.Void
instance Database.PG.Query.Class.ToPrepArg System.Cron.Types.CronSchedule
instance Database.PG.Query.Class.FromCol System.Cron.Types.CronSchedule

module Data.Aeson.KeyMap.Extended
mapWithKey :: (Key -> v1 -> v2) -> KeyMap v1 -> KeyMap v2

module Data.Aeson.Extended
class ToJSONKeyValue a
toJSONKeyValue :: ToJSONKeyValue a => a -> (Key, Value)
class FromJSONKeyValue a
parseJSONKeyValue :: FromJSONKeyValue a => (Key, Value) -> Parser a

-- | Similar to <a>FromJSON</a>, except the parser can also source data
--   with which to construct <tt>a</tt> from a context <tt>ctx</tt>.
--   
--   This can be useful if the <tt>a</tt> value contains some data that is
--   not from the current piece of JSON (the <a>Value</a>). For example,
--   some data from higher up in the overall JSON graph, or from some
--   system context.
class FromJSONWithContext ctx a | a -> ctx
parseJSONWithContext :: FromJSONWithContext ctx a => ctx -> Value -> Parser a

-- | An optional key-value pair for encoding a JSON object.
--   
--   <pre>
--   object $ ["foo" .= 0] &lt;&gt; catMaybes [ "bar" .=? Nothing, "baz" .=? 2 ]
--   </pre>
(.=?) :: (ToJSON v, KeyValue kv) => Key -> Maybe v -> Maybe kv
infixr 8 .=?

-- | Map a <a>Parser</a> over a list, keeping the JSONPath context
mapWithJSONPath :: (a -> Parser b) -> [a] -> Parser [b]
encodeToStrictText :: ToJSON a => a -> Text
instance Data.Aeson.Extended.ToJSONKeyValue Data.Void.Void
instance Data.Aeson.Extended.ToJSONKeyValue a => Data.Aeson.Extended.ToJSONKeyValue (Data.Functor.Const.Const a b)


-- | A tiny mtl-style wrapper around <a>newUnique</a>.
module Control.Monad.Unique
class (Monad m) => MonadUnique m
newUnique :: MonadUnique m => m Unique
instance Control.Monad.Unique.MonadUnique GHC.Types.IO
instance Control.Monad.Unique.MonadUnique m => Control.Monad.Unique.MonadUnique (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Unique.MonadUnique m => Control.Monad.Unique.MonadUnique (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Unique.MonadUnique m => Control.Monad.Unique.MonadUnique (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Control.Monad.Unique.MonadUnique m) => Control.Monad.Unique.MonadUnique (Control.Monad.Trans.Writer.Strict.WriterT w m)

module Hasura.Incremental.Select

-- | The <a>Select</a> class provides a way to access subparts of a product
--   type using a reified <a>Selector</a>. A <tt><a>Selector</a> a b</tt>
--   is essentially a function from <tt>a</tt> to <tt>b</tt>, and indeed
--   <a>select</a> converts a <a>Selector</a> to such a function. However,
--   unlike functions, <a>Selector</a>s can be compared for equality using
--   <a>GEq</a> and ordered using <a>GCompare</a>.
--   
--   This is useful to implement dependency tracking, since it’s possible
--   to track in a reified form exactly which parts of a data structure are
--   used.
--   
--   Instances of <a>Select</a> can be automatically derived for record
--   types (just define an empty instance). The instance uses the magical
--   <a>HasField</a> constraints, and <a>Selector</a>s for the type can be
--   written using <tt>OverloadedLabels</tt>.
class (GCompare (Selector a)) => Select a where {
    type family Selector a :: Type -> Type;
    type Selector r = FieldS r;
}
select :: Select a => Selector a b -> a -> b
select :: (Select a, Selector a ~ FieldS a) => Selector a b -> a -> b

-- | The constant selector, which is useful for representing selectors into
--   data structures where all fields have the same type. Matching on a
--   value of type <tt><a>ConstS</a> k a b</tt> causes <tt>a</tt> and
--   <tt>b</tt> to unify, effectively “pinning” <tt>b</tt> to <tt>a</tt>.
data ConstS k a b
[ConstS] :: !k -> ConstS k a a
selectKey :: (Select a, Selector a ~ ConstS k v) => k -> a -> v
data FieldS r a
[FieldS] :: (KnownSymbol s, HasField s r a) => !Proxy s -> FieldS r a

-- | A <a>UniqueS</a> is, as the name implies, a globally-unique
--   <a>Selector</a>, which can be created using <a>newUniqueS</a>. If a
--   value of type <tt><a>UniqueS</a> a</tt> is found to be equal (via
--   <a>geq</a>) with another value of type <tt><a>UniqueS</a> b</tt>, then
--   <tt>a</tt> and <tt>b</tt> must be the same type. This effectively
--   allows the creation of a dynamically-extensible sum type, where new
--   constructors can be created at runtime using <a>newUniqueS</a>.
newtype UniqueS a
UniqueS :: Unique -> UniqueS a
newUniqueS :: MonadUnique m => m (UniqueS a)
data DMapS k f a
[DMapS] :: !k a -> DMapS k f (Maybe (f a))
instance GHC.Classes.Eq (Hasura.Incremental.Select.UniqueS a)
instance Data.GADT.Internal.GCompare k => Hasura.Incremental.Select.Select (Data.Dependent.Map.Internal.DMap k f)
instance Data.GADT.Internal.GEq k => Data.GADT.Internal.GEq (Hasura.Incremental.Select.DMapS k f)
instance Data.GADT.Internal.GCompare k => Data.GADT.Internal.GCompare (Hasura.Incremental.Select.DMapS k f)
instance Data.GADT.Internal.GEq Hasura.Incremental.Select.UniqueS
instance Data.GADT.Internal.GCompare Hasura.Incremental.Select.UniqueS
instance (GHC.Classes.Eq k, GHC.Classes.Ord k, Data.Hashable.Class.Hashable k) => Hasura.Incremental.Select.Select (Data.HashMap.Internal.HashMap k v)
instance (GHC.TypeLits.KnownSymbol s, GHC.Records.HasField s r a) => GHC.OverloadedLabels.IsLabel s (Hasura.Incremental.Select.FieldS r a)
instance Data.GADT.Internal.GEq (Hasura.Incremental.Select.FieldS r)
instance Data.GADT.Internal.GCompare (Hasura.Incremental.Select.FieldS r)
instance GHC.Classes.Eq k => Data.GADT.Internal.GEq (Hasura.Incremental.Select.ConstS k a)
instance GHC.Classes.Ord k => Data.GADT.Internal.GCompare (Hasura.Incremental.Select.ConstS k a)

module Hasura.RQL.Types.Endpoint.Trie

-- | Trie from <a>PathComponent</a>s to <tt>MultiMap</tt>s
type MultiMapPathTrie a k v = Trie (PathComponent a) (MultiMap k v)

-- | A component in a URL path: either a literal or a wildcard parameter
data PathComponent a
PathLiteral :: a -> PathComponent a
PathParam :: PathComponent a

-- | Result of matching a path <tt>[<a>PathComponent</a>] a</tt> and key
--   <tt>k</tt> in a <a>MultiMapPathTrie</a>.
--   
--   <a>MatchResult</a> is a lattice where <a>MatchNotFound</a> is the
--   bottom element and <a>MatchAmbiguous</a> is the top element:
--   
--   MatchAmbiguous / MatchFound v0 as0 MatchFound v1 as1 / MatchMissingKey
--   (ks0 &lt;&gt; ks1) / MatchMissingKey ks0 MatchMissingKey ks1 /
--   MatchNotFound
data MatchResult a k v

-- | Multiple results.
MatchAmbiguous :: MatchResult a k v

-- | A single unambiguous result. Returns the value found and a list of
--   parameter bindings.
MatchFound :: v -> [a] -> MatchResult a k v

-- | A path was found, but not a key. Returns a list of keys found.
MatchMissingKey :: NonEmpty k -> MatchResult a k v

-- | Path was not found in the <a>MultiMapPathTrie</a>.
MatchNotFound :: MatchResult a k v

-- | Look up the value at a path. <tt>PathParam</tt> matches any path
--   component. Returns a list of pairs containing the value found and
--   bindings for any <tt>PathParam</tt>s.
lookupPath :: (Eq a, Hashable a) => [a] -> Trie (PathComponent a) v -> [(v, [a])]

-- | Match a key <tt>k</tt> and path <tt>[a]</tt> against a
--   <tt>MultiMapPathTrie a k v</tt>
matchPath :: (Eq a, Eq k, Hashable k, Hashable a) => k -> [a] -> MultiMapPathTrie a k v -> MatchResult a k v

-- | A version of ambiguousPaths that attempts to group all ambiguous paths
--   that have overlapping endpoints
ambiguousPathsGrouped :: (Hashable a, Eq k, Hashable k, Ord v, Ord a) => MultiMapPathTrie a k v -> [(Set [PathComponent a], Set v)]
groupAmbiguousPaths :: (Ord a, Ord v) => [(Set [PathComponent a], Set v)] -> [(Set [PathComponent a], Set v)]

-- | Detect and return all ambiguous paths in the <tt>MultiMapPathTrie</tt>
--   A path <tt>p</tt> is ambiguous if <tt>matchPath k p</tt> can return
--   <tt>MatchAmbiguous</tt> for some <tt>k</tt>.
ambiguousPaths :: (Eq a, Hashable a, Eq k, Hashable k, Ord v) => MultiMapPathTrie a k v -> [([PathComponent a], Set v)]
instance GHC.Generics.Generic (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance (GHC.Show.Show v, GHC.Show.Show a, GHC.Show.Show k) => GHC.Show.Show (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance (GHC.Classes.Eq v, GHC.Classes.Eq a, GHC.Classes.Eq k) => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance GHC.Base.Semigroup (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance GHC.Base.Monoid (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSONKey (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)

module Hasura.RQL.Types.Network
data Network
Network :: [TlsAllow] -> Network
[networkTlsAllowlist] :: Network -> [TlsAllow]
emptyNetwork :: Network
data TlsAllow
TlsAllow :: String -> Maybe String -> Maybe [TlsPermission] -> TlsAllow
[taHost] :: TlsAllow -> String
[taSuffix] :: TlsAllow -> Maybe String
[taPermit] :: TlsAllow -> Maybe [TlsPermission]
data TlsPermission
SelfSigned :: TlsPermission
type AddHostToTLSAllowlist = TlsAllow
data DropHostFromTLSAllowlist
DropHostFromTLSAllowlist :: String -> DropHostFromTLSAllowlist
[_dhftaHost] :: DropHostFromTLSAllowlist -> String
instance GHC.Enum.Bounded Hasura.RQL.Types.Network.TlsPermission
instance GHC.Enum.Enum Hasura.RQL.Types.Network.TlsPermission
instance GHC.Generics.Generic Hasura.RQL.Types.Network.TlsPermission
instance GHC.Classes.Eq Hasura.RQL.Types.Network.TlsPermission
instance GHC.Read.Read Hasura.RQL.Types.Network.TlsPermission
instance GHC.Show.Show Hasura.RQL.Types.Network.TlsPermission
instance GHC.Generics.Generic Hasura.RQL.Types.Network.TlsAllow
instance GHC.Classes.Eq Hasura.RQL.Types.Network.TlsAllow
instance GHC.Read.Read Hasura.RQL.Types.Network.TlsAllow
instance GHC.Show.Show Hasura.RQL.Types.Network.TlsAllow
instance GHC.Generics.Generic Hasura.RQL.Types.Network.Network
instance GHC.Classes.Eq Hasura.RQL.Types.Network.Network
instance GHC.Show.Show Hasura.RQL.Types.Network.Network
instance GHC.Classes.Eq Hasura.RQL.Types.Network.DropHostFromTLSAllowlist
instance GHC.Show.Show Hasura.RQL.Types.Network.DropHostFromTLSAllowlist
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Network.DropHostFromTLSAllowlist
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Network.DropHostFromTLSAllowlist
instance Test.QuickCheck.Arbitrary.Arbitrary Hasura.RQL.Types.Network.Network
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Network.Network
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Network.Network
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Network.TlsAllow
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Network.TlsAllow
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Network.TlsPermission
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Network.TlsPermission

module Hasura.RQL.Types.ResultCustomization

-- | Mapping that can be provided to a ResultCustomizer to map top-level
--   field aliases that were not available at field parse time. E.g. for
--   aliases created in the remote server query for remote joins.
newtype AliasMapping
AliasMapping :: (Name -> Name) -> AliasMapping
[unAliasMapping] :: AliasMapping -> Name -> Name

-- | AliasMapping that maps a single field name to an alias
singletonAliasMapping :: Name -> Name -> AliasMapping

-- | Function to modify JSON values returned from the remote server e.g. to
--   map values of __typename fields to customized type names. The
--   customizer uses Maybe to allow short-circuiting subtrees where no
--   customizations are needed.
newtype ResultCustomizer
ResultCustomizer :: (AliasMapping -> Value -> Value) -> ResultCustomizer
[unResultCustomizer] :: ResultCustomizer -> AliasMapping -> Value -> Value

-- | Apply a ResultCustomizer to a JSON value
applyResultCustomizer :: ResultCustomizer -> Value -> Value

-- | Apply an AliasMapping to a ResultCustomizer.
applyAliasMapping :: AliasMapping -> ResultCustomizer -> ResultCustomizer

-- | Take a ResultCustomizer for a JSON subtree, and a fieldName, and
--   produce a ResultCustomizer for a parent object or array of objects
--   that applies the subtree customizer to the subtree at the given
--   fieldName.
modifyFieldByName :: Name -> ResultCustomizer -> ResultCustomizer

-- | Create a RemoteResultCustomizer that applies the typeNameMap to a JSON
--   string value, e.g. for use in customizing a __typename field value.
customizeTypeNameString :: HashMap Name Name -> ResultCustomizer
instance GHC.Base.Monoid Hasura.RQL.Types.ResultCustomization.AliasMapping
instance GHC.Base.Semigroup Hasura.RQL.Types.ResultCustomization.AliasMapping
instance GHC.Base.Monoid Hasura.RQL.Types.ResultCustomization.ResultCustomizer
instance GHC.Base.Semigroup Hasura.RQL.Types.ResultCustomization.ResultCustomizer

module Hasura.RQL.Types.Subscription

-- | CursorOrdering is used in the streaming subscriptions to specify how
--   to order the cursor.
data CursorOrdering
COAscending :: CursorOrdering
CODescending :: CursorOrdering
data SubscriptionType
Streaming :: SubscriptionType
LiveQuery :: SubscriptionType
instance GHC.Generics.Generic Hasura.RQL.Types.Subscription.CursorOrdering
instance GHC.Classes.Eq Hasura.RQL.Types.Subscription.CursorOrdering
instance GHC.Show.Show Hasura.RQL.Types.Subscription.CursorOrdering
instance GHC.Generics.Generic Hasura.RQL.Types.Subscription.SubscriptionType
instance GHC.Classes.Eq Hasura.RQL.Types.Subscription.SubscriptionType
instance GHC.Show.Show Hasura.RQL.Types.Subscription.SubscriptionType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Subscription.CursorOrdering

module Hasura.SQL.GeoJSON
data Position
Position :: !Double -> !Double -> !Maybe Double -> Position
withParsedArray :: FromJSON a => String -> (Vector a -> Parser b) -> Value -> Parser b
newtype Point
Point :: Position -> Point
[unPoint] :: Point -> Position
newtype MultiPoint
MultiPoint :: [Position] -> MultiPoint
[unMultiPoint] :: MultiPoint -> [Position]
data LineString
LineString :: !Position -> !Position -> ![Position] -> LineString
[_lsFirst] :: LineString -> !Position
[_lsSecond] :: LineString -> !Position
[_lsRest] :: LineString -> ![Position]
newtype MultiLineString
MultiLineString :: [LineString] -> MultiLineString
[unMultiLineString] :: MultiLineString -> [LineString]
data LinearRing
LinearRing :: !Position -> !Position -> !Position -> ![Position] -> LinearRing
[_pFirst] :: LinearRing -> !Position
[_pSecond] :: LinearRing -> !Position
[_pThird] :: LinearRing -> !Position
[_pRest] :: LinearRing -> ![Position]
newtype Polygon
Polygon :: [LinearRing] -> Polygon
[unPolygon] :: Polygon -> [LinearRing]
newtype MultiPolygon
MultiPolygon :: [Polygon] -> MultiPolygon
[unMultiPolygon] :: MultiPolygon -> [Polygon]
data CRSNameProps
CRSNameProps :: !Text -> CRSNameProps
[_cnpName] :: CRSNameProps -> !Text
data CRSLinkProps
CRSLinkProps :: !Text -> !Maybe Text -> CRSLinkProps
[_clpHref] :: CRSLinkProps -> !Text
[_clpType] :: CRSLinkProps -> !Maybe Text
data CRS
CRSName :: !CRSNameProps -> CRS
CRSLink :: !CRSLinkProps -> CRS
data GeometryWithCRS
GeometryWithCRS :: !Geometry -> !Maybe CRS -> GeometryWithCRS
[_gwcGeom] :: GeometryWithCRS -> !Geometry
[_gwcCrs] :: GeometryWithCRS -> !Maybe CRS
encToCoords :: ToJSON a => Text -> a -> Maybe CRS -> Value
newtype GeometryCollection
GeometryCollection :: [GeometryWithCRS] -> GeometryCollection
[unGeometryCollection] :: GeometryCollection -> [GeometryWithCRS]
data Geometry
GPoint :: !Point -> Geometry
GMultiPoint :: !MultiPoint -> Geometry
GLineString :: !LineString -> Geometry
GMultiLineString :: !MultiLineString -> Geometry
GPolygon :: !Polygon -> Geometry
GMultiPolygon :: !MultiPolygon -> Geometry
GGeometryCollection :: !GeometryCollection -> Geometry
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.GeometryWithCRS
instance GHC.Show.Show Hasura.SQL.GeoJSON.GeometryWithCRS
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.GeometryCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.GeometryCollection
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.GeometryCollection
instance GHC.Show.Show Hasura.SQL.GeoJSON.GeometryCollection
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Geometry
instance GHC.Show.Show Hasura.SQL.GeoJSON.Geometry
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.GeometryWithCRS
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.GeometryWithCRS
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.CRS
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.CRS
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.CRSLinkProps
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.CRSLinkProps
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.CRSNameProps
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.CRSNameProps
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Position
instance GHC.Show.Show Hasura.SQL.GeoJSON.Position
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.Point
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.Point
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Point
instance GHC.Show.Show Hasura.SQL.GeoJSON.Point
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.MultiPoint
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.MultiPoint
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.MultiPoint
instance GHC.Show.Show Hasura.SQL.GeoJSON.MultiPoint
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.LineString
instance GHC.Show.Show Hasura.SQL.GeoJSON.LineString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.MultiLineString
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.MultiLineString
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.MultiLineString
instance GHC.Show.Show Hasura.SQL.GeoJSON.MultiLineString
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.LinearRing
instance GHC.Show.Show Hasura.SQL.GeoJSON.LinearRing
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.Polygon
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.Polygon
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Polygon
instance GHC.Show.Show Hasura.SQL.GeoJSON.Polygon
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.MultiPolygon
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.MultiPolygon
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.MultiPolygon
instance GHC.Show.Show Hasura.SQL.GeoJSON.MultiPolygon
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.CRSNameProps
instance GHC.Show.Show Hasura.SQL.GeoJSON.CRSNameProps
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.CRSLinkProps
instance GHC.Show.Show Hasura.SQL.GeoJSON.CRSLinkProps
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.CRS
instance GHC.Show.Show Hasura.SQL.GeoJSON.CRS
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.LinearRing
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.LinearRing
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.LineString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.LineString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.Position
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.Position

module Hasura.SQL.Time
data ZonedTimeOfDay
ZonedTimeOfDay :: TimeOfDay -> TimeZone -> ZonedTimeOfDay
[ztodTime] :: ZonedTimeOfDay -> TimeOfDay
[ztodZone] :: ZonedTimeOfDay -> TimeZone
utc :: TimeZone
zonedTimeOfDay :: Text -> Parser ZonedTimeOfDay
instance GHC.Classes.Eq Hasura.SQL.Time.ZonedTimeOfDay
instance GHC.Show.Show Hasura.SQL.Time.ZonedTimeOfDay
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.Time.ZonedTimeOfDay

module Hasura.SQL.Value
data TxtEncodedVal
TENull :: TxtEncodedVal
TELit :: !Text -> TxtEncodedVal
instance GHC.Generics.Generic Hasura.SQL.Value.TxtEncodedVal
instance GHC.Classes.Eq Hasura.SQL.Value.TxtEncodedVal
instance GHC.Show.Show Hasura.SQL.Value.TxtEncodedVal
instance Data.Hashable.Class.Hashable Hasura.SQL.Value.TxtEncodedVal
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.Value.TxtEncodedVal
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.Value.TxtEncodedVal

module Hasura.SQL.WKT
newtype WKT
WKT :: Text -> WKT
[getWKT] :: WKT -> Text
class ToWKT a
toWKT :: ToWKT a => a -> Either QErr WKT
mkWKT :: Text -> Either QErr Text -> Either QErr WKT
parens :: Text -> Text
commaSeparated :: [Position] -> Either QErr Text
positionToText :: Position -> Either QErr Text
lineStringToText :: LineString -> Either QErr Text
linearRingToText :: LinearRing -> Either QErr Text
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.Point
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.MultiPoint
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.LineString
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.MultiLineString
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.Polygon
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.MultiPolygon
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.GeometryCollection
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.Geometry
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.GeometryWithCRS

module Hasura.Server.Init.Arg.PrettyPrinter
mkEnvVarDoc :: [(String, String)] -> Doc
mkExamplesDoc :: [[String]] -> Doc


-- | This module exports an OpenAPI specification for the GraphQL Engine
--   metadata API.
--   
--   The OpenAPI specification for metadata is experimental and incomplete.
--   Please do not incorporate it into essential workflows at this time.
module Hasura.Server.MetadataOpenAPI

-- | An OpenApi document includes "schemas" that describe the data that may
--   be produced or consumed by an API. It can also include "paths" which
--   describe REST endpoints, and the document can include other API
--   metadata. This example only includes schemas.
--   
--   Throws an error if any schema listed in <a>openApiSchemas</a> does not
--   have a name.
--   
--   The OpenAPI specification for metadata is experimental and incomplete.
--   Please do not incorporate it into essential workflows at this time.
metadataOpenAPI :: OpenApi

-- | All metadata DTOs should be listed here. Schemas in this list must be
--   named! Some autodocodec combinators apply names for you, like
--   <tt>object</tt>. Otherwise you can use the <tt>named</tt> combinator
--   to apply a name.
--   
--   As far as I can tell it is necessary to explicitly list all of the
--   data types that should be included in the OpenApi document with their
--   names. It would be nice to provide only a top-level type
--   (<tt>Metadata</tt> in this case), and have all of the types referenced
--   by that type included automatically; but I haven't seen a way to do
--   that.
openApiSchemas :: [NamedSchema]

-- | Introspect a given <a>NamedSchema</a> to get its name, and return the
--   name with the unwrapped schema. (NamedSchema wraps a pair of an
--   <a>Schema</a> and an optional name.)
--   
--   Throws an exception if the named schema has no name. If this happens
--   to you then use autodocodec's <tt>named</tt> combinator to apply a
--   name to your codec.
applySchemaName :: NamedSchema -> (Text, Schema)
toNamedSchema :: HasCodec a => Proxy a -> NamedSchema

module Hasura.Server.Metrics

-- | A specification of the metrics tracked by the server.
--   
--   The use of the "unit" type () for the "tag structure" type parameter
--   of a metric indicates that we prohibit that metric from being
--   annotated with tags.
data ServerMetricsSpec :: Symbol -> MetricType -> Type -> Type

-- | Current Number of active Warp threads
[WarpThreads] :: ServerMetricsSpec "warp_threads" 'GaugeType ()

-- | Current number of active websocket connections
[WebsocketConnections] :: ServerMetricsSpec "websocket_connections" 'GaugeType ()

-- | Current number of active subscriptions
[ActiveSubscriptions] :: ServerMetricsSpec "active_subscriptions" 'GaugeType ()

-- | Total Number of events fetched from last 'Event Trigger Fetch'
[NumEventsFetchedPerBatch] :: ServerMetricsSpec "events_fetched_per_batch" 'DistributionType ()

-- | Current number of Event trigger's HTTP workers in process
[NumEventHTTPWorkers] :: ServerMetricsSpec "num_event_trigger_http_workers" 'GaugeType ()

-- | Time (in seconds) between the 'Event Trigger Fetch' from DB and the
--   processing of the event
[EventQueueTime] :: ServerMetricsSpec "event_queue_time" 'DistributionType ()

-- | The current schema cache metadata resource version
[SchemaCacheMetadataResourceVersion] :: ServerMetricsSpec "schema_cache_metadata_resource_version" 'GaugeType ()

-- | Current number active live queries
[ActiveLiveQueries] :: ServerMetricsSpec "active_livequeries" 'GaugeType ()

-- | Current number of streaming subscriptions
[ActiveStreaming] :: ServerMetricsSpec "active_streaming_subscriptions" 'GaugeType ()

-- | Mutable references for the server metrics. See
--   <a>ServerMetricsSpec</a> for a description of each metric.
data ServerMetrics
ServerMetrics :: !Gauge -> !Gauge -> !Gauge -> !Distribution -> !Gauge -> !Distribution -> !Gauge -> !Gauge -> !Gauge -> ServerMetrics
[smWarpThreads] :: ServerMetrics -> !Gauge
[smWebsocketConnections] :: ServerMetrics -> !Gauge
[smActiveSubscriptions] :: ServerMetrics -> !Gauge
[smNumEventsFetchedPerBatch] :: ServerMetrics -> !Distribution
[smNumEventHTTPWorkers] :: ServerMetrics -> !Gauge
[smEventQueueTime] :: ServerMetrics -> !Distribution
[smSchemaCacheMetadataResourceVersion] :: ServerMetrics -> !Gauge
[smActiveLiveQueries] :: ServerMetrics -> !Gauge
[smActiveStreamingSubscriptions] :: ServerMetrics -> !Gauge
createServerMetrics :: Store ServerMetricsSpec -> IO ServerMetrics

module Hasura.Server.Name
_Bool :: Name
_Double :: Name
_float8 :: Name
_Number :: Name
_numeric :: Name


-- | Mutable references for Prometheus metrics.
--   
--   These metrics are independent from the metrics in
--   <a>Hasura.Server.Metrics</a>.
module Hasura.Server.Prometheus

-- | Mutable references for Prometheus metrics.
data PrometheusMetrics
PrometheusMetrics :: ConnectionsGauge -> Gauge -> GraphQLRequestMetrics -> EventTriggerMetrics -> PrometheusMetrics
[pmConnections] :: PrometheusMetrics -> ConnectionsGauge
[pmActiveSubscriptions] :: PrometheusMetrics -> Gauge
[pmGraphQLRequestMetrics] :: PrometheusMetrics -> GraphQLRequestMetrics
[pmEventTriggerMetrics] :: PrometheusMetrics -> EventTriggerMetrics
data GraphQLRequestMetrics
GraphQLRequestMetrics :: Counter -> Counter -> Counter -> Counter -> Counter -> Histogram -> Histogram -> GraphQLRequestMetrics
[gqlRequestsQuerySuccess] :: GraphQLRequestMetrics -> Counter
[gqlRequestsQueryFailure] :: GraphQLRequestMetrics -> Counter
[gqlRequestsMutationSuccess] :: GraphQLRequestMetrics -> Counter
[gqlRequestsMutationFailure] :: GraphQLRequestMetrics -> Counter
[gqlRequestsUnknownFailure] :: GraphQLRequestMetrics -> Counter
[gqlExecutionTimeSecondsQuery] :: GraphQLRequestMetrics -> Histogram
[gqlExecutionTimeSecondsMutation] :: GraphQLRequestMetrics -> Histogram
data EventTriggerMetrics
EventTriggerMetrics :: Gauge -> Histogram -> EventTriggerMetrics
[eventTriggerHTTPWorkers] :: EventTriggerMetrics -> Gauge
[eventQueueTimeSeconds] :: EventTriggerMetrics -> Histogram

-- | Create dummy mutable references without associating them to a metrics
--   store.
makeDummyPrometheusMetrics :: IO PrometheusMetrics
makeDummyGraphQLRequestMetrics :: IO GraphQLRequestMetrics
makeDummyEventTriggerMetrics :: IO EventTriggerMetrics

-- | A mutable reference for atomically sampling the number of websocket
--   connections and number of threads forked by the warp webserver.
--   
--   Because we derive the number of (non-websocket) HTTP connections by
--   the difference of these two metrics, we must sample them
--   simultaneously, otherwise we might report a negative number of HTTP
--   connections.
newtype ConnectionsGauge
ConnectionsGauge :: IORef Connections -> ConnectionsGauge
data Connections
Connections :: Int64 -> Int64 -> Connections
[connWarpThreads] :: Connections -> Int64
[connWebsockets] :: Connections -> Int64
newConnectionsGauge :: IO ConnectionsGauge
readConnectionsGauge :: ConnectionsGauge -> IO Connections
incWarpThreads :: ConnectionsGauge -> IO ()
decWarpThreads :: ConnectionsGauge -> IO ()
incWebsocketConnections :: ConnectionsGauge -> IO ()
decWebsocketConnections :: ConnectionsGauge -> IO ()
modifyConnectionsGauge :: (Connections -> Connections) -> ConnectionsGauge -> IO ()


-- | Counters used in telemetry collection. Additional counters can be
--   added here.and serviced in <a>Hasura.Server.Telemetry</a>.
module Hasura.Server.Telemetry.Counters

-- | The properties that characterize this request. The dimensions over
--   which we collect metrics for each serviced request.
data RequestDimensions
RequestDimensions :: !QueryType -> !Locality -> !Transport -> RequestDimensions
[$sel:telemQueryType:RequestDimensions] :: RequestDimensions -> !QueryType
[$sel:telemLocality:RequestDimensions] :: RequestDimensions -> !Locality
[$sel:telemTransport:RequestDimensions] :: RequestDimensions -> !Transport

-- | Accumulated time metrics.
data RequestTimings
RequestTimings :: !Seconds -> !Seconds -> RequestTimings

-- | Time spent waiting on PG/remote http calls
[$sel:telemTimeIO:RequestTimings] :: RequestTimings -> !Seconds

-- | Total service time for request (including
--   <a>$sel:telemTimeIO:RequestTimings</a>)
[$sel:telemTimeTot:RequestTimings] :: RequestTimings -> !Seconds

-- | <a>RequestTimings</a> along with the count
data RequestTimingsCount
RequestTimingsCount :: !Seconds -> !Seconds -> !Word -> RequestTimingsCount
[$sel:telemTimeIO:RequestTimingsCount] :: RequestTimingsCount -> !Seconds
[$sel:telemTimeTot:RequestTimingsCount] :: RequestTimingsCount -> !Seconds

-- | The number of requests that have contributed to the accumulated
--   timings above. So e.g. <tt>telemTimeTot / count</tt> would give the
--   mean service time.
[$sel:telemCount:RequestTimingsCount] :: RequestTimingsCount -> !Word

-- | Internal. Counts and durations across many <a>RequestDimensions</a>.
--   
--   NOTE: We use the global mutable variable pattern for metric collection
--   counters for convenience at collection site (don't wear hairshirts
--   that discourage useful reporting).
requestCounters :: IORef (HashMap (RequestDimensions, RunningTimeBucket) RequestTimingsCount)

-- | Internal. Since these metrics are accumulated while graphql-engine is
--   running and sent periodically, we need to include a tag that is unique
--   for each start of hge. This lets us e.g. query for just the latest
--   uploaded sample for each start of hge.
--   
--   We use time rather than a UUID since having this be monotonic
--   increasing is convenient.
approxStartTime :: POSIXTime

-- | Was this request a mutation (involved DB writes)?
data QueryType
Mutation :: QueryType
Query :: QueryType

-- | Was this a PG local query, or did it involve remote execution?
data Locality

-- | No data was fetched
Empty :: Locality

-- | local DB data
Local :: Locality

-- | remote schema
Remote :: Locality

-- | mixed
Heterogeneous :: Locality

-- | Was this a query over http or websockets?
data Transport
HTTP :: Transport
WebSocket :: Transport

-- | The timings and counts here were from requests with total time longer
--   than <a>$sel:bucketGreaterThan:RunningTimeBucket</a> (but less than
--   any larger bucket cutoff times).
newtype RunningTimeBucket
RunningTimeBucket :: Seconds -> RunningTimeBucket
[$sel:bucketGreaterThan:RunningTimeBucket] :: RunningTimeBucket -> Seconds
totalTimeBuckets :: [RunningTimeBucket]

-- | Save a timing metric sample in our in-memory store. These will be
--   accumulated and uploaded periodically in
--   <a>Hasura.Server.Telemetry</a>.
recordTimingMetric :: MonadIO m => RequestDimensions -> RequestTimings -> m ()

-- | The final shape of this part of our metrics data JSON. This should
--   allow reasonably efficient querying using GIN indexes and JSONB
--   containment operations (which treat arrays as sets).
data ServiceTimingMetrics
ServiceTimingMetrics :: Int -> [ServiceTimingMetric] -> ServiceTimingMetrics

-- | This is set to a new unique value when the counters reset (e.g.
--   because of a restart)
[$sel:collectionTag:ServiceTimingMetrics] :: ServiceTimingMetrics -> Int
[$sel:serviceTimingMetrics:ServiceTimingMetrics] :: ServiceTimingMetrics -> [ServiceTimingMetric]
data ServiceTimingMetric
ServiceTimingMetric :: RequestDimensions -> RunningTimeBucket -> RequestTimingsCount -> ServiceTimingMetric
[$sel:dimensions:ServiceTimingMetric] :: ServiceTimingMetric -> RequestDimensions
[$sel:bucket:ServiceTimingMetric] :: ServiceTimingMetric -> RunningTimeBucket
[$sel:metrics:ServiceTimingMetric] :: ServiceTimingMetric -> RequestTimingsCount
dumpServiceTimingMetrics :: MonadIO m => m ServiceTimingMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.RequestDimensions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.RequestDimensions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Enum.Enum Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.Locality
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.Locality
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.Locality
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.Locality
instance GHC.Enum.Enum Hasura.Server.Telemetry.Counters.Locality
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.Transport
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.Transport
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.Transport
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.Transport
instance GHC.Enum.Enum Hasura.Server.Telemetry.Counters.Transport
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.RequestDimensions
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.RequestDimensions
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.RequestDimensions
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.RequestDimensions
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.RequestDimensions
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.Transport
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.Transport
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.Transport
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.Locality
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.Locality
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.Locality
instance GHC.Base.Semigroup Hasura.Server.Telemetry.Counters.Locality
instance GHC.Base.Monoid Hasura.Server.Telemetry.Counters.Locality
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.QueryType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.QueryType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Base.Semigroup Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Base.Semigroup Hasura.Server.Telemetry.Counters.RequestTimings

module Hasura.Server.Utils
jsonHeader :: Header
sqlHeader :: Header
gzipHeader :: Header
userRoleHeader :: IsString a => a
deprecatedAccessKeyHeader :: IsString a => a
adminSecretHeader :: IsString a => a
userIdHeader :: IsString a => a
requestIdHeader :: IsString a => a
useBackendOnlyPermissionsHeader :: IsString a => a
getRequestHeader :: HeaderName -> [Header] -> Maybe ByteString
parseStringAsBool :: String -> Either String Bool

-- | Quotes a regex using Template Haskell so syntax errors can be reported
--   at compile-time.
quoteRegex :: CompOption -> ExecOption -> String -> Q (TExp Regex)
fmapL :: (a -> a') -> Either a b -> Either a' b
generateFingerprint :: IO Text
httpExceptToJSON :: HttpException -> Value
commonClientHeadersIgnored :: IsString a => [a]
sessionVariablePrefix :: Text
isSessionVariable :: Text -> Bool
isReqUserId :: Text -> Bool
mkClientHeadersForward :: [Header] -> [Header]
mkSetCookieHeaders :: Response a -> ResponseHeaders
filterRequestHeaders :: [Header] -> [Header]
filterHeaders :: HashSet HeaderName -> [Header] -> [Header]

-- | The version integer
data APIVersion
VIVersion1 :: APIVersion
VIVersion2 :: APIVersion
englishList :: Text -> NonEmpty Text -> Text
makeReasonMessage :: [a] -> (a -> Text) -> Text
executeJSONPath :: JSONPath -> Value -> IResult Value
sha1 :: ByteString -> ByteString
cryptoHash :: ToJSON a => a -> ByteString
readIsoLevel :: String -> Either String TxIsolation
parseConnLifeTime :: Maybe NominalDiffTime -> Maybe NominalDiffTime

-- | The environment variables that were moved to metadata. These
--   environment variables are available if a v1 hasura project is run an
--   v2 hasura server. These environment variables are marked as deprecated
--   only when the v1 hasura project is migrated to v2 project.
newtype EnvVarsMovedToMetadata
EnvVarsMovedToMetadata :: [String] -> EnvVarsMovedToMetadata
[unEnvVarsMovedToMetadata] :: EnvVarsMovedToMetadata -> [String]

-- | These env vars are completely deprecated
newtype DeprecatedEnvVars
DeprecatedEnvVars :: [String] -> DeprecatedEnvVars
[unDeprecatedEnvVars] :: DeprecatedEnvVars -> [String]
envVarsMovedToMetadata :: EnvVarsMovedToMetadata
deprecatedEnvVars :: DeprecatedEnvVars
sensitiveHeaders :: HashSet HeaderName
redactSensitiveHeader :: Header -> Header
instance GHC.Classes.Eq Hasura.Server.Utils.APIVersion
instance GHC.Show.Show Hasura.Server.Utils.APIVersion
instance GHC.Show.Show Hasura.Server.Utils.EnvVarsMovedToMetadata
instance GHC.Show.Show Hasura.Server.Utils.DeprecatedEnvVars
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Utils.APIVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Utils.APIVersion


-- | CORS (Cross Origin Resource Sharing) related configuration
module Hasura.Server.Cors
data DomainParts
DomainParts :: !Text -> !Text -> !Maybe Int -> DomainParts
[wdScheme] :: DomainParts -> !Text
[wdHost] :: DomainParts -> !Text
[wdPort] :: DomainParts -> !Maybe Int
data Domains
Domains :: !HashSet Text -> !HashSet DomainParts -> Domains
[dmFqdns] :: Domains -> !HashSet Text
[dmWildcards] :: Domains -> !HashSet DomainParts
data CorsConfig
CCAllowAll :: CorsConfig
CCAllowedOrigins :: Domains -> CorsConfig
CCDisabled :: Bool -> CorsConfig
isCorsDisabled :: CorsConfig -> Bool
readCorsDomains :: String -> Either String CorsConfig
data CorsPolicy
CorsPolicy :: !CorsConfig -> ![Text] -> !Int -> CorsPolicy
[cpConfig] :: CorsPolicy -> !CorsConfig
[cpMethods] :: CorsPolicy -> ![Text]
[cpMaxAge] :: CorsPolicy -> !Int
mkDefaultCorsPolicy :: CorsConfig -> CorsPolicy
inWildcardList :: Domains -> Text -> Bool

-- | Parsers for wildcard domains
runParser :: Parser a -> Text -> Either String a
parseOrigin :: Text -> Either String DomainParts
originParser :: Parser DomainParts
parseOptWildcardDomain :: Text -> Either String (Either Text DomainParts)
domainParser :: Maybe (Parser Text) -> Parser DomainParts
instance GHC.Classes.Eq Hasura.Server.Cors.CorsConfig
instance GHC.Show.Show Hasura.Server.Cors.CorsConfig
instance GHC.Classes.Eq Hasura.Server.Cors.CorsPolicy
instance GHC.Show.Show Hasura.Server.Cors.CorsPolicy
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Cors.CorsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Cors.CorsConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Cors.Domains
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Cors.Domains
instance GHC.Classes.Eq Hasura.Server.Cors.Domains
instance GHC.Show.Show Hasura.Server.Cors.Domains
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Cors.DomainParts
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Cors.DomainParts
instance Data.Hashable.Class.Hashable Hasura.Server.Cors.DomainParts
instance GHC.Generics.Generic Hasura.Server.Cors.DomainParts
instance GHC.Classes.Eq Hasura.Server.Cors.DomainParts
instance GHC.Show.Show Hasura.Server.Cors.DomainParts

module Hasura.Server.Middleware
corsMiddleware :: CorsPolicy -> Middleware

module Hasura.Server.Compression
data CompressionType
CTGZip :: CompressionType
compressionTypeToTxt :: CompressionType -> Text

-- | Maybe compress the response body
compressResponse :: RequestHeaders -> ByteString -> (ByteString, Maybe Header, Maybe CompressionType)

-- | Which, if any, compressed encodings can the client accept?
--   
--   
--   <a>https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding</a>
getAcceptedCompression :: RequestHeaders -> Maybe CompressionType
instance GHC.Classes.Eq Hasura.Server.Compression.CompressionType
instance GHC.Show.Show Hasura.Server.Compression.CompressionType

module Hasura.Server.Auth.JWT.Internal

-- | Helper functions to decode Text to JWK
parseHmacKey :: Text -> Int64 -> Either Text JWK
parseRsaKey :: Text -> Either Text JWK
parseEdDSAKey :: Text -> Either Text JWK

-- | Helper functions to decode PEM bytestring to RSA public key
fromRawPem :: ByteString -> Either Text JWK
fromPkcsPem :: ByteString -> Either Text PubKey
fromX509Pem :: ByteString -> Either Text PubKey
pubKeyToJwk :: PubKey -> Either Text JWK
getAtleastOne :: Text -> [a] -> Either Text a
calculateSize :: Integer -> Int


-- | This module calculates parameterized query hash, which is a way to
--   hash an incoming query (after resolving variables) with all leaf nodes
--   (i.e. scalar values) discarded. In other words, two queries having the
--   same parameterized query hash are essentially the same query but may
--   differ in leaf values.
--   
--   For example:
--   
--   <ol>
--   <li>query { authors (where: {id: {_eq: 2}}) { id name } }</li>
--   <li>query { authors (where: {id: {_eq: 203943}}) { id name } }</li>
--   <li>query { authors (where: {id: {_eq: $id}}) { id name } }</li>
--   </ol>
--   
--   For any value of <a>id</a>
--   
--   <ol>
--   <li>query { authors (where: $whereBoolExp) { id name } }</li>
--   </ol>
--   
--   only when <tt>whereBoolExp</tt> is of the form of
--   
--   { "id": { "_eq": <a>id</a> } }
--   
--   All the above queries should result in the same parameterized query
--   hash.
--   
--   The following steps are done to calculate the parameterized query
--   hash:
--   
--   <ol>
--   <li>Normalize the GraphQL query by substituting the variables (if any)
--   in appropriate places.</li>
--   <li>Substitute any scalar GraphQL values (Int, Float, Enum, String and
--   Boolean) to null</li>
--   <li>For input objects and list, traverse through them and do step no
--   2.</li>
--   <li>Calculate the hash of the query obtained from step 3.</li>
--   </ol>
--   
--   Note: Parameterized query hash is a PRO only feature
module Hasura.GraphQL.ParameterizedQueryHash

-- | a set of parameterized query hashes attached to a request this type
--   exists because a simple list of <tt>ParameterisedQueryHash</tt>es
--   won't let us log a single-request batch and a single non-batched
--   request differently. the log format uses json lists for requests
--   executed in batched mode, for fields like <tt>query</tt>, but not for
--   requests in single mode (e.g. <tt>query: "..."</tt> vs <tt>query:
--   ["..."]</tt>) and so to conform to that, we capture the whole _set_ of
--   parameterised query hashes when it's created, tagging it with
--   information about how it was created (i.e. from a batched request, a
--   single request, etc.)
data ParameterizedQueryHashList

-- | an empty query hash set, either for an operation that does not produce
--   query hashes, or due to failure in operation execution
PQHSetEmpty :: ParameterizedQueryHashList

-- | a query hash set consisting of a single element, corresponding to e.g.
--   a single (non-batched) graphql request
PQHSetSingleton :: !ParameterizedQueryHash -> ParameterizedQueryHashList

-- | a query hash set associated to a batched request note that this does
--   not need to contain multiple query hashes: it is possible for a batch
--   to contain only one request
PQHSetBatched :: ![ParameterizedQueryHash] -> ParameterizedQueryHashList

-- | we use something that explicitly produces an <a>Object</a> instead of
--   writing a <a>ToJSON</a> instance. in the latter case, functions
--   consuming the output of <a>toJSON</a> would have to perform a partial
--   pattern-match on the <a>Value</a> output to extract a JSON object from
--   it. for the other patterns, it would have to either throw a runtime
--   error on or silently ignore the other patterns, and the latter choice
--   would cause a silent failure if the <a>ToJSON</a> instance were
--   modified to no longer always return objects
parameterizedQueryHashListToObject :: ParameterizedQueryHashList -> Object
newtype ParameterizedQueryHash
ParameterizedQueryHash :: ByteString -> ParameterizedQueryHash
[unParamQueryHash] :: ParameterizedQueryHash -> ByteString
normalizeSelectionSet :: SelectionSet NoFragments Variable -> SelectionSet NoFragments Void
calculateParameterizedQueryHash :: SelectionSet NoFragments Variable -> ParameterizedQueryHash
mkUnsafeParameterizedQueryHash :: Text -> ParameterizedQueryHash
instance GHC.Classes.Eq Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash
instance GHC.Show.Show Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash
instance GHC.Classes.Eq Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHashList
instance GHC.Show.Show Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHashList
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash


-- | This module implements <i>fragment inlining</i>, which converts all
--   fragment spreads in a GraphQL query to inline fragments. For example,
--   given a query like
--   
--   <pre>
--   query {
--     users {
--       id
--       ...userFields
--     }
--   }
--   
--   fragment userFields on User {
--     name
--     favoriteColor
--   }
--   </pre>
--   
--   the fragment inliner will convert it to this:
--   
--   <pre>
--   query {
--     users {
--       id
--       ... on User {
--         name
--         favoriteColor
--       }
--     }
--   }
--   </pre>
--   
--   This is a straightforward and mechanical transformation, but it
--   simplifies further processing, since we catch unbound fragments and
--   recursive fragment definitions early in the pipeline, so parsing does
--   not have to worry about it. In that sense, fragment inlining is
--   similar to the variable resolution pass performed by
--   <a>Hasura.GraphQL.Execute.Resolve</a>, but for fragment definitions
--   rather than variables.
module Hasura.GraphQL.Execute.Inline

-- | Internal bookkeeping used during inlining.
data InlineEnv
InlineEnv :: HashMap Name FragmentDefinition -> [Name] -> InlineEnv

-- | All known fragment definitions.
[_ieFragmentDefinitions] :: InlineEnv -> HashMap Name FragmentDefinition

-- | Fragments we’re currently inlining higher up in the call stack, used
--   to detect fragment cycles.
[_ieFragmentStack] :: InlineEnv -> [Name]

-- | Internal bookkeeping used during inlining.
newtype InlineState
InlineState :: HashMap Name (InlineFragment NoFragments Name) -> InlineState

-- | A cache of fragment definitions we’ve already inlined, so we don’t
--   need to inline them again.
[_isFragmentCache] :: InlineState -> HashMap Name (InlineFragment NoFragments Name)
ieFragmentStack :: Lens' InlineEnv [Name]
isFragmentCache :: Iso' InlineState (HashMap Name (InlineFragment NoFragments Name))
type MonadInline m = (MonadError QErr m, MonadReader InlineEnv m, MonadState InlineState m)

-- | Inlines all fragment spreads in a <a>SelectionSet</a>; see the module
--   documentation for <a>Hasura.GraphQL.Execute.Inline</a> for details.
inlineSelectionSet :: (MonadError QErr m, Foldable t) => t FragmentDefinition -> SelectionSet FragmentSpread Name -> m (SelectionSet NoFragments Name)
inlineSelection :: MonadInline m => Selection FragmentSpread Name -> m (Selection NoFragments Name)
inlineFragmentSpread :: MonadInline m => FragmentSpread Name -> m (InlineFragment NoFragments Name)

module Hasura.GraphQL.Transport.HTTP.Protocol
newtype GQLExecDoc
GQLExecDoc :: [ExecutableDefinition Name] -> GQLExecDoc
[unGQLExecDoc] :: GQLExecDoc -> [ExecutableDefinition Name]
newtype OperationName
OperationName :: Name -> OperationName
[_unOperationName] :: OperationName -> Name
type VariableValues = HashMap Name Value

-- | <a>https://graphql.org/learn/serving-over-http/#post-request</a>
--   
--   See <a>GQLReqParsed</a> for invariants.
data GQLReq a
GQLReq :: !Maybe OperationName -> !a -> !Maybe VariableValues -> GQLReq a
[_grOperationName] :: GQLReq a -> !Maybe OperationName
[_grQuery] :: GQLReq a -> !a
[_grVariables] :: GQLReq a -> !Maybe VariableValues

-- | Batched queries are sent as a JSON array of <a>GQLReq</a> records.
--   This newtype exists to support the unusual JSON encoding.
--   
--   See <a>https://github.com/hasura/graphql-engine/issues/1812</a>.
data GQLBatchedReqs a
GQLSingleRequest :: a -> GQLBatchedReqs a
GQLBatchedReqs :: [a] -> GQLBatchedReqs a
newtype GQLQueryText
GQLQueryText :: Text -> GQLQueryText
[_unGQLQueryText] :: GQLQueryText -> Text

-- | We've not yet parsed the graphql query string parameter of the POST.
type GQLReqUnparsed = GQLReq GQLQueryText

-- | Invariants:
--   
--   <ul>
--   <li>when <a>_grOperationName</a> is <tt>Nothing</tt>, <a>_grQuery</a>
--   contains exactly one <tt>ExecutableDefinitionOperation</tt> (and zero
--   or more <tt>ExecutableDefinitionFragment</tt>)</li>
--   <li>when <a>_grOperationName</a> is present, there is a corresponding
--   <tt>ExecutableDefinitionOperation</tt> in <a>_grQuery</a></li>
--   </ul>
type GQLReqParsed = GQLReq GQLExecDoc
type ReqsText = GQLBatchedReqs (GQLReq GQLQueryText)

-- | A simplified form of <a>GQLReqParsed</a> which is more ergonomic in
--   particular for APIs that act as graphql <i>clients</i> (e.g. in remote
--   relationship execution). This is a "desugared" request in which
--   fragments have been inlined (see <tt>inlineSelectionSet</tt>), and the
--   operation (<a>_grOperationName</a>) to be executed is the only payload
--   (in contrast to a <a>ExecutableDocument</a> with possibly many named
--   operations).
--   
--   <a>_grOperationName</a> is essentially ignored here, but should
--   correspond with <tt>_todName</tt> if present.
--   
--   These could maybe benefit from an HKD refactoring.
type GQLReqOutgoing = GQLReq SingleOperation

-- | A single graphql operation to be executed, with fragment definitions
--   inlined. This is the simplified form of <a>GQLExecDoc</a> or
--   <a>ExecutableDocument</a>:
type SingleOperation = TypedOperationDefinition NoFragments Name
renderGQLReqOutgoing :: GQLReqOutgoing -> GQLReqUnparsed

-- | Obtain the actual single operation to be executed, from the possibly-
--   multi-operation document, validating per the spec and inlining any
--   fragment definitions (pre-defined parts of a graphql query) at
--   fragment spreads (locations where fragments are "spliced"). See:
--   
--   <a>https://spec.graphql.org/June2018/#sec-Executable-Definitions</a>
--   and... <a>https://graphql.org/learn/serving-over-http/</a>
getSingleOperation :: MonadError QErr m => GQLReqParsed -> m SingleOperation
toParsed :: MonadError QErr m => GQLReqUnparsed -> m GQLReqParsed
encodeGQErr :: Bool -> QErr -> Value
type GQResult a = Either GQExecError a
newtype GQExecError
GQExecError :: [Value] -> GQExecError
type GQResponse = GQResult ByteString
isExecError :: GQResult a -> Bool
encodeGQResp :: GQResponse -> EncJSON
decodeGQResp :: EncJSON -> (Maybe GQResponse, EncJSON)
encodeHTTPResp :: GQResponse -> EncJSON
instance GHC.Base.Functor Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs
instance GHC.Generics.Generic (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance Data.String.IsString Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance GHC.Classes.Ord Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance GHC.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQExecError
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.GQExecError
instance GHC.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.GQExecError
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Language.Haskell.TH.Syntax.Lift Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance GHC.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance GHC.Classes.Ord Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance Language.Haskell.TH.Syntax.Lift Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance GHC.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance GHC.Classes.Ord Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance GHC.Base.Functor Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq
instance GHC.Generics.Generic (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc


-- | This file contains types for both the websocket protocols (Apollo) and
--   (graphql-ws) | See Apollo:
--   <a>https://github.com/apollographql/subscriptions-transport-ws/blob/master/PROTOCOL.md</a>
--   | See graphql-ws:
--   <a>https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md</a>
module Hasura.GraphQL.Transport.WebSocket.Protocol
data WSSubProtocol
Apollo :: WSSubProtocol
GraphQLWS :: WSSubProtocol
showSubProtocol :: WSSubProtocol -> String
toWSSubProtocol :: String -> WSSubProtocol
newtype OperationId
OperationId :: Text -> OperationId
[unOperationId] :: OperationId -> Text
unsafeMkOperationId :: Text -> OperationId
data ServerMsgType
SMT_GQL_CONNECTION_KEEP_ALIVE :: ServerMsgType
SMT_GQL_CONNECTION_ERROR :: ServerMsgType
SMT_GQL_DATA :: ServerMsgType
SMT_GQL_NEXT :: ServerMsgType
SMT_GQL_PING :: ServerMsgType
SMT_GQL_PONG :: ServerMsgType
SMT_GQL_CONNECTION_ACK :: ServerMsgType
SMT_GQL_ERROR :: ServerMsgType
SMT_GQL_COMPLETE :: ServerMsgType
data ConnParams
ConnParams :: Maybe (HashMap Text Text) -> ConnParams
[_cpHeaders] :: ConnParams -> Maybe (HashMap Text Text)
data StartMsg
StartMsg :: !OperationId -> !GQLReqUnparsed -> StartMsg
[_smId] :: StartMsg -> !OperationId
[_smPayload] :: StartMsg -> !GQLReqUnparsed
data StopMsg
StopMsg :: OperationId -> StopMsg
[_stId] :: StopMsg -> OperationId
data PingPongPayload
PingPongPayload :: !Maybe Text -> PingPongPayload
[_smMessage] :: PingPongPayload -> !Maybe Text
keepAliveMessage :: PingPongPayload
data SubscribeMsg
SubscribeMsg :: !OperationId -> !GQLReqUnparsed -> SubscribeMsg
[_subId] :: SubscribeMsg -> !OperationId
[_subPayload] :: SubscribeMsg -> !GQLReqUnparsed
data ClientMsg
CMConnInit :: !Maybe ConnParams -> ClientMsg
CMStart :: !StartMsg -> ClientMsg
CMStop :: !StopMsg -> ClientMsg
CMConnTerm :: ClientMsg
CMPing :: !Maybe PingPongPayload -> ClientMsg
CMPong :: !Maybe PingPongPayload -> ClientMsg
data DataMsg
DataMsg :: !OperationId -> !GQResponse -> DataMsg
[_dmId] :: DataMsg -> !OperationId
[_dmPayload] :: DataMsg -> !GQResponse
data ErrorMsg
ErrorMsg :: !OperationId -> !Value -> ErrorMsg
[_emId] :: ErrorMsg -> !OperationId
[_emPayload] :: ErrorMsg -> !Value
newtype CompletionMsg
CompletionMsg :: OperationId -> CompletionMsg
[unCompletionMsg] :: CompletionMsg -> OperationId
newtype ConnErrMsg
ConnErrMsg :: Text -> ConnErrMsg
[unConnErrMsg] :: ConnErrMsg -> Text
data ServerErrorMsg
ServerErrorMsg :: Text -> ServerErrorMsg
[unServerErrorMsg] :: ServerErrorMsg -> Text
data ServerMsg
SMConnAck :: ServerMsg
SMConnKeepAlive :: ServerMsg
SMConnErr :: !ConnErrMsg -> ServerMsg
SMData :: !DataMsg -> ServerMsg
SMErr :: !ErrorMsg -> ServerMsg
SMComplete :: !CompletionMsg -> ServerMsg
SMNext :: !DataMsg -> ServerMsg
SMPing :: !Maybe PingPongPayload -> ServerMsg
SMPong :: !Maybe PingPongPayload -> ServerMsg

-- | This is sent from the server to the client while closing the websocket
--   on encountering an error.
data ServerErrorCode
ProtocolError1002 :: ServerErrorCode
GenericError4400 :: !String -> ServerErrorCode
Unauthorized4401 :: ServerErrorCode
Forbidden4403 :: ServerErrorCode
ConnectionInitTimeout4408 :: ServerErrorCode
NonUniqueSubscription4409 :: !OperationId -> ServerErrorCode
TooManyRequests4429 :: ServerErrorCode
encodeServerErrorMsg :: ServerErrorCode -> ByteString
encodeServerMsg :: ServerMsg -> ByteString
data WSConnInitTimerStatus
Running :: WSConnInitTimerStatus
Done :: WSConnInitTimerStatus
type WSConnInitTimer = (TVar WSConnInitTimerStatus, TMVar ())
getWSTimerState :: WSConnInitTimer -> IO WSConnInitTimerStatus
getNewWSTimer :: Seconds -> IO WSConnInitTimer
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorCode
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.WSConnInitTimerStatus
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.WSConnInitTimerStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ClientMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ClientMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ErrorMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ErrorMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance Data.String.IsString Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ClientMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.WSSubProtocol
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.WSSubProtocol
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance Data.String.IsString Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ServerMsgType
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ServerMsgType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ServerMsgType


-- | Implements <i>variable resolution</i> for GraphQL queries, which
--   annotates the use site of each GraphQL variable with its value.
module Hasura.GraphQL.Execute.Resolve
resolveVariables :: forall m fragments. (MonadError QErr m, Traversable fragments) => [VariableDefinition] -> VariableValues -> [Directive Name] -> SelectionSet fragments Name -> m ([Directive Variable], SelectionSet fragments Variable)


-- | Functions related to parsing <tt>Cache-Control</tt> header as defined
--   in <a>https://tools.ietf.org/html/rfc7234#section-5.2</a>
--   
--   To get <tt>max-age</tt>/<tt>s-maxage</tt> from <tt>Cache-Control</tt>
--   header, use <a>parseMaxAge</a>. If you need to check other directives
--   use <a>parseCacheControl</a>.
--   
--   Rules which starts with <tt>obs-</tt> is not required to implement
--   because they are maked as "obsolete" as per
--   <a>https://tools.ietf.org/html/rfc7230#section-1.2</a>
module Data.Parser.CacheControl
type CacheControl = [CacheControlDirective]
data CacheControlDirective
CCDOnlyToken :: !Text -> CacheControlDirective
CCDTokenWithVal :: !Text -> !Text -> CacheControlDirective

-- | Tries to parse the <tt>max-age</tt> or <tt>s-maxage</tt> present in
--   the value of <tt>Cache-Control</tt> header
parseMaxAge :: Integral a => Text -> Either String a
findMaxAge :: Integral a => CacheControl -> Either String (Maybe a)

-- | Checks if the <tt>no-cache</tt> directive is present
noCacheExists :: CacheControl -> Bool

-- | Checks if the <tt>no-store</tt> directive is present
noStoreExists :: CacheControl -> Bool

-- | Checks if the <tt>must-revalidate</tt> directive is present
mustRevalidateExists :: CacheControl -> Bool
findCCDOnlyToken :: (Text -> Bool) -> CacheControl -> Maybe Text
findCCDTokenWithVal :: (Text -> Bool) -> CacheControl -> Maybe (Text, Text)

-- | Parses a <tt>Cache-Control</tt> header and returns a list of
--   directives
parseCacheControl :: Text -> Either String CacheControl
cacheControlParser :: Parser CacheControl
optionalWhitespaceParser :: Parser (Maybe Char)
cacheDirectiveParser :: Parser CacheControlDirective
tokenParser :: Parser Text
tcharParser :: Parser Char
dquoteParser :: Parser Char
vcharParser :: Parser Char
quotedStringParser :: Parser Text
quotedPairParser :: Parser Char
qdTextParser :: Parser Char
instance GHC.Classes.Eq Data.Parser.CacheControl.CacheControlDirective
instance GHC.Show.Show Data.Parser.CacheControl.CacheControlDirective

module Hasura.Server.Version
data Version
VersionDev :: !Text -> Version
VersionRelease :: !Version -> Version
currentVersion :: Version

-- | A version-based string used to form the CDN URL for fetching console
--   assets.
consoleAssetsVersion :: Text
instance GHC.Classes.Eq Hasura.Server.Version.Version
instance GHC.Show.Show Hasura.Server.Version.Version
instance Data.Text.Conversions.ToText Hasura.Server.Version.Version
instance Data.Text.Conversions.FromText Hasura.Server.Version.Version
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Version.Version
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Version.Version

module Net.IPv4

-- | The length should be between 0 and 32. These bounds are inclusive.
--   This expectation is not in any way enforced by this library because it
--   does not cause errors. A mask length greater than 32 will be treated
--   as if it were 32.
data IPv4Range
IPv4Range :: {-# UNPACK #-} !IPv4 -> {-# UNPACK #-} !Word8 -> IPv4Range
[ipv4RangeBase] :: IPv4Range -> {-# UNPACK #-} !IPv4
[ipv4RangeLength] :: IPv4Range -> {-# UNPACK #-} !Word8

-- | A 32-bit Internet Protocol version 4 address. To use this with the
--   <tt>network</tt> library, it is necessary to use
--   <tt>Network.Socket.htonl</tt> to convert the underlying <a>Word32</a>
--   from host byte order to network byte order.
newtype IPv4
IPv4 :: Word32 -> IPv4
[getIPv4] :: IPv4 -> Word32

-- | Decode an <a>IPv4Range</a> from <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; IPv4.decodeRange "172.16.0.0/12"
--   Just (IPv4Range {ipv4RangeBase = ipv4 172 16 0 0, ipv4RangeLength = 12})
--   
--   &gt;&gt;&gt; IPv4.decodeRange "192.168.25.254/16"
--   Just (IPv4Range {ipv4RangeBase = ipv4 192 168 0 0, ipv4RangeLength = 16})
--   </pre>
decodeRange :: Text -> Maybe IPv4Range

-- | Parse an <a>IPv4Range</a> using a <a>Parser</a>.
--   
--   <pre>
--   &gt;&gt;&gt; AT.parseOnly IPv4.parserRange "192.168.25.254/16"
--   Right (IPv4Range {ipv4RangeBase = ipv4 192 168 0 0, ipv4RangeLength = 16})
--   </pre>
parserRange :: Parser IPv4Range

-- | Parse an <a>IPv4</a> address using a <a>Parser</a>.
--   
--   <pre>
--   &gt;&gt;&gt; AT.parseOnly IPv4.parser "192.168.2.47"
--   Right (ipv4 192 168 2 47)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; AT.parseOnly IPv4.parser "192.168.2.470"
--   Left "Failed reading: All octets in an IPv4 address must be between 0 and 255"
--   </pre>
parser :: Parser IPv4

-- | This does not do an endOfInput check because it is reused in the range
--   parser implementation.
dotDecimalParser :: Parser IPv4

-- | Checks to see if an <a>IPv4</a> address belongs in the
--   <a>IPv4Range</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let ip = IPv4.fromOctets 10 10 1 92
--   
--   &gt;&gt;&gt; IPv4.contains (IPv4.IPv4Range (IPv4.fromOctets 10 0 0 0) 8) ip
--   True
--   
--   &gt;&gt;&gt; IPv4.contains (IPv4.IPv4Range (IPv4.fromOctets 10 11 0 0) 16) ip
--   False
--   </pre>
--   
--   Typically, element-testing functions are written to take the element
--   as the first argument and the set as the second argument. This is
--   intentionally written the other way for better performance when
--   iterating over a collection. For example, you might test elements in a
--   list for membership like this:
--   
--   <pre>
--   &gt;&gt;&gt; let r = IPv4.IPv4Range (IPv4.fromOctets 10 10 10 6) 31
--   
--   &gt;&gt;&gt; mapM_ (P.print . IPv4.contains r) (take 5 $ iterate succ $ IPv4.fromOctets 10 10 10 5)
--   False
--   True
--   True
--   False
--   False
--   </pre>
--   
--   The implementation of <a>contains</a> ensures that (with GHC), the
--   bitmask creation and range normalization only occur once in the above
--   example. They are reused as the list is iterated.
contains :: IPv4Range -> IPv4 -> Bool
mask :: Word8 -> Word32

-- | This is provided to mirror the interface provided by
--   <tt>Data.Set</tt>. It behaves just like <a>contains</a> but with
--   flipped arguments.
--   
--   <pre>
--   IPv4.member ip r == IPv4.contains r ip
--   </pre>
member :: IPv4 -> IPv4Range -> Bool

-- | An alias for the <tt>ipv4</tt> smart constructor.
fromOctets :: Word8 -> Word8 -> Word8 -> Word8 -> IPv4

-- | An uncurried variant of <a>fromOctets</a>.
fromTupleOctets :: (Word8, Word8, Word8, Word8) -> IPv4

-- | This is sort of a misnomer. It takes Word to make dotDecimalParser
--   perform better. This is mostly for internal use. The arguments must
--   all fit in a Word8.
fromOctets' :: Word -> Word -> Word -> Word -> IPv4
ipOctetSizeErrorMsg :: String

-- | Normalize an <a>IPv4Range</a>. The first result of this is that the
--   <a>IPv4</a> inside the <a>IPv4Range</a> is changed so that the
--   insignificant bits are zeroed out. For example:
--   
--   <pre>
--   &gt;&gt;&gt; IPv4.printRange $ IPv4.normalize $ IPv4.IPv4Range (IPv4.fromOctets 192 168 1 19) 24
--   192.168.1.0/24
--   
--   &gt;&gt;&gt; IPv4.printRange $ IPv4.normalize $ IPv4.IPv4Range (IPv4.fromOctets 192 168 1 163) 28
--   192.168.1.160/28
--   </pre>
--   
--   The second effect of this is that the mask length is lowered to be 32
--   or smaller. Working with <a>IPv4Range</a>s that have not been
--   normalized does not cause any issues for this library, although other
--   applications may reject such ranges (especially those with a mask
--   length above 32).
--   
--   Note that <a>normalize</a> is idempotent, that is:
--   
--   <pre>
--   IPv4.normalize r == (IPv4.normalize . IPv4.normalize) r
--   </pre>
normalize :: IPv4Range -> IPv4Range
rightToMaybe :: Either a b -> Maybe b
instance GHC.Show.Show Net.IPv4.IPv4
instance GHC.Read.Read Net.IPv4.IPv4
instance GHC.Classes.Ord Net.IPv4.IPv4
instance GHC.Ix.Ix Net.IPv4.IPv4
instance Data.Hashable.Class.Hashable Net.IPv4.IPv4
instance GHC.Generics.Generic Net.IPv4.IPv4
instance Data.Bits.FiniteBits Net.IPv4.IPv4
instance GHC.Classes.Eq Net.IPv4.IPv4
instance GHC.Enum.Enum Net.IPv4.IPv4
instance GHC.Enum.Bounded Net.IPv4.IPv4
instance Data.Bits.Bits Net.IPv4.IPv4
instance GHC.Generics.Generic Net.IPv4.IPv4Range
instance GHC.Read.Read Net.IPv4.IPv4Range
instance GHC.Show.Show Net.IPv4.IPv4Range
instance GHC.Classes.Ord Net.IPv4.IPv4Range
instance GHC.Classes.Eq Net.IPv4.IPv4Range

module Net.IPv6

-- | Decode an <a>IPv6Range</a> from <a>Text</a>.
--   
--   <pre>
--   &gt;&gt;&gt; addr = IPv6.ipv6 0xDEAD 0xBEEF 0x3240 0xA426 0xBA68 0x1CD0 0x4263 0x109B
--   
--   &gt;&gt;&gt; fmap IPv6.encodeRange $ IPv6.decodeRange (Text.pack "dead:beef:3240:a426:ba68:1cd0:4263:109b/28")
--   Just "dead:bee0::/28"
--   </pre>
decodeRange :: Text -> Maybe IPv6Range

-- | Parse an <a>IPv6Range</a> using a <a>Parser</a>.
parserRange :: Parser IPv6Range

-- | An <a>IPv6Range</a>. It is made up of the first <a>IPv6</a> in the
--   range and its length.
data IPv6Range
IPv6Range :: {-# UNPACK #-} !IPv6 -> {-# UNPACK #-} !Word8 -> IPv6Range
[ipv6RangeBase] :: IPv6Range -> {-# UNPACK #-} !IPv6
[ipv6RangeLength] :: IPv6Range -> {-# UNPACK #-} !Word8

-- | A 128-bit Internet Protocol version 6 address.
newtype IPv6
IPv6 :: Word128 -> IPv6
[getIPv6] :: IPv6 -> Word128

-- | Parse an <a>IPv6</a> using <a>Parser</a>.
--   
--   <pre>
--   &gt;&gt;&gt; Atto.parseOnly IPv6.parser (Text.pack "dead:beef:3240:a426:ba68:1cd0:4263:109b")
--   Right (ipv6 0xdead 0xbeef 0x3240 0xa426 0xba68 0x1cd0 0x4263 0x109b)
--   </pre>
parser :: Parser IPv6

-- | Normalize an <a>IPv6Range</a>. The first result of this is that the
--   <a>IPv6</a> inside the <a>IPv6Range</a> is changed so that the
--   insignificant bits are zeroed out. For example:
--   
--   <pre>
--   &gt;&gt;&gt; addr1 = IPv6.ipv6 0x0192 0x0168 0x0001 0x0019 0x0000 0x0000 0x0000 0x0000
--   
--   &gt;&gt;&gt; addr2 = IPv6.ipv6 0x0192 0x0168 0x0001 0x0163 0x0000 0x0000 0x0000 0x0000
--   
--   &gt;&gt;&gt; IPv6.printRange $ IPv6.normalize $ IPv6.IPv6Range addr1 24
--   192:100::/24
--   
--   &gt;&gt;&gt; IPv6.printRange $ IPv6.normalize $ IPv6.IPv6Range addr2 28
--   192:160::/28
--   </pre>
--   
--   The second effect of this is that the mask length is lowered to be 128
--   or smaller. Working with <a>IPv6Range</a>s that have not been
--   normalized does not cause any issues for this library, although other
--   applications may reject such ranges (especially those with a mask
--   length above 128).
--   
--   Note that 'normalize is idempotent, that is:
--   
--   <pre>
--   IPv6.normalize r == (IPv6.normalize . IPv6.normalize) r
--   </pre>
normalize :: IPv6Range -> IPv6Range
mask128 :: IPv6
mask :: Word8 -> IPv6

-- | An alias for the <tt>ipv6</tt> smart constructor.
fromWord16s :: Word16 -> Word16 -> Word16 -> Word16 -> Word16 -> Word16 -> Word16 -> Word16 -> IPv6
fromWord16sWord128 :: Word128 -> Word128 -> Word128 -> Word128 -> Word128 -> Word128 -> Word128 -> Word128 -> Word128

-- | Uncurried variant of <a>fromWord32s</a>.
fromTupleWord32s :: (Word32, Word32, Word32, Word32) -> IPv6

-- | This is provided to mirror the interface provided by
--   <tt>Data.Set</tt>. It behaves just like <a>contains</a> but with
--   flipped arguments.
--   
--   <pre>
--   IPv6.member ip r == IPv6.contains r ip
--   </pre>
member :: IPv6 -> IPv6Range -> Bool
rightToMaybe :: Either a b -> Maybe b

-- | Checks to see if an <a>IPv6</a> address belongs in the
--   <a>IPv6Range</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let ip = IPv6.ipv6 0x2001 0x0db8 0x0db8 0x1094 0x2051 0x0000 0x0000 0x0001
--   
--   &gt;&gt;&gt; let iprange mask = IPv6.IPv6Range (IPv6.ipv6 0x2001 0x0db8 0x0000 0x0000 0x0000 0x0000 0x0000 0x0001) mask
--   
--   &gt;&gt;&gt; IPv6.contains (iprange 8) ip
--   True
--   
--   &gt;&gt;&gt; IPv6.contains (iprange 48) ip
--   False
--   </pre>
--   
--   Typically, element-testing functions are written to take the element
--   as the first argument and the set as the second argument. This is
--   intentionally written the other way for better performance when
--   iterating over a collection. For example, you might test elements in a
--   list for membership like this:
--   
--   <pre>
--   &gt;&gt;&gt; let r = IPv6.IPv6Range (IPv6.ipv6 0x2001 0x0db8 0x0000 0x0000 0x0000 0x0000 0x0000 0x0001) 64
--   
--   &gt;&gt;&gt; fmap (IPv6.contains r) (take 5 $ iterate succ $ IPv6.ipv6 0x2001 0x0db8 0x0000 0x0000 0xffff 0xffff 0xffff 0xfffe)
--   [True,True,False,False,False]
--   </pre>
--   
--   The implementation of <a>contains</a> ensures that (with GHC), the
--   bitmask creation and range normalization only occur once in the above
--   example. They are reused as the list is iterated.
contains :: IPv6Range -> IPv6 -> Bool

-- | Build an <a>IPv6</a> from four 32-bit words. The leftmost argument is
--   the high word and the rightword is the low word.
fromWord32s :: Word32 -> Word32 -> Word32 -> Word32 -> IPv6
fromWord32sWord128 :: Word128 -> Word128 -> Word128 -> Word128 -> Word128
instance GHC.Ix.Ix Net.IPv6.IPv6
instance GHC.Show.Show Net.IPv6.IPv6
instance GHC.Read.Read Net.IPv6.IPv6
instance GHC.Generics.Generic Net.IPv6.IPv6
instance Data.Bits.FiniteBits Net.IPv6.IPv6
instance Data.Bits.Bits Net.IPv6.IPv6
instance GHC.Classes.Ord Net.IPv6.IPv6
instance GHC.Classes.Eq Net.IPv6.IPv6
instance GHC.Enum.Enum Net.IPv6.IPv6
instance GHC.Enum.Bounded Net.IPv6.IPv6
instance GHC.Generics.Generic Net.IPv6.IPv6Range
instance GHC.Read.Read Net.IPv6.IPv6Range
instance GHC.Show.Show Net.IPv6.IPv6Range
instance GHC.Classes.Ord Net.IPv6.IPv6Range
instance GHC.Classes.Eq Net.IPv6.IPv6Range

module Network.HTTP.Client.DynamicTlsPermissions
newtype TlsServiceDefinitionError
TlsServiceDefinitionError :: String -> TlsServiceDefinitionError
[tlsServiceDefinitionError] :: TlsServiceDefinitionError -> String
errorE :: String -> c
dynamicTlsSettings :: IO [TlsAllow] -> IO TLSSettings
instance GHC.Show.Show Network.HTTP.Client.DynamicTlsPermissions.TlsServiceDefinitionError
instance GHC.Exception.Type.Exception Network.HTTP.Client.DynamicTlsPermissions.TlsServiceDefinitionError

module Network.HTTP.Client.Manager
class (Monad m) => HasHttpManagerM m
askHttpManager :: HasHttpManagerM m => m Manager
instance Network.HTTP.Client.Manager.HasHttpManagerM m => Network.HTTP.Client.Manager.HasHttpManagerM (Control.Monad.Trans.Except.ExceptT e m)
instance Network.HTTP.Client.Manager.HasHttpManagerM m => Network.HTTP.Client.Manager.HasHttpManagerM (Control.Monad.Trans.Reader.ReaderT r m)
instance Network.HTTP.Client.Manager.HasHttpManagerM m => Network.HTTP.Client.Manager.HasHttpManagerM (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Network.HTTP.Client.Manager.HasHttpManagerM m) => Network.HTTP.Client.Manager.HasHttpManagerM (Control.Monad.Trans.Writer.Strict.WriterT w m)


-- | Restricted <tt>ManagerSettings</tt> for
--   <a>https://haskell-lang.org/library/http-client</a> - - Portions from
--   http-client-tls Copyright (c) 2013 Michael Snoyman - Portions from
--   http-client-restricted Copyright 2018 Joey Hess <a>id@joeyh.name</a> -
--   - License: MIT
module Network.HTTP.Client.Restricted
data Decision
Allow :: Decision
Deny :: Decision
type Restriction = AddrInfo -> Decision

-- | Blocked requests raise this exception, wrapped as
--   <tt>InternalException</tt>.
data ConnectionRestricted
ConnectionRestricted :: String -> AddrInfo -> ConnectionRestricted
[crHostName] :: ConnectionRestricted -> String
[crAddress] :: ConnectionRestricted -> AddrInfo

-- | Adjusts a ManagerSettings to enforce a Restriction. The restriction
--   will be checked each time a Request is made, and for each redirect
--   followed.
--   
--   This overrides the <tt>managerRawConnection</tt> and
--   <tt>managerTlsConnection</tt> with its own implementations that check
--   the Restriction. They should otherwise behave the same as the ones
--   provided by http-client-tls.
--   
--   This function is not exported, because using it with a ManagerSettings
--   produced by something other than http-client-tls would result in
--   surprising behavior, since its connection methods would not be used.
restrictManagerSettings :: Maybe ConnectionContext -> Maybe TLSSettings -> Restriction -> ManagerSettings -> ManagerSettings

-- | Makes a TLS-capable ManagerSettings with a Restriction applied to it.
--   
--   The Restriction will be checked each time a Request is made, and for
--   each redirect followed.
--   
--   Aside from checking the Restriction, it should behave the same as
--   <a>mkManagerSettingsContext</a> from http-client-tls.
--   
--   <pre>
--   main = do
--   	manager &lt;- newManager $ mkRestrictedManagerSettings myRestriction Nothing Nothing
--   request &lt;- parseRequest "http://httpbin.org/get"
--   	response &lt;- httpLbs request manager
--   	print $ responseBody response
--   </pre>
--   
--   See <tt>mkManagerSettingsContext</tt> for why it can be useful to
--   provide a <a>ConnectionContext</a>.
--   
--   Note that SOCKS is not supported.
mkRestrictedManagerSettings :: Restriction -> Maybe ConnectionContext -> Maybe TLSSettings -> ManagerSettings
wrapOurExceptions :: ManagerSettings -> Request -> IO a -> IO a
restrictedRawConnection :: Restriction -> IO (Maybe HostAddress -> String -> Int -> IO Connection)
restrictedTlsConnection :: Maybe ConnectionContext -> Maybe TLSSettings -> Restriction -> IO (Maybe HostAddress -> String -> Int -> IO Connection)
getConnection :: Restriction -> Maybe TLSSettings -> Maybe ConnectionContext -> IO (Maybe HostAddress -> String -> Int -> IO Connection)
convertConnection :: Connection -> IO Connection
instance GHC.Show.Show Network.HTTP.Client.Restricted.ConnectionRestricted
instance GHC.Exception.Type.Exception Network.HTTP.Client.Restricted.ConnectionRestricted

module Network.HTTP.Client.Blocklisting
data Blocklist
Blocklist :: [IPv4Range] -> [IPv6Range] -> Blocklist
[ipv4Blocklist] :: Blocklist -> [IPv4Range]
[ipv6Blocklist] :: Blocklist -> [IPv6Range]

-- | Determine whether the given address is blocked by the given blocklist.
--   NOTE: Only restricts IPv4 and IPv6 addresses. Other address families
--   are not restricted.
block :: Blocklist -> AddrInfo -> Decision
instance GHC.Generics.Generic Network.HTTP.Client.Blocklisting.Blocklist
instance GHC.Show.Show Network.HTTP.Client.Blocklisting.Blocklist
instance GHC.Base.Semigroup Network.HTTP.Client.Blocklisting.Blocklist
instance GHC.Base.Monoid Network.HTTP.Client.Blocklisting.Blocklist

module Network.HTTP.Client.CreateManager

-- | This mkHttpManager function takes a mechanism for finding the current
--   allowlist, | Thus allowing it to be coupled from any ref type such as
--   SchemaCacheRef. | A mechanism to block IPs (both IPv4 and IPv6) has
--   also been added to it.
mkHttpManager :: IO [TlsAllow] -> Blocklist -> IO Manager

module Hasura.HTTP
hdrsToText :: [Header] -> [(Text, Text)]
wreqOptions :: Manager -> [Header] -> Options
addDefaultHeaders :: [Header] -> [Header]
isDefaultHeader :: Header -> Bool
defaultHeaders :: [Header]
newtype HttpException
HttpException :: HttpException -> HttpException
[unHttpException] :: HttpException -> HttpException
getHTTPExceptionStatus :: HttpException -> Maybe Int
serializeHTTPExceptionMessage :: HttpException -> Text
serializeHTTPExceptionMessageForDebugging :: HttpException -> Text
encodeHTTPRequestJSON :: Request -> Value
data HttpResponse a
HttpResponse :: !a -> !ResponseHeaders -> HttpResponse a
[_hrBody] :: HttpResponse a -> !a
[_hrHeaders] :: HttpResponse a -> !ResponseHeaders
addHttpResponseHeaders :: ResponseHeaders -> HttpResponse a -> HttpResponse a
serializeServantClientErrorMessage :: ClientError -> Text
serializeServantClientErrorMessageForDebugging :: ClientError -> Text
serializeExceptionForDebugging :: Exception e => e -> Text
instance GHC.Show.Show Hasura.HTTP.HttpException
instance Data.Traversable.Traversable Hasura.HTTP.HttpResponse
instance Data.Foldable.Foldable Hasura.HTTP.HttpResponse
instance GHC.Base.Functor Hasura.HTTP.HttpResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.HTTP.HttpException

module Hasura.Server.CheckUpdates
newtype UpdateInfo
UpdateInfo :: Version -> UpdateInfo
[_uiLatest] :: UpdateInfo -> Version
checkForUpdates :: LoggerCtx a -> Manager -> IO void
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.CheckUpdates.UpdateInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.CheckUpdates.UpdateInfo
instance GHC.Show.Show Hasura.Server.CheckUpdates.UpdateInfo

module Hasura.Server.Auth.JWT.Logging

-- | Possible errors during fetching and parsing JWK (the <a>Text</a> type
--   at the end is a friendly error message)
data JwkFetchError

-- | Exception while making the HTTP request
JFEHttpException :: !HttpException -> !Text -> JwkFetchError

-- | Non-2xx HTTP errors from the upstream server
JFEHttpError :: !URI -> !Status -> !ByteString -> !Text -> JwkFetchError

-- | Error parsing the JWK response itself
JFEJwkParseError :: !Text -> !Text -> JwkFetchError

-- | Error parsing the expiry of the JWK
JFEExpiryParseError :: !Maybe Text -> Text -> JwkFetchError
data JwkRefreshLog
JwkRefreshLog :: !LogLevel -> !Maybe Text -> !Maybe JwkFetchError -> JwkRefreshLog
[jrlLogLevel] :: JwkRefreshLog -> !LogLevel
[jrlMessage] :: JwkRefreshLog -> !Maybe Text
[jrlError] :: JwkRefreshLog -> !Maybe JwkFetchError
instance GHC.Show.Show Hasura.Server.Auth.JWT.Logging.JwkFetchError
instance GHC.Show.Show Hasura.Server.Auth.JWT.Logging.JwkRefreshLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.Logging.JwkRefreshLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Auth.JWT.Logging.JwkRefreshLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.Logging.JwkFetchError


-- | Our HTTP client library, with better ergonomics for logging and so on
--   (see <a>Request</a>).
module Network.HTTP.Client.Transformable

-- | <tt>Network.HTTP.Client</tt>.<a>Request</a> stores the request body in
--   a sum type which has a case containing IO along with some other
--   unwieldy cases. This makes it difficult to log our requests before and
--   after transformation.
--   
--   In our codebase we only ever use the Lazy ByteString case. So by
--   lifting the request body out of Network.HTTP.Client.Request, we make
--   it much easier to log our Requests.
--   
--   When executing the request we simply insert the value at <a>rdBody</a>
--   into the Request.
--   
--   When working with Transformable Requests you should always import this
--   module qualified and use the `mkRequest*` functions for constructing
--   requests. Modification of Request should be done using the provided
--   lens API.
--   
--   NOTE: This module is meant to be imported qualified, e.g.
--   
--   <pre>
--   import qualified Network.HTTP.Client.Transformable as HTTP
--   </pre>
--   
--   ...or
--   
--   <pre>
--   import qualified Network.HTTP.Client.Transformable as Transformable
--   </pre>
--   
--   Use <a>performRequest</a> to execute the request.
data Request
Request :: Request -> Maybe ByteString -> Request
[rdRequest] :: Request -> Request
[rdBody] :: Request -> Maybe ByteString

-- | Convert a URL into a Request value.
--   
--   NOTE: This function will throw an error in <a>MonadThrow</a> if the
--   URL is invalid.
mkRequestThrow :: MonadThrow m => Text -> m Request

-- | <a>mkRequestThrow</a> with the <a>MonadThrow</a> instance specialized
--   to <a>Either</a>.
--   
--   NOTE: While this function makes use of <a>impureThrow</a>, it should
--   be impossible to trigger in practice.
--   
--   <a>mkRequestThrow</a> calls <a>parseRequest</a>, which only ever
--   throws <a>HttpException</a> errors (which should be "caught" by the
--   <a>fromException</a> cast).
mkRequestEither :: Text -> Either HttpException Request

-- | Creates a <a>Request</a>, converting it from a <a>Request</a>. This
--   only supports requests that use a Strict/Lazy ByteString as a request
--   body and will fail with all other body types.
--   
--   NOTE: You should avoid creating <a>Request</a>s and use the
--   <tt>mk</tt> functions to create <a>Request</a>s. This is for if a
--   framework hands you a precreated <a>Request</a> and you don't have a
--   choice.
tryFromClientRequest :: Request -> Either Text Request

-- | Url is 'materialized view' into <a>Request</a> consisting of
--   concatenation of <a>host</a>, <a>port</a>, <a>queryParams</a>, and
--   <a>path</a> in the underlying request object, as well as a literal url
--   field that stores the textual representation that was supplied from
--   metadata.
--   
--   The reason why we store the textual URL in addition to the parsed URL
--   in the request is that the parsed URL loses syntactic information such
--   as "does <a>http://foo.com</a> end in a slash?" which is important
--   when a template user has expectations about the $url variable matching
--   the string that was configured in the action.
--   
--   We use the literal field to <a>view</a> the value but we must
--   carefully set the subcomponents by hand during <a>set</a> operations.
--   Be careful modifying this lens and verify against the unit tests..
url :: Lens' Request Text
body :: Lens' Request (Maybe ByteString)
headers :: Lens' Request [Header]
host :: Lens' Request ByteString
secure :: Lens' Request Bool
method :: Lens' Request ByteString
path :: Lens' Request ByteString
port :: Lens' Request Int
getQueryStr :: Request -> ByteString
queryParams :: Lens' Request Query
timeout :: Lens' Request ResponseTimeout
getReqSize :: Request -> Int64
toRequest :: Request -> Request

-- | NOTE: for now, please always wrap this in <tt>tracedHttpRequest</tt>
--   to make sure a trace is logged.
performRequest :: Request -> Manager -> IO (Response ByteString)
instance GHC.Show.Show Network.HTTP.Client.Transformable.Request
instance Data.Aeson.Types.ToJSON.ToJSON Network.HTTP.Client.Transformable.Request

module Hasura.Tracing

-- | Any additional human-readable key-value pairs relevant to the
--   execution of a block of code.
type TracingMetadata = [(Text, Text)]
newtype Reporter
Reporter :: (forall io a. MonadIO io => TraceContext -> Text -> io (a, TracingMetadata) -> io a) -> Reporter
[runReporter] :: Reporter -> forall io a. MonadIO io => TraceContext -> Text -> io (a, TracingMetadata) -> io a
noReporter :: Reporter

-- | A type class for monads which support some way to report execution
--   traces.
--   
--   See <tt>instance Tracing.HasReporter (AppM impl)</tt> in
--   <tt>HasuraPro.App</tt>.
class Monad m => HasReporter m

-- | Get the current tracer
askReporter :: HasReporter m => m Reporter

-- | Get the current tracer
askReporter :: HasReporter m => m Reporter

-- | A trace context records the current active trace, the active span
--   within that trace, and the span's parent, unless the current span is
--   the root.
data TraceContext
TraceContext :: !Word64 -> !Word64 -> !Maybe Word64 -> TraceContext

-- | TODO what is this exactly? The topmost span id?
[tcCurrentTrace] :: TraceContext -> !Word64
[tcCurrentSpan] :: TraceContext -> !Word64
[tcCurrentParent] :: TraceContext -> !Maybe Word64

-- | The <a>TraceT</a> monad transformer adds the ability to keep track of
--   the current trace context.
newtype TraceT m a
TraceT :: ReaderT (TraceContext, Reporter) (WriterT TracingMetadata m) a -> TraceT m a
[unTraceT] :: TraceT m a -> ReaderT (TraceContext, Reporter) (WriterT TracingMetadata m) a

-- | Run an action in the <a>TraceT</a> monad transformer. <a>runTraceT</a>
--   delimits a new trace with its root span, and the arguments specify a
--   name and metadata for that span.
runTraceT :: (HasReporter m, MonadIO m) => Text -> TraceT m a -> m a
runTraceTWith :: MonadIO m => TraceContext -> Reporter -> Text -> TraceT m a -> m a

-- | Run an action in the <a>TraceT</a> monad transformer in an existing
--   context.
runTraceTInContext :: (MonadIO m, HasReporter m) => TraceContext -> Text -> TraceT m a -> m a

-- | Run an action in the <a>TraceT</a> monad transformer in an existing
--   context.
runTraceTWithReporter :: MonadIO m => Reporter -> Text -> TraceT m a -> m a

-- | Monads which support tracing. <a>TraceT</a> is the standard example.
class Monad m => MonadTrace m

-- | Trace the execution of a block of code, attaching a human-readable
--   name.
trace :: MonadTrace m => Text -> m a -> m a

-- | Ask for the current tracing context, so that we can provide it to any
--   downstream services, e.g. in HTTP headers.
currentContext :: MonadTrace m => m TraceContext

-- | Ask for the current tracing reporter
currentReporter :: MonadTrace m => m Reporter

-- | Log some metadata to be attached to the current span
attachMetadata :: MonadTrace m => TracingMetadata -> m ()

-- | Reinterpret a <a>TraceT</a> action in another <a>MonadTrace</a>. This
--   can be useful when you need to reorganize a monad transformer stack,
--   for example, to embed an action in some monadic computation, while
--   preserving tracing metadata and context.
--   
--   For example, we use this function in various places in
--   <tt>BackendExecute</tt>, where we receive an action to execute in some
--   concrete monad transformer stack. See the various implementations of
--   <tt>runQuery</tt> for examples. Ideally, the input computation's type
--   would be sufficiently polymorphic that we would not need to reorder
--   monads inthe transformer stack. However, the monad transformer stacks
--   must be concrete, because their types are defined by an associated
--   type family <tt>ExecutionMonad</tt>. Hence, we need to use this
--   function to peel off the outermost <a>TraceT</a> constructor, and
--   embed the computation in some other <a>MonadTrace</a>.
--   
--   A second example is related to caching. The <tt>cacheLookup</tt>
--   function returns an action in a concrete transformer stack, again
--   because we are constrained by the usage of a type class. We need to
--   reinterpret the <a>TraceT</a> component of this concrete stack in some
--   other abstract monad transformer stack, using this function.
--   
--   Laws:
--   
--   <pre>
--   interpTraceT id (hoist f (TraceT x)) = interpTraceT f (TraceT x)
--   </pre>
interpTraceT :: MonadTrace n => (m (a, TracingMetadata) -> n (b, TracingMetadata)) -> TraceT m a -> n b

-- | Encode Word64 to 16 character hex string
word64ToHex :: Word64 -> Text

-- | Decode 16 character hex string to Word64
hexToWord64 :: Text -> Maybe Word64

-- | Inject the trace context as a set of HTTP headers.
injectHttpContext :: TraceContext -> [Header]

-- | Extract the trace and parent span headers from a HTTP request and
--   create a new <a>TraceContext</a>. The new context will contain a fresh
--   span ID, and the provided span ID will be assigned as the immediate
--   parent span.
extractHttpContext :: [Header] -> IO (Maybe TraceContext)

-- | Inject the trace context as a JSON value, appropriate for storing in
--   (e.g.) an event trigger payload.
injectEventContext :: TraceContext -> Value

-- | Extract a trace context from an event trigger payload.
extractEventContext :: Value -> IO (Maybe TraceContext)

-- | Perform HTTP request which supports Trace headers using a HTTP.Request
--   value
--   
--   TODO REFACTOR: - inline <a>performRequest</a> so that we can be sure a
--   trace is always logged - Inline <tt>try</tt> here since we always use
--   that at call sites
tracedHttpRequest :: MonadTrace m => Request -> (Request -> m a) -> m a
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.Tracing.TraceT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.Tracing.TraceT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hasura.Tracing.TraceT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hasura.Tracing.TraceT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Hasura.Tracing.TraceT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Hasura.Tracing.TraceT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Tracing.TraceT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.Tracing.TraceT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.Tracing.TraceT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.Tracing.TraceT m)
instance Control.Monad.IO.Class.MonadIO m => Hasura.Tracing.MonadTrace (Hasura.Tracing.TraceT m)
instance Hasura.Tracing.MonadTrace m => Hasura.Tracing.MonadTrace (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Tracing.MonadTrace m => Hasura.Tracing.MonadTrace (Control.Monad.Trans.State.Strict.StateT e m)
instance Hasura.Tracing.MonadTrace m => Hasura.Tracing.MonadTrace (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.Tracing.TraceT
instance Control.Monad.Morph.MFunctor Hasura.Tracing.TraceT
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.Tracing.TraceT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.Tracing.TraceT m)
instance Network.HTTP.Client.Manager.HasHttpManagerM m => Network.HTTP.Client.Manager.HasHttpManagerM (Hasura.Tracing.TraceT m)
instance Hasura.Tracing.HasReporter m => Hasura.Tracing.HasReporter (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Tracing.HasReporter m => Hasura.Tracing.HasReporter (Control.Monad.Trans.Except.ExceptT e m)

module Hasura.Backends.DataConnector.Logging
data RequestLogInfo
RequestLogInfo :: Text -> Text -> KeyMap Text -> Maybe Text -> RequestLogInfo
[_rliRequestMethod] :: RequestLogInfo -> Text
[_rliRequestUri] :: RequestLogInfo -> Text
[_rliRequestHeaders] :: RequestLogInfo -> KeyMap Text
[_rliRequestBody] :: RequestLogInfo -> Maybe Text
data AgentCommunicationLog
AgentCommunicationLog :: Maybe RequestLogInfo -> Maybe Int -> Maybe Text -> Text -> Text -> AgentCommunicationLog
[_aclRequest] :: AgentCommunicationLog -> Maybe RequestLogInfo
[_aclResponseStatusCode] :: AgentCommunicationLog -> Maybe Int
[_aclError] :: AgentCommunicationLog -> Maybe Text
[_aclTraceId] :: AgentCommunicationLog -> Text
[_aclSpanId] :: AgentCommunicationLog -> Text
logAgentRequest :: (MonadIO m, MonadTrace m) => Logger Hasura -> Request -> Either HttpException (Response ByteString) -> m ()
extractRequestLogInfoFromClientRequest :: Request -> RequestLogInfo
logClientError :: (MonadIO m, MonadTrace m) => Logger Hasura -> ClientError -> m ()
extractRequestLogInfoFromClientInfo :: ClientError -> Maybe RequestLogInfo
headersToKeyMap :: [Header] -> KeyMap Text
fromUtf8 :: ByteString -> Text
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Logging.RequestLogInfo
instance GHC.Show.Show Hasura.Backends.DataConnector.Logging.RequestLogInfo
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Logging.AgentCommunicationLog
instance GHC.Show.Show Hasura.Backends.DataConnector.Logging.AgentCommunicationLog
instance Hasura.Logging.ToEngineLog Hasura.Backends.DataConnector.Logging.AgentCommunicationLog Hasura.Logging.Hasura

module Hasura.Backends.DataConnector.Agent.Client
data AgentClientContext
AgentClientContext :: Logger Hasura -> BaseUrl -> Manager -> Maybe Int -> AgentClientContext
[_accLogger] :: AgentClientContext -> Logger Hasura
[_accBaseUrl] :: AgentClientContext -> BaseUrl
[_accHttpManager] :: AgentClientContext -> Manager
[_accResponseTimeout] :: AgentClientContext -> Maybe Int
newtype AgentClientT m a
AgentClientT :: ReaderT AgentClientContext m a -> AgentClientT m a
runAgentClientT :: AgentClientT m a -> AgentClientContext -> m a
askClientContext :: Monad m => AgentClientT m AgentClientContext
runRequestAcceptStatus' :: (MonadIO m, MonadTrace m, MonadError QErr m) => Maybe [Status] -> Request -> AgentClientT m Response
throwClientError' :: (MonadIO m, MonadTrace m, MonadError QErr m) => ClientError -> AgentClientT m a
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance Hasura.Tracing.MonadTrace m => Hasura.Tracing.MonadTrace (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance (Control.Monad.IO.Class.MonadIO m, Hasura.Tracing.MonadTrace m, Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr m) => Servant.Client.Core.RunClient.RunClient (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)

module Network.URI.Extended
instance Data.Aeson.Types.FromJSON.FromJSON Network.URI.URI
instance Data.Aeson.Types.ToJSON.ToJSON Network.URI.URI
instance Data.Aeson.Types.ToJSON.ToJSONKey Network.URI.URI
instance Data.Hashable.Class.Hashable Network.URI.URI


-- | Supporting functionality for fine-grained dependency tracking.
module Hasura.Incremental.Internal.Dependency

-- | A <a>Dependency</a> represents a value that a <tt>Rule</tt> can
--   <i>conditionally</i> depend on. A <a>Dependency</a> is created using
--   <tt>newDependency</tt>, and it can be “opened” again using
--   <tt>dependOn</tt>. What makes a <a>Dependency</a> useful is the way it
--   cooperates with <tt>cache</tt>---if a <a>Dependency</a> is passed to a
--   cached rule, but that rule (or any of its sub-rules) never “opens” it
--   using <tt>dependOn</tt>, then subsequent executions of the rule will
--   ignore the <a>Dependency</a> when computing whether or not it is
--   necessary to re-execute the rule.
--   
--   The above functionality is useful on its own to express conditional
--   dependencies, but even more useful is the ability to express
--   <i>partial</i> dependencies. For example, if a <a>Dependency</a>
--   contains a <a>HashMap</a>, a rule can choose to only depend on the
--   value associated with a particular key by using <a>selectKeyD</a> (or
--   the more general <a>selectD</a>). Only the parts that are actually
--   used will be counted when computing whether a rule needs to be
--   re-executed.
data Dependency a
Dependency :: !DependencyKey a -> !a -> Dependency a

-- | Applies a <a>Selector</a> to select part of a <a>Dependency</a>.
selectD :: Select a => Selector a b -> Dependency a -> Dependency b

-- | Selects a single key from a dependency containing a map-like data
--   structure.
selectKeyD :: (Select a, Selector a ~ ConstS k v) => k -> Dependency a -> Dependency v

-- | Tracks whether a <a>Dependency</a> is a “root” dependency created by
--   <tt>newDependency</tt> or a “child” dependency created from an
--   existing dependency using <a>selectD</a>.
data DependencyKey a
[DependencyRoot] :: !UniqueS a -> DependencyKey a
[DependencyChild] :: Select a => !Selector a b -> !DependencyKey a -> DependencyKey b

-- | A typeclass that implements the dependency-checking machinery used by
--   <tt>cache</tt>. Morally, this class is like <a>Eq</a>, but it only
--   checks the parts of a <a>Dependency</a> that were actually accessed on
--   the previous execution. It is highly unlikely you will need to
--   implement any <a>Cacheable</a> instances yourself; the default
--   implementation uses <a>Generic</a> to derive an instance
--   automatically.
class (Eq a) => Cacheable a
unchanged :: Cacheable a => Accesses -> a -> a -> Bool
unchanged :: (Cacheable a, Generic a, GCacheable (Rep a)) => Accesses -> a -> a -> Bool

-- | A mapping from root <a>Dependency</a> keys to the accesses made
--   against those dependencies.
newtype Accesses
Accesses :: DMap UniqueS Access -> Accesses
[unAccesses] :: Accesses -> DMap UniqueS Access
recordAccess :: DependencyKey a -> Access a -> Accesses -> Accesses

-- | Records the accesses made within a single <a>Dependency</a> and its
--   children. The <a>Semigroup</a> instance for <a>Access</a> computes a
--   least upper bound:
--   
--   <ul>
--   <li><a>AccessedAll</a> serves as the top of the lattice and records
--   the dependency’s entire value was accessed.</li>
--   <li><a>AccessedParts</a> records a set of accesses for individual
--   parts of a dependency.</li>
--   </ul>
data Access a
[AccessedAll] :: Cacheable a => Access a
[AccessedParts] :: Select a => !DMap (Selector a) Access -> Access a
class GCacheable f
gunchanged :: GCacheable f => f p -> f p -> Accesses -> Bool
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.Description
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.EnumValue
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.ExecutableDocument a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Data.Sequence.NonEmpty.Internal.NESeq a)
instance GHC.Base.Semigroup Hasura.Incremental.Internal.Dependency.Accesses
instance GHC.Base.Monoid Hasura.Incremental.Internal.Dependency.Accesses
instance GHC.Base.Semigroup (Hasura.Incremental.Internal.Dependency.Access a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Incremental.Internal.Dependency.Dependency a)
instance Hasura.Incremental.Internal.Dependency.Cacheable GHC.Types.Char
instance Hasura.Incremental.Internal.Dependency.Cacheable GHC.Types.Double
instance Hasura.Incremental.Internal.Dependency.Cacheable GHC.Types.Int
instance Hasura.Incremental.Internal.Dependency.Cacheable GHC.Int.Int32
instance Hasura.Incremental.Internal.Dependency.Cacheable GHC.Int.Int64
instance Hasura.Incremental.Internal.Dependency.Cacheable GHC.Integer.Type.Integer
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Scientific.Scientific
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Text.Internal.Text
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Text.NonEmpty.NonEmptyText
instance Hasura.Incremental.Internal.Dependency.Cacheable Network.URI.URIAuth
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.Name
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Time.Clock.Internal.DiffTime.DiffTime
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Time.Clock.Internal.UTCTime.UTCTime
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Time.Calendar.Days.Day
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Time.LocalTime.Internal.TimeOfDay.TimeOfDay
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Time.LocalTime.Internal.LocalTime.LocalTime
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.ByteString.Internal.ByteString
instance Hasura.Incremental.Internal.Dependency.Cacheable GHC.Types.Float
instance Hasura.Incremental.Internal.Dependency.Cacheable GHC.Types.Word
instance Hasura.Incremental.Internal.Dependency.Cacheable GHC.Word.Word8
instance Hasura.Incremental.Internal.Dependency.Cacheable GHC.Word.Word16
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Aeson.Key.Key
instance Hasura.Incremental.Internal.Dependency.Cacheable System.Cron.Types.StepField
instance Hasura.Incremental.Internal.Dependency.Cacheable System.Cron.Types.RangeField
instance Hasura.Incremental.Internal.Dependency.Cacheable System.Cron.Types.SpecificField
instance Hasura.Incremental.Internal.Dependency.Cacheable System.Cron.Types.BaseField
instance Hasura.Incremental.Internal.Dependency.Cacheable System.Cron.Types.CronField
instance Hasura.Incremental.Internal.Dependency.Cacheable System.Cron.Types.MonthSpec
instance Hasura.Incremental.Internal.Dependency.Cacheable System.Cron.Types.DayOfMonthSpec
instance Hasura.Incremental.Internal.Dependency.Cacheable System.Cron.Types.DayOfWeekSpec
instance Hasura.Incremental.Internal.Dependency.Cacheable System.Cron.Types.HourSpec
instance Hasura.Incremental.Internal.Dependency.Cacheable System.Cron.Types.MinuteSpec
instance Hasura.Incremental.Internal.Dependency.Cacheable System.Cron.Types.CronSchedule
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Data.Sequence.Internal.Seq a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Data.Vector.Vector a)
instance (Hasura.Incremental.Internal.Dependency.Cacheable k, Hasura.Incremental.Internal.Dependency.Cacheable v) => Hasura.Incremental.Internal.Dependency.Cacheable (Data.HashMap.Internal.HashMap k v)
instance (Hasura.Incremental.Internal.Dependency.Cacheable k, Hasura.Incremental.Internal.Dependency.Cacheable v) => Hasura.Incremental.Internal.Dependency.Cacheable (Data.HashMap.Strict.NonEmpty.NEHashMap k v)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Data.HashSet.Internal.HashSet a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Data.HashSet.InsOrd.InsOrdHashSet a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Data.CaseInsensitive.Internal.CI a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Data.Set.Internal.Set a)
instance (Data.Hashable.Class.Hashable k, Hasura.Incremental.Internal.Dependency.Cacheable k, Hasura.Incremental.Internal.Dependency.Cacheable v) => Hasura.Incremental.Internal.Dependency.Cacheable (Data.HashMap.Strict.InsOrd.InsOrdHashMap k v)
instance (Hasura.Incremental.Internal.Dependency.Cacheable k, Hasura.Incremental.Internal.Dependency.Cacheable v) => Hasura.Incremental.Internal.Dependency.Cacheable (Data.Map.Internal.Map k v)
instance Hasura.Incremental.Internal.Dependency.Cacheable v => Hasura.Incremental.Internal.Dependency.Cacheable (Data.Aeson.KeyMap.KeyMap v)
instance Hasura.Incremental.Internal.Dependency.Cacheable ()
instance (Hasura.Incremental.Internal.Dependency.Cacheable a, Hasura.Incremental.Internal.Dependency.Cacheable b) => Hasura.Incremental.Internal.Dependency.Cacheable (a, b)
instance (Hasura.Incremental.Internal.Dependency.Cacheable a, Hasura.Incremental.Internal.Dependency.Cacheable b, Hasura.Incremental.Internal.Dependency.Cacheable c) => Hasura.Incremental.Internal.Dependency.Cacheable (a, b, c)
instance (Hasura.Incremental.Internal.Dependency.Cacheable a, Hasura.Incremental.Internal.Dependency.Cacheable b, Hasura.Incremental.Internal.Dependency.Cacheable c, Hasura.Incremental.Internal.Dependency.Cacheable d) => Hasura.Incremental.Internal.Dependency.Cacheable (a, b, c, d)
instance (Hasura.Incremental.Internal.Dependency.Cacheable a, Hasura.Incremental.Internal.Dependency.Cacheable b, Hasura.Incremental.Internal.Dependency.Cacheable c, Hasura.Incremental.Internal.Dependency.Cacheable d, Hasura.Incremental.Internal.Dependency.Cacheable e) => Hasura.Incremental.Internal.Dependency.Cacheable (a, b, c, d, e)
instance (Hasura.Incremental.Internal.Dependency.Cacheable a, Hasura.Incremental.Internal.Dependency.Cacheable b, Hasura.Incremental.Internal.Dependency.Cacheable c, Hasura.Incremental.Internal.Dependency.Cacheable d, Hasura.Incremental.Internal.Dependency.Cacheable e, Hasura.Incremental.Internal.Dependency.Cacheable f) => Hasura.Incremental.Internal.Dependency.Cacheable (a, b, c, d, e, f)
instance (Hasura.Incremental.Internal.Dependency.Cacheable a, Hasura.Incremental.Internal.Dependency.Cacheable b, Hasura.Incremental.Internal.Dependency.Cacheable c, Hasura.Incremental.Internal.Dependency.Cacheable d, Hasura.Incremental.Internal.Dependency.Cacheable e, Hasura.Incremental.Internal.Dependency.Cacheable f, Hasura.Incremental.Internal.Dependency.Cacheable g) => Hasura.Incremental.Internal.Dependency.Cacheable (a, b, c, d, e, f, g)
instance Hasura.Incremental.Internal.Dependency.Cacheable GHC.Types.Bool
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Void.Void
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.Aeson.Types.Internal.Value
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.FragmentDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.GType
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.Nullability
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.OperationType
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.VariableDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.InputValueDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.EnumValueDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.FieldDefinition a)
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.ScalarTypeDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.UnionTypeDefinition
instance (Hasura.Incremental.Internal.Dependency.Cacheable possibleTypes, Hasura.Incremental.Internal.Dependency.Cacheable a) => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.InterfaceTypeDefinition a possibleTypes)
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.EnumTypeDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.InputObjectTypeDefinition a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.ObjectTypeDefinition a)
instance (Hasura.Incremental.Internal.Dependency.Cacheable a, Hasura.Incremental.Internal.Dependency.Cacheable possibleTypes) => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.TypeDefinition a possibleTypes)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Data.Functor.Identity.Identity a)
instance Hasura.Incremental.Internal.Dependency.Cacheable Network.URI.URI
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.URL.Template.Variable
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.URL.Template.TemplateItem
instance Hasura.Incremental.Internal.Dependency.Cacheable Data.URL.Template.URLTemplate
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (GHC.Maybe.Maybe a)
instance (Hasura.Incremental.Internal.Dependency.Cacheable a, Hasura.Incremental.Internal.Dependency.Cacheable b) => Hasura.Incremental.Internal.Dependency.Cacheable (Data.Either.Either a b)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable [a]
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (GHC.Base.NonEmpty a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.Directive a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.ExecutableDefinition a)
instance (Hasura.Incremental.Internal.Dependency.Cacheable (a b), Hasura.Incremental.Internal.Dependency.Cacheable b) => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.Field a b)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.FragmentSpread a)
instance (Hasura.Incremental.Internal.Dependency.Cacheable (a b), Hasura.Incremental.Internal.Dependency.Cacheable b) => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.InlineFragment a b)
instance (Hasura.Incremental.Internal.Dependency.Cacheable (a b), Hasura.Incremental.Internal.Dependency.Cacheable b) => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.OperationDefinition a b)
instance (Hasura.Incremental.Internal.Dependency.Cacheable (a b), Hasura.Incremental.Internal.Dependency.Cacheable b) => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.Selection a b)
instance (Hasura.Incremental.Internal.Dependency.Cacheable (a b), Hasura.Incremental.Internal.Dependency.Cacheable b) => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.TypedOperationDefinition a b)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Language.GraphQL.Draft.Syntax.Value a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Data.Functor.Const.Const a b)
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.RootOperationTypeDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.SchemaDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.TypeSystemDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.SchemaDocument
instance Hasura.Incremental.Internal.Dependency.Cacheable Language.GraphQL.Draft.Syntax.SchemaIntrospection
instance Hasura.Incremental.Internal.Dependency.Cacheable Servant.Client.Core.BaseUrl.Scheme
instance Hasura.Incremental.Internal.Dependency.Cacheable Servant.Client.Core.BaseUrl.BaseUrl
instance Hasura.Incremental.Internal.Dependency.Cacheable v => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.GraphQL.Parser.Variable.InputValue v)
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.GraphQL.Parser.Variable.Variable
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.GraphQL.Parser.Variable.VariableInfo
instance Hasura.Incremental.Internal.Dependency.GCacheable GHC.Generics.V1
instance Hasura.Incremental.Internal.Dependency.GCacheable GHC.Generics.U1
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.GCacheable (GHC.Generics.K1 t a)
instance Hasura.Incremental.Internal.Dependency.GCacheable f => Hasura.Incremental.Internal.Dependency.GCacheable (GHC.Generics.M1 t m f)
instance (Hasura.Incremental.Internal.Dependency.GCacheable f, Hasura.Incremental.Internal.Dependency.GCacheable g) => Hasura.Incremental.Internal.Dependency.GCacheable (f GHC.Generics.:*: g)
instance (Hasura.Incremental.Internal.Dependency.GCacheable f, Hasura.Incremental.Internal.Dependency.GCacheable g) => Hasura.Incremental.Internal.Dependency.GCacheable (f GHC.Generics.:+: g)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Incremental.Internal.Dependency.Dependency a)
instance Data.GADT.Internal.GEq Hasura.Incremental.Internal.Dependency.DependencyKey
instance Data.GADT.Internal.GCompare Hasura.Incremental.Internal.Dependency.DependencyKey


-- | Defines the basic <a>Rule</a> datatype and its core operations.
module Hasura.Incremental.Internal.Rule

-- | A value of type <tt><a>Rule</a> m a b</tt> is a <i>build rule</i>: a
--   computation that describes how to build a value of type <tt>b</tt>
--   from a value of type <tt>a</tt> in a monad <tt>m</tt>. What
--   distinguishes <tt><a>Rule</a> m a b</tt> from an ordinary function of
--   type <tt>a -&gt; m b</tt> is that it can be made <i>incremental</i>
--   (in the sense of “incremental compilation”)—after executing it, future
--   executions can perform a subset of the required work if only a portion
--   of the input changed.
--   
--   To achieve this, <a>Rule</a>s have a more restrictive interface: there
--   is no <tt>Monad (<a>Rule</a> m a)</tt> instance, for example. Instead,
--   <a>Rule</a>s are composed using the <a>Arrow</a> hierarchy of
--   operations, which ensures that the dependency graph of build rules is
--   mostly static (though it may contain conditional branches, and
--   combinators such as <a>keyed</a> can express restricted forms of
--   dynamic dependencies). Each atomic rule may be defined using the
--   <a>Monad</a> instance for <tt>m</tt>, but incrementalization is not
--   supported inside those rules — they are treated as a single,
--   monolithic computation.
--   
--   Atomic rules are created with the <a>arrM</a> function, and caching
--   can be added to a rule using the <tt>cache</tt> combinator. Rules can
--   be executed using the <a>build</a> function, which returns a
--   <a>Result</a>. A <a>Result</a> contains the built value, accessible
--   via <a>result</a>, but it also allows supplying a new input value
--   using <a>rebuild</a> to produce a new result incrementally.
newtype Rule m a b
Rule :: (forall r. Accesses -> a -> (Accesses -> b -> Rule m a b -> m r) -> m r) -> Rule m a b
build :: Applicative m => Rule m a b -> a -> m (Result m a b)
data Result m a b
Result :: !b -> !Rule m a b -> Result m a b
[result] :: Result m a b -> !b
[rebuildRule] :: Result m a b -> !Rule m a b
rebuild :: Applicative m => Result m a b -> a -> m (Result m a b)
rComp :: Rule m a1 b -> Rule m a2 a1 -> Rule m a2 b
rId :: Rule m a a
rArr :: (a -> b) -> Rule m a b
rArrM :: Monad m => (a -> m b) -> Rule m a b
rFirst :: Rule m a b1 -> Rule m (a, b2) (b1, b2)
rLeft :: Rule m a b1 -> Rule m (Either a b2) (Either b1 b2)
rPure :: b -> Rule m a b
rSecond :: Rule m a1 b -> Rule m (a2, a1) (a2, b)
swapEither :: Either a b -> Either b a
rRight :: Rule m a1 b -> Rule m (Either a2 a1) (Either a2 b)
rSplit :: Rule m a1 b1 -> Rule m a2 b2 -> Rule m (a1, a2) (b1, b2)
rFanout :: Rule m a b1 -> Rule m a b2 -> Rule m a (b1, b2)
rFork :: Rule m a1 b1 -> Rule m a2 b2 -> Rule m (Either a1 a2) (Either b1 b2)
fromEither :: Either a a -> a
rFanin :: Rule m a1 b -> Rule m a2 b -> Rule m (Either a1 a2) b
class (Arrow arr) => ArrowDistribute arr

-- | Distributes an arrow that operates on key-value pairs, over a
--   <a>HashMap</a> in an order-independent way.
--   
--   This is intended to be used as a control operator in <tt>proc</tt>
--   notation; see Note [Weird control operator types] in
--   <a>Control.Arrow.Extended</a>.
keyed :: (ArrowDistribute arr, Eq k, Hashable k) => arr (e, (k, (a, s))) b -> arr (e, (HashMap k a, s)) (HashMap k b)
instance GHC.Base.Functor (Hasura.Incremental.Internal.Rule.Result m a)
instance (GHC.Base.Monoid w, Hasura.Incremental.Internal.Rule.ArrowDistribute arr) => Hasura.Incremental.Internal.Rule.ArrowDistribute (Control.Arrow.Trans.WriterA w arr)
instance Hasura.Incremental.Internal.Rule.ArrowDistribute (Hasura.Incremental.Internal.Rule.Rule m)
instance GHC.Base.Functor (Hasura.Incremental.Internal.Rule.Rule m a)
instance GHC.Base.Applicative (Hasura.Incremental.Internal.Rule.Rule m a)
instance Data.Profunctor.Unsafe.Profunctor (Hasura.Incremental.Internal.Rule.Rule m)
instance Data.Profunctor.Strong.Strong (Hasura.Incremental.Internal.Rule.Rule m)
instance Data.Profunctor.Choice.Choice (Hasura.Incremental.Internal.Rule.Rule m)
instance Control.Category.Category (Hasura.Incremental.Internal.Rule.Rule m)
instance Control.Arrow.Arrow (Hasura.Incremental.Internal.Rule.Rule m)
instance Control.Arrow.ArrowChoice (Hasura.Incremental.Internal.Rule.Rule m)
instance GHC.Base.Monad m => Control.Arrow.Extended.ArrowKleisli m (Hasura.Incremental.Internal.Rule.Rule m)

module Hasura.Incremental.Internal.Cache
class (ArrowKleisli m arr) => ArrowCache m arr | arr -> m

-- | Adds equality-based caching to the given arrow. After each execution
--   of the arrow, its input and result values are cached. On the next
--   execution, the new input value is compared via <a>==</a> to the
--   previous input value. If they are the same, the previous result is
--   returned <i>without</i> re-executing the arrow. Otherwise, the old
--   cached values are discarded, and the arrow is re-executed to produce a
--   new set of cached values.
--   
--   Indescriminate use of <a>cache</a> is likely to have little effect
--   except to increase memory usage, since the input and result of each
--   execution must be retained in memory. Avoid using <a>cache</a> around
--   arrows with large input or output that is likely to change often
--   unless profiling indicates it is computationally expensive enough to
--   be worth the memory overhead.
--   
--   <b>Note that only direct inputs and outputs of the given arrow are
--   cached.</b> If an arrow provides access to values through a
--   side-channel, they will <b>not</b> participate in caching.
cache :: (ArrowCache m arr, Cacheable a) => arr a b -> arr a b

-- | Creates a new <a>Dependency</a>, which allows fine-grained caching of
--   composite values; see the documentation for <a>Dependency</a> for more
--   details.
newDependency :: ArrowCache m arr => arr a (Dependency a)

-- | Extract the value from a <a>Dependency</a>, incurring a dependency on
--   its entirety. To depend on only a portion of the value, use
--   <a>selectD</a> or <a>selectKeyD</a> before passing it to
--   <a>dependOn</a>.
dependOn :: (ArrowCache m arr, Cacheable a) => arr (Dependency a) a

-- | Run a monadic sub-computation with the ability to access dependencies;
--   see <a>MonadDepend</a> for more details.
bindDepend :: ArrowCache m arr => arr (DependT m a) a

-- | A restricted, monadic variant of <a>ArrowCache</a> that can only read
--   dependencies, not create new ones or add local caching. This serves as
--   a limited adapter between arrow and monadic code.
class (Monad m) => MonadDepend m
dependOnM :: (MonadDepend m, Cacheable a) => Dependency a -> m a
newtype DependT m a
DependT :: StateT Accesses m a -> DependT m a
[unDependT] :: DependT m a -> StateT Accesses m a
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.Incremental.Internal.Cache.DependT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.Incremental.Internal.Cache.DependT
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.Incremental.Internal.Cache.DependT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.Incremental.Internal.Cache.DependT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.Incremental.Internal.Cache.DependT m)
instance (Control.Arrow.ArrowChoice arr, Hasura.Incremental.Internal.Cache.ArrowCache m arr) => Hasura.Incremental.Internal.Cache.ArrowCache m (Control.Arrow.Trans.ErrorA e arr)
instance (GHC.Base.Monoid w, Hasura.Incremental.Internal.Cache.ArrowCache m arr) => Hasura.Incremental.Internal.Cache.ArrowCache m (Control.Arrow.Trans.WriterA w arr)
instance Control.Monad.Unique.MonadUnique m => Hasura.Incremental.Internal.Cache.ArrowCache m (Hasura.Incremental.Internal.Rule.Rule m)
instance GHC.Base.Monad m => Hasura.Incremental.Internal.Cache.MonadDepend (Hasura.Incremental.Internal.Cache.DependT m)
instance Hasura.Incremental.Internal.Cache.MonadDepend m => Hasura.Incremental.Internal.Cache.MonadDepend (Control.Monad.Trans.Except.ExceptT e m)


-- | A simple implementation of <i>incremental build rules</i>, which can
--   be used to avoid unnecessary recomputation on incrementally-changing
--   input. See <a>Rule</a> for more details.
module Hasura.Incremental

-- | A simple helper type that can be used to implement explicit cache
--   invalidation. Internally, each <a>InvalidationKey</a> is a counter;
--   <a>initialInvalidationKey</a> starts the counter at 0 and
--   <a>invalidate</a> increments it by 1. Two <a>InvalidationKey</a>s are
--   equal iff they have the same internal count, so depending on an
--   <a>InvalidationKey</a> provides a mechanism to force portions of the
--   build process to be reexecuted by calling <a>invalidate</a> before
--   running the build.
newtype InvalidationKey
InvalidationKey :: Int -> InvalidationKey
initialInvalidationKey :: InvalidationKey
invalidate :: InvalidationKey -> InvalidationKey
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Incremental.InvalidationKey
instance GHC.Classes.Eq Hasura.Incremental.InvalidationKey
instance GHC.Show.Show Hasura.Incremental.InvalidationKey

module Hasura.Session
newtype RoleName
RoleName :: NonEmptyText -> RoleName
[getRoleTxt] :: RoleName -> NonEmptyText
roleNameToTxt :: RoleName -> Text
mkRoleName :: Text -> Maybe RoleName
mkRoleNameSafe :: NonEmptyText -> RoleName
adminRoleName :: RoleName
newtype SessionVariable
SessionVariable :: CI Text -> SessionVariable
[unSessionVariable] :: SessionVariable -> CI Text

-- | Converts a <a>SessionVariable</a> value to a GraphQL name. This will
--   fail if the session variable contains characters that are not valid
--   for a graphql names. It is the caller's responsibility to decide what
--   to do in such a case.
sessionVariableToGraphQLName :: SessionVariable -> Maybe Name
parseSessionVariable :: Text -> Parser SessionVariable
sessionVariableToText :: SessionVariable -> Text
mkSessionVariable :: Text -> SessionVariable
type SessionVariableValue = Text
newtype SessionVariables
SessionVariables :: HashMap SessionVariable SessionVariableValue -> SessionVariables
[unSessionVariables] :: SessionVariables -> HashMap SessionVariable SessionVariableValue
filterSessionVariables :: (SessionVariable -> SessionVariableValue -> Bool) -> SessionVariables -> SessionVariables
mkSessionVariablesText :: HashMap Text Text -> SessionVariables
mkSessionVariablesHeaders :: [Header] -> SessionVariables
sessionVariablesToHeaders :: SessionVariables -> [Header]
getSessionVariables :: SessionVariables -> [Text]
getSessionVariablesSet :: SessionVariables -> HashSet SessionVariable
getSessionVariableValue :: SessionVariable -> SessionVariables -> Maybe SessionVariableValue

-- | Represent the admin secret state; whether the secret is sent in the
--   request or if actually authorization is not configured.
data UserAdminSecret
UAdminSecretSent :: UserAdminSecret
UAdminSecretNotSent :: UserAdminSecret
UAuthNotSet :: UserAdminSecret

-- | Represents the 'X-Hasura-Use-Backend-Only-Permissions' session
--   variable and request made with 'X-Hasura-Admin-Secret' if any auth
--   configured. For more details see Note [Backend only permissions]
data BackendOnlyFieldAccess
BOFAAllowed :: BackendOnlyFieldAccess
BOFADisallowed :: BackendOnlyFieldAccess
data UserInfo
UserInfo :: !RoleName -> !SessionVariables -> !BackendOnlyFieldAccess -> UserInfo
[_uiRole] :: UserInfo -> !RoleName
[_uiSession] :: UserInfo -> !SessionVariables
[_uiBackendOnlyFieldAccess] :: UserInfo -> !BackendOnlyFieldAccess
class (Monad m) => UserInfoM m
askUserInfo :: UserInfoM m => m UserInfo
askCurRole :: UserInfoM m => m RoleName

-- | Represents how to build a role from the session variables
data UserRoleBuild

-- | Look for `x-hasura-role` session variable value and absence will raise
--   an exception
URBFromSessionVariables :: UserRoleBuild

-- | Look for `x-hasura-role` session variable value, if absent fall back
--   to given role
URBFromSessionVariablesFallback :: !RoleName -> UserRoleBuild

-- | Use only the pre-determined role
URBPreDetermined :: !RoleName -> UserRoleBuild

-- | Build <tt><a>UserInfo</a> from </tt><a>SessionVariables</a>
mkUserInfo :: forall m. MonadError QErr m => UserRoleBuild -> UserAdminSecret -> SessionVariables -> m UserInfo
maybeRoleFromSessionVariables :: SessionVariables -> Maybe RoleName
adminUserInfo :: UserInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Session.RoleName
instance Control.DeepSeq.NFData Hasura.Session.RoleName
instance GHC.Generics.Generic Hasura.Session.RoleName
instance Database.PG.Query.Class.ToPrepArg Hasura.Session.RoleName
instance Database.PG.Query.Class.FromCol Hasura.Session.RoleName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Session.RoleName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Session.RoleName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Session.RoleName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Session.RoleName
instance Data.Hashable.Class.Hashable Hasura.Session.RoleName
instance GHC.Classes.Ord Hasura.Session.RoleName
instance GHC.Classes.Eq Hasura.Session.RoleName
instance GHC.Show.Show Hasura.Session.RoleName
instance GHC.Classes.Ord Hasura.Session.SessionVariable
instance Control.DeepSeq.NFData Hasura.Session.SessionVariable
instance Data.Data.Data Hasura.Session.SessionVariable
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Session.SessionVariable
instance Data.String.IsString Hasura.Session.SessionVariable
instance Data.Hashable.Class.Hashable Hasura.Session.SessionVariable
instance GHC.Classes.Eq Hasura.Session.SessionVariable
instance GHC.Show.Show Hasura.Session.SessionVariable
instance GHC.Base.Monoid Hasura.Session.SessionVariables
instance GHC.Base.Semigroup Hasura.Session.SessionVariables
instance Data.Hashable.Class.Hashable Hasura.Session.SessionVariables
instance GHC.Classes.Eq Hasura.Session.SessionVariables
instance GHC.Show.Show Hasura.Session.SessionVariables
instance GHC.Classes.Eq Hasura.Session.UserAdminSecret
instance GHC.Show.Show Hasura.Session.UserAdminSecret
instance GHC.Generics.Generic Hasura.Session.BackendOnlyFieldAccess
instance GHC.Classes.Eq Hasura.Session.BackendOnlyFieldAccess
instance GHC.Show.Show Hasura.Session.BackendOnlyFieldAccess
instance GHC.Generics.Generic Hasura.Session.UserInfo
instance GHC.Classes.Eq Hasura.Session.UserInfo
instance GHC.Show.Show Hasura.Session.UserInfo
instance GHC.Classes.Eq Hasura.Session.UserRoleBuild
instance GHC.Show.Show Hasura.Session.UserRoleBuild
instance Hasura.Session.UserInfoM m => Hasura.Session.UserInfoM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Session.UserInfoM m => Hasura.Session.UserInfoM (Control.Monad.Trans.Except.ExceptT r m)
instance Hasura.Session.UserInfoM m => Hasura.Session.UserInfoM (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.Session.UserInfoM m => Hasura.Session.UserInfoM (Hasura.Tracing.TraceT m)
instance Data.Hashable.Class.Hashable Hasura.Session.UserInfo
instance Data.Hashable.Class.Hashable Hasura.Session.BackendOnlyFieldAccess
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Session.SessionVariables
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Session.SessionVariables
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Session.SessionVariable
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Session.SessionVariable
instance Data.Text.Extended.ToTxt Hasura.Session.SessionVariable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Session.SessionVariable
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Session.SessionVariable
instance Data.Text.Extended.ToTxt Hasura.Session.RoleName


-- | This module implements the bulk of Hasura's JWT capabilities and
--   interactions. Its main point of non-testing invocation is <a>Auth</a>.
--   
--   It exports both <a>processJwt</a> and <a>processJwt_</a> with
--   <a>processJwt_</a> being the majority of the implementation with the
--   JWT Token processing function passed in as an argument in order to
--   enable mocking in test-code.
--   
--   In <a>processJwt_</a>, prior to validation of the token, first the
--   token locations and issuers are reconciled. Locations are either
--   specified as auth or cookie (with cookie name) or assumed to be auth.
--   Issuers can be omitted or specified, where an omitted configured
--   issuer can match any issuer specified by a request.
--   
--   If none match, then this is considered an no-auth request, if one
--   matches, then normal token auth is performed, and if multiple match,
--   then this is considered an ambiguity error.
module Hasura.Server.Auth.JWT
newtype RawJWT
RawJWT :: ByteString -> RawJWT
data JWTClaimsFormat
JCFJson :: JWTClaimsFormat
JCFStringifiedJson :: JWTClaimsFormat
data JWTHeader
JHAuthorization :: JWTHeader
JHCookie :: Text -> JWTHeader
defaultClaimsFormat :: JWTClaimsFormat
allowedRolesClaim :: SessionVariable
defaultRoleClaim :: SessionVariable
defaultClaimsNamespace :: Text

-- | <a>JWTCustomClaimsMapValueG</a> is used to represent a single value of
--   the <a>JWTCustomClaimsMap</a>. A <a>JWTCustomClaimsMapValueG</a> can
--   either be an JSON object or the literal value of the claim. If the
--   value is an JSON object, then it should contain a key <tt>path</tt>,
--   which is the JSON path to the claim value in the JWT token. There's
--   also an option to specify a default value in the map via the 'default'
--   key, which will be used when a peek at the JWT token using the JSON
--   path fails (key does not exist).
data JWTCustomClaimsMapValueG v

-- | JSONPath to the key in the claims map, in case the key doesn't exist
--   in the claims map then the default value will be used (if provided)
JWTCustomClaimsMapJSONPath :: !JSONPath -> !Maybe v -> JWTCustomClaimsMapValueG v
JWTCustomClaimsMapStatic :: !v -> JWTCustomClaimsMapValueG v
type JWTCustomClaimsMapDefaultRole = JWTCustomClaimsMapValueG RoleName
type JWTCustomClaimsMapAllowedRoles = JWTCustomClaimsMapValueG [RoleName]
type JWTCustomClaimsMapValue = JWTCustomClaimsMapValueG SessionVariableValue
type CustomClaimsMap = HashMap SessionVariable JWTCustomClaimsMapValue

-- | JWTClaimsMap is an option to provide a custom JWT claims map. The
--   JWTClaimsMap should be specified in the
--   <tt>HASURA_GRAPHQL_JWT_SECRET</tt> in the <tt>claims_map</tt>. The
--   JWTClaimsMap, if specified, requires two mandatory fields, namely,
--   `x-hasura-allowed-roles` and the `x-hasura-default-role`, other claims
--   may also be provided in the claims map.
data JWTCustomClaimsMap
JWTCustomClaimsMap :: !JWTCustomClaimsMapDefaultRole -> !JWTCustomClaimsMapAllowedRoles -> !CustomClaimsMap -> JWTCustomClaimsMap
[jcmDefaultRole] :: JWTCustomClaimsMap -> !JWTCustomClaimsMapDefaultRole
[jcmAllowedRoles] :: JWTCustomClaimsMap -> !JWTCustomClaimsMapAllowedRoles
[jcmCustomClaims] :: JWTCustomClaimsMap -> !CustomClaimsMap

-- | JWTNamespace is used to locate the claims map within the JWT token.
--   The location can be either provided via a JSON path or the name of the
--   key in the JWT token.
data JWTNamespace
ClaimNsPath :: JSONPath -> JWTNamespace
ClaimNs :: Text -> JWTNamespace
data JWTClaims
JCNamespace :: !JWTNamespace -> !JWTClaimsFormat -> JWTClaims
JCMap :: !JWTCustomClaimsMap -> JWTClaims

-- | Hashable Wrapper for constructing a HashMap of JWTConfigs
newtype StringOrURI
StringOrURI :: StringOrURI -> StringOrURI
[unStringOrURI] :: StringOrURI -> StringOrURI

-- | The JWT configuration we got from the user.
data JWTConfig
JWTConfig :: !Either JWK URI -> !Maybe Audience -> !Maybe StringOrURI -> !JWTClaims -> !Maybe NominalDiffTime -> !Maybe JWTHeader -> JWTConfig
[jcKeyOrUrl] :: JWTConfig -> !Either JWK URI
[jcAudience] :: JWTConfig -> !Maybe Audience
[jcIssuer] :: JWTConfig -> !Maybe StringOrURI
[jcClaims] :: JWTConfig -> !JWTClaims
[jcAllowedSkew] :: JWTConfig -> !Maybe NominalDiffTime
[jcHeader] :: JWTConfig -> !Maybe JWTHeader

-- | The validated runtime JWT configuration returned by <tt>mkJwtCtx</tt>
--   in <tt>setupAuthMode</tt>.
--   
--   This is also evidence that the <a>jwkRefreshCtrl</a> thread is
--   running, if an expiration schedule could be determined.
data JWTCtx
JWTCtx :: !IORef JWKSet -> !Maybe Audience -> !Maybe StringOrURI -> !JWTClaims -> !Maybe NominalDiffTime -> !JWTHeader -> JWTCtx

-- | This needs to be a mutable variable for <a>updateJwkRef</a>.
[jcxKey] :: JWTCtx -> !IORef JWKSet
[jcxAudience] :: JWTCtx -> !Maybe Audience
[jcxIssuer] :: JWTCtx -> !Maybe StringOrURI
[jcxClaims] :: JWTCtx -> !JWTClaims
[jcxAllowedSkew] :: JWTCtx -> !Maybe NominalDiffTime
[jcxHeader] :: JWTCtx -> !JWTHeader
data HasuraClaims
HasuraClaims :: ![RoleName] -> !RoleName -> HasuraClaims
[_cmAllowedRoles] :: HasuraClaims -> ![RoleName]
[_cmDefaultRole] :: HasuraClaims -> !RoleName

-- | An action that refreshes the JWK at intervals in an infinite loop.
jwkRefreshCtrl :: (MonadIO m, MonadBaseControl IO m, HasReporter m) => Logger Hasura -> Manager -> URI -> IORef JWKSet -> DiffTime -> m void

-- | Given a JWK url, fetch JWK from it and update the IORef
updateJwkRef :: (MonadIO m, MonadBaseControl IO m, MonadError JwkFetchError m, MonadTrace m) => Logger Hasura -> Manager -> URI -> IORef JWKSet -> m (Maybe NominalDiffTime)

-- | First check for Cache-Control header, if not found, look for Expires
--   header
determineJwkExpiryLifetime :: forall m. (MonadIO m, MonadError JwkFetchError m) => m UTCTime -> Logger Hasura -> ResponseHeaders -> m (Maybe NominalDiffTime)
type ClaimsMap = HashMap SessionVariable Value

-- | Decode a Jose ClaimsSet without verifying the signature
decodeClaimsSet :: RawJWT -> Maybe ClaimsSet

-- | Extract the issuer from a bearer tokena _without_ verifying it.
tokenIssuer :: RawJWT -> Maybe StringOrURI

-- | Process the request headers to verify the JWT and extract UserInfo
--   from it From the JWT config, we check which header to expect, it can
--   be the <a>Authorization</a> or <a>Cookie</a> header
--   
--   Iff no <a>Authorization</a>/<a>Cookie</a> header was passed, we will
--   fall back to the unauthenticated user role [1], if one was configured
--   at server start.
--   
--   When no 'x-hasura-user-role' is specified in the request, the
--   mandatory 'x-hasura-default-role' [2] from the JWT claims will be
--   used.
processJwt :: (MonadIO m, MonadError QErr m) => [JWTCtx] -> RequestHeaders -> Maybe RoleName -> m (UserInfo, Maybe UTCTime, [Header])
type AuthTokenLocation = JWTHeader
processJwt_ :: MonadError QErr m => (JWTCtx -> ByteString -> m (ClaimsMap, Maybe UTCTime)) -> (RawJWT -> Maybe StringOrURI) -> (JWTCtx -> JWTHeader) -> [JWTCtx] -> RequestHeaders -> Maybe RoleName -> m (UserInfo, Maybe UTCTime, [Header])

-- | Processes a token payload (excluding the `Bearer ` prefix in the
--   context of a JWTCtx)
processHeaderSimple :: (MonadIO m, MonadError QErr m) => JWTCtx -> ByteString -> m (ClaimsMap, Maybe UTCTime)

-- | parse the claims map from the JWT token or custom claims from the JWT
--   config
parseClaimsMap :: MonadError QErr m => ClaimsSet -> JWTClaims -> m ClaimsMap

-- | Verify the JWT against given JWK
verifyJwt :: (MonadError JWTError m, MonadIO m) => JWTCtx -> RawJWT -> m ClaimsSet
parseHasuraClaims :: forall m. MonadError QErr m => ClaimsMap -> m HasuraClaims
parseJwtClaim :: (FromJSON a, MonadError QErr m) => Value -> Text -> m a
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.HasuraClaims
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.HasuraClaims
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTConfig
instance GHC.Generics.Generic Hasura.Server.Auth.JWT.JWTHeader
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTHeader
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTHeader
instance Data.Traversable.Traversable Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG
instance Data.Foldable.Foldable Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG
instance GHC.Base.Functor Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG
instance GHC.Classes.Eq v => GHC.Classes.Eq (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance GHC.Show.Show v => GHC.Show.Show (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTNamespace
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTNamespace
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTClaims
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTClaims
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.StringOrURI
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.StringOrURI
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.StringOrURI
instance GHC.Show.Show Hasura.Server.Auth.JWT.StringOrURI
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTConfig
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTConfig
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTCtx
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.HasuraClaims
instance GHC.Show.Show Hasura.Server.Auth.JWT.HasuraClaims
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTCtx
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Server.Auth.JWT.StringOrURI
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Server.Auth.JWT.StringOrURI
instance Data.Aeson.Types.ToJSON.ToJSONKey (GHC.Maybe.Maybe Hasura.Server.Auth.JWT.StringOrURI)
instance Data.Aeson.Types.FromJSON.FromJSONKey (GHC.Maybe.Maybe Hasura.Server.Auth.JWT.StringOrURI)
instance Data.Hashable.Class.Hashable Hasura.Server.Auth.JWT.StringOrURI
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTNamespace
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance Data.Aeson.Types.FromJSON.FromJSON v => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance Data.Aeson.Types.ToJSON.ToJSON v => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance Data.Hashable.Class.Hashable Hasura.Server.Auth.JWT.JWTHeader
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTHeader
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTHeader
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTClaimsFormat
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTClaimsFormat
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTClaimsFormat
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTClaimsFormat

module Hasura.RQL.Types.ApiLimit
data ApiLimit
ApiLimit :: Maybe RateLimit -> Maybe DepthLimit -> Maybe NodeLimit -> Maybe TimeLimit -> Bool -> ApiLimit
[_alRateLimit] :: ApiLimit -> Maybe RateLimit
[_alDepthLimit] :: ApiLimit -> Maybe DepthLimit
[_alNodeLimit] :: ApiLimit -> Maybe NodeLimit
[_alTimeLimit] :: ApiLimit -> Maybe TimeLimit
[_alDisabled] :: ApiLimit -> Bool
emptyApiLimit :: ApiLimit
data Limit a
Limit :: a -> InsOrdHashMap RoleName a -> Limit a
[_lGlobal] :: Limit a -> a
[_lPerRole] :: Limit a -> InsOrdHashMap RoleName a
type RateLimit = Limit RateLimitConfig
type DepthLimit = Limit MaxDepth
type NodeLimit = Limit MaxNodes
type TimeLimit = Limit MaxTime
data RateLimitConfig
RateLimitConfig :: Int -> Maybe UniqueParamConfig -> RateLimitConfig
[_rlcMaxReqsPerMin] :: RateLimitConfig -> Int
[_rlcUniqueParams] :: RateLimitConfig -> Maybe UniqueParamConfig

-- | The unique key using which an authenticated client can be identified
data UniqueParamConfig

-- | it can be a list of session variable (like session var in
--   <tt>UserInfo</tt>)
UPCSessionVar :: [Text] -> UniqueParamConfig

-- | or it can be an IP address
UPCIpAddress :: UniqueParamConfig
newtype MaxDepth
MaxDepth :: Int -> MaxDepth
[unMaxDepth] :: MaxDepth -> Int
newtype MaxNodes
MaxNodes :: Int -> MaxNodes
[unMaxNodes] :: MaxNodes -> Int
newtype MaxTime
MaxTime :: Seconds -> MaxTime
[unMaxTime] :: MaxTime -> Seconds
instance GHC.Generics.Generic (Hasura.RQL.Types.ApiLimit.Limit a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.ApiLimit.Limit a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.ApiLimit.Limit a)
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.MaxDepth
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Classes.Ord Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.MaxDepth
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.MaxNodes
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Classes.Ord Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.MaxNodes
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.MaxTime
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Classes.Ord Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.ApiLimit
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.ApiLimit
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.ApiLimit
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.ApiLimit
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.ApiLimit
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.ApiLimit.MaxTime
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.ApiLimit.Limit a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.ApiLimit.Limit a)


-- | Module of reusable functions for Kriti transforms.
--   
--   NOTE: This defines an alternative <a>runKritiWith</a> that includes
--   the basicFunctions by default. You should probably invoke Kriti
--   through this module rather than directly in order to make updating the
--   functions available only require touching this module.
--   
--   TODO: This should be added to the documentation and referenced in
--   (for-example) REST Connectors once the documentation refactor project
--   is complete.
module Data.Aeson.Kriti.Functions
type KritiFunc = Value -> Either CustomFunctionError Value

-- | <a>runKriti</a> attaches the basicFunctions by default NOTE: The error
--   type is SerializedError due to KritiError not currently being exported
runKriti :: Text -> [(Text, Value)] -> Either SerializedError Value

-- | <a>runKritiWith</a> attaches the basicFunctions by default.
runKritiWith :: Text -> [(Text, Value)] -> HashMap Text KritiFunc -> Either SerializedError Value

-- | Re-Export of the Kriti <tt>stdlib</tt>
basicFunctions :: HashMap Text KritiFunc

-- | Functions that interact with environment variables
environmentFunctions :: Environment -> HashMap Text KritiFunc

-- | Functions that interact with HGE session during requests
sessionFunctions :: Maybe SessionVariables -> HashMap Text KritiFunc

module Hasura.SQL.Types
class ToSQL a
toSQL :: ToSQL a => a -> Builder
toSQLTxt :: ToSQL a => a -> Text

-- | The type of all Postgres types (i.e. scalars and arrays). This type is
--   parameterized so that we can have both <tt><a>CollectableType</a>
--   <tt>PGScalarType</tt></tt> and <tt><a>CollectableType</a>
--   <a>PGColumnType</a></tt>, for when we care about the distinction made
--   by <a>PGColumnType</a>. If we ever change <a>PGColumnType</a> to
--   handle arrays, not just scalars, then the parameterization can go
--   away.
--   
--   TODO (from master): This is incorrect modeling, as
--   <tt>PGScalarType</tt> will capture anything (under
--   <tt>PGUnknown</tt>). This should be fixed when support for all types
--   is merged.
data CollectableType a
CollectableTypeScalar :: !a -> CollectableType a
CollectableTypeArray :: !a -> CollectableType a

-- | The name of the schema in which the graphql-engine will install
--   database extensions.
newtype ExtensionsSchema
ExtensionsSchema :: Text -> ExtensionsSchema
[_unExtensionsSchema] :: ExtensionsSchema -> Text
instance Control.DeepSeq.NFData Hasura.SQL.Types.ExtensionsSchema
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.SQL.Types.ExtensionsSchema
instance Data.Hashable.Class.Hashable Hasura.SQL.Types.ExtensionsSchema
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.Types.ExtensionsSchema
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.Types.ExtensionsSchema
instance GHC.Classes.Eq Hasura.SQL.Types.ExtensionsSchema
instance GHC.Show.Show Hasura.SQL.Types.ExtensionsSchema
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.SQL.Types.CollectableType a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.Types.CollectableType a)
instance Hasura.SQL.Types.ToSQL a => Hasura.SQL.Types.ToSQL (Hasura.SQL.Types.CollectableType a)
instance GHC.Base.Functor Hasura.SQL.Types.CollectableType
instance Data.Data.Data a => Data.Data.Data (Hasura.SQL.Types.CollectableType a)
instance GHC.Generics.Generic (Hasura.SQL.Types.CollectableType a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.SQL.Types.CollectableType a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.SQL.Types.CollectableType a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.SQL.Types.CollectableType a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.SQL.Types.CollectableType a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.SQL.Types.CollectableType a)
instance Hasura.SQL.Types.ToSQL Text.Builder.Builder
instance Hasura.SQL.Types.ToSQL a => Hasura.SQL.Types.ToSQL (GHC.Maybe.Maybe a)

module Hasura.RQL.Types.Roles
newtype ParentRoles
ParentRoles :: HashSet RoleName -> ParentRoles
[_unParentRoles] :: ParentRoles -> HashSet RoleName

-- | The <a>Role</a> type represents a role by containing its name and the
--   names of its parent roles. This type is used externally in the
--   <tt>add_inherited_role</tt> metadata API and is also used internally
--   in the permission building part of the schema cache building process
data Role
Role :: RoleName -> ParentRoles -> Role
[_rRoleName] :: Role -> RoleName

-- | set of the parent role names, in case of non-inherited roles it will
--   be an empty set
[_rParentRoles] :: Role -> ParentRoles
type InheritedRole = Role
newtype DropInheritedRole
DropInheritedRole :: RoleName -> DropInheritedRole
[_ddrRoleName] :: DropInheritedRole -> RoleName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Roles.DropInheritedRole
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Roles.DropInheritedRole
instance GHC.Generics.Generic Hasura.RQL.Types.Roles.ParentRoles
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Roles.ParentRoles
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Roles.ParentRoles
instance GHC.Classes.Eq Hasura.RQL.Types.Roles.ParentRoles
instance GHC.Show.Show Hasura.RQL.Types.Roles.ParentRoles
instance GHC.Generics.Generic Hasura.RQL.Types.Roles.Role
instance GHC.Classes.Eq Hasura.RQL.Types.Roles.Role
instance GHC.Show.Show Hasura.RQL.Types.Roles.Role
instance GHC.Classes.Eq Hasura.RQL.Types.Roles.DropInheritedRole
instance GHC.Show.Show Hasura.RQL.Types.Roles.DropInheritedRole
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Roles.Role
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Roles.Role
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Roles.Role
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Roles.Role
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Roles.ParentRoles
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Roles.ParentRoles

module Hasura.RQL.Types.QueryTags
data QueryTagsFormat
Standard :: QueryTagsFormat
SQLCommenter :: QueryTagsFormat

-- | QueryTagsConfig is the configuration created by the users to control
--   query tags
--   
--   This config let's hasura know about the followingL 1. In what format
--   should the query tags be created 2. Should they be appended to the SQL
--   
--   FWIW, <a>QueryTagsConfig</a> are coupled along with the Source
--   metadata. So you can also think <a>QueryTagsConfig</a> as the query
--   tags configuration for each source.
--   
--   The workflow is something like this:
--   
--   <ol>
--   <li>The <a>QueryTagsConfig</a> for a source is created from the
--   metadata we get from the user.</li>
--   <li>This configuration is packaged (for the lack of better word) along
--   with SourceConfigWith</li>
--   <li>These query tags configuration are extracted from the
--   <tt>SourceConfigWith</tt> in the <tt>mkDBQueryPlan</tt>,
--   <tt>mkDBMutationPlan</tt>, <tt>mkDBSubscriptionPlan</tt> functions and
--   are passed along to the point where the actual SQL generation takes
--   place</li>
--   </ol>
--   
--   Note that, it is important for <a>QueryTagsConfig</a> to be a part of
--   <tt>SourceConfigWith</tt> because that's the only sane way (that we
--   can think of) the `mkDB..Plan` functions can get the QueryTagsConfig.
data QueryTagsConfig
QueryTagsConfig :: !Bool -> !QueryTagsFormat -> QueryTagsConfig
[_qtcDisabled] :: QueryTagsConfig -> !Bool
[_qtcFormat] :: QueryTagsConfig -> !QueryTagsFormat
defaultQueryTagsConfig :: QueryTagsConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryTags.QueryTagsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryTags.QueryTagsConfig
instance GHC.Generics.Generic Hasura.RQL.Types.QueryTags.QueryTagsFormat
instance GHC.Classes.Eq Hasura.RQL.Types.QueryTags.QueryTagsFormat
instance GHC.Show.Show Hasura.RQL.Types.QueryTags.QueryTagsFormat
instance GHC.Generics.Generic Hasura.RQL.Types.QueryTags.QueryTagsConfig
instance GHC.Classes.Eq Hasura.RQL.Types.QueryTags.QueryTagsConfig
instance GHC.Show.Show Hasura.RQL.Types.QueryTags.QueryTagsConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.QueryTags.QueryTagsConfig
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryTags.QueryTagsConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryTags.QueryTagsConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.QueryTags.QueryTagsFormat
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryTags.QueryTagsFormat
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryTags.QueryTagsFormat
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryTags.QueryTagsFormat
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryTags.QueryTagsFormat

module Hasura.RQL.Types.QueryCollection
newtype CollectionName
CollectionName :: NonEmptyText -> CollectionName
[unCollectionName] :: CollectionName -> NonEmptyText
newtype QueryName
QueryName :: NonEmptyText -> QueryName
[unQueryName] :: QueryName -> NonEmptyText
newtype GQLQuery
GQLQuery :: ExecutableDocument Name -> GQLQuery
[unGQLQuery] :: GQLQuery -> ExecutableDocument Name
newtype GQLQueryWithText
GQLQueryWithText :: (Text, GQLQuery) -> GQLQueryWithText
getGQLQuery :: GQLQueryWithText -> GQLQuery
getGQLQueryText :: GQLQueryWithText -> Text
data ListedQuery
ListedQuery :: QueryName -> GQLQueryWithText -> ListedQuery
[_lqName] :: ListedQuery -> QueryName
[_lqQuery] :: ListedQuery -> GQLQueryWithText
newtype CollectionDef
CollectionDef :: [ListedQuery] -> CollectionDef
[_cdQueries] :: CollectionDef -> [ListedQuery]
cdQueries :: Iso' CollectionDef [ListedQuery]
data CreateCollection
CreateCollection :: CollectionName -> CollectionDef -> Maybe Text -> CreateCollection
[_ccName] :: CreateCollection -> CollectionName
[_ccDefinition] :: CreateCollection -> CollectionDef
[_ccComment] :: CreateCollection -> Maybe Text
ccName :: Lens' CreateCollection CollectionName
ccDefinition :: Lens' CreateCollection CollectionDef
ccComment :: Lens' CreateCollection (Maybe Text)
collectionQueries :: CreateCollection -> [ExecutableDocument Name]
data RenameCollection
RenameCollection :: CollectionName -> CollectionName -> RenameCollection
[_rcName] :: RenameCollection -> CollectionName
[_rcNewName] :: RenameCollection -> CollectionName
rcNewName :: Lens' RenameCollection CollectionName
rcName :: Lens' RenameCollection CollectionName
data DropCollection
DropCollection :: CollectionName -> Bool -> DropCollection
[_dcCollection] :: DropCollection -> CollectionName
[_dcCascade] :: DropCollection -> Bool
data AddQueryToCollection
AddQueryToCollection :: CollectionName -> QueryName -> GQLQueryWithText -> AddQueryToCollection
[_aqtcCollectionName] :: AddQueryToCollection -> CollectionName
[_aqtcQueryName] :: AddQueryToCollection -> QueryName
[_aqtcQuery] :: AddQueryToCollection -> GQLQueryWithText
data DropQueryFromCollection
DropQueryFromCollection :: CollectionName -> QueryName -> DropQueryFromCollection
[_dqfcCollectionName] :: DropQueryFromCollection -> CollectionName
[_dqfcQueryName] :: DropQueryFromCollection -> QueryName
type QueryCollections = InsOrdHashMap CollectionName CreateCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.DropCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.DropCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.DropCollection
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.DropCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.RenameCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.RenameCollection
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.RenameCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.RenameCollection
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.RenameCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.CreateCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.CreateCollection
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.CreateCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.CreateCollection
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.CreateCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.CollectionDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.CollectionDef
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.QueryCollection.CollectionDef
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.CollectionDef
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.CollectionDef
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.CollectionDef
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.CollectionDef
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.ListedQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.ListedQuery
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.QueryCollection.CollectionName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.QueryCollection.CollectionName
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.CollectionName
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.CollectionName
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.CollectionName
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.CollectionName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.QueryName
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.QueryName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.QueryCollection.GQLQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.GQLQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.GQLQuery
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.GQLQuery
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.GQLQuery
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.GQLQuery
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.GQLQuery
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.GQLQuery
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.ListedQuery
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.ListedQuery
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.ListedQuery
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.ListedQuery
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.QueryCollection.ListedQuery
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.ListedQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.GQLQueryWithText

module Hasura.RQL.Types.Endpoint
data EndpointMethod
GET :: EndpointMethod
POST :: EndpointMethod
PUT :: EndpointMethod
DELETE :: EndpointMethod
PATCH :: EndpointMethod
newtype EndpointName
EndpointName :: NonEmptyText -> EndpointName
[unEndpointName] :: EndpointName -> NonEmptyText
newtype EndpointUrl
EndpointUrl :: NonEmptyText -> EndpointUrl
[unEndpointUrl] :: EndpointUrl -> NonEmptyText
mkEndpointUrl :: ToTxt a => a -> Maybe EndpointUrl
data QueryReference
QueryReference :: CollectionName -> QueryName -> QueryReference
[_qrCollectionName] :: QueryReference -> CollectionName
[_qrQueryName] :: QueryReference -> QueryName
qrQueryName :: Lens' QueryReference QueryName
qrCollectionName :: Lens' QueryReference CollectionName
data EndpointDef query
EndpointDef :: query -> EndpointDef query
[_edQuery] :: EndpointDef query -> query
edQuery :: forall query_a56es query_a56qy. Iso (EndpointDef query_a56es) (EndpointDef query_a56qy) query_a56es query_a56qy
type EndpointTrie query = MultiMapPathTrie Text EndpointMethod (EndpointMetadata query)
buildEndpointsTrie :: Ord query => [EndpointMetadata query] -> EndpointTrie query

-- | Split a path and construct PathSegments based on callbacks for
--   variables and literals Var callback is passed the ":" prefix as part
--   of the text.
splitPath :: (Text -> a) -> (Text -> a) -> EndpointUrl -> [a]
type CreateEndpoint = EndpointMetadata QueryReference
data EndpointMetadata query
EndpointMetadata :: EndpointName -> EndpointUrl -> NonEmpty EndpointMethod -> EndpointDef query -> Maybe Text -> EndpointMetadata query
[_ceName] :: EndpointMetadata query -> EndpointName
[_ceUrl] :: EndpointMetadata query -> EndpointUrl
[_ceMethods] :: EndpointMetadata query -> NonEmpty EndpointMethod
[_ceDefinition] :: EndpointMetadata query -> EndpointDef query
[_ceComment] :: EndpointMetadata query -> Maybe Text
ceUrl :: forall query_a56qM. Lens' (EndpointMetadata query_a56qM) EndpointUrl
ceName :: forall query_a56qM. Lens' (EndpointMetadata query_a56qM) EndpointName
ceMethods :: forall query_a56qM. Lens' (EndpointMetadata query_a56qM) (NonEmpty EndpointMethod)
ceDefinition :: forall query_a56qM query_a56Oc. Lens (EndpointMetadata query_a56qM) (EndpointMetadata query_a56Oc) (EndpointDef query_a56qM) (EndpointDef query_a56Oc)
ceComment :: forall query_a56qM. Lens' (EndpointMetadata query_a56qM) (Maybe Text)
data DropEndpoint
DropEndpoint :: EndpointName -> DropEndpoint
[_deName] :: DropEndpoint -> EndpointName
deName :: Iso' DropEndpoint EndpointName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.DropEndpoint
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.DropEndpoint
instance GHC.Generics.Generic Hasura.RQL.Types.Endpoint.DropEndpoint
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.DropEndpoint
instance GHC.Show.Show Hasura.RQL.Types.Endpoint.DropEndpoint
instance Data.Aeson.Types.ToJSON.ToJSON query => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance Data.Aeson.Types.FromJSON.FromJSON query => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance Data.Traversable.Traversable Hasura.RQL.Types.Endpoint.EndpointMetadata
instance Data.Foldable.Foldable Hasura.RQL.Types.Endpoint.EndpointMetadata
instance GHC.Base.Functor Hasura.RQL.Types.Endpoint.EndpointMetadata
instance GHC.Generics.Generic (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance GHC.Classes.Ord query => GHC.Classes.Ord (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance GHC.Classes.Eq query => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance GHC.Show.Show query => GHC.Show.Show (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance Data.Aeson.Types.ToJSON.ToJSON query => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance Data.Aeson.Types.FromJSON.FromJSON query => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance Data.Traversable.Traversable Hasura.RQL.Types.Endpoint.EndpointDef
instance Data.Foldable.Foldable Hasura.RQL.Types.Endpoint.EndpointDef
instance GHC.Base.Functor Hasura.RQL.Types.Endpoint.EndpointDef
instance GHC.Generics.Generic (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance GHC.Classes.Ord query => GHC.Classes.Ord (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance GHC.Classes.Eq query => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance GHC.Show.Show query => GHC.Show.Show (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.QueryReference
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.QueryReference
instance GHC.Generics.Generic Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Classes.Ord Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Show.Show Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Endpoint.EndpointName
instance GHC.Classes.Ord Hasura.RQL.Types.Endpoint.EndpointName
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.EndpointName
instance GHC.Show.Show Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.EndpointUrl
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.EndpointUrl
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Endpoint.EndpointUrl
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Classes.Ord Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Show.Show Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Generics.Generic Hasura.RQL.Types.Endpoint.QueryReference
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.QueryReference
instance GHC.Show.Show Hasura.RQL.Types.Endpoint.QueryReference
instance Web.Internal.HttpApiData.FromHttpApiData Hasura.RQL.Types.Endpoint.EndpointUrl
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Endpoint.EndpointMethod

module Hasura.RQL.Types.Allowlist
newtype DropCollectionFromAllowlist
DropCollectionFromAllowlist :: CollectionName -> DropCollectionFromAllowlist
[_dcfaCollection] :: DropCollectionFromAllowlist -> CollectionName
data AllowlistScope
AllowlistScopeGlobal :: AllowlistScope
AllowlistScopeRoles :: NonEmpty RoleName -> AllowlistScope
data AllowlistEntry
AllowlistEntry :: CollectionName -> AllowlistScope -> AllowlistEntry
[aeCollection] :: AllowlistEntry -> CollectionName
[aeScope] :: AllowlistEntry -> AllowlistScope

-- | Wrap <a>AllowlistEntry</a> with a FromJSON instance that requires
--   <tt>scope</tt> to be set.
newtype UpdateScopeOfCollectionInAllowlist
UpdateScopeOfCollectionInAllowlist :: AllowlistEntry -> UpdateScopeOfCollectionInAllowlist
type MetadataAllowlist = InsOrdHashMap CollectionName AllowlistEntry
metadataAllowlistInsert :: AllowlistEntry -> MetadataAllowlist -> Either Text MetadataAllowlist
metadataAllowlistUpdateScope :: AllowlistEntry -> MetadataAllowlist -> Either Text MetadataAllowlist

-- | Produce a list of all collections in the allowlist. This is used in
--   <tt>runDropCollection</tt> to function to ensure that we don't delete
--   any collections which are referred to in the allowlist.
metadataAllowlistAllCollections :: MetadataAllowlist -> [CollectionName]

-- | A query stripped of typenames. A query is allowed if it occurs in an
--   allowed query collection after normalization.
--   
--   Compare docs<i>graphql</i>core<i>deployment</i>allow-list.rst.
newtype NormalizedQuery
NormalizedQuery :: ExecutableDocument Name -> NormalizedQuery
[unNormalizedQuery] :: NormalizedQuery -> ExecutableDocument Name

-- | Normalize query for comparison by stripping type names.
normalizeQuery :: ExecutableDocument Name -> NormalizedQuery

-- | InlinedAllowlist is the data type with which the allowlist is
--   represented in the schema cache, it contains a global and a per role
--   allowlist and when allowlist is enabled in the graphql-engine, the
--   incoming query for a non-admin role should either be in the global
--   allowlist or in the given role's role based allowlist.
--   
--   Essentially, it's a memoization of <a>allowlistAllowsQuery</a>
--   implemented in terms of <a>MetadataAllowlist</a>.
data InlinedAllowlist
InlinedAllowlist :: HashSet NormalizedQuery -> HashMap RoleName (HashSet NormalizedQuery) -> InlinedAllowlist
[iaGlobal] :: InlinedAllowlist -> HashSet NormalizedQuery
[iaPerRole] :: InlinedAllowlist -> HashMap RoleName (HashSet NormalizedQuery)
inlineAllowlist :: QueryCollections -> MetadataAllowlist -> InlinedAllowlist

-- | The mode in which the allowlist functions. In global mode, collections
--   with non-global scope are ignored.
data AllowlistMode
AllowlistModeGlobalOnly :: AllowlistMode
AllowlistModeFull :: AllowlistMode
allowlistAllowsQuery :: InlinedAllowlist -> AllowlistMode -> RoleName -> ExecutableDocument Name -> Bool
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.InlinedAllowlist
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.NormalizedQuery
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Allowlist.NormalizedQuery
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.NormalizedQuery
instance GHC.Show.Show Hasura.RQL.Types.Allowlist.NormalizedQuery
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.InlinedAllowlist
instance GHC.Show.Show Hasura.RQL.Types.Allowlist.InlinedAllowlist
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.UpdateScopeOfCollectionInAllowlist
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.AllowlistEntry
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.AllowlistEntry
instance GHC.Generics.Generic Hasura.RQL.Types.Allowlist.AllowlistScope
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.AllowlistScope
instance GHC.Show.Show Hasura.RQL.Types.Allowlist.AllowlistScope
instance GHC.Generics.Generic Hasura.RQL.Types.Allowlist.AllowlistEntry
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.AllowlistEntry
instance GHC.Show.Show Hasura.RQL.Types.Allowlist.AllowlistEntry
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.AllowlistScope
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.AllowlistScope
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance GHC.Show.Show Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist


-- | Utility types relating to numeric values
module Hasura.RQL.Types.Numeric
newtype NonNegative a
NonNegative :: a -> NonNegative a
[getNonNegative] :: NonNegative a -> a
mkNonNegative :: (Ord a, Num a) => a -> Maybe (NonNegative a)
unsafeNonNegative :: a -> NonNegative a
newtype NonNegativeInt
NonNegativeInt :: Int -> NonNegativeInt
[getNonNegativeInt] :: NonNegativeInt -> Int
mkNonNegativeInt :: Int -> Maybe NonNegativeInt
unsafeNonNegativeInt :: Int -> NonNegativeInt
newtype PositiveInt
PositiveInt :: Int -> PositiveInt
[getPositiveInt] :: PositiveInt -> Int
mkPositiveInt :: Int -> Maybe PositiveInt
unsafePositiveInt :: Int -> PositiveInt
newtype NonNegativeDiffTime
NonNegativeDiffTime :: DiffTime -> NonNegativeDiffTime
[unNonNegativeDiffTime] :: NonNegativeDiffTime -> DiffTime
unsafeNonNegativeDiffTime :: DiffTime -> NonNegativeDiffTime
mkNonNegativeDiffTime :: DiffTime -> Maybe NonNegativeDiffTime
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Numeric.NonNegative a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Numeric.NonNegative a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.Types.Numeric.NonNegative a)
instance GHC.Generics.Generic a => GHC.Generics.Generic (Hasura.RQL.Types.Numeric.NonNegative a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Numeric.NonNegative a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hasura.RQL.Types.Numeric.NonNegative a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Numeric.NonNegative a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.Numeric.NonNegative a)
instance GHC.Base.Functor Hasura.RQL.Types.Numeric.NonNegative
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Numeric.NonNegativeInt
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Numeric.NonNegativeInt
instance Control.DeepSeq.NFData Hasura.RQL.Types.Numeric.NonNegativeInt
instance GHC.Generics.Generic Hasura.RQL.Types.Numeric.NonNegativeInt
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Numeric.NonNegativeInt
instance GHC.Classes.Eq Hasura.RQL.Types.Numeric.NonNegativeInt
instance GHC.Show.Show Hasura.RQL.Types.Numeric.NonNegativeInt
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Numeric.PositiveInt
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Numeric.PositiveInt
instance Control.DeepSeq.NFData Hasura.RQL.Types.Numeric.PositiveInt
instance GHC.Generics.Generic Hasura.RQL.Types.Numeric.PositiveInt
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Numeric.PositiveInt
instance GHC.Classes.Eq Hasura.RQL.Types.Numeric.PositiveInt
instance GHC.Show.Show Hasura.RQL.Types.Numeric.PositiveInt
instance GHC.Num.Num Hasura.RQL.Types.Numeric.NonNegativeDiffTime
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Numeric.NonNegativeDiffTime
instance Control.DeepSeq.NFData Hasura.RQL.Types.Numeric.NonNegativeDiffTime
instance GHC.Generics.Generic Hasura.RQL.Types.Numeric.NonNegativeDiffTime
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Numeric.NonNegativeDiffTime
instance GHC.Classes.Eq Hasura.RQL.Types.Numeric.NonNegativeDiffTime
instance GHC.Show.Show Hasura.RQL.Types.Numeric.NonNegativeDiffTime
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Numeric.NonNegativeDiffTime
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Numeric.PositiveInt
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Numeric.NonNegativeInt
instance (GHC.Real.Fractional a, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Numeric.NonNegative a)

module Hasura.GraphQL.Execute.Subscription.Options
data SubscriptionsOptions
SubscriptionsOptions :: !BatchSize -> !RefetchInterval -> SubscriptionsOptions
[_lqoBatchSize] :: SubscriptionsOptions -> !BatchSize
[_lqoRefetchInterval] :: SubscriptionsOptions -> !RefetchInterval
type LiveQueriesOptions = SubscriptionsOptions
type StreamQueriesOptions = SubscriptionsOptions
mkSubscriptionsOptions :: Maybe BatchSize -> Maybe RefetchInterval -> SubscriptionsOptions
newtype BatchSize
BatchSize :: NonNegativeInt -> BatchSize
[unBatchSize] :: BatchSize -> NonNegativeInt
mkBatchSize :: Int -> Maybe BatchSize
newtype RefetchInterval
RefetchInterval :: NonNegativeDiffTime -> RefetchInterval
[unRefetchInterval] :: RefetchInterval -> NonNegativeDiffTime
mkRefetchInterval :: DiffTime -> Maybe RefetchInterval
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions

module Hasura.RQL.Types.GraphqlSchemaIntrospection
newtype SetGraphqlIntrospectionOptions
SetGraphqlIntrospectionOptions :: HashSet RoleName -> SetGraphqlIntrospectionOptions
[_idrDisabledForRoles] :: SetGraphqlIntrospectionOptions -> HashSet RoleName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Base.Monoid Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Base.Semigroup Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Generics.Generic Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Classes.Eq Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Show.Show Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Control.DeepSeq.NFData Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions


-- | The <a>Transform</a> typeclass with various types and helper functions
--   for evaluating transformations.
module Hasura.RQL.DDL.Webhook.Transform.Class

-- | <a>Transform</a> describes how to reify a defunctionalized
--   transformation for a particular request field.
class Transform a where {
    
    -- | The associated type 'TransformFn a' is the defunctionalized version of
    --   some transformation that should be applied to a given request field.
    --   
    --   In most cases it is some variation on a piece of template text
    --   describing the transformation.
    data family TransformFn a :: Type;
}

-- | <a>transform</a> is a function which takes <a>TransformFn</a> of
--   <tt>a</tt> and reifies it into a function of the form:
--   
--   <pre>
--   ReqTransformCtx -&gt; a -&gt; m a
--   </pre>
transform :: (Transform a, MonadError TransformErrorBundle m) => TransformFn a -> RequestTransformCtx -> a -> m a

-- | Validate a <a>TransformFn</a> of <tt>a</tt>.
validate :: Transform a => TemplatingEngine -> TransformFn a -> Validation TransformErrorBundle ()

-- | We use collect all transformation failures as a '[J.Value]'.
newtype TransformErrorBundle
TransformErrorBundle :: [Value] -> TransformErrorBundle
[tebMessages] :: TransformErrorBundle -> [Value]

-- | A helper function for serializing transformation errors to JSON.
throwErrorBundle :: MonadError TransformErrorBundle m => Text -> Maybe Value -> m a

-- | Common context that is made available to all request transformations.
data RequestTransformCtx
RequestTransformCtx :: Maybe Value -> Value -> Value -> Maybe Value -> TemplatingEngine -> HashMap Text (Value -> Either CustomFunctionError Value) -> RequestTransformCtx
[rtcBaseUrl] :: RequestTransformCtx -> Maybe Value
[rtcBody] :: RequestTransformCtx -> Value
[rtcSessionVariables] :: RequestTransformCtx -> Value
[rtcQueryParams] :: RequestTransformCtx -> Maybe Value
[rtcEngine] :: RequestTransformCtx -> TemplatingEngine
[rtcFunctions] :: RequestTransformCtx -> HashMap Text (Value -> Either CustomFunctionError Value)

-- | A smart constructor for constructing the <a>RequestTransformCtx</a>
--   
--   XXX: This function makes internal usage of <a>decodeUtf8</a>, which
--   throws an impure exception when the supplied <a>ByteString</a> cannot
--   be decoded into valid UTF8 text!
mkReqTransformCtx :: Text -> Maybe SessionVariables -> TemplatingEngine -> Request -> RequestTransformCtx

-- | Common context that is made available to all response transformations.
data ResponseTransformCtx
ResponseTransformCtx :: Value -> Value -> HashMap Text (Value -> Either CustomFunctionError Value) -> TemplatingEngine -> ResponseTransformCtx
[responseTransformBody] :: ResponseTransformCtx -> Value
[responseTransformReqCtx] :: ResponseTransformCtx -> Value
[responseTransformFunctions] :: ResponseTransformCtx -> HashMap Text (Value -> Either CustomFunctionError Value)
[responseTransformEngine] :: ResponseTransformCtx -> TemplatingEngine

-- | Available templating engines.
data TemplatingEngine
Kriti :: TemplatingEngine

-- | Textual transformation template.
newtype Template
Template :: Text -> Template
[unTemplate] :: Template -> Text

-- | A helper function for executing transformations from a <a>Template</a>
--   and a <a>RequestTransformCtx</a>.
--   
--   NOTE: This and all related funtions are hard-coded to Kriti at the
--   moment. When we add additional template engines this function will
--   need to take a <a>TemplatingEngine</a> parameter.
runRequestTemplateTransform :: Template -> RequestTransformCtx -> Either TransformErrorBundle Value
validateRequestTemplateTransform :: TemplatingEngine -> Template -> Either TransformErrorBundle ()
validateRequestTemplateTransform' :: TemplatingEngine -> Template -> Validation TransformErrorBundle ()

-- | A helper function for executing transformations from a <a>Template</a>
--   and a <a>ResponseTransformCtx</a>.
--   
--   NOTE: This and all related funtions are hard-coded to Kriti at the
--   moment. When we add additional template engines this function will
--   need to take a <a>TemplatingEngine</a> parameter.
runResponseTemplateTransform :: Template -> ResponseTransformCtx -> Either TransformErrorBundle Value

-- | <tt>RequestTransform</tt> Versioning
data Version
V1 :: Version
V2 :: Version

-- | Validated textual transformation template /for string interpolation
--   only/.
--   
--   This is necessary due to Kriti not distinguishing between string
--   literals and string templates.
newtype UnescapedTemplate
UnescapedTemplate :: Text -> UnescapedTemplate
[getUnescapedTemplate] :: UnescapedTemplate -> Text

-- | Wrap an <a>UnescapedTemplate</a> with escaped double quotes.
wrapUnescapedTemplate :: UnescapedTemplate -> Template

-- | A helper function for executing Kriti transformations from a
--   <a>UnescapedTemplate</a> and a <tt>RequestTrasformCtx</tt>.
--   
--   The difference from <a>runRequestTemplateTransform</a> is that this
--   function will wrap the template text in double quotes before running
--   Kriti.
runUnescapedRequestTemplateTransform :: RequestTransformCtx -> UnescapedTemplate -> Either TransformErrorBundle ByteString

-- | Run a Kriti transformation with an unescaped template in
--   <a>Validation</a> instead of <a>Either</a>.
runUnescapedRequestTemplateTransform' :: RequestTransformCtx -> UnescapedTemplate -> Validation TransformErrorBundle ByteString
validateRequestUnescapedTemplateTransform :: TemplatingEngine -> UnescapedTemplate -> Either TransformErrorBundle ()
validateRequestUnescapedTemplateTransform' :: TemplatingEngine -> UnescapedTemplate -> Validation TransformErrorBundle ()

-- | Run an <a>UnescapedTemplate</a> with a <a>ResponseTransformCtx</a>.
runUnescapedResponseTemplateTransform :: ResponseTransformCtx -> UnescapedTemplate -> Either TransformErrorBundle ByteString

-- | Run an <a>UnescapedTemplate</a> with a <a>ResponseTransformCtx</a> in
--   <a>Validation</a>.
runUnescapedResponseTemplateTransform' :: ResponseTransformCtx -> UnescapedTemplate -> Validation TransformErrorBundle ByteString

-- | Encode a JSON Scalar Value as a <a>ByteString</a>. If a non-Scalar
--   value is provided, will return a <tt>TrnasformErrorBundle</tt>
encodeScalar :: MonadError TransformErrorBundle m => Value -> m ByteString
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Class.TransformErrorBundle
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Class.TransformErrorBundle
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Class.TransformErrorBundle
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Base.Semigroup Hasura.RQL.DDL.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Base.Monoid Hasura.RQL.DDL.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Class.TransformErrorBundle
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Class.TemplatingEngine
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Class.TemplatingEngine
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Class.TemplatingEngine
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Class.TemplatingEngine
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Class.TemplatingEngine
instance GHC.Enum.Enum Hasura.RQL.DDL.Webhook.Transform.Class.TemplatingEngine
instance GHC.Enum.Bounded Hasura.RQL.DDL.Webhook.Transform.Class.TemplatingEngine
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Class.Template
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Class.Template
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.DDL.Webhook.Transform.Class.Template
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.DDL.Webhook.Transform.Class.Template
instance Data.Hashable.Class.Hashable Hasura.RQL.DDL.Webhook.Transform.Class.Template
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Class.Template
instance GHC.Classes.Ord Hasura.RQL.DDL.Webhook.Transform.Class.Template
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Class.Template
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Class.Template
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Class.Version
instance Data.Hashable.Class.Hashable Hasura.RQL.DDL.Webhook.Transform.Class.Version
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Class.Version
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Class.Version
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Class.Version
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Class.Version
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Class.UnescapedTemplate
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.DDL.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.DDL.Webhook.Transform.Class.UnescapedTemplate
instance Data.Hashable.Class.Hashable Hasura.RQL.DDL.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Classes.Ord Hasura.RQL.DDL.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Class.Version
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Class.Version
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Class.Template
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Class.Template
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Class.RequestTransformCtx
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Class.TemplatingEngine
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Class.TemplatingEngine

module Hasura.RQL.DDL.Webhook.Transform.Url

-- | The actual URL string we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Url
Url :: Text -> Url
[unUrl] :: Url -> Text

-- | The defunctionalized transformation function on <a>Url</a>
newtype UrlTransformFn
Modify :: UnescapedTemplate -> UrlTransformFn

-- | Provide an implementation for the transformations defined by
--   <a>UrlTransformFn</a>.
--   
--   If one views <a>UrlTransformFn</a> as an interface describing URL
--   transformations, this can be seen as an implementation of these
--   transformations as normal Haskell functions.
applyUrlTransformFn :: MonadError TransformErrorBundle m => UrlTransformFn -> RequestTransformCtx -> Url -> m Url

-- | Validate that the provided <a>UrlTransformFn</a> is correct in the
--   context of a particular <a>TemplatingEngine</a>.
--   
--   This is a product of the fact that the correctness of a given
--   transformation may be dependent on zero, one, or more of the templated
--   transformations encoded within the given <a>UrlTransformFn</a>.
validateUrlTransformFn :: TemplatingEngine -> UrlTransformFn -> Validation TransformErrorBundle ()
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Url.Url
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Url.Url
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Url.UrlTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Url.UrlTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Url.UrlTransformFn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Url.UrlTransformFn
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Url.UrlTransformFn
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Url.UrlTransformFn
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Url.UrlTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Url.Url)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Url.Url)
instance Control.DeepSeq.NFData (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Url.Url)
instance Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Url.Url)
instance GHC.Show.Show (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Url.Url)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Url.Url)
instance GHC.Classes.Eq (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Url.Url)
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.DDL.Webhook.Transform.Url.Url

module Hasura.RQL.DDL.Webhook.Transform.QueryParams

-- | The actual query params we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype QueryParams
QueryParams :: Query -> QueryParams
[unQueryParams] :: QueryParams -> Query

-- | The defunctionalized transformation <a>QueryParams</a>
newtype QueryParamsTransformFn
AddOrReplace :: [(UnescapedTemplate, Maybe UnescapedTemplate)] -> QueryParamsTransformFn

-- | Provide an implementation for the transformations defined by
--   <a>QueryParamsTransformFn</a>.
--   
--   If one views <a>QueryParamsTransformFn</a> as an interface describing
--   HTTP method transformations, this can be seen as an implementation of
--   these transformations as normal Haskell functions.
applyQueryParamsTransformFn :: MonadError TransformErrorBundle m => QueryParamsTransformFn -> RequestTransformCtx -> QueryParams -> m QueryParams

-- | Validate that the provided <a>QueryParamsTransformFn</a> is correct in
--   the context of a particular <a>TemplatingEngine</a>.
--   
--   This is a product of the fact that the correctness of a given
--   transformation may be dependent on zero, one, or more of the templated
--   transformations encoded within the given
--   <a>QueryParamsTransformFn</a>.
validateQueryParamsTransformFn :: TemplatingEngine -> QueryParamsTransformFn -> Validation TransformErrorBundle ()
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParams)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParams)
instance Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParams)
instance Control.DeepSeq.NFData (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParams)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParams)
instance GHC.Classes.Eq (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParams)
instance GHC.Show.Show (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParams)
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParams
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.QueryParams.QueryParamsTransformFn

module Hasura.RQL.DDL.Webhook.Transform.Method

-- | The actual request method we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Method
Method :: CI Text -> Method

-- | The defunctionalized transformation on <a>Method</a>.
newtype MethodTransformFn

-- | Replace the HTTP existing <a>Method</a> with a new one.
Replace :: Method -> MethodTransformFn

-- | Provide an implementation for the transformations defined by
--   <a>MethodTransformFn</a>.
--   
--   If one views <a>MethodTransformFn</a> as an interface describing HTTP
--   method transformations, this can be seen as an implementation of these
--   transformations as normal Haskell functions.
applyMethodTransformFn :: MonadError TransformErrorBundle m => MethodTransformFn -> RequestTransformCtx -> Method -> m Method

-- | Validate that the provided <a>MethodTransformFn</a> is correct in the
--   context of a particular <a>TemplatingEngine</a>.
--   
--   This is a product of the fact that the correctness of a given
--   transformation may be dependent on zero, one, or more of the templated
--   transformations encoded within the given <a>MethodTransformFn</a>.
--   
--   XXX: Do we want to validate the HTTP method verb?
validateMethodTransformFn :: TemplatingEngine -> MethodTransformFn -> Validation TransformErrorBundle ()
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Method.Method
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Method.Method
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Method.Method
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Method.Method
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Method.Method
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Method.MethodTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Method.MethodTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Method.MethodTransformFn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Method.MethodTransformFn
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Method.MethodTransformFn
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Method.MethodTransformFn
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Method.MethodTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Method.Method)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Method.Method)
instance Control.DeepSeq.NFData (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Method.Method)
instance Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Method.Method)
instance GHC.Show.Show (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Method.Method)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Method.Method)
instance GHC.Classes.Eq (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Method.Method)
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.DDL.Webhook.Transform.Method.Method
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Method.Method
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Method.Method

module Hasura.RQL.DDL.Webhook.Transform.Headers

-- | The actual header data we are transforming..
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Headers
Headers :: [Header] -> Headers

-- | The defunctionalized transformation on <a>Headers</a>
newtype HeadersTransformFn

-- | Add or replace matching <a>Header</a>s.
AddReplaceOrRemove :: AddReplaceOrRemoveFields -> HeadersTransformFn

-- | The user can supply a set of header keys to be filtered from the
--   request and a set of headers to be added to the request.
data AddReplaceOrRemoveFields
AddReplaceOrRemoveFields :: [(CI Text, UnescapedTemplate)] -> [CI Text] -> AddReplaceOrRemoveFields

-- | A list of key-value pairs for <a>Header</a>s which should be added (if
--   they don't exist) or replaced (if they do) within the HTTP message.
[addOrReplaceHeaders] :: AddReplaceOrRemoveFields -> [(CI Text, UnescapedTemplate)]

-- | A list of <a>Header</a> keys which should be removed from the HTTP
--   message.
[removeHeaders] :: AddReplaceOrRemoveFields -> [CI Text]

-- | Provide an implementation for the transformations defined by
--   <a>HeadersTransformFn</a>.
--   
--   If one views <a>HeadersTransformFn</a> as an interface describing HTTP
--   message header transformations, this can be seen as an implementation
--   of these transformations as normal Haskell functions.
applyHeadersTransformFn :: MonadError TransformErrorBundle m => HeadersTransformFn -> RequestTransformCtx -> Headers -> m Headers

-- | Validate that the provided <a>HeadersTransformFn</a> is correct in the
--   context of a particular <a>TemplatingEngine</a>.
--   
--   This is a product of the fact that the correctness of a given
--   transformation may be dependent on zero, one, or more of the templated
--   transformations encoded within the given <a>HeadersTransformFn</a>.
validateHeadersTransformFn :: TemplatingEngine -> HeadersTransformFn -> Validation TransformErrorBundle ()

-- | This newtype exists solely to anchor a <a>FromJSON</a> instance and is
--   eliminated in the <tt>TransformHeaders</tt> <a>FromJSON</a> instance.
newtype HeaderKey
HeaderKey :: CI Text -> HeaderKey
[unHeaderKey] :: HeaderKey -> CI Text
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Classes.Ord Hasura.RQL.DDL.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Headers.HeadersTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Headers.HeadersTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Headers.HeadersTransformFn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Headers.HeadersTransformFn
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Headers.HeadersTransformFn
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Headers.HeadersTransformFn
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Headers.HeadersTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Headers.Headers)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Headers.Headers)
instance Control.DeepSeq.NFData (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Headers.Headers)
instance Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Headers.Headers)
instance GHC.Show.Show (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Headers.Headers)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Headers.Headers)
instance GHC.Classes.Eq (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Headers.Headers)
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Headers.HeaderKey
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Headers.HeaderKey
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Headers.HeaderKey
instance GHC.Classes.Ord Hasura.RQL.DDL.Webhook.Transform.Headers.HeaderKey
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Headers.HeaderKey
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Headers.HeaderKey
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Headers.HeaderKey
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.DDL.Webhook.Transform.Headers.Headers
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Headers.AddReplaceOrRemoveFields

module Hasura.RQL.DDL.Webhook.Transform.Body

-- | HTTP message body being transformed.
data Body
JSONBody :: Maybe Value -> Body
RawBody :: ByteString -> Body

-- | The transformations which can be applied to an HTTP message body.
data BodyTransformFn

-- | Remove the HTTP message body.
Remove :: BodyTransformFn

-- | Modify the JSON message body by applying a <a>Template</a>
--   transformation.
ModifyAsJSON :: Template -> BodyTransformFn

-- | Modify the JSON message body by applying <a>UnescapedTemplate</a>
--   transformations to each field with a matching <a>Text</a> key.
ModifyAsFormURLEncoded :: HashMap Text UnescapedTemplate -> BodyTransformFn

-- | Provide an implementation for the transformations defined by
--   <a>BodyTransformFn</a>.
--   
--   If one views <a>BodyTransformFn</a> as an interface describing HTTP
--   message body transformations, this can be seen as an implementation of
--   these transformations as normal Haskell functions.
applyBodyTransformFn :: MonadError TransformErrorBundle m => BodyTransformFn -> RequestTransformCtx -> Body -> m Body

-- | Validate that the provided <a>BodyTransformFn</a> is correct in the
--   context of a particular <a>TemplatingEngine</a>.
--   
--   This is a product of the fact that the correctness of a given
--   transformation may be dependent on zero, one, or more of the templated
--   transformations encoded within the given <a>BodyTransformFn</a>.
validateBodyTransformFn :: TemplatingEngine -> BodyTransformFn -> Validation TransformErrorBundle ()

-- | Fold a <a>HashMap</a> of header key/value pairs into an
--   <tt>x-www-form-urlencoded</tt> message body.
foldFormEncoded :: HashMap Text ByteString -> ByteString

-- | URI-escape <a>Text</a> blobs.
escapeURIText :: Text -> Text

-- | URI-escape <a>ByteString</a> blobs, which are presumed to represent
--   <a>Text</a>.
--   
--   XXX: This function makes internal usage of <a>decodeUtf8</a>, which
--   throws an impure exception when the supplied <a>ByteString</a> cannot
--   be decoded into valid UTF8 text!
escapeURIBS :: ByteString -> ByteString
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Body.Body
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Body.Body
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.Body.BodyTransformFn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.Body.BodyTransformFn
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.Body.BodyTransformFn
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.Body.BodyTransformFn
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.Body.BodyTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Body.Body)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Body.Body)
instance Control.DeepSeq.NFData (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Body.Body)
instance Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Body.Body)
instance GHC.Show.Show (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Body.Body)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Body.Body)
instance GHC.Classes.Eq (Hasura.RQL.DDL.Webhook.Transform.Class.TransformFn Hasura.RQL.DDL.Webhook.Transform.Body.Body)
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.DDL.Webhook.Transform.Body.Body
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.Body.BodyTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.Body.BodyTransformFn


-- | Webhook Transformations are data transformations used to modify HTTP
--   Requests/Responses before requests are executed and after responses
--   are received.
--   
--   Transformations are supplied by users as part of the Metadata for a
--   particular Action or EventTrigger as a <a>RequestTransform</a> record.
--   Per-field Transformations are stored as data (defunctionalized), often
--   in the form of a Kriti template, and then converted into actual
--   functions (reified) at runtime by the <a>Transform</a> typeclass.
--   
--   We take a Higher Kinded Data (HKD) approach to representing the
--   transformations. <a>RequestFields</a> is an HKD which can represent
--   the actual request data as 'RequestFields Identity' or the
--   defunctionalized transforms as 'RequestFields (WithOptional
--   TransformFn)'.
--   
--   We can then traverse over the entire <a>RequestFields</a> HKD to reify
--   all the fields at once and apply them to our actual request data.
--   
--   NOTE: We don't literally use <a>traverse</a> or the HKD equivalent
--   <tt>btraverse</tt>, but you can think of this operation morally as a
--   traversal. See <a>applyRequestTransform</a> for implementation
--   details.
module Hasura.RQL.DDL.Webhook.Transform

-- | <a>RequestTransform</a> is the metadata representation of a request
--   transformation. It consists of a record of higher kinded data (HKD)
--   along with some regular data. We seperate the HKD data into its own
--   record field called <a>requestFields</a> which we nest inside our
--   non-HKD record. The actual transformation operations are contained in
--   the HKD.
data RequestTransform
RequestTransform :: Version -> RequestFields (WithOptional TransformFn) -> TemplatingEngine -> RequestTransform
[version] :: RequestTransform -> Version
[requestFields] :: RequestTransform -> RequestFields (WithOptional TransformFn)
[templateEngine] :: RequestTransform -> TemplatingEngine

-- | Defunctionalized Webhook Transformation
--   
--   We represent a defunctionalized request transformation by
--   parameterizing our HKD with <a>WithOptional</a><tt>
--   </tt><a>TransformFn</a>, which marks each of the fields as optional
--   and supplies the appropriate transformation function to them if if
--   they are provided.
type RequestTransformFns = RequestFields (WithOptional TransformFn)

-- | Actual Request Data
--   
--   We represent the actual request data by parameterizing our HKD with
--   <a>Identity</a>, which allows us to trivially unwrap the fields (which
--   should exist after any transformations have been applied).
type RequestData = RequestFields Identity

-- | This is our HKD type. It is a record with fields for each component of
--   an <a>Request</a> we wish to transform.
data RequestFields f
RequestFields :: f Method -> f Url -> f Body -> f QueryParams -> f Headers -> RequestFields f
[method] :: RequestFields f -> f Method
[url] :: RequestFields f -> f Url
[body] :: RequestFields f -> f Body
[queryParams] :: RequestFields f -> f QueryParams
[requestHeaders] :: RequestFields f -> f Headers

-- | A 'Lens'' for viewing a <a>Request</a> as our <a>RequestData</a> HKD;
--   it does so by wrapping each of the matching request fields in a
--   corresponding <a>TransformFn</a>.
--   
--   XXX: This function makes internal usage of <a>decodeUtf8</a>, which
--   throws an impure exception when the supplied <tt>ByteString</tt>
--   cannot be decoded into valid UTF8 text!
requestL :: Lens' Request RequestData

-- | Transform an <a>Request</a> with a <a>RequestTransform</a>.
--   
--   Note: we pass in the request url explicitly for use in the
--   <tt>ReqTransformCtx</tt>. We do this so that we can ensure that the
--   url is syntactically identical to what the use submits. If we use the
--   parsed request from the <a>Request</a> term then it is possible that
--   the url is semantically equivalent but syntactically different. An
--   example of this is the presence or lack of a trailing slash on the URL
--   path. This important when performing string interpolation on the
--   request url.
applyRequestTransform :: forall m. MonadError TransformErrorBundle m => (Request -> RequestTransformCtx) -> RequestTransformFns -> Request -> m Request

-- | Enrich a <a>Functor</a> <tt>f</tt> with optionality; this is primarily
--   useful when one wants to annotate fields as optional when using the
--   Higher-Kinded Data pattern.
--   
--   <a>WithOptional</a><tt> f</tt> is equivalent to <tt>Compose Maybe
--   f</tt>.
newtype WithOptional f result
WithOptional :: Maybe (f result) -> WithOptional f result
[getOptional] :: WithOptional f result -> Maybe (f result)

-- | <a>WithOptional</a> smart constructor for the special case of optional
--   values that are representationally equivalent to some "wrapper" type.
--   
--   For example: <tt> withOptional @HeaderTransformsAction headers ==
--   WithOptional $ fmap HeadersTransform headers </tt>
--   
--   In other words: this function observes the isomorphism between
--   <tt><a>Maybe</a> a</tt> and <tt><a>WithOptional</a> f b</tt> if an
--   isomorphism exists between <tt>a</tt> and <tt>f b</tt>.
withOptional :: forall a b f. Coercible a (f b) => Maybe a -> WithOptional f b

-- | A set of data transformation functions generated from a
--   <a>MetadataResponseTransform</a>. <a>Nothing</a> means use the
--   original response value.
data ResponseTransform
ResponseTransform :: Maybe (ResponseTransformCtx -> Either TransformErrorBundle Value) -> TemplatingEngine -> ResponseTransform
[respTransformBody] :: ResponseTransform -> Maybe (ResponseTransformCtx -> Either TransformErrorBundle Value)
[respTransformTemplateEngine] :: ResponseTransform -> TemplatingEngine
data MetadataResponseTransform
MetadataResponseTransform :: Version -> Maybe BodyTransformFn -> TemplatingEngine -> MetadataResponseTransform
[mrtVersion] :: MetadataResponseTransform -> Version
[mrtBodyTransform] :: MetadataResponseTransform -> Maybe BodyTransformFn
[mrtTemplatingEngine] :: MetadataResponseTransform -> TemplatingEngine

-- | A helper function for constructing the <tt>RespTransformCtx</tt>
buildRespTransformCtx :: Maybe RequestTransformCtx -> Maybe SessionVariables -> TemplatingEngine -> ByteString -> ResponseTransformCtx

-- | Construct a Template Transformation function for Responses
--   
--   XXX: This function makes internal usage of <a>decodeUtf8</a>, which
--   throws an impure exception when the supplied <tt>ByteString</tt>
--   cannot be decoded into valid UTF8 text!
mkRespTemplateTransform :: TemplatingEngine -> BodyTransformFn -> ResponseTransformCtx -> Either TransformErrorBundle Value
mkResponseTransform :: MetadataResponseTransform -> ResponseTransform

-- | At the moment we only transform the body of Responses. 'http-client'
--   does not export the constructors for <tt>Response</tt>. If we want to
--   transform then we will need additional <tt>apply</tt> functions.
applyResponseTransform :: ResponseTransform -> ResponseTransformCtx -> Either TransformErrorBundle ByteString
instance Barbies.Internal.ConstraintsB.ConstraintsB Hasura.RQL.DDL.Webhook.Transform.RequestFields
instance Barbies.Internal.TraversableB.TraversableB Hasura.RQL.DDL.Webhook.Transform.RequestFields
instance Barbies.Internal.ApplicativeB.ApplicativeB Hasura.RQL.DDL.Webhook.Transform.RequestFields
instance Barbies.Internal.FunctorB.FunctorB Hasura.RQL.DDL.Webhook.Transform.RequestFields
instance GHC.Generics.Generic (Hasura.RQL.DDL.Webhook.Transform.RequestFields f)
instance Data.Aeson.Types.ToJSON.ToJSON (f result) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.WithOptional f result)
instance Data.Aeson.Types.FromJSON.FromJSON (f result) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.WithOptional f result)
instance GHC.Show.Show (f result) => GHC.Show.Show (Hasura.RQL.DDL.Webhook.Transform.WithOptional f result)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Webhook.Transform.WithOptional f result)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Hasura.RQL.DDL.Webhook.Transform.WithOptional f)
instance GHC.Base.Functor f => GHC.Base.Functor (Hasura.RQL.DDL.Webhook.Transform.WithOptional f)
instance GHC.Classes.Eq (f result) => GHC.Classes.Eq (Hasura.RQL.DDL.Webhook.Transform.WithOptional f result)
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.RequestTransform
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.RequestTransform
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.RequestTransform
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.RequestTransform
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.RequestTransform
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Webhook.Transform.MetadataResponseTransform
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Webhook.Transform.MetadataResponseTransform
instance GHC.Generics.Generic Hasura.RQL.DDL.Webhook.Transform.MetadataResponseTransform
instance GHC.Classes.Eq Hasura.RQL.DDL.Webhook.Transform.MetadataResponseTransform
instance GHC.Show.Show Hasura.RQL.DDL.Webhook.Transform.MetadataResponseTransform
instance Barbies.Internal.ConstraintsB.AllBF GHC.Show.Show f Hasura.RQL.DDL.Webhook.Transform.RequestFields => GHC.Show.Show (Hasura.RQL.DDL.Webhook.Transform.RequestFields f)
instance Barbies.Internal.ConstraintsB.AllBF GHC.Classes.Eq f Hasura.RQL.DDL.Webhook.Transform.RequestFields => GHC.Classes.Eq (Hasura.RQL.DDL.Webhook.Transform.RequestFields f)
instance Barbies.Internal.ConstraintsB.AllBF Control.DeepSeq.NFData f Hasura.RQL.DDL.Webhook.Transform.RequestFields => Control.DeepSeq.NFData (Hasura.RQL.DDL.Webhook.Transform.RequestFields f)
instance Barbies.Internal.ConstraintsB.AllBF Hasura.Incremental.Internal.Dependency.Cacheable f Hasura.RQL.DDL.Webhook.Transform.RequestFields => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.DDL.Webhook.Transform.RequestFields f)
instance Hasura.Incremental.Internal.Dependency.Cacheable (f result) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.DDL.Webhook.Transform.WithOptional f result)
instance Control.DeepSeq.NFData (f result) => Control.DeepSeq.NFData (Hasura.RQL.DDL.Webhook.Transform.WithOptional f result)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.MetadataResponseTransform
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.MetadataResponseTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.RequestTransform
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.RequestTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Webhook.Transform.RequestTransformFns
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Webhook.Transform.RequestTransformFns


-- | We validate <a>TransformFn</a> terms inside <a>RequestTransform</a>
--   before dispatching Metadata actions in <tt>runMetadataQueryV1M</tt>.
--   Validation follows the same HKD pattern from
--   <a>applyRequestTransform</a> but using <a>btraverseC</a> to call
--   <a>validate</a> from the <a>Transform</a> class on all the HKD fields.
module Hasura.RQL.DDL.Webhook.Transform.Validation
type Tuple1 a b = Compose ((,) a) b
type OptionalTuple1 a b = WithOptional (Tuple1 a b)

-- | A variation on <tt>RequestTransformFn</tt> where <a>TransformFn</a> is
--   tupled with <a>TemplatingEngine</a>. This is necessary to validate the
--   <a>TransformFn</a>.
--   
--   TODO: In the future we most likely want to embed the
--   <a>TemplatingEngine</a> in the <a>TransformFn</a> or the
--   <a>Template</a>/<tt>UnwrappedTemplate</tt>, in which case we would not
--   need this alias for validation.
type ValidationFields = RequestFields (OptionalTuple1 TemplatingEngine TransformFn)

-- | A lens for zipping our defunctionalized transform with the
--   <a>TemplatingEngine</a> for validation.
transformFns :: Lens' RequestTransform ValidationFields

-- | Validate all 'TransformFn a' fields in the <a>RequestTransform</a>.
validateRequestTransform :: MonadError TransformErrorBundle m => RequestTransform -> m RequestTransform

-- | Used to annotate that a <a>RequestTransform</a>, or some record
--   containing a <a>RequestTransform</a> has not yet been validated.
newtype Unvalidated a
Unvalidated :: a -> Unvalidated a
[_unUnvalidate] :: Unvalidated a -> a

-- | A lens for focusing through <a>Unvalidated</a> in
--   <a>validateTransforms</a>.
unUnvalidate :: Lens' (Unvalidated a) a

-- | Used to annotate that a higher kinded type containing a
--   <a>RequestTransform</a> has not yet been validated.
--   
--   This is needed specifically for <tt>CreateEventTriggerQuery</tt> and
--   any other type that is paramterized by a <tt>BackendType</tt>.
newtype Unvalidated1 (f :: k -> Type) (a :: k)
Unvalidated1 :: f a -> Unvalidated1 (f :: k -> Type) (a :: k)
[_unUnvalidate1] :: Unvalidated1 (f :: k -> Type) (a :: k) -> f a

-- | A lens for focusing through <a>Unvalidated1</a> in
--   <a>validateTransforms</a>.
unUnvalidate1 :: Lens' (Unvalidated1 f a) (f a)

-- | Used to focus into a records in <tt>RQLMetadataV1</tt> and validate
--   any <a>RequestTransform</a> terms present.
validateTransforms :: MonadError QErr m => LensLike (Either TransformErrorBundle) api api RequestTransform RequestTransform -> (api -> m EncJSON) -> api -> m EncJSON
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated a)
instance forall k (f :: k -> *) (a :: k). Data.Aeson.Types.ToJSON.ToJSON (f a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated1 f a)
instance forall k (f :: k -> *) (a :: k). Data.Aeson.Types.FromJSON.FromJSON (f a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated1 f a)

module Hasura.RQL.DDL.Headers
data HeaderConf
HeaderConf :: HeaderName -> HeaderValue -> HeaderConf
type HeaderName = Text
data HeaderValue
HVValue :: Text -> HeaderValue
HVEnv :: Text -> HeaderValue

-- | Resolve configuration headers
makeHeadersFromConf :: MonadError QErr m => Environment -> [HeaderConf] -> m [Header]

-- | Encode headers to HeaderConf
toHeadersConf :: [Header] -> [HeaderConf]
instance GHC.Generics.Generic Hasura.RQL.DDL.Headers.HeaderValue
instance GHC.Classes.Eq Hasura.RQL.DDL.Headers.HeaderValue
instance GHC.Show.Show Hasura.RQL.DDL.Headers.HeaderValue
instance GHC.Generics.Generic Hasura.RQL.DDL.Headers.HeaderConf
instance GHC.Classes.Eq Hasura.RQL.DDL.Headers.HeaderConf
instance GHC.Show.Show Hasura.RQL.DDL.Headers.HeaderConf
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Headers.HeaderConf
instance Data.Hashable.Class.Hashable Hasura.RQL.DDL.Headers.HeaderConf
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Headers.HeaderConf
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Headers.HeaderConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Headers.HeaderConf
instance Control.DeepSeq.NFData Hasura.RQL.DDL.Headers.HeaderValue
instance Data.Hashable.Class.Hashable Hasura.RQL.DDL.Headers.HeaderValue
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Headers.HeaderValue


-- | This module contains types which are common to event triggers and
--   scheduled triggers.
module Hasura.RQL.Types.Eventing
newtype EventId
EventId :: Text -> EventId
[unEventId] :: EventId -> Text

-- | There are two types of events: EventType (for event triggers) and
--   ScheduledType (for scheduled triggers)
data TriggerTypes
EventType :: TriggerTypes
ScheduledType :: TriggerTypes
data WebhookRequest
WebhookRequest :: Value -> [HeaderConf] -> Text -> WebhookRequest
[_rqPayload] :: WebhookRequest -> Value
[_rqHeaders] :: WebhookRequest -> [HeaderConf]
[_rqVersion] :: WebhookRequest -> Text
data WebhookResponse
WebhookResponse :: SerializableBlob -> [HeaderConf] -> Int -> WebhookResponse
[_wrsBody] :: WebhookResponse -> SerializableBlob
[_wrsHeaders] :: WebhookResponse -> [HeaderConf]
[_wrsStatus] :: WebhookResponse -> Int
newtype ClientError
ClientError :: SerializableBlob -> ClientError
[_ceMessage] :: ClientError -> SerializableBlob
data Response (a :: TriggerTypes)
ResponseHTTP :: WebhookResponse -> Response (a :: TriggerTypes)
ResponseError :: ClientError -> Response (a :: TriggerTypes)
type InvocationVersion = Text
invocationVersionET :: InvocationVersion
invocationVersionST :: InvocationVersion
data Invocation (a :: TriggerTypes)
Invocation :: EventId -> Maybe Int -> WebhookRequest -> Response a -> Invocation (a :: TriggerTypes)
[iEventId] :: Invocation (a :: TriggerTypes) -> EventId
[iStatus] :: Invocation (a :: TriggerTypes) -> Maybe Int
[iRequest] :: Invocation (a :: TriggerTypes) -> WebhookRequest
[iResponse] :: Invocation (a :: TriggerTypes) -> Response a

-- | PGTextArray is only used for PG array encoding
newtype PGTextArray
PGTextArray :: [Text] -> PGTextArray
[unPGTextArray] :: PGTextArray -> [Text]

-- | Used to construct the payload of Event Trigger
--   
--   OLD: Depicts the old database row value for UPDATE/DELETE trigger
--   operations. This is used to construct the 'data.old' field of the
--   event trigger payload. The value of 'data.old' is null in INSERT
--   trigger operation.
--   
--   NEW: Depicts the new database row value for INSERT/UPDATE trigger
--   operations. This is used to construct the 'data.new' field of the
--   event trigger payload. The value of 'data.new' is null in DELETE
--   trigger operation.
data OpVar
OLD :: OpVar
NEW :: OpVar
instance GHC.Classes.Eq Hasura.RQL.Types.Eventing.PGTextArray
instance GHC.Show.Show Hasura.RQL.Types.Eventing.PGTextArray
instance GHC.Show.Show Hasura.RQL.Types.Eventing.OpVar
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Eventing.PGTextArray
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Eventing.Response 'Hasura.RQL.Types.Eventing.EventType)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Eventing.Response 'Hasura.RQL.Types.Eventing.ScheduledType)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.ClientError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.WebhookResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.WebhookRequest
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Eventing.EventId
instance Control.DeepSeq.NFData Hasura.RQL.Types.Eventing.EventId
instance GHC.Generics.Generic Hasura.RQL.Types.Eventing.EventId
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Eventing.EventId
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Eventing.EventId
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Eventing.EventId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.EventId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Eventing.EventId
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Eventing.EventId
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Eventing.EventId
instance GHC.Classes.Ord Hasura.RQL.Types.Eventing.EventId
instance GHC.Classes.Eq Hasura.RQL.Types.Eventing.EventId
instance GHC.Show.Show Hasura.RQL.Types.Eventing.EventId

module Hasura.RQL.Types.Common
newtype RelName
RelName :: NonEmptyText -> RelName
[getRelTxt] :: RelName -> NonEmptyText
relNameToTxt :: RelName -> Text
fromRemoteRelationship :: RelName -> FieldName
data RelType
ObjRel :: RelType
ArrRel :: RelType
relTypeToTxt :: RelType -> Text
data JsonAggSelect
JASMultipleRows :: JsonAggSelect
JASSingleObject :: JsonAggSelect
data InsertOrder
BeforeParent :: InsertOrder
AfterParent :: InsertOrder

-- | Postgres OIDs.
--   <a>https://www.postgresql.org/docs/12/datatype-oid.html</a>
newtype OID
OID :: Int -> OID
[unOID] :: OID -> Int
newtype FieldName
FieldName :: Text -> FieldName
[getFieldNameTxt] :: FieldName -> Text
type Fields a = [(FieldName, a)]
class ToAesonPairs a
toAesonPairs :: (ToAesonPairs a, KeyValue v) => a -> [v]
data SourceName
SNDefault :: SourceName
SNName :: NonEmptyText -> SourceName
sourceNameToText :: SourceName -> Text
defaultSource :: SourceName
data InpValInfo
InpValInfo :: Maybe Description -> Name -> Maybe (Value Void) -> GType -> InpValInfo
[_iviDesc] :: InpValInfo -> Maybe Description
[_iviName] :: InpValInfo -> Name
[_iviDefVal] :: InpValInfo -> Maybe (Value Void)
[_iviType] :: InpValInfo -> GType
newtype SystemDefined
SystemDefined :: Bool -> SystemDefined
[unSystemDefined] :: SystemDefined -> Bool
isSystemDefined :: SystemDefined -> Bool
data SQLGenCtx
SQLGenCtx :: StringifyNumbers -> DangerouslyCollapseBooleans -> OptimizePermissionFilters -> SQLGenCtx
[stringifyNum] :: SQLGenCtx -> StringifyNumbers
[dangerousBooleanCollapse] :: SQLGenCtx -> DangerouslyCollapseBooleans
[optimizePermissionFilters] :: SQLGenCtx -> OptimizePermissionFilters
successMsg :: EncJSON
newtype ResolvedWebhook
ResolvedWebhook :: Text -> ResolvedWebhook
[unResolvedWebhook] :: ResolvedWebhook -> Text
newtype InputWebhook
InputWebhook :: URLTemplate -> InputWebhook
[unInputWebhook] :: InputWebhook -> URLTemplate
resolveWebhook :: QErrM m => Environment -> InputWebhook -> m ResolvedWebhook
newtype Timeout
Timeout :: Int -> Timeout
[unTimeout] :: Timeout -> Int
defaultActionTimeoutSecs :: Timeout

-- | See API reference here:
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/syntax-defs.html#pgconnectionparameters</a>
data PGConnectionParams
PGConnectionParams :: Text -> Text -> Maybe Text -> Int -> Text -> PGConnectionParams
[_pgcpHost] :: PGConnectionParams -> Text
[_pgcpUsername] :: PGConnectionParams -> Text
[_pgcpPassword] :: PGConnectionParams -> Maybe Text
[_pgcpPort] :: PGConnectionParams -> Int
[_pgcpDatabase] :: PGConnectionParams -> Text
data UrlConf

-- | the database connection string
UrlValue :: InputWebhook -> UrlConf

-- | the name of environment variable containing the connection string
UrlFromEnv :: Text -> UrlConf

-- | the minimum required `connection parameters` to construct a valid
--   connection string
UrlFromParams :: PGConnectionParams -> UrlConf
getConnOptionsFromConnParams :: PGConnectionParams -> ConnOptions

-- | Construct a Postgres connection URI as a String from
--   <a>PGConnectionParams</a>.
--   
--   NOTE: This function takes care to properly escape all URI components,
--   as Postgres requires that a connection URI is percent-encoded if it
--   includes symbols with "special meaning".
--   
--   See the <tt>libpq</tt> documentation for details:
--   <a>https://www.postgresql.org/docs/13/libpq-connect.html#id-1.7.3.8.3.6</a>
getPGConnectionStringFromParams :: PGConnectionParams -> String
resolveUrlConf :: MonadError QErr m => Environment -> UrlConf -> m Text
getEnv :: QErrM m => Environment -> Text -> m Text

-- | Various user-controlled configuration for metrics used by Pro
data MetricsConfig
MetricsConfig :: Bool -> Bool -> MetricsConfig

-- | should the query-variables be logged and analyzed for metrics
[_mcAnalyzeQueryVariables] :: MetricsConfig -> Bool

-- | should the response-body be analyzed for empty and null responses
[_mcAnalyzeResponseBody] :: MetricsConfig -> Bool
emptyMetricsConfig :: MetricsConfig
data Comment

-- | Automatically generate a comment (derive it from DB comments, or a
--   sensible default describing the source of the data)
Automatic :: Comment

-- | The user's explicitly provided comment, or explicitly no comment (ie.
--   leave it blank, do not autogenerate one)
Explicit :: Maybe NonEmptyText -> Comment
commentToMaybeText :: Comment -> Maybe Text
commentFromMaybeText :: Maybe Text -> Comment

-- | We use the following type, after we resolve the env var. | This will
--   store both the env var name and the resolved value.
data EnvRecord a
EnvRecord :: Text -> a -> EnvRecord a
[_envVarName] :: EnvRecord a -> Text
[_envVarValue] :: EnvRecord a -> a
data ApolloFederationVersion
V1 :: ApolloFederationVersion
data ApolloFederationConfig
ApolloFederationConfig :: ApolloFederationVersion -> ApolloFederationConfig
[enable] :: ApolloFederationConfig -> ApolloFederationVersion
isApolloFedV1enabled :: Maybe ApolloFederationConfig -> Bool
instance GHC.Generics.Generic Hasura.RQL.Types.Common.Comment
instance GHC.Show.Show Hasura.RQL.Types.Common.Comment
instance GHC.Classes.Eq Hasura.RQL.Types.Common.Comment
instance GHC.Generics.Generic (Hasura.RQL.Types.Common.EnvRecord a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Common.EnvRecord a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.Common.EnvRecord a)
instance GHC.Generics.Generic Hasura.RQL.Types.Common.ApolloFederationVersion
instance GHC.Classes.Eq Hasura.RQL.Types.Common.ApolloFederationVersion
instance GHC.Show.Show Hasura.RQL.Types.Common.ApolloFederationVersion
instance GHC.Generics.Generic Hasura.RQL.Types.Common.ApolloFederationConfig
instance GHC.Classes.Eq Hasura.RQL.Types.Common.ApolloFederationConfig
instance GHC.Show.Show Hasura.RQL.Types.Common.ApolloFederationConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.ApolloFederationConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.ApolloFederationConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.ApolloFederationConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.ApolloFederationConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.ApolloFederationVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.ApolloFederationVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.ApolloFederationVersion
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.ApolloFederationVersion
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.Types.Common.EnvRecord a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Common.EnvRecord a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Common.EnvRecord a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Common.EnvRecord a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Common.EnvRecord a)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.Comment
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.Comment
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.Comment
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.Comment
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.Comment
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.MetricsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.MetricsConfig
instance GHC.Generics.Generic Hasura.RQL.Types.Common.UrlConf
instance GHC.Classes.Eq Hasura.RQL.Types.Common.UrlConf
instance GHC.Show.Show Hasura.RQL.Types.Common.UrlConf
instance GHC.Generics.Generic Hasura.RQL.Types.Common.MetricsConfig
instance GHC.Classes.Eq Hasura.RQL.Types.Common.MetricsConfig
instance GHC.Show.Show Hasura.RQL.Types.Common.MetricsConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.UrlConf
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.UrlConf
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.UrlConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.UrlConf
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.UrlConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.PGConnectionParams
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.PGConnectionParams
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.RelName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.RelName
instance GHC.Generics.Generic Hasura.RQL.Types.Common.RelName
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.RelName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.RelName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.RelName
instance GHC.Classes.Ord Hasura.RQL.Types.Common.RelName
instance GHC.Classes.Eq Hasura.RQL.Types.Common.RelName
instance GHC.Show.Show Hasura.RQL.Types.Common.RelName
instance Data.Data.Data Hasura.RQL.Types.Common.RelType
instance GHC.Generics.Generic Hasura.RQL.Types.Common.RelType
instance GHC.Classes.Eq Hasura.RQL.Types.Common.RelType
instance GHC.Show.Show Hasura.RQL.Types.Common.RelType
instance GHC.Generics.Generic Hasura.RQL.Types.Common.JsonAggSelect
instance GHC.Classes.Eq Hasura.RQL.Types.Common.JsonAggSelect
instance GHC.Show.Show Hasura.RQL.Types.Common.JsonAggSelect
instance GHC.Generics.Generic Hasura.RQL.Types.Common.InsertOrder
instance GHC.Classes.Eq Hasura.RQL.Types.Common.InsertOrder
instance GHC.Show.Show Hasura.RQL.Types.Common.InsertOrder
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.OID
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.OID
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.OID
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.OID
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.OID
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.OID
instance GHC.Classes.Eq Hasura.RQL.Types.Common.OID
instance GHC.Show.Show Hasura.RQL.Types.Common.OID
instance GHC.Base.Semigroup Hasura.RQL.Types.Common.FieldName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.FieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.FieldName
instance Data.String.IsString Hasura.RQL.Types.Common.FieldName
instance GHC.Generics.Generic Hasura.RQL.Types.Common.FieldName
instance Data.Data.Data Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.FieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.FieldName
instance GHC.Classes.Ord Hasura.RQL.Types.Common.FieldName
instance GHC.Classes.Eq Hasura.RQL.Types.Common.FieldName
instance GHC.Show.Show Hasura.RQL.Types.Common.FieldName
instance GHC.Generics.Generic Hasura.RQL.Types.Common.SourceName
instance GHC.Classes.Ord Hasura.RQL.Types.Common.SourceName
instance GHC.Classes.Eq Hasura.RQL.Types.Common.SourceName
instance GHC.Show.Show Hasura.RQL.Types.Common.SourceName
instance GHC.Generics.Generic Hasura.RQL.Types.Common.InpValInfo
instance Language.Haskell.TH.Syntax.Lift Hasura.RQL.Types.Common.InpValInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Common.InpValInfo
instance GHC.Show.Show Hasura.RQL.Types.Common.InpValInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.SystemDefined
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.SystemDefined
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Common.SystemDefined
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.SystemDefined
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.SystemDefined
instance GHC.Classes.Eq Hasura.RQL.Types.Common.SystemDefined
instance GHC.Show.Show Hasura.RQL.Types.Common.SystemDefined
instance GHC.Classes.Eq Hasura.RQL.Types.Common.SQLGenCtx
instance GHC.Show.Show Hasura.RQL.Types.Common.SQLGenCtx
instance GHC.Generics.Generic Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.ResolvedWebhook
instance GHC.Classes.Eq Hasura.RQL.Types.Common.ResolvedWebhook
instance GHC.Show.Show Hasura.RQL.Types.Common.ResolvedWebhook
instance GHC.Generics.Generic Hasura.RQL.Types.Common.InputWebhook
instance GHC.Classes.Eq Hasura.RQL.Types.Common.InputWebhook
instance GHC.Show.Show Hasura.RQL.Types.Common.InputWebhook
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.Timeout
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.Timeout
instance GHC.Generics.Generic Hasura.RQL.Types.Common.Timeout
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.Timeout
instance GHC.Classes.Eq Hasura.RQL.Types.Common.Timeout
instance GHC.Show.Show Hasura.RQL.Types.Common.Timeout
instance GHC.Generics.Generic Hasura.RQL.Types.Common.PGConnectionParams
instance GHC.Classes.Eq Hasura.RQL.Types.Common.PGConnectionParams
instance GHC.Show.Show Hasura.RQL.Types.Common.PGConnectionParams
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.PGConnectionParams
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.PGConnectionParams
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.PGConnectionParams
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.Timeout
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.InputWebhook
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.InputWebhook
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.InputWebhook
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.InputWebhook
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.InputWebhook
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.InputWebhook
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.ResolvedWebhook
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.ResolvedWebhook
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.InpValInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.SourceName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.SourceName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.SourceName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.RQL.Types.Common.SourceName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Common.SourceName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.SourceName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.SourceName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.SourceName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.FieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.InsertOrder
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.InsertOrder
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.InsertOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.InsertOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.InsertOrder
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.JsonAggSelect
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.JsonAggSelect
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.RelType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.RelType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Common.RelType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.RelType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.RelType
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.RelType
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.RelName


-- | API related to Postgres' pg dump
module Hasura.Server.API.PGDump
data PGDumpReqBody
PGDumpReqBody :: !SourceName -> ![String] -> !Bool -> PGDumpReqBody
[prbSource] :: PGDumpReqBody -> !SourceName
[prbOpts] :: PGDumpReqBody -> ![String]
[prbCleanOutput] :: PGDumpReqBody -> !Bool
execPGDump :: (MonadError QErr m, MonadIO m) => PGDumpReqBody -> ConnInfo -> m ByteString
instance GHC.Classes.Eq Hasura.Server.API.PGDump.PGDumpReqBody
instance GHC.Show.Show Hasura.Server.API.PGDump.PGDumpReqBody
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.PGDump.PGDumpReqBody

module Hasura.GraphQL.Schema.NamingCase

-- | Represents the different possible type cases for fields and types,
--   i.e. <tt>HasuraCase</tt> and <tt>GraphqlCase</tt> (<tt>CamelCase</tt>
--   fields and <tt>PascalCase</tt> types).
data NamingCase
HasuraCase :: NamingCase
GraphqlCase :: NamingCase
parseNamingConventionFromText :: Text -> Either String NamingCase
isGraphqlCase :: NamingCase -> Bool
instance GHC.Generics.Generic Hasura.GraphQL.Schema.NamingCase.NamingCase
instance GHC.Show.Show Hasura.GraphQL.Schema.NamingCase.NamingCase
instance GHC.Classes.Eq Hasura.GraphQL.Schema.NamingCase.NamingCase
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.GraphQL.Schema.NamingCase.NamingCase
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Schema.NamingCase.NamingCase
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Schema.NamingCase.NamingCase

module Hasura.Server.Types
newtype RequestId
RequestId :: Text -> RequestId
[unRequestId] :: RequestId -> Text
getRequestId :: MonadIO m => [Header] -> m (RequestId, [Header])

-- | A uuid of a source database.
newtype DbUid
DbUid :: Text -> DbUid
[getDbUid] :: DbUid -> Text
newtype DbVersion
DbVersion :: Text -> DbVersion
[unDbVersion] :: DbVersion -> Text
newtype PGVersion
PGVersion :: Int -> PGVersion
[unPGVersion] :: PGVersion -> Int
pgToDbVersion :: PGVersion -> DbVersion

-- | A uuid of the postgres metadata db.
newtype MetadataDbId
MetadataDbId :: Text -> MetadataDbId
[getMetadataDbId] :: MetadataDbId -> Text
mdDbIdToDbUid :: MetadataDbId -> DbUid
newtype InstanceId
InstanceId :: Text -> InstanceId
[getInstanceId] :: InstanceId -> Text

-- | Generate an <a>InstanceId</a> from a <tt>UUID</tt>
generateInstanceId :: IO InstanceId
data ExperimentalFeature
EFInheritedRoles :: ExperimentalFeature
EFOptimizePermissionFilters :: ExperimentalFeature
EFNamingConventions :: ExperimentalFeature
EFStreamingSubscriptions :: ExperimentalFeature
EFApolloFederation :: ExperimentalFeature
data MaintenanceMode a
MaintenanceModeEnabled :: a -> MaintenanceMode a
MaintenanceModeDisabled :: MaintenanceMode a

-- | See Note [ReadOnly Mode]
data ReadOnlyMode
ReadOnlyModeEnabled :: ReadOnlyMode
ReadOnlyModeDisabled :: ReadOnlyMode

-- | EventingMode decides whether the eventing subsystem should be enabled
--   or disabled. <tt>EventDisabled</tt> mode disables Event Triggers,
--   Async Actions, Scheduled Events and source catalaog migrations. This
--   is an internal feature and will not be exposed to users.
data EventingMode
EventingEnabled :: EventingMode
EventingDisabled :: EventingMode
data ServerConfigCtx
ServerConfigCtx :: InferFunctionPermissions -> RemoteSchemaPermissions -> SQLGenCtx -> MaintenanceMode () -> HashSet ExperimentalFeature -> EventingMode -> ReadOnlyMode -> Maybe NamingCase -> ServerConfigCtx
[_sccFunctionPermsCtx] :: ServerConfigCtx -> InferFunctionPermissions
[_sccRemoteSchemaPermsCtx] :: ServerConfigCtx -> RemoteSchemaPermissions
[_sccSQLGenCtx] :: ServerConfigCtx -> SQLGenCtx
[_sccMaintenanceMode] :: ServerConfigCtx -> MaintenanceMode ()
[_sccExperimentalFeatures] :: ServerConfigCtx -> HashSet ExperimentalFeature
[_sccEventingMode] :: ServerConfigCtx -> EventingMode
[_sccReadOnlyMode] :: ServerConfigCtx -> ReadOnlyMode

-- | stores global default naming convention
[_sccDefaultNamingConvention] :: ServerConfigCtx -> Maybe NamingCase
class (Monad m) => HasServerConfigCtx m
askServerConfigCtx :: HasServerConfigCtx m => m ServerConfigCtx
instance Data.Hashable.Class.Hashable Hasura.Server.Types.RequestId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.RequestId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.RequestId
instance GHC.Classes.Eq Hasura.Server.Types.RequestId
instance GHC.Show.Show Hasura.Server.Types.RequestId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.DbUid
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.DbUid
instance GHC.Classes.Eq Hasura.Server.Types.DbUid
instance GHC.Show.Show Hasura.Server.Types.DbUid
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.DbVersion
instance GHC.Classes.Eq Hasura.Server.Types.DbVersion
instance GHC.Show.Show Hasura.Server.Types.DbVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.PGVersion
instance GHC.Classes.Eq Hasura.Server.Types.PGVersion
instance GHC.Show.Show Hasura.Server.Types.PGVersion
instance Database.PG.Query.Class.ToPrepArg Hasura.Server.Types.MetadataDbId
instance Database.PG.Query.Class.FromCol Hasura.Server.Types.MetadataDbId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.MetadataDbId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.MetadataDbId
instance GHC.Classes.Eq Hasura.Server.Types.MetadataDbId
instance GHC.Show.Show Hasura.Server.Types.MetadataDbId
instance Database.PG.Query.Class.ToPrepArg Hasura.Server.Types.InstanceId
instance Database.PG.Query.Class.FromCol Hasura.Server.Types.InstanceId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.InstanceId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.InstanceId
instance GHC.Classes.Eq Hasura.Server.Types.InstanceId
instance GHC.Show.Show Hasura.Server.Types.InstanceId
instance GHC.Generics.Generic Hasura.Server.Types.ExperimentalFeature
instance GHC.Classes.Eq Hasura.Server.Types.ExperimentalFeature
instance GHC.Show.Show Hasura.Server.Types.ExperimentalFeature
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Server.Types.MaintenanceMode a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Server.Types.MaintenanceMode a)
instance GHC.Classes.Eq Hasura.Server.Types.ReadOnlyMode
instance GHC.Show.Show Hasura.Server.Types.ReadOnlyMode
instance GHC.Classes.Eq Hasura.Server.Types.EventingMode
instance GHC.Show.Show Hasura.Server.Types.EventingMode
instance GHC.Classes.Eq Hasura.Server.Types.ServerConfigCtx
instance GHC.Show.Show Hasura.Server.Types.ServerConfigCtx
instance Hasura.Server.Types.HasServerConfigCtx m => Hasura.Server.Types.HasServerConfigCtx (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.Types.HasServerConfigCtx m => Hasura.Server.Types.HasServerConfigCtx (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Server.Types.HasServerConfigCtx m => Hasura.Server.Types.HasServerConfigCtx (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.Server.Types.MaintenanceMode ())
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Server.Types.MaintenanceMode ())
instance Data.Hashable.Class.Hashable Hasura.Server.Types.ExperimentalFeature
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.ExperimentalFeature
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.ExperimentalFeature


-- | Postgres Types CitusExtraTableMetadata
--   
--   Additional metadata information for Citus tables.
--   
--   See
--   <a>https://www.citusdata.com/blog/2017/07/27/database-table-types-with-citus-and-postgres/</a>
--   for more details on the Citus table types.
module Hasura.Backends.Postgres.Types.CitusExtraTableMetadata
data ExtraTableMetadata
Local :: ExtraTableMetadata
Reference :: ExtraTableMetadata
Distributed :: Text -> ExtraTableMetadata
[distributionColumn] :: ExtraTableMetadata -> Text
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance GHC.Show.Show Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata


-- | Postgres Execute Types
--   
--   Execution context and source configuration for Postgres databases.
--   Provides support for things such as read-only transactions and read
--   replicas.
module Hasura.Backends.Postgres.Execute.Types
type RunTx = forall m a. (MonadIO m, MonadBaseControl IO m) => TxET QErr m a -> ExceptT QErr m a
data PGExecCtx
PGExecCtx :: RunTx -> RunTx -> RunTx -> IO () -> PGExecCtx

-- | Run a Q.ReadOnly transaction
[_pecRunReadOnly] :: PGExecCtx -> RunTx

-- | Run a read only statement without an explicit transaction block
[_pecRunReadNoTx] :: PGExecCtx -> RunTx

-- | Run a Q.ReadWrite transaction
[_pecRunReadWrite] :: PGExecCtx -> RunTx

-- | Destroys connection pools
[_pecDestroyConn] :: PGExecCtx -> IO ()

-- | Creates a Postgres execution context for a single Postgres master pool
mkPGExecCtx :: TxIsolation -> PGPool -> PGExecCtx
defaultTxErrorHandler :: PGTxErr -> QErr

-- | Constructs a transaction error handler tailored for the needs of RQL's
--   DML.
dmlTxErrorHandler :: PGTxErr -> QErr

-- | Constructs a transaction error handler given a predicate that
--   determines which errors are expected and should be reported to the
--   user. All other errors are considered internal errors.
mkTxErrorHandler :: (PGErrorType -> Bool) -> PGTxErr -> QErr
data PGSourceConfig
PGSourceConfig :: PGExecCtx -> ConnInfo -> Maybe (NonEmpty ConnInfo) -> IO () -> ExtensionsSchema -> PGSourceConfig
[_pscExecCtx] :: PGSourceConfig -> PGExecCtx
[_pscConnInfo] :: PGSourceConfig -> ConnInfo
[_pscReadReplicaConnInfos] :: PGSourceConfig -> Maybe (NonEmpty ConnInfo)
[_pscPostDropHook] :: PGSourceConfig -> IO ()
[_pscExtensionsSchema] :: PGSourceConfig -> ExtensionsSchema
runPgSourceReadTx :: (MonadIO m, MonadBaseControl IO m) => PGSourceConfig -> TxET QErr m a -> m (Either QErr a)
runPgSourceWriteTx :: (MonadIO m, MonadBaseControl IO m) => PGSourceConfig -> TxET QErr m a -> m (Either QErr a)
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.Types.PGSourceConfig
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Types.PGSourceConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Execute.Types.PGSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.Types.PGSourceConfig


-- | Postgres Connection Settings
--   
--   This module contains types and combinators related to postgres
--   connection, pool, and replica related settings.
module Hasura.Backends.Postgres.Connection.Settings
data PostgresPoolSettings
PostgresPoolSettings :: Maybe Int -> Maybe Int -> Maybe Int -> Maybe NominalDiffTime -> Maybe NominalDiffTime -> PostgresPoolSettings
[_ppsMaxConnections] :: PostgresPoolSettings -> Maybe Int
[_ppsIdleTimeout] :: PostgresPoolSettings -> Maybe Int
[_ppsRetries] :: PostgresPoolSettings -> Maybe Int
[_ppsPoolTimeout] :: PostgresPoolSettings -> Maybe NominalDiffTime
[_ppsConnectionLifetime] :: PostgresPoolSettings -> Maybe NominalDiffTime
data DefaultPostgresPoolSettings
DefaultPostgresPoolSettings :: Int -> Int -> Int -> Maybe NominalDiffTime -> DefaultPostgresPoolSettings
[_dppsMaxConnections] :: DefaultPostgresPoolSettings -> Int
[_dppsIdleTimeout] :: DefaultPostgresPoolSettings -> Int
[_dppsRetries] :: DefaultPostgresPoolSettings -> Int
[_dppsConnectionLifetime] :: DefaultPostgresPoolSettings -> Maybe NominalDiffTime
defaultPostgresPoolSettings :: DefaultPostgresPoolSettings
setPostgresPoolSettings :: PostgresPoolSettings
getDefaultPGPoolSettingIfNotExists :: Maybe PostgresPoolSettings -> DefaultPostgresPoolSettings -> (Int, Int, Int)
data SSLMode
Disable :: SSLMode
Allow :: SSLMode
Prefer :: SSLMode
Require :: SSLMode
VerifyCA :: SSLMode
VerifyFull :: SSLMode
newtype CertVar
CertVar :: String -> CertVar
newtype CertData
CertData :: Text -> CertData
[unCert] :: CertData -> Text
data PGClientCerts p a
PGClientCerts :: Maybe a -> Maybe a -> Maybe a -> SSLMode -> Maybe p -> PGClientCerts p a
[pgcSslCert] :: PGClientCerts p a -> Maybe a
[pgcSslKey] :: PGClientCerts p a -> Maybe a
[pgcSslRootCert] :: PGClientCerts p a -> Maybe a
[pgcSslMode] :: PGClientCerts p a -> SSLMode
[pgcSslPassword] :: PGClientCerts p a -> Maybe p
data PostgresSourceConnInfo
PostgresSourceConnInfo :: UrlConf -> Maybe PostgresPoolSettings -> Bool -> TxIsolation -> Maybe (PGClientCerts CertVar CertVar) -> PostgresSourceConnInfo
[_psciDatabaseUrl] :: PostgresSourceConnInfo -> UrlConf
[_psciPoolSettings] :: PostgresSourceConnInfo -> Maybe PostgresPoolSettings
[_psciUsePreparedStatements] :: PostgresSourceConnInfo -> Bool
[_psciIsolationLevel] :: PostgresSourceConnInfo -> TxIsolation
[_psciSslConfiguration] :: PostgresSourceConnInfo -> Maybe (PGClientCerts CertVar CertVar)
psciUsePreparedStatements :: Lens' PostgresSourceConnInfo Bool
psciSslConfiguration :: Lens' PostgresSourceConnInfo (Maybe (PGClientCerts CertVar CertVar))
psciPoolSettings :: Lens' PostgresSourceConnInfo (Maybe PostgresPoolSettings)
psciIsolationLevel :: Lens' PostgresSourceConnInfo TxIsolation
psciDatabaseUrl :: Lens' PostgresSourceConnInfo UrlConf
defaultPostgresExtensionsSchema :: ExtensionsSchema
data PostgresConnConfiguration
PostgresConnConfiguration :: PostgresSourceConnInfo -> Maybe (NonEmpty PostgresSourceConnInfo) -> ExtensionsSchema -> PostgresConnConfiguration
[_pccConnectionInfo] :: PostgresConnConfiguration -> PostgresSourceConnInfo
[_pccReadReplicas] :: PostgresConnConfiguration -> Maybe (NonEmpty PostgresSourceConnInfo)
[_pccExtensionsSchema] :: PostgresConnConfiguration -> ExtensionsSchema
pccReadReplicas :: Lens' PostgresConnConfiguration (Maybe (NonEmpty PostgresSourceConnInfo))
pccExtensionsSchema :: Lens' PostgresConnConfiguration ExtensionsSchema
pccConnectionInfo :: Lens' PostgresConnConfiguration PostgresSourceConnInfo
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance GHC.Generics.Generic Database.PG.Query.Transaction.TxIsolation
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance (Data.Aeson.Types.ToJSON.ToJSON p, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance Data.Bifunctor.Bifunctor Hasura.Backends.Postgres.Connection.Settings.PGClientCerts
instance Data.Bifoldable.Bifoldable Hasura.Backends.Postgres.Connection.Settings.PGClientCerts
instance Data.Bitraversable.Bitraversable Hasura.Backends.Postgres.Connection.Settings.PGClientCerts
instance (Hasura.Incremental.Internal.Dependency.Cacheable p, Hasura.Incremental.Internal.Dependency.Cacheable a) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance (Data.Hashable.Class.Hashable p, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance (Control.DeepSeq.NFData p, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Hasura.Incremental.Internal.Dependency.Cacheable Database.PG.Query.Transaction.TxIsolation
instance Control.DeepSeq.NFData Database.PG.Query.Transaction.TxIsolation
instance Data.Hashable.Class.Hashable Database.PG.Query.Transaction.TxIsolation
instance Data.Aeson.Types.FromJSON.FromJSON Database.PG.Query.Transaction.TxIsolation
instance Data.Aeson.Types.ToJSON.ToJSON Database.PG.Query.Transaction.TxIsolation
instance (Data.Aeson.Types.FromJSON.FromJSON p, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.DefaultPostgresPoolSettings
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.DefaultPostgresPoolSettings
instance GHC.Enum.Bounded Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Enum.Enum Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Classes.Ord Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.CertVar
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.CertVar
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.CertVar
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.CertData
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.CertData
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.CertData
instance Data.Traversable.Traversable (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p)
instance Data.Foldable.Foldable (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p)
instance GHC.Base.Functor (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq p) => GHC.Classes.Eq (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance (GHC.Show.Show a, GHC.Show.Show p) => GHC.Show.Show (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.CertData
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings


-- | MSSQL Connection
--   
--   This module handles the connection against an MS SQL Server. It
--   defines the connection string, connection pool, default settings, and
--   conversion functions between MSSQL and graphql-engine.
module Hasura.Backends.MSSQL.Connection
class MonadError QErr m => MonadMSSQLTx m
liftMSSQLTx :: MonadMSSQLTx m => TxE QErr a -> m a

-- | ODBC connection string for MSSQL server
newtype MSSQLConnectionString
MSSQLConnectionString :: Text -> MSSQLConnectionString
[unMSSQLConnectionString] :: MSSQLConnectionString -> Text
data InputConnectionString
RawString :: ConnectionString -> InputConnectionString
FromEnvironment :: Text -> InputConnectionString
data MSSQLPoolSettings
MSSQLPoolSettings :: Int -> Int -> MSSQLPoolSettings
[_mpsMaxConnections] :: MSSQLPoolSettings -> Int
[_mpsIdleTimeout] :: MSSQLPoolSettings -> Int
defaultMSSQLPoolSettings :: MSSQLPoolSettings
data MSSQLConnectionInfo
MSSQLConnectionInfo :: InputConnectionString -> MSSQLPoolSettings -> MSSQLConnectionInfo
[_mciConnectionString] :: MSSQLConnectionInfo -> InputConnectionString
[_mciPoolSettings] :: MSSQLConnectionInfo -> MSSQLPoolSettings
data MSSQLConnConfiguration
MSSQLConnConfiguration :: MSSQLConnectionInfo -> Maybe (NonEmpty MSSQLConnectionInfo) -> MSSQLConnConfiguration
[_mccConnectionInfo] :: MSSQLConnConfiguration -> MSSQLConnectionInfo
[_mccReadReplicas] :: MSSQLConnConfiguration -> Maybe (NonEmpty MSSQLConnectionInfo)
createMSSQLPool :: MonadIO m => QErrM m => MSSQLConnectionInfo -> Environment -> m (ConnectionString, MSSQLPool)
resolveInputConnectionString :: QErrM m => Environment -> InputConnectionString -> m ConnectionString
getEnv :: QErrM m => Environment -> Text -> m Text
type MSSQLRunTx = forall m a. (MonadIO m, MonadBaseControl IO m) => TxET QErr m a -> ExceptT QErr m a

-- | Execution Context required to execute MSSQL transactions
data MSSQLExecCtx
MSSQLExecCtx :: MSSQLRunTx -> MSSQLRunTx -> IO () -> MSSQLExecCtx

-- | A function that runs read-only queries
[mssqlRunReadOnly] :: MSSQLExecCtx -> MSSQLRunTx

-- | A function that runs read-write queries; run in a transaction
[mssqlRunReadWrite] :: MSSQLExecCtx -> MSSQLRunTx

-- | Destroys connection pools
[mssqlDestroyConn] :: MSSQLExecCtx -> IO ()

-- | Creates a MSSQL execution context for a single primary pool
mkMSSQLExecCtx :: MSSQLPool -> MSSQLExecCtx
data MSSQLSourceConfig
MSSQLSourceConfig :: ConnectionString -> MSSQLExecCtx -> MSSQLSourceConfig
[_mscConnectionString] :: MSSQLSourceConfig -> ConnectionString
[_mscExecCtx] :: MSSQLSourceConfig -> MSSQLExecCtx
odbcValueToJValue :: Value -> Value
runMSSQLSourceReadTx :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> TxET QErr m a -> m (Either QErr a)
runMSSQLSourceWriteTx :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> TxET QErr m a -> m (Either QErr a)
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Connection.InputConnectionString
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.InputConnectionString
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.InputConnectionString
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Hasura.Backends.MSSQL.Connection.MonadMSSQLTx m => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Control.Monad.Trans.Reader.ReaderT s m)
instance Hasura.Backends.MSSQL.Connection.MonadMSSQLTx m => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Hasura.Backends.MSSQL.Connection.MonadMSSQLTx m) => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Control.Monad.IO.Class.MonadIO m => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Database.MSSQL.Transaction.TxET Hasura.Base.Error.QErr m)
instance Hasura.Incremental.Internal.Dependency.Cacheable Database.MSSQL.Pool.ConnectionString
instance Data.Hashable.Class.Hashable Database.MSSQL.Pool.ConnectionString
instance Control.DeepSeq.NFData Database.MSSQL.Pool.ConnectionString

module Hasura.Backends.DataConnector.IR.Table

-- | The fully qualified name of a table. The last element in the list is
--   the table name and all other elements represent namespacing of the
--   table name. For example, for a database that has schemas, the name
--   would be '[<a>schema</a>,<a>name</a>]'
newtype Name
Name :: NonEmpty Text -> Name
[unName] :: Name -> NonEmpty Text
newtype ConstraintName
ConstraintName :: Text -> ConstraintName
[unConstraintName] :: ConstraintName -> Text
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Table.Name
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Table.Name
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Table.Name
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Table.Name
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Table.Name
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Table.Name
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Table.Name
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Table.Name
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Table.Name
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Table.ConstraintName Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance Witch.From.From Hasura.Backends.DataConnector.IR.Table.ConstraintName Hasura.Backends.DataConnector.API.V0.Table.ConstraintName
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.IR.Table.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Table.Name
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.IR.Table.Name
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Table.TableName Hasura.Backends.DataConnector.IR.Table.Name
instance Witch.From.From Hasura.Backends.DataConnector.IR.Table.Name Hasura.Backends.DataConnector.API.V0.Table.TableName
instance Witch.From.From Data.Text.Internal.Text Hasura.Backends.DataConnector.IR.Table.Name
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.IR.Table.Name
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.IR.Table.Name

module Hasura.Backends.DataConnector.IR.Scalar.Type

-- | Types of scalar values
--   
--   Used to specify the domain of legal values for a <tt>Column</tt>.
--   
--   NOTE: This type shouldn't _need_ ser/de instances, but they're imposed
--   by the <tt>Backend</tt> class.
--   
--   XXX: Should we add a <tt>Nullable _ :: Type</tt> constructor instead
--   of using an <tt>isNullable</tt> flag in <tt>Column</tt>?
data Type
String :: Type
Number :: Type
Bool :: Type
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Scalar.Type.Type Hasura.Backends.DataConnector.IR.Scalar.Type.Type
instance Witch.From.From Hasura.Backends.DataConnector.IR.Scalar.Type.Type Hasura.Backends.DataConnector.API.V0.Scalar.Type.Type

module Hasura.Backends.DataConnector.IR.Scalar.Value

-- | Literal scalar values that can appear as leaf nodes in expressions
--   
--   NOTE: This type shouldn't _need_ ser/de instances, but they're imposed
--   by the <tt>Backend</tt> class.
data Value
String :: Text -> Value
Number :: Scientific -> Value
Boolean :: Bool -> Value
Null :: Value
data Literal
ValueLiteral :: Value -> Literal
ArrayLiteral :: [Value] -> Literal
parseValue :: Type -> Value -> Parser Value
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Scalar.Value.Value
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Scalar.Value.Value
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Scalar.Value.Value
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Scalar.Value.Value
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Scalar.Value.Value
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Scalar.Value.Value
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Scalar.Value.Value
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Scalar.Value.Value
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Scalar.Value.Value
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Scalar.Value.Value
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Scalar.Value.Literal
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Scalar.Value.Literal
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Scalar.Value.Literal
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Scalar.Value.Literal
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Scalar.Value.Literal
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Scalar.Value.Literal
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Scalar.Value.Literal
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Scalar.Value.Literal
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Scalar.Value.Value Hasura.Backends.DataConnector.IR.Scalar.Value.Value
instance Witch.From.From Hasura.Backends.DataConnector.IR.Scalar.Value.Value Hasura.Backends.DataConnector.API.V0.Scalar.Value.Value

module Hasura.Backends.DataConnector.IR.Name

-- | A tagged, opaque wrapper around <a>Text</a> that provides a number of
--   derived derived instances (primarily as required by the
--   <tt>Backend</tt> typeclass).
--   
--   This wrapper is indexed by <a>NameType</a> so that different "names"
--   can be represented as semantically distinct types without the
--   boilerplate of actually defining these wrappers separately.
newtype Name ty
Name :: Text -> Name ty
[unName] :: Name ty -> Text

-- | The "type" of "name" that the <a>Name</a> type is meant to provide a
--   textual representation for.
--   
--   In other words: an enumeration of all the types for which <a>Name</a>
--   acts as a shared abstraction.
data NameType
Column :: NameType
Relationship :: NameType
instance Data.Text.Extended.ToTxt (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance Data.Aeson.Types.ToJSON.ToJSONKey (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance Control.DeepSeq.NFData (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance Data.Hashable.Class.Hashable (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance Data.Aeson.Types.FromJSON.FromJSONKey (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance GHC.Show.Show (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance GHC.Classes.Ord (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance GHC.Generics.Generic (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance GHC.Classes.Eq (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance Data.Typeable.Internal.Typeable ty => Data.Data.Data (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance Hasura.Base.ToErrorValue.ToErrorValue (Hasura.Backends.DataConnector.IR.Name.Name ty)
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Column.ColumnName (Hasura.Backends.DataConnector.IR.Name.Name 'Hasura.Backends.DataConnector.IR.Name.Column)
instance Witch.From.From (Hasura.Backends.DataConnector.IR.Name.Name 'Hasura.Backends.DataConnector.IR.Name.Column) Hasura.Backends.DataConnector.API.V0.Column.ColumnName
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Relationships.RelationshipName (Hasura.Backends.DataConnector.IR.Name.Name 'Hasura.Backends.DataConnector.IR.Name.Relationship)
instance Witch.From.From (Hasura.Backends.DataConnector.IR.Name.Name 'Hasura.Backends.DataConnector.IR.Name.Relationship) Hasura.Backends.DataConnector.API.V0.Relationships.RelationshipName
instance Witch.From.From Data.Text.Internal.Text (Hasura.Backends.DataConnector.IR.Name.Name 'Hasura.Backends.DataConnector.IR.Name.Column)
instance Witch.From.From Data.Text.Internal.Text (Hasura.Backends.DataConnector.IR.Name.Name 'Hasura.Backends.DataConnector.IR.Name.Relationship)

module Hasura.Backends.DataConnector.IR.Column

-- | An alias for <a>Column</a> <a>Name</a>s.
--   
--   This alias is defined in its own module primarily for the convenience
--   of importing it qualified.
--   
--   For example: @ import Data.Coerce (coerce) import
--   Hasura.Experimental.IR.Column qualified as Column (Name)
--   
--   example :: Column.Name example = coerce <tt>Text </tt>Column.Name
--   "column_name" @
type Name = Name 'Column

module Hasura.Backends.DataConnector.Schema.Column

-- | A schematic representation which captures common attributes associated
--   with a piece of data that is stored in a given backend.
--   
--   These attributes ascribe meaningful semantics to the data that they
--   are associated with.
--   
--   cf. <a>https://en.wikipedia.org/wiki/Column_(database)</a>
--   <a>https://www.postgresql.org/docs/13/ddl-basics.html</a>
--   
--   XXX: Instead of an <tt>isNullable</tt> flag, should we instead add a
--   <tt>Nullable</tt> data constructor to <a>Type</a>?
data Column
Column :: Name -> Type -> Bool -> Maybe Text -> Column
[name] :: Column -> Name
[type_] :: Column -> Type
[isNullable] :: Column -> Bool
[description] :: Column -> Maybe Text
instance GHC.Show.Show Hasura.Backends.DataConnector.Schema.Column.Column
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Schema.Column.Column
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Schema.Column.Column
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Schema.Column.Column
instance Data.Data.Data Hasura.Backends.DataConnector.Schema.Column.Column

module Hasura.Backends.DataConnector.Schema.Table

-- | A schematic representation which captures a named collection of
--   columns
--   
--   TODO(cdparks): schematic in the sense of "relating to a schema" or
--   symbolic? This language is also used in the <tt>Column</tt>
--   documentation
--   
--   An element of a table is known as a row, record, tuple, or object, and
--   conforms to the shape specified by the list of <tt>Column</tt>s below.
--   
--   cf. <a>https://en.wikipedia.org/wiki/Table_(database)</a>
--   <a>https://www.postgresql.org/docs/13/ddl-basics.html</a>
--   
--   NOTE(jkachmar): This type shouldn't _need_ ser/de instances, but
--   they're imposed by the <tt>Backend</tt> class.
data Table
Table :: Name -> [Column] -> Maybe Text -> Maybe Text -> Table
[name] :: Table -> Name
[columns] :: Table -> [Column]
[primaryKey] :: Table -> Maybe Text
[description] :: Table -> Maybe Text
instance GHC.Show.Show Hasura.Backends.DataConnector.Schema.Table.Table
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Schema.Table.Table
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Schema.Table.Table
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Schema.Table.Table
instance Data.Data.Data Hasura.Backends.DataConnector.Schema.Table.Table

module Hasura.Backends.DataConnector.IR.Relationships
type RelationshipName = Name 'Relationship
mkRelationshipName :: RelName -> RelationshipName
type SourceTableName = Name
newtype TableRelationships
TableRelationships :: HashMap SourceTableName (HashMap RelationshipName Relationship) -> TableRelationships
[unTableRelationships] :: TableRelationships -> HashMap SourceTableName (HashMap RelationshipName Relationship)
data Relationship
Relationship :: Name -> RelationshipType -> HashMap SourceColumnName TargetColumnName -> Relationship
[_rTargetTable] :: Relationship -> Name
[_rRelationshipType] :: Relationship -> RelationshipType
[_rColumnMapping] :: Relationship -> HashMap SourceColumnName TargetColumnName
data RelationshipType
ObjectRelationship :: RelationshipType
ArrayRelationship :: RelationshipType
type SourceColumnName = Name
type TargetColumnName = Name
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Relationships.RelationshipType
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Relationships.RelationshipType
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Relationships.RelationshipType
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Relationships.RelationshipType
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Relationships.RelationshipType
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Relationships.Relationship
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Relationships.Relationship
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Relationships.Relationship
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Relationships.Relationship
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Relationships.Relationship
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Relationships.TableRelationships
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Relationships.TableRelationships
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Relationships.TableRelationships
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Relationships.TableRelationships
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Relationships.TableRelationships
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Relationships.TableRelationships
instance GHC.Base.Semigroup Hasura.Backends.DataConnector.IR.Relationships.TableRelationships
instance GHC.Base.Monoid Hasura.Backends.DataConnector.IR.Relationships.TableRelationships
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Relationships.Relationship
instance Witch.From.From Hasura.Backends.DataConnector.IR.Relationships.Relationship Hasura.Backends.DataConnector.API.V0.Relationships.Relationship
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Relationships.Relationship Hasura.Backends.DataConnector.IR.Relationships.Relationship
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Relationships.RelationshipType
instance Witch.From.From Hasura.Backends.DataConnector.IR.Relationships.RelationshipType Hasura.Backends.DataConnector.API.V0.Relationships.RelationshipType
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Relationships.RelationshipType Hasura.Backends.DataConnector.IR.Relationships.RelationshipType

module Hasura.Backends.DataConnector.IR.Function
newtype Name
Name :: NonEmpty Text -> Name
[unName] :: Name -> NonEmpty Text
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Function.Name
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Function.Name
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Function.Name
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Function.Name
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Function.Name
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Function.Name
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Function.Name
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Function.Name
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Function.Name
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Function.Name
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.IR.Function.Name
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.IR.Function.Name
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.IR.Function.Name

module Hasura.Backends.DataConnector.IR.Expression

-- | A "concrete" expression type for datasource-agnostic queries (as
--   opposed to our existing polymorphic intermediate representation).
--   
--   This type should be seen as an intermediate phase of the processing
--   pipeline which provides a high-level interface that the GraphQL Engine
--   can use to inspect, manipulate, optimize, etc. before sending off to
--   an agent that will be responsible for performing query
--   generation/execution.
--   
--   This type should ascribe clear semantics to its sub-expressions; when
--   this is not possible, it should clearly defer to the semantics of some
--   reference datasource with clearer documentation.
--   
--   e.g. <a>https://www.postgresql.org/docs/13/sql-expressions.html</a>
data Expression

-- | A logical <tt>AND</tt> fold.
--   
--   cf. <a>https://www.postgresql.org/docs/13/functions-logical.html</a>
And :: [Expression] -> Expression

-- | A logical <tt>OR</tt> fold.
--   
--   cf. <a>https://www.postgresql.org/docs/13/functions-logical.html</a>
Or :: [Expression] -> Expression

-- | A logical <tt>NOT</tt> function.
--   
--   cf. <a>https://www.postgresql.org/docs/13/functions-logical.html</a>
Not :: Expression -> Expression

-- | Apply a <a>BinaryComparisonOperator</a> that compares a column to a
--   <a>ComparisonValue</a>; the result of this application will return
--   "true" or "false" depending on the <a>BinaryComparisonOperator</a>
--   that's being applied.
ApplyBinaryComparisonOperator :: BinaryComparisonOperator -> ComparisonColumn -> ComparisonValue -> Expression

-- | Apply a <a>BinaryArrayComparisonOperator</a> that evaluates a column
--   with the <a>BinaryArrayComparisonOperator</a> against an array of
--   <a>ComparisonValue</a>s. The result of this application will return
--   "true" or "false" depending on the
--   <a>BinaryArrayComparisonOperator</a> that's being applied.
ApplyBinaryArrayComparisonOperator :: BinaryArrayComparisonOperator -> ComparisonColumn -> [Value] -> Expression

-- | Apply a <a>UnaryComparisonOperator</a> that evaluates a column with
--   the <a>UnaryComparisonOperator</a>; the result of this application
--   will return "true" or "false" depending on the
--   <a>UnaryComparisonOperator</a> that's being applied.
ApplyUnaryComparisonOperator :: UnaryComparisonOperator -> ComparisonColumn -> Expression

-- | Operators which are typically applied to two <a>Expression</a>s (via
--   the <tt>ApplyOperator</tt> sub-<a>Expression</a>) to perform a boolean
--   comparison.
--   
--   cf.
--   <a>https://www.postgresql.org/docs/13/functions-comparison.html</a>
--   
--   XXX(jkachmar): Comparison operations are tricky business!
--   
--   We should define the semantics of these comparisons in a way that is
--   clear and carefully considered.
data BinaryComparisonOperator
LessThan :: BinaryComparisonOperator
LessThanOrEqual :: BinaryComparisonOperator
GreaterThan :: BinaryComparisonOperator
GreaterThanOrEqual :: BinaryComparisonOperator
Equal :: BinaryComparisonOperator
CustomBinaryComparisonOperator :: Text -> BinaryComparisonOperator
data UnaryComparisonOperator
IsNull :: UnaryComparisonOperator
CustomUnaryComparisonOperator :: Text -> UnaryComparisonOperator
data BinaryArrayComparisonOperator
In :: BinaryArrayComparisonOperator
CustomBinaryArrayComparisonOperator :: Text -> BinaryArrayComparisonOperator
data ComparisonColumn
ComparisonColumn :: [RelationshipName] -> Name -> ComparisonColumn
[_ccPath] :: ComparisonColumn -> [RelationshipName]
[_ccName] :: ComparisonColumn -> Name
data ComparisonValue
AnotherColumn :: ComparisonColumn -> ComparisonValue
ScalarValue :: Value -> ComparisonValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Expression.ComparisonValue
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Expression.ComparisonValue
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Expression.ComparisonValue
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Expression.ComparisonValue
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Expression.ComparisonValue
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Expression.ComparisonValue
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Expression.ComparisonValue
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Expression.ComparisonValue
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Expression.ComparisonValue
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Expression.ComparisonValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Expression.Expression
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Expression.Expression
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Expression.Expression
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Expression.Expression
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Expression.Expression
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Expression.Expression
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Expression.Expression
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Expression.Expression
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Expression.Expression
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Expression.Expression
instance Witch.From.From Hasura.Backends.DataConnector.IR.Expression.Expression Hasura.Backends.DataConnector.API.V0.Expression.Expression
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Expression.Expression Hasura.Backends.DataConnector.IR.Expression.Expression
instance Witch.From.From Hasura.Backends.DataConnector.IR.Expression.ComparisonValue Hasura.Backends.DataConnector.API.V0.Expression.ComparisonValue
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Expression.ComparisonValue Hasura.Backends.DataConnector.IR.Expression.ComparisonValue
instance Witch.From.From Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn Hasura.Backends.DataConnector.API.V0.Expression.ComparisonColumn
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Expression.ComparisonColumn Hasura.Backends.DataConnector.IR.Expression.ComparisonColumn
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Expression.BinaryArrayComparisonOperator Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator
instance Witch.From.From Hasura.Backends.DataConnector.IR.Expression.BinaryArrayComparisonOperator Hasura.Backends.DataConnector.API.V0.Expression.BinaryArrayComparisonOperator
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Expression.UnaryComparisonOperator Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator
instance Witch.From.From Hasura.Backends.DataConnector.IR.Expression.UnaryComparisonOperator Hasura.Backends.DataConnector.API.V0.Expression.UnaryComparisonOperator
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Expression.BinaryComparisonOperator Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator
instance Witch.From.From Hasura.Backends.DataConnector.IR.Expression.BinaryComparisonOperator Hasura.Backends.DataConnector.API.V0.Expression.BinaryComparisonOperator

module Hasura.Backends.DataConnector.IR.Aggregate
data Aggregate
SingleColumn :: SingleColumnAggregate -> Aggregate
Count :: CountAggregate -> Aggregate
data SingleColumnAggregate
SingleColumnAggregate :: SingleColumnAggregateFunction -> Name -> SingleColumnAggregate
[_scaFunction] :: SingleColumnAggregate -> SingleColumnAggregateFunction
[_scaColumn] :: SingleColumnAggregate -> Name
data SingleColumnAggregateFunction
Average :: SingleColumnAggregateFunction
Max :: SingleColumnAggregateFunction
Min :: SingleColumnAggregateFunction
StandardDeviationPopulation :: SingleColumnAggregateFunction
StandardDeviationSample :: SingleColumnAggregateFunction
Sum :: SingleColumnAggregateFunction
VariancePopulation :: SingleColumnAggregateFunction
VarianceSample :: SingleColumnAggregateFunction
data CountAggregate
StarCount :: CountAggregate
ColumnCount :: Name -> CountAggregate
ColumnDistinctCount :: Name -> CountAggregate
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregate
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregate
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregate
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregate
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregate
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregate
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregate
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregate
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregate
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Aggregate.CountAggregate
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Aggregate.CountAggregate
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Aggregate.CountAggregate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Aggregate.CountAggregate
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Aggregate.CountAggregate
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Aggregate.CountAggregate
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Aggregate.CountAggregate
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Aggregate.CountAggregate
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Aggregate.CountAggregate
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Aggregate.CountAggregate
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Aggregate.Aggregate
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.Aggregate.Aggregate
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.Aggregate.Aggregate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.IR.Aggregate.Aggregate
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.Aggregate.Aggregate
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Aggregate.Aggregate
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Aggregate.Aggregate
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Aggregate.Aggregate
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Aggregate.Aggregate
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Aggregate.Aggregate
instance Witch.From.From Hasura.Backends.DataConnector.IR.Aggregate.Aggregate Hasura.Backends.DataConnector.API.V0.Aggregate.Aggregate
instance Witch.From.From Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregate Hasura.Backends.DataConnector.API.V0.Aggregate.SingleColumnAggregate
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Aggregate.SingleColumnAggregateFunction Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction
instance Witch.From.From Hasura.Backends.DataConnector.IR.Aggregate.SingleColumnAggregateFunction Hasura.Backends.DataConnector.API.V0.Aggregate.SingleColumnAggregateFunction

module Hasura.Backends.DataConnector.IR.OrderBy
data OrderBy
OrderBy :: HashMap RelationshipName OrderByRelation -> NonEmpty OrderByElement -> OrderBy
[_obRelations] :: OrderBy -> HashMap RelationshipName OrderByRelation
[_obElements] :: OrderBy -> NonEmpty OrderByElement
data OrderByRelation
OrderByRelation :: Maybe Expression -> HashMap RelationshipName OrderByRelation -> OrderByRelation
[_obrWhere] :: OrderByRelation -> Maybe Expression
[_obrSubrelations] :: OrderByRelation -> HashMap RelationshipName OrderByRelation
data OrderByElement
OrderByElement :: [RelationshipName] -> OrderByTarget -> OrderDirection -> OrderByElement
[_obeTargetPath] :: OrderByElement -> [RelationshipName]
[_obeTarget] :: OrderByElement -> OrderByTarget
[_obeOrderDirection] :: OrderByElement -> OrderDirection
data OrderByTarget
OrderByColumn :: Name -> OrderByTarget
OrderByStarCountAggregate :: OrderByTarget
OrderBySingleColumnAggregate :: SingleColumnAggregate -> OrderByTarget
data OrderDirection
Ascending :: OrderDirection
Descending :: OrderDirection
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.OrderBy.OrderByRelation
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.OrderBy.OrderByRelation
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.OrderBy.OrderByRelation
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.OrderBy.OrderByRelation
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.OrderBy.OrderByRelation
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.OrderBy.OrderByRelation
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.OrderBy.OrderByRelation
instance Data.Data.Data Hasura.Backends.DataConnector.IR.OrderBy.OrderByRelation
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.OrderBy.OrderByTarget
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.OrderBy.OrderByTarget
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.OrderBy.OrderByTarget
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.OrderBy.OrderByTarget
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.OrderBy.OrderByTarget
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.OrderBy.OrderByTarget
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.OrderBy.OrderByTarget
instance Data.Data.Data Hasura.Backends.DataConnector.IR.OrderBy.OrderByTarget
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.OrderBy.OrderDirection
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.OrderBy.OrderDirection
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.OrderBy.OrderDirection
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.OrderBy.OrderDirection
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.OrderBy.OrderDirection
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.OrderBy.OrderDirection
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.OrderBy.OrderDirection
instance Data.Data.Data Hasura.Backends.DataConnector.IR.OrderBy.OrderDirection
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.OrderBy.OrderByElement
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.OrderBy.OrderByElement
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.OrderBy.OrderByElement
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.OrderBy.OrderByElement
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.OrderBy.OrderByElement
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.OrderBy.OrderByElement
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.OrderBy.OrderByElement
instance Data.Data.Data Hasura.Backends.DataConnector.IR.OrderBy.OrderByElement
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.IR.OrderBy.OrderBy
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.IR.OrderBy.OrderBy
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.IR.OrderBy.OrderBy
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.OrderBy.OrderBy
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.OrderBy.OrderBy
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.OrderBy.OrderBy
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.OrderBy.OrderBy
instance Data.Data.Data Hasura.Backends.DataConnector.IR.OrderBy.OrderBy
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.OrderBy.OrderBy
instance Witch.From.From Hasura.Backends.DataConnector.IR.OrderBy.OrderBy Hasura.Backends.DataConnector.API.V0.OrderBy.OrderBy
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.OrderBy.OrderByElement
instance Witch.From.From Hasura.Backends.DataConnector.IR.OrderBy.OrderByElement Hasura.Backends.DataConnector.API.V0.OrderBy.OrderByElement
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.OrderBy.OrderDirection
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.OrderBy.OrderDirection Hasura.Backends.DataConnector.IR.OrderBy.OrderDirection
instance Witch.From.From Hasura.Backends.DataConnector.IR.OrderBy.OrderDirection Hasura.Backends.DataConnector.API.V0.OrderBy.OrderDirection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.OrderBy.OrderByTarget
instance Witch.From.From Hasura.Backends.DataConnector.IR.OrderBy.OrderByTarget Hasura.Backends.DataConnector.API.V0.OrderBy.OrderByTarget
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.OrderBy.OrderByRelation
instance Witch.From.From Hasura.Backends.DataConnector.IR.OrderBy.OrderByRelation Hasura.Backends.DataConnector.API.V0.OrderBy.OrderByRelation

module Hasura.Backends.DataConnector.IR.Query

-- | An abstract request to retrieve structured data from some source.
data QueryRequest
QueryRequest :: Name -> TableRelationships -> Query -> QueryRequest
[_qrTable] :: QueryRequest -> Name
[_qrTableRelationships] :: QueryRequest -> TableRelationships
[_qrQuery] :: QueryRequest -> Query

-- | The details of a query against a table
data Query
Query :: HashMap FieldName Field -> HashMap FieldName Aggregate -> Maybe Int -> Maybe Int -> Maybe Expression -> Maybe OrderBy -> Query
[_qFields] :: Query -> HashMap FieldName Field
[_qAggregates] :: Query -> HashMap FieldName Aggregate

-- | Optionally limit to N results.
[_qLimit] :: Query -> Maybe Int

-- | Optionally offset from the Nth result.
[_qOffset] :: Query -> Maybe Int

-- | Optionally constrain the results to satisfy some predicate.
[_qWhere] :: Query -> Maybe Expression

-- | Optionally order the results by the value of one or more fields.
[_qOrderBy] :: Query -> Maybe OrderBy
memptyToNothing :: (Monoid m, Eq m) => m -> Maybe m

-- | The specific fields that are targeted by a <a>Query</a>.
--   
--   A field conceptually falls under one of the two following categories:
--   1. a "column" within the data store that the query is being issued
--   against 2. a "relationship", which indicates that the field is the
--   result of another query that must be executed on its own NOTE: The
--   <a>ToJSON</a> instance is only intended for logging purposes.
data Field
ColumnField :: Name -> Field
RelField :: RelationshipField -> Field

-- | A relationship consists of the following components: - a sub-query,
--   from the perspective that a relationship field will occur within a
--   broader <a>Query</a> - a join condition relating the data returned by
--   the sub-query with that of the broader <a>Query</a>
--   
--   cf. <a>https://en.wikipedia.org/wiki/Join_(SQL)</a>
--   <a>https://www.postgresql.org/docs/13/tutorial-join.html</a>
--   <a>https://www.postgresql.org/docs/13/queries-table-expressions.html#QUERIES-FROM</a>
--   
--   NOTE: The <a>ToJSON</a> instance is only intended for logging
--   purposes.
data RelationshipField
RelationshipField :: RelationshipName -> Query -> RelationshipField
[_rfRelationship] :: RelationshipField -> RelationshipName
[_rfQuery] :: RelationshipField -> Query
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Query.Field
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Query.Field
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Query.Field
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Query.Field
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Query.Field
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Query.Query
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Query.Query
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Query.Query
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Query.Query
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Query.Query
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Query.RelationshipField
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Query.RelationshipField
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Query.RelationshipField
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Query.RelationshipField
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Query.RelationshipField
instance GHC.Show.Show Hasura.Backends.DataConnector.IR.Query.QueryRequest
instance GHC.Classes.Ord Hasura.Backends.DataConnector.IR.Query.QueryRequest
instance GHC.Generics.Generic Hasura.Backends.DataConnector.IR.Query.QueryRequest
instance GHC.Classes.Eq Hasura.Backends.DataConnector.IR.Query.QueryRequest
instance Data.Data.Data Hasura.Backends.DataConnector.IR.Query.QueryRequest
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Query.QueryRequest
instance Witch.From.From Hasura.Backends.DataConnector.IR.Query.QueryRequest Hasura.Backends.DataConnector.API.V0.Query.QueryRequest
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Query.Query
instance Witch.From.From Hasura.Backends.DataConnector.IR.Query.Query Hasura.Backends.DataConnector.API.V0.Query.Query
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Query.Field
instance Witch.From.From Hasura.Backends.DataConnector.IR.Query.Field Hasura.Backends.DataConnector.API.V0.Query.Field
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.IR.Query.RelationshipField
instance Witch.From.From Hasura.Backends.DataConnector.IR.Query.RelationshipField Hasura.Backends.DataConnector.API.V0.Query.RelationshipField

module Hasura.Backends.DataConnector.Adapter.Types
data ConnSourceConfig
ConnSourceConfig :: Config -> Maybe Text -> Maybe SourceTimeout -> ConnSourceConfig

-- | An arbitrary JSON payload to be passed to the agent in a header. HGE
--   validates this against the OpenAPI Spec provided by the agent.
[value] :: ConnSourceConfig -> Config

-- | Kriti Template for transforming the supplied <a>Config</a> value.
[template] :: ConnSourceConfig -> Maybe Text

-- | Timeout setting for HTTP requests to the agent. -- TODO: verify with
--   lyndon
[timeout] :: ConnSourceConfig -> Maybe SourceTimeout
data SourceTimeout
SourceTimeoutSeconds :: Int -> SourceTimeout
SourceTimeoutMilliseconds :: Int -> SourceTimeout
SourceTimeoutMicroseconds :: Int -> SourceTimeout
sourceTimeoutMicroseconds :: SourceTimeout -> Int
data SourceConfig
SourceConfig :: BaseUrl -> Config -> Maybe Text -> Capabilities -> SchemaResponse -> Manager -> Maybe Int -> DataConnectorName -> SourceConfig
[_scEndpoint] :: SourceConfig -> BaseUrl
[_scConfig] :: SourceConfig -> Config
[_scTemplate] :: SourceConfig -> Maybe Text
[_scCapabilities] :: SourceConfig -> Capabilities
[_scSchema] :: SourceConfig -> SchemaResponse
[_scManager] :: SourceConfig -> Manager
[_scTimeoutMicroseconds] :: SourceConfig -> Maybe Int
[_scDataConnectorName] :: SourceConfig -> DataConnectorName
newtype DataConnectorName
DataConnectorName :: NonEmptyText -> DataConnectorName
[unDataConnectorName] :: DataConnectorName -> NonEmptyText
data DataConnectorOptions
DataConnectorOptions :: BaseUrl -> DataConnectorOptions
[_dcoUri] :: DataConnectorOptions -> BaseUrl
data CountType
StarCount :: CountType
ColumnCount :: NonEmpty Name -> CountType
ColumnDistinctCount :: NonEmpty Name -> CountType
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance Data.Data.Data Hasura.Backends.DataConnector.Adapter.Types.CountType
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.CountType
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.CountType
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.CountType
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.CountType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.DataConnectorName Data.Text.NonEmpty.NonEmptyText
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout

module Hasura.SQL.Backend

-- | Argument to Postgres; we represent backends which are variations on
--   Postgres as sub-types of Postgres. This value indicates which
--   "flavour" of Postgres a backend is.
data PostgresKind
Vanilla :: PostgresKind
Citus :: PostgresKind
Cockroach :: PostgresKind

-- | An enum that represents each backend we support.
data BackendType
Postgres :: PostgresKind -> BackendType
MSSQL :: BackendType
BigQuery :: BackendType
MySQL :: BackendType
DataConnector :: BackendType

-- | Similar to <a>BackendType</a>, however, in the case of
--   <a>DataConnectorKind</a> we need to be able capture the name of the
--   data connector that should be used by the DataConnector backend. This
--   type correlates to the kind property of <tt>SourceMetadata</tt>, which
--   is usually just postgres, mssql, etc for static backends, but can be a
--   configurable value for DataConnector hence requiring
--   <a>DataConnectorName</a> for <a>DataConnectorKind</a>
--   
--   This type cannot entirely replace <a>BackendType</a> because
--   <a>BackendType</a> has a fixed number of possible values which can be
--   enumerated over at compile time, but <a>BackendSourceKind</a> does not
--   because DataConnector fundamentally is configured at runtime with
--   <a>DataConnectorName</a>.
data BackendSourceKind (b :: BackendType)
[PostgresVanillaKind] :: BackendSourceKind ('Postgres 'Vanilla)
[PostgresCitusKind] :: BackendSourceKind ('Postgres 'Citus)
[PostgresCockroachKind] :: BackendSourceKind ('Postgres 'Cockroach)
[MSSQLKind] :: BackendSourceKind 'MSSQL
[BigQueryKind] :: BackendSourceKind 'BigQuery
[MySQLKind] :: BackendSourceKind 'MySQL
[DataConnectorKind] :: DataConnectorName -> BackendSourceKind 'DataConnector
mkParseStaticBackendSourceKind :: BackendSourceKind b -> Value -> Parser (BackendSourceKind b)

-- | Some generated APIs use a shortened version of the backend's name
--   rather than its full name. This function returns the "short form" of a
--   backend, if any.
backendShortName :: BackendType -> Maybe Text
supportedBackends :: [BackendType]
backendTextNames :: BackendType -> [Text]
backendTextNameLookup :: [(Text, BackendType)]

-- | This uses this lookup mechanism to avoid having to duplicate and
--   hardcode the backend string. We accept both the short form and the
--   long form of the backend's name.
backendTypeFromText :: Text -> Maybe BackendType
parseBackendTypeFromText :: Text -> Parser BackendType
backendTypeFromBackendSourceKind :: BackendSourceKind b -> BackendType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.SQL.Backend.PostgresKind
instance Data.Hashable.Class.Hashable Hasura.SQL.Backend.PostgresKind
instance GHC.Generics.Generic Hasura.SQL.Backend.PostgresKind
instance GHC.Classes.Ord Hasura.SQL.Backend.PostgresKind
instance GHC.Classes.Eq Hasura.SQL.Backend.PostgresKind
instance GHC.Show.Show Hasura.SQL.Backend.PostgresKind
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.SQL.Backend.BackendType
instance Data.Hashable.Class.Hashable Hasura.SQL.Backend.BackendType
instance GHC.Generics.Generic Hasura.SQL.Backend.BackendType
instance GHC.Classes.Ord Hasura.SQL.Backend.BackendType
instance GHC.Classes.Eq Hasura.SQL.Backend.BackendType
instance GHC.Show.Show Hasura.SQL.Backend.BackendType
instance GHC.Show.Show (Hasura.SQL.Backend.BackendSourceKind b)
instance GHC.Classes.Eq (Hasura.SQL.Backend.BackendSourceKind b)
instance GHC.Classes.Ord (Hasura.SQL.Backend.BackendSourceKind b)
instance Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.SQL.Backend.BackendSourceKind b)
instance Witch.From.From (Hasura.SQL.Backend.BackendSourceKind b) Data.Text.NonEmpty.NonEmptyText
instance Data.Text.Extended.ToTxt (Hasura.SQL.Backend.BackendSourceKind b)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.SQL.Backend.BackendSourceKind b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.Backend.BackendSourceKind ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Vanilla))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.Backend.BackendSourceKind ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Citus))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.Backend.BackendSourceKind ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Cockroach))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.Backend.BackendSourceKind 'Hasura.SQL.Backend.MSSQL)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.Backend.BackendSourceKind 'Hasura.SQL.Backend.BigQuery)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.Backend.BackendSourceKind 'Hasura.SQL.Backend.MySQL)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.Backend.BackendSourceKind 'Hasura.SQL.Backend.DataConnector)
instance Witch.From.From Hasura.SQL.Backend.BackendType Data.Text.NonEmpty.NonEmptyText
instance Data.Text.Extended.ToTxt Hasura.SQL.Backend.BackendType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.Backend.BackendType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.Backend.BackendType
instance Hasura.Incremental.Internal.Dependency.Cacheable (Data.Proxy.Proxy b)

module Hasura.Server.Migrate.Version

-- | Represents the catalog version. This is stored in the database and
--   then compared with the latest version on startup.
data MetadataCatalogVersion

-- | A typical catalog version.
MetadataCatalogVersion :: Int -> MetadataCatalogVersion

-- | Maintained for compatibility with catalog version 0.8.
MetadataCatalogVersion08 :: MetadataCatalogVersion

-- | This is the source catalog version, used when deciding whether to
--   (re-)create event triggers.
newtype SourceCatalogVersion (backend :: BackendType)
SourceCatalogVersion :: Int -> SourceCatalogVersion (backend :: BackendType)
instance Language.Haskell.TH.Syntax.Lift Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Classes.Eq Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance Language.Haskell.TH.Syntax.Lift (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Read.Read (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Show.Show (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Enum.Enum (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Classes.Eq (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Classes.Ord Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Enum.Enum Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Show.Show Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Read.Read Hasura.Server.Migrate.Version.MetadataCatalogVersion


-- | A module that defines the current catalog version and nothing else.
--   This is necessary to circumvent the unfortunate “GHC stage
--   restriction,” which prevents us from using a binding in a compile-time
--   splice unless it is defined in a different module. The actual
--   migration code is in <a>Hasura.Server.Migrate</a>.
module Hasura.Server.Migrate.LatestVersion

-- | The current catalog schema version. We store this in a file because we
--   want to append the current verson to the catalog_versions file when
--   tagging a new release, in <tt>tag-release.sh</tt>.
latestCatalogVersion :: MetadataCatalogVersion
latestCatalogVersionString :: Text

module Hasura.SQL.Tag

-- | A singleton-like GADT that associates a tag to each backend.
data BackendTag (b :: BackendType)
[PostgresVanillaTag] :: BackendTag ('Postgres 'Vanilla)
[PostgresCitusTag] :: BackendTag ('Postgres 'Citus)
[PostgresCockroachTag] :: BackendTag ('Postgres 'Cockroach)
[MSSQLTag] :: BackendTag 'MSSQL
[BigQueryTag] :: BackendTag 'BigQuery
[MySQLTag] :: BackendTag 'MySQL
[DataConnectorTag] :: BackendTag 'DataConnector

-- | This class describes how to get a tag for a given type. We use it in
--   AnyBackend: `case backendTag @b of`...
class HasTag (b :: BackendType)
backendTag :: HasTag b => BackendTag b

-- | How to convert back from a tag to a runtime value.
reify :: BackendTag b -> BackendType
instance Hasura.SQL.Tag.HasTag ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Vanilla)
instance Hasura.SQL.Tag.HasTag ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Citus)
instance Hasura.SQL.Tag.HasTag ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Cockroach)
instance Hasura.SQL.Tag.HasTag 'Hasura.SQL.Backend.MSSQL
instance Hasura.SQL.Tag.HasTag 'Hasura.SQL.Backend.BigQuery
instance Hasura.SQL.Tag.HasTag 'Hasura.SQL.Backend.MySQL
instance Hasura.SQL.Tag.HasTag 'Hasura.SQL.Backend.DataConnector

module Hasura.RQL.Types.Backend
type Representable a = (Show a, Eq a, Hashable a, Cacheable a, NFData a)
type SessionVarType b = CollectableType (ScalarType b)
data ComputedFieldReturnType (b :: BackendType)
ReturnsScalar :: ScalarType b -> ComputedFieldReturnType (b :: BackendType)
ReturnsTable :: TableName b -> ComputedFieldReturnType (b :: BackendType)
ReturnsOthers :: ComputedFieldReturnType (b :: BackendType)
type XEnable = ()
type XDisable = Void

-- | Used for keeping track of the extent of support of naming convention
--   across different backends.
--   
--   <tt>AllConventions</tt> implies a full support whereas
--   <tt>OnlyHasuraCase</tt> implies a partial support of only
--   <tt>HasuraCase</tt>
data SupportedNamingCase
OnlyHasuraCase :: SupportedNamingCase
AllConventions :: SupportedNamingCase

-- | Mapping from abstract types to concrete backend representation
--   
--   The RQL IR, used as the output of GraphQL parsers and of the RQL
--   parsers, is backend-agnostic: it uses an abstract representation of
--   the structure of a query, and delegates to the backends the task of
--   choosing an appropriate concrete representation.
--   
--   Additionally, grouping all those types under one typeclass rather than
--   having dedicated type families allows to explicitly list all typeclass
--   requirements, which simplifies the instance declarations of all IR
--   types.
--   
--   There are no injectivity requirements on those type families: it's
--   okay for two different backends to use the same types. That means,
--   however, that functions cannot identify to what backend b a given
--   <tt>TableName b</tt> refers to; most generic functions will need
--   either a type application or a <tt>Proxy</tt> parameter to
--   disambiguate between different backends at the call site.
class (Representable (TableName b), Representable (FunctionName b), Representable (FunctionArgument b), Representable (ConstraintName b), Representable (BasicOrderType b), Representable (NullsOrderType b), Representable (Column b), Representable (ScalarType b), Representable (SQLExpression b), Representable (ScalarSelectionArguments b), Representable (SourceConnConfiguration b), Representable (ExtraTableMetadata b), Representable (XComputedField b), Representable (ComputedFieldDefinition b), Representable (ComputedFieldImplicitArguments b), Representable (ComputedFieldReturn b), Ord (TableName b), Ord (FunctionName b), Ord (ScalarType b), Data (TableName b), FromJSON (BackendConfig b), FromJSON (Column b), FromJSON (ConstraintName b), FromJSON (FunctionName b), FromJSON (ScalarType b), FromJSON (TableName b), FromJSON (SourceConnConfiguration b), FromJSON (ExtraTableMetadata b), FromJSON (ComputedFieldDefinition b), FromJSON (BackendSourceKind b), FromJSONKey (Column b), ToJSON (BackendConfig b), ToJSON (Column b), ToJSON (ConstraintName b), ToJSON (FunctionArgument b), ToJSON (FunctionName b), ToJSON (ScalarType b), ToJSON (SourceConfig b), ToJSON (TableName b), ToJSON (SourceConnConfiguration b), ToJSON (ExtraTableMetadata b), ToJSON (SQLExpression b), ToJSON (ComputedFieldDefinition b), ToJSON (ComputedFieldImplicitArguments b), ToJSON (ComputedFieldReturn b), ToJSONKey (Column b), ToJSONKey (FunctionName b), ToJSONKey (ScalarType b), ToJSONKey (TableName b), ToTxt (Column b), ToTxt (FunctionName b), ToTxt (ScalarType b), ToTxt (TableName b), ToTxt (ConstraintName b), ToErrorValue (Column b), ToErrorValue (FunctionName b), ToErrorValue (ScalarType b), ToErrorValue (TableName b), ToErrorValue (ConstraintName b), Cacheable (SourceConfig b), Cacheable (BackendConfig b), Typeable (TableName b), Typeable (ConstraintName b), Typeable b, HasTag b, Functor (FunctionArgumentExp b), Foldable (FunctionArgumentExp b), Traversable (FunctionArgumentExp b), Eq (BackendConfig b), Show (BackendConfig b), Monoid (BackendConfig b), Eq (CountType b), Show (CountType b), Eq (ScalarValue b), Show (ScalarValue b), Eq (XNodesAgg b), Show (XNodesAgg b), Eq (XRelay b), Show (XRelay b), Eq (XStreamingSubscription b), Show (XStreamingSubscription b), Traversable (BooleanOperators b), Functor (BackendUpdate b), Foldable (BackendUpdate b), Traversable (BackendUpdate b), Functor (BackendInsert b), Foldable (BackendInsert b), Traversable (BackendInsert b), Functor (AggregationPredicates b), Foldable (AggregationPredicates b), Traversable (AggregationPredicates b)) => Backend (b :: BackendType) where {
    type family BackendConfig b :: Type;
    
    -- | User facing connection configuration for a database.
    type family SourceConnConfiguration b :: Type;
    
    -- | Internal connection configuration for a database - connection string,
    --   connection pool etc
    type family SourceConfig b :: Type;
    type family TableName b :: Type;
    type family FunctionName b :: Type;
    type family RawFunctionInfo b :: Type;
    type family ConstraintName b :: Type;
    type family BasicOrderType b :: Type;
    type family NullsOrderType b :: Type;
    type family CountType b :: Type;
    type family Column b :: Type;
    type family ScalarValue b :: Type;
    type family ScalarType b :: Type;
    type family SQLExpression b :: Type;
    type family ComputedFieldDefinition b :: Type;
    
    -- | Arguments of a scalar field's selection { query { some_table { # a
    --   scalar field column(ScalarSelectionArguments) } } }
    type family ScalarSelectionArguments b :: Type;
    type family ExtraTableMetadata b :: Type;
    
    -- | FunctionArgument
    type family FunctionArgument b :: Type;
    
    -- | Function input argument expression
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type family FunctionArgumentExp b :: Type -> Type;
    
    -- | Computed field function argument values which are being implicitly
    --   inferred from table and/or session information
    type family ComputedFieldImplicitArguments b :: Type;
    
    -- | Computed field return information
    type family ComputedFieldReturn b :: Type;
    
    -- | Intermediate Representation of extensions to the shared set of boolean
    --   operators on table fields.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type family BooleanOperators b :: Type -> Type;
    
    -- | Intermediate Representation of aggregation predicates. The default
    --   implementation makes aggregation predicates uninstantiable.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type family AggregationPredicates b :: Type -> Type;
    
    -- | Intermediate Representation of Update Mutations. The default
    --   implementation makes update expressions uninstantiable.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type family BackendUpdate b :: Type -> Type;
    
    -- | Intermediate Representation of Insert Mutations. The default
    --   implementation makes insert expressions uninstantiable.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type family BackendInsert b :: Type -> Type;
    type family XComputedField b :: Type;
    type family XRelay b :: Type;
    type family XNodesAgg b :: Type;
    
    -- | Extension to flag the availability of object and array relationships
    --   in inserts (aka nested inserts).
    type family XNestedInserts b :: Type;
    type family XStreamingSubscription b :: Type;
    type AggregationPredicates b = Const Void;
    type BackendUpdate b = Const Void;
    type BackendInsert b = Const Void;
}
isComparableType :: Backend b => ScalarType b -> Bool
isNumType :: Backend b => ScalarType b -> Bool
textToScalarValue :: Backend b => Maybe Text -> ScalarValue b
parseScalarValue :: Backend b => ScalarType b -> Value -> Either QErr (ScalarValue b)
scalarValueToJSON :: Backend b => ScalarValue b -> Value
functionToTable :: Backend b => FunctionName b -> TableName b
tableToFunction :: Backend b => TableName b -> FunctionName b
computedFieldFunction :: Backend b => ComputedFieldDefinition b -> FunctionName b
computedFieldReturnType :: Backend b => ComputedFieldReturn b -> ComputedFieldReturnType b

-- | Build function arguments expression from computed field implicit
--   arguments
fromComputedFieldImplicitArguments :: Backend b => v -> ComputedFieldImplicitArguments b -> [FunctionArgumentExp b v]
tableGraphQLName :: Backend b => TableName b -> Either QErr Name
functionGraphQLName :: Backend b => FunctionName b -> Either QErr Name
getTableIdentifier :: Backend b => TableName b -> Either QErr GQLNameIdentifier
snakeCaseTableName :: Backend b => TableName b -> Text
namingConventionSupport :: Backend b => SupportedNamingCase
_ReturnsOthers :: forall b_a7KAV. Prism' (ComputedFieldReturnType b_a7KAV) ()
_ReturnsTable :: forall b_a7KAV. Prism' (ComputedFieldReturnType b_a7KAV) (TableName b_a7KAV)
_ReturnsScalar :: forall b_a7KAV. Prism' (ComputedFieldReturnType b_a7KAV) (ScalarType b_a7KAV)

module Hasura.RQL.Types.Relationships.Local
data RelDef a
RelDef :: RelName -> a -> Maybe Text -> RelDef a
[_rdName] :: RelDef a -> RelName
[_rdUsing] :: RelDef a -> a
[_rdComment] :: RelDef a -> Maybe Text
rdUsing :: forall a_a7U0A a_a7U7B. Lens (RelDef a_a7U0A) (RelDef a_a7U7B) a_a7U0A a_a7U7B
rdName :: forall a_a7U0A. Lens' (RelDef a_a7U0A) RelName
rdComment :: forall a_a7U0A. Lens' (RelDef a_a7U0A) (Maybe Text)
data RelManualConfig (b :: BackendType)
RelManualConfig :: TableName b -> HashMap (Column b) (Column b) -> Maybe InsertOrder -> RelManualConfig (b :: BackendType)
[rmTable] :: RelManualConfig (b :: BackendType) -> TableName b
[rmColumns] :: RelManualConfig (b :: BackendType) -> HashMap (Column b) (Column b)
[rmInsertOrder] :: RelManualConfig (b :: BackendType) -> Maybe InsertOrder
data RelUsing (b :: BackendType) a
RUFKeyOn :: a -> RelUsing (b :: BackendType) a
RUManual :: RelManualConfig b -> RelUsing (b :: BackendType) a
data ArrRelUsingFKeyOn (b :: BackendType)
ArrRelUsingFKeyOn :: TableName b -> NonEmpty (Column b) -> ArrRelUsingFKeyOn (b :: BackendType)
[arufTable] :: ArrRelUsingFKeyOn (b :: BackendType) -> TableName b
[arufColumns] :: ArrRelUsingFKeyOn (b :: BackendType) -> NonEmpty (Column b)
data WithTable b a
WithTable :: SourceName -> TableName b -> a -> WithTable b a
[wtSource] :: WithTable b a -> SourceName
[wtName] :: WithTable b a -> TableName b
[wtInfo] :: WithTable b a -> a
data ObjRelUsingChoice b
SameTable :: NonEmpty (Column b) -> ObjRelUsingChoice b
RemoteTable :: TableName b -> NonEmpty (Column b) -> ObjRelUsingChoice b
type ArrRelUsing b = RelUsing b (ArrRelUsingFKeyOn b)
type ArrRelDef b = RelDef (ArrRelUsing b)
type ObjRelUsing b = RelUsing b (ObjRelUsingChoice b)
type ObjRelDef b = RelDef (ObjRelUsing b)
data RelInfo (b :: BackendType)
RelInfo :: RelName -> RelType -> HashMap (Column b) (Column b) -> TableName b -> Bool -> InsertOrder -> RelInfo (b :: BackendType)
[riName] :: RelInfo (b :: BackendType) -> RelName
[riType] :: RelInfo (b :: BackendType) -> RelType
[riMapping] :: RelInfo (b :: BackendType) -> HashMap (Column b) (Column b)
[riRTable] :: RelInfo (b :: BackendType) -> TableName b
[riIsManual] :: RelInfo (b :: BackendType) -> Bool
[riInsertOrder] :: RelInfo (b :: BackendType) -> InsertOrder
data Nullable
Nullable :: Nullable
NotNullable :: Nullable
boolToNullable :: Bool -> Nullable
fromRel :: RelName -> FieldName
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.Local.Nullable
instance GHC.Show.Show Hasura.RQL.Types.Relationships.Local.Nullable
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Local.Nullable
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.WithTable b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.WithTable b a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Relationships.Local.Nullable
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.Local.Nullable
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Relationships.Local.Nullable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.Local.Nullable
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.Local.Nullable
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance (Data.Aeson.Types.FromJSON.FromJSON a, Hasura.RQL.Types.Backend.Backend b) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.WithTable b a)
instance (Hasura.RQL.Types.Common.ToAesonPairs a, Hasura.RQL.Types.Backend.Backend b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.WithTable b a)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable a) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Data.Aeson.Types.FromJSON.FromJSON a, Hasura.RQL.Types.Backend.Backend b) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Hasura.RQL.Types.Common.ToAesonPairs (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Relationships.Local.RelDef a)

module Hasura.RQL.Types.Function

-- | <a>https://www.postgresql.org/docs/current/xfunc-volatility.html</a>
data FunctionVolatility
FTVOLATILE :: FunctionVolatility
FTIMMUTABLE :: FunctionVolatility
FTSTABLE :: FunctionVolatility
funcTypToTxt :: FunctionVolatility -> Text
newtype FunctionArgName
FunctionArgName :: Text -> FunctionArgName
[getFuncArgNameTxt] :: FunctionArgName -> Text
data InputArgument a
IAUserProvided :: a -> InputArgument a
IASessionVariables :: FunctionArgName -> InputArgument a
_IASessionVariables :: forall a_a893J. Prism' (InputArgument a_a893J) FunctionArgName
_IAUserProvided :: forall a_a89vK a_a893J. Prism (InputArgument a_a89vK) (InputArgument a_a893J) a_a89vK a_a893J
type FunctionInputArgument b = InputArgument (FunctionArgument b)

-- | Indicates whether the user requested the corresponding function to be
--   tracked as a mutation or a query/subscription, in
--   <tt>track_function</tt>.
data FunctionExposedAs
FEAQuery :: FunctionExposedAs
FEAMutation :: FunctionExposedAs
newtype FunctionPermissionInfo
FunctionPermissionInfo :: RoleName -> FunctionPermissionInfo
[_fpmRole] :: FunctionPermissionInfo -> RoleName
fpmRole :: Iso' FunctionPermissionInfo RoleName
type FunctionPermissionsMap = HashMap RoleName FunctionPermissionInfo

-- | Custom root fields for functions. When set, will be the names exposed
--   to the user in the schema.
--   
--   See rfcs/function-root-field-customisation.md for more information.
data FunctionCustomRootFields
FunctionCustomRootFields :: Maybe Name -> Maybe Name -> FunctionCustomRootFields
[_fcrfFunction] :: FunctionCustomRootFields -> Maybe Name
[_fcrfFunctionAggregate] :: FunctionCustomRootFields -> Maybe Name

-- | A function custom root fields without custom names set. This is the
--   default.
emptyFunctionCustomRootFields :: FunctionCustomRootFields

-- | Tracked SQL function metadata. See <tt>buildFunctionInfo</tt>.
data FunctionInfo (b :: BackendType)
FunctionInfo :: FunctionName b -> Name -> Name -> Name -> SystemDefined -> FunctionVolatility -> FunctionExposedAs -> Seq (FunctionInputArgument b) -> TableName b -> Maybe Text -> FunctionPermissionsMap -> JsonAggSelect -> Maybe Text -> FunctionInfo (b :: BackendType)
[_fiSQLName] :: FunctionInfo (b :: BackendType) -> FunctionName b
[_fiGQLName] :: FunctionInfo (b :: BackendType) -> Name
[_fiGQLArgsName] :: FunctionInfo (b :: BackendType) -> Name
[_fiGQLAggregateName] :: FunctionInfo (b :: BackendType) -> Name
[_fiSystemDefined] :: FunctionInfo (b :: BackendType) -> SystemDefined
[_fiVolatility] :: FunctionInfo (b :: BackendType) -> FunctionVolatility

-- | In which part of the schema should this function be exposed?
--   
--   See <tt>mkFunctionInfo</tt> and <a>_fcExposedAs</a>.
[_fiExposedAs] :: FunctionInfo (b :: BackendType) -> FunctionExposedAs
[_fiInputArgs] :: FunctionInfo (b :: BackendType) -> Seq (FunctionInputArgument b)

-- | NOTE: when a table is created, a new composite type of the same name
--   is automatically created; so strictly speaking this field means "the
--   function returns the composite type corresponding to this table".
[_fiReturnType] :: FunctionInfo (b :: BackendType) -> TableName b

-- | this field represents the description of the function as present on
--   the database
[_fiDescription] :: FunctionInfo (b :: BackendType) -> Maybe Text

-- | Roles to which the function is accessible
[_fiPermissions] :: FunctionInfo (b :: BackendType) -> FunctionPermissionsMap
[_fiJsonAggSelect] :: FunctionInfo (b :: BackendType) -> JsonAggSelect
[_fiComment] :: FunctionInfo (b :: BackendType) -> Maybe Text
fiVolatility :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) FunctionVolatility
fiSystemDefined :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) SystemDefined
fiSQLName :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) (FunctionName b_a89MU)
fiReturnType :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) (TableName b_a89MU)
fiPermissions :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) FunctionPermissionsMap
fiJsonAggSelect :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) JsonAggSelect
fiInputArgs :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) (Seq (FunctionInputArgument b_a89MU))
fiGQLName :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) Name
fiGQLArgsName :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) Name
fiGQLAggregateName :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) Name
fiExposedAs :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) FunctionExposedAs
fiDescription :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) (Maybe Text)
fiComment :: forall b_a89MU. Lens' (FunctionInfo b_a89MU) (Maybe Text)

-- | Apply function name customization to function arguments, as detailed
--   in 'rfcs/function-root-field-customisation.md'. We want the different
--   variations of a function (i.e. basic, aggregate) to share the same
--   type name for their arguments.
getFunctionArgsGQLName :: Name -> FunctionConfig -> (Name -> Name) -> Name

-- | Apply function name customization to the basic function variation, as
--   detailed in 'rfcs/function-root-field-customisation.md'.
getFunctionGQLName :: Name -> FunctionConfig -> (Name -> Name) -> Name

-- | Apply function name customization to the aggregate function variation,
--   as detailed in 'rfcs/function-root-field-customisation.md'.
getFunctionAggregateGQLName :: Name -> FunctionConfig -> (Name -> Name) -> Name
getInputArgs :: FunctionInfo b -> Seq (FunctionArgument b)
type FunctionCache b = HashMap (FunctionName b) (FunctionInfo b)

-- | Tracked function configuration, and payload of the
--   <tt>pg_track_function</tt> and <tt>pg_set_function_customization</tt>
--   API calls.
data FunctionConfig
FunctionConfig :: Maybe FunctionArgName -> Maybe FunctionExposedAs -> FunctionCustomRootFields -> Maybe Name -> FunctionConfig
[_fcSessionArgument] :: FunctionConfig -> Maybe FunctionArgName

-- | In which top-level field should we expose this function?
--   
--   The user might omit this, in which case we'll infer the location from
--   the SQL functions volatility. See <tt>mkFunctionInfo</tt> or the
--   <tt>track_function</tt> API docs for details of validation, etc.
[_fcExposedAs] :: FunctionConfig -> Maybe FunctionExposedAs
[_fcCustomRootFields] :: FunctionConfig -> FunctionCustomRootFields
[_fcCustomName] :: FunctionConfig -> Maybe Name

-- | The default function config; v1 of the API implies this.
emptyFunctionConfig :: FunctionConfig
type DBFunctionsMetadata b = HashMap (FunctionName b) [RawFunctionInfo b]
data FunctionArgsExpG a
FunctionArgsExp :: [a] -> HashMap Text a -> FunctionArgsExpG a
[_faePositional] :: FunctionArgsExpG a -> [a]
[_faeNamed] :: FunctionArgsExpG a -> HashMap Text a
type FunctionArgsExp b v = FunctionArgsExpG (FunctionArgumentExp b v)
emptyFunctionArgsExp :: FunctionArgsExpG a
instance GHC.Generics.Generic (Hasura.RQL.Types.Function.FunctionArgsExpG a)
instance Data.Traversable.Traversable Hasura.RQL.Types.Function.FunctionArgsExpG
instance Data.Foldable.Foldable Hasura.RQL.Types.Function.FunctionArgsExpG
instance GHC.Base.Functor Hasura.RQL.Types.Function.FunctionArgsExpG
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Function.FunctionArgsExpG a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.Function.FunctionArgsExpG a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Function.FunctionArgsExpG a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Function.FunctionArgsExpG a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.Types.Function.FunctionArgsExpG a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Function.FunctionConfig
instance GHC.Generics.Generic Hasura.RQL.Types.Function.FunctionConfig
instance GHC.Classes.Eq Hasura.RQL.Types.Function.FunctionConfig
instance GHC.Show.Show Hasura.RQL.Types.Function.FunctionConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.Function.FunctionConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Function.FunctionConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Function.FunctionConfig
instance GHC.Generics.Generic (Hasura.RQL.Types.Function.FunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Function.FunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Function.FunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Function.FunctionInfo b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Function.FunctionCustomRootFields
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Function.FunctionCustomRootFields
instance GHC.Generics.Generic Hasura.RQL.Types.Function.FunctionCustomRootFields
instance GHC.Classes.Eq Hasura.RQL.Types.Function.FunctionCustomRootFields
instance GHC.Show.Show Hasura.RQL.Types.Function.FunctionCustomRootFields
instance Control.DeepSeq.NFData Hasura.RQL.Types.Function.FunctionCustomRootFields
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Function.FunctionCustomRootFields
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Function.FunctionPermissionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Function.FunctionPermissionInfo
instance GHC.Generics.Generic Hasura.RQL.Types.Function.FunctionPermissionInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Function.FunctionPermissionInfo
instance GHC.Show.Show Hasura.RQL.Types.Function.FunctionPermissionInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Function.FunctionPermissionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Function.FunctionExposedAs
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Function.FunctionExposedAs
instance GHC.Generics.Generic Hasura.RQL.Types.Function.FunctionExposedAs
instance GHC.Classes.Eq Hasura.RQL.Types.Function.FunctionExposedAs
instance GHC.Show.Show Hasura.RQL.Types.Function.FunctionExposedAs
instance Control.DeepSeq.NFData Hasura.RQL.Types.Function.FunctionExposedAs
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Function.FunctionExposedAs
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Function.InputArgument a)
instance Data.Data.Data Hasura.RQL.Types.Function.FunctionArgName
instance Language.Haskell.TH.Syntax.Lift Hasura.RQL.Types.Function.FunctionArgName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Function.FunctionArgName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Function.FunctionArgName
instance GHC.Generics.Generic Hasura.RQL.Types.Function.FunctionArgName
instance Data.String.IsString Hasura.RQL.Types.Function.FunctionArgName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Function.FunctionArgName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Function.FunctionArgName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Function.FunctionArgName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Function.FunctionArgName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Function.FunctionArgName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Function.FunctionArgName
instance GHC.Classes.Ord Hasura.RQL.Types.Function.FunctionArgName
instance GHC.Classes.Eq Hasura.RQL.Types.Function.FunctionArgName
instance GHC.Show.Show Hasura.RQL.Types.Function.FunctionArgName
instance GHC.Base.Functor Hasura.RQL.Types.Function.InputArgument
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Function.InputArgument a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.Function.InputArgument a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Function.FunctionVolatility
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Function.FunctionVolatility
instance GHC.Show.Show Hasura.RQL.Types.Function.FunctionVolatility
instance GHC.Generics.Generic Hasura.RQL.Types.Function.FunctionVolatility
instance GHC.Classes.Eq Hasura.RQL.Types.Function.FunctionVolatility
instance Control.DeepSeq.NFData Hasura.RQL.Types.Function.FunctionVolatility
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Function.FunctionVolatility

module Hasura.RQL.Types.EventTrigger

-- | Unique name for event trigger.
newtype TriggerName
TriggerName :: NonEmptyText -> TriggerName
[unTriggerName] :: TriggerName -> NonEmptyText
triggerNameToTxt :: TriggerName -> Text
data Ops
INSERT :: Ops
UPDATE :: Ops
DELETE :: Ops
MANUAL :: Ops
data SubscribeColumns (b :: BackendType)
SubCStar :: SubscribeColumns (b :: BackendType)
SubCArray :: [Column b] -> SubscribeColumns (b :: BackendType)
data SubscribeOpSpec (b :: BackendType)
SubscribeOpSpec :: SubscribeColumns b -> Maybe (SubscribeColumns b) -> SubscribeOpSpec (b :: BackendType)

-- | Columns of the table that user can subscribe to listen for changes.
[sosColumns] :: SubscribeOpSpec (b :: BackendType) -> SubscribeColumns b

-- | Columns that the event trigger payload should consists. If set, only
--   those columns will be visible in the payload. By default, the payload
--   consists of all the columns of the table.
[sosPayload] :: SubscribeOpSpec (b :: BackendType) -> Maybe (SubscribeColumns b)
defaultNumRetries :: Int
defaultRetryInterval :: Int
defaultTimeoutSeconds :: Int
defaultRetryConf :: RetryConf
data RetryConf
RetryConf :: Int -> Int -> Maybe Int -> RetryConf
[rcNumRetries] :: RetryConf -> Int
[rcIntervalSec] :: RetryConf -> Int
[rcTimeoutSec] :: RetryConf -> Maybe Int
data EventHeaderInfo
EventHeaderInfo :: HeaderConf -> Text -> EventHeaderInfo
[ehiHeaderConf] :: EventHeaderInfo -> HeaderConf
[ehiCachedValue] :: EventHeaderInfo -> Text
data WebhookConf
WCValue :: InputWebhook -> WebhookConf
WCEnv :: Text -> WebhookConf
data WebhookConfInfo
WebhookConfInfo :: WebhookConf -> EnvRecord ResolvedWebhook -> WebhookConfInfo
[wciWebhookConf] :: WebhookConfInfo -> WebhookConf
[wciCachedValue] :: WebhookConfInfo -> EnvRecord ResolvedWebhook

-- | The table operations on which the event trigger will be invoked.
data TriggerOpsDef (b :: BackendType)
TriggerOpsDef :: Maybe (SubscribeOpSpec b) -> Maybe (SubscribeOpSpec b) -> Maybe (SubscribeOpSpec b) -> Maybe Bool -> TriggerOpsDef (b :: BackendType)
[tdInsert] :: TriggerOpsDef (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[tdUpdate] :: TriggerOpsDef (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[tdDelete] :: TriggerOpsDef (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[tdEnableManual] :: TriggerOpsDef (b :: BackendType) -> Maybe Bool
data EventTriggerConf (b :: BackendType)
EventTriggerConf :: TriggerName -> TriggerOpsDef b -> Maybe InputWebhook -> Maybe Text -> RetryConf -> Maybe [HeaderConf] -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> EventTriggerConf (b :: BackendType)
[etcName] :: EventTriggerConf (b :: BackendType) -> TriggerName
[etcDefinition] :: EventTriggerConf (b :: BackendType) -> TriggerOpsDef b
[etcWebhook] :: EventTriggerConf (b :: BackendType) -> Maybe InputWebhook
[etcWebhookFromEnv] :: EventTriggerConf (b :: BackendType) -> Maybe Text
[etcRetryConf] :: EventTriggerConf (b :: BackendType) -> RetryConf
[etcHeaders] :: EventTriggerConf (b :: BackendType) -> Maybe [HeaderConf]
[etcRequestTransform] :: EventTriggerConf (b :: BackendType) -> Maybe RequestTransform
[etcResponseTransform] :: EventTriggerConf (b :: BackendType) -> Maybe MetadataResponseTransform
data RecreateEventTriggers
RETRecreate :: RecreateEventTriggers
RETDoNothing :: RecreateEventTriggers
data TriggerMetadata
TriggerMetadata :: TriggerName -> TriggerMetadata
[tmName] :: TriggerMetadata -> TriggerName

-- | Change data for a particular row
--   
--   
--   <a>https://docs.hasura.io/1.0/graphql/manual/event-triggers/payload.html</a>
data Event (b :: BackendType)
Event :: EventId -> SourceName -> TableName b -> TriggerMetadata -> Value -> Int -> UTCTime -> Event (b :: BackendType)
[eId] :: Event (b :: BackendType) -> EventId
[eSource] :: Event (b :: BackendType) -> SourceName
[eTable] :: Event (b :: BackendType) -> TableName b
[eTrigger] :: Event (b :: BackendType) -> TriggerMetadata
[eEvent] :: Event (b :: BackendType) -> Value
[eTries] :: Event (b :: BackendType) -> Int
[eCreatedAt] :: Event (b :: BackendType) -> UTCTime

-- | The event payload processed by <tt>processEvent</tt>
data EventWithSource (b :: BackendType)
EventWithSource :: Event b -> SourceConfig b -> SourceName -> UTCTime -> EventWithSource (b :: BackendType)
[_ewsEvent] :: EventWithSource (b :: BackendType) -> Event b
[_ewsSourceConfig] :: EventWithSource (b :: BackendType) -> SourceConfig b
[_ewsSourceName] :: EventWithSource (b :: BackendType) -> SourceName

-- | The <a>UTCTime</a> represents the time when the event was fetched from
--   DB. ^ Used to calculate Event Lock time
[_ewsFetchTime] :: EventWithSource (b :: BackendType) -> UTCTime
data ProcessEventError
PESetRetry :: UTCTime -> ProcessEventError
PESetError :: ProcessEventError
data EventTriggerInfo (b :: BackendType)
EventTriggerInfo :: TriggerName -> TriggerOpsDef b -> RetryConf -> WebhookConfInfo -> [EventHeaderInfo] -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> EventTriggerInfo (b :: BackendType)
[etiName] :: EventTriggerInfo (b :: BackendType) -> TriggerName
[etiOpsDef] :: EventTriggerInfo (b :: BackendType) -> TriggerOpsDef b
[etiRetryConf] :: EventTriggerInfo (b :: BackendType) -> RetryConf

-- | The HTTP(s) URL which will be called with the event payload on
--   configured operation. Must be a POST handler. This URL can be entered
--   manually or can be picked up from an environment variable (the
--   environment variable needs to be set before using it for this
--   configuration).
[etiWebhookInfo] :: EventTriggerInfo (b :: BackendType) -> WebhookConfInfo

-- | Custom headers can be added to an event trigger. Each webhook request
--   will have these headers added.
[etiHeaders] :: EventTriggerInfo (b :: BackendType) -> [EventHeaderInfo]
[etiRequestTransform] :: EventTriggerInfo (b :: BackendType) -> Maybe RequestTransform
[etiResponseTransform] :: EventTriggerInfo (b :: BackendType) -> Maybe MetadataResponseTransform
type EventTriggerInfoMap b = HashMap TriggerName (EventTriggerInfo b)
newtype FetchBatchSize
FetchBatchSize :: Int -> FetchBatchSize
[_unFetchBatchSize] :: FetchBatchSize -> Int
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.Event b)
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.ProcessEventError
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.ProcessEventError
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.FetchBatchSize
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.FetchBatchSize
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.EventTrigger.Event b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.Event b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.Event b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance GHC.Base.Semigroup Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.WebhookConf
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.WebhookConf
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.WebhookConf
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.WebhookConf
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.EventTrigger.WebhookConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.WebhookConf
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.WebhookConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.RetryConf
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.RetryConf
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.EventTrigger.TriggerName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.EventTrigger.TriggerName
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.TriggerName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Classes.Ord Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.Ops
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.Ops
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.Ops
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.RetryConf
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.RetryConf
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.RetryConf
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.RetryConf
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.EventTrigger.RetryConf
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.EventTrigger.Ops


-- | These are types for Scheduled Trigger definition; see
--   <a>Hasura.Eventing.ScheduledTrigger</a>
module Hasura.RQL.Types.ScheduledTrigger
type CronEventId = EventId
type OneOffScheduledEventId = EventId
type ScheduledEventId = EventId
type InvocationId = Text
data STRetryConf
STRetryConf :: Int -> NonNegativeDiffTime -> NonNegativeDiffTime -> NonNegativeDiffTime -> STRetryConf
[strcNumRetries] :: STRetryConf -> Int
[strcRetryIntervalSeconds] :: STRetryConf -> NonNegativeDiffTime
[strcTimeoutSeconds] :: STRetryConf -> NonNegativeDiffTime

-- | The tolerance configuration is used to determine whether a scheduled
--   event is not too old to process. The age of the scheduled event is the
--   difference between the current timestamp and the scheduled event's
--   timestamp, if the age is than the tolerance then the scheduled event
--   is marked as dead.
[strcToleranceSeconds] :: STRetryConf -> NonNegativeDiffTime
defaultSTRetryConf :: STRetryConf
data CronTriggerMetadata
CronTriggerMetadata :: TriggerName -> InputWebhook -> CronSchedule -> Maybe Value -> STRetryConf -> [HeaderConf] -> Bool -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CronTriggerMetadata
[ctName] :: CronTriggerMetadata -> TriggerName
[ctWebhook] :: CronTriggerMetadata -> InputWebhook
[ctSchedule] :: CronTriggerMetadata -> CronSchedule
[ctPayload] :: CronTriggerMetadata -> Maybe Value
[ctRetryConf] :: CronTriggerMetadata -> STRetryConf
[ctHeaders] :: CronTriggerMetadata -> [HeaderConf]
[ctIncludeInMetadata] :: CronTriggerMetadata -> Bool
[ctComment] :: CronTriggerMetadata -> Maybe Text
[ctRequestTransform] :: CronTriggerMetadata -> Maybe RequestTransform
[ctResponseTransform] :: CronTriggerMetadata -> Maybe MetadataResponseTransform
data CreateCronTrigger
CreateCronTrigger :: TriggerName -> InputWebhook -> CronSchedule -> Maybe Value -> STRetryConf -> [HeaderConf] -> Bool -> Maybe Text -> Bool -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CreateCronTrigger
[_cctName] :: CreateCronTrigger -> TriggerName
[_cctWebhook] :: CreateCronTrigger -> InputWebhook
[_cctCronSchedule] :: CreateCronTrigger -> CronSchedule
[_cctPayload] :: CreateCronTrigger -> Maybe Value
[_cctRetryConf] :: CreateCronTrigger -> STRetryConf
[_cctHeaders] :: CreateCronTrigger -> [HeaderConf]
[_cctIncludeInMetadata] :: CreateCronTrigger -> Bool
[_cctComment] :: CreateCronTrigger -> Maybe Text
[_cctReplace] :: CreateCronTrigger -> Bool
[_cctRequestTransform] :: CreateCronTrigger -> Maybe RequestTransform
[_cctResponseTransform] :: CreateCronTrigger -> Maybe MetadataResponseTransform
cctWebhook :: Lens' CreateCronTrigger InputWebhook
cctRetryConf :: Lens' CreateCronTrigger STRetryConf
cctResponseTransform :: Lens' CreateCronTrigger (Maybe MetadataResponseTransform)
cctRequestTransform :: Lens' CreateCronTrigger (Maybe RequestTransform)
cctReplace :: Lens' CreateCronTrigger Bool
cctPayload :: Lens' CreateCronTrigger (Maybe Value)
cctName :: Lens' CreateCronTrigger TriggerName
cctIncludeInMetadata :: Lens' CreateCronTrigger Bool
cctHeaders :: Lens' CreateCronTrigger [HeaderConf]
cctCronSchedule :: Lens' CreateCronTrigger CronSchedule
cctComment :: Lens' CreateCronTrigger (Maybe Text)
newtype ScheduledTriggerName
ScheduledTriggerName :: TriggerName -> ScheduledTriggerName
[unName] :: ScheduledTriggerName -> TriggerName
formatTime' :: UTCTime -> Text
data CreateScheduledEvent
CreateScheduledEvent :: InputWebhook -> UTCTime -> Maybe Value -> [HeaderConf] -> STRetryConf -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CreateScheduledEvent
[cseWebhook] :: CreateScheduledEvent -> InputWebhook

-- | The timestamp should be in the <a>8601
--   https://en.wikipedia.org/wiki/ISO_8601</a> format (which is what
--   <tt>aeson</tt> expects by default for <a>UTCTime</a>).
[cseScheduleAt] :: CreateScheduledEvent -> UTCTime
[csePayload] :: CreateScheduledEvent -> Maybe Value
[cseHeaders] :: CreateScheduledEvent -> [HeaderConf]
[cseRetryConf] :: CreateScheduledEvent -> STRetryConf
[cseComment] :: CreateScheduledEvent -> Maybe Text
[cseRequestTransform] :: CreateScheduledEvent -> Maybe RequestTransform
[cseResponseTransform] :: CreateScheduledEvent -> Maybe MetadataResponseTransform

-- | The <a>ScheduledEventType</a> data type is needed to differentiate
--   between a <tt>CronScheduledEvent</tt> and <a>OneOffScheduledEvent</a>
--   scheduled event because they both have different configurations and
--   they live in different tables.
data ScheduledEventType

-- | A Cron scheduled event has a template defined which will contain the
--   webhook, header configuration, retry configuration and a payload.
--   Every cron event created uses the above mentioned configurations
--   defined in the template. The configuration defined with the cron
--   trigger is cached and hence it's not fetched along the cron scheduled
--   events.
Cron :: ScheduledEventType

-- | A One-off scheduled event doesn't have any template defined so all the
--   configuration is fetched along the scheduled events.
OneOff :: ScheduledEventType
data ScheduledEventInvocation
ScheduledEventInvocation :: InvocationId -> EventId -> Maybe Int -> Maybe Value -> Maybe Value -> UTCTime -> ScheduledEventInvocation
[_seiId] :: ScheduledEventInvocation -> InvocationId
[_seiEventId] :: ScheduledEventInvocation -> EventId
[_seiStatus] :: ScheduledEventInvocation -> Maybe Int
[_seiRequest] :: ScheduledEventInvocation -> Maybe Value
[_seiResponse] :: ScheduledEventInvocation -> Maybe Value
[_seiCreatedAt] :: ScheduledEventInvocation -> UTCTime
data ScheduledEvent
SEOneOff :: ScheduledEvent
SECron :: TriggerName -> ScheduledEvent
parseScheduledEvent :: Object -> Parser ScheduledEvent
scheduledEventToPairs :: ScheduledEvent -> [Pair]
data CronEventSeed
CronEventSeed :: TriggerName -> UTCTime -> CronEventSeed
[cesName] :: CronEventSeed -> TriggerName
[cesScheduledTime] :: CronEventSeed -> UTCTime
type OneOffEvent = CreateScheduledEvent
data ScheduledEventStatus
SESScheduled :: ScheduledEventStatus
SESLocked :: ScheduledEventStatus
SESDelivered :: ScheduledEventStatus
SESError :: ScheduledEventStatus
SESDead :: ScheduledEventStatus
scheduledEventStatusToText :: ScheduledEventStatus -> Text
textToScheduledEventStatus :: Text -> Maybe ScheduledEventStatus
data OneOffScheduledEvent
OneOffScheduledEvent :: OneOffScheduledEventId -> InputWebhook -> UTCTime -> STRetryConf -> Maybe Value -> [HeaderConf] -> Text -> Int -> UTCTime -> Maybe UTCTime -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> OneOffScheduledEvent
[_ooseId] :: OneOffScheduledEvent -> OneOffScheduledEventId
[_ooseWebhookConf] :: OneOffScheduledEvent -> InputWebhook
[_ooseScheduledTime] :: OneOffScheduledEvent -> UTCTime
[_ooseRetryConf] :: OneOffScheduledEvent -> STRetryConf
[_oosePayload] :: OneOffScheduledEvent -> Maybe Value
[_ooseHeaderConf] :: OneOffScheduledEvent -> [HeaderConf]
[_ooseStatus] :: OneOffScheduledEvent -> Text
[_ooseTries] :: OneOffScheduledEvent -> Int
[_ooseCreatedAt] :: OneOffScheduledEvent -> UTCTime
[_ooseNextRetryAt] :: OneOffScheduledEvent -> Maybe UTCTime
[_ooseComment] :: OneOffScheduledEvent -> Maybe Text
[_ooseRequestTransform] :: OneOffScheduledEvent -> Maybe RequestTransform
[_ooseResponseTransform] :: OneOffScheduledEvent -> Maybe MetadataResponseTransform
data CronEvent
CronEvent :: CronEventId -> TriggerName -> UTCTime -> Text -> Int -> UTCTime -> Maybe UTCTime -> CronEvent
[_ceId] :: CronEvent -> CronEventId
[_ceTriggerName] :: CronEvent -> TriggerName

-- | We expect this to always be at second zero, since cron events have
--   minute resolution. Note that a OneOffScheduledEvent has full timestamp
--   precision.
[_ceScheduledTime] :: CronEvent -> UTCTime
[_ceStatus] :: CronEvent -> Text
[_ceTries] :: CronEvent -> Int

-- | it is the time at which the cron event generator created the event
[_ceCreatedAt] :: CronEvent -> UTCTime
[_ceNextRetryAt] :: CronEvent -> Maybe UTCTime
data ScheduledEventPagination
ScheduledEventPagination :: Maybe Int -> Maybe Int -> ScheduledEventPagination
[_sepLimit] :: ScheduledEventPagination -> Maybe Int
[_sepOffset] :: ScheduledEventPagination -> Maybe Int
parseScheduledEventPagination :: Object -> Parser ScheduledEventPagination
scheduledEventPaginationToPairs :: ScheduledEventPagination -> [Pair]

-- | Query type to fetch all one-off/cron scheduled events
data GetScheduledEvents
GetScheduledEvents :: ScheduledEvent -> ScheduledEventPagination -> [ScheduledEventStatus] -> GetScheduledEvents
[_gseScheduledEvent] :: GetScheduledEvents -> ScheduledEvent
[_gsePagination] :: GetScheduledEvents -> ScheduledEventPagination
[_gseStatus] :: GetScheduledEvents -> [ScheduledEventStatus]
data WithTotalCount a
WithTotalCount :: Int -> a -> WithTotalCount a
[_wtcCount] :: WithTotalCount a -> Int
[_wtcData] :: WithTotalCount a -> a

-- | Query type to delete cron/one-off events.
data DeleteScheduledEvent
DeleteScheduledEvent :: ScheduledEventType -> ScheduledEventId -> DeleteScheduledEvent
[_dseType] :: DeleteScheduledEvent -> ScheduledEventType
[_dseEventId] :: DeleteScheduledEvent -> ScheduledEventId
data GetInvocationsBy
GIBEventId :: EventId -> ScheduledEventType -> GetInvocationsBy
GIBEvent :: ScheduledEvent -> GetInvocationsBy
data GetEventInvocations
GetEventInvocations :: GetInvocationsBy -> ScheduledEventPagination -> GetEventInvocations
[_geiInvocationsBy] :: GetEventInvocations -> GetInvocationsBy
[_geiPagination] :: GetEventInvocations -> ScheduledEventPagination
data ClearCronEvents

-- | Used to delete the cron events only of the specified cron trigger
SingleCronTrigger :: TriggerName -> ClearCronEvents

-- | Used to delete all the cron events of the cron triggers with
--   `include_in_metadata: true` It is used in the case of the
--   <tt>replace_metadata</tt> API
MetadataCronTriggers :: [TriggerName] -> ClearCronEvents
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.GetInvocationsBy
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.GetInvocationsBy
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.GetEventInvocations
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.GetEventInvocations
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ClearCronEvents
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ClearCronEvents
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.GetEventInvocations
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.GetEventInvocations
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventPagination
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventPagination
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.ScheduledTrigger.WithTotalCount a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.ScheduledTrigger.WithTotalCount a)
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEvent
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CronEventSeed
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.CronEventSeed
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance Control.DeepSeq.NFData Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Control.DeepSeq.NFData Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance Control.DeepSeq.NFData Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.STRetryConf


-- | <h1>Hasura.Eventing.HTTP</h1>
--   
--   This module is an utility module providing HTTP utilities for
--   <a>Hasura.Eventing.EventTriggers</a> and
--   <a>Hasura.Eventing.ScheduledTriggers</a>.
--   
--   The event triggers and scheduled triggers share the event delivery
--   mechanism using the <tt>tryWebhook</tt> function defined in this
--   module.
module Hasura.Eventing.HTTP
retryAfterHeader :: CI Text
data ExtraLogContext
ExtraLogContext :: !EventId -> !Maybe TriggerName -> ExtraLogContext
[elEventId] :: ExtraLogContext -> !EventId
[elEventName] :: ExtraLogContext -> !Maybe TriggerName
data HTTPResp (a :: TriggerTypes)
HTTPResp :: !Int -> ![HeaderConf] -> !SerializableBlob -> !Int64 -> HTTPResp (a :: TriggerTypes)
[hrsStatus] :: HTTPResp (a :: TriggerTypes) -> !Int
[hrsHeaders] :: HTTPResp (a :: TriggerTypes) -> ![HeaderConf]
[hrsBody] :: HTTPResp (a :: TriggerTypes) -> !SerializableBlob
[hrsSize] :: HTTPResp (a :: TriggerTypes) -> !Int64
data HTTPErr (a :: TriggerTypes)
HClient :: !HttpException -> HTTPErr (a :: TriggerTypes)
HStatus :: !HTTPResp a -> HTTPErr (a :: TriggerTypes)
HOther :: !String -> HTTPErr (a :: TriggerTypes)
mkHTTPResp :: Response ByteString -> HTTPResp a
data RequestDetails
RequestDetails :: Request -> Int64 -> Maybe Request -> Maybe Int64 -> Maybe RequestTransformCtx -> Maybe SessionVariables -> RequestDetails
[_rdOriginalRequest] :: RequestDetails -> Request
[_rdOriginalSize] :: RequestDetails -> Int64
[_rdTransformedRequest] :: RequestDetails -> Maybe Request
[_rdTransformedSize] :: RequestDetails -> Maybe Int64
[_rdReqTransformCtx] :: RequestDetails -> Maybe RequestTransformCtx
[_rdSessionVars] :: RequestDetails -> Maybe SessionVariables
extractRequest :: RequestDetails -> Request
data HTTPRespExtra (a :: TriggerTypes)
HTTPRespExtra :: !Either (HTTPErr a) (HTTPResp a) -> !ExtraLogContext -> !RequestDetails -> !Text -> ![HeaderConf] -> HTTPRespExtra (a :: TriggerTypes)
[_hreResponse] :: HTTPRespExtra (a :: TriggerTypes) -> !Either (HTTPErr a) (HTTPResp a)
[_hreContext] :: HTTPRespExtra (a :: TriggerTypes) -> !ExtraLogContext
[_hreRequest] :: HTTPRespExtra (a :: TriggerTypes) -> !RequestDetails
[_hreWebhookVarName] :: HTTPRespExtra (a :: TriggerTypes) -> !Text
[_hreLogHeaders] :: HTTPRespExtra (a :: TriggerTypes) -> ![HeaderConf]
isNetworkError :: HTTPErr a -> Bool
isNetworkErrorHC :: HttpException -> Bool
anyBodyParser :: Response ByteString -> Either (HTTPErr a) (HTTPResp a)
data HTTPReq
HTTPReq :: !String -> !String -> !Maybe Value -> !Int -> !Maybe Int -> HTTPReq
[_hrqMethod] :: HTTPReq -> !String
[_hrqUrl] :: HTTPReq -> !String
[_hrqPayload] :: HTTPReq -> !Maybe Value
[_hrqTry] :: HTTPReq -> !Int
[_hrqDelay] :: HTTPReq -> !Maybe Int
logHTTPForET :: (MonadReader r m, Has (Logger Hasura) r, MonadIO m) => Either (HTTPErr 'EventType) (HTTPResp 'EventType) -> ExtraLogContext -> RequestDetails -> Text -> [HeaderConf] -> m ()
logHTTPForST :: (MonadReader r m, Has (Logger Hasura) r, MonadIO m) => Either (HTTPErr 'ScheduledType) (HTTPResp 'ScheduledType) -> ExtraLogContext -> RequestDetails -> Text -> [HeaderConf] -> m ()
runHTTP :: MonadIO m => Manager -> Request -> m (Either (HTTPErr a) (HTTPResp a))
data TransformableRequestError a
HTTPError :: Value -> HTTPErr a -> TransformableRequestError a
TransformationError :: Value -> TransformErrorBundle -> TransformableRequestError a
mkRequest :: MonadError (TransformableRequestError a) m => [Header] -> ResponseTimeout -> ByteString -> Maybe RequestTransform -> ResolvedWebhook -> m RequestDetails
invokeRequest :: (MonadReader r m, MonadError (TransformableRequestError a) m, Has Manager r, Has (Logger Hasura) r, MonadIO m, MonadTrace m) => RequestDetails -> Maybe ResponseTransform -> Maybe SessionVariables -> (Either (HTTPErr a) (HTTPResp a) -> RequestDetails -> m ()) -> m (HTTPResp a)
mkResp :: Int -> SerializableBlob -> [HeaderConf] -> Response a
mkClientErr :: SerializableBlob -> Response a
mkWebhookReq :: Value -> [HeaderConf] -> InvocationVersion -> WebhookRequest
mkInvocationResp :: Maybe Int -> SerializableBlob -> [HeaderConf] -> Response a
isClientError :: Int -> Bool
encodeHeader :: EventHeaderInfo -> Header
decodeHeader :: [EventHeaderInfo] -> (HeaderName, ByteString) -> HeaderConf

-- | Encodes given request headers along with our <tt>defaultHeaders</tt>
--   and returns them along with the re-decoded set of headers (for logging
--   purposes).
prepareHeaders :: [EventHeaderInfo] -> ([Header], [HeaderConf])
getRetryAfterHeaderFromHTTPErr :: HTTPErr a -> Maybe Text
getRetryAfterHeaderFromResp :: HTTPResp a -> Maybe Text
parseRetryHeaderValue :: Text -> Maybe Int
instance GHC.Show.Show (Hasura.Eventing.HTTP.TransformableRequestError a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.HTTP.HTTPReq
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Eventing.HTTP.HTTPReq
instance Hasura.Logging.ToEngineLog Hasura.Eventing.HTTP.HTTPReq Hasura.Logging.Hasura
instance GHC.Classes.Eq Hasura.Eventing.HTTP.HTTPReq
instance GHC.Show.Show Hasura.Eventing.HTTP.HTTPReq
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.HTTP.HTTPRespExtra a)
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPRespExtra 'Hasura.RQL.Types.Eventing.EventType) Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPRespExtra 'Hasura.RQL.Types.Eventing.ScheduledType) Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.HTTP.RequestDetails
instance GHC.Show.Show (Hasura.Eventing.HTTP.HTTPErr a)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.HTTP.HTTPErr a)
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPErr 'Hasura.RQL.Types.Eventing.EventType) Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPErr 'Hasura.RQL.Types.Eventing.ScheduledType) Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.HTTP.HTTPResp a)
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPResp 'Hasura.RQL.Types.Eventing.EventType) Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPResp 'Hasura.RQL.Types.Eventing.ScheduledType) Hasura.Logging.Hasura
instance GHC.Classes.Eq Hasura.Eventing.HTTP.ExtraLogContext
instance GHC.Show.Show Hasura.Eventing.HTTP.ExtraLogContext
instance GHC.Show.Show (Hasura.Eventing.HTTP.HTTPResp a)

module Hasura.Eventing.ScheduledTrigger.Types
newtype ScheduledTriggerInternalErr
ScheduledTriggerInternalErr :: QErr -> ScheduledTriggerInternalErr
data CronTriggerStats
CronTriggerStats :: !TriggerName -> !Int -> !UTCTime -> CronTriggerStats
[_ctsName] :: CronTriggerStats -> !TriggerName
[_ctsUpcomingEventsCount] :: CronTriggerStats -> !Int
[_ctsMaxScheduledTime] :: CronTriggerStats -> !UTCTime
data RetryContext
RetryContext :: !Int -> !STRetryConf -> RetryContext
[_rctxTries] :: RetryContext -> !Int
[_rctxConf] :: RetryContext -> !STRetryConf
data ScheduledEventWebhookPayload
ScheduledEventWebhookPayload :: !EventId -> !Maybe TriggerName -> !UTCTime -> !Value -> !Maybe Text -> !Maybe UTCTime -> !Maybe RequestTransform -> !Maybe MetadataResponseTransform -> ScheduledEventWebhookPayload
[sewpId] :: ScheduledEventWebhookPayload -> !EventId
[sewpName] :: ScheduledEventWebhookPayload -> !Maybe TriggerName
[sewpScheduledTime] :: ScheduledEventWebhookPayload -> !UTCTime
[sewpPayload] :: ScheduledEventWebhookPayload -> !Value
[sewpComment] :: ScheduledEventWebhookPayload -> !Maybe Text

-- | sewpCreatedAt is the time at which the event was created, In case of
--   one-off scheduled events, it's the time at which the user created the
--   event and in case of cron triggers, the graphql-engine generator,
--   generates the cron events, the <tt>created_at</tt> is just an
--   implementation detail, so we don't send it
[sewpCreatedAt] :: ScheduledEventWebhookPayload -> !Maybe UTCTime
[sewpRequestTransform] :: ScheduledEventWebhookPayload -> !Maybe RequestTransform
[sewpResponseTransform] :: ScheduledEventWebhookPayload -> !Maybe MetadataResponseTransform
data ScheduledEventOp
SEOpRetry :: !UTCTime -> ScheduledEventOp
SEOpStatus :: !ScheduledEventStatus -> ScheduledEventOp
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventOp
instance GHC.Show.Show Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventOp
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventWebhookPayload
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.ScheduledTriggerInternalErr
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.CronTriggerStats
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.RetryContext
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventWebhookPayload
instance GHC.Show.Show Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventWebhookPayload
instance Hasura.Logging.ToEngineLog Hasura.Eventing.ScheduledTrigger.Types.ScheduledTriggerInternalErr Hasura.Logging.Hasura


-- | Postgres SQL Types
--   
--   Combinators and helpers for dealing with Postgres types such as
--   strings, numerals, geography and geometry, etc.
module Hasura.Backends.Postgres.SQL.Types
newtype Identifier
Identifier :: Text -> Identifier
[getIdenTxt] :: Identifier -> Text
class IsIdentifier a
toIdentifier :: IsIdentifier a => a -> Identifier
pgFmtIdentifier :: Text -> Text
pgFmtLit :: Text -> Text
trimNullChars :: Text -> Text
newtype TableName
TableName :: Text -> TableName
[getTableTxt] :: TableName -> Text
data TableType
TTBaseTable :: TableType
TTView :: TableType
TTForeignTable :: TableType
TTLocalTemporary :: TableType
isView :: TableType -> Bool
newtype ConstraintName
ConstraintName :: Text -> ConstraintName
[getConstraintTxt] :: ConstraintName -> Text
newtype FunctionName
FunctionName :: Text -> FunctionName
[getFunctionTxt] :: FunctionName -> Text
newtype SchemaName
SchemaName :: Text -> SchemaName
[getSchemaTxt] :: SchemaName -> Text
publicSchema :: SchemaName
hdbCatalogSchema :: SchemaName
data QualifiedObject a
QualifiedObject :: SchemaName -> a -> QualifiedObject a
[qSchema] :: QualifiedObject a -> SchemaName
[qName] :: QualifiedObject a -> a
qualifiedObjectToText :: ToTxt a => QualifiedObject a -> Text
snakeCaseQualifiedObject :: ToTxt a => QualifiedObject a -> Text
getIdentifierQualifiedObject :: ToTxt a => QualifiedObject a -> Either QErr GQLNameIdentifier
namingConventionSupport :: SupportedNamingCase
qualifiedObjectToName :: (ToTxt a, MonadError QErr m) => QualifiedObject a -> m Name

-- | Represents a database table qualified with the schema name.
type QualifiedTable = QualifiedObject TableName
type QualifiedFunction = QualifiedObject FunctionName
newtype PGDescription
PGDescription :: Text -> PGDescription
[getPGDescription] :: PGDescription -> Text
newtype PGCol
PGCol :: Text -> PGCol
[getPGColTxt] :: PGCol -> Text
unsafePGCol :: Text -> PGCol
showPGCols :: (Foldable t, Functor t) => t PGCol -> Text
data PGScalarType
PGSmallInt :: PGScalarType
PGInteger :: PGScalarType
PGBigInt :: PGScalarType
PGSerial :: PGScalarType
PGBigSerial :: PGScalarType
PGFloat :: PGScalarType
PGDouble :: PGScalarType
PGNumeric :: PGScalarType
PGMoney :: PGScalarType
PGBoolean :: PGScalarType
PGChar :: PGScalarType
PGVarchar :: PGScalarType
PGText :: PGScalarType
PGCitext :: PGScalarType
PGDate :: PGScalarType
PGTimeStamp :: PGScalarType
PGTimeStampTZ :: PGScalarType
PGTimeTZ :: PGScalarType
PGJSON :: PGScalarType
PGJSONB :: PGScalarType
PGGeometry :: PGScalarType
PGGeography :: PGScalarType
PGRaster :: PGScalarType
PGUUID :: PGScalarType
PGLtree :: PGScalarType
PGLquery :: PGScalarType
PGLtxtquery :: PGScalarType
PGArray :: PGScalarType -> PGScalarType
PGUnknown :: Text -> PGScalarType
PGCompositeScalar :: Text -> PGScalarType
PGEnumScalar :: Text -> PGScalarType
pgScalarTypeToText :: PGScalarType -> Text
textToPGScalarType :: Text -> PGScalarType
pgScalarTranslations :: [(Text, PGScalarType)]
isNumType :: PGScalarType -> Bool
stringTypes :: [PGScalarType]
isStringType :: PGScalarType -> Bool
jsonTypes :: [PGScalarType]
isJSONType :: PGScalarType -> Bool
isComparableType :: PGScalarType -> Bool
isBigNum :: PGScalarType -> Bool
geoTypes :: [PGScalarType]
isGeoType :: PGScalarType -> Bool
data PGTypeKind
PGKindBase :: PGTypeKind
PGKindComposite :: PGTypeKind
PGKindDomain :: PGTypeKind
PGKindEnum :: PGTypeKind
PGKindRange :: PGTypeKind
PGKindPseudo :: PGTypeKind
PGKindUnknown :: Text -> PGTypeKind
data QualifiedPGType
QualifiedPGType :: SchemaName -> PGScalarType -> PGTypeKind -> QualifiedPGType
[_qptSchema] :: QualifiedPGType -> SchemaName
[_qptName] :: QualifiedPGType -> PGScalarType
[_qptType] :: QualifiedPGType -> PGTypeKind
isBaseType :: QualifiedPGType -> Bool
typeToTable :: QualifiedPGType -> QualifiedTable
mkFunctionArgScalarType :: QualifiedPGType -> PGScalarType

-- | Metadata describing SQL functions at the DB level, i.e. below the
--   GraphQL layer.
data PGRawFunctionInfo
PGRawFunctionInfo :: OID -> Bool -> FunctionVolatility -> SchemaName -> PGScalarType -> PGTypeKind -> Bool -> [QualifiedPGType] -> [FunctionArgName] -> Int -> Bool -> Maybe PGDescription -> PGRawFunctionInfo
[rfiOid] :: PGRawFunctionInfo -> OID
[rfiHasVariadic] :: PGRawFunctionInfo -> Bool
[rfiFunctionType] :: PGRawFunctionInfo -> FunctionVolatility
[rfiReturnTypeSchema] :: PGRawFunctionInfo -> SchemaName
[rfiReturnTypeName] :: PGRawFunctionInfo -> PGScalarType
[rfiReturnTypeType] :: PGRawFunctionInfo -> PGTypeKind
[rfiReturnsSet] :: PGRawFunctionInfo -> Bool
[rfiInputArgTypes] :: PGRawFunctionInfo -> [QualifiedPGType]
[rfiInputArgNames] :: PGRawFunctionInfo -> [FunctionArgName]
[rfiDefaultArgs] :: PGRawFunctionInfo -> Int
[rfiReturnsTable] :: PGRawFunctionInfo -> Bool
[rfiDescription] :: PGRawFunctionInfo -> Maybe PGDescription
mkScalarTypeName :: MonadError QErr m => PGScalarType -> m Name
pgTypeOid :: PGScalarType -> Oid
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.RQL.Types.Common.RelName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.RQL.Types.Common.FieldName
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.Identifier
instance GHC.Base.Semigroup Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.Identifier
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.Identifier
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.Identifier
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.String.IsString Hasura.Backends.Postgres.SQL.Types.TableName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.Types.TableName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.TableName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.TableName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.TableType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.String.IsString Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Data.Data a => Data.Data.Data (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Base.Functor Hasura.Backends.Postgres.SQL.Types.QualifiedObject
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGDescription
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGDescription
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Data.String.IsString Hasura.Backends.Postgres.SQL.Types.PGCol
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.Types.PGCol
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.Postgres.SQL.Types.PGCol
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.PGCol
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.PGCol
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.PGCol
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.PGCol
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance (Data.Aeson.Types.ToJSON.ToJSON a, Data.Text.Extended.ToTxt a) => Data.Aeson.Types.ToJSON.ToJSONKey (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Text.Extended.ToTxt a => Data.Text.Extended.ToTxt (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Text.Extended.ToTxt a => Hasura.Base.ToErrorValue.ToErrorValue (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Hasura.SQL.Types.ToSQL a => Hasura.SQL.Types.ToSQL (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.TableType
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.TableName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.TableName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.Identifier
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.Identifier


module Hasura.RQL.Types.ComputedField
newtype ComputedFieldName
ComputedFieldName :: NonEmptyText -> ComputedFieldName
[unComputedFieldName] :: ComputedFieldName -> NonEmptyText
computedFieldNameToText :: ComputedFieldName -> Text
fromComputedField :: ComputedFieldName -> FieldName
data FunctionTrackedAs (b :: BackendType)
FTAComputedField :: ComputedFieldName -> SourceName -> TableName b -> FunctionTrackedAs (b :: BackendType)
FTACustomFunction :: CustomFunctionNames -> FunctionTrackedAs (b :: BackendType)

-- | The function name and input arguments name for the "args" field
--   parser.
--   
--   <pre>
--   function_name(args: args_name)
--   </pre>
data CustomFunctionNames
CustomFunctionNames :: Name -> Name -> CustomFunctionNames
[cfnFunctionName] :: CustomFunctionNames -> Name
[cfnArgsName] :: CustomFunctionNames -> Name
data ComputedFieldFunction (b :: BackendType)
ComputedFieldFunction :: FunctionName b -> Seq (FunctionArgument b) -> ComputedFieldImplicitArguments b -> Maybe PGDescription -> ComputedFieldFunction (b :: BackendType)
[_cffName] :: ComputedFieldFunction (b :: BackendType) -> FunctionName b
[_cffInputArgs] :: ComputedFieldFunction (b :: BackendType) -> Seq (FunctionArgument b)
[_cffComputedFieldImplicitArgs] :: ComputedFieldFunction (b :: BackendType) -> ComputedFieldImplicitArguments b
[_cffDescription] :: ComputedFieldFunction (b :: BackendType) -> Maybe PGDescription
data ComputedFieldInfo (b :: BackendType)
ComputedFieldInfo :: XComputedField b -> ComputedFieldName -> ComputedFieldFunction b -> ComputedFieldReturn b -> Maybe Text -> ComputedFieldInfo (b :: BackendType)
[_cfiXComputedFieldInfo] :: ComputedFieldInfo (b :: BackendType) -> XComputedField b
[_cfiName] :: ComputedFieldInfo (b :: BackendType) -> ComputedFieldName
[_cfiFunction] :: ComputedFieldInfo (b :: BackendType) -> ComputedFieldFunction b
[_cfiReturnType] :: ComputedFieldInfo (b :: BackendType) -> ComputedFieldReturn b
[_cfiDescription] :: ComputedFieldInfo (b :: BackendType) -> Maybe Text
cfiXComputedFieldInfo :: forall b_a9HhX. Lens' (ComputedFieldInfo b_a9HhX) (XComputedField b_a9HhX)
cfiReturnType :: forall b_a9HhX. Lens' (ComputedFieldInfo b_a9HhX) (ComputedFieldReturn b_a9HhX)
cfiName :: forall b_a9HhX. Lens' (ComputedFieldInfo b_a9HhX) ComputedFieldName
cfiFunction :: forall b_a9HhX. Lens' (ComputedFieldInfo b_a9HhX) (ComputedFieldFunction b_a9HhX)
cfiDescription :: forall b_a9HhX. Lens' (ComputedFieldInfo b_a9HhX) (Maybe Text)

-- | Filter computed fields not returning rows of existing table
removeComputedFieldsReturningExistingTable :: forall backend. Backend backend => [ComputedFieldInfo backend] -> [ComputedFieldInfo backend]
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.ComputedField.ComputedFieldName
instance GHC.Generics.Generic Hasura.RQL.Types.ComputedField.ComputedFieldName
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.ComputedField.ComputedFieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.ComputedField.ComputedFieldName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.ComputedField.ComputedFieldName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.ComputedField.ComputedFieldName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.ComputedField.ComputedFieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ComputedField.ComputedFieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ComputedField.ComputedFieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.ComputedField.ComputedFieldName
instance GHC.Classes.Ord Hasura.RQL.Types.ComputedField.ComputedFieldName
instance GHC.Classes.Eq Hasura.RQL.Types.ComputedField.ComputedFieldName
instance GHC.Show.Show Hasura.RQL.Types.ComputedField.ComputedFieldName
instance GHC.Generics.Generic Hasura.RQL.Types.ComputedField.CustomFunctionNames
instance GHC.Classes.Eq Hasura.RQL.Types.ComputedField.CustomFunctionNames
instance GHC.Show.Show Hasura.RQL.Types.ComputedField.CustomFunctionNames
instance GHC.Generics.Generic (Hasura.RQL.Types.ComputedField.FunctionTrackedAs b)
instance GHC.Generics.Generic (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance GHC.Generics.Generic (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.ComputedField.FunctionTrackedAs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.ComputedField.FunctionTrackedAs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)

module Hasura.RQL.Types.Column
newtype EnumValue
EnumValue :: Name -> EnumValue
[getEnumValue] :: EnumValue -> Name
newtype EnumValueInfo
EnumValueInfo :: Maybe Text -> EnumValueInfo
[evComment] :: EnumValueInfo -> Maybe Text
type EnumValues = HashMap EnumValue EnumValueInfo

-- | Represents a reference to an “enum table,” a single-column Postgres
--   table that is referenced via foreign key.
data EnumReference (b :: BackendType)
EnumReference :: TableName b -> EnumValues -> Maybe Name -> EnumReference (b :: BackendType)
[erTable] :: EnumReference (b :: BackendType) -> TableName b
[erValues] :: EnumReference (b :: BackendType) -> EnumValues
[erTableCustomName] :: EnumReference (b :: BackendType) -> Maybe Name

-- | The type we use for columns, which are currently always “scalars”
--   (though see the note about <a>CollectableType</a>). Unlike
--   <a>ScalarType</a>, which represents a type that a backend knows about,
--   this type characterizes distinctions we make but the backend doesn’t.
data ColumnType (b :: BackendType)

-- | Ordinary Postgres columns.
ColumnScalar :: ScalarType b -> ColumnType (b :: BackendType)

-- | Columns that reference enum tables (see
--   <a>Hasura.RQL.Schema.Enum</a>). This is not actually a distinct type
--   from the perspective of Postgres (at the time of this writing, we
--   ensure they always have type <tt>text</tt>), but we really want to
--   distinguish this case, since we treat it <i>completely</i> differently
--   in the GraphQL schema.
ColumnEnumReference :: EnumReference b -> ColumnType (b :: BackendType)
_ColumnEnumReference :: forall b_a9P8h. Prism' (ColumnType b_a9P8h) (EnumReference b_a9P8h)
_ColumnScalar :: forall b_a9P8h. Prism' (ColumnType b_a9P8h) (ScalarType b_a9P8h)

-- | A parser to parse a json value with enforcing column type
type ValueParser b m v = CollectableType (ColumnType b) -> Value -> m v
data ColumnValue (b :: BackendType)
ColumnValue :: ColumnType b -> ScalarValue b -> ColumnValue (b :: BackendType)
[cvType] :: ColumnValue (b :: BackendType) -> ColumnType b
[cvValue] :: ColumnValue (b :: BackendType) -> ScalarValue b
isScalarColumnWhere :: (ScalarType b -> Bool) -> ColumnType b -> Bool
isEnumColumn :: ColumnType b -> Bool

-- | Note: Unconditionally accepts null values and returns <tt>PGNull</tt>.
parseScalarValueColumnType :: forall m b. (MonadError QErr m, Backend b) => ColumnType b -> Value -> m (ScalarValue b)
parseScalarValuesColumnType :: (MonadError QErr m, Backend b) => ColumnType b -> [Value] -> m [ScalarValue b]

-- | “Raw” column info, as stored in the catalog (but not in the schema
--   cache). Instead of containing a <tt>PGColumnType</tt>, it only
--   contains a <tt>PGScalarType</tt>, which is combined with the
--   <tt>pcirReferences</tt> field and other table data to eventually
--   resolve the type to a <tt>PGColumnType</tt>.
data RawColumnInfo (b :: BackendType)
RawColumnInfo :: Column b -> Int -> ScalarType b -> Bool -> Maybe Description -> ColumnMutability -> RawColumnInfo (b :: BackendType)
[rciName] :: RawColumnInfo (b :: BackendType) -> Column b

-- | The “ordinal position” of the column according to Postgres. Numbering
--   starts at 1 and increases. Dropping a column does <i>not</i> cause the
--   columns to be renumbered, so a column can be consistently identified
--   by its position.
[rciPosition] :: RawColumnInfo (b :: BackendType) -> Int
[rciType] :: RawColumnInfo (b :: BackendType) -> ScalarType b
[rciIsNullable] :: RawColumnInfo (b :: BackendType) -> Bool
[rciDescription] :: RawColumnInfo (b :: BackendType) -> Maybe Description
[rciMutability] :: RawColumnInfo (b :: BackendType) -> ColumnMutability

-- | Indicates whether a column may participate in certain mutations.
--   
--   For example, identity columns may sometimes be insertable but rarely
--   updatable, depending on the backend and how they're declared.
--   
--   This guides the schema parsers such that they only generate fields for
--   columns where they're valid without having to model the exact
--   circumstances which cause a column to appear or not.
--   
--   See
--   <a>https://github.com/hasura/graphql-engine/blob/master/rfcs/column-mutability.md</a>.
data ColumnMutability
ColumnMutability :: Bool -> Bool -> ColumnMutability
[_cmIsInsertable] :: ColumnMutability -> Bool
[_cmIsUpdatable] :: ColumnMutability -> Bool

-- | “Resolved” column info, produced from a <a>RawColumnInfo</a> value
--   that has been combined with other schema information to produce a
--   <tt>PGColumnType</tt>.
data ColumnInfo (b :: BackendType)
ColumnInfo :: Column b -> Name -> Int -> ColumnType b -> Bool -> Maybe Description -> ColumnMutability -> ColumnInfo (b :: BackendType)
[ciColumn] :: ColumnInfo (b :: BackendType) -> Column b

-- | field name exposed in GraphQL interface
[ciName] :: ColumnInfo (b :: BackendType) -> Name
[ciPosition] :: ColumnInfo (b :: BackendType) -> Int
[ciType] :: ColumnInfo (b :: BackendType) -> ColumnType b
[ciIsNullable] :: ColumnInfo (b :: BackendType) -> Bool
[ciDescription] :: ColumnInfo (b :: BackendType) -> Maybe Description
[ciMutability] :: ColumnInfo (b :: BackendType) -> ColumnMutability
type PrimaryKeyColumns b = NESeq (ColumnInfo b)
onlyNumCols :: forall b. Backend b => [ColumnInfo b] -> [ColumnInfo b]
isNumCol :: forall b. Backend b => ColumnInfo b -> Bool
onlyComparableCols :: forall b. Backend b => [ColumnInfo b] -> [ColumnInfo b]
getColInfos :: Backend b => [Column b] -> [ColumnInfo b] -> [ColumnInfo b]
fromCol :: Backend b => Column b -> FieldName
type ColumnValues b a = HashMap (Column b) a

-- | Represents a reference to a source column, possibly casted an
--   arbitrary number of times. Used within <tt>parseBoolExpOperations</tt>
--   for bookkeeping.
data ColumnReference (b :: BackendType)
ColumnReferenceColumn :: ColumnInfo b -> ColumnReference (b :: BackendType)
ColumnReferenceComputedField :: ComputedFieldName -> ScalarType b -> ColumnReference (b :: BackendType)
ColumnReferenceCast :: ColumnReference b -> ColumnType b -> ColumnReference (b :: BackendType)
columnReferenceType :: ColumnReference backend -> ColumnType backend
instance GHC.Show.Show Hasura.RQL.Types.Column.ColumnMutability
instance GHC.Generics.Generic Hasura.RQL.Types.Column.ColumnMutability
instance GHC.Classes.Eq Hasura.RQL.Types.Column.ColumnMutability
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.RawColumnInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.ColumnInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Backend.ScalarValue b)) => GHC.Classes.Eq (Hasura.RQL.Types.Column.ColumnValue b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Backend.ScalarValue b)) => GHC.Show.Show (Hasura.RQL.Types.Column.ColumnValue b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Text.Extended.ToTxt (Hasura.RQL.Types.Column.ColumnReference b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Column.ColumnMutability
instance Control.DeepSeq.NFData Hasura.RQL.Types.Column.ColumnMutability
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Column.ColumnMutability
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Column.ColumnMutability
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Column.ColumnMutability
instance Hasura.RQL.Types.Backend.Backend b => Data.Text.Extended.ToTxt (Hasura.RQL.Types.Column.ColumnType b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.EnumReference b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.EnumReference b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Column.EnumValueInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Column.EnumValueInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Column.EnumValue
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Column.EnumValue
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Column.EnumValue
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Column.EnumValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Column.EnumValue
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Column.EnumValue
instance Control.DeepSeq.NFData Hasura.RQL.Types.Column.EnumValue
instance GHC.Classes.Ord Hasura.RQL.Types.Column.EnumValue
instance GHC.Classes.Eq Hasura.RQL.Types.Column.EnumValue
instance GHC.Show.Show Hasura.RQL.Types.Column.EnumValue
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Column.EnumValueInfo
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Column.EnumValueInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.Column.EnumValueInfo
instance GHC.Classes.Ord Hasura.RQL.Types.Column.EnumValueInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Column.EnumValueInfo
instance GHC.Show.Show Hasura.RQL.Types.Column.EnumValueInfo


-- | Postgres Types Functions
--   
--   Postgres specific types related to SQL functions
module Hasura.Backends.Postgres.Types.Function
newtype HasDefault
HasDefault :: Bool -> HasDefault
[unHasDefault] :: HasDefault -> Bool
data FunctionArg
FunctionArg :: Maybe FunctionArgName -> QualifiedPGType -> HasDefault -> FunctionArg
[faName] :: FunctionArg -> Maybe FunctionArgName
[faType] :: FunctionArg -> QualifiedPGType
[faHasDefault] :: FunctionArg -> HasDefault
data ArgumentExp a

-- | Table row accessor
AETableRow :: ArgumentExp a

-- | Hardcoded reference to
--   <tt>hdb_catalog.hdb_action_log.response_payload</tt>
AEActionResponsePayload :: ArgumentExp a

-- | JSON/JSONB hasura session variable object
AESession :: a -> ArgumentExp a
AEInput :: a -> ArgumentExp a

-- | Eliminate <a>ArgumentExp</a>
--   
--   Used to ensure that the right column is used for
--   <a>AEActionResponsePayload</a>.
onArgumentExp :: a -> (Text -> a) -> ArgumentExp a -> a

-- | Hardcoded <tt>hdb_catalog.hdb_action_log.response_payload</tt> column
--   name
actionResponsePayloadColumn :: Text
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.Function.HasDefault
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.Function.HasDefault
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Types.Function.HasDefault
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Show.Show Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.Function.FunctionArg
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.Function.FunctionArg
instance GHC.Show.Show Hasura.Backends.Postgres.Types.Function.FunctionArg
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance Data.Traversable.Traversable Hasura.Backends.Postgres.Types.Function.ArgumentExp
instance Data.Foldable.Foldable Hasura.Backends.Postgres.Types.Function.ArgumentExp
instance GHC.Base.Functor Hasura.Backends.Postgres.Types.Function.ArgumentExp
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Types.Function.FunctionArg
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.Function.FunctionArg
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.Function.FunctionArg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.Function.FunctionArg


-- | Postgres types related to computed fields
module Hasura.Backends.Postgres.Types.ComputedField
data ComputedFieldDefinition
ComputedFieldDefinition :: QualifiedFunction -> Maybe FunctionArgName -> Maybe FunctionArgName -> ComputedFieldDefinition
[_cfdFunction] :: ComputedFieldDefinition -> QualifiedFunction
[_cfdTableArgument] :: ComputedFieldDefinition -> Maybe FunctionArgName
[_cfdSessionArgument] :: ComputedFieldDefinition -> Maybe FunctionArgName

-- | The function table argument is either the very first argument or the
--   named argument with an index. The index is 0 if the named argument is
--   the first.
data FunctionTableArgument
FTAFirst :: FunctionTableArgument
FTANamed :: FunctionArgName -> Int -> FunctionTableArgument

-- | The session argument, which passes Hasura session variables to a SQL
--   function as a JSON object.
data FunctionSessionArgument
FunctionSessionArgument :: FunctionArgName -> Int -> FunctionSessionArgument
data ComputedFieldImplicitArguments
ComputedFieldImplicitArguments :: FunctionTableArgument -> Maybe FunctionSessionArgument -> ComputedFieldImplicitArguments
[_cffaTableArgument] :: ComputedFieldImplicitArguments -> FunctionTableArgument
[_cffaSessionArgument] :: ComputedFieldImplicitArguments -> Maybe FunctionSessionArgument
fromComputedFieldImplicitArguments :: v -> ComputedFieldImplicitArguments -> [ArgumentExp v]
data ComputedFieldReturn
CFRScalar :: PGScalarType -> ComputedFieldReturn
CFRSetofTable :: QualifiedTable -> ComputedFieldReturn
_CFRSetofTable :: Prism' ComputedFieldReturn QualifiedTable
_CFRScalar :: Prism' ComputedFieldReturn PGScalarType
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance GHC.Show.Show Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance GHC.Show.Show Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance GHC.Show.Show Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance GHC.Show.Show Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance GHC.Show.Show Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition


-- | Postgres SQL DML
--   
--   Provide types and combinators for defining Postgres SQL queries and
--   mutations.
module Hasura.Backends.Postgres.SQL.DML

-- | An select statement that does not require mutation CTEs.
--   
--   See <a>SelectWithG</a> or <a>SelectWith</a> for select statements with
--   mutations as CTEs.
data Select
Select :: [(TableAlias, Select)] -> Maybe DistinctExpr -> [Extractor] -> Maybe FromExp -> Maybe WhereFrag -> Maybe GroupByExp -> Maybe HavingExp -> Maybe OrderByExp -> Maybe LimitExp -> Maybe OffsetExp -> Select

-- | Unlike <a>SelectWith</a>, does not allow data-modifying statements (as
--   those are only allowed at the top level of a query).
[selCTEs] :: Select -> [(TableAlias, Select)]
[selDistinct] :: Select -> Maybe DistinctExpr
[selExtr] :: Select -> [Extractor]
[selFrom] :: Select -> Maybe FromExp
[selWhere] :: Select -> Maybe WhereFrag
[selGroupBy] :: Select -> Maybe GroupByExp
[selHaving] :: Select -> Maybe HavingExp
[selOrderBy] :: Select -> Maybe OrderByExp
[selLimit] :: Select -> Maybe LimitExp
[selOffset] :: Select -> Maybe OffsetExp

-- | An empty select statement.
mkSelect :: Select
newtype LimitExp
LimitExp :: SQLExp -> LimitExp
newtype OffsetExp
OffsetExp :: SQLExp -> OffsetExp
newtype OrderByExp
OrderByExp :: NonEmpty OrderByItem -> OrderByExp

data OrderByItem
OrderByItem :: SQLExp -> Maybe OrderType -> Maybe NullsOrder -> OrderByItem
[oExpression] :: OrderByItem -> SQLExp
[oOrdering] :: OrderByItem -> Maybe OrderType
[oNullsOrder] :: OrderByItem -> Maybe NullsOrder

-- | Order by ascending or descending
data OrderType
OTAsc :: OrderType
OTDesc :: OrderType
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder
newtype GroupByExp
GroupByExp :: [SQLExp] -> GroupByExp
newtype FromExp
FromExp :: [FromItem] -> FromExp
mkIdenFromExp :: IsIdentifier a => a -> FromExp
mkSimpleFromExp :: QualifiedTable -> FromExp
mkSelFromExp :: Bool -> Select -> TableName -> FromItem
mkRowExp :: [Extractor] -> SQLExp
newtype HavingExp
HavingExp :: BoolExp -> HavingExp
newtype WhereFrag
WhereFrag :: BoolExp -> WhereFrag
[getWFBoolExp] :: WhereFrag -> BoolExp
mkSIdenExp :: IsIdentifier a => a -> SQLExp
mkQIdenExp :: (IsIdentifier a, IsIdentifier b) => a -> b -> SQLExp
data Qual
QualifiedIdentifier :: Identifier -> Maybe TypeAnn -> Qual
QualTable :: QualifiedTable -> Qual
QualVar :: Text -> Qual
mkQual :: QualifiedTable -> Qual
mkQIdentifier :: (IsIdentifier a, IsIdentifier b) => a -> b -> QIdentifier
mkQIdentifierTable :: IsIdentifier a => QualifiedTable -> a -> QIdentifier
data QIdentifier
QIdentifier :: Qual -> Identifier -> QIdentifier
data ColumnOp
ColumnOp :: SQLOp -> SQLExp -> ColumnOp
[_colOp] :: ColumnOp -> SQLOp
[_colExp] :: ColumnOp -> SQLExp
newtype SQLOp
SQLOp :: Text -> SQLOp
[sqlOpTxt] :: SQLOp -> Text
incOp :: SQLOp
mulOp :: SQLOp
jsonbPathOp :: SQLOp
jsonbConcatOp :: SQLOp
jsonbDeleteOp :: SQLOp
jsonbDeleteAtPathOp :: SQLOp
newtype TypeAnn
TypeAnn :: Text -> TypeAnn
[unTypeAnn] :: TypeAnn -> Text
mkTypeAnn :: CollectableType PGScalarType -> TypeAnn
intTypeAnn :: TypeAnn
numericTypeAnn :: TypeAnn
textTypeAnn :: TypeAnn
textArrTypeAnn :: TypeAnn
jsonTypeAnn :: TypeAnn
jsonbTypeAnn :: TypeAnn
boolTypeAnn :: TypeAnn
data CountType
CTStar :: CountType
CTSimple :: [PGCol] -> CountType
CTDistinct :: [PGCol] -> CountType
newtype TupleExp
TupleExp :: [SQLExp] -> TupleExp
data SQLExp
SEPrep :: Int -> SQLExp
SENull :: SQLExp
SELit :: Text -> SQLExp
SEUnsafe :: Text -> SQLExp
SESelect :: Select -> SQLExp

-- | all fields (<tt>*</tt>) or all fields from relation (<tt>iden.*</tt>)
SEStar :: Maybe Qual -> SQLExp

-- | A column name
SEIdentifier :: Identifier -> SQLExp

-- | SEIdentifier and SERowIdentifier are distinguished for easier rewrite
--   rules
SERowIdentifier :: Identifier -> SQLExp

-- | A qualified column name
SEQIdentifier :: QIdentifier -> SQLExp

-- | this is used to apply a sql function to an expression. The <a>Text</a>
--   is the function name
SEFnApp :: Text -> [SQLExp] -> Maybe OrderByExp -> SQLExp
SEOpApp :: SQLOp -> [SQLExp] -> SQLExp
SETyAnn :: SQLExp -> TypeAnn -> SQLExp
SECond :: BoolExp -> SQLExp -> SQLExp -> SQLExp
SEBool :: BoolExp -> SQLExp
SEExcluded :: Identifier -> SQLExp
SEArray :: [SQLExp] -> SQLExp
SEArrayIndex :: SQLExp -> SQLExp -> SQLExp
SETuple :: TupleExp -> SQLExp
SECount :: CountType -> SQLExp
SENamedArg :: Identifier -> SQLExp -> SQLExp
SEFunction :: FunctionExp -> SQLExp

-- | Represents an alias assignment for a column
newtype ColumnAlias
ColumnAlias :: Identifier -> ColumnAlias
[getColumnAlias] :: ColumnAlias -> Identifier
toColumnAlias :: IsIdentifier a => a -> ColumnAlias

-- | Convert a column alias assignment to SQL _with_ <tt>AS</tt> prefix
columnAliasToSqlWithAs :: ColumnAlias -> Builder

-- | Convert a column alias assignment to SQL _without_ <tt>AS</tt> prefix
columnAliasToSqlWithoutAs :: ColumnAlias -> Builder

-- | Represents an alias assignment for a table, relation or row
newtype TableAlias
TableAlias :: Identifier -> TableAlias
[getTableAlias] :: TableAlias -> Identifier
toTableAlias :: IsIdentifier a => a -> TableAlias

-- | Convert a table alias assignment to SQL _with_ <tt>AS</tt> prefix
tableAliasToSqlWithAs :: TableAlias -> Builder

-- | Convert a table alias assignment to SQL _without_ <tt>AS</tt> prefix
tableAliasToSqlWithoutAs :: TableAlias -> Builder
countStar :: SQLExp
intToSQLExp :: Int -> SQLExp
int64ToSQLExp :: Int64 -> SQLExp

-- | Extractor can be used to apply Postgres alias to a column
data Extractor
Extractor :: SQLExp -> Maybe ColumnAlias -> Extractor
mkSQLOpExp :: SQLOp -> SQLExp -> SQLExp -> SQLExp
columnDefaultValue :: SQLExp
handleIfNull :: SQLExp -> SQLExp -> SQLExp
applyJsonBuildObj :: [SQLExp] -> SQLExp
applyJsonBuildArray :: [SQLExp] -> SQLExp
applyRowToJson :: [Extractor] -> SQLExp
applyUppercase :: SQLExp -> SQLExp
mkExtr :: IsIdentifier a => a -> Extractor
data DistinctExpr
DistinctSimple :: DistinctExpr
DistinctOn :: [SQLExp] -> DistinctExpr
data FunctionArgs
FunctionArgs :: [SQLExp] -> HashMap Text SQLExp -> FunctionArgs
[fasPostional] :: FunctionArgs -> [SQLExp]
[fasNamed] :: FunctionArgs -> HashMap Text SQLExp
data FunctionDefinitionListItem
FunctionDefinitionListItem :: ColumnAlias -> PGScalarType -> FunctionDefinitionListItem
[_dliColumn] :: FunctionDefinitionListItem -> ColumnAlias
[_dliType] :: FunctionDefinitionListItem -> PGScalarType

-- | We can alias the result of a function call that returns a <tt>SETOF
--   RECORD</tt> by naming the result relation, and the columns and their
--   types. For example:
--   
--   <pre>
--   SELECT * FROM
--   function_returns_record(arg1, arg2 ...) AS relation_name(column_1 column_1_type, column_2 column_2_type, ...)
--   </pre>
--   
--   Note: a function that returns a table (instead of a record) cannot
--   name the types as seen in the above example.
data FunctionAlias
FunctionAlias :: TableAlias -> Maybe [FunctionDefinitionListItem] -> FunctionAlias
[_faIdentifier] :: FunctionAlias -> TableAlias
[_faDefinitionList] :: FunctionAlias -> Maybe [FunctionDefinitionListItem]
mkFunctionAlias :: TableAlias -> Maybe [(ColumnAlias, PGScalarType)] -> FunctionAlias

-- | A function call
data FunctionExp
FunctionExp :: QualifiedFunction -> FunctionArgs -> Maybe FunctionAlias -> FunctionExp
[feName] :: FunctionExp -> QualifiedFunction
[feArgs] :: FunctionExp -> FunctionArgs
[feAlias] :: FunctionExp -> Maybe FunctionAlias

-- | See <tt>from_item</tt> in
--   <a>https://www.postgresql.org/docs/current/sql-select.html</a>
data FromItem

-- | A simple table
FISimple :: QualifiedTable -> Maybe TableAlias -> FromItem

-- | An identifier (from CTEs)
FIIdentifier :: Identifier -> FromItem

-- | A function call (that should return a relation (<tt>SETOF</tt>) and
--   not a scalar)
FIFunc :: FunctionExp -> FromItem

-- | <tt>unnest</tt> converts (an) array(s) to a relation.
--   
--   We have: * The unnest function arguments * The relation alias * A list
--   of column aliases
--   
--   See <tt>unnest</tt> in
--   <a>https://www.postgresql.org/docs/current/functions-array.html</a>.
FIUnnest :: [SQLExp] -> TableAlias -> [ColumnAlias] -> FromItem
FISelect :: Lateral -> Select -> TableAlias -> FromItem
FISelectWith :: Lateral -> SelectWithG Select -> TableAlias -> FromItem
FIValues :: ValuesExp -> TableAlias -> Maybe [ColumnAlias] -> FromItem
FIJoin :: JoinExpr -> FromItem
mkSelFromItem :: Select -> TableAlias -> FromItem
mkSelectWithFromItem :: SelectWithG Select -> TableAlias -> FromItem
mkLateralFromItem :: Select -> TableAlias -> FromItem
newtype Lateral
Lateral :: Bool -> Lateral
data JoinExpr
JoinExpr :: FromItem -> JoinType -> FromItem -> JoinCond -> JoinExpr
[tjeLeft] :: JoinExpr -> FromItem
[tjeType] :: JoinExpr -> JoinType
[tjeRight] :: JoinExpr -> FromItem
[tjeJC] :: JoinExpr -> JoinCond
data JoinType
Inner :: JoinType
LeftOuter :: JoinType
RightOuter :: JoinType
FullOuter :: JoinType
data JoinCond
JoinOn :: BoolExp -> JoinCond
JoinUsing :: [Identifier] -> JoinCond
data BoolExp
BELit :: Bool -> BoolExp
BEBin :: BinOp -> BoolExp -> BoolExp -> BoolExp
BENot :: BoolExp -> BoolExp
BECompare :: CompareOp -> SQLExp -> SQLExp -> BoolExp
BECompareAny :: CompareOp -> SQLExp -> SQLExp -> BoolExp
BENull :: SQLExp -> BoolExp
BENotNull :: SQLExp -> BoolExp
BEExists :: Select -> BoolExp
BEIN :: SQLExp -> [SQLExp] -> BoolExp
BEExp :: SQLExp -> BoolExp
simplifyBoolExp :: BoolExp -> BoolExp
mkExists :: FromItem -> BoolExp -> BoolExp
data BinOp
AndOp :: BinOp
OrOp :: BinOp
data CompareOp
SEQ :: CompareOp
SGT :: CompareOp
SLT :: CompareOp
SIN :: CompareOp
SNE :: CompareOp
SGTE :: CompareOp
SLTE :: CompareOp
SNIN :: CompareOp
SLIKE :: CompareOp
SNLIKE :: CompareOp
SILIKE :: CompareOp
SNILIKE :: CompareOp
SSIMILAR :: CompareOp
SNSIMILAR :: CompareOp
SREGEX :: CompareOp
SIREGEX :: CompareOp
SNREGEX :: CompareOp
SNIREGEX :: CompareOp
SContains :: CompareOp
SContainedIn :: CompareOp
SHasKey :: CompareOp
SHasKeysAny :: CompareOp
SHasKeysAll :: CompareOp
SMatchesFulltext :: CompareOp
data SQLDelete
SQLDelete :: QualifiedTable -> Maybe UsingExp -> Maybe WhereFrag -> Maybe RetExp -> SQLDelete
[delTable] :: SQLDelete -> QualifiedTable
[delUsing] :: SQLDelete -> Maybe UsingExp
[delWhere] :: SQLDelete -> Maybe WhereFrag
[delRet] :: SQLDelete -> Maybe RetExp
data SQLUpdate
SQLUpdate :: QualifiedTable -> SetExp -> Maybe FromExp -> Maybe WhereFrag -> Maybe RetExp -> SQLUpdate
[upTable] :: SQLUpdate -> QualifiedTable
[upSet] :: SQLUpdate -> SetExp
[upFrom] :: SQLUpdate -> Maybe FromExp
[upWhere] :: SQLUpdate -> Maybe WhereFrag
[upRet] :: SQLUpdate -> Maybe RetExp
newtype SetExp
SetExp :: [SetExpItem] -> SetExp
newtype SetExpItem
SetExpItem :: (PGCol, SQLExp) -> SetExpItem
buildUpsertSetExp :: [PGCol] -> HashMap PGCol SQLExp -> SetExp
newtype UsingExp
UsingExp :: [TableName] -> UsingExp
newtype RetExp
RetExp :: [Extractor] -> RetExp
selectStar :: Extractor
selectStar' :: Qual -> Extractor
returningStar :: RetExp
data SQLConflictTarget
SQLColumn :: [PGCol] -> SQLConflictTarget
SQLConstraint :: ConstraintName -> SQLConflictTarget
data SQLConflict
DoNothing :: Maybe SQLConflictTarget -> SQLConflict
Update :: SQLConflictTarget -> SetExp -> Maybe WhereFrag -> SQLConflict
newtype ValuesExp
ValuesExp :: [TupleExp] -> ValuesExp
[getValuesExp] :: ValuesExp -> [TupleExp]
data SQLInsert
SQLInsert :: QualifiedTable -> [PGCol] -> ValuesExp -> Maybe SQLConflict -> Maybe RetExp -> SQLInsert
[siTable] :: SQLInsert -> QualifiedTable
[siCols] :: SQLInsert -> [PGCol]
[siValues] :: SQLInsert -> ValuesExp
[siConflict] :: SQLInsert -> Maybe SQLConflict
[siRet] :: SQLInsert -> Maybe RetExp

-- | Top-level Common Table Expression statement.
--   
--   A top level CTE can be a query or a mutation statement.
--   
--   Postgres supports mutations only in top-level CTEs. See
--   <a>https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-MODIFYING</a>
data TopLevelCTE
CTESelect :: Select -> TopLevelCTE
CTEInsert :: SQLInsert -> TopLevelCTE
CTEUpdate :: SQLUpdate -> TopLevelCTE
CTEDelete :: SQLDelete -> TopLevelCTE

-- | A <tt>SELECT</tt> statement with Common Table Expressions.
--   <a>https://www.postgresql.org/docs/current/queries-with.html</a>
--   
--   These CTEs are determined by the <tt>statement</tt> parameter.
--   Currently they are either <a>TopLevelCTE</a>, which allow for a query
--   or mutation statement, or <a>Select</a>, which only allow for querying
--   results.
--   
--   The distinction is required because Postgres only supports mutations
--   in CTEs at the top level. See
--   <a>https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-MODIFYING</a>
data SelectWithG statement
SelectWith :: [(TableAlias, statement)] -> Select -> SelectWithG statement
[swCTEs] :: SelectWithG statement -> [(TableAlias, statement)]
[swSelect] :: SelectWithG statement -> Select

-- | A top-level select with CTEs.
type SelectWith = SelectWithG TopLevelCTE
(<+>) :: ToSQL a => Text -> [a] -> Builder
infixr 6 <+>
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OrderType
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.OrderType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OrderType
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.OrderType
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.SQLOp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.SQLOp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.SQLOp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.SQLOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLOp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLOp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Qual
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.Qual
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Qual
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.Qual
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.CountType
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.CountType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.CountType
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.CountType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Lateral
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.Lateral
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Lateral
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Lateral
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Lateral
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.Lateral
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.JoinType
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.JoinType
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.JoinType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.JoinType
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.BinOp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.BinOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.BinOp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.BinOp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.UsingExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.UsingExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLConflictTarget
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLConflictTarget
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.LimitExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.LimitExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.JoinCond
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.JoinCond
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.JoinCond
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FromItem
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FromItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FromItem
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FromItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FromExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.FromExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FromExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FromExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FromExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FromExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.HavingExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.HavingExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Extractor
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.Extractor
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Extractor
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.Extractor
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.TupleExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TupleExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.BoolExp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.BoolExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.BoolExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.SQLExp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.SQLExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Select
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.Select
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Select
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.Select
instance Data.Data.Data statement => Data.Data.Data (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Classes.Eq statement => GHC.Classes.Eq (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Show.Show statement => GHC.Show.Show (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SetExpItem
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SetExpItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SetExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SetExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLConflict
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLConflict
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.RetExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.RetExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLUpdate
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLUpdate
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLDelete
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLDelete
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLInsert
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLInsert
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TopLevelCTE
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.TopLevelCTE
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Select
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.TopLevelCTE
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLInsert
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLDelete
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLUpdate
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.RetExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLConflict
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SetExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SetExpItem
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Select
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.Select
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Select
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FromExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Extractor
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.Extractor
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Extractor
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Extractor
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FromItem
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.FromItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FromItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FromItem
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Control.DeepSeq.NFData v => Control.DeepSeq.NFData (Hasura.Backends.Postgres.SQL.DML.SelectWithG v)
instance Hasura.Incremental.Internal.Dependency.Cacheable v => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.Postgres.SQL.DML.SelectWithG v)
instance Data.Hashable.Class.Hashable v => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.SQL.DML.SelectWithG v)
instance Hasura.SQL.Types.ToSQL v => Hasura.SQL.Types.ToSQL (Hasura.Backends.Postgres.SQL.DML.SelectWithG v)
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLConflictTarget
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.UsingExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.CompareOp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.CompareOp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.CompareOp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.CompareOp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.BinOp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.BinOp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.BinOp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.BinOp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.JoinType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.JoinType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.JoinType
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.JoinType
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Lateral
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.CountType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.CountType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.CountType
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.CountType
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Qual
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.Qual
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Qual
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Qual
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OrderType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.Postgres.SQL.DML.OrderType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OrderType
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OrderType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.DML.OrderType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.DML.OrderType


-- | Postgres SQL Value
--   
--   Deals with Postgres scalar values, converting them to and from
--   <a>Text</a>, and to JSON <a>Value</a>.
module Hasura.Backends.Postgres.SQL.Value
newtype RasterWKB
RasterWKB :: Base16 ByteString -> RasterWKB
[getRasterWKB] :: RasterWKB -> Base16 ByteString
newtype Ltree
Ltree :: Text -> Ltree
data PGScalarValue
PGValInteger :: Int32 -> PGScalarValue
PGValSmallInt :: Int16 -> PGScalarValue
PGValBigInt :: Int64 -> PGScalarValue
PGValFloat :: Float -> PGScalarValue
PGValDouble :: Double -> PGScalarValue
PGValNumeric :: Scientific -> PGScalarValue
PGValMoney :: Scientific -> PGScalarValue
PGValBoolean :: Bool -> PGScalarValue
PGValChar :: Char -> PGScalarValue
PGValVarchar :: Text -> PGScalarValue
PGValText :: Text -> PGScalarValue
PGValCitext :: Text -> PGScalarValue
PGValDate :: Day -> PGScalarValue
PGValTimeStamp :: LocalTime -> PGScalarValue
PGValTimeStampTZ :: UTCTime -> PGScalarValue
PGValTimeTZ :: ZonedTimeOfDay -> PGScalarValue
PGNull :: PGScalarType -> PGScalarValue
PGValJSON :: JSON -> PGScalarValue
PGValJSONB :: JSONB -> PGScalarValue
PGValGeo :: GeometryWithCRS -> PGScalarValue
PGValRaster :: RasterWKB -> PGScalarValue
PGValUUID :: UUID -> PGScalarValue
PGValLtree :: Ltree -> PGScalarValue
PGValLquery :: Text -> PGScalarValue
PGValLtxtquery :: Text -> PGScalarValue
PGValUnknown :: Text -> PGScalarValue
PGValArray :: [PGScalarValue] -> PGScalarValue
pgScalarValueToJson :: PGScalarValue -> Value
textToScalarValue :: Maybe Text -> PGScalarValue
withConstructorFn :: PGScalarType -> SQLExp -> SQLExp
withScalarTypeAnn :: PGScalarType -> SQLExp -> SQLExp
withTypeAnn :: CollectableType PGScalarType -> SQLExp -> SQLExp
scientificToInteger :: (Integral i, Bounded i) => Scientific -> Parser i
scientificToFloat :: RealFloat f => Scientific -> Parser f
parsePGValue :: PGScalarType -> Value -> Parser PGScalarValue
txtEncodedVal :: PGScalarValue -> TxtEncodedVal
binEncoder :: PGScalarValue -> PrepArg
formatTimestamp :: FormatTime t => t -> Text
txtEncoder :: PGScalarValue -> SQLExp
buildArrayLiteral :: [PGScalarValue] -> Text
toPrepParam :: Int -> PGScalarType -> SQLExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Value.RasterWKB
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Value.RasterWKB
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Value.Ltree
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Value.Ltree
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Value.PGScalarValue
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Value.PGScalarValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Value.Ltree
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Value.Ltree
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Value.RasterWKB
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Value.RasterWKB


-- | Postgres SQL Rename Identifiers
--   
--   <ol>
--   <li>Prefix table names with underscores to avoid issues where column
--   names and tables conflict. This can happen because we give columns and
--   tables the name <tt>root</tt> for some reason, and that can trip up
--   <tt>row_to_json</tt>. See
--   <a>https://github.com/PostgREST/postgrest/issues/993#issuecomment-340377813</a>.
--   An alternative solution would be to not create a <tt>TableAlias</tt>
--   with the name <tt>root</tt>, but that seemed a bit complicated for me
--   to do at the time.</li>
--   <li>Bypass the Postgres limitation of truncating identifiers to 63
--   characters long by prepending they identifier's md5 hash when they are
--   longer than 63 characters.</li>
--   </ol>
--   
--   We do both operations in the same traversal for performance reasons,
--   but a simpler implementation of (1) would be <tt>transformBi
--   prefixHash</tt> from the uniplate or the generic-plate package.
--   
--   See Postgres docs:
--   <a>https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS</a>
module Hasura.Backends.Postgres.SQL.RenameIdentifiers

-- | Prefix table names with undescores and rename long identifiers.
renameIdentifiers :: Select -> Select

-- | prefix table names with undescores and rename long identifiers.
renameIdentifiersSelectWith :: SelectWithG Select -> SelectWithG Select

-- | Prefix md5 hash if identifier length is over 63 characters. We assume
--   (rightly) that identifiers with names longer than 63 characters are
--   not database table columns, and are made by us using aliases, so we
--   should be free to rename them.
prefixHash :: Identifier -> Identifier
renameTablesAndLongIdentifiers :: Select -> Select
renameTablesAndLongIdentifiersWith :: SelectWithG Select -> SelectWithG Select
runMyState :: MyState a -> a
noTables :: TableNames

-- | The tables in scope
newtype TableNames
TableNames :: HashSet Identifier -> TableNames
[_tables] :: TableNames -> HashSet Identifier
type MyState = State TableNames

-- | attach a prefix to an identifier
mkPrefixedName :: Identifier -> Identifier

-- | Add the alias to the set and return a prefixed alias.
addAliasAndPrefixHash :: TableAlias -> MyState TableAlias

-- | Search for the identifier in the table names set and return a prefixed
--   identifier if found, or the original identifier if not found in the
--   set.
getTableNameAndPrefixHash :: Identifier -> MyState Identifier

-- | Run an action that might change the tables names set and discard the
--   changes made to the set.
restoringTables :: MyState a -> MyState a

-- | We run the algorithm on each CTE separately and discard the table
--   names set, then we run the algorithm on the main select and return
--   that result (with the table names found in scope).
uSelectWith :: SelectWithG Select -> MyState (SelectWithG Select)

-- | We go in order of each component in the select, starting with the from
--   and CTE clauses (as those introduce new table names to scope). We
--   return a transformed <tt>Select</tt> (with the table names).
uSelect :: Select -> MyState Select

-- | Transform every <tt>from_item</tt>. Potentially introduces a new
--   alias.
uFromExp :: FromExp -> MyState FromExp

-- | Transform a single <tt>from_item</tt>. Potentially introduces a new
--   alias.
uFromItem :: FromItem -> MyState FromItem

-- | Transform a function call expression.
uFunctionExp :: FunctionExp -> MyState FunctionExp

-- | Transform function call arguments.
uFunctionArgs :: FunctionArgs -> MyState FunctionArgs

-- | Transform a function call alias.
uFunctionAlias :: FunctionAlias -> MyState FunctionAlias

-- | Transform join expressions. Potentially introduces a new alias.
uJoinExp :: JoinExpr -> MyState JoinExpr

-- | Transform Join condition. <tt>ON</tt> join condition might contain
--   references to table names and aliases.
uJoinCond :: JoinCond -> MyState JoinCond

-- | Transform boolean expression.
--   
--   The boolean expression structure does not contain a table name
--   currently, So we look for <tt>SQLExp</tt>s and transform those, as
--   those may contain table names and aliases.
--   
--   We discard table names that might be introduced here because we don't
--   use them outside of the boolean expression.
uBoolExp :: BoolExp -> MyState BoolExp

-- | Transform a SQL expression. We look for table names and aliases and
--   rename them if needed. SQL expressions do not introduce new table
--   aliases, so we discard the new aliases that might be generated here.
uSqlExp :: SQLExp -> MyState SQLExp

-- | Transform order by clauses. Since order by does not introduce new
--   aliases we can discard the new names that might be added, this is
--   already done by <a>uSqlExp</a> though.
uOrderBy :: OrderByExp -> MyState OrderByExp

-- | Prefix a table alias with a hash if needed.
prefixHashTableAlias :: TableAlias -> TableAlias

-- | Prefix a column alias with a hash if needed.
prefixHashColumnAlias :: ColumnAlias -> ColumnAlias
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.RenameIdentifiers.TableNames
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.RenameIdentifiers.TableNames


-- | Postgres Connection MonadTx
--   
--   This module contains <a>MonadTx</a> and related combinators.
--   
--   <a>MonadTx</a>, a class which abstracts the <a>QErr</a> in <a>TxE</a>
--   via <a>MonadError</a>.
--   
--   The combinators are used for running, tracing, or otherwise perform
--   database related tasks. Please consult the individual documentation
--   for more information.
module Hasura.Backends.Postgres.Connection.MonadTx
class (MonadError QErr m) => MonadTx m
liftTx :: MonadTx m => TxE QErr a -> m a

-- | Executes the given query in a transaction of the specified mode,
--   within the provided PGExecCtx.
runTx :: (MonadIO m, MonadBaseControl IO m) => PGExecCtx -> TxAccess -> TxET QErr m a -> ExceptT QErr m a
runTxWithCtx :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m, UserInfoM m) => PGExecCtx -> TxAccess -> TxET QErr m a -> m a

-- | This runs the given set of statements (Tx) without wrapping them in
--   BEGIN and COMMIT. This should only be used for running a single
--   statement query!
runQueryTx :: (MonadIO m, MonadError QErr m) => PGExecCtx -> TxET QErr IO a -> m a
setHeadersTx :: MonadIO m => SessionVariables -> TxET QErr m ()
sessionInfoJsonExp :: SessionVariables -> SQLExp
withUserInfo :: MonadIO m => UserInfo -> TxET QErr m a -> TxET QErr m a
setTraceContextInTx :: MonadIO m => TraceContext -> TxET QErr m ()

-- | Inject the trace context as a transaction-local variable, so that it
--   can be picked up by any triggers (including event triggers).
withTraceContext :: MonadIO m => TraceContext -> TxET QErr m a -> TxET QErr m a
checkDbConnection :: MonadTx m => m ()
doesSchemaExist :: MonadTx m => SchemaName -> m Bool
doesTableExist :: MonadTx m => SchemaName -> TableName -> m Bool
isExtensionAvailable :: MonadTx m => Text -> m Bool
enablePgcryptoExtension :: forall m. MonadTx m => ExtensionsSchema -> m ()
dropHdbCatalogSchema :: MonadTx m => m ()
instance Hasura.Tracing.MonadTrace m => Hasura.Tracing.MonadTrace (Database.PG.Query.Transaction.TxET e m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Trans.Reader.ReaderT s m)
instance (GHC.Base.Monoid w, Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m) => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Validate.Internal.ValidateT e m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.Tracing.TraceT m)
instance Control.Monad.IO.Class.MonadIO m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)


-- | Postgres Connetion
--   
--   This module re-exports:
--   
--   <ul>
--   <li>MonadTx for abstracting postgres transactions</li>
--   <li>Settings for dealing with connection, pool, and replica
--   settings</li>
--   <li>ET for execution contexts and source configurations</li>
--   </ul>
module Hasura.Backends.Postgres.Connection

module Hasura.Server.Migrate.Internal

-- | The old 0.8 catalog version is non-integral, so the version has always
--   been stored as a string.
getCatalogVersion :: TxE QErr MetadataCatalogVersion
from3To4 :: forall m. (Backend ('Postgres 'Vanilla), MonadTx m) => m ()
setCatalogVersion :: MonadTx m => Text -> UTCTime -> m ()

module Hasura.RQL.IR.Value
data UnpreparedValue (b :: BackendType)

-- | A SQL value that can be parameterized over.
UVParameter :: Maybe VariableInfo -> ColumnValue b -> UnpreparedValue (b :: BackendType)

-- | A literal SQL expression that <i>cannot</i> be parameterized over.
UVLiteral :: SQLExpression b -> UnpreparedValue (b :: BackendType)

-- | The entire session variables JSON object.
UVSession :: UnpreparedValue (b :: BackendType)

-- | A single session variable.
UVSessionVar :: SessionVarType b -> SessionVariable -> UnpreparedValue (b :: BackendType)

-- | This indicates whether a variable value came from a certain GraphQL
--   variable
data ValueWithOrigin a
ValueWithOrigin :: VariableInfo -> a -> ValueWithOrigin a
ValueNoOrigin :: a -> ValueWithOrigin a
openValueOrigin :: ValueWithOrigin a -> a
mkParameter :: ValueWithOrigin (ColumnValue b) -> UnpreparedValue b
instance GHC.Base.Functor Hasura.RQL.IR.Value.ValueWithOrigin
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Column.ColumnValue b), GHC.Classes.Eq (Hasura.RQL.Types.Backend.ScalarValue b)) => GHC.Classes.Eq (Hasura.RQL.IR.Value.UnpreparedValue b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Column.ColumnValue b), GHC.Show.Show (Hasura.RQL.Types.Backend.ScalarValue b)) => GHC.Show.Show (Hasura.RQL.IR.Value.UnpreparedValue b)

module Hasura.RQL.IR.OrderBy
data OrderByCol
OCPG :: FieldName -> OrderByCol
OCRel :: FieldName -> OrderByCol -> OrderByCol
orderByColFromToks :: MonadFail m => [Text] -> m OrderByCol
orderByColFromTxt :: MonadFail m => Text -> m OrderByCol
data OrderByItemG (b :: BackendType) a
OrderByItemG :: Maybe (BasicOrderType b) -> a -> Maybe (NullsOrderType b) -> OrderByItemG (b :: BackendType) a
[obiType] :: OrderByItemG (b :: BackendType) a -> Maybe (BasicOrderType b)
[obiColumn] :: OrderByItemG (b :: BackendType) a -> a
[obiNulls] :: OrderByItemG (b :: BackendType) a -> Maybe (NullsOrderType b)
type OrderByItem b = OrderByItemG b OrderByCol
instance GHC.Classes.Eq Hasura.RQL.IR.OrderBy.OrderByCol
instance GHC.Show.Show Hasura.RQL.IR.OrderBy.OrderByCol
instance GHC.Generics.Generic (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance Data.Traversable.Traversable (Hasura.RQL.IR.OrderBy.OrderByItemG b)
instance Data.Foldable.Foldable (Hasura.RQL.IR.OrderBy.OrderByItemG b)
instance GHC.Base.Functor (Hasura.RQL.IR.OrderBy.OrderByItemG b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.IR.OrderBy.OrderByCol


-- | Boolean Expressions
--   
--   This module defines the IR representation of boolean expressions used
--   in <tt>_where</tt> clauses in GraphQL queries, permissions, and so on.
--   
--   The types in this module define a <i>generic</i> structure with
--   "holes" to be filled by each backend. Specifically, holes will include
--   things like types for table names, and backend field types.
module Hasura.RQL.IR.BoolExp

-- | This type represents a boolean expression tree. It is parametric over
--   the actual implementation of the actual boolean term values. It
--   nonetheless leaks some information: "exists" is only used in
--   permissions, to add conditions based on another table.
--   
--   <ul>
--   <li>The <tt>backend</tt> parameter is used to find the
--   backend-specific type for table names in the <tt>BoolExists</tt>
--   constructor.</li>
--   <li>The <tt>field</tt> type represent the type of database-specific
--   field types.</li>
--   </ul>
data GBoolExp (backend :: BackendType) field
BoolAnd :: [GBoolExp backend field] -> GBoolExp (backend :: BackendType) field
BoolOr :: [GBoolExp backend field] -> GBoolExp (backend :: BackendType) field
BoolNot :: GBoolExp backend field -> GBoolExp (backend :: BackendType) field

-- | Represents a condition on an aribtrary table. since the
--   <tt>backend</tt> and <tt>field</tt> are the same, the table must be of
--   the same database type.
BoolExists :: GExists backend field -> GBoolExp (backend :: BackendType) field

-- | A column field
BoolField :: field -> GBoolExp (backend :: BackendType) field

-- | A default representation for a <tt>true</tt> boolean value.
gBoolExpTrue :: GBoolExp backend field

-- | Represents a condition on an aribtrary table. Used as part of our
--   permissions boolean expressions. See our documentation for more
--   information:
--   <a>https://hasura.io/docs/latest/graphql/core/auth/authorization/permission-rules.html#using-unrelated-tables-views</a>
data GExists (backend :: BackendType) field
GExists :: TableName backend -> GBoolExp backend field -> GExists (backend :: BackendType) field
[_geTable] :: GExists (backend :: BackendType) field -> TableName backend
[_geWhere] :: GExists (backend :: BackendType) field -> GBoolExp backend field
geWhere :: forall backend_abBOS field_abBOT field_abFeA. Lens (GExists backend_abBOS field_abBOT) (GExists backend_abBOS field_abFeA) (GBoolExp backend_abBOS field_abBOT) (GBoolExp backend_abBOS field_abFeA)
geTable :: forall backend_abBOS field_abBOT. Lens' (GExists backend_abBOS field_abBOT) (TableName backend_abBOS)

-- | We don't allow conditions across relationships in permissions: the
--   type we use as the terms in GBoolExp is this one, ColExp, which only
--   contains a FieldName and a JSON Value.
data ColExp
ColExp :: FieldName -> Value -> ColExp
[ceCol] :: ColExp -> FieldName
[ceVal] :: ColExp -> Value

-- | This <tt>BoolExp</tt> type is a simple alias for the boolean
--   expressions used in permissions, that uses <a>ColExp</a> as the term
--   in GBoolExp.
newtype BoolExp (b :: BackendType)
BoolExp :: GBoolExp b ColExp -> BoolExp (b :: BackendType)
[unBoolExp] :: BoolExp (b :: BackendType) -> GBoolExp b ColExp
_BoolField :: forall backend_abBOU field_abBOV. Prism' (GBoolExp backend_abBOU field_abBOV) field_abBOV
_BoolExists :: forall backend_abBOU field_abBOV. Prism' (GBoolExp backend_abBOU field_abBOV) (GExists backend_abBOU field_abBOV)
_BoolNot :: forall backend_abBOU field_abBOV. Prism' (GBoolExp backend_abBOU field_abBOV) (GBoolExp backend_abBOU field_abBOV)
_BoolOr :: forall backend_abBOU field_abBOV. Prism' (GBoolExp backend_abBOU field_abBOV) [GBoolExp backend_abBOU field_abBOV]
_BoolAnd :: forall backend_abBOU field_abBOV. Prism' (GBoolExp backend_abBOU field_abBOV) [GBoolExp backend_abBOU field_abBOV]

-- | Permissions get translated into boolean expressions that are threaded
--   throuhgout the parsers. For the leaf values of those permissions, we
--   use this type, which references but doesn't inline the session
--   variables.
data PartialSQLExp (backend :: BackendType)
PSESessVar :: SessionVarType backend -> SessionVariable -> PartialSQLExp (backend :: BackendType)
PSESession :: PartialSQLExp (backend :: BackendType)
PSESQLExp :: SQLExpression backend -> PartialSQLExp (backend :: BackendType)
isStaticValue :: PartialSQLExp backend -> Bool
hasStaticExp :: Backend b => OpExpG b (PartialSQLExp b) -> Bool

-- | Operand for cast operator
type CastExp backend field = HashMap (ScalarType backend) [OpExpG backend field]

-- | This type represents the boolean operators that can be applied on
--   values of a column. This type only contains the common core, that we
--   expect to be ultimately entirely supported in most if not all
--   backends. Backends can extend this with the <tt>BooleanOperators</tt>
--   type in <tt>Backend</tt>.
data OpExpG (backend :: BackendType) field
ACast :: CastExp backend field -> OpExpG (backend :: BackendType) field
AEQ :: Bool -> field -> OpExpG (backend :: BackendType) field
ANE :: Bool -> field -> OpExpG (backend :: BackendType) field
AIN :: field -> OpExpG (backend :: BackendType) field
ANIN :: field -> OpExpG (backend :: BackendType) field
AGT :: field -> OpExpG (backend :: BackendType) field
ALT :: field -> OpExpG (backend :: BackendType) field
AGTE :: field -> OpExpG (backend :: BackendType) field
ALTE :: field -> OpExpG (backend :: BackendType) field
ALIKE :: field -> OpExpG (backend :: BackendType) field
ANLIKE :: field -> OpExpG (backend :: BackendType) field
CEQ :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CNE :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CGT :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CLT :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CGTE :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CLTE :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
ANISNULL :: OpExpG (backend :: BackendType) field
ANISNOTNULL :: OpExpG (backend :: BackendType) field
ABackendSpecific :: BooleanOperators backend field -> OpExpG (backend :: BackendType) field
data RootOrCurrentColumn b
RootOrCurrentColumn :: RootOrCurrent -> Column b -> RootOrCurrentColumn b

-- | The arguments of column-operators may refer to either the so-called
--   'root tabular value' or 'current tabular value'.
data RootOrCurrent
IsRoot :: RootOrCurrent
IsCurrent :: RootOrCurrent
opExpDepCol :: OpExpG backend field -> Maybe (RootOrCurrentColumn backend)

-- | This type is used to represent the kinds of boolean expression used
--   for compouted fields based on the return type of the SQL function.
data ComputedFieldBoolExp (backend :: BackendType) scalar

-- | SQL function returning a scalar
CFBEScalar :: [OpExpG backend scalar] -> ComputedFieldBoolExp (backend :: BackendType) scalar

-- | SQL function returning SET OF table
CFBETable :: TableName backend -> AnnBoolExp backend scalar -> ComputedFieldBoolExp (backend :: BackendType) scalar

-- | Using a computed field in boolean expression. Example: A computed
--   field "full_name" ("first_name" || "last_name") is defined to the
--   "user" table. Boolean expression to filter whose "full_name" is LIKE
--   "%bob%" query { user(where: {full_name: {_like: "%bob%"}}){ id
--   first_name last_name full_name } } Limitation: We only support
--   computed fields in boolean expressions when they are functions with no
--   input arguments, because it is complex to generate schema for
--   <tt>where</tt> clauses for functions that have input arguments.
data AnnComputedFieldBoolExp (backend :: BackendType) scalar
AnnComputedFieldBoolExp :: XComputedField backend -> ComputedFieldName -> FunctionName backend -> FunctionArgsExp backend scalar -> ComputedFieldBoolExp backend scalar -> AnnComputedFieldBoolExp (backend :: BackendType) scalar
[_acfbXFieldInfo] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> XComputedField backend
[_acfbName] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> ComputedFieldName
[_acfbFunction] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> FunctionName backend
[_acfbFunctionArgsExp] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> FunctionArgsExp backend scalar
[_acfbBoolExp] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> ComputedFieldBoolExp backend scalar

-- | This type is used for boolean terms in GBoolExp in the schema; there
--   are four kinds boolean terms: - operators on a column of the current
--   table, using the <a>OpExpG</a> kind of operators - arbitrary
--   expressions on columns of tables in relationships (in the same source)
--   - A computed field of the current table - aggregation operations on
--   array relationships on the current tables.
--   
--   This type is parameterized over the type of leaf values, the values on
--   which we operate.
data AnnBoolExpFld (backend :: BackendType) leaf
AVColumn :: ColumnInfo backend -> [OpExpG backend leaf] -> AnnBoolExpFld (backend :: BackendType) leaf
AVRelationship :: RelInfo backend -> AnnBoolExp backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf
AVComputedField :: AnnComputedFieldBoolExp backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf
AVAggregationPredicates :: AggregationPredicates backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf

-- | A simple alias for the kind of boolean expressions used in the schema,
--   that ties together <a>GBoolExp</a>, <a>OpExpG</a>, and
--   <a>AnnBoolExpFld</a>.
type AnnBoolExp backend scalar = GBoolExp backend (AnnBoolExpFld backend scalar)
type AnnBoolExpFldSQL backend = AnnBoolExpFld backend (SQLExpression backend)
type AnnBoolExpSQL backend = AnnBoolExp backend (SQLExpression backend)
type AnnBoolExpPartialSQL backend = AnnBoolExp backend (PartialSQLExp backend)
annBoolExpTrue :: AnnBoolExp backend scalar
andAnnBoolExps :: AnnBoolExp backend scalar -> AnnBoolExp backend scalar -> AnnBoolExp backend scalar

-- | Operand for STDWithin opoerator
data DWithinGeomOp field
DWithinGeomOp :: field -> field -> DWithinGeomOp field
[dwgeomDistance] :: DWithinGeomOp field -> field
[dwgeomFrom] :: DWithinGeomOp field -> field

-- | Operand for STDWithin opoerator
data DWithinGeogOp field
DWithinGeogOp :: field -> field -> field -> DWithinGeogOp field
[dwgeogDistance] :: DWithinGeogOp field -> field
[dwgeogFrom] :: DWithinGeogOp field -> field
[dwgeogUseSpheroid] :: DWithinGeogOp field -> field

-- | Operand for STIntersect
data STIntersectsNbandGeommin field
STIntersectsNbandGeommin :: field -> field -> STIntersectsNbandGeommin field
[singNband] :: STIntersectsNbandGeommin field -> field
[singGeommin] :: STIntersectsNbandGeommin field -> field

-- | Operand for STIntersect
data STIntersectsGeomminNband field
STIntersectsGeomminNband :: field -> Maybe field -> STIntersectsGeomminNband field
[signGeommin] :: STIntersectsGeomminNband field -> field
[signNband] :: STIntersectsGeomminNband field -> Maybe field

-- | This is a simple newtype over AnnBoolExpFld. At time of writing, I do
--   not know why we want this, and why it exists. It might be a relic of a
--   needed differentiation, now lost? TODO: can this be removed?
newtype AnnColumnCaseBoolExpField (backend :: BackendType) field
AnnColumnCaseBoolExpField :: AnnBoolExpFld backend field -> AnnColumnCaseBoolExpField (backend :: BackendType) field
[_accColCaseBoolExpField] :: AnnColumnCaseBoolExpField (backend :: BackendType) field -> AnnBoolExpFld backend field

-- | Similar to AnnBoolExp, this type alias ties together <a>GBoolExp</a>,
--   <a>OpExpG</a>, and <tt>AnnColumnCaseBoolExpFld</tt>.
type AnnColumnCaseBoolExp b a = GBoolExp b (AnnColumnCaseBoolExpField b a)
type AnnColumnCaseBoolExpPartialSQL b = AnnColumnCaseBoolExp b (PartialSQLExp b)
type PreSetColsG b v = HashMap (Column b) v
type PreSetColsPartial b = HashMap (Column b) (PartialSQLExp b)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpField backend field)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpField backend)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpField backend)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpField backend)
instance GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpField b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a), GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpField b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a), Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpField b a)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a), Hasura.Incremental.Internal.Dependency.Cacheable a) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpField b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a), Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpField b a)
instance Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpField b a)
instance Data.Aeson.Types.ToJSON.ToJSON field => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance Data.Aeson.Types.FromJSON.FromJSON field => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance Data.Data.Data field => Data.Data.Data (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband
instance Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband
instance GHC.Base.Functor Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance GHC.Show.Show field => GHC.Show.Show (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband a)
instance Data.Aeson.Types.ToJSON.ToJSON field => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Data.Aeson.Types.FromJSON.FromJSON field => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Data.Data.Data field => Data.Data.Data (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin
instance Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin
instance GHC.Base.Functor Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance GHC.Show.Show field => GHC.Show.Show (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin a)
instance Data.Aeson.Types.ToJSON.ToJSON field => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance Data.Aeson.Types.FromJSON.FromJSON field => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance Data.Data.Data field => Data.Data.Data (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.DWithinGeogOp
instance Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.DWithinGeogOp
instance GHC.Base.Functor Hasura.RQL.IR.BoolExp.DWithinGeogOp
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance GHC.Show.Show field => GHC.Show.Show (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.DWithinGeogOp a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.DWithinGeogOp a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.DWithinGeogOp a)
instance Data.Aeson.Types.ToJSON.ToJSON field => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance Data.Aeson.Types.FromJSON.FromJSON field => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.PartialSQLExp backend)
instance GHC.Generics.Generic Hasura.RQL.IR.BoolExp.RootOrCurrent
instance GHC.Show.Show Hasura.RQL.IR.BoolExp.RootOrCurrent
instance GHC.Classes.Eq Hasura.RQL.IR.BoolExp.RootOrCurrent
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.OpExpG backend field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend scalar)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp backend scalar)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend leaf)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend)
instance Data.Data.Data field => Data.Data.Data (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.DWithinGeomOp
instance Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.DWithinGeomOp
instance GHC.Base.Functor Hasura.RQL.IR.BoolExp.DWithinGeomOp
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance GHC.Show.Show field => GHC.Show.Show (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.OpExpG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.OpExpG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.OpExpG b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Backend.BooleanOperators b a), GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Backend.BooleanOperators b a), GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.OpExpG b a)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), GHC.Show.Show (Hasura.RQL.IR.BoolExp.OpExpG b a)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a), GHC.Classes.Eq (Hasura.RQL.Types.Function.FunctionArgsExp b a)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a), GHC.Show.Show (Hasura.RQL.Types.Function.FunctionArgsExp b a)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Backend.AggregationPredicates b a), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.OpExpG b a)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Backend.AggregationPredicates b a), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a), GHC.Show.Show (Hasura.RQL.IR.BoolExp.OpExpG b a)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.DWithinGeomOp a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.DWithinGeomOp a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.DWithinGeomOp a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.OpExpG b a)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.OpExpG b a)) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.OpExpG b a)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a), Control.DeepSeq.NFData (Hasura.RQL.Types.Function.FunctionArgsExp b a)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a), Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Function.FunctionArgsExp b a)) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a), Data.Hashable.Class.Hashable (Hasura.RQL.Types.Function.FunctionArgsExp b a)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.Types.Backend.AggregationPredicates b a), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.OpExpG b a)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Backend.AggregationPredicates b a), Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a), Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.OpExpG b a)) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.Types.Backend.AggregationPredicates b a), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.OpExpG b a)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.Types.Backend.AggregationPredicates b a), Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.OpExpG b a), Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.Types.Backend.BooleanOperators b a), Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Backend.BooleanOperators b a), Hasura.Incremental.Internal.Dependency.Cacheable a) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.Types.Backend.BooleanOperators b a), Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.Types.Backend.BooleanOperators b a), Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Control.DeepSeq.NFData Hasura.RQL.IR.BoolExp.RootOrCurrent
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.IR.BoolExp.RootOrCurrent
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.BoolExp.RootOrCurrent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.IR.BoolExp.RootOrCurrent
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.Types.Backend.SQLExpression b)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.Types.Backend.SQLExpression b)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Backend.SQLExpression b)) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance (Hasura.RQL.IR.BoolExp.BoolExp b1 GHC.Types.~ t) => Control.Lens.Wrapped.Rewrapped (Hasura.RQL.IR.BoolExp.BoolExp b2) t
instance Control.Lens.Wrapped.Wrapped (Hasura.RQL.IR.BoolExp.BoolExp b)
instance GHC.Generics.Generic Hasura.RQL.IR.BoolExp.ColExp
instance Data.Data.Data Hasura.RQL.IR.BoolExp.ColExp
instance GHC.Classes.Eq Hasura.RQL.IR.BoolExp.ColExp
instance GHC.Show.Show Hasura.RQL.IR.BoolExp.ColExp
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.BoolExp b)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Control.DeepSeq.NFData Hasura.RQL.IR.BoolExp.ColExp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.IR.BoolExp.ColExp
instance Data.Aeson.Extended.FromJSONKeyValue Hasura.RQL.IR.BoolExp.ColExp
instance Data.Aeson.Extended.ToJSONKeyValue Hasura.RQL.IR.BoolExp.ColExp
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance (Hasura.RQL.Types.Backend.Backend backend, Data.Data.Data field) => Data.Data.Data (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.GBoolExp backend)
instance Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.GBoolExp backend)
instance GHC.Base.Functor (Hasura.RQL.IR.BoolExp.GBoolExp backend)
instance (Hasura.RQL.Types.Backend.Backend backend, GHC.Classes.Eq field) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance (Hasura.RQL.Types.Backend.Backend backend, GHC.Show.Show field) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.GExists backend field)
instance Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.GExists backend)
instance Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.GExists backend)
instance GHC.Base.Functor (Hasura.RQL.IR.BoolExp.GExists backend)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Data.Data a) => Data.Data.Data (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Data.Data a) => Control.Lens.Plated.Plated (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable a) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.FromJSONKeyValue a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend backend, Data.Aeson.Extended.ToJSONKeyValue field) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Data.Data a) => Control.Lens.Plated.Plated (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable a) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.FromJSONKeyValue a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.ToJSONKeyValue a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.GExists b a)

module Hasura.RQL.Types.Permission
data PermType
PTInsert :: PermType
PTSelect :: PermType
PTUpdate :: PermType
PTDelete :: PermType
permTypeToCode :: PermType -> Text
data PermColSpec b
PCStar :: PermColSpec b
PCCols :: [Column b] -> PermColSpec b
data PermDef (b :: BackendType) (perm :: BackendType -> Type)
PermDef :: RoleName -> PermDefPermission b perm -> Maybe Text -> PermDef (b :: BackendType) (perm :: BackendType -> Type)
[_pdRole] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> RoleName
[_pdPermission] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> PermDefPermission b perm
[_pdComment] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> Maybe Text

-- | The permission data as it appears in a <a>PermDef</a>. Since this type
--   is a GADT it facilitates that values which are polymorphic may
--   re-discover its specific type of permission by case analysis.
--   
--   The fact that permission types are tracked in types are more
--   accidental than intentional and something we want to move away from,
--   see <a>https://github.com/hasura/graphql-engine-mono/issues/4076</a>.
data PermDefPermission (b :: BackendType) (perm :: BackendType -> Type)
[SelPerm'] :: SelPerm b -> PermDefPermission b SelPerm
[InsPerm'] :: InsPerm b -> PermDefPermission b InsPerm
[UpdPerm'] :: UpdPerm b -> PermDefPermission b UpdPerm
[DelPerm'] :: DelPerm b -> PermDefPermission b DelPerm
unPermDefPermission :: PermDefPermission b perm -> perm b
reflectPermDefPermission :: PermDefPermission b a -> PermType
data QueryRootFieldType
QRFTSelect :: QueryRootFieldType
QRFTSelectByPk :: QueryRootFieldType
QRFTSelectAggregate :: QueryRootFieldType
data SubscriptionRootFieldType
SRFTSelect :: SubscriptionRootFieldType
SRFTSelectByPk :: SubscriptionRootFieldType
SRFTSelectAggregate :: SubscriptionRootFieldType
SRFTSelectStream :: SubscriptionRootFieldType
data InsPerm (b :: BackendType)
InsPerm :: BoolExp b -> Maybe (ColumnValues b Value) -> Maybe (PermColSpec b) -> Bool -> InsPerm (b :: BackendType)
[ipCheck] :: InsPerm (b :: BackendType) -> BoolExp b
[ipSet] :: InsPerm (b :: BackendType) -> Maybe (ColumnValues b Value)
[ipColumns] :: InsPerm (b :: BackendType) -> Maybe (PermColSpec b)
[ipBackendOnly] :: InsPerm (b :: BackendType) -> Bool
type InsPermDef b = PermDef b InsPerm
data AllowedRootFields rootFieldType
ARFAllowAllRootFields :: AllowedRootFields rootFieldType
ARFAllowConfiguredRootFields :: HashSet rootFieldType -> AllowedRootFields rootFieldType
isRootFieldAllowed :: Eq rootField => rootField -> AllowedRootFields rootField -> Bool
data SelPerm (b :: BackendType)
SelPerm :: PermColSpec b -> BoolExp b -> Maybe Int -> Bool -> [ComputedFieldName] -> AllowedRootFields QueryRootFieldType -> AllowedRootFields SubscriptionRootFieldType -> SelPerm (b :: BackendType)

-- | Allowed columns
[spColumns] :: SelPerm (b :: BackendType) -> PermColSpec b

-- | Filter expression
[spFilter] :: SelPerm (b :: BackendType) -> BoolExp b

-- | Limit value
[spLimit] :: SelPerm (b :: BackendType) -> Maybe Int

-- | Allow aggregation
[spAllowAggregations] :: SelPerm (b :: BackendType) -> Bool

-- | Allowed computed fields which should not include the fields returning
--   rows of existing table.
[spComputedFields] :: SelPerm (b :: BackendType) -> [ComputedFieldName]
[spAllowedQueryRootFields] :: SelPerm (b :: BackendType) -> AllowedRootFields QueryRootFieldType
[spAllowedSubscriptionRootFields] :: SelPerm (b :: BackendType) -> AllowedRootFields SubscriptionRootFieldType
type SelPermDef b = PermDef b SelPerm
data DelPerm (b :: BackendType)
DelPerm :: BoolExp b -> Bool -> DelPerm (b :: BackendType)
[dcFilter] :: DelPerm (b :: BackendType) -> BoolExp b
[dcBackendOnly] :: DelPerm (b :: BackendType) -> Bool
type DelPermDef b = PermDef b DelPerm
data UpdPerm (b :: BackendType)
UpdPerm :: PermColSpec b -> Maybe (ColumnValues b Value) -> BoolExp b -> Maybe (BoolExp b) -> Bool -> UpdPerm (b :: BackendType)
[ucColumns] :: UpdPerm (b :: BackendType) -> PermColSpec b
[ucSet] :: UpdPerm (b :: BackendType) -> Maybe (ColumnValues b Value)
[ucFilter] :: UpdPerm (b :: BackendType) -> BoolExp b

-- | Check expression, which must be true after update. This is optional
--   because we don't want to break the v1 API but Nothing should be
--   equivalent to the expression which always returns true.
[ucCheck] :: UpdPerm (b :: BackendType) -> Maybe (BoolExp b)
[ucBackendOnly] :: UpdPerm (b :: BackendType) -> Bool
type UpdPermDef b = PermDef b UpdPerm
pdRole :: forall b_acwsA perm_acwsB. Lens' (PermDef b_acwsA perm_acwsB) RoleName
pdPermission :: forall b_acwsA perm_acwsB b_acEqz perm_acEqA. Lens (PermDef b_acwsA perm_acwsB) (PermDef b_acEqz perm_acEqA) (PermDefPermission b_acwsA perm_acwsB) (PermDefPermission b_acEqz perm_acEqA)
pdComment :: forall b_acwsA perm_acwsB. Lens' (PermDef b_acwsA perm_acwsB) (Maybe Text)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.SelPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.InsPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.UpdPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.DelPerm)
instance GHC.Generics.Generic Hasura.RQL.Types.Permission.PermType
instance GHC.Classes.Eq Hasura.RQL.Types.Permission.PermType
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.PermColSpec b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Permission.QueryRootFieldType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Permission.QueryRootFieldType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Permission.QueryRootFieldType
instance GHC.Generics.Generic Hasura.RQL.Types.Permission.QueryRootFieldType
instance GHC.Classes.Eq Hasura.RQL.Types.Permission.QueryRootFieldType
instance GHC.Show.Show Hasura.RQL.Types.Permission.QueryRootFieldType
instance Control.DeepSeq.NFData Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Generics.Generic Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Classes.Eq Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Show.Show Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.InsPerm b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance GHC.Classes.Eq rootFieldType => GHC.Classes.Eq (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance GHC.Show.Show rootFieldType => GHC.Show.Show (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.SelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.SelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.SelPerm b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.DelPerm b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.UpdPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.UpdPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.UpdPerm b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.PermColSpec b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.PermColSpec b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (perm b)) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Permission.PermDef b perm)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (perm b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.RQL.Types.Common.ToAesonPairs (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.SelPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.InsPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.UpdPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.DelPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Permission.UpdPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.UpdPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.UpdPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Permission.SelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.SelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.SelPerm b)
instance Hasura.Incremental.Internal.Dependency.Cacheable rootFieldType => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance Control.DeepSeq.NFData rootFieldType => Control.DeepSeq.NFData (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance Data.Aeson.Types.ToJSON.ToJSON rootFieldType => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance GHC.Base.Semigroup (Data.HashSet.Internal.HashSet rootFieldType) => GHC.Base.Semigroup (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.InsPerm b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Permission.QueryRootFieldType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Permission.QueryRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Permission.PermColSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermColSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.PermColSpec b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Permission.PermType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Permission.PermType
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Permission.PermType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Permission.PermType
instance GHC.Show.Show Hasura.RQL.Types.Permission.PermType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Permission.PermType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Permission.PermType

module Hasura.RQL.IR.Conflict
data ConflictTarget (b :: BackendType)
CTColumn :: [Column b] -> ConflictTarget (b :: BackendType)
CTConstraint :: ConstraintName b -> ConflictTarget (b :: BackendType)
data OnConflictClauseData b v
OnConflictClauseData :: ConflictTarget b -> [Column b] -> PreSetColsG b v -> AnnBoolExp b v -> OnConflictClauseData b v
[cp1udConflictTarget] :: OnConflictClauseData b v -> ConflictTarget b
[cp1udAffectedColumns] :: OnConflictClauseData b v -> [Column b]
[cp1udValues] :: OnConflictClauseData b v -> PreSetColsG b v
[cp1udFilter] :: OnConflictClauseData b v -> AnnBoolExp b v
data OnConflictClause (b :: BackendType) v
OCCDoNothing :: Maybe (ConflictTarget b) -> OnConflictClause (b :: BackendType) v
OCCUpdate :: OnConflictClauseData b v -> OnConflictClause (b :: BackendType) v
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Conflict.OnConflictClauseData b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Conflict.OnConflictClauseData b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Conflict.OnConflictClauseData b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Conflict.OnConflictClause b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Conflict.OnConflictClause b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Conflict.OnConflictClause b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.Conflict.ConflictTarget b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.Conflict.ConflictTarget b)


-- | This module contains the default types and function that model
--   aggregation predicates.
module Hasura.RQL.IR.BoolExp.AggregationPredicates

-- | This type the default non-empty implementation of the
--   <tt>AggregationPredicates</tt> type family of 'class Backend'.
--   
--   This represents an _applied_ aggregation predicate, i.e. _not_ an
--   aggegation function in isolation.
--   
--   In the default schema implementation, this type results from parsing
--   graphql such as:
--   
--   table(_where( <a>relation</a>_aggregate: {<a>functionname</a>: {
--   arguments: <a>arguments</a>, predicate: <a>predicate</a>, distinct:
--   bool } } )) { ... }
--   
--   Note that we make no attemt at modelling window functions or so-called
--   <tt>analytical</tt> functions such as <tt>percentile_cont</tt>.
data AggregationPredicatesImplementation (b :: BackendType) field
AggregationPredicatesImplementation :: RelInfo b -> [AggregationPredicate b field] -> AggregationPredicatesImplementation (b :: BackendType) field
[aggRelation] :: AggregationPredicatesImplementation (b :: BackendType) field -> RelInfo b
[aggPredicates] :: AggregationPredicatesImplementation (b :: BackendType) field -> [AggregationPredicate b field]
data AggregationPredicate (b :: BackendType) field
AggregationPredicate :: Text -> Bool -> Maybe (AnnBoolExp b field) -> AggregationPredicateArguments b -> [OpExpG b field] -> AggregationPredicate (b :: BackendType) field
[aggPredFunctionName] :: AggregationPredicate (b :: BackendType) field -> Text
[aggPredDistinct] :: AggregationPredicate (b :: BackendType) field -> Bool
[aggPredFilter] :: AggregationPredicate (b :: BackendType) field -> Maybe (AnnBoolExp b field)
[aggPredArguments] :: AggregationPredicate (b :: BackendType) field -> AggregationPredicateArguments b
[aggPredPredicate] :: AggregationPredicate (b :: BackendType) field -> [OpExpG b field]
data AggregationPredicateArguments (b :: BackendType)
AggregationPredicateArgumentsStar :: AggregationPredicateArguments (b :: BackendType)
AggregationPredicateArguments :: NonEmpty (Column b) -> AggregationPredicateArguments (b :: BackendType)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.OpExpG b field), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), GHC.Show.Show (Hasura.RQL.IR.BoolExp.OpExpG b field), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.OpExpG b field), Hasura.RQL.Types.Backend.Backend b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.Types.Backend.BooleanOperators b field), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), Data.Hashable.Class.Hashable field) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b), Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.OpExpG b field)) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.OpExpG b field)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.OpExpG b field)) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)


-- | Postgres Types BoolExp
--   
--   Postgres-specific <tt>BooleanOperator</tt> extensions.
module Hasura.Backends.Postgres.Types.BoolExp
data BooleanOperators a
AILIKE :: a -> BooleanOperators a
ANILIKE :: a -> BooleanOperators a
ASIMILAR :: a -> BooleanOperators a
ANSIMILAR :: a -> BooleanOperators a
AREGEX :: a -> BooleanOperators a
AIREGEX :: a -> BooleanOperators a
ANREGEX :: a -> BooleanOperators a
ANIREGEX :: a -> BooleanOperators a
AContains :: a -> BooleanOperators a
AContainedIn :: a -> BooleanOperators a
AHasKey :: a -> BooleanOperators a
AHasKeysAny :: a -> BooleanOperators a
AHasKeysAll :: a -> BooleanOperators a
ASTContains :: a -> BooleanOperators a
ASTCrosses :: a -> BooleanOperators a
ASTEquals :: a -> BooleanOperators a
ASTIntersects :: a -> BooleanOperators a
AST3DIntersects :: a -> BooleanOperators a
ASTOverlaps :: a -> BooleanOperators a
ASTTouches :: a -> BooleanOperators a
ASTWithin :: a -> BooleanOperators a
ASTIntersectsRast :: a -> BooleanOperators a
ASTDWithinGeom :: DWithinGeomOp a -> BooleanOperators a
AST3DDWithinGeom :: DWithinGeomOp a -> BooleanOperators a
ASTDWithinGeog :: DWithinGeogOp a -> BooleanOperators a
ASTIntersectsGeomNband :: STIntersectsGeomminNband a -> BooleanOperators a
ASTIntersectsNbandGeom :: STIntersectsNbandGeommin a -> BooleanOperators a
AAncestor :: a -> BooleanOperators a
AAncestorAny :: a -> BooleanOperators a
ADescendant :: a -> BooleanOperators a
ADescendantAny :: a -> BooleanOperators a
AMatches :: a -> BooleanOperators a
AMatchesAny :: a -> BooleanOperators a
AMatchesFulltext :: a -> BooleanOperators a
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Data.Traversable.Traversable Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators
instance GHC.Base.Functor Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators
instance Data.Foldable.Foldable Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)


-- | <h1>Reasonably efficient PostgreSQL live queries</h1>
--   
--   The module implements <i>query multiplexing</i>, which is our
--   implementation strategy for live queries (i.e. GraphQL subscriptions)
--   made against Postgres. Fundamentally, our implementation is built
--   around polling, which is never ideal, but it’s a lot easier to
--   implement than trying to do something event-based. To minimize the
--   resource cost of polling, we use <i>multiplexing</i>, which is
--   essentially a two-tier batching strategy.
--   
--   <h2>The high-level idea</h2>
--   
--   The objective is to minimize the number of concurrent polling workers
--   to reduce database load as much as possible. A very naïve strategy
--   would be to group identical queries together so we only have one
--   poller per <i>unique</i> active subscription. That’s a good start, but
--   of course, in practice, most queries differ slightly. However, it
--   happens that they very frequently /only differ in their variables/
--   (that is, GraphQL query variables and session variables), and in those
--   cases, we try to generated parameterized SQL. This means that the same
--   prepared SQL query can be reused, just with a different set of
--   variables.
--   
--   To give a concrete example, consider the following query:
--   
--   <pre>
--   subscription vote_count($post_id: Int!) {
--     vote_count(where: {post_id: {_eq: $post_id}}) {
--       votes
--     }
--   }
--   </pre>
--   
--   No matter what the client provides for <tt>$post_id</tt>, we will
--   always generate the same SQL:
--   
--   <pre>
--   SELECT votes FROM vote_count WHERE post_id = $1
--   </pre>
--   
--   If multiple clients subscribe to <tt>vote_count</tt>, we can certainly
--   reuse the same prepared query. For example, imagine we had 10
--   concurrent subscribers, each listening on a distinct
--   <tt>$post_id</tt>:
--   
--   <pre>
--   let postIds = [3, 11, 32, 56, 13, 97, 24, 43, 109, 48]
--   </pre>
--   
--   We could iterate over <tt>postIds</tt> in Haskell, executing the same
--   prepared query 10 times:
--   
--   <pre>
--   for postIds $ \postId -&gt;
--     Q.listQE defaultTxErrorHandler preparedQuery (Identity postId) True
--   </pre>
--   
--   Sadly, that on its own isn’t good enough. The overhead of running each
--   query is large enough that Postgres becomes overwhelmed if we have to
--   serve lots of concurrent subscribers. Therefore, what we want to be
--   able to do is somehow make one query instead of ten.
--   
--   <h3>Multiplexing</h3>
--   
--   This is where multiplexing comes in. By taking advantage of Postgres
--   <a>lateral joins</a>, we can do the iteration in Postgres rather than
--   in Haskell, allowing us to pay the query overhead just once for all
--   ten subscribers. Essentially, lateral joins add <a>map</a>-like
--   functionality to SQL, so we can run our query once per
--   <tt>$post_id</tt>:
--   
--   <pre>
--   SELECT results.votes
--   FROM unnest($1::integer[]) query_variables (post_id)
--   LEFT JOIN LATERAL (
--     SELECT coalesce(json_agg(votes), '[]')
--     FROM vote_count WHERE vote_count.post_id = query_variables.post_id
--   ) results ON true
--   </pre>
--   
--   If we generalize this approach just a little bit more, we can apply
--   this transformation to arbitrary queries parameterized over arbitrary
--   session and query variables!
--   
--   <h2>Implementation overview</h2>
--   
--   To support query multiplexing, we maintain a tree of the following
--   types, where <tt>&gt;</tt> should be read as “contains”:
--   
--   <pre>
--   <tt>SubscriptionsState</tt> &gt; <tt>Poller</tt> &gt; <tt>Cohort</tt> &gt; <tt>Subscriber</tt>
--   </pre>
--   
--   Here’s a brief summary of each type’s role:
--   
--   <ul>
--   <li>A <tt>Subscriber</tt> is an actual client with an open websocket
--   connection.</li>
--   <li>A <tt>Cohort</tt> is a set of <tt>Subscriber</tt>s that are all
--   subscribed to the same query /with the exact same variables/. (By
--   batching these together, we can do better than multiplexing, since we
--   can just query the data once.)</li>
--   <li>A <tt>Poller</tt> is a worker thread for a single, multiplexed
--   query. It fetches data for a set of <tt>Cohort</tt>s that all use the
--   same parameterized query, but have different sets of variables.</li>
--   <li>Finally, the <tt>SubscriptionsState</tt> is the top-level
--   container that holds all the active <tt>Poller</tt>s.</li>
--   </ul>
--   
--   Additional details are provided by the documentation for individual
--   bindings.
module Hasura.GraphQL.Execute.Subscription.Plan

-- | When running multiplexed queries, we have to be especially careful
--   about user input, since invalid values will cause the query to fail,
--   causing collateral damage for anyone else multiplexed into the same
--   query. Therefore, we pre-validate variables against Postgres by
--   executing a no-op query of the shape
--   
--   <pre>
--   SELECT 'v1'::t1, 'v2'::t2, ..., 'vn'::tn
--   </pre>
--   
--   so if any variable values are invalid, the error will be caught early.
newtype ValidatedVariables f
ValidatedVariables :: f TxtEncodedVal -> ValidatedVariables f
[_unValidatedVariables] :: ValidatedVariables f -> f TxtEncodedVal
unValidatedVariables :: forall f_adqXd f_adr5e. Iso (ValidatedVariables f_adqXd) (ValidatedVariables f_adr5e) (f_adqXd TxtEncodedVal) (f_adr5e TxtEncodedVal)
type ValidatedQueryVariables = ValidatedVariables (HashMap Name)
type ValidatedSyntheticVariables = ValidatedVariables []
type ValidatedCursorVariables = ValidatedVariables (HashMap Name)
mkUnsafeValidateVariables :: f TxtEncodedVal -> ValidatedVariables f
newtype CohortId
CohortId :: UUID -> CohortId
[unCohortId] :: CohortId -> UUID
newCohortId :: MonadIO m => m CohortId
dummyCohortId :: CohortId
data CohortVariables
CohortVariables :: !SessionVariables -> !ValidatedQueryVariables -> !ValidatedSyntheticVariables -> !ValidatedCursorVariables -> CohortVariables
[_cvSessionVariables] :: CohortVariables -> !SessionVariables
[_cvQueryVariables] :: CohortVariables -> !ValidatedQueryVariables

-- | To allow more queries to be multiplexed together, we introduce
--   “synthetic” variables for <i>all</i> SQL literals in a query, even if
--   they don’t correspond to any GraphQL variable. For example, the query
--   
--   <pre>
--   subscription latest_tracks($condition: tracks_bool_exp!) {
--     tracks(where: $tracks_bool_exp) {
--       id
--       title
--     }
--   }
--   </pre>
--   
--   might be executed with similar values for <tt>$condition</tt>, such as
--   <tt>{"album_id": {"_eq": "1"}}</tt> and <tt>{"album_id": {"_eq":
--   "2"}}</tt>.
--   
--   Normally, we wouldn’t bother parameterizing over the <tt>1</tt> and
--   <tt>2</tt> literals in the resulting query because we can’t cache that
--   query plan (since different <tt>$condition</tt> values could lead to
--   different SQL). However, for live queries, we can still take advantage
--   of the similarity between the two queries by multiplexing them
--   together, so we replace them with references to synthetic variables.
[_cvSyntheticVariables] :: CohortVariables -> !ValidatedSyntheticVariables

-- | Cursor variables contain the latest value of the cursor. The value of
--   the cursor variables are updated after every poll. If the value has
--   been changed - see [Streaming subscription polling]. Cursor variables
--   are only used in the case of streaming subscriptions, for live queries
--   it will be empty.
[_cvCursorVariables] :: CohortVariables -> !ValidatedCursorVariables
cvSyntheticVariables :: Lens' CohortVariables ValidatedSyntheticVariables
cvSessionVariables :: Lens' CohortVariables SessionVariables
cvQueryVariables :: Lens' CohortVariables ValidatedQueryVariables
cvCursorVariables :: Lens' CohortVariables ValidatedCursorVariables
modifyCursorCohortVariables :: ValidatedCursorVariables -> CohortVariables -> CohortVariables

-- | Builds a cohort's variables by only using the session variables that
--   are required for the subscription
mkCohortVariables :: HashSet SessionVariable -> SessionVariables -> ValidatedQueryVariables -> ValidatedSyntheticVariables -> ValidatedCursorVariables -> CohortVariables
newtype CohortIdArray
CohortIdArray :: [CohortId] -> CohortIdArray
[unCohortIdArray] :: CohortIdArray -> [CohortId]
newtype CohortVariablesArray
CohortVariablesArray :: [CohortVariables] -> CohortVariablesArray
[unCohortVariablesArray] :: CohortVariablesArray -> [CohortVariables]

-- | A self-contained, ready-to-execute subscription plan. Contains enough
--   information to find an existing poller that this can be added to
--   <i>or</i> to create a new poller if necessary.
data SubscriptionQueryPlan (b :: BackendType) q
SubscriptionQueryPlan :: !ParameterizedSubscriptionQueryPlan b q -> !SourceConfig b -> !CohortVariables -> !Maybe Name -> SubscriptionQueryPlan (b :: BackendType) q
[_sqpParameterizedPlan] :: SubscriptionQueryPlan (b :: BackendType) q -> !ParameterizedSubscriptionQueryPlan b q
[_sqpSourceConfig] :: SubscriptionQueryPlan (b :: BackendType) q -> !SourceConfig b
[_sqpVariables] :: SubscriptionQueryPlan (b :: BackendType) q -> !CohortVariables

-- | We need to know if the source has a namespace so that we can wrap it
--   around the response from the DB
[_sqpNamespace] :: SubscriptionQueryPlan (b :: BackendType) q -> !Maybe Name
data ParameterizedSubscriptionQueryPlan (b :: BackendType) q
ParameterizedSubscriptionQueryPlan :: !RoleName -> !q -> ParameterizedSubscriptionQueryPlan (b :: BackendType) q
[_plqpRole] :: ParameterizedSubscriptionQueryPlan (b :: BackendType) q -> !RoleName
[_plqpQuery] :: ParameterizedSubscriptionQueryPlan (b :: BackendType) q -> !q
data SubscriptionQueryPlanExplanation
SubscriptionQueryPlanExplanation :: !Text -> ![Text] -> !CohortVariables -> SubscriptionQueryPlanExplanation
[_sqpeSql] :: SubscriptionQueryPlanExplanation -> !Text
[_sqpePlan] :: SubscriptionQueryPlanExplanation -> ![Text]
[_sqpeVariables] :: SubscriptionQueryPlanExplanation -> !CohortVariables
newtype CursorVariableValues
CursorVariableValues :: HashMap Name TxtEncodedVal -> CursorVariableValues
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.SubscriptionQueryPlanExplanation
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.SubscriptionQueryPlanExplanation
instance Data.Aeson.Types.ToJSON.ToJSON q => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Execute.Subscription.Plan.ParameterizedSubscriptionQueryPlan b q)
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortIdArray
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortIdArray
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortVariablesArray
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortVariablesArray
instance GHC.Show.Show q => GHC.Show.Show (Hasura.GraphQL.Execute.Subscription.Plan.ParameterizedSubscriptionQueryPlan b q)
instance Database.PG.Query.Class.ToPrepArg Hasura.GraphQL.Execute.Subscription.Plan.CohortVariablesArray
instance Database.PG.Query.Class.ToPrepArg Hasura.GraphQL.Execute.Subscription.Plan.CohortIdArray
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance Database.PG.Query.Class.FromCol Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance GHC.Show.Show (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Show.Show (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance GHC.Classes.Eq (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Classes.Eq (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance Data.Hashable.Class.Hashable (f Hasura.SQL.Value.TxtEncodedVal) => Data.Hashable.Class.Hashable (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance Data.Aeson.Types.ToJSON.ToJSON (f Hasura.SQL.Value.TxtEncodedVal) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance GHC.Base.Semigroup (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Base.Semigroup (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance GHC.Base.Monoid (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Base.Monoid (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)


-- | Postgres Types Update
--   
--   This module defines the Update-related IR types specific to Postgres.
module Hasura.Backends.Postgres.Types.Update

-- | Represents an entry in an <i>update_table_many</i> update.
data MultiRowUpdate pgKind v
MultiRowUpdate :: AnnBoolExp ('Postgres pgKind) v -> HashMap PGCol (UpdateOpExpression v) -> MultiRowUpdate pgKind v

-- | The <i>where</i> clause for each individual update.
--   
--   Note that the <i>single</i> updates do not have a where clause,
--   because it uses the one found in <a>AnnotatedUpdateG</a>. However, we
--   have one for each update for <i>update_many</i>.
[mruWhere] :: MultiRowUpdate pgKind v -> AnnBoolExp ('Postgres pgKind) v

-- | The <i>update</i> expression, e.g, "set", "inc", etc., for each
--   column.
[mruExpression] :: MultiRowUpdate pgKind v -> HashMap PGCol (UpdateOpExpression v)

-- | The PostgreSQL-specific data of an Update expression.
--   
--   This is parameterised over <tt>v</tt> which enables different phases
--   of IR transformation to maintain the overall structure while
--   enriching/transforming the data at the leaves.
data BackendUpdate pgKind v

-- | The update operations to perform on each colum.
BackendUpdate :: HashMap PGCol (UpdateOpExpression v) -> BackendUpdate pgKind v

-- | The update operations to perform, in sequence, for an
--   <i>update_table_many</i> operation.
BackendMultiRowUpdate :: [MultiRowUpdate pgKind v] -> BackendUpdate pgKind v

-- | Are we updating anything?
isEmpty :: BackendUpdate pgKind v -> Bool

-- | The various <tt>update operators</tt> supported by PostgreSQL, i.e.
--   the <tt>_set</tt>, <tt>_inc</tt> operators that appear in the schema.
--   
--   See <a>Update Mutations User docs</a>
data UpdateOpExpression v
UpdateSet :: v -> UpdateOpExpression v
UpdateInc :: v -> UpdateOpExpression v
UpdateAppend :: v -> UpdateOpExpression v
UpdatePrepend :: v -> UpdateOpExpression v
UpdateDeleteKey :: v -> UpdateOpExpression v
UpdateDeleteElem :: v -> UpdateOpExpression v
UpdateDeleteAtPath :: [v] -> UpdateOpExpression v
instance GHC.Classes.Eq v => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance GHC.Show.Show v => GHC.Show.Show (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance Data.Data.Data v => Data.Data.Data (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance Data.Traversable.Traversable Hasura.Backends.Postgres.Types.Update.UpdateOpExpression
instance Data.Foldable.Foldable Hasura.Backends.Postgres.Types.Update.UpdateOpExpression
instance GHC.Base.Functor Hasura.Backends.Postgres.Types.Update.UpdateOpExpression
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Types.Update.MultiRowUpdate pgKind v)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Types.Update.BackendUpdate pgKind v)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind) => GHC.Base.Functor (Hasura.Backends.Postgres.Types.Update.MultiRowUpdate pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind) => Data.Foldable.Foldable (Hasura.Backends.Postgres.Types.Update.MultiRowUpdate pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind) => Data.Traversable.Traversable (Hasura.Backends.Postgres.Types.Update.MultiRowUpdate pgKind)
instance (Data.Data.Data v, Data.Typeable.Internal.Typeable pgKind, Data.Data.Data (Hasura.RQL.IR.BoolExp.AnnBoolExpFld ('Hasura.SQL.Backend.Postgres pgKind) v), Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind)) => Data.Data.Data (Hasura.Backends.Postgres.Types.Update.MultiRowUpdate pgKind v)
instance (GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpFld ('Hasura.SQL.Backend.Postgres pgKind) v), GHC.Show.Show (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v), Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind)) => GHC.Show.Show (Hasura.Backends.Postgres.Types.Update.MultiRowUpdate pgKind v)
instance (GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpFld ('Hasura.SQL.Backend.Postgres pgKind) v), GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v), Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind)) => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Update.MultiRowUpdate pgKind v)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind) => GHC.Base.Functor (Hasura.Backends.Postgres.Types.Update.BackendUpdate pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind) => Data.Foldable.Foldable (Hasura.Backends.Postgres.Types.Update.BackendUpdate pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind) => Data.Traversable.Traversable (Hasura.Backends.Postgres.Types.Update.BackendUpdate pgKind)
instance (Data.Data.Data v, Data.Typeable.Internal.Typeable pgKind, Data.Data.Data (Hasura.RQL.IR.BoolExp.AnnBoolExpFld ('Hasura.SQL.Backend.Postgres pgKind) v), Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind)) => Data.Data.Data (Hasura.Backends.Postgres.Types.Update.BackendUpdate pgKind v)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind), GHC.Show.Show (Hasura.Backends.Postgres.Types.Update.MultiRowUpdate pgKind v), GHC.Show.Show (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)) => GHC.Show.Show (Hasura.Backends.Postgres.Types.Update.BackendUpdate pgKind v)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind), GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Update.MultiRowUpdate pgKind v), GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)) => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Update.BackendUpdate pgKind v)


-- | Postgres Types Insert
--   
--   This module defines the Insert-related IR types specific to Postgres.
module Hasura.Backends.Postgres.Types.Insert

-- | The PostgreSQL-specific data of an Insert expression.
--   
--   This is parameterised over <tt>v</tt> which enables different phases
--   of IR transformation to maintain the overall structure while
--   enriching/transforming the data at the leaves.
newtype BackendInsert pgKind v
BackendInsert :: Maybe (OnConflictClause ('Postgres pgKind) v) -> BackendInsert pgKind v
[_biConflictClause] :: BackendInsert pgKind v -> Maybe (OnConflictClause ('Postgres pgKind) v)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind) => GHC.Base.Functor (Hasura.Backends.Postgres.Types.Insert.BackendInsert pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind) => Data.Foldable.Foldable (Hasura.Backends.Postgres.Types.Insert.BackendInsert pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind) => Data.Traversable.Traversable (Hasura.Backends.Postgres.Types.Insert.BackendInsert pgKind)


-- | Postgres Instances Types
--   
--   Defines a <a>Backend</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.Types

-- | This class is an implementation detail of <a>Backend</a>. Some types
--   of <a>Backend</a> differ across different Postgres "kinds". This class
--   alllows each "kind" to specify its own specific implementation. All
--   common code is directly part of the <a>Backend</a> instance.
--   
--   Note: Users shouldn't ever put this as a constraint. Use `Backend
--   ('Postgres pgKind)` instead.
class (Representable (PgExtraTableMetadata pgKind), ToJSON (PgExtraTableMetadata pgKind), FromJSON (PgExtraTableMetadata pgKind)) => PostgresBackend (pgKind :: PostgresKind) where {
    type family PgExtraTableMetadata pgKind :: Type;
}
instance Hasura.Backends.Postgres.Instances.Types.PostgresBackend 'Hasura.SQL.Backend.Vanilla
instance Hasura.Backends.Postgres.Instances.Types.PostgresBackend 'Hasura.SQL.Backend.Citus
instance Hasura.Backends.Postgres.Instances.Types.PostgresBackend 'Hasura.SQL.Backend.Cockroach
instance (Hasura.SQL.Tag.HasTag ('Hasura.SQL.Backend.Postgres pgKind), Data.Typeable.Internal.Typeable ('Hasura.SQL.Backend.Postgres pgKind), Hasura.Backends.Postgres.Instances.Types.PostgresBackend pgKind, Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.Backend.BackendSourceKind ('Hasura.SQL.Backend.Postgres pgKind))) => Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind)

module Hasura.RQL.DML.Types
newtype OrderByExp
OrderByExp :: [OrderByItem ('Postgres 'Vanilla)] -> OrderByExp
[getOrderByItems] :: OrderByExp -> [OrderByItem ('Postgres 'Vanilla)]
data DMLQuery a
DMLQuery :: SourceName -> QualifiedTable -> a -> DMLQuery a
getSourceDMLQuery :: forall a. DMLQuery a -> SourceName
data SelectG a b c
SelectG :: [a] -> Maybe b -> Maybe OrderByExp -> Maybe c -> Maybe c -> SelectG a b c
[sqColumns] :: SelectG a b c -> [a]
[sqWhere] :: SelectG a b c -> Maybe b
[sqOrderBy] :: SelectG a b c -> Maybe OrderByExp
[sqLimit] :: SelectG a b c -> Maybe c
[sqOffset] :: SelectG a b c -> Maybe c
data Wildcard
Star :: Wildcard
StarDot :: Wildcard -> Wildcard
parseWildcard :: Parser Wildcard
data SelCol
SCStar :: Wildcard -> SelCol
SCExtSimple :: PGCol -> SelCol
SCExtRel :: RelName -> Maybe RelName -> SelectQ -> SelCol
type SelectQ = SelectG SelCol (BoolExp ('Postgres 'Vanilla)) Int
type SelectQT = SelectG SelCol (BoolExp ('Postgres 'Vanilla)) Value
type SelectQuery = DMLQuery SelectQ
type SelectQueryT = DMLQuery SelectQT
type InsObj b = ColumnValues b Value
data ConflictAction
CAIgnore :: ConflictAction
CAUpdate :: ConflictAction
newtype ConstraintOn
ConstraintOn :: [PGCol] -> ConstraintOn
[getPGCols] :: ConstraintOn -> [PGCol]
data OnConflict
OnConflict :: Maybe ConstraintOn -> Maybe ConstraintName -> ConflictAction -> OnConflict
[ocConstraintOn] :: OnConflict -> Maybe ConstraintOn
[ocConstraint] :: OnConflict -> Maybe ConstraintName
[ocAction] :: OnConflict -> ConflictAction
data InsertQuery
InsertQuery :: QualifiedTable -> SourceName -> Value -> Maybe OnConflict -> Maybe [PGCol] -> InsertQuery
[iqTable] :: InsertQuery -> QualifiedTable
[iqSource] :: InsertQuery -> SourceName
[iqObjects] :: InsertQuery -> Value
[iqOnConflict] :: InsertQuery -> Maybe OnConflict
[iqReturning] :: InsertQuery -> Maybe [PGCol]
type UpdVals b = ColumnValues b Value
data UpdateQuery
UpdateQuery :: QualifiedTable -> SourceName -> BoolExp ('Postgres 'Vanilla) -> UpdVals ('Postgres 'Vanilla) -> UpdVals ('Postgres 'Vanilla) -> UpdVals ('Postgres 'Vanilla) -> [PGCol] -> Maybe [PGCol] -> UpdateQuery
[uqTable] :: UpdateQuery -> QualifiedTable
[uqSource] :: UpdateQuery -> SourceName
[uqWhere] :: UpdateQuery -> BoolExp ('Postgres 'Vanilla)
[uqSet] :: UpdateQuery -> UpdVals ('Postgres 'Vanilla)
[uqInc] :: UpdateQuery -> UpdVals ('Postgres 'Vanilla)
[uqMul] :: UpdateQuery -> UpdVals ('Postgres 'Vanilla)
[uqDefault] :: UpdateQuery -> [PGCol]
[uqReturning] :: UpdateQuery -> Maybe [PGCol]
data DeleteQuery
DeleteQuery :: QualifiedTable -> SourceName -> BoolExp ('Postgres 'Vanilla) -> Maybe [PGCol] -> DeleteQuery
[doTable] :: DeleteQuery -> QualifiedTable
[doSource] :: DeleteQuery -> SourceName
[doWhere] :: DeleteQuery -> BoolExp ('Postgres 'Vanilla)
[doReturning] :: DeleteQuery -> Maybe [PGCol]
data CountQuery
CountQuery :: QualifiedTable -> SourceName -> Maybe [PGCol] -> Maybe (BoolExp ('Postgres 'Vanilla)) -> CountQuery
[cqTable] :: CountQuery -> QualifiedTable
[cqSource] :: CountQuery -> SourceName
[cqDistinct] :: CountQuery -> Maybe [PGCol]
[cqWhere] :: CountQuery -> Maybe (BoolExp ('Postgres 'Vanilla))
data QueryT
QTInsert :: InsertQuery -> QueryT
QTSelect :: SelectQueryT -> QueryT
QTUpdate :: UpdateQuery -> QueryT
QTDelete :: DeleteQuery -> QueryT
QTCount :: CountQuery -> QueryT
QTBulk :: [QueryT] -> QueryT
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.QueryT
instance GHC.Classes.Eq Hasura.RQL.DML.Types.InsertQuery
instance GHC.Show.Show Hasura.RQL.DML.Types.InsertQuery
instance GHC.Classes.Eq Hasura.RQL.DML.Types.UpdateQuery
instance GHC.Show.Show Hasura.RQL.DML.Types.UpdateQuery
instance GHC.Classes.Eq Hasura.RQL.DML.Types.DeleteQuery
instance GHC.Show.Show Hasura.RQL.DML.Types.DeleteQuery
instance GHC.Classes.Eq Hasura.RQL.DML.Types.CountQuery
instance GHC.Show.Show Hasura.RQL.DML.Types.CountQuery
instance GHC.Classes.Eq Hasura.RQL.DML.Types.QueryT
instance GHC.Show.Show Hasura.RQL.DML.Types.QueryT
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.CountQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.DeleteQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.UpdateQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.InsertQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.OnConflict
instance GHC.Classes.Ord Hasura.RQL.DML.Types.Wildcard
instance GHC.Classes.Eq Hasura.RQL.DML.Types.Wildcard
instance GHC.Show.Show Hasura.RQL.DML.Types.Wildcard
instance GHC.Classes.Eq Hasura.RQL.DML.Types.SelCol
instance GHC.Show.Show Hasura.RQL.DML.Types.SelCol
instance GHC.Classes.Eq Hasura.RQL.DML.Types.ConflictAction
instance GHC.Show.Show Hasura.RQL.DML.Types.ConflictAction
instance GHC.Classes.Eq Hasura.RQL.DML.Types.ConstraintOn
instance GHC.Show.Show Hasura.RQL.DML.Types.ConstraintOn
instance GHC.Classes.Eq Hasura.RQL.DML.Types.OnConflict
instance GHC.Show.Show Hasura.RQL.DML.Types.OnConflict
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.ConstraintOn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.ConflictAction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.SelCol
instance (Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON b, Data.Aeson.Types.FromJSON.FromJSON c) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DML.Types.SelectG a b c)
instance GHC.Classes.Eq Hasura.RQL.DML.Types.OrderByExp
instance GHC.Show.Show Hasura.RQL.DML.Types.OrderByExp
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.DML.Types.DMLQuery a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.DML.Types.DMLQuery a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (Hasura.RQL.DML.Types.SelectG a b c)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => GHC.Show.Show (Hasura.RQL.DML.Types.SelectG a b c)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DML.Types.DMLQuery a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.OrderByExp


-- | Postgres Types Column
--   
--   Gets the Postgres type used to represent a column, defaulting to Text
--   when unsure.
module Hasura.Backends.Postgres.Types.Column

-- | Gets the representation type associated with a <a>ColumnType</a>.
--   Avoid using this if possible. Prefer <tt>parsePGScalarValue</tt>,
--   <tt>parsePGScalarValues</tt>, or <a>mkTypedSessionVar</a>.
unsafePGColumnToBackend :: ColumnType ('Postgres pgKind) -> PGScalarType


-- | Postgres Translate Column
--   
--   Translate column values to Postgres-specific SQL expressions.
module Hasura.Backends.Postgres.Translate.Column
toTxtValue :: ColumnValue ('Postgres pgKind) -> SQLExp

-- | Formats each columns to appropriate SQL expression
toJSONableExp :: StringifyNumbers -> ColumnType ('Postgres pgKind) -> Bool -> Maybe NamingCase -> SQLExp -> SQLExp


-- | Postgres DDL Source Version
--   
--   Deals with catalog version - used by <a>Source</a>.
module Hasura.Backends.Postgres.DDL.Source.Version
type SourceCatalogVersion (pgKind :: PostgresKind) = SourceCatalogVersion ('Postgres pgKind)
initialSourceCatalogVersion :: SourceCatalogVersion pgKind
latestSourceCatalogVersion :: SourceCatalogVersion pgKind
previousSourceCatalogVersions :: [SourceCatalogVersion pgKind]
setSourceCatalogVersion :: MonadTx m => m ()
getSourceCatalogVersion :: MonadTx m => m (SourceCatalogVersion postgres)


-- | MSSQL Types Internal
--   
--   Types for Transact-SQL aka T-SQL; the language of SQL Server.
--   
--   In this module we define various MS SQL Server specific data types
--   used for T-SQL generation.
--   
--   These types are also used as underlying types in the <tt>Backend
--   'MSSQL</tt> instance which is defined in
--   <a>Hasura.Backends.MSSQL.Instances.Types</a>.
--   
--   We convert RQL IR ASTs to types defined here in the
--   <a>Hasura.Backends.MSSQL.FromIr</a> module, and we implement
--   pretty-printing for these types in the
--   <a>Hasura.Backends.MSSQL.ToQuery</a> module.
--   
--   NOTE: Various type class instances (including simple once such as Eq
--   and Show) are implemented in the
--   <a>Hasura.Backends.MSSQL.Types.Instances</a> module.
module Hasura.Backends.MSSQL.Types.Internal
type Column (b :: BackendType) = ColumnName
type ColumnType (b :: BackendType) = ScalarType
type Value = Value
data UnifiedColumn
UnifiedColumn :: ColumnName -> ScalarType -> UnifiedColumn
[$sel:name:UnifiedColumn] :: UnifiedColumn -> ColumnName
[$sel:type':UnifiedColumn] :: UnifiedColumn -> ScalarType
data UnifiedTableName
UnifiedTableName :: Text -> Text -> UnifiedTableName
[$sel:schema:UnifiedTableName] :: UnifiedTableName -> Text
[$sel:name:UnifiedTableName] :: UnifiedTableName -> Text
data UnifiedObjectRelationship
UnifiedObjectRelationship :: UnifiedUsing -> Text -> UnifiedObjectRelationship
[$sel:using:UnifiedObjectRelationship] :: UnifiedObjectRelationship -> UnifiedUsing
[$sel:name:UnifiedObjectRelationship] :: UnifiedObjectRelationship -> Text
data UnifiedArrayRelationship
UnifiedArrayRelationship :: UnifiedUsing -> Text -> UnifiedArrayRelationship
[$sel:using:UnifiedArrayRelationship] :: UnifiedArrayRelationship -> UnifiedUsing
[$sel:name:UnifiedArrayRelationship] :: UnifiedArrayRelationship -> Text
newtype UnifiedUsing
UnifiedUsing :: UnifiedOn -> UnifiedUsing
[$sel:foreign_key_constraint_on:UnifiedUsing] :: UnifiedUsing -> UnifiedOn
data UnifiedOn
UnifiedOn :: UnifiedTableName -> Text -> UnifiedOn
[$sel:table:UnifiedOn] :: UnifiedOn -> UnifiedTableName
[$sel:column:UnifiedOn] :: UnifiedOn -> Text
data BooleanOperators a
ASTContains :: a -> BooleanOperators a
ASTCrosses :: a -> BooleanOperators a
ASTEquals :: a -> BooleanOperators a
ASTIntersects :: a -> BooleanOperators a
ASTOverlaps :: a -> BooleanOperators a
ASTTouches :: a -> BooleanOperators a
ASTWithin :: a -> BooleanOperators a
data Select
Select :: Maybe With -> Top -> [Projection] -> Maybe From -> [Join] -> Where -> For -> Maybe (NonEmpty OrderBy) -> Maybe Expression -> Select
[$sel:selectWith:Select] :: Select -> Maybe With
[$sel:selectTop:Select] :: Select -> Top
[$sel:selectProjections:Select] :: Select -> [Projection]
[$sel:selectFrom:Select] :: Select -> Maybe From
[$sel:selectJoins:Select] :: Select -> [Join]
[$sel:selectWhere:Select] :: Select -> Where
[$sel:selectFor:Select] :: Select -> For
[$sel:selectOrderBy:Select] :: Select -> Maybe (NonEmpty OrderBy)
[$sel:selectOffset:Select] :: Select -> Maybe Expression
emptySelect :: Select
newtype OutputColumn
OutputColumn :: ColumnName -> OutputColumn
[$sel:unOutputColumn:OutputColumn] :: OutputColumn -> ColumnName
data Inserted
Inserted :: Inserted
data Deleted
Deleted :: Deleted
data Output t
Output :: t -> [OutputColumn] -> Output t
[$sel:outputType:Output] :: Output t -> t
[$sel:outputColumns:Output] :: Output t -> [OutputColumn]
type InsertOutput = Output Inserted
newtype Values
Values :: [Expression] -> Values
data Insert
Insert :: TableName -> [ColumnName] -> InsertOutput -> TempTable -> [Values] -> Insert
[$sel:insertTable:Insert] :: Insert -> TableName
[$sel:insertColumns:Insert] :: Insert -> [ColumnName]
[$sel:insertOutput:Insert] :: Insert -> InsertOutput
[$sel:insertTempTable:Insert] :: Insert -> TempTable
[$sel:insertValues:Insert] :: Insert -> [Values]
data SetValue
SetON :: SetValue
SetOFF :: SetValue
data SetIdentityInsert
SetIdentityInsert :: SomeTableName -> SetValue -> SetIdentityInsert
[$sel:setTable:SetIdentityInsert] :: SetIdentityInsert -> SomeTableName
[$sel:setValue:SetIdentityInsert] :: SetIdentityInsert -> SetValue
type DeleteOutput = Output Deleted
data Delete
Delete :: Aliased TableName -> DeleteOutput -> TempTable -> Where -> Delete
[$sel:deleteTable:Delete] :: Delete -> Aliased TableName
[$sel:deleteOutput:Delete] :: Delete -> DeleteOutput
[$sel:deleteTempTable:Delete] :: Delete -> TempTable
[$sel:deleteWhere:Delete] :: Delete -> Where

-- | MERGE statement. Used for upserts and is responsible for actually
--   inserting or updating the data in the table.
data Merge
Merge :: TableName -> MergeUsing -> MergeOn -> MergeWhenMatched -> MergeWhenNotMatched -> InsertOutput -> TempTable -> Merge
[$sel:mergeTargetTable:Merge] :: Merge -> TableName
[$sel:mergeUsing:Merge] :: Merge -> MergeUsing
[$sel:mergeOn:Merge] :: Merge -> MergeOn
[$sel:mergeWhenMatched:Merge] :: Merge -> MergeWhenMatched
[$sel:mergeWhenNotMatched:Merge] :: Merge -> MergeWhenNotMatched
[$sel:mergeInsertOutput:Merge] :: Merge -> InsertOutput
[$sel:mergeOutputTempTable:Merge] :: Merge -> TempTable

-- | The <tt>USING</tt> section of a <tt>MERGE</tt> statement. Specifies
--   the temp table schema where the input values are.
data MergeUsing
MergeUsing :: TempTableName -> [ColumnName] -> MergeUsing
[$sel:mergeUsingTempTable:MergeUsing] :: MergeUsing -> TempTableName
[$sel:mergeUsingColumns:MergeUsing] :: MergeUsing -> [ColumnName]

-- | The <tt>ON</tt> section of a <tt>MERGE</tt> statement. Which columns
--   to match on?
data MergeOn
MergeOn :: [ColumnName] -> MergeOn
[$sel:mergeOnColumns:MergeOn] :: MergeOn -> [ColumnName]

-- | The <tt>WHEN MATCHED</tt> section of a <tt>MERGE</tt> statement. Which
--   columns to update when <tt>match_columns</tt> match (including
--   presets), and on which condition to actually update the values.
data MergeWhenMatched
MergeWhenMatched :: [ColumnName] -> Expression -> HashMap ColumnName Expression -> MergeWhenMatched
[$sel:mwmUpdateColumns:MergeWhenMatched] :: MergeWhenMatched -> [ColumnName]
[$sel:mwmCondition:MergeWhenMatched] :: MergeWhenMatched -> Expression
[$sel:mwmUpdatePreset:MergeWhenMatched] :: MergeWhenMatched -> HashMap ColumnName Expression

-- | The <tt>WHEN MATCHED</tt> section of a <tt>MERGE</tt> statement. Which
--   columns to insert?
newtype MergeWhenNotMatched
MergeWhenNotMatched :: [ColumnName] -> MergeWhenNotMatched
[$sel:mergeWhenNotMatchedInsertColumns:MergeWhenNotMatched] :: MergeWhenNotMatched -> [ColumnName]

-- | SELECT INTO temporary table statement without values. Used to create a
--   temporary table with the same schema as an existing table.
data SelectIntoTempTable
SelectIntoTempTable :: TempTableName -> [UnifiedColumn] -> TableName -> SITTConstraints -> SelectIntoTempTable
[$sel:sittTempTableName:SelectIntoTempTable] :: SelectIntoTempTable -> TempTableName
[$sel:sittColumns:SelectIntoTempTable] :: SelectIntoTempTable -> [UnifiedColumn]
[$sel:sittFromTableName:SelectIntoTempTable] :: SelectIntoTempTable -> TableName
[$sel:sittConstraints:SelectIntoTempTable] :: SelectIntoTempTable -> SITTConstraints

-- | When creating a temporary table from an existing table schema, what
--   should we do with the constraints (such as <tt>IDENTITY</tt>?)
data SITTConstraints
KeepConstraints :: SITTConstraints
RemoveConstraints :: SITTConstraints

-- | Simple insert into a temporary table.
data InsertValuesIntoTempTable
InsertValuesIntoTempTable :: TempTableName -> [ColumnName] -> [Values] -> InsertValuesIntoTempTable
[$sel:ivittTempTableName:InsertValuesIntoTempTable] :: InsertValuesIntoTempTable -> TempTableName
[$sel:ivittColumns:InsertValuesIntoTempTable] :: InsertValuesIntoTempTable -> [ColumnName]
[$sel:ivittValues:InsertValuesIntoTempTable] :: InsertValuesIntoTempTable -> [Values]

-- | A temporary table name is prepended by a hash-sign
newtype TempTableName
TempTableName :: Text -> TempTableName

-- | A name of a regular table or temporary table
data SomeTableName
RegularTableName :: TableName -> SomeTableName
TemporaryTableName :: TempTableName -> SomeTableName
data TempTable
TempTable :: TempTableName -> [ColumnName] -> TempTable
[$sel:ttName:TempTable] :: TempTable -> TempTableName
[$sel:ttColumns:TempTable] :: TempTable -> [ColumnName]

-- | A version of <a>Select</a> without a <tt>FROM</tt> clause. This means
--   it can only project expressions already selected in adjacent join
--   clauses, hence the name <tt>reselect</tt>.
data Reselect
Reselect :: [Projection] -> For -> Where -> Reselect
[$sel:reselectProjections:Reselect] :: Reselect -> [Projection]
[$sel:reselectFor:Reselect] :: Reselect -> For
[$sel:reselectWhere:Reselect] :: Reselect -> Where
data OrderBy
OrderBy :: FieldName -> Order -> NullsOrder -> Maybe ScalarType -> OrderBy
[$sel:orderByFieldName:OrderBy] :: OrderBy -> FieldName
[$sel:orderByOrder:OrderBy] :: OrderBy -> Order
[$sel:orderByNullsOrder:OrderBy] :: OrderBy -> NullsOrder
[$sel:orderByType:OrderBy] :: OrderBy -> Maybe ScalarType
data Order
AscOrder :: Order
DescOrder :: Order
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder
NullsAnyOrder :: NullsOrder
data For
JsonFor :: ForJson -> For
NoFor :: For
data ForJson
ForJson :: JsonCardinality -> Root -> ForJson
[$sel:jsonCardinality:ForJson] :: ForJson -> JsonCardinality
[$sel:jsonRoot:ForJson] :: ForJson -> Root
data Root
NoRoot :: Root
Root :: Text -> Root
data JsonCardinality
JsonArray :: JsonCardinality
JsonSingleton :: JsonCardinality
data Projection
ExpressionProjection :: Aliased Expression -> Projection
FieldNameProjection :: Aliased FieldName -> Projection
AggregateProjection :: Aliased Aggregate -> Projection
StarProjection :: Projection
data Join
Join :: JoinSource -> JoinAlias -> Join
[$sel:joinSource:Join] :: Join -> JoinSource
[$sel:joinJoinAlias:Join] :: Join -> JoinAlias
data JoinSource
JoinSelect :: Select -> JoinSource
JoinReselect :: Reselect -> JoinSource
data JoinAlias
JoinAlias :: Text -> Maybe Text -> JoinAlias
[$sel:joinAliasEntity:JoinAlias] :: JoinAlias -> Text
[$sel:joinAliasField:JoinAlias] :: JoinAlias -> Maybe Text
newtype Where
Where :: [Expression] -> Where
newtype With
With :: NonEmpty (Aliased Select) -> With
data Top
NoTop :: Top
Top :: Int -> Top
data Expression
ValueExpression :: Value -> Expression
AndExpression :: [Expression] -> Expression
OrExpression :: [Expression] -> Expression
NotExpression :: Expression -> Expression
ExistsExpression :: Select -> Expression
SelectExpression :: Select -> Expression
IsNullExpression :: Expression -> Expression
IsNotNullExpression :: Expression -> Expression
ColumnExpression :: FieldName -> Expression

-- | This one acts like a "cast to JSON" and makes SQL Server behave like
--   it knows your field is JSON and not double-encode it.
JsonQueryExpression :: Expression -> Expression
ToStringExpression :: Expression -> Expression
MethodApplicationExpression :: Expression -> MethodApplicationExpression -> Expression
FunctionApplicationExpression :: FunctionApplicationExpression -> Expression

-- | This is for getting actual atomic values out of a JSON string.
JsonValueExpression :: Expression -> JsonPath -> Expression
OpExpression :: Op -> Expression -> Expression -> Expression
ListExpression :: [Expression] -> Expression
STOpExpression :: SpatialOp -> Expression -> Expression -> Expression
CastExpression :: Expression -> ScalarType -> DataLength -> Expression

-- | "CASE WHEN (expression) THEN (expression) ELSE (expression) END"
ConditionalExpression :: Expression -> Expression -> Expression -> Expression

-- | The <tt>DEFAULT</tt> value. TODO: Make this as a part of
--   @<a>Value</a>.
DefaultExpression :: Expression

-- | Data type describing the length of a datatype. Used in
--   <a>CastExpression</a>s.
data DataLength
DataLengthUnspecified :: DataLength
DataLengthInt :: Int -> DataLength
DataLengthMax :: DataLength

-- | SQL functions application: <tt>some_function(e1, e2, ..)</tt>.
data FunctionApplicationExpression
FunExpISNULL :: Expression -> Expression -> FunctionApplicationExpression

-- | Object expression method application: <tt>(expression).text(e1, e2,
--   ..)</tt>
data MethodApplicationExpression
MethExpSTAsText :: MethodApplicationExpression
data JsonPath
RootPath :: JsonPath
FieldPath :: JsonPath -> Text -> JsonPath
IndexPath :: JsonPath -> Integer -> JsonPath
data Aggregate
CountAggregate :: Countable FieldName -> Aggregate
OpAggregate :: Text -> [Expression] -> Aggregate
TextAggregate :: Text -> Aggregate
data Countable name
StarCountable :: Countable name
NonNullFieldCountable :: name -> Countable name
DistinctCountable :: name -> Countable name
data From
FromQualifiedTable :: Aliased TableName -> From
FromOpenJson :: Aliased OpenJson -> From
FromSelect :: Aliased Select -> From
FromIdentifier :: Text -> From
FromTempTable :: Aliased TempTableName -> From

-- | Extract the name bound in a <a>From</a> clause as an
--   <a>EntityAlias</a>.
fromAlias :: From -> EntityAlias
data OpenJson
OpenJson :: Expression -> Maybe (NonEmpty JsonFieldSpec) -> OpenJson
[$sel:openJsonExpression:OpenJson] :: OpenJson -> Expression
[$sel:openJsonWith:OpenJson] :: OpenJson -> Maybe (NonEmpty JsonFieldSpec)
data JsonFieldSpec
ScalarField :: ScalarType -> DataLength -> Text -> Maybe JsonPath -> JsonFieldSpec
JsonField :: Text -> Maybe JsonPath -> JsonFieldSpec
StringField :: Text -> Maybe JsonPath -> JsonFieldSpec
data Aliased a
Aliased :: a -> Text -> Aliased a
[$sel:aliasedThing:Aliased] :: Aliased a -> a
[$sel:aliasedAlias:Aliased] :: Aliased a -> Text
newtype SchemaName
SchemaName :: Text -> SchemaName
[$sel:_unSchemaName:SchemaName] :: SchemaName -> Text
data TableName
TableName :: Text -> SchemaName -> TableName
[$sel:tableName:TableName] :: TableName -> Text
[$sel:tableSchema:TableName] :: TableName -> SchemaName
data FieldName
FieldName :: Text -> Text -> FieldName
[$sel:fieldName:FieldName] :: FieldName -> Text
[$sel:fieldNameEntity:FieldName] :: FieldName -> Text
data Comment
DueToPermission :: Comment
RequestedSingleObject :: Comment
newtype EntityAlias
EntityAlias :: Text -> EntityAlias
[$sel:entityAliasText:EntityAlias] :: EntityAlias -> Text
columnNameToFieldName :: ColumnName -> EntityAlias -> FieldName
data Op
LT :: Op
LTE :: Op
GT :: Op
GTE :: Op
IN :: Op
LIKE :: Op
NLIKE :: Op
NIN :: Op
EQ' :: Op
NEQ' :: Op

-- | Supported operations for spatial data types
data SpatialOp
STEquals :: SpatialOp
STContains :: SpatialOp
STCrosses :: SpatialOp
STIntersects :: SpatialOp
STOverlaps :: SpatialOp
STWithin :: SpatialOp
STTouches :: SpatialOp

-- | Column name of some database table -- this differs to FieldName that
--   is used for referring to things within a query.
newtype ColumnName
ColumnName :: Text -> ColumnName
[$sel:columnNameText:ColumnName] :: ColumnName -> Text
newtype ConstraintName
ConstraintName :: Text -> ConstraintName
[$sel:constraintNameText:ConstraintName] :: ConstraintName -> Text
newtype FunctionName
FunctionName :: Text -> FunctionName
[$sel:functionNameText:FunctionName] :: FunctionName -> Text

-- | Derived from the odbc package.
data ScalarType
CharType :: ScalarType
NumericType :: ScalarType
DecimalType :: ScalarType
IntegerType :: ScalarType
SmallintType :: ScalarType
FloatType :: ScalarType
RealType :: ScalarType
DateType :: ScalarType
Ss_time2Type :: ScalarType
VarcharType :: ScalarType
WcharType :: ScalarType
WvarcharType :: ScalarType
WtextType :: ScalarType
TimestampType :: ScalarType
TextType :: ScalarType
BinaryType :: ScalarType
VarbinaryType :: ScalarType
BigintType :: ScalarType
TinyintType :: ScalarType
BitType :: ScalarType
GuidType :: ScalarType
GeographyType :: ScalarType
GeometryType :: ScalarType
UnknownType :: Text -> ScalarType
scalarTypeDBName :: DataLength -> ScalarType -> Text
fromDataLength :: DataLength -> Text
mkMSSQLScalarTypeName :: MonadError QErr m => ScalarType -> m Name
parseScalarValue :: ScalarType -> Value -> Either QErr Value
isComparableType :: ScalarType -> Bool
isNumType :: ScalarType -> Bool
getGQLTableName :: TableName -> Either QErr Name
snakeCaseTableName :: TableName -> Text
getTableIdentifier :: TableName -> Either QErr GQLNameIdentifier
namingConventionSupport :: SupportedNamingCase
stringTypes :: [ScalarType]
geoTypes :: [ScalarType]
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.String.IsString Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Base.Functor Hasura.Backends.MSSQL.Types.Internal.Countable

module Hasura.Backends.MSSQL.DDL.Source.Version
type SourceCatalogVersion = SourceCatalogVersion 'MSSQL
initialSourceCatalogVersion :: SourceCatalogVersion
latestSourceCatalogVersion :: SourceCatalogVersion
previousSourceCatalogVersions :: [SourceCatalogVersion]
setSourceCatalogVersion :: MonadMSSQLTx m => SourceCatalogVersion -> m ()
getSourceCatalogVersion :: MonadMSSQLTx m => m SourceCatalogVersion


-- | Dispatch over backends.
--   
--   <h1>Creating and consuming <a>AnyBackend</a></h1>
--   
--   Creating a new value of type <a>AnyBackend</a> is done via
--   <a>mkAnyBackend</a>.
--   
--   Consuming a value of type <a>AnyBackend</a> is done via either
--   <tt>runAnyBackend</tt> or any of the dispatch functions
--   (<a>dispatchAnyBackend</a>, <a>dispatchAnyBackend'</a>,
--   <a>dispatchAnyBackend''</a>).
--   
--   For implementation details, or when trying to understand this module,
--   start from <a>AnyBackend</a>.
--   
--   <h1>Backend Architecture</h1>
--   
--   Our multiple backend architecture uses type classes and associated
--   types in order to share code, such as parsing graphql queries,
--   building schemas and metadata, while still accounting for the
--   differences between backends.
--   
--   Each backend implements the <tt>Backend</tt> type class from
--   <a>Hasura.RQL.Types.Backend</a> as well as instances for other classes
--   such as <tt>BackendSchema</tt> from
--   <a>Hasura.GraphQL.Schema.Backend</a>, and define the associated types
--   and functions, such as <tt>ScalarType</tt> and
--   <tt>parseScalarValue</tt>, which fit the backend.
--   
--   Whenever one of these associated types (<tt>ScalarType</tt>,
--   <tt>Column</tt>, etc.) are used, we need to either push the
--   <a>BackendType</a> to our caller (and making our type <tt>BackendType
--   -&gt; Type</tt>), or use <a>AnyBackend</a> (and allow our type to be
--   <a>Type</a>). This is particularly useful when we need to store a
--   container of any backend.
--   
--   In order to actually program abstractly using type classes, we need
--   the type class instances to be available for us to use. This module is
--   a trick to enumerate all supported backends and their respective
--   instances to convince GHC that they can be used.
--   
--   <h1>Example usage</h1>
--   
--   As an example of using this module, consider wanting to write a
--   function that calculates metrics for each source. For example, we want
--   to count the number of tables each source has.
--   
--   The <tt>SchemaCache</tt> (defined in
--   <a>Hasura.RQL.Types.SchemaCache</a>) holds a hash map from each source
--   to their information. The source information is parameterized by the
--   <a>BackendType</a> and is hidden using an existential type inside
--   <a>AnyBackend</a>. It essentially looks like this:
--   
--   <pre>
--   data SourceInfo b = ...
--   
--   type SourceCache = HashMap SourceName (AnyBackend SourceInfo)
--   </pre>
--   
--   Our metrics calculation function cares which backend it receives, but
--   only for its type class instances so it can call the relevant
--   functions:
--   
--   <pre>
--   telemetryForSource :: forall (b :: BackendType). SourceInfo b -&gt; TelemetryPayload
--   </pre>
--   
--   In order to apply this function to all backends and return the
--   telemetry payload for each, we need to map over the hash map and
--   dispatch the function over the relevant backend. we can do this with
--   <a>runBackend</a>:
--   
--   <pre>
--   telemetries =
--     map
--       (`runBackend` telemetryForSource)
--       (scSources schemaCache)
--   </pre>
--   
--   If we want to be able to extract some information about the backend
--   type inside <tt>telemetryForSource</tt>, we can do this using
--   <a>backendTag</a>:
--   
--   <pre>
--   let telemetryForSource :: forall (b :: BackendType). HasTag b =&gt; SourceInfo b -&gt; TelemetryPayload
--       telemetryForSource =
--         let dbKind = reify (backendTag @b)
--   </pre>
--   
--   Note that we needed to add the <a>HasTag</a> constraint, which now
--   means we can't use <a>runBackend</a> because our function has the
--   wrong type (it has an extra constraint). Instead, we can use
--   <a>dispatchAnyBackend</a> which allows us to have one constraint:
--   
--   <pre>
--   telemetries =
--     fmap
--       (\sourceinfo -&gt; (Any.dispatchAnyBackend @HasTag) sourceinfo telemetryForSource)
--       (scSources schemaCache)
--   </pre>
--   
--   Note that we had to add the constraint name as a type application, and
--   we had to explicitly add a lambda instead of using <a>flip</a>.
module Hasura.SQL.AnyBackend

-- | Allows storing types of kind <tt>BackendType -&gt; Type</tt>
--   heterogenously.
--   
--   Adding a new constructor to <a>BackendType</a> will automatically
--   create a new constructor here.
--   
--   Given some type defined as <tt>data T (b :: BackendType) = ...</tt>,
--   we can define <tt>AnyBackend T</tt> without mentioning any
--   <a>BackendType</a>.
--   
--   This is useful for having generic containers of potentially different
--   types of T. For instance, <tt>SourceCache</tt> is defined as a
--   <tt>HashMap SourceName (AnyBackend SourceInfo)</tt>.
data AnyBackend (i :: BackendType -> Type)
PostgresVanillaValue :: i ('Postgres 'Vanilla) -> AnyBackend (i :: BackendType -> Type)
PostgresCitusValue :: i ('Postgres 'Citus) -> AnyBackend (i :: BackendType -> Type)
PostgresCockroachValue :: i ('Postgres 'Cockroach) -> AnyBackend (i :: BackendType -> Type)
MSSQLValue :: i 'MSSQL -> AnyBackend (i :: BackendType -> Type)
BigQueryValue :: i 'BigQuery -> AnyBackend (i :: BackendType -> Type)
MySQLValue :: i 'MySQL -> AnyBackend (i :: BackendType -> Type)
DataConnectorValue :: i 'DataConnector -> AnyBackend (i :: BackendType -> Type)

-- | Generates a constraint for all backends.
type AllBackendsSatisfy (c :: BackendType -> Constraint) = (c ('Postgres 'Vanilla), c ('Postgres 'Citus), c ('Postgres 'Cockroach), c 'MSSQL, c 'BigQuery, c 'MySQL, c 'DataConnector)

-- | Generates a constraint for a generic type over all backends.
type SatisfiesForAllBackends (i :: BackendType -> Type) (c :: Type -> Constraint) = (c (i ('Postgres 'Vanilla)), c (i ('Postgres 'Citus)), c (i ('Postgres 'Cockroach)), c (i 'MSSQL), c (i 'BigQuery), c (i 'MySQL), c (i 'DataConnector))

-- | How to obtain a tag from a runtime value.
liftTag :: BackendType -> AnyBackend BackendTag

-- | Transforms an <tt>AnyBackend i</tt> into an <tt>AnyBackend j</tt>.
mapBackend :: forall (i :: BackendType -> Type) (j :: BackendType -> Type). AnyBackend i -> (forall b. i b -> j b) -> AnyBackend j

-- | Traverse an <tt>AnyBackend i</tt> into an <tt>f (AnyBackend j)</tt>.
traverseBackend :: forall (c :: BackendType -> Constraint) (i :: BackendType -> Type) (j :: BackendType -> Type) f. (AllBackendsSatisfy c, Functor f) => AnyBackend i -> (forall b. c b => i b -> f (j b)) -> f (AnyBackend j)

-- | Creates a new <tt>AnyBackend i</tt> for a given backend <tt>b</tt> by
--   wrapping the given <tt>i b</tt>.
mkAnyBackend :: forall (b :: BackendType) (i :: BackendType -> Type). HasTag b => i b -> AnyBackend i

-- | Dispatch a function to the value inside the <tt>AnyBackend</tt>, that
--   does not require bringing into scope a new class constraint.
runBackend :: forall (i :: BackendType -> Type) (r :: Type). AnyBackend i -> (forall (b :: BackendType). i b -> r) -> r

-- | Dispatch an existential using an universally quantified function while
--   also resolving a different constraint. Use this to dispatch Backend*
--   instances. This is essentially a wrapper around <tt>runAnyBackend f .
--   repackAnyBackend @c</tt>.
dispatchAnyBackend :: forall (c :: BackendType -> Constraint) (i :: BackendType -> Type) (r :: Type). AllBackendsSatisfy c => AnyBackend i -> (forall (b :: BackendType). c b => i b -> r) -> r
dispatchAnyBackendWithTwoConstraints :: forall (c1 :: BackendType -> Constraint) (c2 :: BackendType -> Constraint) (i :: BackendType -> Type) (r :: Type). AllBackendsSatisfy c1 => AllBackendsSatisfy c2 => AnyBackend i -> (forall (b :: BackendType). c1 b => c2 b => i b -> r) -> r

-- | Unlike <a>dispatchAnyBackend</a>, the expected constraint has a
--   different kind. Use for classes like <a>Show</a>, <a>ToJSON</a>, etc.
dispatchAnyBackend' :: forall (c :: Type -> Constraint) (i :: BackendType -> Type) (r :: Type). i `SatisfiesForAllBackends` c => AnyBackend i -> (forall (b :: BackendType). c (i b) => i b -> r) -> r

-- | This allows you to apply a constraint to the Backend instances (c2) as
--   well as a constraint on the higher-kinded <tt>i b</tt> type (c1)
dispatchAnyBackend'' :: forall (c1 :: Type -> Constraint) (c2 :: BackendType -> Constraint) (i :: BackendType -> Type) (r :: Type). i `SatisfiesForAllBackends` c1 => AllBackendsSatisfy c2 => AnyBackend i -> (forall (b :: BackendType). c2 b => c1 (i b) => i b -> r) -> r

-- | Sometimes we need to run operations on two backends of the same type.
--   If the backends don't contain the same type, the given <tt>r</tt>
--   value is returned. Otherwise, the function is called with the two
--   wrapped values.
composeAnyBackend :: forall (c :: BackendType -> Constraint) (i :: BackendType -> Type) (r :: Type). AllBackendsSatisfy c => (forall (b :: BackendType). c b => i b -> i b -> r) -> AnyBackend i -> AnyBackend i -> r -> r

-- | Try to unpack the type of an existential. Returns <tt>Just x</tt> upon
--   a succesful match, <tt>Nothing</tt> otherwise.
unpackAnyBackend :: forall (b :: BackendType) (i :: BackendType -> Type). HasTag b => AnyBackend i -> Maybe (i b)

-- | Dispatch variant for use with arrow syntax.
--   
--   NOTE: The below function accepts two constraints, if the arrow you
--   want to dispatch only has one constraint then repeat the constraint
--   twice. For example:
--   
--   <pre>
--   AB.dispatchAnyBackendArrow @BackendMetadata @BackendMetadata (proc (sourceMetadata, invalidationKeys)
--   </pre>
dispatchAnyBackendArrow :: forall (c1 :: BackendType -> Constraint) (c2 :: BackendType -> Constraint) (i :: BackendType -> Type) (r :: Type) (arr :: Type -> Type -> Type) x. (ArrowChoice arr, AllBackendsSatisfy c1, AllBackendsSatisfy c2) => (forall b. c1 b => c2 b => arr (i b, x) r) -> arr (AnyBackend i, x) r

-- | Attempts to parse an <a>AnyBackend</a> from a JSON value, using the
--   provided backend information.
parseAnyBackendFromJSON :: i `SatisfiesForAllBackends` FromJSON => BackendType -> Value -> Parser (AnyBackend i)

-- | Outputs a debug JSON value from an <a>AnyBackend</a>. This function
--   must only be used for debug purposes, as it has no way of inserting
--   the backend kind in the output, since there's no guarantee that the
--   output will be an object.
debugAnyBackendToJSON :: i `SatisfiesForAllBackends` ToJSON => AnyBackend i -> Value
backendSourceKindFromText :: Text -> Maybe (AnyBackend BackendSourceKind)
parseBackendSourceKindFromJSON :: Value -> Parser (AnyBackend BackendSourceKind)
instance GHC.Generics.Generic (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Show.Show => GHC.Show.Show (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Classes.Eq => GHC.Classes.Eq (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Hashable.Class.Hashable => Data.Hashable.Class.Hashable (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Hasura.Incremental.Internal.Dependency.Cacheable => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.SQL.AnyBackend.AnyBackend i)

module Hasura.SQL.BackendMap

-- | A BackendMap is a data structure that can contain at most one value of
--   an <tt>i</tt> per <a>BackendType</a> The <tt>i</tt> type must be one
--   that is parameterized by a BackendType-kinded type parameter
newtype BackendMap (i :: BackendType -> Type)
BackendMap :: Map BackendType (AnyBackend i) -> BackendMap (i :: BackendType -> Type)
singleton :: forall b i. HasTag b => i b -> BackendMap i

-- | Get a value from the map for the particular <a>BackendType</a>
--   <tt>b</tt>. This function is usually used with a type application.
--   <tt> lookup </tt>('Postgres 'Vanilla) backendMap @
lookup :: forall (b :: BackendType) i. HasTag b => BackendMap i -> Maybe (i b)

-- | Get all values in the map
elems :: forall i. BackendMap i -> [AnyBackend i]

-- | The expression <tt>modify f bmap</tt> alters the value <tt>x</tt> at
--   <tt>b</tt>. <tt>modify</tt> is a restricted version of <a>alter</a>
--   which cannot delete entries and if there is no <tt>b</tt> key present
--   in the map, it will apply the modification function to the <tt>i
--   b</tt> unit value and insert the result at <tt>b</tt>.
modify :: forall b i. (HasTag b, Monoid (i b)) => (i b -> i b) -> BackendMap i -> BackendMap i

-- | The expression <tt>alter f bmap</tt> alters the value <tt>x</tt> at
--   <tt>b</tt>, or absence thereof. alter can be used to insert, delete,
--   or update a value in a Map.
--   
--   In short : <tt>lookup k (alter f k m) = f (lookup k m)</tt>.
alter :: forall b i. HasTag b => (Maybe (i b) -> Maybe (i b)) -> BackendMap i -> BackendMap i
instance GHC.Base.Monoid (Hasura.SQL.BackendMap.BackendMap i)
instance GHC.Base.Semigroup (Hasura.SQL.BackendMap.BackendMap i)
instance GHC.Generics.Generic (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Show.Show => GHC.Show.Show (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Classes.Eq => GHC.Classes.Eq (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Aeson.Types.FromJSON.FromJSON => Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Hasura.SQL.BackendMap.BackendMap i)

module Hasura.Backends.DataConnector.Adapter.ConfigTransform
transformConfig :: MonadError QErr m => Config -> Maybe Text -> [(Text, Value)] -> Environment -> m Config
transformSourceConfig :: MonadError QErr m => SourceConfig -> [(Text, Value)] -> Environment -> m SourceConfig
transformConnSourceConfig :: MonadError QErr m => ConnSourceConfig -> [(Text, Value)] -> Environment -> m Config
additionalFunctions :: Environment -> HashMap Text (Value -> Either CustomFunctionError Value)

module Hasura.Backends.DataConnector.Adapter.Backend

-- | An alias for <tt>()</tt> indicating that a particular associated type
--   has not yet been implemented for the <a>DataConnector</a> backend.
--   
--   <tt>()</tt> is used (rather than a type with an empty data
--   constructor) because it comes with many of the instances that these
--   associated types require.
--   
--   This alias should <i>not</i> be exported from this module, and it's
--   only defined for clarity.
type Unimplemented = ()
data CustomBooleanOperator a
CustomBooleanOperator :: Text -> Maybe (Either (RootOrCurrentColumn 'DataConnector) a) -> CustomBooleanOperator a
[_cboName] :: CustomBooleanOperator a -> Text
[_cboRHS] :: CustomBooleanOperator a -> Maybe (Either (RootOrCurrentColumn 'DataConnector) a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator
instance GHC.Base.Functor Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator
instance Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator
instance GHC.Generics.Generic (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.DataConnector
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)

module Hasura.Backends.BigQuery.Source
data PKey
PKey :: PrivateKey -> Text -> PKey
[unPKey] :: PKey -> PrivateKey
[originalBS] :: PKey -> Text
newtype GoogleAccessToken
GoogleAccessToken :: Text -> GoogleAccessToken
data TokenResp
TokenResp :: GoogleAccessToken -> Integer -> TokenResp
[_trAccessToken] :: TokenResp -> GoogleAccessToken
[_trExpiresAt] :: TokenResp -> Integer
data ServiceAccount
ServiceAccount :: Text -> PKey -> Text -> ServiceAccount
[_saClientEmail] :: ServiceAccount -> Text
[_saPrivateKey] :: ServiceAccount -> PKey
[_saProjectId] :: ServiceAccount -> Text
data ConfigurationJSON a
FromEnvJSON :: Text -> ConfigurationJSON a
FromYamlJSON :: a -> ConfigurationJSON a

-- | Configuration inputs when they are a YAML array or an Env var whos
--   value is a comma-separated string
data ConfigurationInputs
FromYamls :: [Text] -> ConfigurationInputs
FromEnvs :: Text -> ConfigurationInputs

-- | Configuration input when the YAML value as well as the Env var have
--   singlular values
data ConfigurationInput
FromYaml :: Text -> ConfigurationInput
FromEnv :: Text -> ConfigurationInput
data BigQueryConnSourceConfig
BigQueryConnSourceConfig :: ConfigurationJSON ServiceAccount -> ConfigurationInputs -> ConfigurationInput -> Maybe ConfigurationInput -> Maybe ConfigurationInput -> Maybe ConfigurationInput -> BigQueryConnSourceConfig
[_cscServiceAccount] :: BigQueryConnSourceConfig -> ConfigurationJSON ServiceAccount
[_cscDatasets] :: BigQueryConnSourceConfig -> ConfigurationInputs
[_cscProjectId] :: BigQueryConnSourceConfig -> ConfigurationInput
[_cscGlobalSelectLimit] :: BigQueryConnSourceConfig -> Maybe ConfigurationInput
[_cscRetryBaseDelay] :: BigQueryConnSourceConfig -> Maybe ConfigurationInput
[_cscRetryLimit] :: BigQueryConnSourceConfig -> Maybe ConfigurationInput
data RetryOptions
RetryOptions :: Microseconds -> Int -> RetryOptions
[_retryBaseDelay] :: RetryOptions -> Microseconds
[_retryNumRetries] :: RetryOptions -> Int
data BigQueryConnection
BigQueryConnection :: ServiceAccount -> Text -> Maybe RetryOptions -> MVar (Maybe TokenResp) -> BigQueryConnection
[_bqServiceAccount] :: BigQueryConnection -> ServiceAccount
[_bqProjectId] :: BigQueryConnection -> Text
[_bqRetryOptions] :: BigQueryConnection -> Maybe RetryOptions
[_bqAccessTokenMVar] :: BigQueryConnection -> MVar (Maybe TokenResp)
data BigQuerySourceConfig
BigQuerySourceConfig :: BigQueryConnection -> [Text] -> Int64 -> BigQuerySourceConfig
[_scConnection] :: BigQuerySourceConfig -> BigQueryConnection
[_scDatasets] :: BigQuerySourceConfig -> [Text]
[_scGlobalSelectLimit] :: BigQuerySourceConfig -> Int64
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.RetryOptions
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQueryConnection
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQuerySourceConfig
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Source.BigQuerySourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.BigQuerySourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance GHC.Generics.Generic (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.ConfigurationInput
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.ConfigurationInput
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.ConfigurationInput
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.ServiceAccount
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.ServiceAccount
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.PKey
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.PKey
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.PKey
instance Data.Data.Data Hasura.Backends.BigQuery.Source.PKey
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.PKey
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.PKey
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Data.Data Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.TokenResp
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.TokenResp
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.TokenResp
instance Data.Data.Data Hasura.Backends.BigQuery.Source.TokenResp
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.TokenResp
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.TokenResp
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.ServiceAccount
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.ServiceAccount
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.ServiceAccount
instance Data.Data.Data Hasura.Backends.BigQuery.Source.ServiceAccount
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.ServiceAccount
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.ServiceAccount
instance GHC.Generics.Generic Crypto.PubKey.RSA.Types.PrivateKey
instance GHC.Generics.Generic Crypto.PubKey.RSA.Types.PublicKey
instance Data.Aeson.Types.ToJSON.ToJSON Crypto.PubKey.RSA.Types.PrivateKey
instance Data.Aeson.Types.ToJSON.ToJSON Crypto.PubKey.RSA.Types.PublicKey
instance Data.Hashable.Class.Hashable Crypto.PubKey.RSA.Types.PrivateKey
instance Data.Hashable.Class.Hashable Crypto.PubKey.RSA.Types.PublicKey
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.TokenResp
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.PKey
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.PKey

module Hasura.Backends.BigQuery.Connection
newtype Scope
Scope :: Text -> Scope
[unScope] :: Scope -> Text
data GoogleAccessTokenRequest
GoogleAccessTokenRequest :: Text -> Text -> GoogleAccessTokenRequest
[_gatrGrantType] :: GoogleAccessTokenRequest -> Text
[_gatrAssertion] :: GoogleAccessTokenRequest -> Text
mkTokenRequest :: Text -> GoogleAccessTokenRequest
data TokenProblem
BearerTokenDecodeProblem :: UnicodeException -> TokenProblem
BearerTokenSignsaferProblem :: Error -> TokenProblem
TokenFetchProblem :: JSONException -> TokenProblem
TokenRequestNonOK :: Status -> TokenProblem
tokenProblemMessage :: TokenProblem -> Text
data ServiceAccountProblem
ServiceAccountFileDecodeProblem :: String -> ServiceAccountProblem
resolveConfigurationJson :: (QErrM m, FromJSON a) => Environment -> ConfigurationJSON a -> m (Either String a)
resolveConfigurationInput :: QErrM m => Environment -> ConfigurationInput -> m Text
resolveConfigurationInputs :: QErrM m => Environment -> ConfigurationInputs -> m [Text]
initConnection :: MonadIO m => ServiceAccount -> Text -> Maybe RetryOptions -> m BigQueryConnection
getAccessToken :: MonadIO m => ServiceAccount -> m (Either TokenProblem TokenResp)

-- | Get a usable token. If the token has expired refresh it.
getUsableToken :: MonadIO m => BigQueryConnection -> m (Either TokenProblem TokenResp)
data BigQueryProblem
TokenProblem :: TokenProblem -> BigQueryProblem
runBigQuery :: MonadIO m => BigQueryConnection -> Request -> m (Either BigQueryProblem (Response ByteString))

-- | Uses up to specified number retries for Google API requests with the
--   specified base delay, uses full jitter backoff, see
--   <a>https://aws.amazon.com/ru/blogs/architecture/exponential-backoff-and-jitter/</a>
--   HTTP statuses for transient errors were taken from
--   <a>https://github.com/googleapis/python-api-core/blob/34ebdcc251d4f3d7d496e8e0b78847645a06650b/google/api_core/retry.py#L112-L115</a>
withGoogleApiRetries :: MonadIO m => RetryOptions -> m (Response body) -> m (Response body)
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Connection.TokenProblem
instance GHC.Show.Show Hasura.Backends.BigQuery.Connection.TokenProblem
instance GHC.Show.Show Hasura.Backends.BigQuery.Connection.ServiceAccountProblem
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Connection.BigQueryProblem
instance GHC.Show.Show Hasura.Backends.BigQuery.Connection.BigQueryProblem
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Connection.BigQueryProblem
instance GHC.Exception.Type.Exception Hasura.Backends.BigQuery.Connection.ServiceAccountProblem
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest
instance Data.String.IsString Hasura.Backends.BigQuery.Connection.Scope
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Connection.Scope
instance GHC.Show.Show Hasura.Backends.BigQuery.Connection.Scope
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest
instance GHC.Show.Show Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest

module Hasura.Backends.MySQL.Types.Internal
data Aliased a
Aliased :: a -> Text -> Aliased a
[aliasedThing] :: Aliased a -> a
[aliasedAlias] :: Aliased a -> Text

-- | Partial of Database.MySQL.Simple.ConnectInfo
data ConnSourceConfig
ConnSourceConfig :: Text -> Word16 -> Text -> Text -> Text -> ConnPoolSettings -> ConnSourceConfig

-- | Works with <tt>127.0.0.1</tt> but not with <tt>localhost</tt>:
--   <a>https://mariadb.com/kb/en/troubleshooting-connection-issues/#localhost-and</a>
[_cscHost] :: ConnSourceConfig -> Text
[_cscPort] :: ConnSourceConfig -> Word16
[_cscUser] :: ConnSourceConfig -> Text
[_cscPassword] :: ConnSourceConfig -> Text
[_cscDatabase] :: ConnSourceConfig -> Text
[_cscPoolSettings] :: ConnSourceConfig -> ConnPoolSettings
data SourceConfig
SourceConfig :: ConnSourceConfig -> Pool Connection -> SourceConfig
[scConfig] :: SourceConfig -> ConnSourceConfig
[scConnectionPool] :: SourceConfig -> Pool Connection
newtype ConstraintName
ConstraintName :: Text -> ConstraintName
[unConstraintName] :: ConstraintName -> Text
newtype FunctionName
FunctionName :: Text -> FunctionName
[unFunctionName] :: FunctionName -> Text
newtype Column
Column :: Text -> Column
[unColumn] :: Column -> Text
data ScalarValue
BigValue :: Int32 -> ScalarValue
BinaryValue :: ByteString -> ScalarValue
BitValue :: Bool -> ScalarValue
BlobValue :: ByteString -> ScalarValue
CharValue :: Text -> ScalarValue
DatetimeValue :: Text -> ScalarValue
DateValue :: Text -> ScalarValue
DecimalValue :: Double -> ScalarValue
DoubleValue :: Double -> ScalarValue
EnumValue :: Text -> ScalarValue
FloatValue :: Double -> ScalarValue
GeometrycollectionValue :: Text -> ScalarValue
GeometryValue :: Text -> ScalarValue
IntValue :: Int32 -> ScalarValue
JsonValue :: Value -> ScalarValue
LinestringValue :: Text -> ScalarValue
MediumValue :: Int32 -> ScalarValue
MultilinestringValue :: Text -> ScalarValue
MultipointValue :: Text -> ScalarValue
MultipolygonValue :: Text -> ScalarValue
NullValue :: ScalarValue
NumericValue :: Double -> ScalarValue
PointValue :: Text -> ScalarValue
PolygonValue :: Text -> ScalarValue
SetValue :: Set Text -> ScalarValue
SmallValue :: Int32 -> ScalarValue
TextValue :: Text -> ScalarValue
TimestampValue :: Text -> ScalarValue
TimeValue :: Text -> ScalarValue
TinyValue :: Int32 -> ScalarValue
UnknownValue :: Text -> ScalarValue
VarbinaryValue :: ByteString -> ScalarValue
VarcharValue :: Text -> ScalarValue
YearValue :: Text -> ScalarValue
data Expression
ValueExpression :: ScalarValue -> Expression
AndExpression :: [Expression] -> Expression
OrExpression :: [Expression] -> Expression
NotExpression :: Expression -> Expression
ExistsExpression :: Select -> Expression
InExpression :: Expression -> [Expression] -> Expression
OpExpression :: Op -> Expression -> Expression -> Expression
ColumnExpression :: FieldName -> Expression
MethodExpression :: Expression -> Text -> [Expression] -> Expression
data Top
NoTop :: Top
Top :: Int -> Top
data Op
LT :: Op
LTE :: Op
GT :: Op
GTE :: Op
IN :: Op
LIKE :: Op
NLIKE :: Op
NIN :: Op
EQ' :: Op
NEQ' :: Op
data ConnPoolSettings
ConnPoolSettings :: Word -> Word -> ConnPoolSettings
[_cscIdleTimeout] :: ConnPoolSettings -> Word
[_cscMaxConnections] :: ConnPoolSettings -> Word
data FieldName
FieldName :: Text -> Text -> FieldName
[fName] :: FieldName -> Text
[fNameEntity] :: FieldName -> Text
data FieldOrigin
NoOrigin :: FieldOrigin
AggregateOrigin :: [Aliased Aggregate] -> FieldOrigin
newtype EntityAlias
EntityAlias :: Text -> EntityAlias
[entityAliasText] :: EntityAlias -> Text
data Countable name
StarCountable :: Countable name
NonNullFieldCountable :: NonEmpty name -> Countable name
DistinctCountable :: NonEmpty name -> Countable name
data Aggregate
CountAggregate :: Countable FieldName -> Aggregate
OpAggregate :: Text -> [Expression] -> Aggregate
TextAggregate :: Text -> Aggregate
data Projection
ExpressionProjection :: Aliased Expression -> Projection
FieldNameProjection :: Aliased FieldName -> Projection
AggregateProjections :: Aliased (NonEmpty (Aliased Aggregate)) -> Projection
AggregateProjection :: Aliased Aggregate -> Projection
StarProjection :: Projection
EntityProjection :: Aliased [(FieldName, FieldOrigin)] -> Projection
ArrayEntityProjection :: EntityAlias -> Aliased [FieldName] -> Projection
data TableName
TableName :: Text -> Maybe Text -> TableName
[name] :: TableName -> Text
[schema] :: TableName -> Maybe Text
data From
FromQualifiedTable :: Aliased TableName -> From
FromSelect :: Aliased Select -> From
data Reselect
Reselect :: [Projection] -> Where -> Reselect
[reselectProjections] :: Reselect -> [Projection]
[reselectWhere] :: Reselect -> Where
data JoinAlias
JoinAlias :: Text -> Maybe Text -> JoinAlias
[joinAliasEntity] :: JoinAlias -> Text
[joinAliasField] :: JoinAlias -> Maybe Text
data Join
Join :: EntityAlias -> Select -> JoinType -> Text -> Top -> Maybe Int -> Join

-- | For display/debug purposes.
[joinRightTable] :: Join -> EntityAlias

-- | Where to pull the data from.
[joinSelect] :: Join -> Select

-- | Type of join to perform in-Haskell.
[joinType] :: Join -> JoinType

-- | Wrap the output in this field name.
[joinFieldName] :: Join -> Text
[joinTop] :: Join -> Top
[joinOffset] :: Join -> Maybe Int
data JoinType

-- | A join without any 'ON x=y' construct. We're querying from a table and
--   doing our own WHERE clauses.
OnlessJoin :: JoinType

-- | An array join on the given fields.
ArrayJoin :: [(FieldName, FieldName)] -> JoinType

-- | An array aggregate join.
ArrayAggregateJoin :: [(FieldName, FieldName)] -> JoinType

-- | Simple object join on the fields.
ObjectJoin :: [(FieldName, FieldName)] -> JoinType
newtype Where
Where :: [Expression] -> Where
data Order
Asc :: Order
Desc :: Order
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder
NullsAnyOrder :: NullsOrder
type ScalarType = Type
data OrderBy
OrderBy :: FieldName -> Order -> NullsOrder -> Maybe ScalarType -> OrderBy
[orderByFieldName] :: OrderBy -> FieldName
[orderByOrder] :: OrderBy -> Order
[orderByNullsOrder] :: OrderBy -> NullsOrder
[orderByType] :: OrderBy -> Maybe ScalarType
data Select
Select :: InsOrdHashSet Projection -> From -> [Join] -> Where -> Maybe (NonEmpty OrderBy) -> Maybe Int -> Top -> [FieldName] -> Maybe [Text] -> Select
[selectProjections] :: Select -> InsOrdHashSet Projection
[selectFrom] :: Select -> From
[selectJoins] :: Select -> [Join]
[selectWhere] :: Select -> Where
[selectOrderBy] :: Select -> Maybe (NonEmpty OrderBy)
[selectSqlOffset] :: Select -> Maybe Int
[selectSqlTop] :: Select -> Top
[selectGroupBy] :: Select -> [FieldName]
[selectFinalWantedFields] :: Select -> Maybe [Text]
mkMySQLScalarTypeName :: MonadError QErr m => ScalarType -> m Name
scalarTypeDBName :: ScalarType -> Text
defaultConnPoolSettings :: ConnPoolSettings

-- | ref:
--   <a>https://dev.mysql.com/doc/c-api/8.0/en/c-api-data-structures.html</a>
--   
--   DB has CHAR, BINARY, VARCHAR and VARBINARY C API only has STRING and
--   VARSTRING Database.MySQL.Base.Types.Type has String, VarString and
--   VarChar for some reason
parseMySQLScalarType :: Text -> ScalarType
parseScalarValue :: ScalarType -> Value -> Either QErr ScalarValue
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.ConstraintName
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.ConstraintName
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.ConstraintName
instance Data.Text.Extended.ToTxt Hasura.Backends.MySQL.Types.Internal.ConstraintName
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.ConstraintName
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.ConstraintName
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.FunctionName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MySQL.Types.Internal.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.MySQL.Types.Internal.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.MySQL.Types.Internal.FunctionName
instance GHC.Classes.Ord Hasura.Backends.MySQL.Types.Internal.FunctionName
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.FunctionName
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.FunctionName
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.Column
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.Column
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.Column
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.Column
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.Column
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.Column
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MySQL.Types.Internal.Column
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.MySQL.Types.Internal.Column
instance Data.Text.Extended.ToTxt Hasura.Backends.MySQL.Types.Internal.Column
instance GHC.Classes.Ord Hasura.Backends.MySQL.Types.Internal.Column
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.Column
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.Column
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance GHC.Classes.Ord Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance GHC.Read.Read Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.ConnPoolSettings
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.ConnPoolSettings
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.ConnPoolSettings
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.ConnPoolSettings
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.ConnPoolSettings
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.ConnSourceConfig
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.ConnSourceConfig
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.ConnSourceConfig
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.ConnSourceConfig
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.ConnSourceConfig
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MySQL.Types.Internal.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance Data.Text.Extended.ToTxt Hasura.Backends.MySQL.Types.Internal.ScalarValue
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MySQL.Types.Internal.Column
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MySQL.Types.Internal.FunctionName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MySQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSON Data.ByteString.Internal.ByteString
instance Data.Aeson.Types.FromJSON.FromJSON Data.ByteString.Internal.ByteString


-- | Instances that're slow to compile.
module Hasura.Backends.MySQL.Types.Instances
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.SourceConfig
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.SourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.SourceConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.ConnPoolSettings
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.ConnSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.ConnSourceConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.ConnSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON (Data.Pool.Pool Database.MySQL.Base.Connection)
instance GHC.Classes.Eq (Data.Pool.Pool Database.MySQL.Base.Connection)
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.SourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.ConnPoolSettings
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.Expression
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.Expression
instance GHC.Base.Monoid Hasura.Backends.MySQL.Types.Internal.Where
instance GHC.Base.Semigroup Hasura.Backends.MySQL.Types.Internal.Where
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.Order
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.Order
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.NullsOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.NullsOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.FieldName
instance Data.Text.Extended.ToTxt Hasura.Backends.MySQL.Types.Internal.TableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.TableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.Types.Internal.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MySQL.Types.Internal.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MySQL.Types.Internal.ScalarType
instance Data.Text.Extended.ToTxt Hasura.Backends.MySQL.Types.Internal.ScalarType
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MySQL.Types.Internal.ScalarType
instance GHC.Base.Monoid Hasura.Backends.MySQL.Types.Internal.Top
instance GHC.Base.Semigroup Hasura.Backends.MySQL.Types.Internal.Top
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.Types.Internal.ConnPoolSettings
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MySQL.Types.Internal.TableName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MySQL.Types.Internal.NullsOrder
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MySQL.Types.Internal.Order
instance GHC.Classes.Ord Hasura.Backends.MySQL.Types.Internal.TableName
instance GHC.Classes.Ord Hasura.Backends.MySQL.Types.Internal.ScalarType
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.Where
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.Where
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.Where
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.Where
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.Aggregate
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.Aggregate
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.Aggregate
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.Aggregate
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.EntityAlias
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.EntityAlias
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.EntityAlias
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.EntityAlias
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.OrderBy
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.OrderBy
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.OrderBy
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.OrderBy
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.JoinAlias
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.JoinAlias
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.JoinAlias
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.JoinAlias
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.Reselect
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.Reselect
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.Reselect
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.Reselect
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.Expression
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.Expression
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.Expression
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.Expression
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.NullsOrder
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.NullsOrder
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.NullsOrder
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.NullsOrder
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.Order
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.Order
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.Order
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.Order
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.Top
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.Top
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.Top
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.Top
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.TableName
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.TableName
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.TableName
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.TableName
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.Select
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.Select
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.Select
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.Select
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.FieldName
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.FieldName
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.FieldName
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.FieldName
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.FieldOrigin
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.FieldOrigin
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.FieldOrigin
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.FieldOrigin
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.Projection
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.Projection
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.Projection
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.Projection
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.From
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.From
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.From
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.From
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.Join
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.Join
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.Join
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.Join
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.Op
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.Op
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.Op
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.Op
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.JoinType
instance GHC.Classes.Eq Hasura.Backends.MySQL.Types.Internal.JoinType
instance GHC.Show.Show Hasura.Backends.MySQL.Types.Internal.JoinType
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.JoinType
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.Where
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.Where
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.Where
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.Aggregate
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.Aggregate
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.Aggregate
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.EntityAlias
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.EntityAlias
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.EntityAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.OrderBy
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.OrderBy
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.OrderBy
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.JoinAlias
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.JoinAlias
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.JoinAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.Reselect
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.Reselect
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.Reselect
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.Expression
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.Expression
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.Expression
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.NullsOrder
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.NullsOrder
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.Order
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.Order
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.Order
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.Top
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.Top
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.Top
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.TableName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.TableName
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.Select
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.Select
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.Select
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.FieldName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.FieldName
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.FieldName
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.FieldOrigin
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.FieldOrigin
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.FieldOrigin
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.Projection
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.Projection
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.Projection
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.From
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.From
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.From
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.Join
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.Join
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.Join
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.Op
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.Op
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.Op
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.JoinType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.JoinType
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.JoinType
instance GHC.Generics.Generic (Hasura.Backends.MySQL.Types.Internal.Aliased a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.MySQL.Types.Internal.Aliased a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.MySQL.Types.Internal.Aliased a)
instance GHC.Base.Functor Hasura.Backends.MySQL.Types.Internal.Aliased
instance Data.Data.Data a => Data.Data.Data (Hasura.Backends.MySQL.Types.Internal.Aliased a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.MySQL.Types.Internal.Aliased a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.MySQL.Types.Internal.Aliased a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.MySQL.Types.Internal.Aliased a)
instance GHC.Generics.Generic Hasura.Backends.MySQL.Types.Internal.ScalarType
instance Data.Data.Data Hasura.Backends.MySQL.Types.Internal.ScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.Types.Internal.ScalarType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MySQL.Types.Internal.ScalarType
instance Control.DeepSeq.NFData Hasura.Backends.MySQL.Types.Internal.ScalarType
instance GHC.Generics.Generic (Hasura.Backends.MySQL.Types.Internal.Countable n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Hasura.Backends.MySQL.Types.Internal.Countable n)
instance GHC.Show.Show n => GHC.Show.Show (Hasura.Backends.MySQL.Types.Internal.Countable n)
instance Data.Data.Data n => Data.Data.Data (Hasura.Backends.MySQL.Types.Internal.Countable n)
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (Hasura.Backends.MySQL.Types.Internal.Countable n)
instance Hasura.Incremental.Internal.Dependency.Cacheable n => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.MySQL.Types.Internal.Countable n)
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (Hasura.Backends.MySQL.Types.Internal.Countable n)
instance Data.Aeson.Types.ToJSON.ToJSON n => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.MySQL.Types.Internal.Countable n)
instance Data.Aeson.Types.FromJSON.FromJSON n => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.MySQL.Types.Internal.Countable n)


-- | Types for MySQL
module Hasura.Backends.MySQL.Types


-- | Convert the simple AST to an SQL query, ready to be passed to the
--   mysql package's query/exec functions.
module Hasura.Backends.MySQL.ToQuery
newtype Query
Query :: ByteString -> Query
[unQuery] :: Query -> ByteString
data Printer
SeqPrinter :: [Printer] -> Printer
SepByPrinter :: Printer -> [Printer] -> Printer
NewlinePrinter :: Printer
QueryPrinter :: Query -> Printer
IndentPrinter :: Int -> Printer -> Printer
(<+>) :: Printer -> Printer -> Printer
fromExpression :: Expression -> Printer
fromScalarType :: ScalarValue -> Query
fromOp :: Op -> Printer
fromFieldName :: FieldName -> Printer
fromSelect :: Select -> Printer
fromOffsetAndLimit :: Top -> Maybe Int -> Printer
fromOrderBys :: Maybe (NonEmpty OrderBy) -> Printer
fromOrderBy :: OrderBy -> [Printer]
fromOrder :: Order -> Printer
fromNullsOrder :: FieldName -> NullsOrder -> Printer
fromProjection :: Projection -> Printer
fromAggregate :: Aggregate -> Printer
fromCountable :: Countable FieldName -> Printer
fromWhere :: Where -> Printer
fromFrom :: From -> Printer
parens :: Printer -> Printer
fromTableName :: TableName -> Printer
fromAliased :: Aliased Printer -> Printer
fromNameText :: Text -> Printer
truePrinter :: Printer
falsePrinter :: Printer
toQueryFlat :: Printer -> Query
toQueryPretty :: Printer -> Query

-- | Produces a query with holes, and a mapping for each
renderBuilderPretty :: Printer -> (Builder, InsOrdHashMap Int ScalarValue)
runBuilderPretty :: Printer -> State (InsOrdHashMap ScalarValue Int) Builder
fromFieldOrigin :: FieldOrigin -> Printer
fromNullAggregate :: Aggregate -> Printer
instance GHC.Base.Semigroup Hasura.Backends.MySQL.ToQuery.Query
instance GHC.Base.Monoid Hasura.Backends.MySQL.ToQuery.Query
instance GHC.Classes.Eq Hasura.Backends.MySQL.ToQuery.Query
instance GHC.Show.Show Hasura.Backends.MySQL.ToQuery.Query
instance GHC.Classes.Eq Hasura.Backends.MySQL.ToQuery.Printer
instance GHC.Show.Show Hasura.Backends.MySQL.ToQuery.Printer
instance Data.String.IsString Hasura.Backends.MySQL.ToQuery.Printer

module Hasura.Backends.MySQL.Instances.Types
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MySQL


-- | Make a plan for the data loader to execute (.Execute).
--   
--   It will produce a graph of actions, to be executed by .Execute.
module Hasura.Backends.MySQL.DataLoader.Plan

-- | A reference to a result of loading a recordset from the database.
data Ref
Ref :: Int -> Text -> Ref

-- | This index will be generated by the planner.
[$sel:idx:Ref] :: Ref -> Int

-- | A display name. The idx gives us uniqueness.
[$sel:text:Ref] :: Ref -> Text

-- | A almost-the-same version of Select from Types.Internal, except with
--   some fields used for planning and executing.
data Select
Select :: Maybe Text -> From -> [FieldName] -> [Join] -> Maybe (NonEmpty OrderBy) -> [Projection] -> Maybe Relationship -> Where -> Maybe [Text] -> Maybe Int -> Top -> Select
[$sel:selectAggUnwrap:Select] :: Select -> Maybe Text
[$sel:selectFrom:Select] :: Select -> From
[$sel:selectGroupBy:Select] :: Select -> [FieldName]
[$sel:selectHaskellJoins:Select] :: Select -> [Join]
[$sel:selectOrderBy:Select] :: Select -> Maybe (NonEmpty OrderBy)
[$sel:selectProjections:Select] :: Select -> [Projection]
[$sel:selectRelationship:Select] :: Select -> Maybe Relationship
[$sel:selectWhere:Select] :: Select -> Where
[$sel:selectWantedFields:Select] :: Select -> Maybe [Text]
[$sel:selectSqlOffset:Select] :: Select -> Maybe Int
[$sel:selectSqlTop:Select] :: Select -> Top

-- | An join action.
data Join
Join :: Ref -> Ref -> Top -> Maybe Int -> JoinType -> Text -> Maybe [Text] -> Join

-- | Join this side...
[$sel:leftRecordSet:Join] :: Join -> Ref

-- | with this side.
[$sel:rightRecordSet:Join] :: Join -> Ref

-- | Join only the top N results. It's important that we do this IN
--   HASKELL, therefore this is not part of the generated SQL.
[$sel:joinRhsTop:Join] :: Join -> Top

-- | Offset applied to the right-hand-side table.
[$sel:joinRhsOffset:Join] :: Join -> Maybe Int

-- | Type of relational join to do.
[$sel:joinType:Join] :: Join -> JoinType

-- | Field name to return the join result as; e.g. "albums" for an artist
--   with an array relation of albums.
[$sel:joinFieldName:Join] :: Join -> Text

-- | The SQL queries may achieve the data using joining fields, but those
--   fields aren't supposed to be returned back to the user. To avoid that,
--   we explicitly specify which fields are wanted from this join. E.g.
--   "title" and "year", but not artist_id which was used to Haskell-join
--   the row with an album_artist_id, or whatever.
[$sel:wantedFields:Join] :: Join -> Maybe [Text]

-- | An action that the executor will perform. Either pull data from the
--   database directly via a select, or join two other actions' record sets
--   together.
data Action
SelectAction :: Select -> Action
JoinAction :: Join -> Action

-- | An action planned, with a unique reference. I.e. the <tt>action</tt>
--   performed yields a result stored at reference <tt>ref</tt>.
data PlannedAction
PlannedAction :: Ref -> Action -> PlannedAction
[$sel:ref:PlannedAction] :: PlannedAction -> Ref
[$sel:action:PlannedAction] :: PlannedAction -> Action

-- | A relationship lets the executor insert on-the-fly WHERE fkey1=fkey2
--   for relationships. These can only be inserted on-the-fly and aren't
--   known at the time of planning, because the keys come from the
--   left-hand-side table for a join.
data Relationship
Relationship :: Ref -> EntityAlias -> JoinType -> Relationship
[$sel:leftRecordSet:Relationship] :: Relationship -> Ref
[$sel:rightTable:Relationship] :: Relationship -> EntityAlias
[$sel:joinType:Relationship] :: Relationship -> JoinType

-- | Just a wrapper to clarify some types. It's different from the
--   MySQL.FieldName because it doesn't care about schemas: schemas aren't
--   returned in recordsets from the database.
newtype FieldName
FieldName :: Text -> FieldName

-- | The reason for this is subtle. Read this documentation. For each join
--   on a select (see above, there is a list), we split that out into three
--   jobs:
--   
--   <ol>
--   <li>One job for the left hand side (i.e. the select).</li>
--   <li>One job for the right hand side (i.e. the join).</li>
--   <li>One job to join them (And in the darkness bind them...)</li>
--   </ol>
--   
--   This is performed as a fold, like: <tt>foldM planJoin head joins</tt>.
--   A nice linked-list or tree-like structure arises. The planner code
--   produces a graph out of this; so it's possible that some parallelism
--   can be achieved by running multiple jobs at once.
--   
--   The "head" is the first, original select. The "tail" is the
--   (indirectly) linked list of joins. That list may also be empty. In
--   that case, the tail is simply the same as the head.
--   
--   If the tail is different to the head, then we choose the tail, as it
--   represents the joined up version of both. If they're the same, we take
--   whichever.
data HeadAndTail
HeadAndTail :: Ref -> Ref -> HeadAndTail
[$sel:head:HeadAndTail] :: HeadAndTail -> Ref
[$sel:tail:HeadAndTail] :: HeadAndTail -> Ref

-- | We're simply accumulating a set of actions with this. The counter lets
--   us generate unique refs.
data PlanState
PlanState :: Seq PlannedAction -> Int -> PlanState
[$sel:actions:PlanState] :: PlanState -> Seq PlannedAction
[$sel:counter:PlanState] :: PlanState -> Int

-- | Simple monad to collect actions.
newtype Plan a
Plan :: State PlanState a -> Plan a
[$sel:unPlan:Plan] :: Plan a -> State PlanState a

-- | Note that we're intentionally discarding the table qualification.
toFieldName :: FieldName -> FieldName
joinAliasName :: EntityAlias -> Text

-- | Used for display purposes, not semantic content.
selectFromName :: From -> Text
runPlan :: Plan r -> (r, [PlannedAction])

-- | See the documentation for <a>HeadAndTail</a>.
planSelectHeadAndTail :: Maybe Relationship -> Maybe Text -> Select -> Plan HeadAndTail

-- | Given a left-hand-side table and a join spec, produce a single
--   reference that refers to the composition of the two.
planJoin :: Ref -> Join -> Plan Ref

-- | Write the planned action to the state, like a writer's <tt>tell</tt>.
tell :: PlannedAction -> Plan ()

-- | Generate a unique reference with a label for debugging.
generate :: Text -> Plan Ref

-- | Graph the set of planned actions ready for execution in the correct
--   order.
actionsForest :: (Graph -> Graph) -> [PlannedAction] -> Forest PlannedAction

-- | Used by the executor to produce a plain old select that can be sent to
--   the MySQL server.
selectQuery :: Select -> Select

-- | From a plain select, and possibly a parent/left-hand-side
--   relationship, produce a select that is useful for execution.
fromSelect :: Maybe Relationship -> Maybe Text -> Select -> Select
instance GHC.Classes.Ord Hasura.Backends.MySQL.DataLoader.Plan.Ref
instance GHC.Generics.Generic Hasura.Backends.MySQL.DataLoader.Plan.Ref
instance GHC.Classes.Eq Hasura.Backends.MySQL.DataLoader.Plan.Ref
instance GHC.Show.Show Hasura.Backends.MySQL.DataLoader.Plan.Ref
instance GHC.Show.Show Hasura.Backends.MySQL.DataLoader.Plan.Join
instance GHC.Show.Show Hasura.Backends.MySQL.DataLoader.Plan.Relationship
instance GHC.Show.Show Hasura.Backends.MySQL.DataLoader.Plan.Select
instance GHC.Show.Show Hasura.Backends.MySQL.DataLoader.Plan.Action
instance GHC.Show.Show Hasura.Backends.MySQL.DataLoader.Plan.PlannedAction
instance Data.String.IsString Hasura.Backends.MySQL.DataLoader.Plan.FieldName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MySQL.DataLoader.Plan.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.DataLoader.Plan.FieldName
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.DataLoader.Plan.FieldName
instance GHC.Classes.Eq Hasura.Backends.MySQL.DataLoader.Plan.FieldName
instance GHC.Classes.Ord Hasura.Backends.MySQL.DataLoader.Plan.FieldName
instance GHC.Show.Show Hasura.Backends.MySQL.DataLoader.Plan.FieldName
instance Control.Monad.State.Class.MonadState Hasura.Backends.MySQL.DataLoader.Plan.PlanState Hasura.Backends.MySQL.DataLoader.Plan.Plan
instance GHC.Base.Monad Hasura.Backends.MySQL.DataLoader.Plan.Plan
instance GHC.Base.Applicative Hasura.Backends.MySQL.DataLoader.Plan.Plan
instance GHC.Base.Functor Hasura.Backends.MySQL.DataLoader.Plan.Plan
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.DataLoader.Plan.Ref


-- | MSSQL Types Instances
--   
--   Instances for types from <a>Hasura.Backends.MSSQL.Types.Internal</a>
--   that're slow to compile.
module Hasura.Backends.MSSQL.Types.Instances
instance GHC.Generics.Generic (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Base.Functor Hasura.Backends.MSSQL.Types.Internal.Aliased
instance Data.Data.Data a => Data.Data.Data (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Where
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.For
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.For
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.For
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.For
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ForJson
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ForJson
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.ForJson
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ForJson
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Root
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Root
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Root
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Root
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Reselect
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Reselect
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Reselect
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Reselect
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.DataLength
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.DataLength
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.DataLength
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.DataLength
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Expression
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Expression
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Expression
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Expression
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Order
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Order
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Order
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Select
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Select
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Select
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Select
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.With
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.With
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.With
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.With
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Top
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.FieldName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.FieldName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.FieldName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Op
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Op
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Op
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Op
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Projection
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Projection
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Projection
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Projection
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.From
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.From
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.From
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.From
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Join
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Join
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Join
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Join
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Inserted
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Inserted
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Inserted
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Inserted
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.TempTable
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.TempTable
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.TempTable
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.TempTable
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Deleted
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Deleted
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Deleted
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Deleted
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Values
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Values
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Values
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Values
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Delete
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Delete
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Delete
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Delete
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Insert
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Insert
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Insert
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Insert
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Merge
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Merge
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Merge
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Merge
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.TableName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Generics.Generic (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Show.Show n => GHC.Show.Show (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Data.Data.Data n => Data.Data.Data (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Base.Monoid Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Base.Semigroup Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Generics.Generic (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance GHC.Base.Functor Hasura.Backends.MSSQL.Types.Internal.BooleanOperators
instance Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Internal.BooleanOperators
instance Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Internal.BooleanOperators
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Where
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Where
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Where
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.For
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.For
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.For
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ForJson
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.ForJson
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ForJson
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Root
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Root
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Root
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Reselect
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Reselect
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Reselect
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.DataLength
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.DataLength
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.DataLength
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Expression
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Expression
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Expression
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Order
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Order
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.TableName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.TableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Select
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Select
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Select
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.With
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.With
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.With
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Top
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Top
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Top
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Op
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Op
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Op
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Projection
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Projection
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Projection
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.From
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.From
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.From
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Join
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Join
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Join
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Inserted
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Inserted
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Inserted
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.TempTable
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.TempTable
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.TempTable
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Deleted
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Deleted
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Deleted
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Values
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Values
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Values
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Delete
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Delete
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Delete
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Insert
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Insert
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Insert
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Merge
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.Merge
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Merge
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance Hasura.Incremental.Internal.Dependency.Cacheable Database.ODBC.Internal.Value
instance Hasura.Incremental.Internal.Dependency.Cacheable Database.ODBC.Internal.Binary
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.TableName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Hasura.Incremental.Internal.Dependency.Cacheable n => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Data.Aeson.Types.ToJSON.ToJSON n => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Data.Aeson.Types.FromJSON.FromJSON n => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Base.Monoid Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Base.Semigroup Hasura.Backends.MSSQL.Types.Internal.Top
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)


-- | MSSQL Types Update
--   
--   This module defines the Update-related IR types specific to MSSQL.
module Hasura.Backends.MSSQL.Types.Update

-- | The MSSQL-specific data of an Update expression.
--   
--   This is parameterised over <tt>v</tt> which enables different phases
--   of IR transformation to maintain the overall structure while
--   enriching/transforming the data at the leaves.
data BackendUpdate v
BackendUpdate :: HashMap ColumnName (UpdateOperator v) -> BackendUpdate v

-- | The update operations to perform on each column.
--   
--   This HashMap will also contain the update operators for the presets.
--   They are populated as part of the schema building in
--   <a>msBuildTableUpdateMutationFields</a> in the call to
--   <tt>buildUpdateOperators</tt>.
[updateOperations] :: BackendUpdate v -> HashMap ColumnName (UpdateOperator v)

-- | The various <tt>update operators</tt> supported by MSSQL, i.e. the
--   <tt>_set</tt>, <tt>_inc</tt> operators that appear in the schema.
--   
--   TODO: Docs for MSSQL! See <a>Update Mutations User docs</a>
data UpdateOperator v
UpdateSet :: v -> UpdateOperator v
UpdateInc :: v -> UpdateOperator v
type UpdateSet = HashMap ColumnName (UpdateOperator Expression)
type UpdateOutput = Output Inserted

-- | UPDATE [table_alias] SET [table_alias].column = <tt>value</tt> OUTPUT
--   INSERTED.column INTO #updated FROM [table_name] AS [table_alias] WHERE
--   <a>filter-expression</a>
data Update
Update :: Aliased TableName -> UpdateSet -> UpdateOutput -> TempTable -> Where -> Update
[updateTable] :: Update -> Aliased TableName
[updateSet] :: Update -> UpdateSet
[updateOutput] :: Update -> UpdateOutput
[updateTempTable] :: Update -> TempTable
[updateWhere] :: Update -> Where
instance Data.Data.Data v => Data.Data.Data (Hasura.Backends.MSSQL.Types.Update.UpdateOperator v)
instance GHC.Generics.Generic (Hasura.Backends.MSSQL.Types.Update.UpdateOperator v)
instance Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Update.UpdateOperator
instance Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Update.UpdateOperator
instance GHC.Base.Functor Hasura.Backends.MSSQL.Types.Update.UpdateOperator
instance Data.Data.Data v => Data.Data.Data (Hasura.Backends.MSSQL.Types.Update.BackendUpdate v)
instance GHC.Generics.Generic (Hasura.Backends.MSSQL.Types.Update.BackendUpdate v)
instance Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Update.BackendUpdate
instance Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Update.BackendUpdate
instance GHC.Base.Functor Hasura.Backends.MSSQL.Types.Update.BackendUpdate


-- | MSSQL Types Insert
--   
--   Types for MSSQL Insert IR.
module Hasura.Backends.MSSQL.Types.Insert

-- | Defines the part in insert mutation that is unique for MSSQL the
--   <tt>if_matched</tt> clause.
data BackendInsert v
BackendInsert :: Maybe (IfMatched v) -> BackendInsert v

-- | <tt>if_matched</tt> can be omitted (and in that case will be
--   <tt>Nothing</tt>). If omitted, we only insert new rows (without
--   upserting).
[_biIfMatched] :: BackendInsert v -> Maybe (IfMatched v)

-- | The IR data representing an <tt>if_matched</tt> clause, which handles
--   upserts.
data IfMatched v
IfMatched :: [Column 'MSSQL] -> [Column 'MSSQL] -> AnnBoolExp 'MSSQL v -> HashMap ColumnName v -> IfMatched v

-- | Columns to compare when checking if there's a match
[_imMatchColumns] :: IfMatched v -> [Column 'MSSQL]

-- | Columns to update when there's a match
[_imUpdateColumns] :: IfMatched v -> [Column 'MSSQL]

-- | A condition for updating columns in case of a match
[_imConditions] :: IfMatched v -> AnnBoolExp 'MSSQL v

-- | Default values (presets) for some columns
[_imColumnPresets] :: IfMatched v -> HashMap ColumnName v
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MSSQL, GHC.Show.Show (Hasura.Backends.MSSQL.Types.Insert.IfMatched v), GHC.Show.Show v) => GHC.Show.Show (Hasura.Backends.MSSQL.Types.Insert.BackendInsert v)
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MSSQL => GHC.Base.Functor Hasura.Backends.MSSQL.Types.Insert.BackendInsert
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MSSQL => Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Insert.BackendInsert
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MSSQL => Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Insert.BackendInsert
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MSSQL, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp 'Hasura.SQL.Backend.MSSQL v), GHC.Show.Show v) => GHC.Show.Show (Hasura.Backends.MSSQL.Types.Insert.IfMatched v)
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MSSQL => GHC.Base.Functor Hasura.Backends.MSSQL.Types.Insert.IfMatched
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MSSQL => Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Insert.IfMatched
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MSSQL => Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Insert.IfMatched


-- | This module exports modules <tt>Hasura.Backends.MSSQL.Types.*</tt>.
--   
--   The types in <a>Hasura.Backends.MSSQL.Types.Internal</a> define types
--   which represent T-SQL AST.
--   
--   The other modules such as <a>Hasura.Backends.MSSQL.Types.Insert</a>
--   and <a>Hasura.Backends.MSSQL.Types.Update</a> represent GraphQL AST
--   parts that are unique for MSSQL.
module Hasura.Backends.MSSQL.Types


-- | MSSQL ToQuery
--   
--   Convert the simple T-SQL AST to an SQL query, ready to be passed to
--   the odbc package's query/exec functions.
--   
--   We define a custom prettyprinter with the type <a>Printer</a>.
--   
--   If you'd like to trace and see what a <a>Printer</a> looks like as
--   SQL, you can use something like: &gt; ltraceM "sql" (ODBC.renderQuery
--   (toQueryPretty myPrinter))
module Hasura.Backends.MSSQL.ToQuery
data Printer
SeqPrinter :: [Printer] -> Printer
SepByPrinter :: Printer -> [Printer] -> Printer
NewlinePrinter :: Printer
QueryPrinter :: Query -> Printer
IndentPrinter :: Int -> Printer -> Printer
(<+>) :: Printer -> Printer -> Printer
(<+>?) :: Printer -> Maybe Printer -> Printer
(?<+>) :: Maybe Printer -> Printer -> Printer
fromExpression :: Expression -> Printer
fromMethodApplicationExpression :: Expression -> MethodApplicationExpression -> Printer
fromFunctionApplicationExpression :: FunctionApplicationExpression -> Printer
fromOp :: Op -> Printer
fromPath :: JsonPath -> Printer
fromFieldName :: FieldName -> Printer
fromInserted :: Inserted -> Printer
fromDeleted :: Deleted -> Printer
fromOutputColumn :: Printer -> OutputColumn -> Printer
fromOutput :: (t -> Printer) -> Output t -> Printer
fromInsertOutput :: InsertOutput -> Printer
fromDeleteOutput :: DeleteOutput -> Printer
fromUpdateOutput :: UpdateOutput -> Printer
fromValues :: Values -> Printer
fromValuesList :: [Values] -> Printer
fromInsert :: Insert -> Printer
fromSetValue :: SetValue -> Printer
fromSetIdentityInsert :: SetIdentityInsert -> Printer

-- | Generate a statement to insert values into temporary table.
fromInsertValuesIntoTempTable :: InsertValuesIntoTempTable -> Printer

-- | Alias for the source table in a MERGE statement. Used when pretty
--   printing MERGE statments.
mergeSourceAlias :: Text

-- | Alias for the target table in a MERGE statement. Used when pretty
--   printing MERGE statments.
mergeTargetAlias :: Text

-- | USING section of a MERGE statement. Used in <a>fromMerge</a>.
fromMergeUsing :: MergeUsing -> Printer

-- | ON section of a MERGE statement. Used in <a>fromMerge</a>.
fromMergeOn :: MergeOn -> Printer

-- | WHEN MATCHED section of a MERGE statement. Used in <a>fromMerge</a>.
fromMergeWhenMatched :: MergeWhenMatched -> Printer

-- | WHEN NOT MATCHED section of a MERGE statement. Used in
--   <a>fromMerge</a>.
fromMergeWhenNotMatched :: MergeWhenNotMatched -> Printer

-- | Generate a MERGE SQL statement
fromMerge :: Merge -> Printer

-- | Generate a delete statement
--   
--   <pre>
--   Delete
--     (Aliased (TableName "table" "schema") "alias")
--     [ColumnName "id", ColumnName "name"]
--     (Where [OpExpression EQ' (ValueExpression (IntValue 1)) (ValueExpression (IntValue 1))])
--   </pre>
--   
--   Becomes:
--   
--   <pre>
--   DELETE [alias] OUTPUT DELETED.[id], DELETED.[name] INTO #deleted([id], [name]) FROM [schema].[table] AS [alias] WHERE ((1) = (1))
--   </pre>
fromDelete :: Delete -> Printer

-- | Generate an update statement
--   
--   <pre>
--   Update
--      (Aliased (TableName "table" "schema") "alias")
--      (fromList [(ColumnName "name", ValueExpression (TextValue "updated_name"))])
--      (Output Inserted)
--      (TempTable (TempTableName "updated") [ColumnName "id", ColumnName "name"])
--      (Where [OpExpression EQ' (ColumnName "id") (ValueExpression (IntValue 1))])
--   </pre>
--   
--   Becomes:
--   
--   <pre>
--   UPDATE [alias] SET [alias].[name] = 'updated_name' OUTPUT INSERTED.[id], INSERTED.[name] INTO
--   #updated([id], [name]) FROM [schema].[table] AS [alias] WHERE (id = 1)
--   </pre>
fromUpdate :: Update -> Printer
fromUpdateSet :: UpdateSet -> Printer

-- | Converts <a>SelectIntoTempTable</a>.
--   
--   <pre>
--   SelectIntoTempTable (TempTableName "deleted")  [UnifiedColumn "id" IntegerType, UnifiedColumn "name" TextType] (TableName "table" "schema")
--   </pre>
--   
--   Becomes:
--   
--   <pre>
--   SELECT [id], [name] INTO #deleted([id], [name]) FROM [schema].[table] WHERE (1&lt;&gt;1) UNION ALL SELECT [id], [name] FROM [schema].[table];
--   </pre>
--   
--   We add the `UNION ALL` part to avoid copying identity constraints, and
--   we cast columns with types such as <tt>timestamp</tt> which are
--   non-insertable to a different type.
fromSelectIntoTempTable :: SelectIntoTempTable -> Printer

-- | <tt>TempTableName "deleted"</tt> becomes <tt>#deleted</tt>
fromTempTableName :: TempTableName -> Printer
fromTempTable :: TempTable -> Printer

-- | @TempTableName "temp_table" is converted to "DROP TABLE #temp_table"
dropTempTableQuery :: TempTableName -> Printer
fromSelect :: Select -> Printer
fromWith :: With -> Printer
fromJoinSource :: JoinSource -> Printer
fromReselect :: Reselect -> Printer
fromOrderBys :: Top -> Maybe Expression -> Maybe (NonEmpty OrderBy) -> Printer
fromOrderBy :: OrderBy -> [Printer]
fromOrder :: Order -> Printer
fromNullsOrder :: FieldName -> NullsOrder -> Printer
fromJoinAlias :: JoinAlias -> Printer
fromFor :: For -> Printer
fromProjection :: Projection -> Printer
fromAggregate :: Aggregate -> Printer
fromCountable :: Countable FieldName -> Printer
fromWhere :: Where -> Printer

-- | Drop useless examples like this from the output:
--   
--   WHERE (((1&lt;&gt;1)) AND ((1=1))) AND ((1=1))
--   
--   And
--   
--   WHERE ((1&lt;&gt;1))
--   
--   They're redundant, but make the output less readable.
collapseWhere :: Expression -> Maybe Expression
fromFrom :: From -> Printer
fromOpenJson :: OpenJson -> Printer
fromJsonFieldSpec :: JsonFieldSpec -> Printer
fromTableName :: TableName -> Printer
fromAliased :: Aliased Printer -> Printer
fromColumnName :: ColumnName -> Printer
fromNameText :: Text -> Printer
fromRawUnescapedText :: Text -> Printer
truePrinter :: Printer
falsePrinter :: Printer
parens :: Printer -> Printer

-- | Pretty-prints a <a>Printer</a> as one line, converting
--   <a>NewlinePrinter</a> to space.
toQueryFlat :: Printer -> Query

-- | Pretty-prints a <a>Printer</a> as multiple lines as defined by the
--   printer.
toQueryPretty :: Printer -> Query
instance GHC.Classes.Eq Hasura.Backends.MSSQL.ToQuery.Printer
instance GHC.Show.Show Hasura.Backends.MSSQL.ToQuery.Printer
instance Data.String.IsString Hasura.Backends.MSSQL.ToQuery.Printer
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.Expression


-- | MSSQL Instances Types
--   
--   Defines a <a>Backend</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.Types
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MSSQL


-- | This module contains supporting definitions for building temporary
--   tables based off of the schema of other tables. This is used in
--   mutations to capture the data of rows that are affected.
module Hasura.Backends.MSSQL.FromIr.SelectIntoTempTable

-- | Create a temporary table with the same schema as the given table.
toSelectIntoTempTable :: TempTableName -> TableName -> [ColumnInfo 'MSSQL] -> SITTConstraints -> SelectIntoTempTable

-- | Extracts the type and column name of a ColumnInfo
columnInfoToUnifiedColumn :: ColumnInfo 'MSSQL -> UnifiedColumn


-- | This module provides constants that are either:
--   
--   <ul>
--   <li>Simply in common user</li>
--   <li>Define names that that multiple pieces of code reference.</li>
--   </ul>
module Hasura.Backends.MSSQL.FromIr.Constants
trueExpression :: Expression
nullExpression :: Expression
emptyArrayExpression :: Expression
jsonFieldName :: Text
aggSubselectName :: Text
existsFieldName :: Text
aggFieldName :: Text
tempTableNameInserted :: TempTableName
tempTableNameValues :: TempTableName
tempTableNameDeleted :: TempTableName
tempTableNameUpdated :: TempTableName


-- | Types for Transact-SQL aka T-SQL; the language of SQL Server.
module Hasura.Backends.BigQuery.Types
data Select
Select :: Top -> AsStruct -> NonEmpty Projection -> From -> [Join] -> Where -> Maybe (NonEmpty OrderBy) -> Maybe Expression -> [FieldName] -> Maybe [Text] -> Cardinality -> Select
[$sel:selectTop:Select] :: Select -> Top
[$sel:selectAsStruct:Select] :: Select -> AsStruct
[$sel:selectProjections:Select] :: Select -> NonEmpty Projection
[$sel:selectFrom:Select] :: Select -> From
[$sel:selectJoins:Select] :: Select -> [Join]
[$sel:selectWhere:Select] :: Select -> Where
[$sel:selectOrderBy:Select] :: Select -> Maybe (NonEmpty OrderBy)
[$sel:selectOffset:Select] :: Select -> Maybe Expression
[$sel:selectGroupBy:Select] :: Select -> [FieldName]
[$sel:selectFinalWantedFields:Select] :: Select -> Maybe [Text]
[$sel:selectCardinality:Select] :: Select -> Cardinality

-- | Helper type allowing addition of extra fields used in PARTITION BY.
--   
--   The main purpose of this type is sumulation of DISTINCT ON implemented
--   in Hasura.Backends.BigQuery.FromIr.simulateDistinctOn
data PartitionableSelect
PartitionableSelect :: (Maybe [FieldName] -> Select) -> From -> PartitionableSelect
[$sel:pselectFinalize:PartitionableSelect] :: PartitionableSelect -> Maybe [FieldName] -> Select
[$sel:pselectFrom:PartitionableSelect] :: PartitionableSelect -> From
simpleSelect :: Select -> PartitionableSelect
noExtraPartitionFields :: PartitionableSelect -> Select
withExtraPartitionFields :: PartitionableSelect -> [FieldName] -> Select
data ArrayAgg
ArrayAgg :: NonEmpty Projection -> Maybe (NonEmpty OrderBy) -> Top -> ArrayAgg
[$sel:arrayAggProjections:ArrayAgg] :: ArrayAgg -> NonEmpty Projection
[$sel:arrayAggOrderBy:ArrayAgg] :: ArrayAgg -> Maybe (NonEmpty OrderBy)
[$sel:arrayAggTop:ArrayAgg] :: ArrayAgg -> Top
data Reselect
Reselect :: NonEmpty Projection -> Where -> Reselect
[$sel:reselectProjections:Reselect] :: Reselect -> NonEmpty Projection
[$sel:reselectWhere:Reselect] :: Reselect -> Where
data OrderBy
OrderBy :: FieldName -> Order -> NullsOrder -> OrderBy
[$sel:orderByFieldName:OrderBy] :: OrderBy -> FieldName
[$sel:orderByOrder:OrderBy] :: OrderBy -> Order
[$sel:orderByNullsOrder:OrderBy] :: OrderBy -> NullsOrder
data Order
AscOrder :: Order
DescOrder :: Order
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder
NullsAnyOrder :: NullsOrder
data FieldOrigin
NoOrigin :: FieldOrigin
AggregateOrigin :: [Aliased Aggregate] -> FieldOrigin
aggregateProjectionsFieldOrigin :: Projection -> FieldOrigin
data Projection
ExpressionProjection :: Aliased Expression -> Projection
FieldNameProjection :: Aliased FieldName -> Projection
AggregateProjections :: Aliased (NonEmpty (Aliased Aggregate)) -> Projection
AggregateProjection :: Aliased Aggregate -> Projection
StarProjection :: Projection
ArrayAggProjection :: Aliased ArrayAgg -> Projection
EntityProjection :: Aliased [(FieldName, FieldOrigin)] -> Projection
ArrayEntityProjection :: EntityAlias -> Aliased [FieldName] -> Projection
WindowProjection :: Aliased WindowFunction -> Projection
data WindowFunction

-- | ROW_NUMBER() OVER(PARTITION BY field)
RowNumberOverPartitionBy :: NonEmpty FieldName -> Maybe (NonEmpty OrderBy) -> WindowFunction
data Join
Join :: JoinSource -> EntityAlias -> [(FieldName, FieldName)] -> JoinProvenance -> Text -> Maybe Text -> EntityAlias -> Join
[$sel:joinSource:Join] :: Join -> JoinSource
[$sel:joinAlias:Join] :: Join -> EntityAlias
[$sel:joinOn:Join] :: Join -> [(FieldName, FieldName)]
[$sel:joinProvenance:Join] :: Join -> JoinProvenance
[$sel:joinFieldName:Join] :: Join -> Text
[$sel:joinExtractPath:Join] :: Join -> Maybe Text
[$sel:joinRightTable:Join] :: Join -> EntityAlias
data JoinProvenance
OrderByJoinProvenance :: JoinProvenance
ObjectJoinProvenance :: [Text] -> JoinProvenance
ArrayAggregateJoinProvenance :: [(Text, FieldOrigin)] -> JoinProvenance
ArrayJoinProvenance :: [Text] -> JoinProvenance
MultiplexProvenance :: JoinProvenance
data JoinSource
JoinSelect :: Select -> JoinSource
newtype Where
Where :: [Expression] -> Where
data Cardinality
Many :: Cardinality
One :: Cardinality
data AsStruct
NoAsStruct :: AsStruct
AsStruct :: AsStruct
data Top
NoTop :: Top
Top :: Int64 -> Top
data Expression
ValueExpression :: Value -> Expression
InExpression :: Expression -> Value -> Expression
AndExpression :: [Expression] -> Expression
OrExpression :: [Expression] -> Expression
NotExpression :: Expression -> Expression
ExistsExpression :: Select -> Expression
SelectExpression :: Select -> Expression
IsNullExpression :: Expression -> Expression
IsNotNullExpression :: Expression -> Expression
ColumnExpression :: FieldName -> Expression
EqualExpression :: Expression -> Expression -> Expression
NotEqualExpression :: Expression -> Expression -> Expression

-- | This one acts like a "cast to JSON" and makes SQL Server behave like
--   it knows your field is JSON and not double-encode it.
JsonQueryExpression :: Expression -> Expression
ToStringExpression :: Expression -> Expression

-- | This is for getting actual atomic values out of a JSON string.
JsonValueExpression :: Expression -> JsonPath -> Expression
OpExpression :: Op -> Expression -> Expression -> Expression
ListExpression :: [Expression] -> Expression
CastExpression :: Expression -> ScalarType -> Expression
FunctionExpression :: FunctionName -> [Expression] -> Expression
ConditionalProjection :: Expression -> FieldName -> Expression

-- | A function input argument expression with argument name
--   <tt>argument_name</tt> =&gt; <tt>argument_value</tt>
FunctionNamedArgument :: Text -> Expression -> Expression
data JsonPath
RootPath :: JsonPath
FieldPath :: JsonPath -> Text -> JsonPath
IndexPath :: JsonPath -> Integer -> JsonPath
data Aggregate
CountAggregate :: Countable FieldName -> Aggregate
OpAggregates :: Text -> NonEmpty (Text, Expression) -> Aggregate
OpAggregate :: Text -> Expression -> Aggregate
TextAggregate :: Text -> Aggregate
data Countable fieldname
StarCountable :: Countable fieldname
NonNullFieldCountable :: NonEmpty fieldname -> Countable fieldname
DistinctCountable :: NonEmpty fieldname -> Countable fieldname
data From
FromQualifiedTable :: Aliased TableName -> From
FromSelect :: Aliased Select -> From
FromSelectJson :: Aliased SelectJson -> From
FromFunction :: Aliased SelectFromFunction -> From
data SelectJson
SelectJson :: Expression -> [(ColumnName, ScalarType)] -> SelectJson
[$sel:selectJsonBody:SelectJson] :: SelectJson -> Expression
[$sel:selectJsonFields:SelectJson] :: SelectJson -> [(ColumnName, ScalarType)]
data SelectFromFunction
SelectFromFunction :: FunctionName -> [Expression] -> SelectFromFunction
[$sel:sffFunctionName:SelectFromFunction] :: SelectFromFunction -> FunctionName
[$sel:sffArguments:SelectFromFunction] :: SelectFromFunction -> [Expression]
data OpenJson
OpenJson :: Expression -> NonEmpty JsonFieldSpec -> OpenJson
[$sel:openJsonExpression:OpenJson] :: OpenJson -> Expression
[$sel:openJsonWith:OpenJson] :: OpenJson -> NonEmpty JsonFieldSpec
data JsonFieldSpec
IntField :: Text -> JsonFieldSpec
JsonField :: Text -> JsonFieldSpec
data Aliased a
Aliased :: a -> Text -> Aliased a
[$sel:aliasedThing:Aliased] :: Aliased a -> a
[$sel:aliasedAlias:Aliased] :: Aliased a -> Text
newtype SchemaName
SchemaName :: [Text] -> SchemaName
[$sel:schemaNameParts:SchemaName] :: SchemaName -> [Text]
data TableName
TableName :: Text -> Text -> TableName
[$sel:tableName:TableName] :: TableName -> Text
[$sel:tableNameSchema:TableName] :: TableName -> Text
data FieldName
FieldName :: Text -> Text -> FieldName
[$sel:fieldName:FieldName] :: FieldName -> Text
[$sel:fieldNameEntity:FieldName] :: FieldName -> Text
newtype ColumnName
ColumnName :: Text -> ColumnName
[$sel:columnName:ColumnName] :: ColumnName -> Text
data Comment
DueToPermission :: Comment
RequestedSingleObject :: Comment
newtype EntityAlias
EntityAlias :: Text -> EntityAlias
[$sel:entityAliasText:EntityAlias] :: EntityAlias -> Text
columnToFieldName :: EntityAlias -> ColumnName -> FieldName
data Op
LessOp :: Op
LessOrEqualOp :: Op
MoreOp :: Op
MoreOrEqualOp :: Op
InOp :: Op
NotInOp :: Op
LikeOp :: Op
NotLikeOp :: Op

-- | Source for this represenation type:
--   
--   
--   <a>https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Value</a>
--   
--   BigQuery results come in via the REST API as one of these simply
--   types.
--   
--   TODO: This omits StructValue -- do we need it?
data Value
NullValue :: Value

-- | 64-bit
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#integer_type</a>
IntegerValue :: Int64 -> Value

-- | Fixed precision
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#decimal_types</a>
DecimalValue :: Decimal -> Value

-- | Fixed precision
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#decimal_types</a>
BigDecimalValue :: BigDecimal -> Value

-- | Floating point
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#floating_point_types</a>
FloatValue :: Float64 -> Value
GeographyValue :: Geography -> Value
StringValue :: Text -> Value
BytesValue :: Base64 -> Value
BoolValue :: Bool -> Value
ArrayValue :: Vector Value -> Value
TimestampValue :: Timestamp -> Value
DateValue :: Date -> Value
TimeValue :: Time -> Value
DatetimeValue :: Datetime -> Value

-- | BigQuery's conception of a timestamp.
newtype Timestamp
Timestamp :: Text -> Timestamp

-- | BigQuery's conception of a date.
newtype Date
Date :: Text -> Date

-- | BigQuery's conception of a time.
newtype Time
Time :: Text -> Time

-- | BigQuery's conception of a datetime.
newtype Datetime
Datetime :: Text -> Datetime

-- | BigQuery's conception of an INTEGER/INT64 (they are the same).
newtype Int64
Int64 :: Text -> Int64
intToInt64 :: Int64 -> Int64
int64Expr :: Int64 -> Expression

-- | BigQuery's conception of a fixed precision decimal.
newtype Decimal
Decimal :: Text -> Decimal

-- | Convert <a>Scientific</a> to <a>Text</a>
scientificToText :: Scientific -> Text

-- | BigQuery's conception of a "big" fixed precision decimal.
newtype BigDecimal
BigDecimal :: Text -> BigDecimal
doubleToBigDecimal :: Double -> BigDecimal

-- | BigQuery's conception of a fixed precision decimal.
newtype Float64
Float64 :: Text -> Float64
doubleToFloat64 :: Double -> Float64

-- | A base-64 encoded binary string.
newtype Base64
Base64 :: ByteString -> Base64
[$sel:unBase64:Base64] :: Base64 -> ByteString
newtype Geography
Geography :: Text -> Geography
[$sel:unGeography:Geography] :: Geography -> Text
data ScalarType
StringScalarType :: ScalarType
BytesScalarType :: ScalarType
IntegerScalarType :: ScalarType
FloatScalarType :: ScalarType
BoolScalarType :: ScalarType
TimestampScalarType :: ScalarType
DateScalarType :: ScalarType
TimeScalarType :: ScalarType
DatetimeScalarType :: ScalarType
GeographyScalarType :: ScalarType
DecimalScalarType :: ScalarType
BigDecimalScalarType :: ScalarType
StructScalarType :: ScalarType
data UnifiedMetadata
UnifiedMetadata :: [UnifiedTableMetadata] -> UnifiedMetadata
[$sel:tables:UnifiedMetadata] :: UnifiedMetadata -> [UnifiedTableMetadata]
data UnifiedTableMetadata
UnifiedTableMetadata :: UnifiedTableName -> [UnifiedObjectRelationship] -> [UnifiedArrayRelationship] -> [UnifiedColumn] -> UnifiedTableMetadata
[$sel:table:UnifiedTableMetadata] :: UnifiedTableMetadata -> UnifiedTableName
[$sel:object_relationships:UnifiedTableMetadata] :: UnifiedTableMetadata -> [UnifiedObjectRelationship]
[$sel:array_relationships:UnifiedTableMetadata] :: UnifiedTableMetadata -> [UnifiedArrayRelationship]
[$sel:columns:UnifiedTableMetadata] :: UnifiedTableMetadata -> [UnifiedColumn]
data UnifiedColumn
UnifiedColumn :: Text -> ScalarType -> UnifiedColumn
[$sel:name:UnifiedColumn] :: UnifiedColumn -> Text
[$sel:type':UnifiedColumn] :: UnifiedColumn -> ScalarType
data UnifiedTableName
UnifiedTableName :: Text -> Text -> UnifiedTableName
[$sel:schema:UnifiedTableName] :: UnifiedTableName -> Text
[$sel:name:UnifiedTableName] :: UnifiedTableName -> Text
data UnifiedObjectRelationship
UnifiedObjectRelationship :: UnifiedUsing -> Text -> UnifiedObjectRelationship
[$sel:using:UnifiedObjectRelationship] :: UnifiedObjectRelationship -> UnifiedUsing
[$sel:name:UnifiedObjectRelationship] :: UnifiedObjectRelationship -> Text
data UnifiedArrayRelationship
UnifiedArrayRelationship :: UnifiedUsing -> Text -> UnifiedArrayRelationship
[$sel:using:UnifiedArrayRelationship] :: UnifiedArrayRelationship -> UnifiedUsing
[$sel:name:UnifiedArrayRelationship] :: UnifiedArrayRelationship -> Text
data UnifiedUsing
UnifiedUsing :: UnifiedOn -> UnifiedUsing
[$sel:foreign_key_constraint_on:UnifiedUsing] :: UnifiedUsing -> UnifiedOn
data UnifiedOn
UnifiedOn :: UnifiedTableName -> Text -> UnifiedOn
[$sel:table:UnifiedOn] :: UnifiedOn -> UnifiedTableName
[$sel:column:UnifiedOn] :: UnifiedOn -> Text
data BooleanOperators a
ASTContains :: a -> BooleanOperators a
ASTEquals :: a -> BooleanOperators a
ASTTouches :: a -> BooleanOperators a
ASTWithin :: a -> BooleanOperators a
ASTIntersects :: a -> BooleanOperators a
ASTDWithin :: DWithinGeogOp a -> BooleanOperators a
data FunctionName
FunctionName :: Text -> Maybe Text -> FunctionName
[$sel:functionName:FunctionName] :: FunctionName -> Text

-- | System functions like "unnest" don't have schema/dataset
[$sel:functionNameSchema:FunctionName] :: FunctionName -> Maybe Text

-- | The metadata required to define a computed field for a BigQuery table
data ComputedFieldDefinition
ComputedFieldDefinition :: FunctionName -> Maybe TableName -> HashMap FunctionArgName ColumnName -> ComputedFieldDefinition

-- | Name of the user defined routine
[$sel:_bqcfdFunction:ComputedFieldDefinition] :: ComputedFieldDefinition -> FunctionName

-- | Name of the table which the function returns. If not provided the
--   return table schema is inferred from the routine API metadata.
[$sel:_bqcfdReturnTable:ComputedFieldDefinition] :: ComputedFieldDefinition -> Maybe TableName

-- | A mapping context to determine argument value from table column
[$sel:_bqcfdArgumentMapping:ComputedFieldDefinition] :: ComputedFieldDefinition -> HashMap FunctionArgName ColumnName

-- | A argument expression for SQL functions
data ArgumentExp v

-- | Value coming from user's input through GraphQL query
AEInput :: v -> ArgumentExp v

-- | For computed fields, value of column from the table
AETableColumn :: ColumnName -> ArgumentExp v
type ComputedFieldImplicitArguments = HashMap FunctionArgName ColumnName

-- | Returning type of the function underlying a computed field
data ComputedFieldReturn

-- | Returns existing table, needs to be present in the metadata
ReturnExistingTable :: TableName -> ComputedFieldReturn

-- | An arbitrary table schema specified by column name and type pairs
ReturnTableSchema :: [(ColumnName, Name, ScalarType)] -> ComputedFieldReturn

-- | Function input argument specification
data FunctionArgument
FunctionArgument :: FunctionArgName -> ScalarType -> FunctionArgument

-- | Argument name of a table valued function is required Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_table_function_statement</a>
[$sel:_faName:FunctionArgument] :: FunctionArgument -> FunctionArgName

-- | The data type of the argument
[$sel:_faType:FunctionArgument] :: FunctionArgument -> ScalarType
parseScalarValue :: ScalarType -> Value -> Either QErr Value
isComparableType :: ScalarType -> Bool
isNumType :: ScalarType -> Bool
getGQLTableName :: TableName -> Either QErr Name
liberalIntegralPrinter :: Coercible Text a => a -> Value
liberalDecimalPrinter :: Coercible a Text => a -> Value

-- | Parse from text by simply validating it contains digits; otherwise,
--   require a JSON integer.
liberalInt64Parser :: (Text -> a) -> Value -> Parser a

-- | Parse either a JSON native double number, or a text string containing
--   something vaguely in scientific notation. In either case, producing a
--   wrapped Text as the final result.
liberalDecimalParser :: (Text -> a) -> Value -> Parser a
projectionAlias :: Projection -> Maybe Text
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Order
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Order
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Order
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Order
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Order
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Order
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.NullsOrder
instance Data.Data.Data Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.NullsOrder
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Cardinality
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Cardinality
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.AsStruct
instance Data.Data.Data Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.AsStruct
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Top
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Top
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Top
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Top
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Top
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Top
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JsonPath
instance Data.Data.Data Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JsonPath
instance Language.Haskell.TH.Syntax.Lift fieldname => Language.Haskell.TH.Syntax.Lift (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance Data.Data.Data fieldname => Data.Data.Data (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Generics.Generic (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Show.Show fieldname => GHC.Show.Show (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Classes.Ord fieldname => GHC.Classes.Ord (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Classes.Eq fieldname => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Data.Data.Data Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Base.Functor Hasura.Backends.BigQuery.Types.Aliased
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Data.Data a => Data.Data.Data (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Generics.Generic (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.Aliased a)
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.SchemaName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.SchemaName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.SchemaName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.SchemaName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.SchemaName
instance Data.Data.Data Hasura.Backends.BigQuery.Types.SchemaName
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.SchemaName
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.SchemaName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.SchemaName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.SchemaName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.SchemaName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.TableName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.TableName
instance Data.Data.Data Hasura.Backends.BigQuery.Types.TableName
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.TableName
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.TableName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.TableName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.FieldName
instance Data.Data.Data Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FieldName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.OrderBy
instance Data.Data.Data Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.WindowFunction
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.WindowFunction
instance Data.Data.Data Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.WindowFunction
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.ColumnName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ColumnName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.ColumnName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Data.Data Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ColumnName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Comment
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Comment
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Comment
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Comment
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Comment
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Comment
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.EntityAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.EntityAlias
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.EntityAlias
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.EntityAlias
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.EntityAlias
instance Data.Data.Data Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.EntityAlias
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.EntityAlias
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Op
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Op
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Op
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Op
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Op
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Op
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Timestamp
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Timestamp
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Timestamp
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Timestamp
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Timestamp
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Timestamp
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Timestamp
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Date
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Date
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Date
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Date
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Date
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Date
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Date
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Date
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Date
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Date
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Date
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Time
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Time
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Time
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Time
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Time
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Time
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Time
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Time
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Time
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Time
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Time
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Datetime
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Datetime
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Datetime
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Datetime
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Datetime
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Datetime
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Datetime
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Int64
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Int64
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Int64
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Int64
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Int64
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Int64
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Int64
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Int64
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Int64
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Decimal
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Decimal
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Decimal
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Decimal
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Decimal
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.BigDecimal
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.BigDecimal
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.BigDecimal
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.BigDecimal
instance Data.Data.Data Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.BigDecimal
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Float64
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Float64
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Float64
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Float64
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Float64
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Float64
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Float64
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Float64
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Float64
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Base64
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Base64
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Base64
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Base64
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Base64
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Base64
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Geography
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Geography
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Geography
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Geography
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Geography
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Geography
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Geography
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Geography
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Value
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Value
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Value
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Value
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Value
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Value
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Data.Data Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedColumn
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedColumn
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedColumn
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedTableName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedTableName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedTableName
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedOn
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedOn
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedOn
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedUsing
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedUsing
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedUsing
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedArrayRelationship
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedArrayRelationship
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedArrayRelationship
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedObjectRelationship
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedObjectRelationship
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedObjectRelationship
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedTableMetadata
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedTableMetadata
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedTableMetadata
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedMetadata
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedMetadata
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedMetadata
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Data.Traversable.Traversable Hasura.Backends.BigQuery.Types.BooleanOperators
instance GHC.Base.Functor Hasura.Backends.BigQuery.Types.BooleanOperators
instance Data.Foldable.Foldable Hasura.Backends.BigQuery.Types.BooleanOperators
instance GHC.Generics.Generic (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.FunctionName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Data.Data Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FunctionName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.ArrayAgg
instance Data.Data.Data Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Projection
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Projection
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Projection
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Projection
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Projection
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Projection
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Aggregate
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Aggregate
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.FieldOrigin
instance Data.Data.Data Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FieldOrigin
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JoinProvenance
instance Data.Data.Data Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JoinProvenance
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JoinSource
instance Data.Data.Data Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JoinSource
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Join
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Join
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Join
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Join
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Join
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Join
instance GHC.Base.Monoid Hasura.Backends.BigQuery.Types.Where
instance GHC.Base.Semigroup Hasura.Backends.BigQuery.Types.Where
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Where
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Where
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Where
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Where
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Where
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Where
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Where
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Where
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Where
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Where
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.SelectJson
instance Data.Data.Data Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Data.Data.Data Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.From
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.From
instance Data.Data.Data Hasura.Backends.BigQuery.Types.From
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.From
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.From
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.From
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Select
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Select
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Select
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Select
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Select
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Select
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Expression
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Expression
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Expression
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Expression
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Expression
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Expression
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.OpenJson
instance Data.Data.Data Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.OpenJson
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Reselect
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Data.Data.Data Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Generics.Generic (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance Data.Traversable.Traversable Hasura.Backends.BigQuery.Types.ArgumentExp
instance Data.Foldable.Foldable Hasura.Backends.BigQuery.Types.ArgumentExp
instance GHC.Base.Functor Hasura.Backends.BigQuery.Types.ArgumentExp
instance GHC.Show.Show v => GHC.Show.Show (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hasura.Backends.BigQuery.Types.Aliased a)
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.FunctionArgument
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FunctionArgument
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FunctionArgument
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.FunctionArgument
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance Data.Hashable.Class.Hashable v => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Reselect
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Reselect
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Reselect
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Reselect
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.OpenJson
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.OpenJson
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.OpenJson
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.OpenJson
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Select
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Select
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Select
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Select
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.ArrayAgg
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ArrayAgg
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.ArrayAgg
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ArrayAgg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.FieldOrigin
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FieldOrigin
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.FieldOrigin
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FieldOrigin
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Projection
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Projection
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Projection
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Projection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Join
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Join
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Join
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Join
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.JoinProvenance
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JoinProvenance
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.JoinProvenance
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JoinProvenance
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.JoinSource
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JoinSource
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.JoinSource
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JoinSource
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Expression
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Expression
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Expression
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Expression
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Aggregate
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Aggregate
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Aggregate
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Aggregate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.From
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.From
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.From
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.From
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.SelectJson
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.SelectJson
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.SelectJson
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.SelectJson
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.FunctionName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FunctionName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.FunctionName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FunctionName
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.ScalarType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.ScalarType
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.ScalarType
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Value
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Value
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Value
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Value
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Value
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Geography
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Geography
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Geography
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Base64
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Base64
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Base64
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Base64
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Base64
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Float64
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Float64
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.BigDecimal
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.BigDecimal
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Decimal
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Decimal
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Int64
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Int64
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Op
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Op
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Op
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Op
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Op
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Comment
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Comment
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Comment
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Comment
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Comment
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.WindowFunction
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.WindowFunction
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.WindowFunction
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.WindowFunction
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.WindowFunction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.OrderBy
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.OrderBy
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.OrderBy
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.OrderBy
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.OrderBy
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.FieldName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FieldName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.FieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.FieldName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.TableName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.TableName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.TableName
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.TableName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.TableName
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.Aliased a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.BigQuery.Types.Aliased a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.BigQuery.Types.Countable a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.Countable a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.Backends.BigQuery.Types.Countable a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.BigQuery.Types.Countable a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Types.Countable a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.JsonPath
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JsonPath
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.JsonPath
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.JsonPath
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JsonPath
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Top
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Top
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Top
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Top
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Top
instance GHC.Base.Monoid Hasura.Backends.BigQuery.Types.Top
instance GHC.Base.Semigroup Hasura.Backends.BigQuery.Types.Top
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.AsStruct
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.AsStruct
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.AsStruct
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.AsStruct
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.AsStruct
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Cardinality
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Cardinality
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Cardinality
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Cardinality
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Cardinality
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.NullsOrder
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.NullsOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.NullsOrder
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.NullsOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Order
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Order
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Backends.BigQuery.Types.Order
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Order
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Order


-- | Convert the simple BigQuery AST to an SQL query, ready to be passed to
--   the odbc package's query/exec functions.
module Hasura.Backends.BigQuery.ToQuery
data Printer
SeqPrinter :: [Printer] -> Printer
SepByPrinter :: Printer -> [Printer] -> Printer
NewlinePrinter :: Printer
UnsafeTextPrinter :: Text -> Printer
IndentPrinter :: Int -> Printer -> Printer
ValuePrinter :: Value -> Printer
(<+>) :: Printer -> Printer -> Printer
fromExpression :: Expression -> Printer
fromScalarType :: ScalarType -> Printer
fromOp :: Op -> Printer
fromPath :: JsonPath -> Printer
fromFieldName :: FieldName -> Printer
fromSelect :: Select -> Printer
fromOn :: (FieldName, FieldName) -> Printer
fromJoinSource :: JoinSource -> Printer
fromReselect :: Reselect -> Printer
fromOrderBys :: Top -> Maybe Expression -> Maybe (NonEmpty OrderBy) -> Printer
fromOrderBy :: OrderBy -> Printer
fromOrder :: Order -> Printer
fromNullsOrder :: NullsOrder -> Printer
fromJoinAlias :: EntityAlias -> Printer
fromProjection :: Projection -> Printer
fromFieldOrigin :: FieldOrigin -> Printer
fromWindowFunction :: WindowFunction -> Printer
fromArrayAgg :: ArrayAgg -> Printer
fromNullAggregate :: Aggregate -> Printer
fromAggregate :: Aggregate -> Printer
fromCountable :: Countable FieldName -> Printer
fromWhere :: Where -> Printer
fromSelectJson :: SelectJson -> Printer
fromFrom :: From -> Printer
fromTableName :: TableName -> Printer
fromFunctionName :: FunctionName -> Printer
fromAliased :: Aliased Printer -> Printer
fromNameText :: Text -> Printer
trueExpression :: Expression
falseExpression :: Expression
fromValue :: Value -> Printer
parens :: Printer -> Printer
toBuilderFlat :: Printer -> Builder
toBuilderPretty :: Printer -> Builder
toTextPretty :: Printer -> Text
toTextFlat :: Printer -> Text

-- | Produces a query with holes, and a mapping for each
renderBuilderFlat :: Printer -> (Builder, InsOrdHashMap Int Value)

-- | Produces a query with holes, and a mapping for each
renderBuilderPretty :: Printer -> (Builder, InsOrdHashMap Int Value)
paramName :: Int -> Builder
runBuilderFlat :: Printer -> State (InsOrdHashMap Value Int) Builder
runBuilderPretty :: Printer -> State (InsOrdHashMap Value Int) Builder

-- | TODO: For now, we're littering this around where projections are
--   built. I'd prefer to use ordered set, or else a newtype wrapper to
--   prove it's been sorted. But that would interrupt code elsewhere. For
--   now, this is an acceptable solution. Plus, a warning issued about
--   duplicates might be useful.
cleanProjections :: NonEmpty Projection -> NonEmpty Projection
instance GHC.Classes.Eq Hasura.Backends.BigQuery.ToQuery.Printer
instance GHC.Show.Show Hasura.Backends.BigQuery.ToQuery.Printer
instance Data.String.IsString Hasura.Backends.BigQuery.ToQuery.Printer
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Expression

module Hasura.Backends.BigQuery.Meta
data MetadataError
RestProblem :: RestProblem -> MetadataError
data RestProblem
GetTablesProblem :: SomeException -> RestProblem
GetTableProblem :: SomeException -> RestProblem
GetRoutineProblem :: SomeException -> RestProblem
GetMetaDecodeProblem :: String -> RestProblem
GetTablesBigQueryProblem :: BigQueryProblem -> RestProblem
GetRoutinesBigQueryProblem :: BigQueryProblem -> RestProblem
RESTRequestNonOK :: Status -> RestProblem
data RestTableList
RestTableList :: Maybe Text -> [RestTableBrief] -> RestTableList
[$sel:nextPageToken:RestTableList] :: RestTableList -> Maybe Text
[$sel:tables:RestTableList] :: RestTableList -> [RestTableBrief]
data RestTableBrief
RestTableBrief :: RestTableReference -> RestTableBrief
[$sel:tableReference:RestTableBrief] :: RestTableBrief -> RestTableReference
data RestTableReference
RestTableReference :: Text -> Text -> Text -> RestTableReference
[$sel:datasetId:RestTableReference] :: RestTableReference -> Text
[$sel:projectId:RestTableReference] :: RestTableReference -> Text
[$sel:tableId:RestTableReference] :: RestTableReference -> Text
data RestTable
RestTable :: RestTableReference -> RestTableSchema -> RestTable
[$sel:tableReference:RestTable] :: RestTable -> RestTableReference
[$sel:schema:RestTable] :: RestTable -> RestTableSchema
data RestTableSchema
RestTableSchema :: [RestFieldSchema] -> RestTableSchema
[$sel:fields:RestTableSchema] :: RestTableSchema -> [RestFieldSchema]
data RestFieldSchema
RestFieldSchema :: Text -> RestType -> Mode -> RestFieldSchema
[$sel:name:RestFieldSchema] :: RestFieldSchema -> Text

-- | The field data type. Possible values include STRING, BYTES, INTEGER,
--   INT64 (same as INTEGER), FLOAT, FLOAT64 (same as FLOAT), BOOLEAN, BOOL
--   (same as BOOLEAN), TIMESTAMP, DATE, TIME, DATETIME, GEOGRAPHY,
--   NUMERIC, RECORD (where RECORD indicates that the field contains a
--   nested schema) or STRUCT (same as RECORD).
[$sel:type':RestFieldSchema] :: RestFieldSchema -> RestType
[$sel:mode:RestFieldSchema] :: RestFieldSchema -> Mode
data Mode
Nullable :: Mode
Required :: Mode
Repeated :: Mode
data RestType
STRING :: RestType
BYTES :: RestType
INTEGER :: RestType
FLOAT :: RestType
BOOL :: RestType
TIMESTAMP :: RestType
DATE :: RestType
TIME :: RestType
DATETIME :: RestType
GEOGRAPHY :: RestType
DECIMAL :: RestType
BIGDECIMAL :: RestType
STRUCT :: RestType

-- | Get all tables from all specified data sets.
getTables :: MonadIO m => BigQuerySourceConfig -> m (Either RestProblem [RestTable])

-- | Get tables in the dataset.
getTablesForDataSet :: MonadIO m => BigQueryConnection -> Text -> m (Either RestProblem [RestTable])

-- | Get tables in the schema.
getTable :: MonadIO m => BigQueryConnection -> Text -> Text -> m (Either RestProblem RestTable)
encodeParams :: [(Text, Text)] -> Text

-- | The fine-grained type of the routine Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#RoutineType</a>
data RestRoutineType
ROUTINE_TYPE_UNSPECIFIED :: RestRoutineType
SCALAR_FUNCTION :: RestRoutineType
PROCEDURE :: RestRoutineType
TABLE_VALUED_FUNCTION :: RestRoutineType

-- | Input argument of a function/routine. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#Argument</a>
data RestArgument
RestArgument :: Maybe Text -> Maybe RestType -> RestArgument

-- | The name of this argument. Can be absent for function return argument.
[$sel:_raName:RestArgument] :: RestArgument -> Maybe Text
[$sel:_raDataType:RestArgument] :: RestArgument -> Maybe RestType

-- | A field or a column. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlField</a>
data RestStandardSqlField
RestStandardSqlField :: Maybe Text -> Maybe RestType -> RestStandardSqlField

-- | The field name is optional and is absent for fields with STRUCT type.
[$sel:_rssfName:RestStandardSqlField] :: RestStandardSqlField -> Maybe Text
[$sel:_rssType:RestStandardSqlField] :: RestStandardSqlField -> Maybe RestType

-- | A table type, which has only list of columns with names and types.
--   Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#StandardSqlTableType</a>
data RestStandardSqlTableType
RestStandardSqlTableType :: [RestStandardSqlField] -> RestStandardSqlTableType
[$sel:_rrttColumns:RestStandardSqlTableType] :: RestStandardSqlTableType -> [RestStandardSqlField]

-- | Id path of a routine. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#RoutineReference</a>
data RestRoutineReference
RestRoutineReference :: Text -> Text -> Text -> RestRoutineReference
[$sel:datasetId:RestRoutineReference] :: RestRoutineReference -> Text
[$sel:projectId:RestRoutineReference] :: RestRoutineReference -> Text
[$sel:routineId:RestRoutineReference] :: RestRoutineReference -> Text
routineReferenceToFunctionName :: RestRoutineReference -> FunctionName

-- | A user-defined function. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#Routine</a>
data RestRoutine
RestRoutine :: RestRoutineReference -> RestRoutineType -> Maybe [RestArgument] -> Maybe RestStandardSqlTableType -> RestRoutine

-- | Reference describing the ID of this routine
[$sel:routineReference:RestRoutine] :: RestRoutine -> RestRoutineReference

-- | The type of routine
[$sel:routineType:RestRoutine] :: RestRoutine -> RestRoutineType

-- | List of arguments defined
[$sel:arguments:RestRoutine] :: RestRoutine -> Maybe [RestArgument]

-- | Routines defined with 'RETURNS TABLE' clause has this information
[$sel:returnTableType:RestRoutine] :: RestRoutine -> Maybe RestStandardSqlTableType

-- | List of routines Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines/list</a>
data RestRoutineList
RestRoutineList :: [RestRoutine] -> Maybe Text -> RestRoutineList
[$sel:_rrlRoutines:RestRoutineList] :: RestRoutineList -> [RestRoutine]
[$sel:_rrlNextPageToken:RestRoutineList] :: RestRoutineList -> Maybe Text

-- | Get all routines from all specified data sets.
getRoutines :: MonadIO m => BigQuerySourceConfig -> m (Either RestProblem [RestRoutine])

-- | Get routines in the dataset.
getRoutinesForDataSet :: MonadIO m => BigQueryConnection -> Text -> m (Either RestProblem [RestRoutine])
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestProblem
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.MetadataError
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTableReference
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestTableReference
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTableBrief
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestTableBrief
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestTableList
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.Mode
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestType
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestFieldSchema
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestFieldSchema
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTableSchema
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestTableSchema
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTable
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestTable
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestRoutineType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestRoutineType
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutineType
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestArgument
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestArgument
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestRoutine
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutine
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutineList
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutineList
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutine
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestArgument
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutineType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableSchema
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestFieldSchema
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.Mode
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableList
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableBrief
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableReference

module Hasura.Backends.BigQuery.Instances.Types
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.BigQuery

module Hasura.RQL.Types.Instances

module Hasura.RQL.Types.SourceCustomization
data RootFieldsCustomization
RootFieldsCustomization :: Maybe Name -> Maybe Name -> Maybe Name -> RootFieldsCustomization
[_rootfcNamespace] :: RootFieldsCustomization -> Maybe Name
[_rootfcPrefix] :: RootFieldsCustomization -> Maybe Name
[_rootfcSuffix] :: RootFieldsCustomization -> Maybe Name
emptyRootFieldsCustomization :: RootFieldsCustomization
data SourceTypeCustomization
SourceTypeCustomization :: Maybe Name -> Maybe Name -> SourceTypeCustomization
[_stcPrefix] :: SourceTypeCustomization -> Maybe Name
[_stcSuffix] :: SourceTypeCustomization -> Maybe Name
emptySourceTypeCustomization :: SourceTypeCustomization
mkCustomizedTypename :: Maybe SourceTypeCustomization -> NamingCase -> MkTypename
mkCustomizedFieldName :: Maybe RootFieldsCustomization -> NamingCase -> MkRootFieldName

-- | apply prefix and suffix to type name according to the source
--   customization
applyTypeCust :: Maybe SourceTypeCustomization -> NamingCase -> Name -> Name

-- | apply prefix and suffix to field name according to the source
--   customization
applyFieldCust :: Maybe RootFieldsCustomization -> NamingCase -> Name -> Name

-- | apply naming convention to type name
applyTypeNameCaseCust :: NamingCase -> Name -> Name

-- | apply naming convention to field name
applyFieldNameCaseCust :: NamingCase -> Name -> Name

-- | returns field name according to the naming conventions as
--   <tt>Text</tt>
getTextFieldName :: NamingCase -> GQLNameIdentifier -> Text

-- | applies naming convention and returns field name
--   
--   Note: This can't possibly fail as <tt>GQLNameIdentifier</tt> contains
--   already validated identifiers
applyTypeNameCaseIdentifier :: NamingCase -> GQLNameIdentifier -> Name

-- | returns type name according to the naming conventions as <tt>Text</tt>
getTextTypeName :: NamingCase -> GQLNameIdentifier -> Text

-- | applies naming convention and returns type name
--   
--   Note: This can't possibly fail as <tt>GQLNameIdentifier</tt> contains
--   already validated identifiers
applyFieldNameCaseIdentifier :: NamingCase -> GQLNameIdentifier -> Name
applyEnumValueCase :: NamingCase -> Name -> Name

-- | append<i>prepend the suffix</i>prefix in the graphql name
applyPrefixSuffix :: Maybe Name -> Maybe Name -> NamingCase -> Bool -> Name -> Name
concatPrefixSuffix :: NamingCase -> Bool -> NonEmpty (Name, NameOrigin) -> Name
data SourceCustomization
SourceCustomization :: Maybe RootFieldsCustomization -> Maybe SourceTypeCustomization -> Maybe NamingCase -> SourceCustomization
[_scRootFields] :: SourceCustomization -> Maybe RootFieldsCustomization
[_scTypeNames] :: SourceCustomization -> Maybe SourceTypeCustomization
[_scNamingConvention] :: SourceCustomization -> Maybe NamingCase
emptySourceCustomization :: SourceCustomization
getRootFieldsCustomization :: SourceCustomization -> RootFieldsCustomization
getSourceTypeCustomization :: SourceCustomization -> SourceTypeCustomization
getNamingConvention :: SourceCustomization -> Maybe NamingCase -> NamingCase

-- | Function to apply root field name customizations.
newtype MkRootFieldName
MkRootFieldName :: (Name -> Name) -> MkRootFieldName
[runMkRootFieldName] :: MkRootFieldName -> Name -> Name
getRootFieldsCustomizer :: forall m. MonadError QErr m => SourceCustomization -> SupportedNamingCase -> Maybe NamingCase -> m MkRootFieldName

-- | Inject NamingCase, typename and root field name customizations from
--   <tt>SourceCustomization</tt> into the environment.
withSourceCustomization :: forall m r a. (MonadReader r m, Has MkTypename r, Has NamingCase r, MonadError QErr m) => SourceCustomization -> SupportedNamingCase -> Maybe NamingCase -> m a -> m a
getNamingCase :: forall m. MonadError QErr m => SourceCustomization -> SupportedNamingCase -> Maybe NamingCase -> m NamingCase
withNamingCaseCustomization :: forall m r a. (MonadReader r m, Has NamingCase r) => NamingCase -> m a -> m a
newtype CustomizeRemoteFieldName
CustomizeRemoteFieldName :: (Name -> Name -> Name) -> CustomizeRemoteFieldName
[runCustomizeRemoteFieldName] :: CustomizeRemoteFieldName -> Name -> Name -> Name
withRemoteFieldNameCustomization :: forall m r a. (MonadReader r m, Has CustomizeRemoteFieldName r) => CustomizeRemoteFieldName -> m a -> m a
mkSelectField :: GQLNameIdentifier -> GQLNameIdentifier
mkSelectAggregateField :: GQLNameIdentifier -> GQLNameIdentifier
mkSelectByPkField :: GQLNameIdentifier -> GQLNameIdentifier
mkInsertField :: GQLNameIdentifier -> GQLNameIdentifier
mkInsertOneField :: GQLNameIdentifier -> GQLNameIdentifier
mkUpdateField :: GQLNameIdentifier -> GQLNameIdentifier
mkUpdateByPkField :: GQLNameIdentifier -> GQLNameIdentifier
mkUpdateManyField :: GQLNameIdentifier -> GQLNameIdentifier
mkDeleteField :: GQLNameIdentifier -> GQLNameIdentifier
mkDeleteByPkField :: GQLNameIdentifier -> GQLNameIdentifier
mkRelayConnectionField :: GQLNameIdentifier -> GQLNameIdentifier
mkSelectStreamField :: GQLNameIdentifier -> GQLNameIdentifier
mkMultiRowUpdateTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkOnConflictTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableConstraintTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateFieldTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkFunctionArgsTypeName :: Name -> GQLNameIdentifier -> GQLNameIdentifier
mkTableBoolExpTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableInsertInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableObjRelInsertInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableArrRelInsertInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableMutationResponseTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableOrderByTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateOrderByTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggOperatorTypeName :: GQLNameIdentifier -> Name -> GQLNameIdentifier
mkTableSelectColumnTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableUpdateColumnTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableOperatorInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier
mkTablePkColumnsInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkEnumTableTypeName :: GQLNameIdentifier -> Maybe Name -> GQLNameIdentifier
instance GHC.Generics.Generic Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance GHC.Show.Show Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance GHC.Classes.Eq Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance GHC.Generics.Generic Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance GHC.Show.Show Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance GHC.Classes.Eq Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance GHC.Generics.Generic Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance GHC.Show.Show Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance GHC.Classes.Eq Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance GHC.Base.Monoid Hasura.RQL.Types.SourceCustomization.MkRootFieldName
instance GHC.Base.Semigroup Hasura.RQL.Types.SourceCustomization.MkRootFieldName
instance GHC.Base.Monoid Hasura.RQL.Types.SourceCustomization.CustomizeRemoteFieldName
instance GHC.Base.Semigroup Hasura.RQL.Types.SourceCustomization.CustomizeRemoteFieldName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization

module Hasura.RQL.Types.RemoteSchema
type UrlFromEnv = Text

-- | Remote schema identifier.
--   
--   NOTE: no validation on the character set is done here; it's likely
--   there is a bug (FIXME) where this interacts with remote relationships
--   and some name mangling needs to happen.
newtype RemoteSchemaName
RemoteSchemaName :: NonEmptyText -> RemoteSchemaName
[unRemoteSchemaName] :: RemoteSchemaName -> NonEmptyText
data RemoteTypeCustomization
RemoteTypeCustomization :: Maybe Name -> Maybe Name -> HashMap Name Name -> RemoteTypeCustomization
[_rtcPrefix] :: RemoteTypeCustomization -> Maybe Name
[_rtcSuffix] :: RemoteTypeCustomization -> Maybe Name
[_rtcMapping] :: RemoteTypeCustomization -> HashMap Name Name
data RemoteFieldCustomization
RemoteFieldCustomization :: Name -> Maybe Name -> Maybe Name -> HashMap Name Name -> RemoteFieldCustomization
[_rfcParentType] :: RemoteFieldCustomization -> Name
[_rfcPrefix] :: RemoteFieldCustomization -> Maybe Name
[_rfcSuffix] :: RemoteFieldCustomization -> Maybe Name
[_rfcMapping] :: RemoteFieldCustomization -> HashMap Name Name
data RemoteSchemaCustomization
RemoteSchemaCustomization :: Maybe Name -> Maybe RemoteTypeCustomization -> Maybe [RemoteFieldCustomization] -> RemoteSchemaCustomization
[_rscRootFieldsNamespace] :: RemoteSchemaCustomization -> Maybe Name
[_rscTypeNames] :: RemoteSchemaCustomization -> Maybe RemoteTypeCustomization
[_rscFieldNames] :: RemoteSchemaCustomization -> Maybe [RemoteFieldCustomization]

-- | <a>RemoteSchemaDef</a> after validation and baking-in of defaults in
--   <a>validateRemoteSchemaDef</a>.
data ValidatedRemoteSchemaDef
ValidatedRemoteSchemaDef :: EnvRecord URI -> [HeaderConf] -> Bool -> Int -> Maybe RemoteSchemaCustomization -> ValidatedRemoteSchemaDef
[_vrsdUrl] :: ValidatedRemoteSchemaDef -> EnvRecord URI
[_vrsdHeaders] :: ValidatedRemoteSchemaDef -> [HeaderConf]
[_vrsdFwdClientHeaders] :: ValidatedRemoteSchemaDef -> Bool
[_vrsdTimeoutSeconds] :: ValidatedRemoteSchemaDef -> Int

-- | See <a>_rsdCustomization</a>.
[_vrsdCustomization] :: ValidatedRemoteSchemaDef -> Maybe RemoteSchemaCustomization
data RemoteSchemaCustomizer
RemoteSchemaCustomizer :: Maybe Name -> HashMap Name Name -> HashMap Name (HashMap Name Name) -> RemoteSchemaCustomizer
[_rscNamespaceFieldName] :: RemoteSchemaCustomizer -> Maybe Name

-- | type name -&gt; type name
[_rscCustomizeTypeName] :: RemoteSchemaCustomizer -> HashMap Name Name

-- | type name -&gt; field name -&gt; field name
[_rscCustomizeFieldName] :: RemoteSchemaCustomizer -> HashMap Name (HashMap Name Name)
identityCustomizer :: RemoteSchemaCustomizer
remoteSchemaCustomizeTypeName :: RemoteSchemaCustomizer -> MkTypename
remoteSchemaCustomizeFieldName :: RemoteSchemaCustomizer -> CustomizeRemoteFieldName
hasTypeOrFieldCustomizations :: RemoteSchemaCustomizer -> Bool

-- | <a>RemoteSchemaDef</a> after the RemoteSchemaCustomizer has been
--   generated by fetchRemoteSchema
data RemoteSchemaInfo
RemoteSchemaInfo :: ValidatedRemoteSchemaDef -> RemoteSchemaCustomizer -> RemoteSchemaInfo
[rsDef] :: RemoteSchemaInfo -> ValidatedRemoteSchemaDef
[rsCustomizer] :: RemoteSchemaInfo -> RemoteSchemaCustomizer

-- | Unvalidated remote schema config, from the user's API request
data RemoteSchemaDef
RemoteSchemaDef :: Maybe InputWebhook -> Maybe UrlFromEnv -> Maybe [HeaderConf] -> Bool -> Maybe Int -> Maybe RemoteSchemaCustomization -> RemoteSchemaDef
[_rsdUrl] :: RemoteSchemaDef -> Maybe InputWebhook
[_rsdUrlFromEnv] :: RemoteSchemaDef -> Maybe UrlFromEnv
[_rsdHeaders] :: RemoteSchemaDef -> Maybe [HeaderConf]
[_rsdForwardClientHeaders] :: RemoteSchemaDef -> Bool
[_rsdTimeoutSeconds] :: RemoteSchemaDef -> Maybe Int
[_rsdCustomization] :: RemoteSchemaDef -> Maybe RemoteSchemaCustomization

-- | The payload for <tt>add_remote_schema</tt>, and a component of
--   <tt>Metadata</tt>.
data AddRemoteSchemaQuery
AddRemoteSchemaQuery :: RemoteSchemaName -> RemoteSchemaDef -> Maybe Text -> AddRemoteSchemaQuery

-- | An internal identifier for this remote schema.
[_arsqName] :: AddRemoteSchemaQuery -> RemoteSchemaName
[_arsqDefinition] :: AddRemoteSchemaQuery -> RemoteSchemaDef

-- | An opaque description or comment. We might display this in the UI, for
--   instance.
[_arsqComment] :: AddRemoteSchemaQuery -> Maybe Text
newtype RemoteSchemaNameQuery
RemoteSchemaNameQuery :: RemoteSchemaName -> RemoteSchemaNameQuery
[_rsnqName] :: RemoteSchemaNameQuery -> RemoteSchemaName
getUrlFromEnv :: (MonadIO m, MonadError QErr m) => Environment -> Text -> m (EnvRecord URI)
validateRemoteSchemaCustomization :: MonadError QErr m => Maybe RemoteSchemaCustomization -> m ()
validateRemoteSchemaDef :: (MonadError QErr m, MonadIO m) => Environment -> RemoteSchemaDef -> m ValidatedRemoteSchemaDef
newtype RemoteSchemaPermissionDefinition
RemoteSchemaPermissionDefinition :: SchemaDocument -> RemoteSchemaPermissionDefinition
[_rspdSchema] :: RemoteSchemaPermissionDefinition -> SchemaDocument
data AddRemoteSchemaPermission
AddRemoteSchemaPermission :: RemoteSchemaName -> RoleName -> RemoteSchemaPermissionDefinition -> Maybe Text -> AddRemoteSchemaPermission
[_arspRemoteSchema] :: AddRemoteSchemaPermission -> RemoteSchemaName
[_arspRole] :: AddRemoteSchemaPermission -> RoleName
[_arspDefinition] :: AddRemoteSchemaPermission -> RemoteSchemaPermissionDefinition
[_arspComment] :: AddRemoteSchemaPermission -> Maybe Text
data DropRemoteSchemaPermissions
DropRemoteSchemaPermissions :: RemoteSchemaName -> RoleName -> DropRemoteSchemaPermissions
[_drspRemoteSchema] :: DropRemoteSchemaPermissions -> RemoteSchemaName
[_drspRole] :: DropRemoteSchemaPermissions -> RoleName

-- | See <tt>resolveRemoteVariable</tt> function. This data type is used
--   for validation of the session variable value
data SessionArgumentPresetInfo
SessionArgumentPresetScalar :: SessionArgumentPresetInfo
SessionArgumentPresetEnum :: HashSet EnumValue -> SessionArgumentPresetInfo

-- | Details required to resolve a "session variable preset" variable.
--   
--   See Notes [Remote Schema Argument Presets] and [Remote Schema
--   Permissions Architecture] for additional information.
data RemoteSchemaVariable
SessionPresetVariable :: SessionVariable -> Name -> SessionArgumentPresetInfo -> RemoteSchemaVariable
QueryVariable :: Variable -> RemoteSchemaVariable
RemoteJSONValue :: GType -> Value -> RemoteSchemaVariable

-- | Extends <a>InputValueDefinition</a> with an optional preset argument.
--   
--   See Note [Remote Schema Argument Presets] for additional information.
data RemoteSchemaInputValueDefinition
RemoteSchemaInputValueDefinition :: InputValueDefinition -> Maybe (Value RemoteSchemaVariable) -> RemoteSchemaInputValueDefinition
[_rsitdDefinition] :: RemoteSchemaInputValueDefinition -> InputValueDefinition
[_rsitdPresetArgument] :: RemoteSchemaInputValueDefinition -> Maybe (Value RemoteSchemaVariable)
newtype RemoteSchemaIntrospection
RemoteSchemaIntrospection :: HashMap Name (TypeDefinition [Name] RemoteSchemaInputValueDefinition) -> RemoteSchemaIntrospection

-- | Extracts the name of a given type from its definition. TODO: move this
--   to Language.GraphQL.Draft.Syntax.
getTypeName :: TypeDefinition possibleTypes inputType -> Name
lookupType :: RemoteSchemaIntrospection -> Name -> Maybe (TypeDefinition [Name] RemoteSchemaInputValueDefinition)
lookupObject :: RemoteSchemaIntrospection -> Name -> Maybe (ObjectTypeDefinition RemoteSchemaInputValueDefinition)
lookupInterface :: RemoteSchemaIntrospection -> Name -> Maybe (InterfaceTypeDefinition [Name] RemoteSchemaInputValueDefinition)
lookupScalar :: RemoteSchemaIntrospection -> Name -> Maybe ScalarTypeDefinition
lookupUnion :: RemoteSchemaIntrospection -> Name -> Maybe UnionTypeDefinition
lookupEnum :: RemoteSchemaIntrospection -> Name -> Maybe EnumTypeDefinition
lookupInputObject :: RemoteSchemaIntrospection -> Name -> Maybe (InputObjectTypeDefinition RemoteSchemaInputValueDefinition)
instance GHC.Classes.Ord Hasura.RQL.Types.RemoteSchema.SessionArgumentPresetInfo
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.SessionArgumentPresetInfo
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.SessionArgumentPresetInfo
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.SessionArgumentPresetInfo
instance GHC.Classes.Ord Hasura.RQL.Types.RemoteSchema.RemoteSchemaVariable
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.RemoteSchemaVariable
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteSchemaVariable
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteSchemaVariable
instance GHC.Classes.Ord Hasura.RQL.Types.RemoteSchema.RemoteSchemaInputValueDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.RemoteSchemaInputValueDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteSchemaInputValueDefinition
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteSchemaInputValueDefinition
instance GHC.Classes.Ord Hasura.RQL.Types.RemoteSchema.RemoteSchemaIntrospection
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.RemoteSchemaIntrospection
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.RemoteSchemaIntrospection
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.RemoteSchemaIntrospection
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteSchemaIntrospection
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteSchemaIntrospection
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.RemoteSchemaInputValueDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.RemoteSchemaInputValueDefinition
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.RemoteSchemaVariable
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.RemoteSchemaVariable
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.SessionArgumentPresetInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.SessionArgumentPresetInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.DropRemoteSchemaPermissions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.DropRemoteSchemaPermissions
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.DropRemoteSchemaPermissions
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.DropRemoteSchemaPermissions
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.DropRemoteSchemaPermissions
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.DropRemoteSchemaPermissions
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.DropRemoteSchemaPermissions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaPermission
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaPermission
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.RemoteSchemaPermissionDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteSchemaPermissionDefinition
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteSchemaPermissionDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaPermission
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaPermission
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaPermission
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaPermission
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaPermission
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.RemoteSchemaPermissionDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.RemoteSchemaPermissionDefinition
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.RemoteSchemaPermissionDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaPermissionDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaPermissionDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaNameQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaNameQuery
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteSchemaNameQuery
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteSchemaNameQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaQuery
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaQuery
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaQuery
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaQuery
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaQuery
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.AddRemoteSchemaQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaDef
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.RemoteSchemaDef
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteSchemaDef
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteSchemaDef
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.RemoteSchemaDef
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.RemoteSchemaDef
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaInfo
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.RemoteSchemaInfo
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteSchemaInfo
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteSchemaInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.RemoteSchemaInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.RemoteSchemaInfo
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.RemoteSchemaInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomizer
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomizer
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomizer
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomizer
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomizer
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomizer
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomizer
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomizer
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.ValidatedRemoteSchemaDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.ValidatedRemoteSchemaDef
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.ValidatedRemoteSchemaDef
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.ValidatedRemoteSchemaDef
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.ValidatedRemoteSchemaDef
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.ValidatedRemoteSchemaDef
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.ValidatedRemoteSchemaDef
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.ValidatedRemoteSchemaDef
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomization
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomization
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomization
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomization
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomization
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomization
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.RemoteSchemaCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.RemoteFieldCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.RemoteFieldCustomization
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.RemoteFieldCustomization
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteFieldCustomization
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteFieldCustomization
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.RemoteFieldCustomization
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.RemoteFieldCustomization
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.RemoteFieldCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.RemoteTypeCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.RemoteTypeCustomization
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance GHC.Classes.Ord Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteSchemaName
instance GHC.Generics.Generic Hasura.RQL.Types.RemoteSchema.RemoteTypeCustomization
instance GHC.Classes.Eq Hasura.RQL.Types.RemoteSchema.RemoteTypeCustomization
instance GHC.Show.Show Hasura.RQL.Types.RemoteSchema.RemoteTypeCustomization
instance Control.DeepSeq.NFData Hasura.RQL.Types.RemoteSchema.RemoteTypeCustomization
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.RemoteSchema.RemoteTypeCustomization
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.RemoteSchema.RemoteTypeCustomization

module Hasura.RQL.Types.Relationships.ToSource

-- | Metadata representation of a "remote" relationship targetting a
--   source.
--   
--   This representation has to be backend-agnostic, as it will be parsed
--   before the source cache is built, meaning we can't decide how
--   something backend specific should be resolved based solely on the
--   source name. But the table name is specific to the targeted backend...
--   There are two solutions to this problem: - we can either include an
--   additional field in the serialization that tells us the "kind" of the
--   backend; but that requies an additional field that is technically not
--   required, and that could potentially be inconsistent - or we can do
--   the same thing that we do for source to source relationships: we store
--   an unparsed JSON value as far as the metadata goes, and we parse it
--   when building the schema cache, when we know the kind of the source
--   from its name We chose the latter.
--   
--   Furthermore, the mapping is represented using a backend-agnostic
--   <a>FieldName</a>, whose interpretation is likewise delayed until the
--   schema cache is built.
--   
--   FIXME: move this to Hasura/Metadata
data ToSourceRelationshipDef
ToSourceRelationshipDef :: RelType -> HashMap FieldName FieldName -> SourceName -> Value -> ToSourceRelationshipDef
[_tsrdRelationshipType] :: ToSourceRelationshipDef -> RelType
[_tsrdFieldMapping] :: ToSourceRelationshipDef -> HashMap FieldName FieldName
[_tsrdSource] :: ToSourceRelationshipDef -> SourceName
[_tsrdTable] :: ToSourceRelationshipDef -> Value

-- | Schema cache information for a table field targeting a remote source.
data RemoteSourceFieldInfo tgt
RemoteSourceFieldInfo :: RelName -> RelType -> SourceName -> SourceConfig tgt -> SourceTypeCustomization -> TableName tgt -> HashMap FieldName (ScalarType tgt, Column tgt) -> RemoteSourceFieldInfo tgt
[_rsfiName] :: RemoteSourceFieldInfo tgt -> RelName
[_rsfiType] :: RemoteSourceFieldInfo tgt -> RelType
[_rsfiSource] :: RemoteSourceFieldInfo tgt -> SourceName
[_rsfiSourceConfig] :: RemoteSourceFieldInfo tgt -> SourceConfig tgt
[_rsfiSourceCustomization] :: RemoteSourceFieldInfo tgt -> SourceTypeCustomization

-- | this is parsed from <a>Value</a>
[_rsfiTable] :: RemoteSourceFieldInfo tgt -> TableName tgt

-- | LHS field name -&gt; RHS Column, RHS Column type
[_rsfiMapping] :: RemoteSourceFieldInfo tgt -> HashMap FieldName (ScalarType tgt, Column tgt)
tsrdTable :: Lens' ToSourceRelationshipDef Value
tsrdSource :: Lens' ToSourceRelationshipDef SourceName
tsrdRelationshipType :: Lens' ToSourceRelationshipDef RelType
tsrdFieldMapping :: Lens' ToSourceRelationshipDef (HashMap FieldName FieldName)
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance GHC.Show.Show Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.ToSource.RemoteSourceFieldInfo tgt)
instance Hasura.RQL.Types.Backend.Backend tgt => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.ToSource.RemoteSourceFieldInfo tgt)
instance Hasura.RQL.Types.Backend.Backend tgt => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Relationships.ToSource.RemoteSourceFieldInfo tgt)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef

module Hasura.RQL.Types.Relationships.ToSchema

-- | Metadata representation of a relationship to a remote schema.
--   
--   FIXME: move this to Hasura/Metadata
data ToSchemaRelationshipDef
ToSchemaRelationshipDef :: RemoteSchemaName -> HashSet FieldName -> RemoteFields -> ToSchemaRelationshipDef

-- | Identifier for this mapping.
[_trrdRemoteSchema] :: ToSchemaRelationshipDef -> RemoteSchemaName

-- | The lhs fields that must be forwarded to the remote schema.
[_trrdLhsFields] :: ToSchemaRelationshipDef -> HashSet FieldName
[_trrdRemoteField] :: ToSchemaRelationshipDef -> RemoteFields

-- | Targeted field in a remote schema relationship. TODO: explain about
--   subfields and why this is a container
newtype RemoteFields
RemoteFields :: NonEmpty FieldCall -> RemoteFields
[unRemoteFields] :: RemoteFields -> NonEmpty FieldCall

-- | Associates a field name with the arguments it will be passed in the
--   query.
--   
--   
--   <a>https://graphql.github.io/graphql-spec/June2018/#sec-Language.Arguments</a>
data FieldCall
FieldCall :: Name -> RemoteArguments -> FieldCall
[fcName] :: FieldCall -> Name
[fcArguments] :: FieldCall -> RemoteArguments

-- | Arguments to a remote GraphQL fields, represented as a mapping from
--   name to GraphQL Value. Said values can be variable names, in which
--   case they'll be referring to values we're closed over. TODO: expand on
--   this
newtype RemoteArguments
RemoteArguments :: HashMap Name (Value Name) -> RemoteArguments
[getRemoteArguments] :: RemoteArguments -> HashMap Name (Value Name)
newtype LHSIdentifier
LHSIdentifier :: Text -> LHSIdentifier
[getLHSIdentifier] :: LHSIdentifier -> Text
tableNameToLHSIdentifier :: Backend b => TableName b -> LHSIdentifier
remoteSchemaToLHSIdentifier :: RemoteSchemaName -> LHSIdentifier

-- | Generates a valid graphql name from an arbitrary LHS identifier. This
--   is done by replacing all unrecognized characters by '_'. This function
--   still returns a <tt>Maybe</tt> value, in cases we can't adjust the raw
--   text (such as the case of empty identifiers).
lhsIdentifierToGraphQLName :: LHSIdentifier -> Maybe Name

-- | Schema cache information for a table field targeting a remote schema.
data RemoteSchemaFieldInfo
RemoteSchemaFieldInfo :: RelName -> HashMap Name RemoteSchemaInputValueDefinition -> RemoteFields -> RemoteSchemaInfo -> [TypeDefinition [Name] RemoteSchemaInputValueDefinition] -> RemoteSchemaName -> LHSIdentifier -> RemoteSchemaFieldInfo

-- | Field name to which we'll map the remote in hasura; this becomes part
--   of the hasura schema.
[_rrfiName] :: RemoteSchemaFieldInfo -> RelName

-- | Input arguments to the remote field info; The <tt>_rfiParamMap</tt>
--   will only include the arguments to the remote field that is being
--   joined. The names of the arguments here are modified, it will be in
--   the format of <a>Field Name</a>_remote_rel_<a>table
--   schema</a>_<a>table name</a><a>relationship name</a>
[_rrfiParamMap] :: RemoteSchemaFieldInfo -> HashMap Name RemoteSchemaInputValueDefinition
[_rrfiRemoteFields] :: RemoteSchemaFieldInfo -> RemoteFields
[_rrfiRemoteSchema] :: RemoteSchemaFieldInfo -> RemoteSchemaInfo

-- | The new input value definitions created for this remote field
[_rrfiInputValueDefinitions] :: RemoteSchemaFieldInfo -> [TypeDefinition [Name] RemoteSchemaInputValueDefinition]

-- | Name of the remote schema, that's used for joining
[_rrfiRemoteSchemaName] :: RemoteSchemaFieldInfo -> RemoteSchemaName

-- | TODO: this one should be gone when <tt>validateRemoteRelationship</tt>
--   function is cleaned up
[_rrfiLHSIdentifier] :: RemoteSchemaFieldInfo -> LHSIdentifier
graphQLValueToJSON :: Value Void -> Value
trrdRemoteSchema :: Lens' ToSchemaRelationshipDef RemoteSchemaName
trrdRemoteField :: Lens' ToSchemaRelationshipDef RemoteFields
trrdLhsFields :: Lens' ToSchemaRelationshipDef (HashSet FieldName)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.ToSchema.ToSchemaRelationshipDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.ToSchema.ToSchemaRelationshipDef
instance Control.DeepSeq.NFData Hasura.RQL.Types.Relationships.ToSchema.RemoteArguments
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.ToSchema.RemoteArguments
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.ToSchema.RemoteArguments
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.ToSchema.RemoteArguments
instance GHC.Show.Show Hasura.RQL.Types.Relationships.ToSchema.RemoteArguments
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.ToSchema.FieldCall
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.ToSchema.FieldCall
instance GHC.Show.Show Hasura.RQL.Types.Relationships.ToSchema.FieldCall
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.ToSchema.RemoteFields
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.ToSchema.RemoteFields
instance GHC.Show.Show Hasura.RQL.Types.Relationships.ToSchema.RemoteFields
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.ToSchema.ToSchemaRelationshipDef
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.ToSchema.ToSchemaRelationshipDef
instance GHC.Show.Show Hasura.RQL.Types.Relationships.ToSchema.ToSchemaRelationshipDef
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.ToSchema.LHSIdentifier
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.ToSchema.LHSIdentifier
instance GHC.Show.Show Hasura.RQL.Types.Relationships.ToSchema.LHSIdentifier
instance GHC.Show.Show Hasura.RQL.Types.Relationships.ToSchema.RemoteSchemaFieldInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.ToSchema.RemoteSchemaFieldInfo
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.ToSchema.RemoteSchemaFieldInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.ToSchema.RemoteSchemaFieldInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.ToSchema.RemoteSchemaFieldInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.ToSchema.LHSIdentifier
instance Control.DeepSeq.NFData Hasura.RQL.Types.Relationships.ToSchema.ToSchemaRelationshipDef
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.ToSchema.ToSchemaRelationshipDef
instance Control.DeepSeq.NFData Hasura.RQL.Types.Relationships.ToSchema.RemoteFields
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.ToSchema.RemoteFields
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.ToSchema.RemoteFields
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.ToSchema.RemoteFields
instance Control.DeepSeq.NFData Hasura.RQL.Types.Relationships.ToSchema.FieldCall
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.ToSchema.FieldCall
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Relationships.ToSchema.FieldCall
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Relationships.ToSchema.RemoteArguments
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.ToSchema.RemoteArguments
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.ToSchema.RemoteArguments


-- | Representation for queries going to remote schemas. Due to the
--   existence of remote relationships from remote schemas, we can't simply
--   reuse the GraphQL document AST we define in graphql-parser-hs, and
--   instead redefine a custom structure to represent such queries.
module Hasura.RQL.IR.RemoteSchema

-- | Custom representation of a selection set.
--   
--   Similarly to other parts of the IR, the <tt>r</tt> argument is used
--   for remote relationships.
data SelectionSet r var
SelectionSetObject :: ObjectSelectionSet r var -> SelectionSet r var
SelectionSetUnion :: DeduplicatedSelectionSet r var -> SelectionSet r var
SelectionSetInterface :: DeduplicatedSelectionSet r var -> SelectionSet r var
SelectionSetNone :: SelectionSet r var

-- | Representation of the normalized selection set of an interface/union
--   type.
--   
--   This representation is used to attempt to minimize the size of the
--   GraphQL query that eventually gets sent to the GraphQL server by
--   defining as many fields as possible on the abstract type.
data DeduplicatedSelectionSet r var
DeduplicatedSelectionSet :: HashSet Name -> HashMap Name (ObjectSelectionSet r var) -> DeduplicatedSelectionSet r var

-- | Fields that aren't explicitly defined for member types
[_dssCommonFields] :: DeduplicatedSelectionSet r var -> HashSet Name

-- | SelectionSets of individual member types
[_dssMemberSelectionSets] :: DeduplicatedSelectionSet r var -> HashMap Name (ObjectSelectionSet r var)
type ObjectSelectionSet r var = InsOrdHashMap Name (Field r var)

-- | Constructs an <tt>InterfaceSelectionSet</tt> from a set of interface
--   fields and an association list of the fields. This function ensures
--   that <tt>__typename</tt> is present in the set of interface fields.
mkInterfaceSelectionSet :: HashSet Name -> [(Name, ObjectSelectionSet r var)] -> DeduplicatedSelectionSet r var

-- | Constructs an <tt>UnionSelectionSet</tt> from a list of the fields,
--   using a singleton set of <tt>__typename</tt> for the set of common
--   fields.
mkUnionSelectionSet :: [(Name, ObjectSelectionSet r var)] -> DeduplicatedSelectionSet r var

-- | Representation of one individual field.
--   
--   This particular type is the reason why we need a different
--   representation from the one in 'graphql-parser-hs': we differentiate
--   between selection fields that target the actual remote schema, and
--   fields that, instead, are remote from it and need to be treated
--   differently.
data Field r var
FieldGraphQL :: GraphQLField r var -> Field r var
FieldRemote :: SchemaRemoteRelationshipSelect r -> Field r var

-- | Normalized representation of a GraphQL field.
--   
--   This type is almost identical to <a>Field</a>, except for the fact
--   that the selection set is our annotated <a>SelectionSet</a>, instead
--   of the original <a>SelectionSet</a>. We use this type to represent the
--   fields of a selection that do target the remote schema.
data GraphQLField r var
GraphQLField :: Name -> Name -> HashMap Name (Value var) -> [Directive var] -> SelectionSet r var -> GraphQLField r var
[_fAlias] :: GraphQLField r var -> Name
[_fName] :: GraphQLField r var -> Name
[_fArguments] :: GraphQLField r var -> HashMap Name (Value var)
[_fDirectives] :: GraphQLField r var -> [Directive var]
[_fSelectionSet] :: GraphQLField r var -> SelectionSet r var
mkGraphQLField :: Maybe Name -> Name -> HashMap Name (Value var) -> [Directive var] -> SelectionSet r var -> GraphQLField r var

-- | Root entry point for a remote schema.
data RemoteSchemaRootField r var
RemoteSchemaRootField :: RemoteSchemaInfo -> ResultCustomizer -> GraphQLField r var -> RemoteSchemaRootField r var
[_rfRemoteSchemaInfo] :: RemoteSchemaRootField r var -> RemoteSchemaInfo
[_rfResultCustomizer] :: RemoteSchemaRootField r var -> ResultCustomizer
[_rfField] :: RemoteSchemaRootField r var -> GraphQLField r var

-- | A remote relationship's selection and fields required for its join
--   condition.
data SchemaRemoteRelationshipSelect r
SchemaRemoteRelationshipSelect :: HashMap FieldName Name -> r -> SchemaRemoteRelationshipSelect r

-- | The fields on the table that are required for the join condition of
--   the remote relationship
[_srrsLHSJoinFields] :: SchemaRemoteRelationshipSelect r -> HashMap FieldName Name

-- | The field that captures the relationship r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
[_srrsRelationship] :: SchemaRemoteRelationshipSelect r -> r
data RemoteFieldArgument
RemoteFieldArgument :: Name -> InputValue RemoteSchemaVariable -> RemoteFieldArgument
[_rfaArgument] :: RemoteFieldArgument -> Name
[_rfaValue] :: RemoteFieldArgument -> InputValue RemoteSchemaVariable
data RemoteSchemaSelect r
RemoteSchemaSelect :: [RemoteFieldArgument] -> ResultCustomizer -> SelectionSet r RemoteSchemaVariable -> NonEmpty FieldCall -> RemoteSchemaInfo -> RemoteSchemaSelect r
[_rselArgs] :: RemoteSchemaSelect r -> [RemoteFieldArgument]
[_rselResultCustomizer] :: RemoteSchemaSelect r -> ResultCustomizer
[_rselSelection] :: RemoteSchemaSelect r -> SelectionSet r RemoteSchemaVariable
[_rselFieldCall] :: RemoteSchemaSelect r -> NonEmpty FieldCall
[_rselRemoteSchema] :: RemoteSchemaSelect r -> RemoteSchemaInfo

-- | Converts a normalized selection set back into a selection set as
--   defined in GraphQL spec, in order to send it to a remote server.
--   
--   This function expects a <a>SelectionSet</a> for which <tt>r</tt> is
--   <a>Void</a>, which guarantees that there is no longer any remote join
--   field in the selection set.
convertSelectionSet :: forall var. Eq var => SelectionSet Void var -> SelectionSet NoFragments var
convertGraphQLField :: Eq var => GraphQLField Void var -> Field NoFragments var

-- | Builds the selection set for an abstract type.
--   
--   Let's consider this query on starwars API: The type <tt>Node</tt> an
--   interface is implemented by <tt>Film</tt>, <tt>Species</tt>,
--   <tt>Planet</tt>, <tt>Person</tt>, <tt>Starship</tt>, <tt>Vehicle</tt>
--   
--   query f { node(id: "ZmlsbXM6MQ==") { __typename id ... on Film { title
--   } ... on Species { name } } }
--   
--   When we parse this, it gets normalized into this query:
--   
--   query f { node(id: "ZmlsbXM6MQ==") { ... on Film { <b>typename:
--   </b>typename id title } ... on Species { <b>typename: </b>typename id
--   name } ... on Planet { <b>typename: </b>typename id } ... on Person {
--   <b>typename: </b>typename id } ... on Starship { <b>typename:
--   </b>typename id } ... on Vehicle { <b>typename: </b>typename id } } }
--   
--   <tt>__typename</tt> and <a>id</a> get pushed to each of the member
--   types. From the above normalized selection set, we want to costruct a
--   query as close to the original as possible. We do this as follows:
--   
--   <ol>
--   <li>find the longest common set of fields that each selection set
--   starts with (in the above case, they are <tt>__typename</tt> and
--   <a>id</a>)</li>
--   <li>from the above list of fields, find the first field that cannot be
--   defined on the abstract type. The fields that can be defined on the
--   abstract type are all the fields that occur before the first non
--   abstract type field (in the above case, both` __typename` and
--   <a>id</a> can be defined on the <tt>Node</tt> type)</li>
--   <li>Strip the base selection set fields from all the member selection
--   sets and filter out the member type selection sets that are subsumed
--   by the base selection set</li>
--   </ol>
--   
--   The above query now translates to this:
--   
--   query f { node(id: "ZmlsbXM6MQ==") { <b>typename: </b>typename id ...
--   on Film { title } ... on Species { name } } }
--   
--   Note that it is not always possible to get the same shape as the
--   original query and there is more than one approach to this. For
--   example, we could have picked the selection set (that can be defined
--   on the abstract type) that is common across all the member selection
--   sets and used that as the base selection.
reduceAbstractTypeSelectionSet :: Eq var => DeduplicatedSelectionSet Void var -> (ObjectSelectionSet Void var, HashMap Name (ObjectSelectionSet Void var))
_FieldRemote :: forall r_akJjB var_akJjC. Prism' (Field r_akJjB var_akJjC) (SchemaRemoteRelationshipSelect r_akJjB)
_FieldGraphQL :: forall r_akJjB var_akKJN var_akJjC. Prism (Field r_akJjB var_akKJN) (Field r_akJjB var_akJjC) (GraphQLField r_akJjB var_akKJN) (GraphQLField r_akJjB var_akJjC)
fSelectionSet :: forall r_akJjz var_akJjA r_akKLO. Lens (GraphQLField r_akJjz var_akJjA) (GraphQLField r_akKLO var_akJjA) (SelectionSet r_akJjz var_akJjA) (SelectionSet r_akKLO var_akJjA)
fName :: forall r_akJjz var_akJjA. Lens' (GraphQLField r_akJjz var_akJjA) Name
fDirectives :: forall r_akJjz var_akJjA. Lens' (GraphQLField r_akJjz var_akJjA) [Directive var_akJjA]
fArguments :: forall r_akJjz var_akJjA. Lens' (GraphQLField r_akJjz var_akJjA) (HashMap Name (Value var_akJjA))
fAlias :: forall r_akJjz var_akJjA. Lens' (GraphQLField r_akJjz var_akJjA) Name
dssMemberSelectionSets :: forall r_akJjF var_akJjG r_akKP6 var_akKP7. Lens (DeduplicatedSelectionSet r_akJjF var_akJjG) (DeduplicatedSelectionSet r_akKP6 var_akKP7) (HashMap Name (ObjectSelectionSet r_akJjF var_akJjG)) (HashMap Name (ObjectSelectionSet r_akKP6 var_akKP7))
dssCommonFields :: forall r_akJjF var_akJjG. Lens' (DeduplicatedSelectionSet r_akJjF var_akJjG) (HashSet Name)
instance Data.Traversable.Traversable Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect
instance Data.Foldable.Foldable Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect
instance GHC.Base.Functor Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect
instance GHC.Show.Show r => GHC.Show.Show (Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect r)
instance GHC.Generics.Generic (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r var)
instance Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r)
instance Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r)
instance GHC.Base.Functor (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r)
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r var)
instance (GHC.Show.Show var, GHC.Show.Show r) => GHC.Show.Show (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r var)
instance Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.SelectionSet r)
instance Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.SelectionSet r)
instance GHC.Base.Functor (Hasura.RQL.IR.RemoteSchema.SelectionSet r)
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.SelectionSet r var)
instance (GHC.Show.Show var, GHC.Show.Show r) => GHC.Show.Show (Hasura.RQL.IR.RemoteSchema.SelectionSet r var)
instance Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.GraphQLField r)
instance Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.GraphQLField r)
instance GHC.Base.Functor (Hasura.RQL.IR.RemoteSchema.GraphQLField r)
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.GraphQLField r var)
instance (GHC.Show.Show var, GHC.Show.Show r) => GHC.Show.Show (Hasura.RQL.IR.RemoteSchema.GraphQLField r var)
instance Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.Field r)
instance Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.Field r)
instance GHC.Base.Functor (Hasura.RQL.IR.RemoteSchema.Field r)
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.Field r var)
instance (GHC.Show.Show var, GHC.Show.Show r) => GHC.Show.Show (Hasura.RQL.IR.RemoteSchema.Field r var)
instance Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.RemoteSchemaRootField r)
instance Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.RemoteSchemaRootField r)
instance GHC.Base.Functor (Hasura.RQL.IR.RemoteSchema.RemoteSchemaRootField r)
instance GHC.Show.Show Hasura.RQL.IR.RemoteSchema.RemoteFieldArgument
instance GHC.Classes.Eq Hasura.RQL.IR.RemoteSchema.RemoteFieldArgument

module Hasura.RQL.Types.Relationships.Remote

-- | Metadata representation of a generic remote relationship, regardless
--   of the source: all sources use this same agnostic definition. The
--   internal definition field is where we differentiate between different
--   targets.
data RemoteRelationship
RemoteRelationship :: RelName -> RemoteRelationshipDefinition -> RemoteRelationship
[_rrName] :: RemoteRelationship -> RelName
[_rrDefinition] :: RemoteRelationship -> RemoteRelationshipDefinition

-- | Represents the format of the metadata a remote relationship was read
--   from and must be written back as. We don't have a good way of doing
--   metadata versioning yet, and we therefore use this to keep track of
--   the format used.
data RRFormat

-- | The remote relationship was parsed from the old format, that was only
--   used only for db-to-rs schemas.
RRFOldDBToRemoteSchema :: RRFormat

-- | The remote relationship was parsed from the new unified format.
RRFUnifiedFormat :: RRFormat

-- | Metadata representation of the internal definition of a remote
--   relationship.
data RemoteRelationshipDefinition

-- | Remote relationship targetting a source.
RelationshipToSource :: ToSourceRelationshipDef -> RemoteRelationshipDefinition

-- | Remote relationship targetting a remote schema.
RelationshipToSchema :: RRFormat -> ToSchemaRelationshipDef -> RemoteRelationshipDefinition

-- | Whether to accept legacy fields when parsing
--   <a>RemoteRelationshipDefinition</a>
data RRParseMode

-- | Only allow legacy fields when parsing
--   <a>RemoteRelationshipDefinition</a>
RRPLegacy :: RRParseMode

-- | Allow legacy fields when parsing <a>RemoteRelationshipDefinition</a>
RRPLenient :: RRParseMode

-- | Reject legacy fields when parsing <a>RemoteRelationshipDefinition</a>
RRPStrict :: RRParseMode

-- | Parse <a>RemoteRelationshipDefinition</a> letting the caller decide
--   how lenient to be.
--   
--   This is necessary because <a>RemoteRelationshipDefinition</a> is
--   parsed in different contexts. In <a>RemoteRelationship</a>, the
--   <a>RemoteRelationshipDefinition</a> is always parsed out from a
--   top-level @"definition" field. Thus, a legacy payload looks like this:
--   
--   <pre>
--   {
--     "name": "thing",
--     "definition": {
--       "remote_schema": "stuff",
--       "hasura_fields": ...
--       "remote_field": ...
--     }
--   }
--   </pre>
--   
--   and a new payload looks like this:
--   
--   <pre>
--   {
--     "name": "thing",
--     "definition": {
--       "to_remote_schema": {
--         "schema": "stuff",
--         "lhs_fields": ...
--         "remote_field": ...
--       }
--     }
--   }
--   </pre>
--   
--   In contrast, <tt>CreateFromSourceRelationship</tt> does not have a
--   top- level <tt>"definition"</tt> in its legacy format. Instead, the
--   legacy fields themselves are top-level:
--   
--   <pre>
--   {
--     "remote_schema": "stuff",
--     "hasura_fields": ...
--     "remote_field": ...
--   }
--   </pre>
--   
--   Furthermore, the presence of a <tt>"definition"</tt> field is used to
--   detect that the new payload is being used:
--   
--   <pre>
--   {
--     "definition": {
--       "to_remote_schema": {
--         "schema": "stuff",
--         "lhs_fields": ...
--         "remote_field": ...
--       }
--     }
--   }
--   </pre>
--   
--   In this latter case, we should not allow <tt>"remote_schema"</tt> to
--   appear under <tt>"definition"</tt>.
parseRemoteRelationshipDefinition :: RRParseMode -> Value -> Parser RemoteRelationshipDefinition

-- | Resolved remote relationship, as stored in the schema cache.
data RemoteFieldInfo lhsJoinField
RemoteFieldInfo :: HashMap FieldName lhsJoinField -> RemoteFieldInfoRHS -> RemoteFieldInfo lhsJoinField
[_rfiLHS] :: RemoteFieldInfo lhsJoinField -> HashMap FieldName lhsJoinField
[_rfiRHS] :: RemoteFieldInfo lhsJoinField -> RemoteFieldInfoRHS

-- | Resolved remote relationship's RHS
data RemoteFieldInfoRHS
RFISchema :: RemoteSchemaFieldInfo -> RemoteFieldInfoRHS
RFISource :: AnyBackend RemoteSourceFieldInfo -> RemoteFieldInfoRHS

-- | Information about the field on the LHS of a join against a remote
--   schema.
data DBJoinField (b :: BackendType)
JoinColumn :: Column b -> ColumnType b -> DBJoinField (b :: BackendType)
JoinComputedField :: ScalarComputedField b -> DBJoinField (b :: BackendType)

-- | Information about a computed field appearing on the LHS of a remote
--   join. FIXME: why do we need all of this?
data ScalarComputedField (b :: BackendType)
ScalarComputedField :: XComputedField b -> ComputedFieldName -> FunctionName b -> ComputedFieldImplicitArguments b -> ScalarType b -> ScalarComputedField (b :: BackendType)
[_scfXField] :: ScalarComputedField (b :: BackendType) -> XComputedField b
[_scfName] :: ScalarComputedField (b :: BackendType) -> ComputedFieldName
[_scfFunction] :: ScalarComputedField (b :: BackendType) -> FunctionName b
[_scfComputedFieldImplicitArgs] :: ScalarComputedField (b :: BackendType) -> ComputedFieldImplicitArguments b
[_scfType] :: ScalarComputedField (b :: BackendType) -> ScalarType b
rrName :: Lens' RemoteRelationship RelName
rrDefinition :: Lens' RemoteRelationship RemoteRelationshipDefinition
_RelationshipToSchema :: Prism' RemoteRelationshipDefinition (RRFormat, ToSchemaRelationshipDef)
_RelationshipToSource :: Prism' RemoteRelationshipDefinition ToSourceRelationshipDef
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.Remote.RemoteRelationship
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RRFormat
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RRFormat
instance GHC.Show.Show Hasura.RQL.Types.Relationships.Remote.RRFormat
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance GHC.Show.Show Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RemoteRelationship
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RemoteRelationship
instance GHC.Show.Show Hasura.RQL.Types.Relationships.Remote.RemoteRelationship
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RRParseMode
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RRParseMode
instance GHC.Show.Show Hasura.RQL.Types.Relationships.Remote.RRParseMode
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfoRHS
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfoRHS
instance GHC.Classes.Eq lhsJoinField => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfo lhsJoinField)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfo lhsJoinField)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Hasura.Incremental.Internal.Dependency.Cacheable lhsJoinField => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfo lhsJoinField)
instance Data.Aeson.Types.ToJSON.ToJSON lhsJoinField => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfo lhsJoinField)
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfoRHS
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfoRHS
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.Remote.RemoteRelationship
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.Remote.RemoteRelationship
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance (TypeError ...) => Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Relationships.Remote.RRFormat

module Hasura.RQL.Types.Table
data CustomRootField
CustomRootField :: Maybe Name -> Comment -> CustomRootField
[_crfName] :: CustomRootField -> Maybe Name
[_crfComment] :: CustomRootField -> Comment
defaultCustomRootField :: CustomRootField
data TableCustomRootFields
TableCustomRootFields :: CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> TableCustomRootFields
[_tcrfSelect] :: TableCustomRootFields -> CustomRootField
[_tcrfSelectByPk] :: TableCustomRootFields -> CustomRootField
[_tcrfSelectAggregate] :: TableCustomRootFields -> CustomRootField
[_tcrfSelectStream] :: TableCustomRootFields -> CustomRootField
[_tcrfInsert] :: TableCustomRootFields -> CustomRootField
[_tcrfInsertOne] :: TableCustomRootFields -> CustomRootField
[_tcrfUpdate] :: TableCustomRootFields -> CustomRootField
[_tcrfUpdateByPk] :: TableCustomRootFields -> CustomRootField
[_tcrfUpdateMany] :: TableCustomRootFields -> CustomRootField
[_tcrfDelete] :: TableCustomRootFields -> CustomRootField
[_tcrfDeleteByPk] :: TableCustomRootFields -> CustomRootField
emptyCustomRootFields :: TableCustomRootFields
getAllCustomRootFields :: TableCustomRootFields -> [CustomRootField]
data FieldInfo (b :: BackendType)
FIColumn :: ColumnInfo b -> FieldInfo (b :: BackendType)
FIRelationship :: RelInfo b -> FieldInfo (b :: BackendType)
FIComputedField :: ComputedFieldInfo b -> FieldInfo (b :: BackendType)
FIRemoteRelationship :: RemoteFieldInfo (DBJoinField b) -> FieldInfo (b :: BackendType)
_FIRemoteRelationship :: forall b_al0N9. Prism' (FieldInfo b_al0N9) (RemoteFieldInfo (DBJoinField b_al0N9))
_FIComputedField :: forall b_al0N9. Prism' (FieldInfo b_al0N9) (ComputedFieldInfo b_al0N9)
_FIRelationship :: forall b_al0N9. Prism' (FieldInfo b_al0N9) (RelInfo b_al0N9)
_FIColumn :: forall b_al0N9. Prism' (FieldInfo b_al0N9) (ColumnInfo b_al0N9)
type FieldInfoMap = HashMap FieldName
fieldInfoName :: forall b. Backend b => FieldInfo b -> FieldName
fieldInfoGraphQLName :: FieldInfo b -> Maybe Name
getRemoteFieldInfoName :: RemoteFieldInfo lhsJoinField -> RelName

-- | Returns all the field names created for the given field. Columns,
--   object relationships, and computed fields only ever produce a single
--   field, but array relationships also contain an <tt>_aggregate</tt>
--   field.
fieldInfoGraphQLNames :: FieldInfo b -> [Name]
getCols :: FieldInfoMap (FieldInfo backend) -> [ColumnInfo backend]

-- | Sort columns based on their ordinal position
sortCols :: [ColumnInfo backend] -> [ColumnInfo backend]
getRels :: FieldInfoMap (FieldInfo backend) -> [RelInfo backend]
getComputedFieldInfos :: FieldInfoMap (FieldInfo backend) -> [ComputedFieldInfo backend]
data InsPermInfo (b :: BackendType)
InsPermInfo :: HashSet (Column b) -> AnnBoolExpPartialSQL b -> PreSetColsPartial b -> Bool -> HashSet Text -> InsPermInfo (b :: BackendType)
[ipiCols] :: InsPermInfo (b :: BackendType) -> HashSet (Column b)
[ipiCheck] :: InsPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[ipiSet] :: InsPermInfo (b :: BackendType) -> PreSetColsPartial b
[ipiBackendOnly] :: InsPermInfo (b :: BackendType) -> Bool
[ipiRequiredHeaders] :: InsPermInfo (b :: BackendType) -> HashSet Text

-- | This type is only used as an intermediate type to combine more than
--   one select permissions for inherited roles.
data CombinedSelPermInfo (b :: BackendType)
CombinedSelPermInfo :: [HashMap (Column b) (Maybe (AnnColumnCaseBoolExpPartialSQL b))] -> [HashMap ComputedFieldName (Maybe (AnnColumnCaseBoolExpPartialSQL b))] -> [AnnBoolExpPartialSQL b] -> Maybe (Max Int) -> Any -> HashSet Text -> AllowedRootFields QueryRootFieldType -> AllowedRootFields SubscriptionRootFieldType -> CombinedSelPermInfo (b :: BackendType)
[cspiCols] :: CombinedSelPermInfo (b :: BackendType) -> [HashMap (Column b) (Maybe (AnnColumnCaseBoolExpPartialSQL b))]
[cspiComputedFields] :: CombinedSelPermInfo (b :: BackendType) -> [HashMap ComputedFieldName (Maybe (AnnColumnCaseBoolExpPartialSQL b))]
[cspiFilter] :: CombinedSelPermInfo (b :: BackendType) -> [AnnBoolExpPartialSQL b]
[cspiLimit] :: CombinedSelPermInfo (b :: BackendType) -> Maybe (Max Int)
[cspiAllowAgg] :: CombinedSelPermInfo (b :: BackendType) -> Any
[cspiRequiredHeaders] :: CombinedSelPermInfo (b :: BackendType) -> HashSet Text
[cspiAllowedQueryRootFieldTypes] :: CombinedSelPermInfo (b :: BackendType) -> AllowedRootFields QueryRootFieldType
[cspiAllowedSubscriptionRootFieldTypes] :: CombinedSelPermInfo (b :: BackendType) -> AllowedRootFields SubscriptionRootFieldType
combinedSelPermInfoToSelPermInfo :: Backend b => Int -> CombinedSelPermInfo b -> SelPermInfo b
data SelPermInfo (b :: BackendType)
SelPermInfo :: HashMap (Column b) (Maybe (AnnColumnCaseBoolExpPartialSQL b)) -> HashMap ComputedFieldName (Maybe (AnnColumnCaseBoolExpPartialSQL b)) -> AnnBoolExpPartialSQL b -> Maybe Int -> Bool -> HashSet Text -> AllowedRootFields QueryRootFieldType -> AllowedRootFields SubscriptionRootFieldType -> SelPermInfo (b :: BackendType)

-- | HashMap of accessible columns to the role, the <a>Column</a> may be
--   mapped to an <a>AnnColumnCaseBoolExpPartialSQL</a>, which happens only
--   in the case of an inherited role, for a non-inherited role, it will be
--   <a>Nothing</a>. The above bool exp will determine if the column should
--   be nullified in a row, when there aren't requisite permissions.
[spiCols] :: SelPermInfo (b :: BackendType) -> HashMap (Column b) (Maybe (AnnColumnCaseBoolExpPartialSQL b))

-- | HashMap of accessible computed fields to the role, mapped to
--   <a>AnnColumnCaseBoolExpPartialSQL</a>, simililar to <a>spiCols</a>.
--   These computed fields do not return rows of existing table.
[spiComputedFields] :: SelPermInfo (b :: BackendType) -> HashMap ComputedFieldName (Maybe (AnnColumnCaseBoolExpPartialSQL b))
[spiFilter] :: SelPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[spiLimit] :: SelPermInfo (b :: BackendType) -> Maybe Int
[spiAllowAgg] :: SelPermInfo (b :: BackendType) -> Bool
[spiRequiredHeaders] :: SelPermInfo (b :: BackendType) -> HashSet Text

-- | allowed root field types to be exposed in the query_root
[spiAllowedQueryRootFields] :: SelPermInfo (b :: BackendType) -> AllowedRootFields QueryRootFieldType

-- | allowed root field types to be exposed in the subscription_root
[spiAllowedSubscriptionRootFields] :: SelPermInfo (b :: BackendType) -> AllowedRootFields SubscriptionRootFieldType
data UpdPermInfo (b :: BackendType)
UpdPermInfo :: HashSet (Column b) -> TableName b -> AnnBoolExpPartialSQL b -> Maybe (AnnBoolExpPartialSQL b) -> PreSetColsPartial b -> Bool -> HashSet Text -> UpdPermInfo (b :: BackendType)
[upiCols] :: UpdPermInfo (b :: BackendType) -> HashSet (Column b)
[upiTable] :: UpdPermInfo (b :: BackendType) -> TableName b
[upiFilter] :: UpdPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[upiCheck] :: UpdPermInfo (b :: BackendType) -> Maybe (AnnBoolExpPartialSQL b)
[upiSet] :: UpdPermInfo (b :: BackendType) -> PreSetColsPartial b
[upiBackendOnly] :: UpdPermInfo (b :: BackendType) -> Bool
[upiRequiredHeaders] :: UpdPermInfo (b :: BackendType) -> HashSet Text
data DelPermInfo (b :: BackendType)
DelPermInfo :: TableName b -> AnnBoolExpPartialSQL b -> !Bool -> HashSet Text -> DelPermInfo (b :: BackendType)
[dpiTable] :: DelPermInfo (b :: BackendType) -> TableName b
[dpiFilter] :: DelPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[dpiBackendOnly] :: DelPermInfo (b :: BackendType) -> !Bool
[dpiRequiredHeaders] :: DelPermInfo (b :: BackendType) -> HashSet Text
data RolePermInfo (b :: BackendType)
RolePermInfo :: Maybe (InsPermInfo b) -> Maybe (SelPermInfo b) -> Maybe (UpdPermInfo b) -> Maybe (DelPermInfo b) -> RolePermInfo (b :: BackendType)
[_permIns] :: RolePermInfo (b :: BackendType) -> Maybe (InsPermInfo b)
[_permSel] :: RolePermInfo (b :: BackendType) -> Maybe (SelPermInfo b)
[_permUpd] :: RolePermInfo (b :: BackendType) -> Maybe (UpdPermInfo b)
[_permDel] :: RolePermInfo (b :: BackendType) -> Maybe (DelPermInfo b)
permUpd :: forall b_al1Cs. Lens' (RolePermInfo b_al1Cs) (Maybe (UpdPermInfo b_al1Cs))
permSel :: forall b_al1Cs. Lens' (RolePermInfo b_al1Cs) (Maybe (SelPermInfo b_al1Cs))
permIns :: forall b_al1Cs. Lens' (RolePermInfo b_al1Cs) (Maybe (InsPermInfo b_al1Cs))
permDel :: forall b_al1Cs. Lens' (RolePermInfo b_al1Cs) (Maybe (DelPermInfo b_al1Cs))
type RolePermInfoMap b = HashMap RoleName (RolePermInfo b)
data ViewInfo
ViewInfo :: Bool -> Bool -> Bool -> ViewInfo
[viIsUpdatable] :: ViewInfo -> Bool
[viIsDeletable] :: ViewInfo -> Bool
[viIsInsertable] :: ViewInfo -> Bool
isMutable :: (ViewInfo -> Bool) -> Maybe ViewInfo -> Bool
data ColumnConfig
ColumnConfig :: Maybe Name -> Comment -> ColumnConfig
[_ccfgCustomName] :: ColumnConfig -> Maybe Name
[_ccfgComment] :: ColumnConfig -> Comment
data TableConfig b
TableConfig :: TableCustomRootFields -> HashMap (Column b) ColumnConfig -> Maybe Name -> Comment -> TableConfig b
[_tcCustomRootFields] :: TableConfig b -> TableCustomRootFields
[_tcColumnConfig] :: TableConfig b -> HashMap (Column b) ColumnConfig
[_tcCustomName] :: TableConfig b -> Maybe Name
[_tcComment] :: TableConfig b -> Comment
tcCustomRootFields :: forall b_al5nE. Lens' (TableConfig b_al5nE) TableCustomRootFields
tcCustomName :: forall b_al5nE. Lens' (TableConfig b_al5nE) (Maybe Name)
tcComment :: forall b_al5nE. Lens' (TableConfig b_al5nE) Comment
tcColumnConfig :: forall b_al5nE b_al64H. Lens (TableConfig b_al5nE) (TableConfig b_al64H) (HashMap (Column b_al5nE) ColumnConfig) (HashMap (Column b_al64H) ColumnConfig)
emptyTableConfig :: TableConfig b
data Constraint (b :: BackendType)
Constraint :: ConstraintName b -> OID -> Constraint (b :: BackendType)
[_cName] :: Constraint (b :: BackendType) -> ConstraintName b
[_cOid] :: Constraint (b :: BackendType) -> OID
data PrimaryKey (b :: BackendType) a
PrimaryKey :: Constraint b -> NESeq a -> PrimaryKey (b :: BackendType) a
[_pkConstraint] :: PrimaryKey (b :: BackendType) a -> Constraint b
[_pkColumns] :: PrimaryKey (b :: BackendType) a -> NESeq a
pkConstraint :: forall b_al65j a_al65k b_al8gi. Lens (PrimaryKey b_al65j a_al65k) (PrimaryKey b_al8gi a_al65k) (Constraint b_al65j) (Constraint b_al8gi)
pkColumns :: forall b_al65j a_al65k a_al8gh. Lens (PrimaryKey b_al65j a_al65k) (PrimaryKey b_al65j a_al8gh) (NESeq a_al65k) (NESeq a_al8gh)

-- | Data type modelling uniqueness constraints. Occasionally this will
--   include primary keys, although those are tracked separately in
--   <a>TableCoreInfoG</a>.
--   
--   For more information about unique constraints, visit the postgresql
--   documentation:
--   <a>https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-UNIQUE-CONSTRAINTS</a>.
data UniqueConstraint (b :: BackendType)
UniqueConstraint :: Constraint b -> HashSet (Column b) -> UniqueConstraint (b :: BackendType)

-- | The postgresql name and object id of a unique constraint.
[_ucConstraint] :: UniqueConstraint (b :: BackendType) -> Constraint b

-- | The set of columns which should be unique for this particular
--   constraint. Used for permissions calculation.
[_ucColumns] :: UniqueConstraint (b :: BackendType) -> HashSet (Column b)
data ForeignKey (b :: BackendType)
ForeignKey :: Constraint b -> TableName b -> NEHashMap (Column b) (Column b) -> ForeignKey (b :: BackendType)
[_fkConstraint] :: ForeignKey (b :: BackendType) -> Constraint b
[_fkForeignTable] :: ForeignKey (b :: BackendType) -> TableName b
[_fkColumnMapping] :: ForeignKey (b :: BackendType) -> NEHashMap (Column b) (Column b)

-- | The <tt>field</tt> and <tt>primaryKeyColumn</tt> type parameters vary
--   as the schema cache is built and more information is accumulated. See
--   also <a>TableCoreInfo</a>.
data TableCoreInfoG (b :: BackendType) field primaryKeyColumn
TableCoreInfo :: TableName b -> Maybe PGDescription -> FieldInfoMap field -> Maybe (PrimaryKey b primaryKeyColumn) -> HashSet (UniqueConstraint b) -> HashSet (ForeignKey b) -> Maybe ViewInfo -> Maybe EnumValues -> TableConfig b -> ExtraTableMetadata b -> Maybe ApolloFederationConfig -> TableCoreInfoG (b :: BackendType) field primaryKeyColumn
[_tciName] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> TableName b
[_tciDescription] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe PGDescription
[_tciFieldInfoMap] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> FieldInfoMap field
[_tciPrimaryKey] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe (PrimaryKey b primaryKeyColumn)

-- | Does <i>not</i> include the primary key; use
--   <a>tciUniqueOrPrimaryKeyConstraints</a> if you need both.
[_tciUniqueConstraints] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> HashSet (UniqueConstraint b)
[_tciForeignKeys] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> HashSet (ForeignKey b)
[_tciViewInfo] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe ViewInfo
[_tciEnumValues] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe EnumValues
[_tciCustomConfig] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> TableConfig b
[_tciExtraTableMetadata] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> ExtraTableMetadata b
[_tciApolloFederationConfig] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe ApolloFederationConfig
tciViewInfo :: forall b_al8gP field_al8gQ primaryKeyColumn_al8gR. Lens' (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_al8gR) (Maybe ViewInfo)
tciUniqueConstraints :: forall b_al8gP field_al8gQ primaryKeyColumn_al8gR. Lens' (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_al8gR) (HashSet (UniqueConstraint b_al8gP))
tciPrimaryKey :: forall b_al8gP field_al8gQ primaryKeyColumn_al8gR primaryKeyColumn_alaBf. Lens (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_al8gR) (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_alaBf) (Maybe (PrimaryKey b_al8gP primaryKeyColumn_al8gR)) (Maybe (PrimaryKey b_al8gP primaryKeyColumn_alaBf))
tciName :: forall b_al8gP field_al8gQ primaryKeyColumn_al8gR. Lens' (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_al8gR) (TableName b_al8gP)
tciForeignKeys :: forall b_al8gP field_al8gQ primaryKeyColumn_al8gR. Lens' (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_al8gR) (HashSet (ForeignKey b_al8gP))
tciFieldInfoMap :: forall b_al8gP field_al8gQ primaryKeyColumn_al8gR field_alaBe. Lens (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_al8gR) (TableCoreInfoG b_al8gP field_alaBe primaryKeyColumn_al8gR) (FieldInfoMap field_al8gQ) (FieldInfoMap field_alaBe)
tciExtraTableMetadata :: forall b_al8gP field_al8gQ primaryKeyColumn_al8gR. Lens' (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_al8gR) (ExtraTableMetadata b_al8gP)
tciEnumValues :: forall b_al8gP field_al8gQ primaryKeyColumn_al8gR. Lens' (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_al8gR) (Maybe EnumValues)
tciDescription :: forall b_al8gP field_al8gQ primaryKeyColumn_al8gR. Lens' (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_al8gR) (Maybe PGDescription)
tciCustomConfig :: forall b_al8gP field_al8gQ primaryKeyColumn_al8gR. Lens' (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_al8gR) (TableConfig b_al8gP)
tciApolloFederationConfig :: forall b_al8gP field_al8gQ primaryKeyColumn_al8gR. Lens' (TableCoreInfoG b_al8gP field_al8gQ primaryKeyColumn_al8gR) (Maybe ApolloFederationConfig)

-- | Fully-processed table info that includes non-column fields.
type TableCoreInfo b = TableCoreInfoG b (FieldInfo b) (ColumnInfo b)
tciUniqueOrPrimaryKeyConstraints :: forall b f. (Eq (Column b), Hashable (Column b)) => TableCoreInfoG b f (ColumnInfo b) -> Maybe (NonEmpty (UniqueConstraint b))
data TableInfo (b :: BackendType)
TableInfo :: TableCoreInfo b -> RolePermInfoMap b -> EventTriggerInfoMap b -> RolePermInfo b -> TableInfo (b :: BackendType)
[_tiCoreInfo] :: TableInfo (b :: BackendType) -> TableCoreInfo b
[_tiRolePermInfoMap] :: TableInfo (b :: BackendType) -> RolePermInfoMap b
[_tiEventTriggerInfoMap] :: TableInfo (b :: BackendType) -> EventTriggerInfoMap b
[_tiAdminRolePermInfo] :: TableInfo (b :: BackendType) -> RolePermInfo b
tiRolePermInfoMap :: forall b_alaDS. Lens' (TableInfo b_alaDS) (RolePermInfoMap b_alaDS)
tiEventTriggerInfoMap :: forall b_alaDS. Lens' (TableInfo b_alaDS) (EventTriggerInfoMap b_alaDS)
tiCoreInfo :: forall b_alaDS. Lens' (TableInfo b_alaDS) (TableCoreInfo b_alaDS)
tiAdminRolePermInfo :: forall b_alaDS. Lens' (TableInfo b_alaDS) (RolePermInfo b_alaDS)
tiName :: Lens' (TableInfo b) (TableName b)
tableInfoName :: TableInfo b -> TableName b
tableArrayRelationships :: TableInfo b -> [RelInfo b]
getRolePermInfo :: RoleName -> TableInfo b -> RolePermInfo b
type TableCoreCache b = HashMap (TableName b) (TableCoreInfo b)
type TableCache b = HashMap (TableName b) (TableInfo b)
type TableEventTriggers b = HashMap (TableName b) [TriggerName]

-- | Metadata of a Postgres foreign key constraint which is being extracted
--   from database via 'src-rsr/pg_table_metadata.sql'
newtype ForeignKeyMetadata (b :: BackendType)
ForeignKeyMetadata :: ForeignKey b -> ForeignKeyMetadata (b :: BackendType)
[unForeignKeyMetadata] :: ForeignKeyMetadata (b :: BackendType) -> ForeignKey b

-- | Metadata of any Backend table which is being extracted from source
--   database
data DBTableMetadata (b :: BackendType)
DBTableMetadata :: OID -> [RawColumnInfo b] -> Maybe (PrimaryKey b (Column b)) -> HashSet (UniqueConstraint b) -> HashSet (ForeignKeyMetadata b) -> Maybe ViewInfo -> Maybe PGDescription -> ExtraTableMetadata b -> DBTableMetadata (b :: BackendType)
[_ptmiOid] :: DBTableMetadata (b :: BackendType) -> OID
[_ptmiColumns] :: DBTableMetadata (b :: BackendType) -> [RawColumnInfo b]
[_ptmiPrimaryKey] :: DBTableMetadata (b :: BackendType) -> Maybe (PrimaryKey b (Column b))

-- | Does <i>not</i> include the primary key
[_ptmiUniqueConstraints] :: DBTableMetadata (b :: BackendType) -> HashSet (UniqueConstraint b)
[_ptmiForeignKeys] :: DBTableMetadata (b :: BackendType) -> HashSet (ForeignKeyMetadata b)
[_ptmiViewInfo] :: DBTableMetadata (b :: BackendType) -> Maybe ViewInfo
[_ptmiDescription] :: DBTableMetadata (b :: BackendType) -> Maybe PGDescription
[_ptmiExtraTableMetadata] :: DBTableMetadata (b :: BackendType) -> ExtraTableMetadata b
type DBTablesMetadata b = HashMap (TableName b) (DBTableMetadata b)
getFieldInfoM :: TableInfo b -> FieldName -> Maybe (FieldInfo b)
getColumnInfoM :: TableInfo b -> FieldName -> Maybe (ColumnInfo b)
askFieldInfo :: MonadError QErr m => FieldInfoMap fieldInfo -> FieldName -> m fieldInfo
askColumnType :: (MonadError QErr m, Backend backend) => FieldInfoMap (FieldInfo backend) -> Column backend -> Text -> m (ColumnType backend)
askColInfo :: forall m backend. (MonadError QErr m, Backend backend) => FieldInfoMap (FieldInfo backend) -> Column backend -> Text -> m (ColumnInfo backend)
askComputedFieldInfo :: MonadError QErr m => FieldInfoMap (FieldInfo backend) -> ComputedFieldName -> m (ComputedFieldInfo backend)
assertColumnExists :: forall backend m. (MonadError QErr m, Backend backend) => FieldInfoMap (FieldInfo backend) -> Text -> Column backend -> m ()
askRelType :: MonadError QErr m => FieldInfoMap (FieldInfo backend) -> RelName -> Text -> m (RelInfo backend)
askRemoteRel :: MonadError QErr m => FieldInfoMap (FieldInfo backend) -> RelName -> m (RemoteFieldInfo (DBJoinField backend))
mkAdminRolePermInfo :: Backend b => TableCoreInfo b -> RolePermInfo b
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.ForeignKeyMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Table.ForeignKeyMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.ForeignKeyMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Table.ForeignKeyMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Table.ForeignKeyMetadata b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Table.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Table.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Table.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Table.ForeignKeyMetadata b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.TableInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.EventTriggerInfoMap b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.RolePermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.RolePermInfoMap b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.TableCoreInfo b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.TableInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.UniqueConstraint b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.ForeignKey b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.TableCoreInfoG b field primaryKeyColumn)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Table.UniqueConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Table.UniqueConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Table.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Table.ForeignKey b)
instance (GHC.Classes.Eq field, GHC.Classes.Eq pkCol, Hasura.RQL.Types.Backend.Backend b) => GHC.Classes.Eq (Hasura.RQL.Types.Table.TableCoreInfoG b field pkCol)
instance (Hasura.Incremental.Internal.Dependency.Cacheable field, Hasura.Incremental.Internal.Dependency.Cacheable pkCol, Hasura.RQL.Types.Backend.Backend b) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.TableCoreInfoG b field pkCol)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Generics.Generic pkCol, Data.Aeson.Types.ToJSON.ToJSON field, Data.Aeson.Types.ToJSON.ToJSON pkCol) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.TableCoreInfoG b field pkCol)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Table.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Table.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.UniqueConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Table.UniqueConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.UniqueConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.UniqueConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Table.UniqueConstraint b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.Constraint b)
instance Data.Foldable.Foldable (Hasura.RQL.Types.Table.PrimaryKey b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.PrimaryKey b a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Table.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Table.Constraint b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.Types.Table.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.Types.Table.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Data.Sequence.NonEmpty.Internal.NESeq a)) => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Table.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable a) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Table.PrimaryKey b a)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Table.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Table.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Table.TableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.TableConfig b)
instance GHC.Generics.Generic Hasura.RQL.Types.Table.ColumnConfig
instance GHC.Show.Show Hasura.RQL.Types.Table.ColumnConfig
instance GHC.Classes.Eq Hasura.RQL.Types.Table.ColumnConfig
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.TableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Table.TableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Table.TableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.TableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.TableConfig b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Table.ColumnConfig
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Table.ColumnConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Table.ColumnConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Table.ColumnConfig
instance GHC.Base.Semigroup Hasura.RQL.Types.Table.ColumnConfig
instance GHC.Base.Monoid Hasura.RQL.Types.Table.ColumnConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Table.ViewInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Table.ViewInfo
instance GHC.Generics.Generic Hasura.RQL.Types.Table.ViewInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Table.ViewInfo
instance GHC.Show.Show Hasura.RQL.Types.Table.ViewInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.Table.ViewInfo
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Table.ViewInfo
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.InsPermInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.SelPermInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.UpdPermInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.DelPermInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.RolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.RQL.Types.Table.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Show.Show (Hasura.RQL.Types.Table.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.RQL.Types.Table.SelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpPartialSQL b)) => GHC.Show.Show (Hasura.RQL.Types.Table.SelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.RQL.Types.Table.UpdPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Show.Show (Hasura.RQL.Types.Table.UpdPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.RQL.Types.Table.DelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Show.Show (Hasura.RQL.Types.Table.DelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.Types.Table.InsPermInfo b), Control.DeepSeq.NFData (Hasura.RQL.Types.Table.SelPermInfo b), Control.DeepSeq.NFData (Hasura.RQL.Types.Table.UpdPermInfo b), Control.DeepSeq.NFData (Hasura.RQL.Types.Table.DelPermInfo b)) => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.RolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.InsPermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.SelPermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.UpdPermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.DelPermInfo b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.RolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.DelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.DelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.DelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.PreSetColsPartial b)) => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.UpdPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.PreSetColsPartial b)) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.UpdPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.UpdPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpPartialSQL b)) => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.SelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpPartialSQL b)) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.SelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.SelPermInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Semigroup (Hasura.RQL.Types.Table.CombinedSelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.PreSetColsPartial b)) => Control.DeepSeq.NFData (Hasura.RQL.Types.Table.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.IR.BoolExp.PreSetColsPartial b)) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.InsPermInfo b)
instance GHC.Generics.Generic Hasura.RQL.Types.Table.CustomRootField
instance GHC.Classes.Eq Hasura.RQL.Types.Table.CustomRootField
instance GHC.Show.Show Hasura.RQL.Types.Table.CustomRootField
instance GHC.Generics.Generic Hasura.RQL.Types.Table.TableCustomRootFields
instance GHC.Classes.Eq Hasura.RQL.Types.Table.TableCustomRootFields
instance GHC.Show.Show Hasura.RQL.Types.Table.TableCustomRootFields
instance GHC.Generics.Generic (Hasura.RQL.Types.Table.FieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Table.FieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Table.FieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.FieldInfo b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Table.TableCustomRootFields
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Table.TableCustomRootFields
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Table.TableCustomRootFields
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Table.TableCustomRootFields
instance Control.DeepSeq.NFData Hasura.RQL.Types.Table.CustomRootField
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Table.CustomRootField
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Table.CustomRootField
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Table.CustomRootField

module Hasura.RQL.Types.Source
data SourceInfo b
SourceInfo :: SourceName -> TableCache b -> FunctionCache b -> SourceConfig b -> Maybe QueryTagsConfig -> SourceCustomization -> SourceInfo b
[_siName] :: SourceInfo b -> SourceName
[_siTables] :: SourceInfo b -> TableCache b
[_siFunctions] :: SourceInfo b -> FunctionCache b
[_siConfiguration] :: SourceInfo b -> SourceConfig b
[_siQueryTagsConfig] :: SourceInfo b -> Maybe QueryTagsConfig
[_siCustomization] :: SourceInfo b -> SourceCustomization
siTables :: forall b_alXvO. Lens' (SourceInfo b_alXvO) (TableCache b_alXvO)
siQueryTagsConfig :: forall b_alXvO. Lens' (SourceInfo b_alXvO) (Maybe QueryTagsConfig)
siName :: forall b_alXvO. Lens' (SourceInfo b_alXvO) SourceName
siFunctions :: forall b_alXvO. Lens' (SourceInfo b_alXvO) (FunctionCache b_alXvO)
siCustomization :: forall b_alXvO. Lens' (SourceInfo b_alXvO) SourceCustomization
siConfiguration :: forall b_alXvO. Lens' (SourceInfo b_alXvO) (SourceConfig b_alXvO)
type BackendSourceInfo = AnyBackend SourceInfo
type SourceCache = HashMap SourceName BackendSourceInfo
unsafeSourceInfo :: forall b. HasTag b => BackendSourceInfo -> Maybe (SourceInfo b)
unsafeSourceName :: BackendSourceInfo -> SourceName
unsafeSourceTables :: forall b. HasTag b => BackendSourceInfo -> Maybe (TableCache b)
unsafeSourceFunctions :: forall b. HasTag b => BackendSourceInfo -> Maybe (FunctionCache b)
unsafeSourceConfiguration :: forall b. HasTag b => BackendSourceInfo -> Maybe (SourceConfig b)

-- | Contains Postgres connection configuration and essential metadata from
--   the database to build schema cache for tables and function.
data ResolvedSource b
ResolvedSource :: SourceConfig b -> SourceTypeCustomization -> DBTablesMetadata b -> DBFunctionsMetadata b -> ScalarMap b -> ResolvedSource b
[_rsConfig] :: ResolvedSource b -> SourceConfig b
[_rsCustomization] :: ResolvedSource b -> SourceTypeCustomization
[_rsTables] :: ResolvedSource b -> DBTablesMetadata b
[_rsFunctions] :: ResolvedSource b -> DBFunctionsMetadata b
[_rsScalars] :: ResolvedSource b -> ScalarMap b

-- | A map from GraphQL name to equivalent scalar type for a given backend.
data ScalarMap b
[ScalarMap] :: Backend b => HashMap Name (ScalarType b) -> ScalarMap b

-- | FIXME: this should be either in <tt>BackendMetadata</tt>, or into a
--   new dedicated <tt>BackendResolve</tt>, instead of listing backends
--   explicitly. It could also be moved to the app level.
type SourceResolver b = SourceName -> SourceConnConfiguration b -> IO (Either QErr (SourceConfig b))
class (Monad m) => MonadResolveSource m
getPGSourceResolver :: MonadResolveSource m => m (SourceResolver ('Postgres 'Vanilla))
getMSSQLSourceResolver :: MonadResolveSource m => m (SourceResolver 'MSSQL)
data MaintenanceModeVersion

-- | should correspond to the source catalog version from which the user is
--   migrating from
PreviousMMVersion :: MaintenanceModeVersion

-- | should correspond to the latest source catalog version
CurrentMMVersion :: MaintenanceModeVersion
instance GHC.Classes.Eq Hasura.RQL.Types.Source.MaintenanceModeVersion
instance GHC.Show.Show Hasura.RQL.Types.Source.MaintenanceModeVersion
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Hasura.Tracing.TraceT m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance Hasura.Logging.ToEngineLog (Hasura.RQL.Types.Source.ResolvedSource b) Hasura.Logging.Hasura
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Semigroup (Hasura.RQL.Types.Source.ScalarMap b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Monoid (Hasura.RQL.Types.Source.ScalarMap b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Table.TableCache b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Function.FunctionCache b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Backend.SourceConfig b), Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryTags.QueryTagsConfig, Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.SourceCustomization) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.SourceInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Source.SourceInfo b)

module Hasura.RQL.Types.CustomTypes

-- | A wrapper around <a>GType</a> which allows us to define custom JSON
--   instances.
--   
--   TODO: this name is ambiguous, and conflicts with
--   Hasura.RQL.DDL.RemoteSchema.Permission.GraphQLType; it should perhaps
--   be renamed, made internal to this module, or removed altogether?
newtype GraphQLType
GraphQLType :: GType -> GraphQLType
[unGraphQLType] :: GraphQLType -> GType
isListType :: GraphQLType -> Bool
isNullableType :: GraphQLType -> Bool
isInBuiltScalar :: Text -> Bool

-- | A set of custom GraphQL types, sorted by "kind".
data CustomTypes
CustomTypes :: [InputObjectTypeDefinition] -> [ObjectTypeDefinition] -> [ScalarTypeDefinition] -> [EnumTypeDefinition] -> CustomTypes
[_ctInputObjects] :: CustomTypes -> [InputObjectTypeDefinition]
[_ctObjects] :: CustomTypes -> [ObjectTypeDefinition]
[_ctScalars] :: CustomTypes -> [ScalarTypeDefinition]
[_ctEnums] :: CustomTypes -> [EnumTypeDefinition]
emptyCustomTypes :: CustomTypes
data InputObjectTypeDefinition
InputObjectTypeDefinition :: InputObjectTypeName -> Maybe Description -> NonEmpty InputObjectFieldDefinition -> InputObjectTypeDefinition
[_iotdName] :: InputObjectTypeDefinition -> InputObjectTypeName
[_iotdDescription] :: InputObjectTypeDefinition -> Maybe Description
[_iotdFields] :: InputObjectTypeDefinition -> NonEmpty InputObjectFieldDefinition
newtype InputObjectTypeName
InputObjectTypeName :: Name -> InputObjectTypeName
[unInputObjectTypeName] :: InputObjectTypeName -> Name
data InputObjectFieldDefinition
InputObjectFieldDefinition :: InputObjectFieldName -> Maybe Description -> GraphQLType -> InputObjectFieldDefinition
[_iofdName] :: InputObjectFieldDefinition -> InputObjectFieldName
[_iofdDescription] :: InputObjectFieldDefinition -> Maybe Description
[_iofdType] :: InputObjectFieldDefinition -> GraphQLType
newtype InputObjectFieldName
InputObjectFieldName :: Name -> InputObjectFieldName
[unInputObjectFieldName] :: InputObjectFieldName -> Name
data ObjectTypeDefinition
ObjectTypeDefinition :: ObjectTypeName -> Maybe Description -> NonEmpty (ObjectFieldDefinition GraphQLType) -> [TypeRelationshipDefinition] -> ObjectTypeDefinition
[_otdName] :: ObjectTypeDefinition -> ObjectTypeName
[_otdDescription] :: ObjectTypeDefinition -> Maybe Description
[_otdFields] :: ObjectTypeDefinition -> NonEmpty (ObjectFieldDefinition GraphQLType)
[_otdRelationships] :: ObjectTypeDefinition -> [TypeRelationshipDefinition]
newtype ObjectTypeName
ObjectTypeName :: Name -> ObjectTypeName
[unObjectTypeName] :: ObjectTypeName -> Name
data ObjectFieldDefinition field
ObjectFieldDefinition :: ObjectFieldName -> Maybe Value -> Maybe Description -> field -> ObjectFieldDefinition field
[_ofdName] :: ObjectFieldDefinition field -> ObjectFieldName
[_ofdArguments] :: ObjectFieldDefinition field -> Maybe Value
[_ofdDescription] :: ObjectFieldDefinition field -> Maybe Description
[_ofdType] :: ObjectFieldDefinition field -> field
newtype ObjectFieldName
ObjectFieldName :: Name -> ObjectFieldName
[unObjectFieldName] :: ObjectFieldName -> Name
data ScalarTypeDefinition
ScalarTypeDefinition :: Name -> Maybe Description -> ScalarTypeDefinition
[_stdName] :: ScalarTypeDefinition -> Name
[_stdDescription] :: ScalarTypeDefinition -> Maybe Description
defaultGraphQLScalars :: HashMap Name ScalarTypeDefinition
data EnumTypeDefinition
EnumTypeDefinition :: EnumTypeName -> Maybe Description -> NonEmpty EnumValueDefinition -> EnumTypeDefinition
[_etdName] :: EnumTypeDefinition -> EnumTypeName
[_etdDescription] :: EnumTypeDefinition -> Maybe Description
[_etdValues] :: EnumTypeDefinition -> NonEmpty EnumValueDefinition
newtype EnumTypeName
EnumTypeName :: Name -> EnumTypeName
[unEnumTypeName] :: EnumTypeName -> Name
data EnumValueDefinition
EnumValueDefinition :: EnumValue -> Maybe Description -> Maybe Bool -> EnumValueDefinition
[_evdValue] :: EnumValueDefinition -> EnumValue
[_evdDescription] :: EnumValueDefinition -> Maybe Description
[_evdIsDeprecated] :: EnumValueDefinition -> Maybe Bool
data TypeRelationshipDefinition
TypeRelationshipDefinition :: RelationshipName -> RelType -> SourceName -> QualifiedTable -> HashMap ObjectFieldName PGCol -> TypeRelationshipDefinition
[_trdName] :: TypeRelationshipDefinition -> RelationshipName
[_trdType] :: TypeRelationshipDefinition -> RelType
[_trdSource] :: TypeRelationshipDefinition -> SourceName
[_trdRemoteTable] :: TypeRelationshipDefinition -> QualifiedTable
[_trdFieldMapping] :: TypeRelationshipDefinition -> HashMap ObjectFieldName PGCol

-- | TODO: deduplicate this in favour of RelName
newtype RelationshipName
RelationshipName :: Name -> RelationshipName
[unRelationshipName] :: RelationshipName -> Name

-- | While we do not persist resolved types in the schema cache, they are
--   used when building the cache to validate and resolve actions and their
--   relationships.
data AnnotatedCustomTypes
AnnotatedCustomTypes :: HashMap Name AnnotatedInputType -> HashMap Name AnnotatedObjectType -> AnnotatedCustomTypes
[_actInputTypes] :: AnnotatedCustomTypes -> HashMap Name AnnotatedInputType
[_actObjectTypes] :: AnnotatedCustomTypes -> HashMap Name AnnotatedObjectType
data AnnotatedInputType
NOCTScalar :: AnnotatedScalarType -> AnnotatedInputType
NOCTEnum :: EnumTypeDefinition -> AnnotatedInputType
NOCTInputObject :: InputObjectTypeDefinition -> AnnotatedInputType
data AnnotatedScalarType
ASTCustom :: ScalarTypeDefinition -> AnnotatedScalarType
ASTReusedScalar :: Name -> AnyBackend ScalarWrapper -> AnnotatedScalarType
newtype ScalarWrapper b
ScalarWrapper :: ScalarType b -> ScalarWrapper b
[unwrapScalar] :: ScalarWrapper b -> ScalarType b
data AnnotatedOutputType
AOTObject :: AnnotatedObjectType -> AnnotatedOutputType
AOTScalar :: AnnotatedScalarType -> AnnotatedOutputType
data AnnotatedObjectType
AnnotatedObjectType :: ObjectTypeName -> Maybe Description -> NonEmpty (ObjectFieldDefinition (GType, AnnotatedObjectFieldType)) -> [AnnotatedTypeRelationship] -> AnnotatedObjectType
[_aotName] :: AnnotatedObjectType -> ObjectTypeName
[_aotDescription] :: AnnotatedObjectType -> Maybe Description
[_aotFields] :: AnnotatedObjectType -> NonEmpty (ObjectFieldDefinition (GType, AnnotatedObjectFieldType))
[_aotRelationships] :: AnnotatedObjectType -> [AnnotatedTypeRelationship]
data AnnotatedObjectFieldType
AOFTScalar :: AnnotatedScalarType -> AnnotatedObjectFieldType
AOFTEnum :: EnumTypeDefinition -> AnnotatedObjectFieldType
AOFTObject :: Name -> AnnotatedObjectFieldType
data AnnotatedTypeRelationship
AnnotatedTypeRelationship :: RelationshipName -> RelType -> SourceName -> SourceConfig ('Postgres 'Vanilla) -> SourceTypeCustomization -> TableInfo ('Postgres 'Vanilla) -> HashMap ObjectFieldName (ColumnInfo ('Postgres 'Vanilla)) -> AnnotatedTypeRelationship
[_atrName] :: AnnotatedTypeRelationship -> RelationshipName
[_atrType] :: AnnotatedTypeRelationship -> RelType
[_atrSource] :: AnnotatedTypeRelationship -> SourceName
[_atrSourceConfig] :: AnnotatedTypeRelationship -> SourceConfig ('Postgres 'Vanilla)
[_atrSourceCustomization] :: AnnotatedTypeRelationship -> SourceTypeCustomization
[_atrTableInfo] :: AnnotatedTypeRelationship -> TableInfo ('Postgres 'Vanilla)
[_atrFieldMapping] :: AnnotatedTypeRelationship -> HashMap ObjectFieldName (ColumnInfo ('Postgres 'Vanilla))
trdType :: Lens' TypeRelationshipDefinition RelType
trdSource :: Lens' TypeRelationshipDefinition SourceName
trdRemoteTable :: Lens' TypeRelationshipDefinition QualifiedTable
trdName :: Lens' TypeRelationshipDefinition RelationshipName
trdFieldMapping :: Lens' TypeRelationshipDefinition (HashMap ObjectFieldName PGCol)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedOutputType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedObjectType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedTypeRelationship
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedObjectFieldType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedInputType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.CustomTypes
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.CustomTypes
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON field => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Data.Aeson.Types.FromJSON.FromJSON field => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.GraphQLType
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.GraphQLType
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.GraphQLType
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.GraphQLType
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.GraphQLType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Generics.Generic (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Data.Traversable.Traversable Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition
instance Data.Foldable.Foldable Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition
instance GHC.Base.Functor Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance GHC.Show.Show field => GHC.Show.Show (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.RelationshipName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.RelationshipName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.RelationshipName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.RelationshipName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.RelationshipName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.CustomTypes
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.CustomTypes
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.CustomTypes
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedScalarType
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.AnnotatedScalarType
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedInputType
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.AnnotatedInputType
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedObjectFieldType
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedTypeRelationship
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedObjectType
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedOutputType
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.CustomTypes.ScalarWrapper b)
instance GHC.Base.Semigroup Hasura.RQL.Types.CustomTypes.AnnotatedCustomTypes
instance GHC.Base.Monoid Hasura.RQL.Types.CustomTypes.AnnotatedCustomTypes
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.CustomTypes
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.CustomTypes
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Control.DeepSeq.NFData field => Control.DeepSeq.NFData (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Hasura.Incremental.Internal.Dependency.Cacheable field => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.GraphQLType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.GraphQLType

module Hasura.RQL.Types.Action
data ActionMetadata
ActionMetadata :: ActionName -> Maybe Text -> ActionDefinitionInput -> [ActionPermissionMetadata] -> ActionMetadata
[_amName] :: ActionMetadata -> ActionName
[_amComment] :: ActionMetadata -> Maybe Text
[_amDefinition] :: ActionMetadata -> ActionDefinitionInput
[_amPermissions] :: ActionMetadata -> [ActionPermissionMetadata]
data ActionPermissionMetadata
ActionPermissionMetadata :: RoleName -> Maybe Text -> ActionPermissionMetadata
[_apmRole] :: ActionPermissionMetadata -> RoleName
[_apmComment] :: ActionPermissionMetadata -> Maybe Text
newtype ActionName
ActionName :: Name -> ActionName
[unActionName] :: ActionName -> Name
newtype ActionId
ActionId :: UUID -> ActionId
[unActionId] :: ActionId -> UUID
actionIdToText :: ActionId -> Text
type ActionDefinitionInput = ActionDefinition GraphQLType InputWebhook
data ActionDefinition arg webhook
ActionDefinition :: [ArgumentDefinition arg] -> GraphQLType -> ActionType -> [HeaderConf] -> Bool -> Timeout -> webhook -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> ActionDefinition arg webhook
[_adArguments] :: ActionDefinition arg webhook -> [ArgumentDefinition arg]
[_adOutputType] :: ActionDefinition arg webhook -> GraphQLType
[_adType] :: ActionDefinition arg webhook -> ActionType
[_adHeaders] :: ActionDefinition arg webhook -> [HeaderConf]
[_adForwardClientHeaders] :: ActionDefinition arg webhook -> Bool

-- | If the timeout is not provided by the user, then the default timeout
--   of 30 seconds will be used
[_adTimeout] :: ActionDefinition arg webhook -> Timeout
[_adHandler] :: ActionDefinition arg webhook -> webhook
[_adRequestTransform] :: ActionDefinition arg webhook -> Maybe RequestTransform
[_adResponseTransform] :: ActionDefinition arg webhook -> Maybe MetadataResponseTransform
data ActionType
ActionQuery :: ActionType
ActionMutation :: ActionMutationKind -> ActionType
data ActionMutationKind
ActionSynchronous :: ActionMutationKind
ActionAsynchronous :: ActionMutationKind
data ArgumentDefinition a
ArgumentDefinition :: ArgumentName -> a -> Maybe Description -> ArgumentDefinition a
[_argName] :: ArgumentDefinition a -> ArgumentName
[_argType] :: ArgumentDefinition a -> a
[_argDescription] :: ArgumentDefinition a -> Maybe Description
newtype ArgumentName
ArgumentName :: Name -> ArgumentName
[unArgumentName] :: ArgumentName -> Name
data ActionInfo
ActionInfo :: ActionName -> (GType, AnnotatedOutputType) -> ResolvedActionDefinition -> HashMap RoleName ActionPermissionInfo -> Bool -> Maybe Text -> ActionInfo
[_aiName] :: ActionInfo -> ActionName
[_aiOutputType] :: ActionInfo -> (GType, AnnotatedOutputType)
[_aiDefinition] :: ActionInfo -> ResolvedActionDefinition
[_aiPermissions] :: ActionInfo -> HashMap RoleName ActionPermissionInfo
[_aiForwardedClientHeaders] :: ActionInfo -> Bool
[_aiComment] :: ActionInfo -> Maybe Text
type ResolvedActionDefinition = ActionDefinition (GType, AnnotatedInputType) (EnvRecord ResolvedWebhook)
newtype ActionPermissionInfo
ActionPermissionInfo :: RoleName -> ActionPermissionInfo
[_apiRole] :: ActionPermissionInfo -> RoleName
data ActionExecContext
ActionExecContext :: Manager -> RequestHeaders -> SessionVariables -> ActionExecContext
[_aecManager] :: ActionExecContext -> Manager
[_aecHeaders] :: ActionExecContext -> RequestHeaders
[_aecSessionVariables] :: ActionExecContext -> SessionVariables
data ActionLogItem
ActionLogItem :: ActionId -> ActionName -> [Header] -> SessionVariables -> Value -> ActionLogItem
[_aliId] :: ActionLogItem -> ActionId
[_aliActionName] :: ActionLogItem -> ActionName
[_aliRequestHeaders] :: ActionLogItem -> [Header]
[_aliSessionVariables] :: ActionLogItem -> SessionVariables
[_aliInputPayload] :: ActionLogItem -> Value
data ActionLogResponse
ActionLogResponse :: ActionId -> UTCTime -> Maybe Value -> Maybe Value -> SessionVariables -> ActionLogResponse
[_alrId] :: ActionLogResponse -> ActionId
[_alrCreatedAt] :: ActionLogResponse -> UTCTime
[_alrResponsePayload] :: ActionLogResponse -> Maybe Value
[_alrErrors] :: ActionLogResponse -> Maybe Value
[_alrSessionVariables] :: ActionLogResponse -> SessionVariables
type ActionLogResponseMap = HashMap ActionId ActionLogResponse
data AsyncActionStatus
AASCompleted :: Value -> AsyncActionStatus
AASError :: QErr -> AsyncActionStatus
data ActionsInfo
ActionsInfo :: ActionName -> Bool -> ActionsInfo
[_asiName] :: ActionsInfo -> ActionName
[_asiForwardClientHeaders] :: ActionsInfo -> Bool
type LockedActionEventId = EventId
newtype LockedActionIdArray
LockedActionIdArray :: [LockedActionEventId] -> LockedActionIdArray
[unCohortIdArray] :: LockedActionIdArray -> [LockedActionEventId]
amPermissions :: Lens' ActionMetadata [ActionPermissionMetadata]
amName :: Lens' ActionMetadata ActionName
amDefinition :: Lens' ActionMetadata ActionDefinitionInput
amComment :: Lens' ActionMetadata (Maybe Text)
adType :: forall arg_ampvU webhook_ampvV. Lens' (ActionDefinition arg_ampvU webhook_ampvV) ActionType
adTimeout :: forall arg_ampvU webhook_ampvV. Lens' (ActionDefinition arg_ampvU webhook_ampvV) Timeout
adResponseTransform :: forall arg_ampvU webhook_ampvV. Lens' (ActionDefinition arg_ampvU webhook_ampvV) (Maybe MetadataResponseTransform)
adRequestTransform :: forall arg_ampvU webhook_ampvV. Lens' (ActionDefinition arg_ampvU webhook_ampvV) (Maybe RequestTransform)
adOutputType :: forall arg_ampvU webhook_ampvV. Lens' (ActionDefinition arg_ampvU webhook_ampvV) GraphQLType
adHeaders :: forall arg_ampvU webhook_ampvV. Lens' (ActionDefinition arg_ampvU webhook_ampvV) [HeaderConf]
adHandler :: forall arg_ampvU webhook_ampvV webhook_amrNJ. Lens (ActionDefinition arg_ampvU webhook_ampvV) (ActionDefinition arg_ampvU webhook_amrNJ) webhook_ampvV webhook_amrNJ
adForwardClientHeaders :: forall arg_ampvU webhook_ampvV. Lens' (ActionDefinition arg_ampvU webhook_ampvV) Bool
adArguments :: forall arg_ampvU webhook_ampvV arg_amrNI. Lens (ActionDefinition arg_ampvU webhook_ampvV) (ActionDefinition arg_amrNI webhook_ampvV) [ArgumentDefinition arg_ampvU] [ArgumentDefinition arg_amrNI]
aiPermissions :: Lens' ActionInfo (HashMap RoleName ActionPermissionInfo)
aiOutputType :: Lens' ActionInfo (GType, AnnotatedOutputType)
aiName :: Lens' ActionInfo ActionName
aiForwardedClientHeaders :: Lens' ActionInfo Bool
aiDefinition :: Lens' ActionInfo ResolvedActionDefinition
aiComment :: Lens' ActionInfo (Maybe Text)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionLogResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionMutationKind
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionMutationKind
instance (Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON b) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Action.ActionDefinition a b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionMetadata
instance (Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.ToJSON.ToJSON b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Action.ActionDefinition a b)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionPermissionMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionPermissionMetadata
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionPermissionMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionPermissionMetadata
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionPermissionMetadata
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Action.ActionName
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Action.ActionName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionName
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionName
instance GHC.Classes.Ord Hasura.RQL.Types.Action.ActionName
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionName
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Action.ActionId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionId
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Action.ActionId
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Action.ActionId
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionId
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionId
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionType
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionType
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Action.ArgumentName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ArgumentName
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ArgumentName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Action.ArgumentName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Action.ArgumentName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Action.ArgumentName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ArgumentName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ArgumentName
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ArgumentName
instance GHC.Show.Show Hasura.RQL.Types.Action.ArgumentName
instance GHC.Generics.Generic (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance Data.Traversable.Traversable Hasura.RQL.Types.Action.ArgumentDefinition
instance Data.Foldable.Foldable Hasura.RQL.Types.Action.ArgumentDefinition
instance GHC.Base.Functor Hasura.RQL.Types.Action.ArgumentDefinition
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance GHC.Generics.Generic (Hasura.RQL.Types.Action.ActionDefinition arg webhook)
instance Data.Traversable.Traversable (Hasura.RQL.Types.Action.ActionDefinition arg)
instance Data.Foldable.Foldable (Hasura.RQL.Types.Action.ActionDefinition arg)
instance GHC.Base.Functor (Hasura.RQL.Types.Action.ActionDefinition arg)
instance (GHC.Classes.Eq arg, GHC.Classes.Eq webhook) => GHC.Classes.Eq (Hasura.RQL.Types.Action.ActionDefinition arg webhook)
instance (GHC.Show.Show arg, GHC.Show.Show webhook) => GHC.Show.Show (Hasura.RQL.Types.Action.ActionDefinition arg webhook)
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionMetadata
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionPermissionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionPermissionInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionPermissionInfo
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionPermissionInfo
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionLogItem
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionLogItem
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionLogResponse
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionLogResponse
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionsInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionsInfo
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionsInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Action.LockedActionIdArray
instance GHC.Show.Show Hasura.RQL.Types.Action.LockedActionIdArray
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Action.LockedActionIdArray
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionMetadata
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Action.ActionMetadata
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData w) => Control.DeepSeq.NFData (Hasura.RQL.Types.Action.ActionDefinition a w)
instance (Hasura.Incremental.Internal.Dependency.Cacheable a, Hasura.Incremental.Internal.Dependency.Cacheable w) => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Action.ActionDefinition a w)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance Hasura.Incremental.Internal.Dependency.Cacheable a => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionType
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Action.ActionType
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionMutationKind
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Action.ActionMutationKind
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Action.ActionName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Action.ActionName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionPermissionMetadata
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Action.ActionPermissionMetadata

module Hasura.Eventing.Common
data LockedEventsCtx
LockedEventsCtx :: TVar (Set CronEventId) -> TVar (Set OneOffScheduledEventId) -> TVar (HashMap SourceName (Set EventId)) -> TVar (Set LockedActionEventId) -> LockedEventsCtx
[leCronEvents] :: LockedEventsCtx -> TVar (Set CronEventId)
[leOneOffEvents] :: LockedEventsCtx -> TVar (Set OneOffScheduledEventId)
[leEvents] :: LockedEventsCtx -> TVar (HashMap SourceName (Set EventId))
[leActionEvents] :: LockedEventsCtx -> TVar (Set LockedActionEventId)

-- | After the events are fetched from the DB, we store the locked events
--   in a hash set(order doesn't matter and look ups are faster) in the
--   event engine context
saveLockedEvents :: MonadIO m => [EventId] -> TVar (Set EventId) -> m ()

-- | Remove an event from the <a>LockedEventsCtx</a> after it has been
--   processed
removeEventFromLockedEvents :: MonadIO m => EventId -> TVar (Set EventId) -> m ()

module Hasura.RQL.IR.Action

-- | Internal representation for a selection of fields on the result of an
--   action. Type parameter r will be either r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
data ActionFieldG (r :: Type)

-- | Scalar value. G.Name is the original field name from the object type.
ACFScalar :: Name -> ActionFieldG (r :: Type)

-- | Remote relationship
ACFRemote :: ActionRemoteRelationshipSelect r -> ActionFieldG (r :: Type)

-- | Constant text value (used for __typename fields)
ACFExpression :: Text -> ActionFieldG (r :: Type)

-- | Nested object. G.Name is the original field name from the object type.
ACFNestedObject :: Name -> ActionFieldsG r -> ActionFieldG (r :: Type)
type ActionFieldsG r = Fields (ActionFieldG r)
type ActionFields = ActionFieldsG Void
data ActionRemoteRelationshipSelect r
ActionRemoteRelationshipSelect :: HashMap FieldName Name -> r -> ActionRemoteRelationshipSelect r

-- | The fields on the table that are required for the join condition of
--   the remote relationship
[_arrsLHSJoinFields] :: ActionRemoteRelationshipSelect r -> HashMap FieldName Name

-- | The field that captures the relationship r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
[_arrsRelationship] :: ActionRemoteRelationshipSelect r -> r
_ACFNestedObject :: forall r_amFH1. Prism' (ActionFieldG r_amFH1) (Name, ActionFieldsG r_amFH1)
_ACFExpression :: forall r_amFH1. Prism' (ActionFieldG r_amFH1) Text
_ACFRemote :: forall r_amFH1. Prism' (ActionFieldG r_amFH1) (ActionRemoteRelationshipSelect r_amFH1)
_ACFScalar :: forall r_amFH1. Prism' (ActionFieldG r_amFH1) Name
data AnnActionExecution (r :: Type)
AnnActionExecution :: ActionName -> GraphQLType -> ActionFieldsG r -> Value -> ActionOutputFields -> EnvRecord ResolvedWebhook -> [HeaderConf] -> Bool -> Timeout -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> AnnActionExecution (r :: Type)
[_aaeName] :: AnnActionExecution (r :: Type) -> ActionName

-- | output type
[_aaeOutputType] :: AnnActionExecution (r :: Type) -> GraphQLType

-- | output selection
[_aaeFields] :: AnnActionExecution (r :: Type) -> ActionFieldsG r

-- | jsonified input arguments
[_aaePayload] :: AnnActionExecution (r :: Type) -> Value

-- | to validate the response fields from webhook
[_aaeOutputFields] :: AnnActionExecution (r :: Type) -> ActionOutputFields
[_aaeWebhook] :: AnnActionExecution (r :: Type) -> EnvRecord ResolvedWebhook
[_aaeHeaders] :: AnnActionExecution (r :: Type) -> [HeaderConf]
[_aaeForwardClientHeaders] :: AnnActionExecution (r :: Type) -> Bool
[_aaeTimeOut] :: AnnActionExecution (r :: Type) -> Timeout
[_aaeRequestTransform] :: AnnActionExecution (r :: Type) -> Maybe RequestTransform
[_aaeResponseTransform] :: AnnActionExecution (r :: Type) -> Maybe MetadataResponseTransform
type ActionOutputFields = HashMap Name GType
getActionOutputFields :: AnnotatedOutputType -> ActionOutputFields
data AnnActionMutationAsync
AnnActionMutationAsync :: ActionName -> Bool -> Value -> AnnActionMutationAsync
[_aamaName] :: AnnActionMutationAsync -> ActionName
[_aamaForwardClientHeaders] :: AnnActionMutationAsync -> Bool

-- | jsonified input arguments
[_aamaPayload] :: AnnActionMutationAsync -> Value
data AsyncActionQueryFieldG (r :: Type)
AsyncTypename :: Text -> AsyncActionQueryFieldG (r :: Type)
AsyncOutput :: ActionFieldsG r -> AsyncActionQueryFieldG (r :: Type)
AsyncId :: AsyncActionQueryFieldG (r :: Type)
AsyncCreatedAt :: AsyncActionQueryFieldG (r :: Type)
AsyncErrors :: AsyncActionQueryFieldG (r :: Type)
type AsyncActionQueryFieldsG r = Fields (AsyncActionQueryFieldG r)
data AnnActionAsyncQuery (b :: BackendType) (r :: Type)
AnnActionAsyncQuery :: ActionName -> ActionId -> GraphQLType -> AsyncActionQueryFieldsG r -> [(Column b, ScalarType b)] -> StringifyNumbers -> Bool -> ActionSourceInfo b -> AnnActionAsyncQuery (b :: BackendType) (r :: Type)
[_aaaqName] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> ActionName
[_aaaqActionId] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> ActionId
[_aaaqOutputType] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> GraphQLType
[_aaaqFields] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> AsyncActionQueryFieldsG r
[_aaaqDefinitionList] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> [(Column b, ScalarType b)]
[_aaaqStringifyNum] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> StringifyNumbers
[_aaaqForwardClientHeaders] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> Bool
[_aaaqSource] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> ActionSourceInfo b
data ActionSourceInfo b

-- | No relationships defined on the action output object
ASINoSource :: ActionSourceInfo b

-- | All relationships refer to tables in one source
ASISource :: SourceName -> SourceConfig b -> ActionSourceInfo b
aaaqStringifyNum :: forall b_amG5f r_amG5g. Lens' (AnnActionAsyncQuery b_amG5f r_amG5g) StringifyNumbers
aaaqSource :: forall b_amG5f r_amG5g. Lens' (AnnActionAsyncQuery b_amG5f r_amG5g) (ActionSourceInfo b_amG5f)
aaaqOutputType :: forall b_amG5f r_amG5g. Lens' (AnnActionAsyncQuery b_amG5f r_amG5g) GraphQLType
aaaqName :: forall b_amG5f r_amG5g. Lens' (AnnActionAsyncQuery b_amG5f r_amG5g) ActionName
aaaqForwardClientHeaders :: forall b_amG5f r_amG5g. Lens' (AnnActionAsyncQuery b_amG5f r_amG5g) Bool
aaaqFields :: forall b_amG5f r_amG5g r_amGI4. Lens (AnnActionAsyncQuery b_amG5f r_amG5g) (AnnActionAsyncQuery b_amG5f r_amGI4) (AsyncActionQueryFieldsG r_amG5g) (AsyncActionQueryFieldsG r_amGI4)
aaaqDefinitionList :: forall b_amG5f r_amG5g. Lens' (AnnActionAsyncQuery b_amG5f r_amG5g) [(Column b_amG5f, ScalarType b_amG5f)]
aaaqActionId :: forall b_amG5f r_amG5g. Lens' (AnnActionAsyncQuery b_amG5f r_amG5g) ActionId
aaeWebhook :: forall r_amG5j. Lens' (AnnActionExecution r_amG5j) (EnvRecord ResolvedWebhook)
aaeTimeOut :: forall r_amG5j. Lens' (AnnActionExecution r_amG5j) Timeout
aaeResponseTransform :: forall r_amG5j. Lens' (AnnActionExecution r_amG5j) (Maybe MetadataResponseTransform)
aaeRequestTransform :: forall r_amG5j. Lens' (AnnActionExecution r_amG5j) (Maybe RequestTransform)
aaePayload :: forall r_amG5j. Lens' (AnnActionExecution r_amG5j) Value
aaeOutputType :: forall r_amG5j. Lens' (AnnActionExecution r_amG5j) GraphQLType
aaeOutputFields :: forall r_amG5j. Lens' (AnnActionExecution r_amG5j) ActionOutputFields
aaeName :: forall r_amG5j. Lens' (AnnActionExecution r_amG5j) ActionName
aaeHeaders :: forall r_amG5j. Lens' (AnnActionExecution r_amG5j) [HeaderConf]
aaeForwardClientHeaders :: forall r_amG5j. Lens' (AnnActionExecution r_amG5j) Bool
aaeFields :: forall r_amG5j r_amGNT. Lens (AnnActionExecution r_amG5j) (AnnActionExecution r_amGNT) (ActionFieldsG r_amG5j) (ActionFieldsG r_amGNT)
_AsyncErrors :: forall r_amG5i. Prism' (AsyncActionQueryFieldG r_amG5i) ()
_AsyncCreatedAt :: forall r_amG5i. Prism' (AsyncActionQueryFieldG r_amG5i) ()
_AsyncId :: forall r_amG5i. Prism' (AsyncActionQueryFieldG r_amG5i) ()
_AsyncOutput :: forall r_amGV8 r_amG5i. Prism (AsyncActionQueryFieldG r_amGV8) (AsyncActionQueryFieldG r_amG5i) (ActionFieldsG r_amGV8) (ActionFieldsG r_amG5i)
_AsyncTypename :: forall r_amG5i. Prism' (AsyncActionQueryFieldG r_amG5i) Text
instance Data.Traversable.Traversable Hasura.RQL.IR.Action.AnnActionExecution
instance Data.Foldable.Foldable Hasura.RQL.IR.Action.AnnActionExecution
instance GHC.Base.Functor Hasura.RQL.IR.Action.AnnActionExecution
instance GHC.Classes.Eq Hasura.RQL.IR.Action.AnnActionMutationAsync
instance GHC.Show.Show Hasura.RQL.IR.Action.AnnActionMutationAsync
instance Data.Traversable.Traversable Hasura.RQL.IR.Action.AsyncActionQueryFieldG
instance Data.Foldable.Foldable Hasura.RQL.IR.Action.AsyncActionQueryFieldG
instance GHC.Base.Functor Hasura.RQL.IR.Action.AsyncActionQueryFieldG
instance Data.Traversable.Traversable (Hasura.RQL.IR.Action.AnnActionAsyncQuery b)
instance Data.Foldable.Foldable (Hasura.RQL.IR.Action.AnnActionAsyncQuery b)
instance GHC.Base.Functor (Hasura.RQL.IR.Action.AnnActionAsyncQuery b)
instance Data.Traversable.Traversable Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect
instance Data.Foldable.Foldable Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect
instance GHC.Base.Functor Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect
instance GHC.Show.Show r => GHC.Show.Show (Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect r)
instance Data.Traversable.Traversable Hasura.RQL.IR.Action.ActionFieldG
instance Data.Foldable.Foldable Hasura.RQL.IR.Action.ActionFieldG
instance GHC.Base.Functor Hasura.RQL.IR.Action.ActionFieldG
instance GHC.Show.Show r => GHC.Show.Show (Hasura.RQL.IR.Action.ActionFieldG r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RQL.IR.Action.ActionFieldG r)

module Hasura.RQL.Types.BoolExp

-- | Context to parse a RHS value in a boolean expression
data BoolExpRHSParser (b :: BackendType) m v
BoolExpRHSParser :: ValueParser b m v -> v -> BoolExpRHSParser (b :: BackendType) m v

-- | Parse a JSON value with enforcing a column type
[_berpValueParser] :: BoolExpRHSParser (b :: BackendType) m v -> ValueParser b m v

-- | Required for a computed field SQL function with session argument
[_berpSessionValue] :: BoolExpRHSParser (b :: BackendType) m v -> v

-- | A function which resolves boolean expression from given table fields
newtype BoolExpResolver b m v
BoolExpResolver :: (BoolExpRHSParser b m v -> TableName b -> FieldInfoMap (FieldInfo b) -> GBoolExp b ColExp -> m (AnnBoolExp b v)) -> BoolExpResolver b m v
[getBoolExpResolver] :: BoolExpResolver b m v -> BoolExpRHSParser b m v -> TableName b -> FieldInfoMap (FieldInfo b) -> GBoolExp b ColExp -> m (AnnBoolExp b v)


-- | Types and functions for interacting with and manipulating SQL enums
--   represented by <i>single-column tables</i>, <b>not</b> native Postgres
--   enum types. Native enum types in Postgres are difficult to change, so
--   we discourage their use, but we might add support for native enum
--   types in the future.
module Hasura.RQL.DDL.Schema.Enum

-- | Given a map of enum tables, computes all enum references implied by
--   the given set of foreign keys. A foreign key constitutes an enum
--   reference iff the following conditions hold:
--   
--   <ol>
--   <li>The key only includes a single column.</li>
--   <li>The referenced column is the table’s primary key.</li>
--   <li>The referenced table is, in fact, an enum table.</li>
--   </ol>
resolveEnumReferences :: forall b. Backend b => HashMap (TableName b) (PrimaryKey b (Column b), TableConfig b, EnumValues) -> HashSet (ForeignKey b) -> HashMap (Column b) (NonEmpty (EnumReference b))


-- | Postgres Types Table
--   
--   Defines a single combinator to throw an error if the view is not
--   mutable.
module Hasura.Backends.Postgres.Types.Table
mutableView :: MonadError QErr m => QualifiedTable -> (ViewInfo -> Bool) -> Maybe ViewInfo -> Text -> m ()


-- | Postgres Translate Mutation
--   
--   Provide a combinator for generating a Postgres SQL SELECT statement
--   for the selected columns in mutation queries.
--   
--   See <a>Mutation</a> and note [Prepared statements in Mutations]
module Hasura.Backends.Postgres.Translate.Mutation

-- | Note:- Using sorted columns is necessary to enable casting the rows
--   returned by VALUES expression to table type. For example, let's
--   consider the table, `CREATE TABLE test (id serial primary key, name
--   text not null, age int)`. The generated values expression should be in
--   order of columns; `SELECT ("row"::table).* VALUES (1, <tt>Robert</tt>,
--   23) AS "row"`.
mkSelectExpFromColumnValues :: forall pgKind m. MonadError QErr m => QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> [ColumnValues ('Postgres pgKind) TxtEncodedVal] -> m Select


-- | Postgres DDL Table
--   
--   Used to fill up the enum values field of <a>TableCoreInfoG</a>.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.Table
data EnumTableIntegrityError (b :: BackendType)
EnumTablePostgresError :: Text -> EnumTableIntegrityError (b :: BackendType)
EnumTableMissingPrimaryKey :: EnumTableIntegrityError (b :: BackendType)
EnumTableMultiColumnPrimaryKey :: [PGCol] -> EnumTableIntegrityError (b :: BackendType)
EnumTableNonTextualPrimaryKey :: RawColumnInfo b -> EnumTableIntegrityError (b :: BackendType)
EnumTableNoEnumValues :: EnumTableIntegrityError (b :: BackendType)
EnumTableInvalidEnumValueNames :: NonEmpty Text -> EnumTableIntegrityError (b :: BackendType)
EnumTableNonTextualCommentColumn :: RawColumnInfo b -> EnumTableIntegrityError (b :: BackendType)
EnumTableTooManyColumns :: [PGCol] -> EnumTableIntegrityError (b :: BackendType)
fetchAndValidateEnumValues :: forall pgKind m. (Backend ('Postgres pgKind), MonadIO m, MonadBaseControl IO m) => PGSourceConfig -> QualifiedTable -> Maybe (PrimaryKey ('Postgres pgKind) (RawColumnInfo ('Postgres pgKind))) -> [RawColumnInfo ('Postgres pgKind)] -> m (Either QErr EnumValues)
fetchEnumValuesFromDb :: forall pgKind m. (MonadTx m, MonadValidate [EnumTableIntegrityError ('Postgres pgKind)] m) => QualifiedTable -> RawColumnInfo ('Postgres pgKind) -> Maybe (RawColumnInfo ('Postgres pgKind)) -> m EnumValues


-- | Postgres DDL EventTrigger
--   
--   Used for creating event triggers for metadata changes.
--   
--   See <a>Cache</a> and <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.EventTrigger
fetchUndeliveredEvents :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> SourceName -> [TriggerName] -> MaintenanceMode () -> FetchBatchSize -> m [Event ('Postgres pgKind)]
setRetry :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> UTCTime -> MaintenanceMode MaintenanceModeVersion -> m ()
insertManualEvent :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> TableName ('Postgres pgKind) -> TriggerName -> Value -> UserInfo -> TraceContext -> m EventId
getMaintenanceModeVersion :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> m MaintenanceModeVersion
recordSuccess :: MonadIO m => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> Invocation 'EventType -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError :: MonadIO m => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> Invocation 'EventType -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError' :: MonadIO m => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> Maybe (Invocation 'EventType) -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
redeliverEvent :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> EventId -> m ()
dropTriggerAndArchiveEvents :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> TriggerName -> QualifiedTable -> m ()
createMissingSQLTriggers :: (MonadIO m, MonadError QErr m, MonadBaseControl IO m, HasServerConfigCtx m, Backend ('Postgres pgKind)) => PGSourceConfig -> TableName ('Postgres pgKind) -> ([ColumnInfo ('Postgres pgKind)], Maybe (PrimaryKey ('Postgres pgKind) (ColumnInfo ('Postgres pgKind)))) -> TriggerName -> TriggerOpsDef ('Postgres pgKind) -> m ()
createTableEventTrigger :: (Backend ('Postgres pgKind), MonadIO m, MonadBaseControl IO m) => ServerConfigCtx -> PGSourceConfig -> QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> TriggerName -> TriggerOpsDef ('Postgres pgKind) -> Maybe (PrimaryKey ('Postgres pgKind) (ColumnInfo ('Postgres pgKind))) -> m (Either QErr ())
dropDanglingSQLTrigger :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> TriggerName -> QualifiedTable -> HashSet Ops -> m ()
updateColumnInEventTrigger :: QualifiedTable -> PGCol -> PGCol -> QualifiedTable -> EventTriggerConf ('Postgres pgKind) -> EventTriggerConf ('Postgres pgKind)
unlockEventsInSource :: MonadIO m => SourceConfig ('Postgres pgKind) -> NESet EventId -> m (Either QErr Int)
checkIfTriggerExists :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> TriggerName -> HashSet Ops -> m Bool
insertInvocation :: Invocation 'EventType -> TxE QErr ()
insertPGManualEvent :: QualifiedTable -> TriggerName -> Value -> TxE QErr EventId
archiveEvents :: TriggerName -> TxE QErr ()
getMaintenanceModeVersionTx :: TxE QErr MaintenanceModeVersion

-- | Lock and return events not yet being processed or completed, up to
--   some limit. Process events approximately in created_at order, but we
--   make no ordering guarentees; events can and will race. Nevertheless we
--   want to ensure newer change events don't starve older ones.
fetchEvents :: SourceName -> [TriggerName] -> FetchBatchSize -> TxE QErr [Event ('Postgres pgKind)]
fetchEventsMaintenanceMode :: SourceName -> [TriggerName] -> FetchBatchSize -> MaintenanceModeVersion -> TxE QErr [Event ('Postgres pgKind)]
setSuccessTx :: Event ('Postgres pgKind) -> MaintenanceMode MaintenanceModeVersion -> TxE QErr ()
setErrorTx :: Event ('Postgres pgKind) -> MaintenanceMode MaintenanceModeVersion -> TxE QErr ()
setRetryTx :: Event ('Postgres pgKind) -> UTCTime -> MaintenanceMode MaintenanceModeVersion -> TxE QErr ()
dropTriggerQ :: TriggerName -> TxE QErr ()
dropTriggerOp :: TriggerName -> Ops -> TxE QErr ()
checkEvent :: EventId -> TxE QErr ()
markForDelivery :: EventId -> TxE QErr ()
redeliverEventTx :: EventId -> TxE QErr ()

-- | unlockEvents takes an array of <a>EventId</a> and unlocks them. This
--   function is called when a graceful shutdown is initiated.
unlockEventsTx :: [EventId] -> TxE QErr Int

-- | QualifiedTriggerName is a type to store the name of the SQL trigger.
--   An example of it is `"notify_hasura_users_all_INSERT"` where
--   <tt>users_all</tt> is the name of the event trigger.
newtype QualifiedTriggerName
QualifiedTriggerName :: Text -> QualifiedTriggerName
[unQualifiedTriggerName] :: QualifiedTriggerName -> Text
pgTriggerName :: Ops -> TriggerName -> QualifiedTriggerName
pgIdenTrigger :: Ops -> TriggerName -> QualifiedTriggerName

-- | pgIdenTrigger is a method used to construct the name of the pg
--   function used for event triggers which are present in the hdb_catalog
--   schema.
--   
--   Define the pgSQL trigger functions on database events.
mkTriggerFunctionQ :: forall pgKind m. (Backend ('Postgres pgKind), MonadTx m, MonadReader ServerConfigCtx m) => TriggerName -> QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> Ops -> SubscribeOpSpec ('Postgres pgKind) -> m QualifiedTriggerName
checkIfTriggerExistsForTableQ :: QualifiedTriggerName -> QualifiedTable -> TxE QErr Bool
checkIfFunctionExistsQ :: TriggerName -> Ops -> TxE QErr Bool
mkTrigger :: forall pgKind m. (Backend ('Postgres pgKind), MonadTx m, MonadReader ServerConfigCtx m) => TriggerName -> QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> Ops -> SubscribeOpSpec ('Postgres pgKind) -> m ()
mkAllTriggersQ :: forall pgKind m. (Backend ('Postgres pgKind), MonadTx m, MonadReader ServerConfigCtx m) => TriggerName -> QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> TriggerOpsDef ('Postgres pgKind) -> m ()
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.DDL.EventTrigger.QualifiedTriggerName
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.EventTrigger.QualifiedTriggerName
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.EventTrigger.QualifiedTriggerName

module Hasura.Backends.MySQL.Meta
getMetadata :: ConnSourceConfig -> Connection -> IO (DBTablesMetadata 'MySQL)
mkMetadata :: [InformationSchema] -> DBTablesMetadata 'MySQL
mergeMetadata :: InformationSchema -> DBTablesMetadata 'MySQL -> DBTablesMetadata 'MySQL
mergeDBTableMetadata :: DBTableMetadata 'MySQL -> DBTableMetadata 'MySQL -> DBTableMetadata 'MySQL
data InformationSchema
InformationSchema :: Text -> Text -> Text -> Word -> Maybe Text -> Text -> Maybe Text -> Text -> InformationSchemaColumnKey -> Text -> Maybe Text -> Maybe Word -> Maybe Word -> Maybe Text -> Maybe Text -> Maybe Text -> InformationSchema
[isTableSchema] :: InformationSchema -> Text
[isTableName] :: InformationSchema -> Text
[isColumnName] :: InformationSchema -> Text
[isOrdinalPosition] :: InformationSchema -> Word
[isColumnDefault] :: InformationSchema -> Maybe Text
[isIsNullable] :: InformationSchema -> Text
[isDataType] :: InformationSchema -> Maybe Text
[isColumnType] :: InformationSchema -> Text
[isColumnKey] :: InformationSchema -> InformationSchemaColumnKey
[isColumnComment] :: InformationSchema -> Text
[isConstraintName] :: InformationSchema -> Maybe Text
[isConstraintOrdinalPosition] :: InformationSchema -> Maybe Word
[isPositionInUniqueConstraint] :: InformationSchema -> Maybe Word
[isReferencedTableSchema] :: InformationSchema -> Maybe Text
[isReferencedTableName] :: InformationSchema -> Maybe Text
[isReferencedColumnName] :: InformationSchema -> Maybe Text
data InformationSchemaColumnKey
PRI :: InformationSchemaColumnKey
UNI :: InformationSchemaColumnKey
MUL :: InformationSchemaColumnKey

-- | This field isn't NULLable and uses empty strings, by the looks of it.
BLANK :: InformationSchemaColumnKey
instance GHC.Generics.Generic Hasura.Backends.MySQL.Meta.InformationSchemaColumnKey
instance GHC.Classes.Eq Hasura.Backends.MySQL.Meta.InformationSchemaColumnKey
instance GHC.Read.Read Hasura.Backends.MySQL.Meta.InformationSchemaColumnKey
instance GHC.Show.Show Hasura.Backends.MySQL.Meta.InformationSchemaColumnKey
instance GHC.Generics.Generic Hasura.Backends.MySQL.Meta.InformationSchema
instance GHC.Classes.Eq Hasura.Backends.MySQL.Meta.InformationSchema
instance GHC.Show.Show Hasura.Backends.MySQL.Meta.InformationSchema
instance Database.MySQL.Simple.QueryResults.QueryResults Hasura.Backends.MySQL.Meta.InformationSchema
instance Database.MySQL.Simple.Result.Result Hasura.Backends.MySQL.Meta.InformationSchemaColumnKey

module Hasura.Backends.MySQL.Connection
resolveSourceConfig :: MonadIO m => Logger Hasura -> SourceName -> ConnSourceConfig -> BackendSourceKind 'MySQL -> BackendConfig 'MySQL -> environment -> manager -> m (Either QErr SourceConfig)
resolveDatabaseMetadata :: MonadIO m => SourceConfig -> SourceTypeCustomization -> m (Either QErr (ResolvedSource 'MySQL))
postDropSourceHook :: MonadIO m => SourceConfig -> TableEventTriggers 'MySQL -> m ()
parseFieldResult :: Field -> Maybe ByteString -> Value
fieldsToAeson :: [Field] -> [[Maybe ByteString]] -> [Value]
runJSONPathQuery :: (MonadError QErr m, MonadIO m) => Pool Connection -> Query -> m Text

-- | Used by the dataloader to produce rows of records. Those rows of
--   records are then manipulated by the dataloader to do Haskell-side
--   joins. Is a Vector of HashMaps the most efficient choice? A
--   pandas-style data frame could also be more efficient, dependingly.
--   However, this is a legible approach; efficiency improvements can be
--   added later.
parseAndCollectRows :: [Field] -> [[Maybe ByteString]] -> Vector (InsOrdHashMap FieldName Value)

-- | Run a query immediately and parse up the results into a vector.
runQueryYieldingRows :: MonadIO m => Pool Connection -> Query -> m (Vector (InsOrdHashMap FieldName Value))
fetchAllRows :: Result -> IO [[Maybe ByteString]]
parseTextRows :: [Field] -> [[Maybe ByteString]] -> [[Text]]
withMySQLPool :: MonadIO m => Pool Connection -> (Connection -> IO a) -> m a


-- | Execute the plan given from .Plan.
module Hasura.Backends.MySQL.DataLoader.Execute

-- | A set of records produced by the database. These are joined together.
--   There are all sorts of optimizations possible here, from using a
--   matrix/flat vector, unboxed sums for Value, etc. Presently we choose a
--   naive implementation in the interest of getting other work done.
data RecordSet
RecordSet :: Maybe PlannedAction -> Vector (InsOrdHashMap FieldName OutputValue) -> Maybe [Text] -> RecordSet
[origin] :: RecordSet -> Maybe PlannedAction
[rows] :: RecordSet -> Vector (InsOrdHashMap FieldName OutputValue)
[wantedFields] :: RecordSet -> Maybe [Text]

-- | The read-only info. used by the Execute monad. Later, this IORef may
--   become either atomically modified or in an STM or MVar so that jobs
--   can be executed in parallel.
data ExecuteReader
ExecuteReader :: IORef (InsOrdHashMap Ref RecordSet) -> SourceConfig -> ExecuteReader
[recordSets] :: ExecuteReader -> IORef (InsOrdHashMap Ref RecordSet)
[credentials] :: ExecuteReader -> SourceConfig

-- | Any problem encountered while executing the plan.
data ExecuteProblem
GetJobDecodeProblem :: String -> ExecuteProblem
CreateQueryJobDecodeProblem :: String -> ExecuteProblem
JoinProblem :: ExecuteProblem -> ExecuteProblem
UnsupportedJoinBug :: JoinType -> ExecuteProblem
MissingRecordSetBug :: Ref -> ExecuteProblem
BrokenJoinInvariant :: [FieldName] -> ExecuteProblem

-- | Execute monad; as queries are performed, the record sets are stored in
--   the map.
newtype Execute a
Execute :: ReaderT ExecuteReader (ExceptT ExecuteProblem IO) a -> Execute a
[unExecute] :: Execute a -> ReaderT ExecuteReader (ExceptT ExecuteProblem IO) a

-- | A value outputted by this execute module in a record set.
data OutputValue
ArrayOutputValue :: Vector OutputValue -> OutputValue
RecordOutputValue :: InsOrdHashMap FieldName OutputValue -> OutputValue
ScalarOutputValue :: Value -> OutputValue
NullOutputValue :: OutputValue

-- | Using the config, run the execute action. Finally, resolve the
--   head-and-tail to a record set.
runExecute :: MonadIO m => SourceConfig -> HeadAndTail -> Execute a -> m (Either ExecuteProblem RecordSet)

-- | Execute the forest of actions.
execute :: Forest PlannedAction -> Execute ()

-- | Execute an action, then store its result in the ref assigned to it.
executePlannedAction :: PlannedAction -> Execute ()

-- | Fetch the record set for the given action.
fetchRecordSetForAction :: Action -> Execute RecordSet

-- | Make a record set from a flat record from the DB.
makeRecordSet :: Vector (InsOrdHashMap FieldName Value) -> RecordSet
saveRecordSet :: Ref -> RecordSet -> Execute ()
getRecordSet :: Ref -> Execute RecordSet

-- | See documentation for <a>HeadAndTail</a>.
getFinalRecordSet :: HeadAndTail -> Execute RecordSet

-- | Inefficient but clean left object join.
leftObjectJoin :: Maybe [Text] -> Text -> [(FieldName, FieldName)] -> RecordSet -> RecordSet -> Either ExecuteProblem RecordSet

-- | A naive, exponential reference implementation of a left join. It
--   serves as a trivial sample implementation for correctness checking of
--   more efficient ones.
leftArrayJoin :: Maybe [Text] -> Text -> [(FieldName, FieldName)] -> Top -> Maybe Int -> RecordSet -> RecordSet -> Either ExecuteProblem RecordSet

-- | Join a row with another as an array join.
joinArrayRows :: Maybe [Text] -> Text -> InsOrdHashMap FieldName OutputValue -> Vector (InsOrdHashMap FieldName OutputValue) -> InsOrdHashMap FieldName OutputValue

-- | Join a row with another as an object join.
--   
--   If rightRow is not a single row, we throw <a>BrokenJoinInvariant</a>.
joinObjectRows :: Maybe [Text] -> Text -> InsOrdHashMap FieldName OutputValue -> Vector (InsOrdHashMap FieldName OutputValue) -> Either ExecuteProblem (InsOrdHashMap FieldName OutputValue)
instance GHC.Show.Show Hasura.Backends.MySQL.DataLoader.Execute.ExecuteProblem
instance GHC.Generics.Generic Hasura.Backends.MySQL.DataLoader.Execute.OutputValue
instance GHC.Classes.Eq Hasura.Backends.MySQL.DataLoader.Execute.OutputValue
instance GHC.Show.Show Hasura.Backends.MySQL.DataLoader.Execute.OutputValue
instance GHC.Show.Show Hasura.Backends.MySQL.DataLoader.Execute.RecordSet
instance Control.Monad.Error.Class.MonadError Hasura.Backends.MySQL.DataLoader.Execute.ExecuteProblem Hasura.Backends.MySQL.DataLoader.Execute.Execute
instance Control.Monad.IO.Class.MonadIO Hasura.Backends.MySQL.DataLoader.Execute.Execute
instance Control.Monad.Reader.Class.MonadReader Hasura.Backends.MySQL.DataLoader.Execute.ExecuteReader Hasura.Backends.MySQL.DataLoader.Execute.Execute
instance GHC.Base.Monad Hasura.Backends.MySQL.DataLoader.Execute.Execute
instance GHC.Base.Applicative Hasura.Backends.MySQL.DataLoader.Execute.Execute
instance GHC.Base.Functor Hasura.Backends.MySQL.DataLoader.Execute.Execute
instance (TypeError ...) => Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.DataLoader.Execute.RecordSet
instance Data.Hashable.Class.Hashable Hasura.Backends.MySQL.DataLoader.Execute.OutputValue


-- | Metadata related types, functions and helpers.
--   
--   Provides a single function which loads the MSSQL database metadata.
--   See the file at src-rsr<i>mssql</i>mssql_table_metadata.sql for the
--   SQL we use to build this metadata. See <a>DBTableMetadata</a> for the
--   Haskell type we use forall storing this metadata.
module Hasura.Backends.MSSQL.Meta
loadDBMetadata :: MonadIO m => TxET QErr m (DBTablesMetadata 'MSSQL)
data SysTable
SysTable :: Text -> Int -> [SysColumn] -> SysSchema -> Maybe SysPrimaryKey -> SysTable
[staName] :: SysTable -> Text
[staObjectId] :: SysTable -> Int
[staJoinedSysColumn] :: SysTable -> [SysColumn]
[staJoinedSysSchema] :: SysTable -> SysSchema
[staJoinedSysPrimaryKey] :: SysTable -> Maybe SysPrimaryKey
newtype SysPrimaryKeyColumn
SysPrimaryKeyColumn :: Text -> SysPrimaryKeyColumn
[spkcName] :: SysPrimaryKeyColumn -> Text
data SysPrimaryKey
SysPrimaryKey :: Text -> Int -> NESeq SysPrimaryKeyColumn -> SysPrimaryKey
[spkName] :: SysPrimaryKey -> Text
[spkIndexId] :: SysPrimaryKey -> Int
[spkColumns] :: SysPrimaryKey -> NESeq SysPrimaryKeyColumn
data SysSchema
SysSchema :: Text -> Int -> SysSchema
[ssName] :: SysSchema -> Text
[ssSchemaId] :: SysSchema -> Int
data SysColumn
SysColumn :: Text -> Int -> Int -> Bool -> Bool -> Bool -> SysType -> [SysForeignKeyColumn] -> SysColumn
[scName] :: SysColumn -> Text
[scColumnId] :: SysColumn -> Int
[scUserTypeId] :: SysColumn -> Int
[scIsNullable] :: SysColumn -> Bool
[scIsIdentity] :: SysColumn -> Bool
[scIsComputed] :: SysColumn -> Bool
[scJoinedSysType] :: SysColumn -> SysType
[scJoinedForeignKeyColumns] :: SysColumn -> [SysForeignKeyColumn]
data SysType
SysType :: Text -> Int -> Int -> SysType
[styName] :: SysType -> Text
[stySchemaId] :: SysType -> Int
[styUserTypeId] :: SysType -> Int
data SysForeignKeyColumn
SysForeignKeyColumn :: Int -> Int -> Int -> Int -> Int -> Int -> Text -> Text -> SysSchema -> SysForeignKeyColumn
[sfkcConstraintObjectId] :: SysForeignKeyColumn -> Int
[sfkcConstraintColumnId] :: SysForeignKeyColumn -> Int
[sfkcParentObjectId] :: SysForeignKeyColumn -> Int
[sfkcParentColumnId] :: SysForeignKeyColumn -> Int
[sfkcReferencedObjectId] :: SysForeignKeyColumn -> Int
[sfkcReferencedColumnId] :: SysForeignKeyColumn -> Int
[sfkcJoinedReferencedTableName] :: SysForeignKeyColumn -> Text
[sfkcJoinedReferencedColumnName] :: SysForeignKeyColumn -> Text
[sfkcJoinedReferencedSysSchema] :: SysForeignKeyColumn -> SysSchema
transformTable :: SysTable -> (TableName, DBTableMetadata 'MSSQL)
transformColumn :: SysColumn -> (RawColumnInfo 'MSSQL, [ForeignKey 'MSSQL])
transformPrimaryKey :: SysPrimaryKey -> PrimaryKey 'MSSQL (Column 'MSSQL)
coalesceKeys :: [ForeignKey 'MSSQL] -> [ForeignKey 'MSSQL]
parseScalarType :: Text -> ScalarType
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysPrimaryKeyColumn
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysPrimaryKeyColumn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysPrimaryKey
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysPrimaryKey
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysSchema
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysSchema
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysType
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysType
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysForeignKeyColumn
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysForeignKeyColumn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysColumn
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysColumn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysTable
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysTable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysTable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysColumn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysForeignKeyColumn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysSchema
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysPrimaryKey
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysPrimaryKeyColumn

module Hasura.Backends.MSSQL.DDL.EventTrigger
fetchUndeliveredEvents :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> SourceName -> [TriggerName] -> MaintenanceMode () -> FetchBatchSize -> m [Event 'MSSQL]
setRetry :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> Event 'MSSQL -> UTCTime -> MaintenanceMode MaintenanceModeVersion -> m ()
insertManualEvent :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TableName -> TriggerName -> Value -> UserInfo -> TraceContext -> m EventId
getMaintenanceModeVersion :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> m MaintenanceModeVersion
recordSuccess :: MonadIO m => MSSQLSourceConfig -> Event 'MSSQL -> Invocation 'EventType -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError :: MonadIO m => MSSQLSourceConfig -> Event 'MSSQL -> Invocation 'EventType -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError' :: MonadIO m => MSSQLSourceConfig -> Event 'MSSQL -> Maybe (Invocation 'EventType) -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
redeliverEvent :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> EventId -> m ()
dropTriggerAndArchiveEvents :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerName -> TableName -> m ()
dropDanglingSQLTrigger :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerName -> TableName -> HashSet Ops -> m ()
createTableEventTrigger :: MonadIO m => ServerConfigCtx -> MSSQLSourceConfig -> TableName -> [ColumnInfo 'MSSQL] -> TriggerName -> TriggerOpsDef 'MSSQL -> Maybe (PrimaryKey 'MSSQL (ColumnInfo 'MSSQL)) -> m (Either QErr ())
createMissingSQLTriggers :: (MonadIO m, MonadError QErr m, MonadBaseControl IO m) => MSSQLSourceConfig -> TableName -> ([ColumnInfo 'MSSQL], Maybe (PrimaryKey 'MSSQL (ColumnInfo 'MSSQL))) -> TriggerName -> TriggerOpsDef 'MSSQL -> m ()
unlockEventsInSource :: MonadIO m => MSSQLSourceConfig -> NESet EventId -> m (Either QErr Int)
checkIfTriggerExists :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerName -> HashSet Ops -> m Bool
insertInvocation :: Invocation 'EventType -> TxE QErr ()
insertMSSQLManualEventTx :: TableName -> TriggerName -> Value -> TxE QErr EventId
setSuccessTx :: Event 'MSSQL -> MaintenanceMode MaintenanceModeVersion -> TxE QErr ()
setErrorTx :: Event 'MSSQL -> MaintenanceMode MaintenanceModeVersion -> TxE QErr ()
setRetryTx :: Event 'MSSQL -> UTCTime -> MaintenanceMode MaintenanceModeVersion -> TxE QErr ()

-- | Lock and return events not yet being processed or completed, up to
--   some limit. Process events approximately in created_at order, but we
--   make no ordering guarentees; events can and will race. Nevertheless we
--   want to ensure newer change events don't starve older ones.
fetchEvents :: SourceName -> [TriggerName] -> FetchBatchSize -> TxE QErr [Event 'MSSQL]
dropTriggerQ :: TriggerName -> SchemaName -> TxE QErr ()
dropTriggerOp :: TriggerName -> SchemaName -> Ops -> TxE QErr ()
archiveEvents :: TriggerName -> TxE QErr ()
checkEventTx :: EventId -> TxE QErr ()
markForDeliveryTx :: EventId -> TxE QErr ()
unlockEventsTx :: [EventId] -> TxE QErr Int
getMaintenanceModeVersionTx :: TxE QErr MaintenanceModeVersion

-- | Note: UTCTIME not supported in SQL Server
--   
--   Refer 'ToSql UTCTIME' instance of odbc package:
--   <a>https://github.com/fpco/odbc/blob/f4f04ea15d14e9a3ed455f7c728dc08734eef8ae/src/Database/ODBC/SQLServer.hs#L377</a>
--   
--   We use SYSDATETIMEOFFSET() to store time values along with it's time
--   zone offset in event_log table. Since ODBC server does not support
--   time zones, we use a workaround.
--   
--   We wrap the time value in Datetime2, but before we insert it into the
--   event_log table we convert it into UTCTIME using the
--   'TODATETIMEOFFSET()' sql function.
convertUTCToDatetime2 :: MonadIO m => UTCTime -> m Datetime2
checkIfTriggerExistsQ :: TriggerName -> Ops -> TxE QErr Bool
newtype QualifiedTriggerName
QualifiedTriggerName :: Text -> QualifiedTriggerName
[unQualifiedTriggerName] :: QualifiedTriggerName -> Text

-- | Store a fragment of SQL expression
newtype SQLFragment
SQLFragment :: Text -> SQLFragment
[unSQLFragment] :: SQLFragment -> Text
msssqlIdenTrigger :: Ops -> SchemaName -> TriggerName -> QualifiedTriggerName
mkAllTriggersQ :: MonadMSSQLTx m => TriggerName -> TableName -> [ColumnInfo 'MSSQL] -> TriggerOpsDef 'MSSQL -> Maybe (PrimaryKey 'MSSQL (ColumnInfo 'MSSQL)) -> m ()
getApplicableColumns :: [ColumnInfo 'MSSQL] -> SubscribeColumns 'MSSQL -> [ColumnInfo 'MSSQL]

-- | Currently we do not support Event Triggers on columns of Spatial data
--   types. We do this because, currently the graphQL API for these types
--   is broken for MSSQL sources. Ref:
--   <a>https://github.com/hasura/graphql-engine-mono/issues/787</a>
checkSpatialDataTypeColumns :: MonadMSSQLTx m => [ColumnInfo 'MSSQL] -> SubscribeOpSpec 'MSSQL -> m ()
mkInsertTriggerQ :: MonadMSSQLTx m => TriggerName -> TableName -> [ColumnInfo 'MSSQL] -> SubscribeOpSpec 'MSSQL -> m ()
mkDeleteTriggerQ :: MonadMSSQLTx m => TriggerName -> TableName -> [ColumnInfo 'MSSQL] -> SubscribeOpSpec 'MSSQL -> m ()
mkUpdateTriggerQ :: MonadMSSQLTx m => TriggerName -> TableName -> [ColumnInfo 'MSSQL] -> Maybe (PrimaryKey 'MSSQL (ColumnInfo 'MSSQL)) -> SubscribeOpSpec 'MSSQL -> m ()
generateColumnTriggerAlias :: OpVar -> Maybe Text -> ColumnInfo 'MSSQL -> SQLFragment
qualifyTableName :: TableName -> Text
mkInsertTriggerQuery :: TableName -> TriggerName -> [ColumnInfo 'MSSQL] -> Text
mkDeleteTriggerQuery :: TableName -> TriggerName -> [ColumnInfo 'MSSQL] -> Text
mkPrimaryKeyJoinExp :: Text -> Text -> [ColumnInfo 'MSSQL] -> SQLFragment
mkListenColumnsExp :: Text -> Text -> [ColumnInfo 'MSSQL] -> SQLFragment

-- | Check if primary key is present in listen columns We use this in
--   update event trigger, to check if the primary key has been updated and
--   construct the payload accordingly.
isPrimaryKeyInListenColumns :: [ColumnInfo 'MSSQL] -> PrimaryKey 'MSSQL (ColumnInfo 'MSSQL) -> SQLFragment
mkUpdateTriggerQuery :: TableName -> TriggerName -> [ColumnInfo 'MSSQL] -> [ColumnInfo 'MSSQL] -> PrimaryKey 'MSSQL (ColumnInfo 'MSSQL) -> Text

module Hasura.RQL.Types.Eventing.Backend

-- | The <tt>BackendEventTrigger</tt> type class contains functions which
--   interacts with the source database to perform event trigger related
--   operations like fetching pending events from the database or inserting
--   a new invocation log after processing an event.
class Backend b => BackendEventTrigger (b :: BackendType)

-- | insertManualEvent inserts the specified event in the event log table,
--   note that this method should also set the trace context and session
--   variables in the source database context (if available).
insertManualEvent :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TableName b -> TriggerName -> Value -> UserInfo -> TraceContext -> m EventId

-- | <tt>fetchUndeliveredEvents</tt> fetches the undelivered events from
--   the source and locks those events for processing. The locking is done
--   so that when there are multiple instances of graphql-engine connected
--   to the same source they don't end up processing the same events
--   concurrently.
--   
--   Also, it's crucial that the SQL query used to fetch events in this
--   function uses something like Postgres's `FOR UPDATE SKIP LOCKED`
--   mechanism so that it skips past the events which are locked by the
--   database and pick newer undelivered events to achieve maximum
--   throughput.
--   
--   The locking mechanism for event triggers is timestamp based i.e. when
--   an event is fetched from the database, the <tt>locked</tt> column will
--   contain the timestamp of when it was fetched from the database.
--   Undelivered events will have <tt>NULL</tt> value as their
--   <tt>locked</tt> column value.
--   
--   The idea behind having a timestamp based locking mechanism is that if
--   the graphql-engine is shutdown abruptly with events being fetched by
--   the events processor, it will be locked and after the shutdown it will
--   remain locked. Now with a timestamp based lock, when the
--   graphql-engine is started again it will also fetch events which have a
--   <tt>locked</tt> value of older than 30 mins along with the undelivered
--   events. So, this way no events remain in a <tt>locked</tt> state.
--   
--   When fetching the events from the event_log table we also include the
--   list of the triggers that exist in the metadata at that point of time,
--   because we have seen in some cases there are events that do not belong
--   to any of the event triggers present in the metadata and those are
--   fetched only to be failed saying the said event trigger doesn't exist.
--   So, to avoid this (atleast, as much as possible) we get only the
--   events of the event triggers we have in the metadata.
fetchUndeliveredEvents :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> SourceName -> [TriggerName] -> MaintenanceMode () -> FetchBatchSize -> m [Event b]

-- | Ad-hoc function to set a retry for an undelivered event
setRetry :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> Event b -> UTCTime -> MaintenanceMode MaintenanceModeVersion -> m ()

-- | <tt>getMaintenanceModeVersion</tt> gets the source catalog version
--   from the source
getMaintenanceModeVersion :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> m MaintenanceModeVersion

-- | <tt>recordSuccess</tt> records a successful event invocation, it does
--   a couple of things,
--   
--   <ol>
--   <li>Insert the invocation in the invocation logs table</li>
--   <li>Mark the event as <tt>delivered</tt> in the event_log table</li>
--   </ol>
recordSuccess :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> Event b -> Invocation 'EventType -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())

-- | <tt>recordError</tt> records an erronous event invocation, it does a
--   couple of things,
--   
--   <ol>
--   <li>Insert the invocation in the invocation logs table</li>
--   <li>Depending on the value of <a>ProcessEventError</a>, it will
--   either, - Set a retry for the given event - Mark the event as
--   <a>error</a></li>
--   </ol>
recordError :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> Event b -> Invocation 'EventType -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())

-- | <tt>recordError'</tt> records an erronous event invocation, it does a
--   couple of things,
--   
--   <ol>
--   <li>If present, insert the invocation in the invocation logs
--   table</li>
--   <li>Depending on the value of <a>ProcessEventError</a>, it will
--   either, - Set a retry for the given event - Mark the event as
--   <a>error</a></li>
--   </ol>
recordError' :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> Event b -> Maybe (Invocation 'EventType) -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())

-- | <tt>dropTriggerAndArchiveEvents</tt> drops the database trigger and
--   marks all the events related to the event trigger as archived. See
--   Note [Cleanup for dropped triggers]
dropTriggerAndArchiveEvents :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerName -> TableName b -> m ()

-- | <tt>dropDanglingSQLTriggger</tt> is used to delete the extraneous SQL
--   triggers created by an event trigger. The extraneous SQL triggers can
--   be created when an event trigger's definition is replaced to a new
--   definition. For example, an event trigger <tt>authors_all</tt> had an
--   INSERT and UPDATE trigger defined earlier and after it has UPDATE and
--   DELETE triggers. So, in this case, we need to drop the trigger created
--   by us earlier for the INSERT trigger.
dropDanglingSQLTrigger :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerName -> TableName b -> HashSet Ops -> m ()
redeliverEvent :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> EventId -> m ()

-- | <tt>unlockEventsInSource</tt> unlocks the cached locked events which
--   were captured when a graceful shutdown is initiated, so that when the
--   graphql-engine restarts these events can be fetched to process them
--   immediately.
unlockEventsInSource :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> NESet EventId -> m (Either QErr Int)

-- | <tt>createMissingSQLTriggers</tt> checks in the source whether all the
--   triggers exist according to the event trigger's specification. If any
--   SQL trigger doesn't exist then it will create it.
createMissingSQLTriggers :: (BackendEventTrigger b, MonadIO m, MonadError QErr m, MonadBaseControl IO m, Backend b, HasServerConfigCtx m) => SourceConfig b -> TableName b -> ([ColumnInfo b], Maybe (PrimaryKey b (ColumnInfo b))) -> TriggerName -> TriggerOpsDef b -> m ()
createTableEventTrigger :: (BackendEventTrigger b, MonadBaseControl IO m, MonadIO m, MonadError QErr m) => ServerConfigCtx -> SourceConfig b -> TableName b -> [ColumnInfo b] -> TriggerName -> TriggerOpsDef b -> Maybe (PrimaryKey b (ColumnInfo b)) -> m (Either QErr ())
checkIfTriggerExists :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerName -> HashSet Ops -> m Bool
instance Hasura.RQL.Types.Eventing.Backend.BackendEventTrigger ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Vanilla)
instance Hasura.RQL.Types.Eventing.Backend.BackendEventTrigger ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Citus)
instance Hasura.RQL.Types.Eventing.Backend.BackendEventTrigger ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Cockroach)
instance Hasura.RQL.Types.Eventing.Backend.BackendEventTrigger 'Hasura.SQL.Backend.MSSQL
instance Hasura.RQL.Types.Eventing.Backend.BackendEventTrigger 'Hasura.SQL.Backend.BigQuery
instance Hasura.RQL.Types.Eventing.Backend.BackendEventTrigger 'Hasura.SQL.Backend.MySQL
instance Hasura.RQL.Types.Eventing.Backend.BackendEventTrigger 'Hasura.SQL.Backend.DataConnector


-- | MSSQL Source
--   
--   Implements the Source related methods of the <a>BackendMetadata</a>
--   type class for the MSSQL backend, which provides an interface for
--   identifying the MSSQL database instance (source) and manipulate it.
--   
--   The actual instance is defined in
--   <a>Hasura.Backends.MSSQL.Instances.Metadata</a>.
module Hasura.Backends.MSSQL.DDL.Source
resolveSourceConfig :: (MonadIO m, MonadResolveSource m) => Logger Hasura -> SourceName -> MSSQLConnConfiguration -> BackendSourceKind 'MSSQL -> BackendConfig 'MSSQL -> Environment -> manager -> m (Either QErr MSSQLSourceConfig)
resolveDatabaseMetadata :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> SourceTypeCustomization -> m (Either QErr (ResolvedSource 'MSSQL))
postDropSourceHook :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> TableEventTriggers 'MSSQL -> m ()
doesSchemaExist :: MonadMSSQLTx m => SchemaName -> m Bool
doesTableExist :: MonadMSSQLTx m => TableName -> m Bool

-- | Initialise catalog tables for a source, including those required by
--   the event delivery subsystem.
prepareCatalog :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> ExceptT QErr m RecreateEventTriggers
dropSourceCatalog :: MonadMSSQLTx m => m ()
migrateSourceCatalog :: MonadMSSQLTx m => m RecreateEventTriggers
migrateSourceCatalogFrom :: MonadMSSQLTx m => SourceCatalogVersion -> m RecreateEventTriggers
sourceMigrations :: [(SourceCatalogVersion, TxE QErr [Text])]


-- | In order to avoid circular dependencies while splitting
--   <a>Metadata</a> into multiple modules, some definitions must be moved
--   out of that module. This module is the bucket for definitions that
--   have not been specifically moved elsewhere.
module Hasura.RQL.Types.Metadata.Common

-- | Parse a list of objects into a map from a derived key, failing if the
--   list has duplicates.
parseListAsMap :: (Hashable k, Eq k, ToTxt k) => Text -> (a -> k) -> Parser [a] -> Parser (InsOrdHashMap k a)
data ComputedFieldMetadata b
ComputedFieldMetadata :: ComputedFieldName -> ComputedFieldDefinition b -> Comment -> ComputedFieldMetadata b
[_cfmName] :: ComputedFieldMetadata b -> ComputedFieldName
[_cfmDefinition] :: ComputedFieldMetadata b -> ComputedFieldDefinition b
[_cfmComment] :: ComputedFieldMetadata b -> Comment
data RemoteSchemaPermissionMetadata
RemoteSchemaPermissionMetadata :: RoleName -> RemoteSchemaPermissionDefinition -> Maybe Text -> RemoteSchemaPermissionMetadata
[_rspmRole] :: RemoteSchemaPermissionMetadata -> RoleName
[_rspmDefinition] :: RemoteSchemaPermissionMetadata -> RemoteSchemaPermissionDefinition
[_rspmComment] :: RemoteSchemaPermissionMetadata -> Maybe Text
rspmRole :: Lens' RemoteSchemaPermissionMetadata RoleName
rspmDefinition :: Lens' RemoteSchemaPermissionMetadata RemoteSchemaPermissionDefinition
rspmComment :: Lens' RemoteSchemaPermissionMetadata (Maybe Text)
type Relationships a = InsOrdHashMap RelName a
type ComputedFields b = InsOrdHashMap ComputedFieldName (ComputedFieldMetadata b)
type RemoteRelationships = InsOrdHashMap RelName RemoteRelationship
type SchemaRemoteRelationships = InsOrdHashMap Name RemoteSchemaTypeRelationships
type Permissions a = InsOrdHashMap RoleName a
type EventTriggers b = InsOrdHashMap TriggerName (EventTriggerConf b)
data RemoteSchemaTypeRelationships
RemoteSchemaTypeRelationships :: Name -> RemoteRelationships -> RemoteSchemaTypeRelationships
[_rstrsName] :: RemoteSchemaTypeRelationships -> Name
[_rstrsRelationships] :: RemoteSchemaTypeRelationships -> RemoteRelationships
data RemoteSchemaMetadata
RemoteSchemaMetadata :: RemoteSchemaName -> RemoteSchemaDef -> Maybe Text -> [RemoteSchemaPermissionMetadata] -> SchemaRemoteRelationships -> RemoteSchemaMetadata
[_rsmName] :: RemoteSchemaMetadata -> RemoteSchemaName
[_rsmDefinition] :: RemoteSchemaMetadata -> RemoteSchemaDef
[_rsmComment] :: RemoteSchemaMetadata -> Maybe Text
[_rsmPermissions] :: RemoteSchemaMetadata -> [RemoteSchemaPermissionMetadata]
[_rsmRemoteRelationships] :: RemoteSchemaMetadata -> SchemaRemoteRelationships
rstrsRelationships :: Lens' RemoteSchemaTypeRelationships RemoteRelationships
rstrsName :: Lens' RemoteSchemaTypeRelationships Name
rsmRemoteRelationships :: Lens' RemoteSchemaMetadata SchemaRemoteRelationships
rsmPermissions :: Lens' RemoteSchemaMetadata [RemoteSchemaPermissionMetadata]
rsmName :: Lens' RemoteSchemaMetadata RemoteSchemaName
rsmDefinition :: Lens' RemoteSchemaMetadata RemoteSchemaDef
rsmComment :: Lens' RemoteSchemaMetadata (Maybe Text)
data TableMetadata b
TableMetadata :: TableName b -> Bool -> TableConfig b -> Relationships (ObjRelDef b) -> Relationships (ArrRelDef b) -> ComputedFields b -> RemoteRelationships -> Permissions (InsPermDef b) -> Permissions (SelPermDef b) -> Permissions (UpdPermDef b) -> Permissions (DelPermDef b) -> EventTriggers b -> Maybe ApolloFederationConfig -> TableMetadata b
[_tmTable] :: TableMetadata b -> TableName b
[_tmIsEnum] :: TableMetadata b -> Bool
[_tmConfiguration] :: TableMetadata b -> TableConfig b
[_tmObjectRelationships] :: TableMetadata b -> Relationships (ObjRelDef b)
[_tmArrayRelationships] :: TableMetadata b -> Relationships (ArrRelDef b)
[_tmComputedFields] :: TableMetadata b -> ComputedFields b
[_tmRemoteRelationships] :: TableMetadata b -> RemoteRelationships
[_tmInsertPermissions] :: TableMetadata b -> Permissions (InsPermDef b)
[_tmSelectPermissions] :: TableMetadata b -> Permissions (SelPermDef b)
[_tmUpdatePermissions] :: TableMetadata b -> Permissions (UpdPermDef b)
[_tmDeletePermissions] :: TableMetadata b -> Permissions (DelPermDef b)
[_tmEventTriggers] :: TableMetadata b -> EventTriggers b
[_tmApolloFederationConfig] :: TableMetadata b -> Maybe ApolloFederationConfig
tmUpdatePermissions :: forall b_anz55. Lens' (TableMetadata b_anz55) (Permissions (UpdPermDef b_anz55))
tmTable :: forall b_anz55. Lens' (TableMetadata b_anz55) (TableName b_anz55)
tmSelectPermissions :: forall b_anz55. Lens' (TableMetadata b_anz55) (Permissions (SelPermDef b_anz55))
tmRemoteRelationships :: forall b_anz55. Lens' (TableMetadata b_anz55) RemoteRelationships
tmObjectRelationships :: forall b_anz55. Lens' (TableMetadata b_anz55) (Relationships (ObjRelDef b_anz55))
tmIsEnum :: forall b_anz55. Lens' (TableMetadata b_anz55) Bool
tmInsertPermissions :: forall b_anz55. Lens' (TableMetadata b_anz55) (Permissions (InsPermDef b_anz55))
tmEventTriggers :: forall b_anz55. Lens' (TableMetadata b_anz55) (EventTriggers b_anz55)
tmDeletePermissions :: forall b_anz55. Lens' (TableMetadata b_anz55) (Permissions (DelPermDef b_anz55))
tmConfiguration :: forall b_anz55. Lens' (TableMetadata b_anz55) (TableConfig b_anz55)
tmComputedFields :: forall b_anz55. Lens' (TableMetadata b_anz55) (ComputedFields b_anz55)
tmArrayRelationships :: forall b_anz55. Lens' (TableMetadata b_anz55) (Relationships (ArrRelDef b_anz55))
tmApolloFederationConfig :: forall b_anz55. Lens' (TableMetadata b_anz55) (Maybe ApolloFederationConfig)
mkTableMeta :: TableName b -> Bool -> TableConfig b -> TableMetadata b
data FunctionMetadata b
FunctionMetadata :: FunctionName b -> FunctionConfig -> [FunctionPermissionInfo] -> Maybe Text -> FunctionMetadata b
[_fmFunction] :: FunctionMetadata b -> FunctionName b
[_fmConfiguration] :: FunctionMetadata b -> FunctionConfig
[_fmPermissions] :: FunctionMetadata b -> [FunctionPermissionInfo]
[_fmComment] :: FunctionMetadata b -> Maybe Text
fmPermissions :: forall b_anzPr. Lens' (FunctionMetadata b_anzPr) [FunctionPermissionInfo]
fmFunction :: forall b_anzPr b_anAIB. Lens (FunctionMetadata b_anzPr) (FunctionMetadata b_anAIB) (FunctionName b_anzPr) (FunctionName b_anAIB)
fmConfiguration :: forall b_anzPr. Lens' (FunctionMetadata b_anzPr) FunctionConfig
fmComment :: forall b_anzPr. Lens' (FunctionMetadata b_anzPr) (Maybe Text)
type Tables b = InsOrdHashMap (TableName b) (TableMetadata b)
type Functions b = InsOrdHashMap (FunctionName b) (FunctionMetadata b)
type RemoteSchemas = InsOrdHashMap RemoteSchemaName RemoteSchemaMetadata
type Endpoints = InsOrdHashMap EndpointName CreateEndpoint
type Actions = InsOrdHashMap ActionName ActionMetadata
type CronTriggers = InsOrdHashMap TriggerName CronTriggerMetadata
type InheritedRoles = InsOrdHashMap RoleName InheritedRole
data SourceMetadata b
SourceMetadata :: SourceName -> BackendSourceKind b -> Tables b -> Functions b -> SourceConnConfiguration b -> Maybe QueryTagsConfig -> SourceCustomization -> SourceMetadata b
[_smName] :: SourceMetadata b -> SourceName
[_smKind] :: SourceMetadata b -> BackendSourceKind b
[_smTables] :: SourceMetadata b -> Tables b
[_smFunctions] :: SourceMetadata b -> Functions b
[_smConfiguration] :: SourceMetadata b -> SourceConnConfiguration b
[_smQueryTags] :: SourceMetadata b -> Maybe QueryTagsConfig
[_smCustomization] :: SourceMetadata b -> SourceCustomization
smTables :: forall b_anAJk. Lens' (SourceMetadata b_anAJk) (Tables b_anAJk)
smQueryTags :: forall b_anAJk. Lens' (SourceMetadata b_anAJk) (Maybe QueryTagsConfig)
smName :: forall b_anAJk. Lens' (SourceMetadata b_anAJk) SourceName
smKind :: forall b_anAJk. Lens' (SourceMetadata b_anAJk) (BackendSourceKind b_anAJk)
smFunctions :: forall b_anAJk. Lens' (SourceMetadata b_anAJk) (Functions b_anAJk)
smCustomization :: forall b_anAJk. Lens' (SourceMetadata b_anAJk) SourceCustomization
smConfiguration :: forall b_anAJk. Lens' (SourceMetadata b_anAJk) (SourceConnConfiguration b_anAJk)
mkSourceMetadata :: forall (b :: BackendType). Backend b => SourceName -> BackendSourceKind b -> SourceConnConfiguration b -> SourceCustomization -> BackendSourceMetadata
type BackendSourceMetadata = AnyBackend SourceMetadata
toSourceMetadata :: forall b. Backend b => Prism' BackendSourceMetadata (SourceMetadata b)
getSourceName :: BackendSourceMetadata -> SourceName
type Sources = InsOrdHashMap SourceName BackendSourceMetadata
parseNonSourcesMetadata :: Object -> Parser (RemoteSchemas, QueryCollections, MetadataAllowlist, CustomTypes, Actions, CronTriggers, ApiLimit, MetricsConfig, InheritedRoles, SetGraphqlIntrospectionOptions)

-- | This newtype simply wraps the BackendConfig type family so that it can
--   be used with BackendMap in the Metadata type. GHC will not allow the
--   type family to be used directly. :(
newtype BackendConfigWrapper b
BackendConfigWrapper :: BackendConfig b -> BackendConfigWrapper b
[unBackendConfigWrapper] :: BackendConfigWrapper b -> BackendConfig b
data CatalogStateType
CSTCli :: CatalogStateType
CSTConsole :: CatalogStateType
data SetCatalogState
SetCatalogState :: CatalogStateType -> Value -> SetCatalogState
[_scsType] :: SetCatalogState -> CatalogStateType
[_scsState] :: SetCatalogState -> Value
data CatalogState
CatalogState :: Text -> Value -> Value -> CatalogState
[_csId] :: CatalogState -> Text
[_csCliState] :: CatalogState -> Value
[_csConsoleState] :: CatalogState -> Value
data GetCatalogState
GetCatalogState :: GetCatalogState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.CatalogState
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.CatalogState
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.CatalogState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance GHC.Base.Semigroup (Hasura.RQL.Types.Backend.BackendConfig b) => GHC.Base.Semigroup (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance GHC.Base.Monoid (Hasura.RQL.Types.Backend.BackendConfig b) => GHC.Base.Monoid (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Extended.FromJSONWithContext (Hasura.SQL.Backend.BackendSourceKind b) (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Metadata.Common.FunctionMetadata b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Metadata.Common.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Metadata.Common.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Common.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Metadata.Common.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Metadata.Common.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Metadata.Common.TableMetadata b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Metadata.Common.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Metadata.Common.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Common.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Metadata.Common.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Metadata.Common.TableMetadata b)
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Common.RemoteSchemaTypeRelationships
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.RemoteSchemaTypeRelationships
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.RemoteSchemaTypeRelationships
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Common.RemoteSchemaMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.RemoteSchemaMetadata
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.RemoteSchemaMetadata
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Metadata.Common.RemoteSchemaMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.RemoteSchemaMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.RemoteSchemaMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.RemoteSchemaTypeRelationships
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.RemoteSchemaTypeRelationships
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Metadata.Common.RemoteSchemaTypeRelationships
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.RemoteSchemaPermissionMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.RemoteSchemaPermissionMetadata
instance GHC.Generics.Generic (Hasura.RQL.Types.Metadata.Common.ComputedFieldMetadata b)
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Common.RemoteSchemaPermissionMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.RemoteSchemaPermissionMetadata
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.RemoteSchemaPermissionMetadata
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Metadata.Common.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Common.ComputedFieldMetadata b)
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.Metadata.Common.RemoteSchemaPermissionMetadata
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.Types.Metadata.Common.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Metadata.Common.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Metadata.Common.ComputedFieldMetadata b)


-- | Helpers used in the implementations of <tt>metadataToOrdJSON</tt> and
--   <tt>metadataToDTO</tt>
module Hasura.RQL.Types.Metadata.Serialization
sourcesToOrdJSONList :: Sources -> Array
remoteSchemasToOrdJSONList :: RemoteSchemas -> Maybe Array
backendConfigsToOrdJSON :: BackendMap BackendConfigWrapper -> Maybe Value
inheritedRolesToOrdJSONList :: InheritedRoles -> Maybe Array
queryCollectionsToOrdJSONList :: QueryCollections -> Maybe Array
allowlistToOrdJSONList :: MetadataAllowlist -> Maybe Array
apiLimitsToOrdJSON :: ApiLimit -> Maybe Value
cronTriggersToOrdJSONList :: CronTriggers -> Maybe Array
customTypesToOrdJSON :: CustomTypes -> Maybe Object
endpointsToOrdJSONList :: Endpoints -> Maybe Array
introspectionDisabledRolesToOrdJSON :: SetGraphqlIntrospectionOptions -> Maybe Value
metricsConfigToOrdJSON :: MetricsConfig -> Maybe Value
networkConfigToOrdJSON :: Network -> Maybe Value
actionMetadataToOrdJSONList :: Actions -> Maybe Array
ifNotEmpty :: (a -> Bool) -> (a -> b) -> a -> Maybe b

-- | Sort list before encoding to JSON value
listToMaybeOrdPairSort :: (Foldable t, Ord b) => Text -> (a -> Value) -> (a -> b) -> t a -> Maybe (Text, Value)

-- | Sort list before encoding to JSON array (not value)
listToMaybeArraySort :: (Foldable t, Ord b) => (a -> Value) -> (a -> b) -> t a -> Maybe Array
listToMaybeOrdPair :: Foldable t => Text -> (a -> Value) -> t a -> Maybe (Text, Value)
maybeSetToMaybeOrdPair :: Backend b => Maybe (ColumnValues b Value) -> Maybe (Text, Value)
maybeDescriptionToMaybeOrdPair :: Maybe Description -> Maybe (Text, Value)
maybeCommentToMaybeOrdPair :: Maybe Text -> Maybe (Text, Value)
maybeAnyToMaybeOrdPair :: Text -> (a -> Value) -> Maybe a -> Maybe (Text, Value)
commentToMaybeOrdPair :: Comment -> Maybe (Text, Value)

module Hasura.RQL.Types.Metadata

-- | Versioning the <tt><a>Metadata</a> JSON structure to track backwards
--   incompatible changes. This value is included in the metadata JSON
--   object at top level <tt>version</tt> key. Always metadata is emitted
--   in the latest version via export metadata API
--   (</tt><tt>runExportMetadata</tt> handler). Adding a new value
--   constructor to @<a>MetadataVersion</a> type bumps the metadata
--   version.
--   
--   NOTE: When metadata version is bumped: 1. The Hasura CLI and Console
--   actively use export metadata API to read metadata. Hence, it is
--   necessary to update CLI and Console to read latest metadata. All
--   changes SHOULD be released hand in hand (preferebly in one pull
--   request) 2. There might be other third party services (developed by
--   Hasura users) which use the export metadata API. Apart from changelog,
--   we need to establish the metadata version update by bumping up the
--   minor version of the GraphQL Engine.
data MetadataVersion
MVVersion1 :: MetadataVersion
MVVersion2 :: MetadataVersion
MVVersion3 :: MetadataVersion
currentMetadataVersion :: MetadataVersion

-- | A complete GraphQL Engine metadata representation to be stored,
--   exported/replaced via metadata queries.
data Metadata
Metadata :: Sources -> RemoteSchemas -> QueryCollections -> MetadataAllowlist -> CustomTypes -> Actions -> CronTriggers -> Endpoints -> ApiLimit -> MetricsConfig -> InheritedRoles -> SetGraphqlIntrospectionOptions -> Network -> BackendMap BackendConfigWrapper -> Metadata
[_metaSources] :: Metadata -> Sources
[_metaRemoteSchemas] :: Metadata -> RemoteSchemas
[_metaQueryCollections] :: Metadata -> QueryCollections
[_metaAllowlist] :: Metadata -> MetadataAllowlist
[_metaCustomTypes] :: Metadata -> CustomTypes
[_metaActions] :: Metadata -> Actions
[_metaCronTriggers] :: Metadata -> CronTriggers
[_metaRestEndpoints] :: Metadata -> Endpoints
[_metaApiLimits] :: Metadata -> ApiLimit
[_metaMetricsConfig] :: Metadata -> MetricsConfig
[_metaInheritedRoles] :: Metadata -> InheritedRoles
[_metaSetGraphqlIntrospectionOptions] :: Metadata -> SetGraphqlIntrospectionOptions
[_metaNetwork] :: Metadata -> Network
[_metaBackendConfigs] :: Metadata -> BackendMap BackendConfigWrapper
metaSources :: Lens' Metadata Sources
metaSetGraphqlIntrospectionOptions :: Lens' Metadata SetGraphqlIntrospectionOptions
metaRestEndpoints :: Lens' Metadata Endpoints
metaRemoteSchemas :: Lens' Metadata RemoteSchemas
metaQueryCollections :: Lens' Metadata QueryCollections
metaNetwork :: Lens' Metadata Network
metaMetricsConfig :: Lens' Metadata MetricsConfig
metaInheritedRoles :: Lens' Metadata InheritedRoles
metaCustomTypes :: Lens' Metadata CustomTypes
metaCronTriggers :: Lens' Metadata CronTriggers
metaBackendConfigs :: Lens' Metadata (BackendMap BackendConfigWrapper)
metaApiLimits :: Lens' Metadata ApiLimit
metaAllowlist :: Lens' Metadata MetadataAllowlist
metaActions :: Lens' Metadata Actions
emptyMetadata :: Metadata
tableMetadataSetter :: Backend b => SourceName -> TableName b -> ASetter' Metadata (TableMetadata b)

-- | A lens setter for the metadata of a specific function as identified by
--   the source name and function name.
functionMetadataSetter :: Backend b => SourceName -> FunctionName b -> ASetter' Metadata (FunctionMetadata b)

-- | A simple monad class which enables fetching and setting
--   @<a>Metadata</a> in the state.
class (Monad m) => MetadataM m
getMetadata :: MetadataM m => m Metadata
putMetadata :: MetadataM m => Metadata -> m ()
data MetadataNoSources
MetadataNoSources :: Tables ('Postgres 'Vanilla) -> Functions ('Postgres 'Vanilla) -> RemoteSchemas -> QueryCollections -> MetadataAllowlist -> CustomTypes -> Actions -> CronTriggers -> MetadataNoSources
[_mnsTables] :: MetadataNoSources -> Tables ('Postgres 'Vanilla)
[_mnsFunctions] :: MetadataNoSources -> Functions ('Postgres 'Vanilla)
[_mnsRemoteSchemas] :: MetadataNoSources -> RemoteSchemas
[_mnsQueryCollections] :: MetadataNoSources -> QueryCollections
[_mnsAllowlist] :: MetadataNoSources -> MetadataAllowlist
[_mnsCustomTypes] :: MetadataNoSources -> CustomTypes
[_mnsActions] :: MetadataNoSources -> Actions
[_mnsCronTriggers] :: MetadataNoSources -> CronTriggers
newtype MetadataModifier
MetadataModifier :: (Metadata -> Metadata) -> MetadataModifier
[runMetadataModifier] :: MetadataModifier -> Metadata -> Metadata
dropTableInMetadata :: forall b. Backend b => SourceName -> TableName b -> MetadataModifier
dropRelationshipInMetadata :: RelName -> TableMetadata b -> TableMetadata b
dropPermissionInMetadata :: RoleName -> PermType -> TableMetadata b -> TableMetadata b
dropComputedFieldInMetadata :: ComputedFieldName -> TableMetadata b -> TableMetadata b
dropEventTriggerInMetadata :: TriggerName -> TableMetadata b -> TableMetadata b
dropRemoteRelationshipInMetadata :: RelName -> TableMetadata b -> TableMetadata b
dropFunctionInMetadata :: forall b. Backend b => SourceName -> FunctionName b -> MetadataModifier
dropRemoteSchemaInMetadata :: RemoteSchemaName -> MetadataModifier
dropRemoteSchemaPermissionInMetadata :: RemoteSchemaName -> RoleName -> MetadataModifier
dropRemoteSchemaRemoteRelationshipInMetadata :: RemoteSchemaName -> Name -> RelName -> MetadataModifier

-- | Encode <a>Metadata</a> to JSON with deterministic ordering (e.g.
--   "version" being at the top). The CLI system stores metadata in files
--   and has option to show changes in git diff style. The diff shouldn't
--   appear different for no metadata changes. So, the ordering of object
--   keys and array elements should remain consistent across versions of
--   graphql-engine if possible.
--   
--   Note: While modifying any part of the code below, make sure the
--   encoded JSON of each type is parsable via its <a>FromJSON</a>
--   instance.
--   
--   TODO: we can use 'aeson-pretty' to serialize in a consistent way, and
--   to specify a (partial) order of keys, while getting the benefits of
--   auto-generated To/FromJSON instances. `FromJSON TableMetadata`
--   complicates this though...
--   
--   See: <a>https://github.com/hasura/graphql-engine/issues/6348</a>
metadataToOrdJSON :: Metadata -> Value

-- | Convert <a>Metadata</a> to a DTO for serialization. In the near future
--   the plan is to use this function instead of the <a>ToJSON</a> instance
--   of <a>Metadata</a>. For the time being DTO serialization does not
--   match the same order of object keys as the <a>ToJSON</a> instance - we
--   can't switch to using this function until that issue is resolved. See
--   <a>https://hasurahq.atlassian.net/browse/MM-29</a>
metadataToDTO :: Metadata -> MetadataV3
instance GHC.Base.Monoid Hasura.RQL.Types.Metadata.MetadataModifier
instance GHC.Base.Semigroup Hasura.RQL.Types.Metadata.MetadataModifier
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.MetadataNoSources
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.MetadataNoSources
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Metadata
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.MetadataNoSources
instance Hasura.RQL.Types.Metadata.MetadataM m => Hasura.RQL.Types.Metadata.MetadataM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.Metadata.MetadataM m => Hasura.RQL.Types.Metadata.MetadataM (Control.Monad.Trans.State.Strict.StateT r m)
instance Hasura.RQL.Types.Metadata.MetadataM m => Hasura.RQL.Types.Metadata.MetadataM (Hasura.Tracing.TraceT m)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Metadata
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.MetadataVersion
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.MetadataVersion
instance GHC.Show.Show Hasura.RQL.Types.Metadata.MetadataVersion
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Metadata
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Metadata
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Metadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.MetadataVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.MetadataVersion

module Hasura.RQL.Types.SchemaCacheTypes
data TableObjId (b :: BackendType)
TOCol :: Column b -> TableObjId (b :: BackendType)
TORel :: RelName -> TableObjId (b :: BackendType)
TOComputedField :: ComputedFieldName -> TableObjId (b :: BackendType)
TORemoteRel :: RelName -> TableObjId (b :: BackendType)
TOForeignKey :: ConstraintName b -> TableObjId (b :: BackendType)
TOPerm :: RoleName -> PermType -> TableObjId (b :: BackendType)
TOTrigger :: TriggerName -> TableObjId (b :: BackendType)
data SourceObjId (b :: BackendType)
SOITable :: TableName b -> SourceObjId (b :: BackendType)
SOITableObj :: TableName b -> TableObjId b -> SourceObjId (b :: BackendType)
SOIFunction :: FunctionName b -> SourceObjId (b :: BackendType)
data SchemaObjId
SOSource :: SourceName -> SchemaObjId
SOSourceObj :: SourceName -> AnyBackend SourceObjId -> SchemaObjId
SORemoteSchema :: RemoteSchemaName -> SchemaObjId
SORemoteSchemaPermission :: RemoteSchemaName -> RoleName -> SchemaObjId

-- | A remote relationship on a remote schema type, identified by 1. remote
--   schema name 2. remote schema type on which the relationship is defined
--   3. name of the relationship
SORemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> SchemaObjId
SORole :: RoleName -> SchemaObjId
reportSchemaObj :: SchemaObjId -> Text
reportSchemaObjs :: [SchemaObjId] -> Text
data DependencyReason
DRTable :: DependencyReason
DRColumn :: DependencyReason
DRRemoteTable :: DependencyReason
DRLeftColumn :: DependencyReason
DRRightColumn :: DependencyReason
DRUsingColumn :: DependencyReason
DRFkey :: DependencyReason
DRRemoteFkey :: DependencyReason
DRUntyped :: DependencyReason
DROnType :: DependencyReason
DRSessionVariable :: DependencyReason
DRPayload :: DependencyReason
DRParent :: DependencyReason
DRRemoteSchema :: DependencyReason
DRRemoteRelationship :: DependencyReason
DRParentRole :: DependencyReason
reasonToTxt :: DependencyReason -> Text
data SchemaDependency
SchemaDependency :: SchemaObjId -> DependencyReason -> SchemaDependency
[sdObjId] :: SchemaDependency -> SchemaObjId
[sdReason] :: SchemaDependency -> DependencyReason
reportDependentObjectsExist :: MonadError QErr m => [SchemaObjId] -> m ()
purgeSourceAndSchemaDependencies :: MonadError QErr m => SchemaObjId -> WriterT MetadataModifier m ()
purgeDependentObject :: forall b m. (MonadError QErr m, Backend b) => SourceName -> SourceObjId b -> m MetadataModifier

-- | Type class to collect schema dependencies from backend-specific
--   aggregation predicates.
class Backend b => GetAggregationPredicatesDeps b
getAggregationPredicateDeps :: GetAggregationPredicatesDeps b => AggregationPredicates b (PartialSQLExp b) -> BoolExpM b [SchemaDependency]
getAggregationPredicateDeps :: (GetAggregationPredicatesDeps b, AggregationPredicates b ~ Const Void) => AggregationPredicates b (PartialSQLExp b) -> BoolExpM b [SchemaDependency]

-- | The monad for doing schema dependency discovery for boolean
--   expressions. maintains the table context of the expressions being
--   translated.
newtype BoolExpM b a
BoolExpM :: Reader (BoolExpCtx b) a -> BoolExpM b a
[unBoolExpM] :: BoolExpM b a -> Reader (BoolExpCtx b) a

-- | The table type context of schema dependency discovery. Boolean
--   expressions may refer to a so-called 'root table' (identified by a
--   <a>$</a>-sign in the expression input syntax) or the <tt>current</tt>
--   table.
data BoolExpCtx b
BoolExpCtx :: SourceName -> TableName b -> TableName b -> BoolExpCtx b
[source] :: BoolExpCtx b -> SourceName

-- | Reference to the <tt>current</tt> table type.
[currTable] :: BoolExpCtx b -> TableName b

-- | Reference to the <tt>root</tt> table type.
[rootTable] :: BoolExpCtx b -> TableName b
runBoolExpM :: BoolExpCtx b -> BoolExpM b a -> a
instance Control.Monad.Reader.Class.MonadReader (Hasura.RQL.Types.SchemaCacheTypes.BoolExpCtx b) (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance GHC.Base.Monad (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance GHC.Base.Applicative (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance GHC.Base.Functor (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance GHC.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.TableObjId b)
instance GHC.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.SourceObjId b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.SourceObjId b)
instance GHC.Generics.Generic Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance GHC.Generics.Generic Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance GHC.Show.Show Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance GHC.Generics.Generic Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance GHC.Show.Show Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.TableObjId b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance GHC.Show.Show Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.SourceObjId b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.TableObjId b)

module Hasura.Backends.MySQL.Instances.SchemaCache
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MySQL => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps 'Hasura.SQL.Backend.MySQL

module Hasura.Backends.MSSQL.Instances.SchemaCache
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.MSSQL => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps 'Hasura.SQL.Backend.MSSQL

module Hasura.Backends.DataConnector.Adapter.SchemaCache
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.DataConnector => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps 'Hasura.SQL.Backend.DataConnector

module Hasura.Backends.BigQuery.Instances.SchemaCache
instance Hasura.RQL.Types.Backend.Backend 'Hasura.SQL.Backend.BigQuery => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps 'Hasura.SQL.Backend.BigQuery

module Hasura.RQL.DDL.SourceKinds
data ListSourceKinds
ListSourceKinds :: ListSourceKinds
data SourceKindInfo
SourceKindInfo :: Text -> SourceType -> SourceKindInfo
[_skiSourceKind] :: SourceKindInfo -> Text
[_skiBuiltin] :: SourceKindInfo -> SourceType
data SourceType
Builtin :: SourceType
Agent :: SourceType
agentSourceKinds :: MetadataM m => m [SourceKindInfo]
mkAgentSource :: DataConnectorName -> SourceKindInfo
mkNativeSource :: BackendType -> Maybe SourceKindInfo
runListSourceKinds :: MetadataM m => ListSourceKinds -> m EncJSON
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SourceKinds.SourceKindInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SourceKinds.SourceKindInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SourceKinds.SourceType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SourceKinds.SourceType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SourceKinds.ListSourceKinds
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SourceKinds.ListSourceKinds


-- | Types related to metadata management API
module Hasura.RQL.DDL.Metadata.Types

-- | <a>ClearMetadata</a> can be used to reset the state of Hasura -- clean
--   the current state by forgetting the tables tracked, relationships,
--   permissions, event triggers etc.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-clear-metadata</a>
data ClearMetadata
ClearMetadata :: ClearMetadata

-- | <a>ExportMetadata</a> is used to export the current metadata from the
--   server as a JSON file.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-export-metadata</a>
data ExportMetadata
ExportMetadata :: ExportMetadata
data ReloadSpec a
RSReloadAll :: ReloadSpec a
RSReloadList :: HashSet a -> ReloadSpec a
type ReloadRemoteSchemas = ReloadSpec RemoteSchemaName
type ReloadSources = ReloadSpec SourceName
reloadAllRemoteSchemas :: ReloadRemoteSchemas
reloadAllSources :: ReloadSources

-- | <a>ReloadMetadata</a> should be used when there is a change in
--   underlying Postgres database that Hasura should be aware of. Example:
--   a new column is added to a table using psql and this column should now
--   be added to the GraphQL schema.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-reload-metadata</a>
data ReloadMetadata
ReloadMetadata :: ReloadRemoteSchemas -> ReloadSources -> ReloadSources -> ReloadMetadata
[_rmReloadRemoteSchemas] :: ReloadMetadata -> ReloadRemoteSchemas
[_rmReloadSources] :: ReloadMetadata -> ReloadSources

-- | Provides a way for the user to allow to explicitly recreate event
--   triggers for some or all the sources. This is useful when a user may
--   have fiddled with the SQL trigger in the source and they'd simply want
--   the event trigger to be recreated without deleting and creating the
--   event trigger. By default, no source's event triggers will be
--   recreated.
[_rmRecreateEventTriggers] :: ReloadMetadata -> ReloadSources

-- | Undocumented Metadata API action which serializes the entire
--   <tt>SchemaCache</tt>.
data DumpInternalState
DumpInternalState :: DumpInternalState

-- | <a>GetInconsistentMetadata</a> can be used to fetch all inconsistent
--   metadata objects.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/schema-metadata-api/manage-metadata/#schema-metadata-get-inconsistent-metadata</a>
data GetInconsistentMetadata
GetInconsistentMetadata :: GetInconsistentMetadata

-- | <a>DropInconsistentMetadata</a> can be used to purge all inconsistent
--   objects from the metadata.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-drop-inconsistent-metadata</a>
data DropInconsistentMetadata
DropInconsistentMetadata :: DropInconsistentMetadata
data AllowInconsistentMetadata
AllowInconsistentMetadata :: AllowInconsistentMetadata
NoAllowInconsistentMetadata :: AllowInconsistentMetadata

-- | Replace metadata either with or without metadata sources.
data ReplaceMetadataV1
RMWithSources :: Metadata -> ReplaceMetadataV1
RMWithoutSources :: MetadataNoSources -> ReplaceMetadataV1

-- | Replace metadata while allowing for inconsitency in the metadata
--   object.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-replace-metadata-syntax</a>
data ReplaceMetadataV2
ReplaceMetadataV2 :: AllowInconsistentMetadata -> ReplaceMetadataV1 -> ReplaceMetadataV2
[_rmv2AllowInconsistentMetadata] :: ReplaceMetadataV2 -> AllowInconsistentMetadata
[_rmv2Metadata] :: ReplaceMetadataV2 -> ReplaceMetadataV1

-- | <a>ReplaceMetadata</a> is used to replace/import metadata into Hasura.
--   Existing metadata will be replaced with the new one.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-replace-metadata</a>
--   TODO: If additional API versions are supported in future it would be
--   ideal to include a version field Rather than differentiating on the
--   "metadata" field.
data ReplaceMetadata
RMReplaceMetadataV1 :: ReplaceMetadataV1 -> ReplaceMetadata
RMReplaceMetadataV2 :: ReplaceMetadataV2 -> ReplaceMetadata
data WebHookUrl
EnvVar :: String -> WebHookUrl
URL :: Text -> WebHookUrl

-- | <a>TestWebhookTransform</a> can be used to test out request
--   transformations using mock data.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#test-webhook-transform</a>
data TestWebhookTransform
TestWebhookTransform :: Environment -> [Header] -> WebHookUrl -> Value -> RequestTransform -> Maybe MetadataResponseTransform -> Maybe SessionVariables -> TestWebhookTransform
[_twtEnv] :: TestWebhookTransform -> Environment
[_twtHeaders] :: TestWebhookTransform -> [Header]
[_twtWebhookUrl] :: TestWebhookTransform -> WebHookUrl
[_twtPayload] :: TestWebhookTransform -> Value
[_twtTransformer] :: TestWebhookTransform -> RequestTransform
[_twtResponseTransformer] :: TestWebhookTransform -> Maybe MetadataResponseTransform
[_twtSessionVariables] :: TestWebhookTransform -> Maybe SessionVariables
twtTransformer :: Lens' TestWebhookTransform RequestTransform
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV1
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV2
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReplaceMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.WebHookUrl
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.TestWebhookTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.TestWebhookTransform
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.TestWebhookTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.WebHookUrl
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.WebHookUrl
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV2
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV2
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV1
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance (Data.Aeson.Types.FromJSON.FromJSON a, GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.ClearMetadata


-- | This module provides operations to load and modify metadata relating
--   to GraphQL Data Connectors.
module Hasura.RQL.DDL.DataConnector
data DCAddAgent
DCAddAgent :: NonEmptyText -> BaseUrl -> DCAddAgent
[_gdcaName] :: DCAddAgent -> NonEmptyText
[_gdcaUrl] :: DCAddAgent -> BaseUrl

-- | Insert a new Data Connector Agent into Metadata.
runAddDataConnectorAgent :: MetadataM m => DCAddAgent -> m EncJSON
data DCDeleteAgent
DCDeleteAgent :: NonEmptyText -> DCDeleteAgent
[_gdcrName] :: DCDeleteAgent -> NonEmptyText
runDeleteDataConnectorAgent :: MetadataM m => DCDeleteAgent -> m EncJSON
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.DataConnector.DCDeleteAgent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.DataConnector.DCDeleteAgent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.DataConnector.DCAddAgent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.DataConnector.DCAddAgent


-- | Postgres DDL Source
--   
--   A Source is a connected database. One can have multiple sources of the
--   same kind (e.g. Postgres).
--   
--   This module provides ways to fetch, update, and deal with table and
--   function metadata and hdb_catalog migrations for a Postgres Source.
--   
--   NOTE: Please have a look at the
--   `server<i>documentation</i>migration-guidelines.md` before adding any
--   new migration if you haven't already looked at it.
module Hasura.Backends.Postgres.DDL.Source

-- | We differentiate the handling of metadata between Citus, Cockroach and
--   Vanilla Postgres because Citus imposes limitations on the types of
--   joins that it permits, which then limits the types of relations that
--   we can track.
class ToMetadataFetchQuery (pgKind :: PostgresKind)
tableMetadata :: ToMetadataFetchQuery pgKind => Query
resolveSourceConfig :: (MonadIO m, MonadResolveSource m) => Logger Hasura -> SourceName -> PostgresConnConfiguration -> BackendSourceKind ('Postgres pgKind) -> BackendConfig ('Postgres pgKind) -> Environment -> manager -> m (Either QErr (SourceConfig ('Postgres pgKind)))

-- | <a>PGSourceLockQuery</a> is a data type which represents the contents
--   of a single object of the locked queries which are queried from the
--   <tt>pg_stat_activity</tt>. See
--   <a>logPGSourceCatalogMigrationLockedQueries</a>.
data PGSourceLockQuery
PGSourceLockQuery :: Text -> Maybe Bool -> Text -> UTCTime -> UTCTime -> Text -> Text -> PGSourceLockQuery
[_psqaQuery] :: PGSourceLockQuery -> Text
[_psqaLockGranted] :: PGSourceLockQuery -> Maybe Bool
[_psqaLockMode] :: PGSourceLockQuery -> Text
[_psqaTransactionStartTime] :: PGSourceLockQuery -> UTCTime
[_psqaQueryStartTime] :: PGSourceLockQuery -> UTCTime
[_psqaWaitEventType] :: PGSourceLockQuery -> Text
[_psqaBlockingQuery] :: PGSourceLockQuery -> Text
newtype PGSourceLockQueryError
PGSourceLockQueryError :: QErr -> PGSourceLockQueryError

-- | <a>logPGSourceCatalogMigrationLockedQueries</a> as the name suggests
--   logs the queries which are blocking in the database. This function is
--   called asynchronously from <tt>initCatalogIfNeeded</tt> while the
--   source catalog is being migrated. NOTE: When there are no locking
--   queries present in the database, nothing will be logged.
logPGSourceCatalogMigrationLockedQueries :: MonadIO m => Logger Hasura -> PGSourceConfig -> m Void
resolveDatabaseMetadata :: forall pgKind m. (Backend ('Postgres pgKind), ToMetadataFetchQuery pgKind, FetchFunctionMetadata pgKind, FetchTableMetadata pgKind, MonadIO m, MonadBaseControl IO m) => SourceMetadata ('Postgres pgKind) -> SourceConfig ('Postgres pgKind) -> SourceTypeCustomization -> m (Either QErr (ResolvedSource ('Postgres pgKind)))

-- | Initialise catalog tables for a source, including those required by
--   the event delivery subsystem.
prepareCatalog :: (MonadIO m, MonadBaseControl IO m) => SourceConfig ('Postgres pgKind) -> ExceptT QErr m RecreateEventTriggers
migrateSourceCatalog :: MonadTx m => m RecreateEventTriggers

-- | <a>migrateSourceCatalogFrom</a> migrates the catalog from a lower to a
--   higher version. When there are any changes in the source catalog, then
--   re-create the existing event triggers in the metadata. This is done so
--   that the event triggers be compatible with the changes introduced in
--   the newly added source catalog migrations. When the source is already
--   in the latest catalog version, we do nothing because nothing has
--   changed w.r.t the source catalog so recreating the event triggers will
--   only be extraneous.
migrateSourceCatalogFrom :: MonadTx m => SourceCatalogVersion pgKind -> m RecreateEventTriggers
sourceMigrations :: [(SourceCatalogVersion pgKind, TxE QErr ())]
upMigrationsUntil43 :: [(MetadataCatalogVersion, TxE QErr ())]

-- | We differentiate for CockroachDB and other PG implementations as our
--   CockroachDB table fetching SQL does not require table information, and
--   fails if it receives unused prepared arguments this distinction should
--   no longer be necessary if this issue is resolved:
--   <a>https://github.com/cockroachdb/cockroach/issues/86375</a>
class FetchTableMetadata (pgKind :: PostgresKind)
fetchTableMetadata :: forall m. (FetchTableMetadata pgKind, Backend ('Postgres pgKind), ToMetadataFetchQuery pgKind, MonadTx m) => [QualifiedTable] -> m (DBTablesMetadata ('Postgres pgKind))

-- | Fetch Postgres metadata of all user tables
pgFetchTableMetadata :: forall pgKind m. (Backend ('Postgres pgKind), ToMetadataFetchQuery pgKind, MonadTx m) => [QualifiedTable] -> m (DBTablesMetadata ('Postgres pgKind))

-- | Fetch Cockroach metadata of all user tables
cockroachFetchTableMetadata :: forall pgKind m. (Backend ('Postgres pgKind), ToMetadataFetchQuery pgKind, MonadTx m) => [QualifiedTable] -> m (DBTablesMetadata ('Postgres pgKind))
class FetchFunctionMetadata (pgKind :: PostgresKind)
fetchFunctionMetadata :: (FetchFunctionMetadata pgKind, MonadTx m) => [QualifiedFunction] -> m (DBFunctionsMetadata ('Postgres pgKind))

-- | Fetch Postgres metadata for all user functions
pgFetchFunctionMetadata :: MonadTx m => [QualifiedFunction] -> m (DBFunctionsMetadata ('Postgres pgKind))

-- | Fetch all scalar types from Postgres
fetchPgScalars :: MonadTx m => m (HashSet PGScalarType)

-- | Clean source database after dropping in metadata
postDropSourceHook :: (MonadIO m, MonadError QErr m, MonadBaseControl IO m) => SourceConfig ('Postgres pgKind) -> TableEventTriggers ('Postgres pgKind) -> m ()
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.DDL.Source.PGSourceLockQueryError
instance Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata 'Hasura.SQL.Backend.Vanilla
instance Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata 'Hasura.SQL.Backend.Citus
instance Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata 'Hasura.SQL.Backend.Cockroach
instance Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata 'Hasura.SQL.Backend.Vanilla
instance Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata 'Hasura.SQL.Backend.Citus
instance Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata 'Hasura.SQL.Backend.Cockroach
instance Hasura.Logging.ToEngineLog Hasura.Backends.Postgres.DDL.Source.PGSourceLockQueryError Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.DDL.Source.PGSourceLockQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.DDL.Source.PGSourceLockQuery
instance Hasura.Logging.ToEngineLog [Hasura.Backends.Postgres.DDL.Source.PGSourceLockQuery] Hasura.Logging.Hasura
instance Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery 'Hasura.SQL.Backend.Vanilla
instance Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery 'Hasura.SQL.Backend.Citus
instance Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery 'Hasura.SQL.Backend.Cockroach

module Hasura.RQL.Types.Metadata.Object
data TableMetadataObjId
MTORel :: RelName -> RelType -> TableMetadataObjId
MTOComputedField :: ComputedFieldName -> TableMetadataObjId
MTOPerm :: RoleName -> PermType -> TableMetadataObjId
MTOTrigger :: TriggerName -> TableMetadataObjId
MTORemoteRelationship :: RelName -> TableMetadataObjId
data SourceMetadataObjId b
SMOTable :: TableName b -> SourceMetadataObjId b
SMOFunction :: FunctionName b -> SourceMetadataObjId b
SMOFunctionPermission :: FunctionName b -> RoleName -> SourceMetadataObjId b
SMOTableObj :: TableName b -> TableMetadataObjId -> SourceMetadataObjId b
data MetadataObjId
MOSource :: SourceName -> MetadataObjId
MOSourceObjId :: SourceName -> AnyBackend SourceMetadataObjId -> MetadataObjId

-- | Originates from user-defined <a>_arsqName</a>
MORemoteSchema :: RemoteSchemaName -> MetadataObjId
MORemoteSchemaPermissions :: RemoteSchemaName -> RoleName -> MetadataObjId

-- | A remote relationship on a remote schema type, identified by 1. remote
--   schema name 2. remote schema type on which the relationship is defined
--   3. name of the relationship
MORemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> MetadataObjId
MOCustomTypes :: MetadataObjId
MOAction :: ActionName -> MetadataObjId
MOActionPermission :: ActionName -> RoleName -> MetadataObjId
MOCronTrigger :: TriggerName -> MetadataObjId
MOInheritedRole :: RoleName -> MetadataObjId
MOEndpoint :: EndpointName -> MetadataObjId
MOHostTlsAllowlist :: String -> MetadataObjId
MOQueryCollectionsQuery :: CollectionName -> ListedQuery -> MetadataObjId
_MOQueryCollectionsQuery :: Prism' MetadataObjId (CollectionName, ListedQuery)
_MOHostTlsAllowlist :: Prism' MetadataObjId String
_MOEndpoint :: Prism' MetadataObjId EndpointName
_MOInheritedRole :: Prism' MetadataObjId RoleName
_MOCronTrigger :: Prism' MetadataObjId TriggerName
_MOActionPermission :: Prism' MetadataObjId (ActionName, RoleName)
_MOAction :: Prism' MetadataObjId ActionName
_MOCustomTypes :: Prism' MetadataObjId ()
_MORemoteSchemaRemoteRelationship :: Prism' MetadataObjId (RemoteSchemaName, Name, RelName)
_MORemoteSchemaPermissions :: Prism' MetadataObjId (RemoteSchemaName, RoleName)
_MORemoteSchema :: Prism' MetadataObjId RemoteSchemaName
_MOSourceObjId :: Prism' MetadataObjId (SourceName, AnyBackend SourceMetadataObjId)
_MOSource :: Prism' MetadataObjId SourceName
moiTypeName :: MetadataObjId -> Text
moiName :: MetadataObjId -> Text
data MetadataObject
MetadataObject :: MetadataObjId -> Value -> MetadataObject
[_moId] :: MetadataObject -> MetadataObjId
[_moDefinition] :: MetadataObject -> Value
moId :: Lens' MetadataObject MetadataObjId
moDefinition :: Lens' MetadataObject Value
data InconsistentRoleEntity
InconsistentTablePermission :: SourceName -> Text -> PermType -> InconsistentRoleEntity
InconsistentRemoteSchemaPermission :: RemoteSchemaName -> InconsistentRoleEntity
data InconsistentMetadata
InconsistentObject :: Text -> Maybe Value -> MetadataObject -> InconsistentMetadata
ConflictingObjects :: Text -> [MetadataObject] -> InconsistentMetadata
DuplicateObjects :: MetadataObjId -> [Value] -> InconsistentMetadata
DuplicateRestVariables :: Text -> MetadataObject -> InconsistentMetadata
InvalidRestSegments :: Text -> MetadataObject -> InconsistentMetadata
AmbiguousRestEndpoints :: Text -> [MetadataObject] -> InconsistentMetadata
ConflictingInheritedPermission :: RoleName -> InconsistentRoleEntity -> InconsistentMetadata
_ConflictingInheritedPermission :: Prism' InconsistentMetadata (RoleName, InconsistentRoleEntity)
_AmbiguousRestEndpoints :: Prism' InconsistentMetadata (Text, [MetadataObject])
_InvalidRestSegments :: Prism' InconsistentMetadata (Text, MetadataObject)
_DuplicateRestVariables :: Prism' InconsistentMetadata (Text, MetadataObject)
_DuplicateObjects :: Prism' InconsistentMetadata (MetadataObjId, [Value])
_ConflictingObjects :: Prism' InconsistentMetadata (Text, [MetadataObject])
_InconsistentObject :: Prism' InconsistentMetadata (Text, Maybe Value, MetadataObject)

-- | Helper function to differentiate which type of inconsistent metadata
--   can be dropped, if an inconsistency cannot be resolved by dropping any
--   part of the metadata then this function should return <a>False</a>,
--   otherwise it should return <a>True</a>
droppableInconsistentMetadata :: InconsistentMetadata -> Bool
getInconsistentRemoteSchemas :: [InconsistentMetadata] -> [RemoteSchemaName]
imObjectIds :: InconsistentMetadata -> [MetadataObjId]
imReason :: InconsistentMetadata -> Text

-- | Builds a map from each unique metadata object id to the
--   inconsistencies associated with it. Note that a single inconsistency
--   can involve multiple metadata objects, so the same inconsistency may
--   appear in the resulting map multiple times!
groupInconsistentMetadataById :: [InconsistentMetadata] -> HashMap MetadataObjId (NonEmpty InconsistentMetadata)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.MetadataObject
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.MetadataObject
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.MetadataObject
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.MetadataObject
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance GHC.Generics.Generic (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.TableMetadataObjId


-- | In <a>Parser</a>, the <a>Definition</a> type has a <a>dOrigin</a>
--   field that allows to track where a fragment of GraphQL type
--   information comes from. This is useful for error reporting and
--   internal repair mechanisms such as inconsistency tracking.
--   
--   Morally, within the HGE codebase, this origin is always
--   <a>MetadataObjId</a>. However, in order to avoid an import of
--   <a>RQL</a> from <a>Parser</a>, the <a>dOrigin</a> has been defined
--   through a type parameter of <a>Definition</a>. This type parameter
--   then has to get threaded through throughout the <a>Parser</a> module
--   hierarchy, so that it ends up in a lot of types. This is very noisy.
--   
--   In order to avoid the noise of this type parameter, which really only
--   has one value, and is really only used in one type, this module erases
--   the type parameter by filling in the desired value, exporting type
--   synonyms of the now-fixed notion of "origin". So most modules in the
--   HGE codebase should import this module rather than <a>Parser</a>.
module Hasura.GraphQL.Schema.Parser
type FieldParser = FieldParser MetadataObjId
type Parser = Parser MetadataObjId
type Schema = Schema MetadataObjId
type ConflictingDefinitions = ConflictingDefinitions MetadataObjId
type Type = Type MetadataObjId
type InputFieldsParser = InputFieldsParser MetadataObjId
type Definition = Definition MetadataObjId
type Directive = Directive MetadataObjId
type DirectiveInfo = DirectiveInfo MetadataObjId
type FieldInfo = FieldInfo MetadataObjId
type InputFieldInfo = InputFieldInfo MetadataObjId
type HasTypeDefinitions = HasTypeDefinitions MetadataObjId
type SomeDefinitionTypeInfo = SomeDefinitionTypeInfo MetadataObjId
type TypeDefinitionsWrapper = TypeDefinitionsWrapper MetadataObjId

-- | In order to aid type inference and type checking, we define this
--   pattern synonym (an actual one) which restricts
--   <a>TypeDefinitionsWrapper</a> to have <a>MetadataObjId</a> set for its
--   origin type parameter.
pattern TypeDefinitionsWrapper :: () => forall a. HasTypeDefinitions a => a -> TypeDefinitionsWrapper
toQErr :: MonadError QErr m => Either ParseError a -> m a
memoizeOn :: (MonadMemoize m, Ord a, Typeable a, Typeable p, MonadParse n, Typeable b) => Name -> a -> m (p n b) -> m (p n b)

-- | A wrapper around <a>memoizeOn</a> that memoizes a function by using
--   its argument as the key.
memoize :: (MonadMemoize m, Ord a, Typeable a, Typeable p, MonadParse n, Typeable b) => Name -> (a -> m (p n b)) -> a -> m (p n b)

module Hasura.GraphQL.Schema.Introspect

-- | Builds a <tt>Schema</tt> from GraphQL types for the query_root,
--   mutation_root and subscription_root.
--   
--   See Note [What introspection exposes]
buildIntrospectionSchema :: Type 'Output -> Maybe (Type 'Output) -> Maybe (Type 'Output) -> Either ConflictingDefinitions Schema

-- | Generate a __type introspection parser
typeIntrospection :: forall n. MonadParse n => FieldParser n (Schema -> Value)

-- | Generate a __schema introspection parser.
schema :: forall n. MonadParse n => FieldParser n (Schema -> Value)
data SomeType
SomeType :: Type k -> SomeType
typeField :: forall n. MonadParse n => Parser 'Output n (SomeType -> Value)
inputValue :: forall n. MonadParse n => Parser 'Output n (Definition InputFieldInfo -> Value)
enumValue :: forall n. MonadParse n => Parser 'Output n (Definition EnumValueInfo -> Value)
typeKind :: forall n. MonadParse n => Parser 'Both n ()
fieldField :: forall n. MonadParse n => Parser 'Output n (Definition FieldInfo -> Value)
directiveSet :: forall n. MonadParse n => Parser 'Output n (DirectiveInfo -> Value)
schemaSet :: forall n. MonadParse n => Parser 'Output n (Schema -> Value)
selectionSetToJSON :: InsOrdHashMap Name Value -> Value
applyPrinter :: InsOrdHashMap Name (ParsedSelection (a -> Value)) -> a -> Value
nameAsJSON :: HasName a => a -> Value

module Hasura.GraphQL.Namespace
data RootFieldAlias
RootFieldAlias :: !Maybe Name -> !Name -> RootFieldAlias
[_rfaNamespace] :: RootFieldAlias -> !Maybe Name
[_rfaAlias] :: RootFieldAlias -> !Name
mkUnNamespacedRootFieldAlias :: Name -> RootFieldAlias
mkNamespacedRootFieldAlias :: Name -> Name -> RootFieldAlias
type RootFieldMap = InsOrdHashMap RootFieldAlias
data NamespacedField a

-- | Normal field
NotNamespaced :: a -> NamespacedField a

-- | Namespace field with other fields nested within
Namespaced :: InsOrdHashMap Name a -> NamespacedField a
namespacedField :: (a -> b) -> (InsOrdHashMap Name a -> b) -> NamespacedField a -> b
type NamespacedFieldMap a = InsOrdHashMap Name (NamespacedField a)
flattenNamespaces :: forall a. NamespacedFieldMap a -> RootFieldMap a
unflattenNamespaces :: RootFieldMap a -> NamespacedFieldMap a

-- | Wrap the field parser results in <tt>NamespacedField</tt>
customizeNamespace :: forall n a. MonadParse n => Maybe Name -> (Name -> ParsedSelection a -> a) -> MkTypename -> [FieldParser n a] -> [FieldParser n (NamespacedField a)]
instance GHC.Generics.Generic Hasura.GraphQL.Namespace.RootFieldAlias
instance GHC.Classes.Eq Hasura.GraphQL.Namespace.RootFieldAlias
instance GHC.Show.Show Hasura.GraphQL.Namespace.RootFieldAlias
instance GHC.Base.Functor Hasura.GraphQL.Namespace.NamespacedField
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Namespace.NamespacedField a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Namespace.NamespacedField a)
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Namespace.RootFieldAlias
instance Data.Text.Extended.ToTxt Hasura.GraphQL.Namespace.RootFieldAlias
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Namespace.RootFieldAlias


-- | This module has the various metadata we want to attach to the
--   generated/executed query
module Hasura.QueryTags

-- | Query Tags are SQL comments which are made up of (key=value) pairs.
--   
--   These are appended to the SQL statements generated by Hasura for
--   GraphQL operations. This enables the ability to get some application
--   context in the database logs and also use native database monitoring
--   tools (e.g. pganalyze) for better performance analysis.
--   
--   The application context(query tags) can be used to detect slow GQL
--   operation and relate them back to the SQL that was generated.
--   
--   For eg: SELECT name FROM child <i>*
--   request_id=487c2ed5-08a4-429a-b0e0-4666a82e3cc6, field_name=child,
--   operation_name=GetChild *</i>
--   
--   For more usage information, refer <a>Query Tags Docs</a>
data QueryTags
QTQuery :: !QueryMetadata -> QueryTags
QTMutation :: !MutationMetadata -> QueryTags
QTLiveQuery :: !LivequeryMetadata -> QueryTags

-- | query-tags as SQL comment which is appended to the prepared SQL
--   statement
newtype QueryTagsComment
QueryTagsComment :: Text -> QueryTagsComment
[_unQueryTagsComment] :: QueryTagsComment -> Text
type Attribute = (Text, Text)
newtype QueryTagsAttributes
QueryTagsAttributes :: [Attribute] -> QueryTagsAttributes
[_unQueryTagsAttributes] :: QueryTagsAttributes -> [Attribute]
emptyQueryTagsAttributes :: QueryTagsAttributes
emptyQueryTagsComment :: QueryTagsComment
data QueryMetadata
QueryMetadata :: !RequestId -> !Maybe Name -> !RootFieldAlias -> !ParameterizedQueryHash -> QueryMetadata
[qmRequestId] :: QueryMetadata -> !RequestId
[qmOperationName] :: QueryMetadata -> !Maybe Name
[qmFieldName] :: QueryMetadata -> !RootFieldAlias
[qmParameterizedQueryHash] :: QueryMetadata -> !ParameterizedQueryHash
data MutationMetadata
MutationMetadata :: !RequestId -> !Maybe Name -> !RootFieldAlias -> !ParameterizedQueryHash -> MutationMetadata
[mmRequestId] :: MutationMetadata -> !RequestId
[mmOperationName] :: MutationMetadata -> !Maybe Name
[mmFieldName] :: MutationMetadata -> !RootFieldAlias
[mmParameterizedQueryHash] :: MutationMetadata -> !ParameterizedQueryHash
data LivequeryMetadata
LivequeryMetadata :: !RootFieldAlias -> !ParameterizedQueryHash -> LivequeryMetadata
[lqmFieldName] :: LivequeryMetadata -> !RootFieldAlias
[lqmParameterizedQueryHash] :: LivequeryMetadata -> !ParameterizedQueryHash
encodeQueryTags :: QueryTags -> QueryTagsAttributes
operationNameAttributes :: Maybe Name -> [(Text, Text)]
instance GHC.Classes.Eq Hasura.QueryTags.QueryTagsComment
instance GHC.Show.Show Hasura.QueryTags.QueryTagsComment
instance GHC.Classes.Eq Hasura.QueryTags.QueryTagsAttributes
instance GHC.Show.Show Hasura.QueryTags.QueryTagsAttributes
instance GHC.Show.Show Hasura.QueryTags.QueryMetadata
instance GHC.Show.Show Hasura.QueryTags.MutationMetadata
instance GHC.Show.Show Hasura.QueryTags.LivequeryMetadata
instance GHC.Show.Show Hasura.QueryTags.QueryTags

module Hasura.Backends.MSSQL.Execute.QueryTags
withQueryTags :: Query -> QueryTagsComment -> Query
withQueryTagsPrinter :: Printer -> QueryTagsComment -> Printer


-- | Add metadata tags as comments to SQL queries.
module Data.SqlCommenter

-- | query-tags format as defined in the Spec
--   <a>https://google.github.io/sqlcommenter/spec/#sql-commenter</a>
sqlCommenterGoogle :: QueryTagsAttributes -> QueryTagsComment

-- | Default 'Query Tags' format in the Hasura GraphQL Engine Creates
--   simple 'key=value' pairs of query tags. No sorting, No URL encoding.
--   If the format of query tags is not mentioned in the metadata then,
--   query-tags are formatted using hte below format
sqlCommenterStandard :: QueryTagsAttributes -> QueryTagsComment

-- | Top-level algorithm to generate the string comment from list of
--   <a>Attribute</a>s Spec
--   <a>https://google.github.io/sqlcommenter/spec/#sql-commenter</a> See
--   Note [Ambiguous SQLCommenterGoogle Specification]
generateCommentTags :: NonEmpty Attribute -> Text


-- | This modules defines the tree of Select types: how we represent a
--   query internally, from its top level <a>QueryDB</a> down to each
--   individual field. Most of those types have three type arguments:
--   
--   b: BackendType The backend that is targeted by that specific select
--   (Postgres Vanilla, MSSQL...); we use the type families in the Backend
--   class to decide how different parts of the IR are represented in
--   different backends.
--   
--   v: Type The type of the leaf values in our AST; used almost
--   exclusively for column values, over which queries can be
--   parameterized. The output of the parser phase will use
--   <tt>UnpreparedValue b</tt> for the leaves, and most backends will then
--   transform the AST to interpret those values and consequently change
--   <tt>v</tt> to be <tt>SQLExpression b</tt>
--   
--   r: BackendType -&gt; Type Joins across backends mean that the
--   aforementioned <tt>b</tt> parameter won't be the same throughout the
--   entire tree; at some point we will have an <tt>AnyBackend</tt> used to
--   encapsulate a branch that uses a different <tt>b</tt>. We still want,
--   however, to be able to parameterize the values of the leaves in that
--   separate branch, and that's what the <tt>r</tt> parameter is for. We
--   also use <tt>UnpreparedValue</tt> here during the parsing phase,
--   meaning all leaf values will be <tt>UnpreparedValue b</tt> for their
--   respective backend <tt>b</tt>, and most backends will then transform
--   their AST, cutting all such remote branches, and therefore using
--   <tt>Const Void</tt> for <tt>r</tt>.
module Hasura.RQL.IR.Select
data QueryDB (b :: BackendType) (r :: Type) v
QDBMultipleRows :: AnnSimpleSelectG b r v -> QueryDB (b :: BackendType) (r :: Type) v
QDBSingleRow :: AnnSimpleSelectG b r v -> QueryDB (b :: BackendType) (r :: Type) v
QDBAggregation :: AnnAggregateSelectG b r v -> QueryDB (b :: BackendType) (r :: Type) v
QDBConnection :: ConnectionSelect b r v -> QueryDB (b :: BackendType) (r :: Type) v
QDBStreamMultipleRows :: AnnSimpleStreamSelectG b r v -> QueryDB (b :: BackendType) (r :: Type) v
data AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type)
AnnSelectG :: Fields (f v) -> SelectFromG b v -> TablePermG b v -> SelectArgsG b v -> StringifyNumbers -> Maybe NamingCase -> AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type)
[$sel:_asnFields:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> Fields (f v)
[$sel:_asnFrom:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> SelectFromG b v
[$sel:_asnPerm:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> TablePermG b v
[$sel:_asnArgs:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> SelectArgsG b v
[$sel:_asnStrfyNum:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> StringifyNumbers
[$sel:_asnNamingConvention:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> Maybe NamingCase

-- | IR type representing nodes for streaming subscriptions
data AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type)
AnnSelectStreamG :: XStreamingSubscription b -> Fields (f v) -> SelectFromG b v -> TablePermG b v -> SelectStreamArgsG b v -> StringifyNumbers -> AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type)

-- | type to indicate if streaming subscription has been enabled in the
--   <a>BackendType</a>. This type helps avoiding missing case match
--   patterns for backends where it's disabled.
[$sel:_assnXStreamingSubscription:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> XStreamingSubscription b

-- | output selection fields
[$sel:_assnFields:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> Fields (f v)

-- | table information to select from
[$sel:_assnFrom:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> SelectFromG b v

-- | select permissions
[$sel:_assnPerm:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> TablePermG b v

-- | streaming arguments
[$sel:_assnArgs:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> SelectStreamArgsG b v
[$sel:_assnStrfyNum:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> StringifyNumbers
type AnnSimpleSelectG b r v = AnnSelectG b (AnnFieldG b r) v
type AnnAggregateSelectG b r v = AnnSelectG b (TableAggregateFieldG b r) v
type AnnSimpleStreamSelectG b r v = AnnSelectStreamG b (AnnFieldG b r) v
type AnnSimpleSelect b = AnnSimpleSelectG b Void (SQLExpression b)
type AnnAggregateSelect b = AnnAggregateSelectG b Void (SQLExpression b)
type AnnSimpleStreamSelect b = AnnSimpleStreamSelectG b Void (SQLExpression b)

-- | We can't write a Bifoldable instance for AnnSelectG because the types
--   don't line up. Instead, we provide this function which can be used to
--   help define Bifoldable instances of other types containing AnnSelectG
--   values.
bifoldMapAnnSelectG :: (Backend b, Bifoldable (f b), Monoid m) => (r -> m) -> (v -> m) -> AnnSelectG b (f b r) v -> m
bifoldMapAnnSelectStreamG :: (Backend b, Bifoldable (f b), Monoid m) => (r -> m) -> (v -> m) -> AnnSelectStreamG b (f b r) v -> m
data ConnectionSelect (b :: BackendType) (r :: Type) v
ConnectionSelect :: XRelay b -> PrimaryKeyColumns b -> Maybe (NonEmpty (ConnectionSplit b v)) -> Maybe ConnectionSlice -> AnnSelectG b (ConnectionField b r) v -> ConnectionSelect (b :: BackendType) (r :: Type) v
[$sel:_csXRelay:ConnectionSelect] :: ConnectionSelect (b :: BackendType) (r :: Type) v -> XRelay b
[$sel:_csPrimaryKeyColumns:ConnectionSelect] :: ConnectionSelect (b :: BackendType) (r :: Type) v -> PrimaryKeyColumns b
[$sel:_csSplit:ConnectionSelect] :: ConnectionSelect (b :: BackendType) (r :: Type) v -> Maybe (NonEmpty (ConnectionSplit b v))
[$sel:_csSlice:ConnectionSelect] :: ConnectionSelect (b :: BackendType) (r :: Type) v -> Maybe ConnectionSlice
[$sel:_csSelect:ConnectionSelect] :: ConnectionSelect (b :: BackendType) (r :: Type) v -> AnnSelectG b (ConnectionField b r) v
data ConnectionSplit (b :: BackendType) v
ConnectionSplit :: ConnectionSplitKind -> v -> OrderByItemG b (AnnotatedOrderByElement b v) -> ConnectionSplit (b :: BackendType) v
[$sel:_csKind:ConnectionSplit] :: ConnectionSplit (b :: BackendType) v -> ConnectionSplitKind
[$sel:_csValue:ConnectionSplit] :: ConnectionSplit (b :: BackendType) v -> v
[$sel:_csOrderBy:ConnectionSplit] :: ConnectionSplit (b :: BackendType) v -> OrderByItemG b (AnnotatedOrderByElement b v)
data ConnectionSlice
SliceFirst :: Int -> ConnectionSlice
SliceLast :: Int -> ConnectionSlice
data ConnectionSplitKind
CSKBefore :: ConnectionSplitKind
CSKAfter :: ConnectionSplitKind

-- | Identifier used exclusively as the argument to <a>FromIdentifier</a>
newtype FIIdentifier
FIIdentifier :: Text -> FIIdentifier
[$sel:unFIIdentifier:FIIdentifier] :: FIIdentifier -> Text
data SelectFromG (b :: BackendType) v
FromTable :: TableName b -> SelectFromG (b :: BackendType) v
FromIdentifier :: FIIdentifier -> SelectFromG (b :: BackendType) v
FromFunction :: FunctionName b -> FunctionArgsExp b v -> Maybe [(Column b, ScalarType b)] -> SelectFromG (b :: BackendType) v
type SelectFrom b = SelectFromG b (SQLExpression b)
data SelectStreamArgsG (b :: BackendType) v
SelectStreamArgsG :: Maybe (AnnBoolExp b v) -> Int -> StreamCursorItem b -> SelectStreamArgsG (b :: BackendType) v

-- | optional filter to filter the stream results
[$sel:_ssaWhere:SelectStreamArgsG] :: SelectStreamArgsG (b :: BackendType) v -> Maybe (AnnBoolExp b v)

-- | maximum number of rows to be returned in a single fetch
[$sel:_ssaBatchSize:SelectStreamArgsG] :: SelectStreamArgsG (b :: BackendType) v -> Int

-- | info related to the cursor column, a single item data type currently
--   because only single column cursors are supported
[$sel:_ssaCursorArg:SelectStreamArgsG] :: SelectStreamArgsG (b :: BackendType) v -> StreamCursorItem b
type SelectStreamArgs b = SelectStreamArgsG b (SQLExpression b)
data SelectArgsG (b :: BackendType) v
SelectArgs :: Maybe (AnnBoolExp b v) -> Maybe (NonEmpty (AnnotatedOrderByItemG b v)) -> Maybe Int -> Maybe Int64 -> Maybe (NonEmpty (Column b)) -> SelectArgsG (b :: BackendType) v
[$sel:_saWhere:SelectArgs] :: SelectArgsG (b :: BackendType) v -> Maybe (AnnBoolExp b v)
[$sel:_saOrderBy:SelectArgs] :: SelectArgsG (b :: BackendType) v -> Maybe (NonEmpty (AnnotatedOrderByItemG b v))
[$sel:_saLimit:SelectArgs] :: SelectArgsG (b :: BackendType) v -> Maybe Int
[$sel:_saOffset:SelectArgs] :: SelectArgsG (b :: BackendType) v -> Maybe Int64
[$sel:_saDistinct:SelectArgs] :: SelectArgsG (b :: BackendType) v -> Maybe (NonEmpty (Column b))
type SelectArgs b = SelectArgsG b (SQLExpression b)
noSelectArgs :: SelectArgsG backend v

-- | The order by element for a computed field based on its return type
data ComputedFieldOrderByElement (b :: BackendType) v

-- | Sort by the scalar computed field
CFOBEScalar :: ScalarType b -> ComputedFieldOrderByElement (b :: BackendType) v
CFOBETableAggregation :: TableName b -> AnnBoolExp b v -> AnnotatedAggregateOrderBy b -> ComputedFieldOrderByElement (b :: BackendType) v
data ComputedFieldOrderBy (b :: BackendType) v
ComputedFieldOrderBy :: XComputedField b -> ComputedFieldName -> FunctionName b -> FunctionArgsExp b v -> ComputedFieldOrderByElement b v -> ComputedFieldOrderBy (b :: BackendType) v
[$sel:_cfobXField:ComputedFieldOrderBy] :: ComputedFieldOrderBy (b :: BackendType) v -> XComputedField b
[$sel:_cfobName:ComputedFieldOrderBy] :: ComputedFieldOrderBy (b :: BackendType) v -> ComputedFieldName
[$sel:_cfobFunction:ComputedFieldOrderBy] :: ComputedFieldOrderBy (b :: BackendType) v -> FunctionName b
[$sel:_cfobFunctionArgsExp:ComputedFieldOrderBy] :: ComputedFieldOrderBy (b :: BackendType) v -> FunctionArgsExp b v
[$sel:_cfobOrderByElement:ComputedFieldOrderBy] :: ComputedFieldOrderBy (b :: BackendType) v -> ComputedFieldOrderByElement b v
data AnnotatedOrderByElement (b :: BackendType) v
AOCColumn :: ColumnInfo b -> AnnotatedOrderByElement (b :: BackendType) v
AOCObjectRelation :: RelInfo b -> AnnBoolExp b v -> AnnotatedOrderByElement b v -> AnnotatedOrderByElement (b :: BackendType) v
AOCArrayAggregation :: RelInfo b -> AnnBoolExp b v -> AnnotatedAggregateOrderBy b -> AnnotatedOrderByElement (b :: BackendType) v
AOCComputedField :: ComputedFieldOrderBy b v -> AnnotatedOrderByElement (b :: BackendType) v
data AnnotatedAggregateOrderBy (b :: BackendType)
AAOCount :: AnnotatedAggregateOrderBy (b :: BackendType)
AAOOp :: Text -> ColumnInfo b -> AnnotatedAggregateOrderBy (b :: BackendType)
type AnnotatedOrderByItemG b v = OrderByItemG b (AnnotatedOrderByElement b v)
type AnnotatedOrderByItem b = AnnotatedOrderByItemG b (SQLExpression b)

-- | Cursor for streaming subscription
data StreamCursorItem (b :: BackendType)
StreamCursorItem :: CursorOrdering -> ColumnInfo b -> ColumnValue b -> StreamCursorItem (b :: BackendType)

-- | Specifies how the cursor item should be ordered
[$sel:_sciOrdering:StreamCursorItem] :: StreamCursorItem (b :: BackendType) -> CursorOrdering

-- | Column info of the cursor item
[$sel:_sciColInfo:StreamCursorItem] :: StreamCursorItem (b :: BackendType) -> ColumnInfo b

-- | Initial value of the cursor item from where the streaming should start
[$sel:_sciInitialValue:StreamCursorItem] :: StreamCursorItem (b :: BackendType) -> ColumnValue b

-- | captures a remote relationship's selection and the necessary context
data RemoteRelationshipSelect b r
RemoteRelationshipSelect :: HashMap FieldName (DBJoinField b) -> r -> RemoteRelationshipSelect b r

-- | The fields on the table that are required for the join condition of
--   the remote relationship
[$sel:_rrsLHSJoinFields:RemoteRelationshipSelect] :: RemoteRelationshipSelect b r -> HashMap FieldName (DBJoinField b)

-- | The field that captures the relationship r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
[$sel:_rrsRelationship:RemoteRelationshipSelect] :: RemoteRelationshipSelect b r -> r
data AnnFieldG (b :: BackendType) (r :: Type) v
AFColumn :: AnnColumnField b v -> AnnFieldG (b :: BackendType) (r :: Type) v
AFObjectRelation :: ObjectRelationSelectG b r v -> AnnFieldG (b :: BackendType) (r :: Type) v
AFArrayRelation :: ArraySelectG b r v -> AnnFieldG (b :: BackendType) (r :: Type) v
AFComputedField :: XComputedField b -> ComputedFieldName -> ComputedFieldSelect b r v -> AnnFieldG (b :: BackendType) (r :: Type) v

-- | A remote relationship field
AFRemote :: RemoteRelationshipSelect b r -> AnnFieldG (b :: BackendType) (r :: Type) v
AFNodeId :: XRelay b -> SourceName -> TableName b -> PrimaryKeyColumns b -> AnnFieldG (b :: BackendType) (r :: Type) v
AFExpression :: Text -> AnnFieldG (b :: BackendType) (r :: Type) v
type AnnField b = AnnFieldG b Void (SQLExpression b)
type AnnFields b = AnnFieldsG b Void (SQLExpression b)
mkAnnColumnField :: Column backend -> ColumnType backend -> Maybe (AnnColumnCaseBoolExp backend v) -> Maybe (ScalarSelectionArguments backend) -> AnnFieldG backend r v
mkAnnColumnFieldAsText :: ColumnInfo backend -> AnnFieldG backend r v
traverseSourceRelationshipSelection :: (Applicative f, Backend backend) => (vf backend -> f (vg backend)) -> SourceRelationshipSelection backend r vf -> f (SourceRelationshipSelection backend r vg)
data TableAggregateFieldG (b :: BackendType) (r :: Type) v
TAFAgg :: AggregateFields b -> TableAggregateFieldG (b :: BackendType) (r :: Type) v
TAFNodes :: XNodesAgg b -> AnnFieldsG b r v -> TableAggregateFieldG (b :: BackendType) (r :: Type) v
TAFExp :: Text -> TableAggregateFieldG (b :: BackendType) (r :: Type) v
data AggregateField (b :: BackendType)
AFCount :: CountType b -> AggregateField (b :: BackendType)
AFOp :: AggregateOp b -> AggregateField (b :: BackendType)
AFExp :: Text -> AggregateField (b :: BackendType)
data AggregateOp (b :: BackendType)
AggregateOp :: Text -> ColumnFields b -> AggregateOp (b :: BackendType)
[$sel:_aoOp:AggregateOp] :: AggregateOp (b :: BackendType) -> Text
[$sel:_aoFields:AggregateOp] :: AggregateOp (b :: BackendType) -> ColumnFields b
data ColFld (b :: BackendType)
CFCol :: Column b -> ColumnType b -> ColFld (b :: BackendType)
CFExp :: Text -> ColFld (b :: BackendType)
type TableAggregateField b = TableAggregateFieldG b Void (SQLExpression b)
type TableAggregateFields b = TableAggregateFieldsG b Void (SQLExpression b)
type TableAggregateFieldsG b r v = Fields (TableAggregateFieldG b r v)
type ColumnFields b = Fields (ColFld b)
type AggregateFields b = Fields (AggregateField b)
type AnnFieldsG b r v = Fields (AnnFieldG b r v)
data ConnectionField (b :: BackendType) (r :: Type) v
ConnectionTypename :: Text -> ConnectionField (b :: BackendType) (r :: Type) v
ConnectionPageInfo :: PageInfoFields -> ConnectionField (b :: BackendType) (r :: Type) v
ConnectionEdges :: EdgeFields b r v -> ConnectionField (b :: BackendType) (r :: Type) v
data PageInfoField
PageInfoTypename :: Text -> PageInfoField
PageInfoHasNextPage :: PageInfoField
PageInfoHasPreviousPage :: PageInfoField
PageInfoStartCursor :: PageInfoField
PageInfoEndCursor :: PageInfoField
data EdgeField (b :: BackendType) (r :: Type) v
EdgeTypename :: Text -> EdgeField (b :: BackendType) (r :: Type) v
EdgeCursor :: EdgeField (b :: BackendType) (r :: Type) v
EdgeNode :: AnnFieldsG b r v -> EdgeField (b :: BackendType) (r :: Type) v
type ConnectionFields b r v = Fields (ConnectionField b r v)
type PageInfoFields = Fields PageInfoField
type EdgeFields b r v = Fields (EdgeField b r v)
data AnnColumnField (b :: BackendType) v
AnnColumnField :: Column b -> ColumnType b -> Bool -> Maybe (ScalarSelectionArguments b) -> Maybe (AnnColumnCaseBoolExp b v) -> AnnColumnField (b :: BackendType) v
[$sel:_acfColumn:AnnColumnField] :: AnnColumnField (b :: BackendType) v -> Column b
[$sel:_acfType:AnnColumnField] :: AnnColumnField (b :: BackendType) v -> ColumnType b

-- | If this field is <a>True</a>, columns are explicitly casted to
--   <tt>text</tt> when fetched, which avoids an issue that occurs because
--   we don’t currently have proper support for array types. See
--   <a>https://github.com/hasura/graphql-engine/pull/3198</a> for more
--   details.
[$sel:_acfAsText:AnnColumnField] :: AnnColumnField (b :: BackendType) v -> Bool

-- | Arguments of this column's selection. See
--   <a>ScalarSelectionArguments</a>
[$sel:_acfArguments:AnnColumnField] :: AnnColumnField (b :: BackendType) v -> Maybe (ScalarSelectionArguments b)

-- | This type is used to determine whether the column should be nullified.
--   When the value is <a>Nothing</a>, the column value will be outputted
--   as computed and when the value is `Just c`, the column will be
--   outputted when <tt>c</tt> evaluates to <tt>true</tt> and <a>null</a>
--   when <tt>c</tt> evaluates to <tt>false</tt>.
[$sel:_acfCaseBoolExpression:AnnColumnField] :: AnnColumnField (b :: BackendType) v -> Maybe (AnnColumnCaseBoolExp b v)
data ComputedFieldScalarSelect (b :: BackendType) v
ComputedFieldScalarSelect :: FunctionName b -> FunctionArgsExp b v -> ScalarType b -> Maybe (ScalarSelectionArguments b) -> ComputedFieldScalarSelect (b :: BackendType) v
[$sel:_cfssFunction:ComputedFieldScalarSelect] :: ComputedFieldScalarSelect (b :: BackendType) v -> FunctionName b
[$sel:_cfssArguments:ComputedFieldScalarSelect] :: ComputedFieldScalarSelect (b :: BackendType) v -> FunctionArgsExp b v
[$sel:_cfssType:ComputedFieldScalarSelect] :: ComputedFieldScalarSelect (b :: BackendType) v -> ScalarType b
[$sel:_cfssScalarArguments:ComputedFieldScalarSelect] :: ComputedFieldScalarSelect (b :: BackendType) v -> Maybe (ScalarSelectionArguments b)
data ComputedFieldSelect (b :: BackendType) (r :: Type) v
CFSScalar :: ComputedFieldScalarSelect b v -> Maybe (AnnColumnCaseBoolExp b v) -> ComputedFieldSelect (b :: BackendType) (r :: Type) v
CFSTable :: JsonAggSelect -> AnnSimpleSelectG b r v -> ComputedFieldSelect (b :: BackendType) (r :: Type) v
data AnnRelationSelectG (b :: BackendType) a
AnnRelationSelectG :: RelName -> HashMap (Column b) (Column b) -> a -> AnnRelationSelectG (b :: BackendType) a
[$sel:_aarRelationshipName:AnnRelationSelectG] :: AnnRelationSelectG (b :: BackendType) a -> RelName
[$sel:_aarColumnMapping:AnnRelationSelectG] :: AnnRelationSelectG (b :: BackendType) a -> HashMap (Column b) (Column b)
[$sel:_aarAnnSelect:AnnRelationSelectG] :: AnnRelationSelectG (b :: BackendType) a -> a
type ArrayRelationSelectG b r v = AnnRelationSelectG b (AnnSimpleSelectG b r v)
type ArrayAggregateSelectG b r v = AnnRelationSelectG b (AnnAggregateSelectG b r v)
type ArrayConnectionSelect b r v = AnnRelationSelectG b (ConnectionSelect b r v)
type ArrayAggregateSelect b = ArrayAggregateSelectG b Void (SQLExpression b)
data AnnObjectSelectG (b :: BackendType) (r :: Type) v
AnnObjectSelectG :: AnnFieldsG b r v -> TableName b -> AnnBoolExp b v -> AnnObjectSelectG (b :: BackendType) (r :: Type) v
[$sel:_aosFields:AnnObjectSelectG] :: AnnObjectSelectG (b :: BackendType) (r :: Type) v -> AnnFieldsG b r v
[$sel:_aosTableFrom:AnnObjectSelectG] :: AnnObjectSelectG (b :: BackendType) (r :: Type) v -> TableName b
[$sel:_aosTableFilter:AnnObjectSelectG] :: AnnObjectSelectG (b :: BackendType) (r :: Type) v -> AnnBoolExp b v
type AnnObjectSelect b r = AnnObjectSelectG b r (SQLExpression b)
type ObjectRelationSelectG b r v = AnnRelationSelectG b (AnnObjectSelectG b r v)
type ObjectRelationSelect b = ObjectRelationSelectG b Void (SQLExpression b)
data ArraySelectG (b :: BackendType) (r :: Type) v
ASSimple :: ArrayRelationSelectG b r v -> ArraySelectG (b :: BackendType) (r :: Type) v
ASAggregate :: ArrayAggregateSelectG b r v -> ArraySelectG (b :: BackendType) (r :: Type) v
ASConnection :: ArrayConnectionSelect b r v -> ArraySelectG (b :: BackendType) (r :: Type) v
type ArraySelect b = ArraySelectG b Void (SQLExpression b)
type ArraySelectFieldsG b r v = Fields (ArraySelectG b r v)

-- | Captures the selection set of a remote source relationship.
data SourceRelationshipSelection (b :: BackendType) (r :: Type) (vf :: BackendType -> Type)
SourceRelationshipObject :: AnnObjectSelectG b r (vf b) -> SourceRelationshipSelection (b :: BackendType) (r :: Type) (vf :: BackendType -> Type)
SourceRelationshipArray :: AnnSimpleSelectG b r (vf b) -> SourceRelationshipSelection (b :: BackendType) (r :: Type) (vf :: BackendType -> Type)
SourceRelationshipArrayAggregate :: AnnAggregateSelectG b r (vf b) -> SourceRelationshipSelection (b :: BackendType) (r :: Type) (vf :: BackendType -> Type)

-- | A relationship to a remote source. <tt>vf</tt> (could use a better
--   name) is analogous to <tt>v</tt> in other IR types such as
--   <a>AnnFieldG</a>. vf's kind is (BackendType -&gt; Type) instead of v's
--   <a>Type</a> so that <tt>v</tt> of <a>AnnFieldG</a> can be specific to
--   the backend that it captures (<tt>b</tt> of an AnnFieldG changes as we
--   walk down the IR branches which capture relationships to other
--   databases)
data RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType)
RemoteSourceSelect :: SourceName -> SourceConfig tgt -> SourceRelationshipSelection tgt r vf -> HashMap FieldName (ScalarType tgt, Column tgt) -> RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType)
[$sel:_rssName:RemoteSourceSelect] :: RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType) -> SourceName
[$sel:_rssConfig:RemoteSourceSelect] :: RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType) -> SourceConfig tgt
[$sel:_rssSelection:RemoteSourceSelect] :: RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType) -> SourceRelationshipSelection tgt r vf

-- | Additional information about the source's join columns: (ScalarType
--   tgt) so that the remote can interpret the join values coming from src
--   (Column tgt) so that an appropriate join condition / IN clause can be
--   built by the remote
[$sel:_rssJoinMapping:RemoteSourceSelect] :: RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType) -> HashMap FieldName (ScalarType tgt, Column tgt)
data TablePermG (b :: BackendType) v
TablePerm :: AnnBoolExp b v -> Maybe Int -> TablePermG (b :: BackendType) v
[$sel:_tpFilter:TablePerm] :: TablePermG (b :: BackendType) v -> AnnBoolExp b v
[$sel:_tpLimit:TablePerm] :: TablePermG (b :: BackendType) v -> Maybe Int
type TablePerm b = TablePermG b (SQLExpression b)
noTablePermissions :: TablePermG backend v

-- | If argument positional index is less than or equal to length of
--   <tt>positional</tt> arguments then insert the value in
--   <tt>positional</tt> arguments else insert the value with argument name
--   in <tt>named</tt> arguments
insertFunctionArg :: FunctionArgName -> Int -> a -> FunctionArgsExpG a -> FunctionArgsExpG a

-- | The "distinct" input field inside "count" aggregate field
--   
--   count ( distinct: Boolean ): Int
data CountDistinct
SelectCountDistinct :: CountDistinct
SelectCountNonDistinct :: CountDistinct
asnStrfyNum :: forall b_ap4t1 f_ap4t2 v_ap4t3. Lens' (AnnSelectG b_ap4t1 f_ap4t2 v_ap4t3) StringifyNumbers
asnPerm :: forall b_ap4t1 f_ap4t2 v_ap4t3. Lens' (AnnSelectG b_ap4t1 f_ap4t2 v_ap4t3) (TablePermG b_ap4t1 v_ap4t3)
asnNamingConvention :: forall b_ap4t1 f_ap4t2 v_ap4t3. Lens' (AnnSelectG b_ap4t1 f_ap4t2 v_ap4t3) (Maybe NamingCase)
asnFrom :: forall b_ap4t1 f_ap4t2 v_ap4t3. Lens' (AnnSelectG b_ap4t1 f_ap4t2 v_ap4t3) (SelectFromG b_ap4t1 v_ap4t3)
asnFields :: forall b_ap4t1 f_ap4t2 v_ap4t3 f_apVou. Lens (AnnSelectG b_ap4t1 f_ap4t2 v_ap4t3) (AnnSelectG b_ap4t1 f_apVou v_ap4t3) (Fields (f_ap4t2 v_ap4t3)) (Fields (f_apVou v_ap4t3))
asnArgs :: forall b_ap4t1 f_ap4t2 v_ap4t3. Lens' (AnnSelectG b_ap4t1 f_ap4t2 v_ap4t3) (SelectArgsG b_ap4t1 v_ap4t3)
aosTableFrom :: forall b_ap4rs r_ap4rt v_ap4ru. Lens' (AnnObjectSelectG b_ap4rs r_ap4rt v_ap4ru) (TableName b_ap4rs)
aosTableFilter :: forall b_ap4rs r_ap4rt v_ap4ru. Lens' (AnnObjectSelectG b_ap4rs r_ap4rt v_ap4ru) (AnnBoolExp b_ap4rs v_ap4ru)
aosFields :: forall b_ap4rs r_ap4rt v_ap4ru r_apVsZ. Lens (AnnObjectSelectG b_ap4rs r_ap4rt v_ap4ru) (AnnObjectSelectG b_ap4rs r_apVsZ v_ap4ru) (AnnFieldsG b_ap4rs r_ap4rt v_ap4ru) (AnnFieldsG b_ap4rs r_apVsZ v_ap4ru)
aarRelationshipName :: forall b_ap4rF a_ap4rG. Lens' (AnnRelationSelectG b_ap4rF a_ap4rG) RelName
aarColumnMapping :: forall b_ap4rF a_ap4rG b_apVvj. Lens (AnnRelationSelectG b_ap4rF a_ap4rG) (AnnRelationSelectG b_apVvj a_ap4rG) (HashMap (Column b_ap4rF) (Column b_ap4rF)) (HashMap (Column b_apVvj) (Column b_apVvj))
aarAnnSelect :: forall b_ap4rF a_ap4rG a_apVvi. Lens (AnnRelationSelectG b_ap4rF a_ap4rG) (AnnRelationSelectG b_ap4rF a_apVvi) a_ap4rG a_apVvi
csXRelay :: forall b_ap4sJ r_ap4sK v_ap4sL. Lens' (ConnectionSelect b_ap4sJ r_ap4sK v_ap4sL) (XRelay b_ap4sJ)
csSplit :: forall b_ap4sJ r_ap4sK v_ap4sL. Lens' (ConnectionSelect b_ap4sJ r_ap4sK v_ap4sL) (Maybe (NonEmpty (ConnectionSplit b_ap4sJ v_ap4sL)))
csSlice :: forall b_ap4sJ r_ap4sK v_ap4sL. Lens' (ConnectionSelect b_ap4sJ r_ap4sK v_ap4sL) (Maybe ConnectionSlice)
csSelect :: forall b_ap4sJ r_ap4sK v_ap4sL r_apVxw. Lens (ConnectionSelect b_ap4sJ r_ap4sK v_ap4sL) (ConnectionSelect b_ap4sJ r_apVxw v_ap4sL) (AnnSelectG b_ap4sJ (ConnectionField b_ap4sJ r_ap4sK) v_ap4sL) (AnnSelectG b_ap4sJ (ConnectionField b_ap4sJ r_apVxw) v_ap4sL)
csPrimaryKeyColumns :: forall b_ap4sJ r_ap4sK v_ap4sL. Lens' (ConnectionSelect b_ap4sJ r_ap4sK v_ap4sL) (PrimaryKeyColumns b_ap4sJ)
saWhere :: forall b_ap4sz v_ap4sA. Lens' (SelectArgsG b_ap4sz v_ap4sA) (Maybe (AnnBoolExp b_ap4sz v_ap4sA))
saOrderBy :: forall b_ap4sz v_ap4sA. Lens' (SelectArgsG b_ap4sz v_ap4sA) (Maybe (NonEmpty (AnnotatedOrderByItemG b_ap4sz v_ap4sA)))
saOffset :: forall b_ap4sz v_ap4sA. Lens' (SelectArgsG b_ap4sz v_ap4sA) (Maybe Int64)
saLimit :: forall b_ap4sz v_ap4sA. Lens' (SelectArgsG b_ap4sz v_ap4sA) (Maybe Int)
saDistinct :: forall b_ap4sz v_ap4sA. Lens' (SelectArgsG b_ap4sz v_ap4sA) (Maybe (NonEmpty (Column b_ap4sz)))
_AFExpression :: forall b_ap4si r_ap4sj v_ap4sk. Prism' (AnnFieldG b_ap4si r_ap4sj v_ap4sk) Text
_AFNodeId :: forall b_ap4si r_ap4sj v_ap4sk. Prism' (AnnFieldG b_ap4si r_ap4sj v_ap4sk) (XRelay b_ap4si, SourceName, TableName b_ap4si, PrimaryKeyColumns b_ap4si)
_AFRemote :: forall b_ap4si r_ap4sj v_ap4sk. Prism' (AnnFieldG b_ap4si r_ap4sj v_ap4sk) (RemoteRelationshipSelect b_ap4si r_ap4sj)
_AFComputedField :: forall b_ap4si r_ap4sj v_ap4sk. Prism' (AnnFieldG b_ap4si r_ap4sj v_ap4sk) (XComputedField b_ap4si, ComputedFieldName, ComputedFieldSelect b_ap4si r_ap4sj v_ap4sk)
_AFArrayRelation :: forall b_ap4si r_ap4sj v_ap4sk. Prism' (AnnFieldG b_ap4si r_ap4sj v_ap4sk) (ArraySelectG b_ap4si r_ap4sj v_ap4sk)
_AFObjectRelation :: forall b_ap4si r_ap4sj v_ap4sk. Prism' (AnnFieldG b_ap4si r_ap4sj v_ap4sk) (ObjectRelationSelectG b_ap4si r_ap4sj v_ap4sk)
_AFColumn :: forall b_ap4si r_ap4sj v_ap4sk. Prism' (AnnFieldG b_ap4si r_ap4sj v_ap4sk) (AnnColumnField b_ap4si v_ap4sk)
_AOCComputedField :: forall b_ap4ss v_ap4st. Prism' (AnnotatedOrderByElement b_ap4ss v_ap4st) (ComputedFieldOrderBy b_ap4ss v_ap4st)
_AOCArrayAggregation :: forall b_ap4ss v_ap4st. Prism' (AnnotatedOrderByElement b_ap4ss v_ap4st) (RelInfo b_ap4ss, AnnBoolExp b_ap4ss v_ap4st, AnnotatedAggregateOrderBy b_ap4ss)
_AOCObjectRelation :: forall b_ap4ss v_ap4st. Prism' (AnnotatedOrderByElement b_ap4ss v_ap4st) (RelInfo b_ap4ss, AnnBoolExp b_ap4ss v_ap4st, AnnotatedOrderByElement b_ap4ss v_ap4st)
_AOCColumn :: forall b_ap4ss v_ap4st. Prism' (AnnotatedOrderByElement b_ap4ss v_ap4st) (ColumnInfo b_ap4ss)
_TAFExp :: forall b_ap4sd r_ap4se v_ap4sf. Prism' (TableAggregateFieldG b_ap4sd r_ap4se v_ap4sf) Text
_TAFNodes :: forall b_ap4sd r_apVQN v_apVQO r_ap4se v_ap4sf. Prism (TableAggregateFieldG b_ap4sd r_apVQN v_apVQO) (TableAggregateFieldG b_ap4sd r_ap4se v_ap4sf) (XNodesAgg b_ap4sd, AnnFieldsG b_ap4sd r_apVQN v_apVQO) (XNodesAgg b_ap4sd, AnnFieldsG b_ap4sd r_ap4se v_ap4sf)
_TAFAgg :: forall b_ap4sd r_ap4se v_ap4sf. Prism' (TableAggregateFieldG b_ap4sd r_ap4se v_ap4sf) (AggregateFields b_ap4sd)
_ConnectionEdges :: forall b_apVUw r_apVUx v_apVUy b_ap4rX r_ap4rY v_ap4rZ. Prism (ConnectionField b_apVUw r_apVUx v_apVUy) (ConnectionField b_ap4rX r_ap4rY v_ap4rZ) (EdgeFields b_apVUw r_apVUx v_apVUy) (EdgeFields b_ap4rX r_ap4rY v_ap4rZ)
_ConnectionPageInfo :: forall b_ap4rX r_ap4rY v_ap4rZ. Prism' (ConnectionField b_ap4rX r_ap4rY v_ap4rZ) PageInfoFields
_ConnectionTypename :: forall b_ap4rX r_ap4rY v_ap4rZ. Prism' (ConnectionField b_ap4rX r_ap4rY v_ap4rZ) Text
_EdgeNode :: forall b_apVY3 r_apVY4 v_apVY5 b_ap4rU r_ap4rV v_ap4rW. Prism (EdgeField b_apVY3 r_apVY4 v_apVY5) (EdgeField b_ap4rU r_ap4rV v_ap4rW) (AnnFieldsG b_apVY3 r_apVY4 v_apVY5) (AnnFieldsG b_ap4rU r_ap4rV v_ap4rW)
_EdgeCursor :: forall b_ap4rU r_ap4rV v_ap4rW. Prism' (EdgeField b_ap4rU r_ap4rV v_ap4rW) ()
_EdgeTypename :: forall b_ap4rU r_ap4rV v_ap4rW. Prism' (EdgeField b_ap4rU r_ap4rV v_ap4rW) Text
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.Select.ConnectionSlice
instance GHC.Generics.Generic Hasura.RQL.IR.Select.ConnectionSlice
instance GHC.Classes.Eq Hasura.RQL.IR.Select.ConnectionSlice
instance GHC.Show.Show Hasura.RQL.IR.Select.ConnectionSlice
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.Select.ConnectionSplitKind
instance GHC.Generics.Generic Hasura.RQL.IR.Select.ConnectionSplitKind
instance GHC.Classes.Eq Hasura.RQL.IR.Select.ConnectionSplitKind
instance GHC.Show.Show Hasura.RQL.IR.Select.ConnectionSplitKind
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.Select.FIIdentifier
instance GHC.Show.Show Hasura.RQL.IR.Select.FIIdentifier
instance GHC.Classes.Eq Hasura.RQL.IR.Select.FIIdentifier
instance GHC.Generics.Generic Hasura.RQL.IR.Select.FIIdentifier
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.SelectFromG b v)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.AnnotatedAggregateOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ComputedFieldOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ComputedFieldOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ComputedFieldOrderByElement b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.ComputedFieldOrderByElement b v)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.ComputedFieldOrderBy b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnotatedOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnotatedOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnotatedOrderByElement b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.AnnotatedOrderByElement b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ConnectionSplit b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ConnectionSplit b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.ConnectionSplit b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ConnectionSplit b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.SelectArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.SelectArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.SelectArgsG b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.SelectArgsG b v)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.StreamCursorItem b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.SelectStreamArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.SelectStreamArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.SelectStreamArgsG b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.SelectStreamArgsG b v)
instance Data.Traversable.Traversable (Hasura.RQL.IR.Select.RemoteRelationshipSelect b)
instance Data.Foldable.Foldable (Hasura.RQL.IR.Select.RemoteRelationshipSelect b)
instance GHC.Base.Functor (Hasura.RQL.IR.Select.RemoteRelationshipSelect b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show r) => GHC.Show.Show (Hasura.RQL.IR.Select.RemoteRelationshipSelect b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.Select.RemoteRelationshipSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.Select.ColFld b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.Select.ColFld b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.Select.AggregateOp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.Select.AggregateOp b)
instance GHC.Classes.Eq Hasura.RQL.IR.Select.PageInfoField
instance GHC.Show.Show Hasura.RQL.IR.Select.PageInfoField
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnColumnField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnColumnField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnColumnField b)
instance Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnRelationSelectG b)
instance Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnRelationSelectG b)
instance GHC.Base.Functor (Hasura.RQL.IR.Select.AnnRelationSelectG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.TablePermG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.TablePermG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.TablePermG b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.TablePermG b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Traversable.Traversable f) => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnSelectStreamG b f)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Foldable.Foldable f) => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnSelectStreamG b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Base.Functor f) => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnSelectStreamG b f)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Traversable.Traversable f) => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnSelectG b f)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Foldable.Foldable f) => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnSelectG b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Base.Functor f) => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnSelectG b f)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ComputedFieldSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ComputedFieldSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ComputedFieldSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.TableAggregateFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.TableAggregateFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.TableAggregateFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.EdgeField b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.EdgeField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.EdgeField b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ConnectionField b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ConnectionField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ConnectionField b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ConnectionSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ConnectionSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ConnectionSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.QueryDB b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.QueryDB b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.QueryDB b r)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.QueryDB b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Common.Fields (f v)), GHC.Classes.Eq (Hasura.RQL.IR.Select.SelectArgsG b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.SelectFromG b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.TablePermG b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSelectG b f v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Common.Fields (f v)), GHC.Show.Show (Hasura.RQL.IR.Select.SelectArgsG b v), GHC.Show.Show (Hasura.RQL.IR.Select.SelectFromG b v), GHC.Show.Show (Hasura.RQL.IR.Select.TablePermG b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnSelectG b f v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.SelectFromG b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.TablePermG b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.SelectStreamArgsG b v), GHC.Classes.Eq (f v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSelectStreamG b f v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.SelectFromG b v), GHC.Show.Show (Hasura.RQL.IR.Select.TablePermG b v), GHC.Show.Show (Hasura.RQL.IR.Select.SelectStreamArgsG b v), GHC.Show.Show (f v)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnSelectStreamG b f v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSelectG b (Hasura.RQL.IR.Select.ConnectionField b r) v), GHC.Classes.Eq Hasura.RQL.IR.Select.ConnectionSlice, GHC.Classes.Eq (Hasura.RQL.IR.Select.ConnectionSplit b v), GHC.Classes.Eq (Hasura.RQL.Types.Column.PrimaryKeyColumns b)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ConnectionSelect b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AnnSelectG b (Hasura.RQL.IR.Select.ConnectionField b r) v), GHC.Show.Show Hasura.RQL.IR.Select.ConnectionSlice, GHC.Show.Show (Hasura.RQL.IR.Select.ConnectionSplit b v), GHC.Show.Show (Hasura.RQL.Types.Column.PrimaryKeyColumns b)) => GHC.Show.Show (Hasura.RQL.IR.Select.ConnectionSelect b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq (Hasura.RQL.IR.OrderBy.OrderByItemG b (Hasura.RQL.IR.Select.AnnotatedOrderByElement b v))) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ConnectionSplit b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v, GHC.Show.Show (Hasura.RQL.IR.OrderBy.OrderByItemG b (Hasura.RQL.IR.Select.AnnotatedOrderByElement b v))) => GHC.Show.Show (Hasura.RQL.IR.Select.ConnectionSplit b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.SelectFromG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.SelectFromG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.SelectFromG b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq (Hasura.RQL.Types.Backend.FunctionArgumentExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.SelectFromG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v, GHC.Show.Show (Hasura.RQL.Types.Backend.FunctionArgumentExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.SelectFromG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.SelectStreamArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show v) => GHC.Show.Show (Hasura.RQL.IR.Select.SelectStreamArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnotatedOrderByItemG b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.SelectArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnotatedOrderByItemG b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.SelectArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnotatedAggregateOrderBy b)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnotatedAggregateOrderBy b)) => GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldOrderByElement b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ComputedFieldOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ComputedFieldOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ComputedFieldOrderBy b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldOrderByElement b v), GHC.Classes.Eq (Hasura.RQL.Types.Function.FunctionArgsExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldOrderByElement b v), GHC.Show.Show (Hasura.RQL.Types.Function.FunctionArgsExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnotatedAggregateOrderBy b), GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldOrderBy b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnotatedOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnotatedAggregateOrderBy b), GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldOrderBy b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnotatedOrderByElement b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnotatedAggregateOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.Select.AnnotatedAggregateOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.Select.StreamCursorItem b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.Select.StreamCursorItem b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnColumnField b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ArraySelectG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldSelect b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ObjectRelationSelectG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.RemoteRelationshipSelect b r)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AnnColumnField b v), GHC.Show.Show (Hasura.RQL.IR.Select.ArraySelectG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldSelect b r v), GHC.Show.Show (Hasura.RQL.IR.Select.ObjectRelationSelectG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.RemoteRelationshipSelect b r)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AggregateFields b), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.TableAggregateFieldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AggregateFields b), GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Select.TableAggregateFieldG b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.Select.AggregateField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.Select.AggregateField b)
instance GHC.Classes.Eq (Hasura.RQL.IR.Select.EdgeFields b r v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ConnectionField b r v)
instance GHC.Show.Show (Hasura.RQL.IR.Select.EdgeFields b r v) => GHC.Show.Show (Hasura.RQL.IR.Select.ConnectionField b r v)
instance GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldsG b r v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.EdgeField b r v)
instance GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldsG b r v) => GHC.Show.Show (Hasura.RQL.IR.Select.EdgeField b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExp b v), GHC.Classes.Eq (Hasura.RQL.Types.Backend.ScalarSelectionArguments b)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnColumnField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExp b v), GHC.Show.Show (Hasura.RQL.Types.Backend.ScalarSelectionArguments b)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnColumnField b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v, GHC.Show.Show (Hasura.RQL.Types.Backend.FunctionArgumentExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq (Hasura.RQL.Types.Backend.FunctionArgumentExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExp b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSimpleSelectG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldSelect b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnColumnCaseBoolExp b v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnSimpleSelectG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldSelect b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnRelationSelectG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnRelationSelectG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnObjectSelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnObjectSelectG b r v)
instance (GHC.Classes.Eq (Hasura.RQL.IR.Select.ArrayRelationSelectG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ArrayAggregateSelectG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ArrayConnectionSelect b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ArraySelectG b r v)
instance (GHC.Show.Show (Hasura.RQL.IR.Select.ArrayRelationSelectG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.ArrayAggregateSelectG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.ArrayConnectionSelect b r v)) => GHC.Show.Show (Hasura.RQL.IR.Select.ArraySelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnAggregateSelectG b r (vf b)), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnObjectSelectG b r (vf b)), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSimpleSelectG b r (vf b))) => GHC.Classes.Eq (Hasura.RQL.IR.Select.SourceRelationshipSelection b r vf)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AnnAggregateSelectG b r (vf b)), GHC.Show.Show (Hasura.RQL.IR.Select.AnnObjectSelectG b r (vf b)), GHC.Show.Show (Hasura.RQL.IR.Select.AnnSimpleSelectG b r (vf b))) => GHC.Show.Show (Hasura.RQL.IR.Select.SourceRelationshipSelection b r vf)
instance (Hasura.RQL.Types.Backend.Backend tgt, GHC.Classes.Eq (Hasura.RQL.IR.Select.SourceRelationshipSelection tgt r vf)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.RemoteSourceSelect r vf tgt)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.TablePermG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.TablePermG b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.QueryDB b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ConnectionSelect b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.AnnFieldG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.TableAggregateFieldG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ConnectionField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.EdgeField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ComputedFieldSelect b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.AnnObjectSelectG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ArraySelectG b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.TablePermG b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.AnnotatedOrderByItemG b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.SelectArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v, Data.Hashable.Class.Hashable (Hasura.RQL.IR.OrderBy.OrderByItemG b (Hasura.RQL.IR.Select.AnnotatedOrderByElement b v))) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.ConnectionSplit b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.AnnotatedAggregateOrderBy b), Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.ComputedFieldOrderBy b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.AnnotatedOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.ComputedFieldOrderByElement b v), Data.Hashable.Class.Hashable (Hasura.RQL.Types.Function.FunctionArgsExp b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.ComputedFieldOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.AnnotatedAggregateOrderBy b)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.ComputedFieldOrderByElement b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.AnnotatedAggregateOrderBy b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v, Data.Hashable.Class.Hashable (Hasura.RQL.Types.Backend.FunctionArgumentExp b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.SelectFromG b v)
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.RQL.IR.Select.FIIdentifier

module Hasura.RQL.IR.Returning
data MutFldG (b :: BackendType) (r :: Type) v
MCount :: MutFldG (b :: BackendType) (r :: Type) v
MExp :: Text -> MutFldG (b :: BackendType) (r :: Type) v
MRet :: AnnFieldsG b r v -> MutFldG (b :: BackendType) (r :: Type) v
type MutFld b = MutFldG b Void (SQLExpression b)
type MutFldsG b r v = Fields (MutFldG b r v)
data MutationOutputG (b :: BackendType) (r :: Type) v
MOutMultirowFields :: MutFldsG b r v -> MutationOutputG (b :: BackendType) (r :: Type) v
MOutSinglerowObject :: AnnFieldsG b r v -> MutationOutputG (b :: BackendType) (r :: Type) v
type MutationOutput b = MutationOutputG b Void (SQLExpression b)
type MutFlds b = MutFldsG b Void (SQLExpression b)
buildEmptyMutResp :: MutationOutput backend -> EncJSON
hasNestedFld :: MutationOutputG backend r a -> Bool
_MRet :: forall b_aqTlo r_aqTlp v_aqTlq b_aqQHA r_aqQHB v_aqQHC. Prism (MutFldG b_aqTlo r_aqTlp v_aqTlq) (MutFldG b_aqQHA r_aqQHB v_aqQHC) (AnnFieldsG b_aqTlo r_aqTlp v_aqTlq) (AnnFieldsG b_aqQHA r_aqQHB v_aqQHC)
_MExp :: forall b_aqQHA r_aqQHB v_aqQHC. Prism' (MutFldG b_aqQHA r_aqQHB v_aqQHC) Text
_MCount :: forall b_aqQHA r_aqQHB v_aqQHC. Prism' (MutFldG b_aqQHA r_aqQHB v_aqQHC) ()
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Returning.MutFldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Returning.MutFldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Returning.MutFldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Returning.MutationOutputG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Returning.MutationOutputG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Returning.MutationOutputG b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Returning.MutFldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Returning.MutFldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Returning.MutFldsG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Returning.MutationOutputG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Returning.MutFldsG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Returning.MutationOutputG b r v)

module Hasura.RQL.IR.Update
data AnnotatedUpdateG (b :: BackendType) (r :: Type) v
AnnotatedUpdateG :: TableName b -> (AnnBoolExp b v, AnnBoolExp b v) -> AnnBoolExp b v -> BackendUpdate b v -> MutationOutputG b r v -> [ColumnInfo b] -> Maybe NamingCase -> AnnotatedUpdateG (b :: BackendType) (r :: Type) v
[_auTable] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> TableName b

-- | The where clause for <i>update_table</i> and <i>update_table_by_pk</i>
--   along with the permissions filter. In the case of
--   <i>update_table_many</i>, this will be empty and the actual where
--   clauses (one per update) are found in <a>BackendUpdate</a>.
[_auWhere] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> (AnnBoolExp b v, AnnBoolExp b v)
[_auCheck] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> AnnBoolExp b v

-- | All the backend-specific data related to an update mutation
[_auBackend] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> BackendUpdate b v

-- | Selection set
[_auOutput] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> MutationOutputG b r v
[_auAllCols] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> [ColumnInfo b]
[_auNamingConvention] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> Maybe NamingCase
type AnnotatedUpdate b = AnnotatedUpdateG b Void (SQLExpression b)
auWhere :: forall b_aqXge r_aqXgf v_aqXgg. Lens' (AnnotatedUpdateG b_aqXge r_aqXgf v_aqXgg) (AnnBoolExp b_aqXge v_aqXgg, AnnBoolExp b_aqXge v_aqXgg)
auTable :: forall b_aqXge r_aqXgf v_aqXgg. Lens' (AnnotatedUpdateG b_aqXge r_aqXgf v_aqXgg) (TableName b_aqXge)
auOutput :: forall b_aqXge r_aqXgf v_aqXgg r_aqYGd. Lens (AnnotatedUpdateG b_aqXge r_aqXgf v_aqXgg) (AnnotatedUpdateG b_aqXge r_aqYGd v_aqXgg) (MutationOutputG b_aqXge r_aqXgf v_aqXgg) (MutationOutputG b_aqXge r_aqYGd v_aqXgg)
auNamingConvention :: forall b_aqXge r_aqXgf v_aqXgg. Lens' (AnnotatedUpdateG b_aqXge r_aqXgf v_aqXgg) (Maybe NamingCase)
auCheck :: forall b_aqXge r_aqXgf v_aqXgg. Lens' (AnnotatedUpdateG b_aqXge r_aqXgf v_aqXgg) (AnnBoolExp b_aqXge v_aqXgg)
auBackend :: forall b_aqXge r_aqXgf v_aqXgg. Lens' (AnnotatedUpdateG b_aqXge r_aqXgf v_aqXgg) (BackendUpdate b_aqXge v_aqXgg)
auAllCols :: forall b_aqXge r_aqXgf v_aqXgg. Lens' (AnnotatedUpdateG b_aqXge r_aqXgf v_aqXgg) [ColumnInfo b_aqXge]
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Update.AnnotatedUpdateG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Update.AnnotatedUpdateG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Update.AnnotatedUpdateG b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq (Hasura.RQL.IR.Returning.MutationOutputG b r v), GHC.Classes.Eq (Hasura.RQL.Types.Backend.BackendUpdate b v), GHC.Classes.Eq r, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Update.AnnotatedUpdateG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show (Hasura.RQL.IR.Returning.MutationOutputG b r v), GHC.Show.Show (Hasura.RQL.Types.Backend.BackendUpdate b v), GHC.Show.Show r, GHC.Show.Show v) => GHC.Show.Show (Hasura.RQL.IR.Update.AnnotatedUpdateG b r v)


-- | Internal representation of an insertion in a database table.
--   
--   What makes this specific mutation tricky is that we support recursive
--   insertions, across local relationships. Because local joins come in
--   two different kinds (object relationships and array relations), and
--   because for each table we expose two root different root fields
--   (insert_one and insert), we distinguish between *single row inserts*
--   and *multi rows inserts*.
--   
--   TODO: the distinction between single-row inserts and multi-rows
--   inserts does not need to be enforced the way it currently is, with
--   booleans and different types. The distinction could be made in the
--   translation layer, if need be.
module Hasura.RQL.IR.Insert

-- | Overall representation of an insert mutation, corresponding to one
--   root field in our mutation, including the parsed selection set of the
--   mutation's output. For historical reasons, it will always contain a
--   <a>MultiObjectInsert</a>, whether the root mutation is a single row or
--   not, and will distinguish between them using a boolean field.
data AnnotatedInsert (b :: BackendType) (r :: Type) v
AnnotatedInsert :: Text -> Bool -> MultiObjectInsert b v -> MutationOutputG b r v -> Maybe NamingCase -> AnnotatedInsert (b :: BackendType) (r :: Type) v
[_aiFieldName] :: AnnotatedInsert (b :: BackendType) (r :: Type) v -> Text
[_aiIsSingle] :: AnnotatedInsert (b :: BackendType) (r :: Type) v -> Bool
[_aiData] :: AnnotatedInsert (b :: BackendType) (r :: Type) v -> MultiObjectInsert b v
[_aiOutput] :: AnnotatedInsert (b :: BackendType) (r :: Type) v -> MutationOutputG b r v
[_aiNamingConvention] :: AnnotatedInsert (b :: BackendType) (r :: Type) v -> Maybe NamingCase

-- | One individual insert, one node from the tree. The <tt>f</tt>
--   parameter is used to construct the container for the values to be
--   inserted: <a>Single</a> for a single-row insert, '[]' for a multi-row
--   insert.
data AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type)
AnnotatedInsertData :: f (AnnotatedInsertRow b v) -> TableName b -> (AnnBoolExp b v, Maybe (AnnBoolExp b v)) -> [ColumnInfo b] -> PreSetColsG b v -> BackendInsert b v -> AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type)
[_aiInsertObject] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> f (AnnotatedInsertRow b v)
[_aiTableName] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> TableName b
[_aiCheckCondition] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> (AnnBoolExp b v, Maybe (AnnBoolExp b v))
[_aiTableColumns] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> [ColumnInfo b]
[_aiPresetValues] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> PreSetColsG b v
[_aiBackendInsert] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> BackendInsert b v

-- | Ad-hoc helper. We differientate between single row inserts
--   (<tt>SingleObjIns</tt>) and multiple row inserts
--   (<tt>MultiObjIns</tt>), but both use the same underlying
--   representation: <tt>AnnIns</tt>. The only difference is which functor
--   is used as a parameter. We use '[]' for <tt>MultiObjIns</tt>, and we
--   use this trivial <a>Single</a> for <tt>SingleObjIns</tt>.
newtype Single a
Single :: a -> Single a
[unSingle] :: Single a -> a
type SingleObjectInsert b v = AnnotatedInsertData b Single v
type MultiObjectInsert b v = AnnotatedInsertData b [] v

-- | An insert item. The object and array relationships are not unavailable
--   when 'XNestedInserts b = XDisable'
data AnnotatedInsertField (b :: BackendType) v
AIColumn :: (Column b, v) -> AnnotatedInsertField (b :: BackendType) v
AIObjectRelationship :: XNestedInserts b -> ObjectRelationInsert b v -> AnnotatedInsertField (b :: BackendType) v
AIArrayRelationship :: XNestedInserts b -> ArrayRelationInsert b v -> AnnotatedInsertField (b :: BackendType) v

-- | One individual row to be inserted. Contains the columns' values and
--   all the matching recursive relationship inserts.
type AnnotatedInsertRow b v = [AnnotatedInsertField b v]

-- | One individual relationship. Unlike other types, this one is not
--   parameterized by the type of the leaves <tt>v</tt>, but by the kind of
--   insert has to be performed: multi-row or single row. See
--   <a>ObjectRelationInsert</a> and <a>ArrayRelationInsert</a>.
data RelationInsert (b :: BackendType) a
RelationInsert :: a -> RelInfo b -> RelationInsert (b :: BackendType) a
[_riInsertData] :: RelationInsert (b :: BackendType) a -> a
[_riRelationInfo] :: RelationInsert (b :: BackendType) a -> RelInfo b

-- | Insert across an object relationship. Object relationships are 1:1
--   relationships across tables; an insert across such a relationship can
--   only insert one single row at a time; <tt>RelIns</tt> is therefore
--   parameterized by a <a>SingleObjectInsert</a>.
type ObjectRelationInsert b v = RelationInsert b (SingleObjectInsert b v)

-- | Insert across an array relationship. Array relationships are 1:*
--   relationships across tables; an insert across such a relationship may
--   therefore contain multiple rows; <tt>RelIns</tt> is therefore
--   parameterized by a <a>MultiObjectInsert</a>.
type ArrayRelationInsert b v = RelationInsert b (MultiObjectInsert b v)

-- | Old-style representation used for non-recursive insertions. This is
--   the representation used by RQL.DML, instead of the new fancy recursive
--   one present in this file. Postgres supports both representations, and
--   actually translates recursive queries that do not have any
--   relationships into this representation first.
data InsertQueryP1 (b :: BackendType)
InsertQueryP1 :: TableName b -> [Column b] -> [[SQLExpression b]] -> Maybe (OnConflictClause b (SQLExpression b)) -> (AnnBoolExpSQL b, Maybe (AnnBoolExpSQL b)) -> MutationOutput b -> [ColumnInfo b] -> InsertQueryP1 (b :: BackendType)
[iqp1Table] :: InsertQueryP1 (b :: BackendType) -> TableName b
[iqp1Cols] :: InsertQueryP1 (b :: BackendType) -> [Column b]
[iqp1Tuples] :: InsertQueryP1 (b :: BackendType) -> [[SQLExpression b]]
[iqp1Conflict] :: InsertQueryP1 (b :: BackendType) -> Maybe (OnConflictClause b (SQLExpression b))
[iqp1CheckCond] :: InsertQueryP1 (b :: BackendType) -> (AnnBoolExpSQL b, Maybe (AnnBoolExpSQL b))
[iqp1Output] :: InsertQueryP1 (b :: BackendType) -> MutationOutput b
[iqp1AllCols] :: InsertQueryP1 (b :: BackendType) -> [ColumnInfo b]
aiOutput :: forall b_ar1IL r_ar1IM v_ar1IN r_ar6Xc. Lens (AnnotatedInsert b_ar1IL r_ar1IM v_ar1IN) (AnnotatedInsert b_ar1IL r_ar6Xc v_ar1IN) (MutationOutputG b_ar1IL r_ar1IM v_ar1IN) (MutationOutputG b_ar1IL r_ar6Xc v_ar1IN)
aiNamingConvention :: forall b_ar1IL r_ar1IM v_ar1IN. Lens' (AnnotatedInsert b_ar1IL r_ar1IM v_ar1IN) (Maybe NamingCase)
aiIsSingle :: forall b_ar1IL r_ar1IM v_ar1IN. Lens' (AnnotatedInsert b_ar1IL r_ar1IM v_ar1IN) Bool
aiFieldName :: forall b_ar1IL r_ar1IM v_ar1IN. Lens' (AnnotatedInsert b_ar1IL r_ar1IM v_ar1IN) Text
aiData :: forall b_ar1IL r_ar1IM v_ar1IN. Lens' (AnnotatedInsert b_ar1IL r_ar1IM v_ar1IN) (MultiObjectInsert b_ar1IL v_ar1IN)
_AIArrayRelationship :: forall b_ar1IB v_ar1IC. Prism' (AnnotatedInsertField b_ar1IB v_ar1IC) (XNestedInserts b_ar1IB, ArrayRelationInsert b_ar1IB v_ar1IC)
_AIObjectRelationship :: forall b_ar1IB v_ar1IC. Prism' (AnnotatedInsertField b_ar1IB v_ar1IC) (XNestedInserts b_ar1IB, ObjectRelationInsert b_ar1IB v_ar1IC)
_AIColumn :: forall b_ar1IB v_ar1IC. Prism' (AnnotatedInsertField b_ar1IB v_ar1IC) (Column b_ar1IB, v_ar1IC)
getInsertColumns :: AnnotatedInsertRow b v -> [(Column b, v)]
getInsertObjectRelationships :: AnnotatedInsertRow b v -> [ObjectRelationInsert b v]
getInsertArrayRelationships :: AnnotatedInsertRow b v -> [ArrayRelationInsert b v]
instance Data.Traversable.Traversable Hasura.RQL.IR.Insert.Single
instance Data.Foldable.Foldable Hasura.RQL.IR.Insert.Single
instance GHC.Base.Functor Hasura.RQL.IR.Insert.Single
instance Data.Traversable.Traversable (Hasura.RQL.IR.Insert.RelationInsert b)
instance Data.Foldable.Foldable (Hasura.RQL.IR.Insert.RelationInsert b)
instance GHC.Base.Functor (Hasura.RQL.IR.Insert.RelationInsert b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.Insert.RelationInsert b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.IR.Insert.RelationInsert b a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Insert.AnnotatedInsertField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Insert.AnnotatedInsertField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Insert.AnnotatedInsertField b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Traversable.Traversable f) => Data.Traversable.Traversable (Hasura.RQL.IR.Insert.AnnotatedInsertData b f)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Foldable.Foldable f) => Data.Foldable.Foldable (Hasura.RQL.IR.Insert.AnnotatedInsertData b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Base.Functor f) => GHC.Base.Functor (Hasura.RQL.IR.Insert.AnnotatedInsertData b f)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Insert.AnnotatedInsert b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Insert.AnnotatedInsert b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Insert.AnnotatedInsert b r)

module Hasura.RQL.IR.Delete
data AnnDelG (b :: BackendType) (r :: Type) v
AnnDel :: TableName b -> (AnnBoolExp b v, AnnBoolExp b v) -> MutationOutputG b r v -> [ColumnInfo b] -> Maybe NamingCase -> AnnDelG (b :: BackendType) (r :: Type) v
[_adTable] :: AnnDelG (b :: BackendType) (r :: Type) v -> TableName b
[_adWhere] :: AnnDelG (b :: BackendType) (r :: Type) v -> (AnnBoolExp b v, AnnBoolExp b v)
[_adOutput] :: AnnDelG (b :: BackendType) (r :: Type) v -> MutationOutputG b r v
[_adAllCols] :: AnnDelG (b :: BackendType) (r :: Type) v -> [ColumnInfo b]
[_adNamingConvention] :: AnnDelG (b :: BackendType) (r :: Type) v -> Maybe NamingCase
type AnnDel b = AnnDelG b Void (SQLExpression b)
adWhere :: forall b_ardqq r_ardqr v_ardqs. Lens' (AnnDelG b_ardqq r_ardqr v_ardqs) (AnnBoolExp b_ardqq v_ardqs, AnnBoolExp b_ardqq v_ardqs)
adTable :: forall b_ardqq r_ardqr v_ardqs. Lens' (AnnDelG b_ardqq r_ardqr v_ardqs) (TableName b_ardqq)
adOutput :: forall b_ardqq r_ardqr v_ardqs r_areDQ. Lens (AnnDelG b_ardqq r_ardqr v_ardqs) (AnnDelG b_ardqq r_areDQ v_ardqs) (MutationOutputG b_ardqq r_ardqr v_ardqs) (MutationOutputG b_ardqq r_areDQ v_ardqs)
adNamingConvention :: forall b_ardqq r_ardqr v_ardqs. Lens' (AnnDelG b_ardqq r_ardqr v_ardqs) (Maybe NamingCase)
adAllCols :: forall b_ardqq r_ardqr v_ardqs. Lens' (AnnDelG b_ardqq r_ardqr v_ardqs) [ColumnInfo b_ardqq]
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Delete.AnnDelG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Delete.AnnDelG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Delete.AnnDelG b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), GHC.Show.Show (Hasura.RQL.IR.Returning.MutationOutputG b r a), GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.IR.Delete.AnnDelG b r a)

module Hasura.RQL.IR.Root
data SourceConfigWith (db :: BackendType -> Type) (b :: BackendType)
SourceConfigWith :: SourceConfig b -> Maybe QueryTagsConfig -> db b -> SourceConfigWith (db :: BackendType -> Type) (b :: BackendType)
data RootField (db :: BackendType -> Type) remote action raw
[RFDB] :: SourceName -> AnyBackend (SourceConfigWith db) -> RootField db remote action raw
[RFRemote] :: remote -> RootField db remote action raw
[RFAction] :: action -> RootField db remote action raw
[RFRaw] :: raw -> RootField db remote action raw
[RFMulti] :: [RootField db remote action raw] -> RootField db remote action raw
data MutationDB (b :: BackendType) (r :: Type) v
MDBInsert :: AnnotatedInsert b r v -> MutationDB (b :: BackendType) (r :: Type) v
MDBUpdate :: AnnotatedUpdateG b r v -> MutationDB (b :: BackendType) (r :: Type) v
MDBDelete :: AnnDelG b r v -> MutationDB (b :: BackendType) (r :: Type) v

-- | This represents a VOLATILE function, and is AnnSimpleSelG for easy
--   re-use of non-VOLATILE function tracking code.
MDBFunction :: JsonAggSelect -> AnnSimpleSelectG b r v -> MutationDB (b :: BackendType) (r :: Type) v
data ActionQuery (r :: Type)
AQQuery :: AnnActionExecution r -> ActionQuery (r :: Type)
AQAsync :: AnnActionAsyncQuery ('Postgres 'Vanilla) r -> ActionQuery (r :: Type)
data ActionMutation (r :: Type)
AMSync :: AnnActionExecution r -> ActionMutation (r :: Type)
AMAsync :: AnnActionMutationAsync -> ActionMutation (r :: Type)
newtype QueryDBRoot r v b
QDBR :: QueryDB b r (v b) -> QueryDBRoot r v b
newtype MutationDBRoot r v b
MDBR :: MutationDB b r (v b) -> MutationDBRoot r v b

-- | IR of a remote relationship. A remote relationship currently can be to
--   either a remote schema or a database's table. See RemoteSourceSelect
--   for explanation on <tt>vf</tt>.
data RemoteRelationshipField vf
RemoteSchemaField :: RemoteSchemaSelect (RemoteRelationshipField vf) -> RemoteRelationshipField vf

-- | AnyBackend is used here to capture a relationship to an arbitrary
--   target
RemoteSourceField :: AnyBackend (RemoteSourceSelect (RemoteRelationshipField vf) vf) -> RemoteRelationshipField vf

-- | Represents a query root field to an action
type QueryActionRoot v = ActionQuery (RemoteRelationshipField v)

-- | Represents a mutation root field to an action
type MutationActionRoot v = ActionMutation (RemoteRelationshipField v)
type QueryRootField v = RootField (QueryDBRoot (RemoteRelationshipField v) v) (RemoteSchemaRootField (RemoteRelationshipField v) RemoteSchemaVariable) (QueryActionRoot v) Value
type MutationRootField v = RootField (MutationDBRoot (RemoteRelationshipField v) v) (RemoteSchemaRootField (RemoteRelationshipField v) RemoteSchemaVariable) (MutationActionRoot v) Value
type SubscriptionRootField v = RootField (QueryDBRoot (RemoteRelationshipField v) v) (RemoteSchemaRootField (RemoteRelationshipField v) RemoteSchemaVariable) (QueryActionRoot v) Value
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Root.MutationDB b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Root.MutationDB b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Root.MutationDB b r)
instance GHC.Generics.Generic (Hasura.RQL.IR.Root.MutationDB b r v)
instance Data.Traversable.Traversable Hasura.RQL.IR.Root.ActionQuery
instance Data.Foldable.Foldable Hasura.RQL.IR.Root.ActionQuery
instance GHC.Base.Functor Hasura.RQL.IR.Root.ActionQuery

module Hasura.RQL.IR


-- | A collection of types and utilities around the <tt>Node</tt> GraphQL
--   type exposed by the Relay API.
module Hasura.GraphQL.Schema.Node
data NodeId
NodeIdV1 :: V1NodeId -> NodeId
NodeIdV2 :: AnyBackend V2NodeId -> NodeId

-- | V1 format of a node.
--   
--   This id does NOT uniquely identify the table properly, as it only
--   knows the table's name, but doesn't store a source name.
data V1NodeId
V1NodeId :: QualifiedTable -> NESeq Value -> V1NodeId
[_ni1Table] :: V1NodeId -> QualifiedTable
[_ni1Columns] :: V1NodeId -> NESeq Value

-- | V2 format of a node.
--   
--   Uniquely identifies a table with source name and table name, and
--   uniquely identifies a row within that table with a list of primary key
--   values.
data V2NodeId b
V2NodeId :: SourceName -> TableName b -> NESeq Value -> V2NodeId b
[_ni2Source] :: V2NodeId b -> SourceName
[_ni2Table] :: V2NodeId b -> TableName b
[_ni2Columns] :: V2NodeId b -> NESeq Value
parseNodeIdV1 :: [Value] -> Parser V1NodeId

-- | Enum representing the supported versions of the API.
data NodeIdVersion
NIVersion1 :: NodeIdVersion
NIVersion2 :: NodeIdVersion
nodeIdVersionInt :: NodeIdVersion -> Int
currentNodeIdVersion :: NodeIdVersion
type NodeMap = HashMap SourceName (AnyBackend TableMap)

-- | All the information required to craft a query to a row pointed to by a
--   <a>NodeId</a>.
data NodeInfo b
NodeInfo :: SourceConfig b -> SelPermInfo b -> PrimaryKeyColumns b -> AnnFieldsG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> NodeInfo b
[nvSourceConfig] :: NodeInfo b -> SourceConfig b
[nvSelectPermissions] :: NodeInfo b -> SelPermInfo b
[nvPrimaryKeys] :: NodeInfo b -> PrimaryKeyColumns b
[nvAnnotatedFields] :: NodeInfo b -> AnnFieldsG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
newtype TableMap b
TableMap :: HashMap (TableName b) (NodeInfo b) -> TableMap b

-- | Given a source name and table name, peform the double lookup within a
--   <a>NodeMap</a>.
findNode :: forall b. Backend b => SourceName -> TableName b -> NodeMap -> Maybe (NodeInfo b)
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Node.NodeIdVersion
instance GHC.Show.Show Hasura.GraphQL.Schema.Node.NodeIdVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Schema.Node.NodeId

module Hasura.GraphQL.Context

-- | For storing both a normal GQLContext and one for the backend variant.
--   Currently, this is to enable the backend variant to have certain
--   insert<i>update</i>delete permissions which the frontend variant does
--   not.
data RoleContext a
RoleContext :: !a -> !Maybe a -> RoleContext a

-- | The default context for normal sessions
[_rctxDefault] :: RoleContext a -> !a

-- | The context for sessions with backend privilege.
[_rctxBackend] :: RoleContext a -> !Maybe a
data GQLContext
GQLContext :: ParserFn (RootFieldMap (QueryRootField UnpreparedValue)) -> Maybe (ParserFn (RootFieldMap (MutationRootField UnpreparedValue))) -> Maybe (ParserFn (RootFieldMap (QueryRootField UnpreparedValue))) -> GQLContext
[gqlQueryParser] :: GQLContext -> ParserFn (RootFieldMap (QueryRootField UnpreparedValue))
[gqlMutationParser] :: GQLContext -> Maybe (ParserFn (RootFieldMap (MutationRootField UnpreparedValue)))
[gqlSubscriptionParser] :: GQLContext -> Maybe (ParserFn (RootFieldMap (QueryRootField UnpreparedValue)))
type ParserFn a = SelectionSet NoFragments Variable -> Either QErr a
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Context.GQLContext
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Context.RoleContext a)
instance Data.Traversable.Traversable Hasura.GraphQL.Context.RoleContext
instance Data.Foldable.Foldable Hasura.GraphQL.Context.RoleContext
instance GHC.Base.Functor Hasura.GraphQL.Context.RoleContext
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Context.RoleContext a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Context.RoleContext a)

module Hasura.RQL.Types.SchemaCache
newtype MetadataResourceVersion
MetadataResourceVersion :: Int64 -> MetadataResourceVersion
[getMetadataResourceVersion] :: MetadataResourceVersion -> Int64
initialResourceVersion :: MetadataResourceVersion
mkParentDep :: forall b. Backend b => SourceName -> TableName b -> SchemaDependency
mkColDep :: forall b. Backend b => DependencyReason -> SourceName -> TableName b -> Column b -> SchemaDependency
mkComputedFieldDep :: forall b. Backend b => DependencyReason -> SourceName -> TableName b -> ComputedFieldName -> SchemaDependency
type WithDeps a = (a, [SchemaDependency])
data IntrospectionResult
IntrospectionResult :: RemoteSchemaIntrospection -> Name -> Maybe Name -> Maybe Name -> IntrospectionResult
[irDoc] :: IntrospectionResult -> RemoteSchemaIntrospection
[irQueryRoot] :: IntrospectionResult -> Name
[irMutationRoot] :: IntrospectionResult -> Maybe Name
[irSubscriptionRoot] :: IntrospectionResult -> Maybe Name
type RemoteSchemaRelationships = InsOrdHashMap Name (InsOrdHashMap RelName (RemoteFieldInfo Name))

-- | See <tt>fetchRemoteSchema</tt>.
data RemoteSchemaCtx
RemoteSchemaCtx :: RemoteSchemaName -> IntrospectionResult -> RemoteSchemaInfo -> ByteString -> HashMap RoleName IntrospectionResult -> RemoteSchemaRelationships -> RemoteSchemaCtx
[_rscName] :: RemoteSchemaCtx -> RemoteSchemaName

-- | Original remote schema without customizations
[_rscIntroOriginal] :: RemoteSchemaCtx -> IntrospectionResult
[_rscInfo] :: RemoteSchemaCtx -> RemoteSchemaInfo

-- | The raw response from the introspection query against the remote
--   server. We store this so we can efficiently service
--   <tt>introspect_remote_schema</tt>.
[_rscRawIntrospectionResult] :: RemoteSchemaCtx -> ByteString
[_rscPermissions] :: RemoteSchemaCtx -> HashMap RoleName IntrospectionResult
[_rscRemoteRelationships] :: RemoteSchemaCtx -> RemoteSchemaRelationships
getIntrospectionResult :: RemoteSchemaPermissions -> RoleName -> RemoteSchemaCtx -> Maybe IntrospectionResult
rscRemoteRelationships :: Lens' RemoteSchemaCtx RemoteSchemaRelationships
rscRawIntrospectionResult :: Lens' RemoteSchemaCtx ByteString
rscPermissions :: Lens' RemoteSchemaCtx (HashMap RoleName IntrospectionResult)
rscName :: Lens' RemoteSchemaCtx RemoteSchemaName
rscIntroOriginal :: Lens' RemoteSchemaCtx IntrospectionResult
rscInfo :: Lens' RemoteSchemaCtx RemoteSchemaInfo
type RemoteSchemaMap = HashMap RemoteSchemaName RemoteSchemaCtx
type DepMap = HashMap SchemaObjId (HashSet SchemaDependency)
data CronTriggerInfo
CronTriggerInfo :: TriggerName -> CronSchedule -> Maybe Value -> STRetryConf -> EnvRecord ResolvedWebhook -> [EventHeaderInfo] -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CronTriggerInfo
[ctiName] :: CronTriggerInfo -> TriggerName
[ctiSchedule] :: CronTriggerInfo -> CronSchedule
[ctiPayload] :: CronTriggerInfo -> Maybe Value
[ctiRetryConf] :: CronTriggerInfo -> STRetryConf
[ctiWebhookInfo] :: CronTriggerInfo -> EnvRecord ResolvedWebhook
[ctiHeaders] :: CronTriggerInfo -> [EventHeaderInfo]
[ctiComment] :: CronTriggerInfo -> Maybe Text
[ctiRequestTransform] :: CronTriggerInfo -> Maybe RequestTransform
[ctiResponseTransform] :: CronTriggerInfo -> Maybe MetadataResponseTransform
newtype SchemaCacheVer
SchemaCacheVer :: Word64 -> SchemaCacheVer
[unSchemaCacheVer] :: SchemaCacheVer -> Word64
initSchemaCacheVer :: SchemaCacheVer
incSchemaCacheVer :: SchemaCacheVer -> SchemaCacheVer
type ActionCache = HashMap ActionName ActionInfo
type InheritedRolesCache = HashMap RoleName (HashSet RoleName)

-- | Retrieves the source info for a given source name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. This
--   function must be used with a _type annotation_, such as `askSourceInfo
--   @('Postgres 'Vanilla)`. It throws an error if it fails to find that
--   source, in which case it looks that source up in the metadata, to
--   differentiate between the source not existing or the type of the
--   source not matching.
askSourceInfo :: forall b m. (CacheRM m, MetadataM m, MonadError QErr m, Backend b) => SourceName -> m (SourceInfo b)

-- | Retrieves the source config for a given source name.
--   
--   This function relies on <a>askSourceInfo</a> and similarly throws an
--   error if the source isn't found.
askSourceConfig :: forall b m. (CacheRM m, MonadError QErr m, Backend b, MetadataM m) => SourceName -> m (SourceConfig b)

-- | Retrieves the table cache for a given source cache and source name.
--   
--   This function must be used with a _type annotation_, such as
--   `unsafeTableCache <tt>('Postgres 'Vanilla)`. It returns </tt>Nothing@
--   if it fails to find that source or if the kind of the source does not
--   match the type annotation, and does not distinguish between the two
--   cases.
unsafeTableCache :: forall b. Backend b => SourceName -> SourceCache -> Maybe (TableCache b)

-- | Retrieves the table cache for a given source name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. It
--   must be used with a _type annotation_, such as `unsafeTableCache
--   <tt>('Postgres 'Vanilla)`. It returns </tt>Nothing@ if it fails to
--   find that source or if the kind of the source does not match the type
--   annotation, and does not distinguish between the two cases.
askTableCache :: forall b m. (Backend b, CacheRM m) => SourceName -> m (Maybe (TableCache b))

-- | Retrieves the information about a table from the source cache, the
--   source name, and the table name.
--   
--   This function returns <tt>Nothing</tt> if it fails to find that source
--   or if the kind of the source does not match the type annotation, and
--   does not distinguish between the two cases.
unsafeTableInfo :: forall b. Backend b => SourceName -> TableName b -> SourceCache -> Maybe (TableInfo b)

-- | Retrieves the information about a table for a given source name and
--   table name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. it
--   throws an error if it fails to find that source, in which case it
--   looks that source up in the metadata, to differentiate between the
--   source not existing or the type of the source not matching.
askTableInfo :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> TableName b -> m (TableInfo b)

-- | Similar to <a>askTableInfo</a>, but drills further down to extract the
--   underlying core info.
askTableCoreInfo :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> TableName b -> m (TableCoreInfo b)

-- | Similar to <a>askTableCoreInfo</a>, but drills further down to extract
--   the underlying field info map.
askTableFieldInfoMap :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> TableName b -> m (FieldInfoMap (FieldInfo b))

-- | Retrieves the metadata information about a table for a given source
--   name and table name.
--   
--   Unlike most other <tt>ask</tt> functions in this module, this function
--   does not drill through the schema cache, and instead inspects the
--   metadata. Like most others, it throws an error if it fails to find
--   that source, in which case it looks that source up in the metadata, to
--   differentiate between the source not existing or the type of the
--   source not matching.
askTableMetadata :: forall b m. (QErrM m, MetadataM m, Backend b) => SourceName -> TableName b -> m (TableMetadata b)

-- | Retrieves the function cache for a given source cache and source name.
--   
--   This function must be used with a _type annotation_, such as
--   `unsafeFunctionCache <tt>('Postgres 'Vanilla)`. It returns
--   </tt>Nothing@ if it fails to find that source or if the kind of the
--   source does not match the type annotation, and does not distinguish
--   between the two cases.
unsafeFunctionCache :: forall b. Backend b => SourceName -> SourceCache -> Maybe (FunctionCache b)

-- | Retrieves the information about a function from the source cache, the
--   source name, and the function name.
--   
--   This function returns <tt>Nothing</tt> if it fails to find that source
--   or if the kind of the source does not match the type annotation, and
--   does not distinguish between the two cases.
unsafeFunctionInfo :: forall b. Backend b => SourceName -> FunctionName b -> SourceCache -> Maybe (FunctionInfo b)

-- | Retrieves the information about a function cache for a given source
--   name and function name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. It
--   throws an error if it fails to find that source, in which case it
--   looks that source up in the metadata, to differentiate between the
--   source not existing or the type of the source not matching.
askFunctionInfo :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> FunctionName b -> m (FunctionInfo b)
data SchemaCache
SchemaCache :: SourceCache -> ActionCache -> RemoteSchemaMap -> InlinedAllowlist -> SchemaIntrospection -> HashMap RoleName (RoleContext GQLContext) -> GQLContext -> HashMap RoleName (RoleContext GQLContext) -> GQLContext -> DepMap -> [InconsistentMetadata] -> HashMap TriggerName CronTriggerInfo -> EndpointTrie GQLQueryWithText -> ApiLimit -> MetricsConfig -> Maybe MetadataResourceVersion -> SetGraphqlIntrospectionOptions -> [TlsAllow] -> QueryCollections -> SchemaCache
[scSources] :: SchemaCache -> SourceCache
[scActions] :: SchemaCache -> ActionCache
[scRemoteSchemas] :: SchemaCache -> RemoteSchemaMap
[scAllowlist] :: SchemaCache -> InlinedAllowlist
[scAdminIntrospection] :: SchemaCache -> SchemaIntrospection
[scGQLContext] :: SchemaCache -> HashMap RoleName (RoleContext GQLContext)
[scUnauthenticatedGQLContext] :: SchemaCache -> GQLContext
[scRelayContext] :: SchemaCache -> HashMap RoleName (RoleContext GQLContext)
[scUnauthenticatedRelayContext] :: SchemaCache -> GQLContext
[scDepMap] :: SchemaCache -> DepMap
[scInconsistentObjs] :: SchemaCache -> [InconsistentMetadata]
[scCronTriggers] :: SchemaCache -> HashMap TriggerName CronTriggerInfo
[scEndpoints] :: SchemaCache -> EndpointTrie GQLQueryWithText
[scApiLimits] :: SchemaCache -> ApiLimit
[scMetricsConfig] :: SchemaCache -> MetricsConfig
[scMetadataResourceVersion] :: SchemaCache -> Maybe MetadataResourceVersion
[scSetGraphqlIntrospectionOptions] :: SchemaCache -> SetGraphqlIntrospectionOptions
[scTlsAllowlist] :: SchemaCache -> [TlsAllow]
[scQueryCollections] :: SchemaCache -> QueryCollections
getAllRemoteSchemas :: SchemaCache -> [RemoteSchemaName]
class (Monad m) => SourceM m
askCurrentSource :: SourceM m => m SourceName
newtype SourceT m a
SourceT :: (SourceName -> m a) -> SourceT m a
[runSourceT] :: SourceT m a -> SourceName -> m a

-- | A more limited version of <a>CacheRM</a> that is used when building
--   the schema cache, since the entire schema cache has not been built
--   yet.
class (SourceM m) => TableCoreInfoRM b m
lookupTableCoreInfo :: TableCoreInfoRM b m => TableName b -> m (Maybe (TableCoreInfo b))
newtype TableCoreCacheRT b m a
TableCoreCacheRT :: ((SourceName, Dependency (TableCoreCache b)) -> m a) -> TableCoreCacheRT b m a
[runTableCoreCacheRT] :: TableCoreCacheRT b m a -> (SourceName, Dependency (TableCoreCache b)) -> m a

-- | All our RQL DML queries operate over a single source. This typeclass
--   facilitates that.
class (TableCoreInfoRM b m) => TableInfoRM b m
lookupTableInfo :: TableInfoRM b m => TableName b -> m (Maybe (TableInfo b))
newtype TableCacheRT b m a
TableCacheRT :: ((SourceName, TableCache b) -> m a) -> TableCacheRT b m a
[runTableCacheRT] :: TableCacheRT b m a -> (SourceName, TableCache b) -> m a
class (Monad m) => CacheRM m
askSchemaCache :: CacheRM m => m SchemaCache
getDependentObjs :: SchemaCache -> SchemaObjId -> [SchemaObjId]
getDependentObjsWith :: (DependencyReason -> Bool) -> SchemaCache -> SchemaObjId -> [SchemaObjId]

-- | Compute all remote dependencies on a source.
--   
--   Given a source name, this function computes all of its dependencies,
--   direct or indirect, and returns all of the dependencies that are not
--   "local" to the source, i.e. that belong to another source or to a
--   remote schema, here dubbed "remote dependencies".
--   
--   This functions returns a <a>SchemaObjId</a> for each such dependency,
--   but makes no attempt at extracting the underlying <a>SourceObjId</a>
--   (if any), for two reasons: 1. a <a>SourceObjId</a> no longer contains
--   the source name, which most callers need to identify where the
--   corresponding dependency is 2. this would prevent us from returning
--   remote schema dependencies, which by definition do not have a
--   corresponding <a>SourceObjId</a>
getRemoteDependencies :: SchemaCache -> SourceName -> [SchemaObjId]

-- | Discover the schema dependencies of an <tt>AnnBoolExpPartialSQL</tt>.
getBoolExpDeps :: forall b. GetAggregationPredicatesDeps b => SourceName -> TableName b -> AnnBoolExpPartialSQL b -> [SchemaDependency]
getBoolExpDeps' :: forall b. (Backend b, GetAggregationPredicatesDeps b) => AnnBoolExpPartialSQL b -> BoolExpM b [SchemaDependency]
getColExpDeps :: forall b. (Backend b, GetAggregationPredicatesDeps b) => AnnBoolExpFld b (PartialSQLExp b) -> BoolExpM b [SchemaDependency]
getOpExpDeps :: forall b. Backend b => [OpExpG b (PartialSQLExp b)] -> BoolExpM b [SchemaDependency]

-- | Asking for a table's fields info without explicit
--   <tt><a>SourceName</a> argument. The source name is implicitly inferred
--   from </tt><a>SourceM</a> via @<a>TableCoreInfoRM</a>.
askFieldInfoMapSource :: (QErrM m, Backend b, TableCoreInfoRM b m) => TableName b -> m (FieldInfoMap (FieldInfo b))
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SchemaCache.SchemaCacheVer
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.SchemaCacheVer
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.SchemaCache.SchemaCacheVer
instance GHC.Classes.Ord Hasura.RQL.Types.SchemaCache.SchemaCacheVer
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.SchemaCacheVer
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.SchemaCacheVer
instance Control.Monad.Trans.Class.MonadTrans (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.Trans.Class.MonadTrans (Hasura.RQL.Types.SchemaCache.TableCacheRT b)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.RQL.Types.SchemaCache.SourceT
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.RQL.Types.SchemaCache.SourceT m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.Types.SchemaCache.SourceT m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.RQL.Types.SchemaCache.SourceT m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hasura.RQL.Types.SchemaCache.SourceT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.RQL.Types.SchemaCache.SourceT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.Types.SchemaCache.SourceT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.Types.SchemaCache.SourceT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.Types.SchemaCache.SourceT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.RQL.Types.SchemaCache.SourceT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.Types.SchemaCache.SourceT m)
instance GHC.Base.Monad m => Hasura.RQL.Types.SchemaCache.SourceM (Hasura.RQL.Types.SchemaCache.SourceT m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Hasura.RQL.Types.SchemaCache.CacheRM m) => Hasura.RQL.Types.SchemaCache.CacheRM (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.Tracing.TraceT m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Database.MSSQL.Transaction.TxET e m)
instance Hasura.Session.UserInfoM m => Hasura.Session.UserInfoM (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance GHC.Base.Monad m => Hasura.RQL.Types.SchemaCache.SourceM (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance (GHC.Base.Monad m, Hasura.RQL.Types.Backend.Backend b) => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance (GHC.Base.Monad m, Hasura.RQL.Types.Backend.Backend b) => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Hasura.Server.Types.HasServerConfigCtx m => Hasura.Server.Types.HasServerConfigCtx (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Hasura.RQL.Types.SchemaCache.TableInfoRM b m) => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Hasura.Tracing.TraceT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance GHC.Base.Monad m => Hasura.RQL.Types.SchemaCache.SourceM (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance (Hasura.Incremental.Internal.Cache.MonadDepend m, Hasura.RQL.Types.Backend.Backend b) => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m) => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.Tracing.TraceT m)
instance Hasura.RQL.Types.SchemaCache.SourceM m => Hasura.RQL.Types.SchemaCache.SourceM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.SourceM m => Hasura.RQL.Types.SchemaCache.SourceM (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Hasura.RQL.Types.SchemaCache.SourceM m) => Hasura.RQL.Types.SchemaCache.SourceM (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.RQL.Types.SchemaCache.SourceM m => Hasura.RQL.Types.SchemaCache.SourceM (Hasura.Tracing.TraceT m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.SchemaCache
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.CronTriggerInfo
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.CronTriggerInfo
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.CronTriggerInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.RemoteSchemaCtx
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance GHC.Num.Num Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance GHC.Generics.Generic Hasura.RQL.Types.SchemaCache.IntrospectionResult
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.IntrospectionResult
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.IntrospectionResult
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.Types.SchemaCache.IntrospectionResult

module Hasura.Server.OpenAPI
buildOpenAPI :: (MonadError QErr m, MonadFix m) => SchemaCache -> m OpenApi
buildAllEndpoints :: (MonadError QErr m, MonadFix m) => SchemaCache -> SchemaIntrospection -> DeclareM m (InsOrdHashMap String (PathItem, Text))
buildEndpoint :: (MonadError QErr m, MonadFix m) => SchemaIntrospection -> EndpointMethod -> EndpointMetadata GQLQueryWithText -> DeclareM m (InsOrdHashMap String (PathItem, Text))

-- | Given the <a>Structure</a> of a query, generate the corresponding
--   parameters.
--   
--   We expect one optional parameter per known scalar variable.
collectParams :: Structure -> EndpointUrl -> [Referenced Param]

-- | Given the <a>Structure</a> of a query, generate the corresponding
--   <a>RequestBody</a>.
--   
--   We always expect an object that has a field per variable of the query
--   if there is at least one variable in the query; otherwise we don't
--   expect a request body.
buildRequestBody :: (MonadError QErr m, MonadFix m) => Structure -> DeclareM m (Maybe (Referenced RequestBody))

-- | Given the information about a variable, build the corresponding
--   schema.
--   
--   Returns the generated schema, and a boolean indicating whether the
--   variable is required.
buildVariableSchema :: (MonadError QErr m, MonadFix m) => VariableInfo -> CircularT (Name, Nullability) (Referenced Schema) (DeclareM m) (Referenced Schema, Bool)

-- | Given the information about an input type, build the corresponding
--   schema.
buildInputFieldSchema :: MonadFix m => GType -> InputFieldInfo -> CircularT (Name, Nullability) (Referenced Schema) (DeclareM m) (Referenced Schema)

-- | Given the <a>Structure</a> of a query, generate the corresponding
--   <a>Response</a>.
buildResponse :: Monad m => Structure -> EndpointMethod -> Text -> DeclareM m Response

-- | Given a list of fields and their types, build a corresponding schema.
buildSelectionSchema :: Monad m => [(Name, FieldInfo)] -> DeclareM m Schema

-- | Build the schema for a given output type.
buildFieldSchema :: Monad m => FieldInfo -> DeclareM m (Referenced Schema)

-- | Craft the OpenAPI <a>Schema</a> for a given scalar. Any non-standard
--   scalar will instead be declared, and returned by reference.
buildScalarSchema :: Monad m => ScalarInfo -> Name -> Nullability -> DeclareM m (Referenced Schema)

-- | Retrieve info associated with a given scalar, if it can be mapped to a
--   built-in OpenAPI scalar. On a match, we return a tuple indiciating
--   which scalar should be used, a pattern, and a boolean indicating
--   whether this type should be inlined.
getReferenceScalarInfo :: Name -> Maybe (OpenApiType, Maybe Pattern, Bool)

-- | Craft the OpenAPI <a>Schema</a> for a given enum.
buildEnumSchema :: Monad m => EnumInfo -> Name -> Nullability -> DeclareM m (Referenced Schema)

-- | Given an annotated GraphQL type (such as <tt>[[Foo!]]!</tt> and a
--   callback function to be used on the actual underlying type, construct
--   a <a>Schema</a> by recursively applying modifiers.
applyModifiers :: Monad m => GType -> (Name -> Nullability -> m (Referenced Schema)) -> m (Referenced Schema)

-- | Adds a declaration for the given type, returns a schema that
--   references it.
declareType :: Monad m => Name -> Nullability -> Schema -> DeclareM m (Referenced Schema)

-- | Crafts a reference name for a given type.
--   
--   We use the fact that JSON references allow characters that GraphQL
--   types don't: we make a different reference for non-nullable type by
--   using the GraphQL convention of suffixing the name by <tt>!</tt>.
--   
--   See Note [Nullable types in OpenAPI].
mkReferenceName :: Name -> Nullability -> Text
type DeclareM = DeclareT (Definitions Schema)

-- | Variable definition for x-hasura-admin-secret
xHasuraAdminSecret :: Param

-- | Convert a GraphQL value to an equivalent JSON representation.
--   
--   TODO: can we deduplicate this?
gqlToJsonValue :: Value Void -> Value


-- | Types and functions used in the process of building the schema cache
--   from metadata information stored in the <tt>hdb_catalog</tt> schema in
--   Postgres.
module Hasura.RQL.Types.SchemaCache.Build
data CollectedInfo
CIInconsistency :: InconsistentMetadata -> CollectedInfo
CIDependency :: MetadataObject -> SchemaObjId -> SchemaDependency -> CollectedInfo
_CIDependency :: Prism' CollectedInfo (MetadataObject, SchemaObjId, SchemaDependency)
_CIInconsistency :: Prism' CollectedInfo InconsistentMetadata
class AsInconsistentMetadata s
_InconsistentMetadata :: AsInconsistentMetadata s => Prism' s InconsistentMetadata
partitionCollectedInfo :: Seq CollectedInfo -> ([InconsistentMetadata], [(MetadataObject, SchemaObjId, SchemaDependency)])
recordInconsistency :: (ArrowWriter (Seq w) arr, AsInconsistentMetadata w) => ((Maybe Value, MetadataObject), Text) `arr` ()
recordInconsistencyM :: (MonadWriter (Seq w) m, AsInconsistentMetadata w) => Maybe Value -> MetadataObject -> Text -> m ()
recordInconsistencies :: (ArrowWriter (Seq w) arr, AsInconsistentMetadata w) => ([MetadataObject], Text) `arr` ()
recordInconsistenciesM' :: (MonadWriter (Seq w) m, AsInconsistentMetadata w) => [(Maybe Value, MetadataObject)] -> Text -> m ()
recordInconsistencies' :: (ArrowWriter (Seq w) arr, AsInconsistentMetadata w) => ([(Maybe Value, MetadataObject)], Text) `arr` ()
recordDependencies :: ArrowWriter (Seq CollectedInfo) arr => (MetadataObject, SchemaObjId, [SchemaDependency]) `arr` ()
recordDependenciesM :: MonadWriter (Seq CollectedInfo) m => MetadataObject -> SchemaObjId -> [SchemaDependency] -> m ()

-- | Monadic version of <a>withRecordInconsistency</a>
withRecordInconsistencyM :: (MonadWriter (Seq w) m, AsInconsistentMetadata w) => MetadataObject -> ExceptT QErr m a -> m (Maybe a)

-- | Record any errors resulting from a computation as inconsistencies
withRecordInconsistency :: (ArrowChoice arr, ArrowWriter (Seq w) arr, AsInconsistentMetadata w) => ErrorA QErr arr (e, s) a -> arr (e, (MetadataObject, s)) (Maybe a)
class (CacheRM m) => CacheRWM m
buildSchemaCacheWithOptions :: CacheRWM m => BuildReason -> CacheInvalidations -> Metadata -> m ()
setMetadataResourceVersionInSchemaCache :: CacheRWM m => MetadataResourceVersion -> m ()
data BuildReason

-- | The build was triggered by an update this instance made to the catalog
--   (in the currently-active transaction), so information in Postgres that
--   needs to be kept in sync with the catalog (i.e. table event triggers
--   in <tt>hdb_catalog</tt> schema) should be updated.
CatalogUpdate :: Maybe (HashSet SourceName) -> BuildReason

-- | The build was triggered by a notification that some other
--   currently-running Hasura instance updated the catalog. Since that
--   instance already updated table event triggers in <tt>hdb_catalog</tt>,
--   this build should be read-only.
CatalogSync :: BuildReason
data CacheInvalidations
CacheInvalidations :: Bool -> HashSet RemoteSchemaName -> HashSet SourceName -> CacheInvalidations

-- | Force reloading of all database information, including information not
--   technically stored in metadata (currently just enum values). Set by
--   the <tt>reload_metadata</tt> API.
[ciMetadata] :: CacheInvalidations -> Bool

-- | Force refetching of the given remote schemas, even if their definition
--   has not changed. Set by the <tt>reload_remote_schema</tt> API.
[ciRemoteSchemas] :: CacheInvalidations -> HashSet RemoteSchemaName

-- | Force re-establishing connections of the given data sources, even if
--   their configuration has not changed. Set by the
--   <tt>pg_reload_source</tt> API.
[ciSources] :: CacheInvalidations -> HashSet SourceName
newtype MetadataT m a
MetadataT :: StateT Metadata m a -> MetadataT m a
[unMetadataT] :: MetadataT m a -> StateT Metadata m a
runMetadataT :: Metadata -> MetadataT m a -> m (a, Metadata)
buildSchemaCacheWithInvalidations :: (MetadataM m, CacheRWM m) => CacheInvalidations -> MetadataModifier -> m ()
buildSchemaCache :: (MetadataM m, CacheRWM m) => MetadataModifier -> m ()

-- | Rebuilds the schema cache after modifying metadata. If an object with
--   the given object id became newly inconsistent, raises an error about
--   it specifically. Otherwise, raises a generic metadata inconsistency
--   error.
buildSchemaCacheFor :: (QErrM m, CacheRWM m, MetadataM m) => MetadataObjId -> MetadataModifier -> m ()

-- | Like <a>buildSchemaCache</a>, but fails if there is any inconsistent
--   metadata.
buildSchemaCacheStrict :: (QErrM m, CacheRWM m, MetadataM m) => m ()

-- | Executes the given action, and if any new <a>InconsistentMetadata</a>s
--   are added to the schema cache as a result of its execution, raises an
--   error.
withNewInconsistentObjsCheck :: (QErrM m, CacheRM m) => m a -> m a

-- | getInconsistentQueryCollections is a helper function that runs the
--   static analysis over the saved queries and reports any inconsistenties
--   with the current schema.
getInconsistentQueryCollections :: MonadError QErr m => SchemaIntrospection -> QueryCollections -> ((CollectionName, ListedQuery) -> MetadataObject) -> EndpointTrie GQLQueryWithText -> [NormalizedQuery] -> m [InconsistentMetadata]
validateQuery :: MonadError QErr m => SchemaIntrospection -> (a -> MetadataObject) -> (a -> [Text] -> Text) -> (a, [ExecutableDefinition Name]) -> m (Either (MetadataObject, Text) ())
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Tracing.MonadTrace m => Hasura.Tracing.MonadTrace (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Morph.MFunctor Hasura.RQL.Types.SchemaCache.Build.MetadataT
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.Types.SchemaCache.SourceM m => Hasura.RQL.Types.SchemaCache.SourceM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.RQL.Types.SchemaCache.Build.MetadataT
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance GHC.Base.Monad m => Hasura.RQL.Types.Metadata.MetadataM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Network.HTTP.Client.Manager.HasHttpManagerM m => Network.HTTP.Client.Manager.HasHttpManagerM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Session.UserInfoM m => Hasura.Session.UserInfoM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Server.Types.HasServerConfigCtx m => Hasura.Server.Types.HasServerConfigCtx (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance GHC.Base.Semigroup Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance GHC.Base.Monoid Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Hasura.Tracing.TraceT m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.Build.BuildReason
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.BuildReason
instance Hasura.RQL.Types.SchemaCache.Build.AsInconsistentMetadata Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance Hasura.RQL.Types.SchemaCache.Build.AsInconsistentMetadata Hasura.RQL.Types.SchemaCache.Build.CollectedInfo
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.CollectedInfo

module Hasura.RQL.DDL.QueryTags
data SetQueryTagsConfig
SetQueryTagsConfig :: SourceName -> QueryTagsConfig -> SetQueryTagsConfig
[_sqtSourceName] :: SetQueryTagsConfig -> SourceName
[_sqtConfig] :: SetQueryTagsConfig -> QueryTagsConfig
runSetQueryTagsConfig :: (MonadError QErr m, MetadataM m, CacheRWM m) => SetQueryTagsConfig -> m EncJSON
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.QueryTags.SetQueryTagsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.QueryTags.SetQueryTagsConfig

module Hasura.RQL.DDL.QueryCollection
addCollectionP2 :: QErrM m => CollectionDef -> m ()
runCreateCollection :: (QErrM m, CacheRWM m, MetadataM m) => CreateCollection -> m EncJSON
runRenameCollection :: (QErrM m, CacheRWM m, MetadataM m) => RenameCollection -> m EncJSON
runAddQueryToCollection :: (CacheRWM m, MonadError QErr m, MetadataM m) => AddQueryToCollection -> m EncJSON
runDropCollection :: (MonadError QErr m, MetadataM m, CacheRWM m) => DropCollection -> m EncJSON
runDropQueryFromCollection :: (CacheRWM m, MonadError QErr m, MetadataM m) => DropQueryFromCollection -> m EncJSON
runAddCollectionToAllowlist :: (MonadError QErr m, MetadataM m, CacheRWM m) => AllowlistEntry -> m EncJSON
dropCollectionFromAllowlist :: (MonadError QErr m, MetadataM m) => CollectionName -> m MetadataModifier
runDropCollectionFromAllowlist :: (MonadError QErr m, MetadataM m, CacheRWM m) => DropCollectionFromAllowlist -> m EncJSON
runUpdateScopeOfCollectionInAllowlist :: (MonadError QErr m, MetadataM m, CacheRWM m) => UpdateScopeOfCollectionInAllowlist -> m EncJSON
assertCollectionDefined :: (QErrM m, MetadataM m) => CollectionName -> m ()
getCollectionDef :: (QErrM m, MetadataM m) => CollectionName -> m CreateCollection
getCollectionDefM :: (QErrM m, MetadataM m) => CollectionName -> m (Maybe CreateCollection)
fetchAllCollections :: MetadataM m => m QueryCollections
fetchAllowlist :: MetadataM m => m MetadataAllowlist
fetchAllAllowlistCollections :: MetadataM m => m [CollectionName]

module Hasura.RQL.DDL.CustomTypes
runSetCustomTypes :: (MonadError QErr m, CacheRWM m, MetadataM m) => CustomTypes -> m EncJSON
clearCustomTypesInMetadata :: MetadataModifier
resolveCustomTypes :: MonadError QErr m => SourceCache -> CustomTypes -> BackendMap ScalarMap -> m AnnotatedCustomTypes

-- | Validate the custom types and return any reused Postgres base types
--   (as scalars).
validateCustomTypeDefinitions :: forall m. MonadValidate [CustomTypeValidationError] m => SourceCache -> CustomTypes -> BackendMap ScalarMap -> m AnnotatedCustomTypes
lookupBackendScalar :: BackendMap ScalarMap -> Name -> Maybe AnnotatedScalarType
data CustomTypeValidationError

-- | type names have to be unique across all types
DuplicateTypeNames :: HashSet Name -> CustomTypeValidationError

-- | field name and the field's base type
InputObjectFieldTypeDoesNotExist :: InputObjectTypeName -> InputObjectFieldName -> Name -> CustomTypeValidationError

-- | duplicate field declaration in input objects
InputObjectDuplicateFields :: InputObjectTypeName -> HashSet InputObjectFieldName -> CustomTypeValidationError

-- | field name and the field's base type
ObjectFieldTypeDoesNotExist :: ObjectTypeName -> ObjectFieldName -> Name -> CustomTypeValidationError

-- | duplicate field declaration in objects
ObjectDuplicateFields :: ObjectTypeName -> HashSet Name -> CustomTypeValidationError

-- | object fields can't have arguments
ObjectFieldArgumentsNotAllowed :: ObjectTypeName -> ObjectFieldName -> CustomTypeValidationError

-- | object fields can't have object types as base types
ObjectFieldObjectBaseType :: ObjectTypeName -> ObjectFieldName -> Name -> CustomTypeValidationError

-- | The table specified in the relationship does not exist
ObjectRelationshipTableDoesNotExist :: ObjectTypeName -> RelationshipName -> QualifiedTable -> CustomTypeValidationError

-- | The field specified in the relationship mapping does not exist
ObjectRelationshipFieldDoesNotExist :: ObjectTypeName -> RelationshipName -> ObjectFieldName -> CustomTypeValidationError

-- | The field specified in the relationship mapping is a list type
ObjectRelationshipFieldListType :: ObjectTypeName -> RelationshipName -> ObjectFieldName -> CustomTypeValidationError

-- | The column specified in the relationship mapping does not exist
ObjectRelationshipColumnDoesNotExist :: ObjectTypeName -> RelationshipName -> QualifiedTable -> PGCol -> CustomTypeValidationError

-- | Object relationship refers to table in multiple sources
ObjectRelationshipMultiSources :: ObjectTypeName -> CustomTypeValidationError

-- | duplicate enum values
DuplicateEnumValues :: EnumTypeName -> HashSet EnumValue -> CustomTypeValidationError
showCustomTypeValidationError :: CustomTypeValidationError -> Text
instance GHC.Classes.Eq Hasura.RQL.DDL.CustomTypes.CustomTypeValidationError
instance GHC.Show.Show Hasura.RQL.DDL.CustomTypes.CustomTypeValidationError

module Hasura.RQL.DDL.ApiLimit
runSetApiLimits :: (MonadError QErr m, MetadataM m, CacheRWM m) => ApiLimit -> m EncJSON
runRemoveApiLimits :: (MonadError QErr m, MetadataM m, CacheRWM m) => m EncJSON


-- | This module defines the schema dependency gathering aspect of the
--   default implementation of aggregation predicates.
module Hasura.RQL.Types.SchemaCache.AggregationPredicates
defaultGetAggregationPredicateDeps :: forall b. (Backend b, GetAggregationPredicatesDeps b) => AggregationPredicatesImplementation b (PartialSQLExp b) -> BoolExpM b [SchemaDependency]

module Hasura.Backends.Postgres.Instances.SchemaCache
instance Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind) => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps ('Hasura.SQL.Backend.Postgres pgKind)

module Hasura.RQL.Types.SchemaCache.Instances

module Hasura.RQL.Types.Roles.Internal

-- | <a>CheckPermission</a> is a type which can be used to combine multiple
--   permissions when the permission type implements the
--   <tt>OnlyRelevantEq</tt> instance
data CheckPermission permissionType
CPUndefined :: CheckPermission permissionType
CPInconsistent :: CheckPermission permissionType
CPDefined :: permissionType -> CheckPermission permissionType

-- | CombineRolePermInfo acts as an intermediate type to be able to combine
--   multiple role permissions into one, using the <a>Monoid</a> instance.
--   Multiple role permissions are combined for inherited role permissions
--   where this is used.
data CombineRolePermInfo (b :: BackendType)
CombineRolePermInfo :: CheckPermission (InsPermInfo b) -> Maybe (CombinedSelPermInfo b) -> CheckPermission (UpdPermInfo b) -> CheckPermission (DelPermInfo b) -> CombineRolePermInfo (b :: BackendType)
[crpiInsPerm] :: CombineRolePermInfo (b :: BackendType) -> CheckPermission (InsPermInfo b)
[crpiSelPerm] :: CombineRolePermInfo (b :: BackendType) -> Maybe (CombinedSelPermInfo b)
[crpiUpdPerm] :: CombineRolePermInfo (b :: BackendType) -> CheckPermission (UpdPermInfo b)
[crpiDelPerm] :: CombineRolePermInfo (b :: BackendType) -> CheckPermission (DelPermInfo b)
rolePermInfoToCombineRolePermInfo :: RolePermInfo b -> CombineRolePermInfo b

-- | <a>OnlyRelevantEq</a> is a type class to implement checking if two
--   types have the relevant info of a type equal. This typeclass is almost
--   like the <a>Eq</a> typeclass but gives the flexibility of having
--   custom rules to check the equality of only the relevant data. Some use
--   cases of it are:
--   
--   <ol>
--   <li>When comparing two <a>ScalarTypeDefinition</a>, the description of
--   the type doesn't matter.</li>
--   <li>The directives are represented as a list, but the order of the
--   directives don't matter</li>
--   </ol>
--   
--   Note: When there's nothing there to discard in a type, the
--   <a>OnlyRelevantEq</a> can be derived as (if needed)
--   
--   instance OnlyRelevantEq a where relevantEq = (==)
--   
--   NOTE: Do not export this type class from this module, as it is only
--   intended to be used in the context of inherited roles. If you think
--   this typeclass fits your use case, then please discuss this with
--   Karthikeyan or in Slack thread to make this a generic typeclass.
class OnlyRelevantEq a
relevantEq :: OnlyRelevantEq a => a -> a -> Bool
maybeToCheckPermission :: Maybe a -> CheckPermission a
instance GHC.Classes.Eq permissionType => GHC.Classes.Eq (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)
instance GHC.Show.Show permissionType => GHC.Show.Show (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq permissionType => GHC.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq permissionType => GHC.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a, Data.Hashable.Class.Hashable a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.OpExpG b a), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.OpExpG b a), Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.Types.Table.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.Types.Table.UpdPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.Types.Table.DelPermInfo b)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Hasura.RQL.Types.RemoteSchema.RemoteSchemaInputValueDefinition
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Hasura.RQL.Types.RemoteSchema.RemoteSchemaIntrospection
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Hasura.RQL.Types.SchemaCache.IntrospectionResult
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (GHC.Maybe.Maybe a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.Name
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq [a]
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.ScalarTypeDefinition
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.FieldDefinition a)
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.ObjectTypeDefinition a)
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.InterfaceTypeDefinition [Language.GraphQL.Draft.Syntax.Name] a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.UnionTypeDefinition
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.InputObjectTypeDefinition a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.EnumValueDefinition
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.EnumTypeDefinition
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.TypeDefinition [Language.GraphQL.Draft.Syntax.Name] a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.InputValueDefinition
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.RQL.Types.Table.DelPermInfo b)), GHC.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.RQL.Types.Table.InsPermInfo b)), GHC.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.RQL.Types.Table.UpdPermInfo b)), GHC.Base.Semigroup (Hasura.RQL.Types.Table.CombinedSelPermInfo b)) => GHC.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CombineRolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.RQL.Types.Table.DelPermInfo b)), GHC.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.RQL.Types.Table.InsPermInfo b)), GHC.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.RQL.Types.Table.UpdPermInfo b)), GHC.Base.Monoid (GHC.Maybe.Maybe (Hasura.RQL.Types.Table.CombinedSelPermInfo b))) => GHC.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CombineRolePermInfo b)

module Hasura.RQL.Types.Metadata.Backend
class (Backend b, Eq (AggregationPredicates b (PartialSQLExp b)), Eq (BooleanOperators b (PartialSQLExp b)), Eq (FunctionArgumentExp b (PartialSQLExp b)), Hashable (AggregationPredicates b (PartialSQLExp b)), Hashable (BooleanOperators b (PartialSQLExp b)), Hashable (FunctionArgumentExp b (PartialSQLExp b))) => BackendMetadata (b :: BackendType)
buildComputedFieldInfo :: (BackendMetadata b, MonadError QErr m) => HashSet (TableName b) -> TableName b -> HashSet (Column b) -> ComputedFieldName -> ComputedFieldDefinition b -> RawFunctionInfo b -> Comment -> m (ComputedFieldInfo b)
fetchAndValidateEnumValues :: (BackendMetadata b, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> TableName b -> Maybe (PrimaryKey b (RawColumnInfo b)) -> [RawColumnInfo b] -> m (Either QErr EnumValues)

-- | Function that resolves the connection related source configuration,
--   and creates a connection pool (and other related parameters) in the
--   process
resolveSourceConfig :: (BackendMetadata b, MonadIO m, MonadResolveSource m) => Logger Hasura -> SourceName -> SourceConnConfiguration b -> BackendSourceKind b -> BackendConfig b -> Environment -> Manager -> m (Either QErr (SourceConfig b))

-- | Function that introspects a database for tables, columns, functions
--   etc.
resolveDatabaseMetadata :: (BackendMetadata b, MonadIO m, MonadBaseControl IO m, MonadResolveSource m) => SourceMetadata b -> SourceConfig b -> SourceTypeCustomization -> m (Either QErr (ResolvedSource b))
parseBoolExpOperations :: (BackendMetadata b, MonadError QErr m, TableCoreInfoRM b m) => ValueParser b m v -> TableName b -> FieldInfoMap (FieldInfo b) -> ColumnReference b -> Value -> m [OpExpG b v]
buildFunctionInfo :: (BackendMetadata b, MonadError QErr m) => SourceName -> FunctionName b -> SystemDefined -> FunctionConfig -> FunctionPermissionsMap -> RawFunctionInfo b -> Maybe Text -> NamingCase -> m (FunctionInfo b, SchemaDependency)
updateColumnInEventTrigger :: BackendMetadata b => TableName b -> Column b -> Column b -> TableName b -> EventTriggerConf b -> EventTriggerConf b
parseCollectableType :: (BackendMetadata b, MonadError QErr m) => CollectableType (ColumnType b) -> Value -> m (PartialSQLExp b)
postDropSourceHook :: (BackendMetadata b, MonadError QErr m, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> TableEventTriggers b -> m ()
validateRelationship :: (BackendMetadata b, MonadError QErr m) => TableCache b -> TableName b -> Either (ObjRelDef b) (ArrRelDef b) -> m ()
validateRelationship :: (BackendMetadata b, MonadError QErr m) => TableCache b -> TableName b -> Either (ObjRelDef b) (ArrRelDef b) -> m ()

-- | Function that that builds a boolean expression field out of a computed
--   field
buildComputedFieldBooleanExp :: (BackendMetadata b, MonadError QErr m, TableCoreInfoRM b m) => BoolExpResolver b m v -> BoolExpRHSParser b m v -> TableName b -> FieldInfoMap (FieldInfo b) -> ComputedFieldInfo b -> Value -> m (AnnComputedFieldBoolExp b v)

-- | Run all operations required to create, update, or migrate the internal
--   catalog used by the backend for internal bookkeeping, if any. The
--   return type indicates whether the performed operations subsequently
--   require re-creating event trigers.
prepareCatalog :: (BackendMetadata b, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> ExceptT QErr m RecreateEventTriggers

module Hasura.Backends.MySQL.Instances.Metadata
instance Hasura.RQL.Types.Metadata.Backend.BackendMetadata 'Hasura.SQL.Backend.MySQL


-- | Functions for fetching and updating @<a>Metadata</a> in the catalog.
module Hasura.RQL.DDL.Schema.Catalog
fetchMetadataFromCatalog :: TxE QErr Metadata
fetchMetadataAndResourceVersionFromCatalog :: TxE QErr (Metadata, MetadataResourceVersion)
fetchMetadataResourceVersionFromCatalog :: TxE QErr MetadataResourceVersion
fetchMetadataNotificationsFromCatalog :: MetadataResourceVersion -> InstanceId -> TxE QErr [(MetadataResourceVersion, CacheInvalidations)]
bumpMetadataVersionInCatalog :: TxE QErr ()
insertMetadataInCatalog :: Metadata -> TxE QErr ()

-- | Check that the specified resource version matches the currently stored
--   one, and...
--   
--   <ul>
--   <li>If so: Update the metadata and bump the version</li>
--   <li>If not: Throw a 409 error</li>
--   </ul>
setMetadataInCatalog :: MetadataResourceVersion -> Metadata -> TxE QErr MetadataResourceVersion


-- | Validate input queries against remote schemas.
module Hasura.RQL.DDL.RemoteRelationship.Validate

-- | An error validating the remote relationship.
data ValidationError
RemoteSchemaNotFound :: RemoteSchemaName -> ValidationError
CouldntFindRemoteField :: Name -> Name -> ValidationError
FieldNotFoundInRemoteSchema :: Name -> ValidationError
NoSuchArgumentForRemote :: Name -> ValidationError
MissingRequiredArgument :: Name -> ValidationError
TypeNotFound :: Name -> ValidationError
JoinFieldNonExistent :: LHSIdentifier -> FieldName -> HashSet FieldName -> ValidationError
ExpectedTypeButGot :: GType -> GType -> ValidationError
InvalidType :: GType -> Text -> ValidationError
InvalidVariable :: Name -> HashSet Name -> ValidationError
NullNotAllowedHere :: ValidationError
InvalidGTypeForStripping :: GType -> ValidationError
UnsupportedMultipleElementLists :: ValidationError
UnsupportedEnum :: ValidationError
InvalidGraphQLName :: Text -> ValidationError
IDTypeJoin :: Name -> ValidationError

-- | TODO: Can this be made not reachable? This is the case where the type
--   of the columns that are mapped do not have a graphql representation.
--   This case is probably not reachable as having a db type which can't be
--   representable in GraphQL should definitely fail the entire schema
--   generation process
CannotGenerateGraphQLTypeName :: Name -> ValidationError
errorToText :: ValidationError -> Text

-- | Validate a remote schema relationship given a context.
validateToSchemaRelationship :: MonadError ValidationError m => ToSchemaRelationshipDef -> LHSIdentifier -> RelName -> (RemoteSchemaInfo, IntrospectionResult) -> HashMap FieldName joinField -> m (HashMap FieldName joinField, RemoteSchemaFieldInfo)

-- | Return a map with keys deleted whose template argument is specified as
--   an atomic (variable, constant), keys which are kept have their values
--   modified by <a>stripObject</a> or <a>stripList</a>. This function
--   creates the 'HashMap G.Name G.InputValueDefinition' which modifies the
--   original input parameters (if any) of the remote node/table being
--   used. Only list or object types are preserved and other types are
--   stripped off. The object or list types are preserved because they can
--   be merged, if any arguments are provided by the user while querying a
--   remote join field.
stripInMap :: RelName -> LHSIdentifier -> RemoteSchemaIntrospection -> HashMap Name RemoteSchemaInputValueDefinition -> HashMap Name (Value Name) -> StateT (HashMap Name (TypeDefinition [Name] RemoteSchemaInputValueDefinition)) (Either ValidationError) (HashMap Name RemoteSchemaInputValueDefinition)

-- | Strip a value type completely, or modify it, if the given value is
--   atomic-ish.
stripValue :: RelName -> LHSIdentifier -> RemoteSchemaIntrospection -> GType -> Value Name -> StateT (HashMap Name (TypeDefinition [Name] RemoteSchemaInputValueDefinition)) (Either ValidationError) (Maybe GType)

-- | Produce a new type for the list, or strip it entirely.
stripList :: RelName -> LHSIdentifier -> RemoteSchemaIntrospection -> GType -> Value Name -> StateT (HashMap Name (TypeDefinition [Name] RemoteSchemaInputValueDefinition)) (Either ValidationError) (Maybe GType)

-- | Produce a new type for the given InpValInfo, modified by
--   <a>stripInMap</a>. Objects can't be deleted entirely, just keys of an
--   object.
stripObject :: RelName -> LHSIdentifier -> RemoteSchemaIntrospection -> GType -> HashMap Name (Value Name) -> StateT (HashMap Name (TypeDefinition [Name] RemoteSchemaInputValueDefinition)) (Either ValidationError) GType

-- | Produce a new name for a type, used when stripping the schema types
--   for a remote relationship. TODO: Consider a separator character to
--   avoid conflicts.
renameTypeForRelationship :: MonadError ValidationError m => RelName -> LHSIdentifier -> Name -> m Name

-- | Convert a field name to a variable name.
hasuraFieldToVariable :: MonadError ValidationError m => FieldName -> m Name

-- | Lookup the field in the schema.
lookupField :: MonadError ValidationError m => Name -> ObjectTypeDefinition RemoteSchemaInputValueDefinition -> m (FieldDefinition RemoteSchemaInputValueDefinition)

-- | Validate remote input arguments against the remote schema.
validateRemoteArguments :: MonadError ValidationError m => HashMap Name RemoteSchemaInputValueDefinition -> HashMap Name (Value Name) -> HashMap Name joinField -> RemoteSchemaIntrospection -> m ()
unwrapGraphQLType :: GType -> GType

-- | Validate a value against a type.
validateType :: MonadError ValidationError m => HashMap Name joinField -> Value Name -> GType -> RemoteSchemaIntrospection -> m ()
isTypeCoercible :: MonadError ValidationError m => GType -> GType -> m ()
assertListType :: MonadError ValidationError m => GType -> m ()
getBaseTyWithNestedLevelsCount :: GType -> (Name, Int)
instance GHC.Classes.Eq Hasura.RQL.DDL.RemoteRelationship.Validate.ValidationError
instance GHC.Show.Show Hasura.RQL.DDL.RemoteRelationship.Validate.ValidationError

module Hasura.RQL.DDL.RemoteRelationship

-- | Argument to the <tt>_create_remote_relationship</tt> and
--   <tt>_update_remote_relationship</tt> families of metadata commands.
--   
--   For historical reason, this type is also used to represent a db-to-rs
--   schema in the metadata.
data CreateFromSourceRelationship (b :: BackendType)
CreateFromSourceRelationship :: SourceName -> TableName b -> RelName -> RemoteRelationshipDefinition -> CreateFromSourceRelationship (b :: BackendType)
[_crrSource] :: CreateFromSourceRelationship (b :: BackendType) -> SourceName
[_crrTable] :: CreateFromSourceRelationship (b :: BackendType) -> TableName b
[_crrName] :: CreateFromSourceRelationship (b :: BackendType) -> RelName
[_crrDefinition] :: CreateFromSourceRelationship (b :: BackendType) -> RemoteRelationshipDefinition
runCreateRemoteRelationship :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => CreateFromSourceRelationship b -> m EncJSON
runUpdateRemoteRelationship :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => CreateFromSourceRelationship b -> m EncJSON

-- | Argument to the <tt>_drop_remote_relationship</tt> family of metadata
--   commands.
data DeleteFromSourceRelationship (b :: BackendType)
DeleteFromSourceRelationship :: SourceName -> TableName b -> RelName -> DeleteFromSourceRelationship (b :: BackendType)
[_drrSource] :: DeleteFromSourceRelationship (b :: BackendType) -> SourceName
[_drrTable] :: DeleteFromSourceRelationship (b :: BackendType) -> TableName b
[_drrName] :: DeleteFromSourceRelationship (b :: BackendType) -> RelName
runDeleteRemoteRelationship :: forall b m. (BackendMetadata b, MonadError QErr m, CacheRWM m, MetadataM m) => DeleteFromSourceRelationship b -> m EncJSON
data CreateRemoteSchemaRemoteRelationship
CreateRemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> RemoteRelationshipDefinition -> CreateRemoteSchemaRemoteRelationship
[_crsrrRemoteSchema] :: CreateRemoteSchemaRemoteRelationship -> RemoteSchemaName
[_crsrrType] :: CreateRemoteSchemaRemoteRelationship -> Name
[_crsrrName] :: CreateRemoteSchemaRemoteRelationship -> RelName
[_crsrrDefinition] :: CreateRemoteSchemaRemoteRelationship -> RemoteRelationshipDefinition
runCreateRemoteSchemaRemoteRelationship :: forall m. (MonadError QErr m, CacheRWM m, MetadataM m) => CreateRemoteSchemaRemoteRelationship -> m EncJSON
runUpdateRemoteSchemaRemoteRelationship :: forall m. (MonadError QErr m, CacheRWM m, MetadataM m) => CreateRemoteSchemaRemoteRelationship -> m EncJSON

-- | Argument to the <tt>_drop_remote_relationship</tt> family of metadata
--   commands.
data DeleteRemoteSchemaRemoteRelationship
DeleteRemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> DeleteRemoteSchemaRemoteRelationship
[_drsrrRemoteSchema] :: DeleteRemoteSchemaRemoteRelationship -> RemoteSchemaName
[_drsrrTypeName] :: DeleteRemoteSchemaRemoteRelationship -> Name
[_drsrrName] :: DeleteRemoteSchemaRemoteRelationship -> RelName
runDeleteRemoteSchemaRemoteRelationship :: forall m. (MonadError QErr m, CacheRWM m, MetadataM m) => DeleteRemoteSchemaRemoteRelationship -> m EncJSON

-- | Internal intermediary step.
--   
--   We build the output of sources in two steps: 1. we first resolve
--   sources, and collect the core info of their tables 2. we then build
--   the entire output from the collection of partially resolved sources
--   
--   We need this split to be able to resolve cross-source relationships:
--   to process one source's remote relationship, we need to know about the
--   target source's tables core info.
--   
--   This data structure is used as an argument to <tt>AnyBackend</tt> in
--   the backend-agnostic intermediary collection, and used here to build
--   remote field info.
data PartiallyResolvedSource b
PartiallyResolvedSource :: SourceMetadata b -> ResolvedSource b -> HashMap (TableName b) (TableCoreInfoG b (ColumnInfo b) (ColumnInfo b)) -> HashMap (TableName b) (EventTriggerInfoMap b) -> PartiallyResolvedSource b
[_prsSourceMetadata] :: PartiallyResolvedSource b -> SourceMetadata b
[_resolvedSource] :: PartiallyResolvedSource b -> ResolvedSource b
[_tableCoreInfoMap] :: PartiallyResolvedSource b -> HashMap (TableName b) (TableCoreInfoG b (ColumnInfo b) (ColumnInfo b))
[_eventTriggerInfoMap] :: PartiallyResolvedSource b -> HashMap (TableName b) (EventTriggerInfoMap b)

-- | Builds the schema cache representation of a remote relationship TODO:
--   this is not actually called by the remote relationship DDL API and is
--   only used as part of the schema cache process. Should this be moved
--   elsewhere?
buildRemoteFieldInfo :: QErrM m => LHSIdentifier -> HashMap FieldName lhsJoinField -> RemoteRelationship -> HashMap SourceName (AnyBackend PartiallyResolvedSource) -> RemoteSchemaMap -> m (RemoteFieldInfo lhsJoinField, [SchemaDependency])
getRemoteSchemaEntityJoinColumns :: MonadError QErr m => RemoteSchemaName -> RemoteSchemaIntrospection -> Name -> m (HashMap FieldName Name)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.RemoteRelationship.DeleteRemoteSchemaRemoteRelationship
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.RemoteRelationship.CreateRemoteSchemaRemoteRelationship
instance GHC.Generics.Generic Hasura.RQL.DDL.RemoteRelationship.CreateRemoteSchemaRemoteRelationship
instance GHC.Classes.Eq (Hasura.RQL.Types.Backend.TableName b) => GHC.Classes.Eq (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)
instance GHC.Show.Show (Hasura.RQL.Types.Backend.TableName b) => GHC.Show.Show (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.RemoteRelationship.CreateRemoteSchemaRemoteRelationship
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.RemoteRelationship.DeleteFromSourceRelationship b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)

module Hasura.RQL.DDL.InheritedRoles
runAddInheritedRole :: (MonadError QErr m, CacheRWM m, MetadataM m) => InheritedRole -> m EncJSON
dropInheritedRoleInMetadata :: RoleName -> MetadataModifier
runDropInheritedRole :: (MonadError QErr m, CacheRWM m, MetadataM m) => DropInheritedRole -> m EncJSON

-- | <a>resolveInheritedRole</a> resolves an inherited role by checking if
--   all the parent roles of an inherited role exists and report the
--   dependencies of the inherited role which will be the list of the
--   parent roles
resolveInheritedRole :: MonadError QErr m => HashSet RoleName -> InheritedRole -> m (Role, [SchemaDependency])

module Hasura.RQL.DDL.EventTrigger
data CreateEventTriggerQuery (b :: BackendType)
CreateEventTriggerQuery :: SourceName -> TriggerName -> TableName b -> Maybe (SubscribeOpSpec b) -> Maybe (SubscribeOpSpec b) -> Maybe (SubscribeOpSpec b) -> Maybe Bool -> Maybe RetryConf -> Maybe InputWebhook -> Maybe Text -> Maybe [HeaderConf] -> Bool -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CreateEventTriggerQuery (b :: BackendType)
[_cetqSource] :: CreateEventTriggerQuery (b :: BackendType) -> SourceName
[_cetqName] :: CreateEventTriggerQuery (b :: BackendType) -> TriggerName
[_cetqTable] :: CreateEventTriggerQuery (b :: BackendType) -> TableName b
[_cetqInsert] :: CreateEventTriggerQuery (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[_cetqUpdate] :: CreateEventTriggerQuery (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[_cetqDelete] :: CreateEventTriggerQuery (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[_cetqEnableManual] :: CreateEventTriggerQuery (b :: BackendType) -> Maybe Bool
[_cetqRetryConf] :: CreateEventTriggerQuery (b :: BackendType) -> Maybe RetryConf
[_cetqWebhook] :: CreateEventTriggerQuery (b :: BackendType) -> Maybe InputWebhook
[_cetqWebhookFromEnv] :: CreateEventTriggerQuery (b :: BackendType) -> Maybe Text
[_cetqHeaders] :: CreateEventTriggerQuery (b :: BackendType) -> Maybe [HeaderConf]
[_cetqReplace] :: CreateEventTriggerQuery (b :: BackendType) -> Bool
[_cetqRequestTransform] :: CreateEventTriggerQuery (b :: BackendType) -> Maybe RequestTransform
[_cetqResponseTrasnform] :: CreateEventTriggerQuery (b :: BackendType) -> Maybe MetadataResponseTransform
cetqWebhookFromEnv :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) (Maybe Text)
cetqWebhook :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) (Maybe InputWebhook)
cetqUpdate :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) (Maybe (SubscribeOpSpec b_aszvX))
cetqTable :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) (TableName b_aszvX)
cetqSource :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) SourceName
cetqRetryConf :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) (Maybe RetryConf)
cetqResponseTrasnform :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) (Maybe MetadataResponseTransform)
cetqRequestTransform :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) (Maybe RequestTransform)
cetqReplace :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) Bool
cetqName :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) TriggerName
cetqInsert :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) (Maybe (SubscribeOpSpec b_aszvX))
cetqHeaders :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) (Maybe [HeaderConf])
cetqEnableManual :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) (Maybe Bool)
cetqDelete :: forall b_aszvX. Lens' (CreateEventTriggerQuery b_aszvX) (Maybe (SubscribeOpSpec b_aszvX))
data DeleteEventTriggerQuery (b :: BackendType)
DeleteEventTriggerQuery :: SourceName -> TriggerName -> DeleteEventTriggerQuery (b :: BackendType)
[_detqSource] :: DeleteEventTriggerQuery (b :: BackendType) -> SourceName
[_detqName] :: DeleteEventTriggerQuery (b :: BackendType) -> TriggerName
data RedeliverEventQuery (b :: BackendType)
RedeliverEventQuery :: EventId -> SourceName -> RedeliverEventQuery (b :: BackendType)
[_rdeqEventId] :: RedeliverEventQuery (b :: BackendType) -> EventId
[_rdeqSource] :: RedeliverEventQuery (b :: BackendType) -> SourceName
data InvokeEventTriggerQuery (b :: BackendType)
InvokeEventTriggerQuery :: TriggerName -> SourceName -> Value -> InvokeEventTriggerQuery (b :: BackendType)
[_ietqName] :: InvokeEventTriggerQuery (b :: BackendType) -> TriggerName
[_ietqSource] :: InvokeEventTriggerQuery (b :: BackendType) -> SourceName
[_ietqPayload] :: InvokeEventTriggerQuery (b :: BackendType) -> Value
resolveEventTriggerQuery :: forall b m. (Backend b, UserInfoM m, QErrM m, CacheRM m) => CreateEventTriggerQuery b -> m (Bool, EventTriggerConf b)
droppedTriggerOps :: TriggerOpsDef b -> TriggerOpsDef b -> HashSet Ops
createEventTriggerQueryMetadata :: forall b m. (BackendMetadata b, QErrM m, UserInfoM m, CacheRWM m, MetadataM m, BackendEventTrigger b, MonadIO m) => CreateEventTriggerQuery b -> m ()
runCreateEventTriggerQuery :: forall b m. (BackendMetadata b, BackendEventTrigger b, QErrM m, UserInfoM m, CacheRWM m, MetadataM m, MonadIO m) => CreateEventTriggerQuery b -> m EncJSON
runDeleteEventTriggerQuery :: forall b m. (BackendEventTrigger b, MonadError QErr m, CacheRWM m, MonadIO m, MetadataM m) => DeleteEventTriggerQuery b -> m EncJSON
runRedeliverEvent :: forall b m. (BackendEventTrigger b, MonadIO m, CacheRM m, QErrM m, MetadataM m) => RedeliverEventQuery b -> m EncJSON
runInvokeEventTrigger :: forall b m. (MonadIO m, QErrM m, CacheRM m, MetadataM m, MonadTrace m, UserInfoM m, BackendEventTrigger b) => InvokeEventTriggerQuery b -> m EncJSON
askTabInfoFromTrigger :: (Backend b, QErrM m, CacheRM m) => SourceName -> TriggerName -> m (TableInfo b)
getTabInfoFromSchemaCache :: (Backend b, QErrM m) => SchemaCache -> SourceName -> TriggerName -> m (TableInfo b)
askEventTriggerInfo :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> TriggerName -> m (EventTriggerInfo b)
maxTriggerNameLength :: Int
getHeaderInfosFromConf :: QErrM m => Environment -> [HeaderConf] -> m [EventHeaderInfo]
getWebhookInfoFromConf :: QErrM m => Environment -> WebhookConf -> m WebhookConfInfo
buildEventTriggerInfo :: forall b m. (Backend b, QErrM m) => Environment -> SourceName -> TableName b -> EventTriggerConf b -> m (EventTriggerInfo b, [SchemaDependency])
getTrigDefDeps :: forall b. Backend b => SourceName -> TableName b -> TriggerOpsDef b -> [SchemaDependency]
getTriggersMap :: SourceMetadata b -> InsOrdHashMap TriggerName (EventTriggerConf b)
getTriggerNames :: SourceMetadata b -> HashSet TriggerName
getTableNameFromTrigger :: forall b m. (Backend b, QErrM m) => SchemaCache -> SourceName -> TriggerName -> m (TableName b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.InvokeEventTriggerQuery b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.RedeliverEventQuery b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.DeleteEventTriggerQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.CreateEventTriggerQuery b)


-- | This module has type class and types which implements the Metadata
--   Storage Abstraction
module Hasura.Metadata.Class
data SchemaSyncEventProcessResult
SchemaSyncEventProcessResult :: !Bool -> !CacheInvalidations -> SchemaSyncEventProcessResult
[_sseprShouldReload] :: SchemaSyncEventProcessResult -> !Bool
[_sseprCacheInvalidations] :: SchemaSyncEventProcessResult -> !CacheInvalidations

-- | Metadata storage abstraction via a type class.
--   
--   This type class enables storing and managing Hasura metadata in an
--   isolated database which will not interfere with user's database where
--   tables/functions are defined. Hence, it'll enable support for
--   databases of multiple backends like MySQL, MSSQL etc.
--   
--   This class has functions broadly related to:
--   
--   <ol>
--   <li>Metadata Management ---------------------- Basic metadata
--   management functions such as retrieving metadata from storage database
--   and replacing the given metadata. TODO: Console specific
--   operations</li>
--   <li>Scheduled Triggers --------------------- Eventing sub-system for
--   scheduled triggers is implemented via metadata storage. For more
--   details, refer description in <a>ScheduledTrigger</a> module.</li>
--   </ol>
--   
--   TODO: Functions need to be added to the type class - Retrieving
--   invocation logs from storage (console requirement) - Deleting an
--   scheduled event - Creating an one-off scheduled event
--   
--   <ol>
--   <li>Async Actions ---------------- Operations to implement async
--   actions sub-system. This includes recording an async action event and
--   retreiving the details of action delivery to the webhook. For more
--   details see Note [Async action architecture] in <a>Action</a>
--   module.</li>
--   </ol>
--   
--   It is believed that all the above three are implemented in a single
--   storage system (ex: a Postgres database). We can split the functions
--   into appropriate and specific type classes in future iterations if
--   required.
class (MonadError QErr m) => MonadMetadataStorage m
fetchMetadataResourceVersion :: MonadMetadataStorage m => m MetadataResourceVersion
fetchMetadata :: MonadMetadataStorage m => m (Metadata, MetadataResourceVersion)
fetchMetadataNotifications :: MonadMetadataStorage m => MetadataResourceVersion -> InstanceId -> m [(MetadataResourceVersion, CacheInvalidations)]
setMetadata :: MonadMetadataStorage m => MetadataResourceVersion -> Metadata -> m MetadataResourceVersion
notifySchemaCacheSync :: MonadMetadataStorage m => MetadataResourceVersion -> InstanceId -> CacheInvalidations -> m ()
getCatalogState :: MonadMetadataStorage m => m CatalogState
setCatalogState :: MonadMetadataStorage m => CatalogStateType -> Value -> m ()
getMetadataDbUid :: MonadMetadataStorage m => m MetadataDbId
checkMetadataStorageHealth :: MonadMetadataStorage m => m ()
getDeprivedCronTriggerStats :: MonadMetadataStorage m => [TriggerName] -> m [CronTriggerStats]
getScheduledEventsForDelivery :: MonadMetadataStorage m => m ([CronEvent], [OneOffScheduledEvent])
insertCronEvents :: MonadMetadataStorage m => [CronEventSeed] -> m ()
insertOneOffScheduledEvent :: MonadMetadataStorage m => OneOffEvent -> m EventId
insertScheduledEventInvocation :: MonadMetadataStorage m => Invocation 'ScheduledType -> ScheduledEventType -> m ()
setScheduledEventOp :: MonadMetadataStorage m => ScheduledEventId -> ScheduledEventOp -> ScheduledEventType -> m ()
unlockScheduledEvents :: MonadMetadataStorage m => ScheduledEventType -> [ScheduledEventId] -> m Int
unlockAllLockedScheduledEvents :: MonadMetadataStorage m => m ()
clearFutureCronEvents :: MonadMetadataStorage m => ClearCronEvents -> m ()
getOneOffScheduledEvents :: MonadMetadataStorage m => ScheduledEventPagination -> [ScheduledEventStatus] -> m (WithTotalCount [OneOffScheduledEvent])
getCronEvents :: MonadMetadataStorage m => TriggerName -> ScheduledEventPagination -> [ScheduledEventStatus] -> m (WithTotalCount [CronEvent])
getInvocations :: MonadMetadataStorage m => GetInvocationsBy -> ScheduledEventPagination -> m (WithTotalCount [ScheduledEventInvocation])
deleteScheduledEvent :: MonadMetadataStorage m => ScheduledEventId -> ScheduledEventType -> m ()
insertAction :: MonadMetadataStorage m => ActionName -> SessionVariables -> [Header] -> Value -> m ActionId
fetchUndeliveredActionEvents :: MonadMetadataStorage m => m [ActionLogItem]
setActionStatus :: MonadMetadataStorage m => ActionId -> AsyncActionStatus -> m ()
fetchActionResponse :: MonadMetadataStorage m => ActionId -> m ActionLogResponse
clearActionData :: MonadMetadataStorage m => ActionName -> m ()
setProcessingActionLogsToPending :: MonadMetadataStorage m => LockedActionIdArray -> m ()

-- | The <a>MetadataStorageT</a> transformer adds ability to throw
--   exceptions for monads deriving @<a>MonadMetadataStorage</a> instance.
--   For more details see Note [Generic MetadataStorageT transformer]
newtype MetadataStorageT m a
MetadataStorageT :: ExceptT QErr m a -> MetadataStorageT m a
[unMetadataStorageT] :: MetadataStorageT m a -> ExceptT QErr m a
runMetadataStorageT :: MetadataStorageT m a -> m (Either QErr a)

-- | Operations from @<a>MonadMetadataStorage</a> used in '<i>v1</i>query'
--   and '<i>v1</i>metadata' APIs
class (MonadMetadataStorage m) => MonadMetadataStorageQueryAPI m

-- | Record a one-off event
createOneOffScheduledEvent :: MonadMetadataStorageQueryAPI m => OneOffEvent -> m EventId

-- | Record a cron event
createCronEvents :: MonadMetadataStorageQueryAPI m => [CronEventSeed] -> m ()

-- | Clear cron events
dropFutureCronEvents :: MonadMetadataStorageQueryAPI m => ClearCronEvents -> m ()

-- | Delete async action logs
deleteActionData :: MonadMetadataStorageQueryAPI m => ActionName -> m ()

-- | Fetch cron/oneoff scheduled event invocations
fetchInvocations :: MonadMetadataStorageQueryAPI m => GetInvocationsBy -> ScheduledEventPagination -> m (WithTotalCount [ScheduledEventInvocation])

-- | Fetch cron/oneoff scheduled events
fetchScheduledEvents :: MonadMetadataStorageQueryAPI m => GetScheduledEvents -> m Value

-- | Drop a cron/oneoff scheduled event
dropEvent :: MonadMetadataStorageQueryAPI m => ScheduledEventId -> ScheduledEventType -> m ()

-- | Retrieve the state from metadata storage catalog
fetchCatalogState :: MonadMetadataStorageQueryAPI m => m CatalogState

-- | Update the state from metadata storage catalog
updateCatalogState :: MonadMetadataStorageQueryAPI m => CatalogStateType -> Value -> m ()
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.Metadata.Class.MetadataStorageT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.Metadata.Class.MetadataStorageT m)
instance Hasura.Server.Types.HasServerConfigCtx m => Hasura.Server.Types.HasServerConfigCtx (Hasura.Metadata.Class.MetadataStorageT m)
instance Network.HTTP.Client.Manager.HasHttpManagerM m => Network.HTTP.Client.Manager.HasHttpManagerM (Hasura.Metadata.Class.MetadataStorageT m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Hasura.Metadata.Class.MetadataStorageT m)
instance Hasura.Tracing.MonadTrace m => Hasura.Tracing.MonadTrace (Hasura.Metadata.Class.MetadataStorageT m)
instance Hasura.Tracing.HasReporter m => Hasura.Tracing.HasReporter (Hasura.Metadata.Class.MetadataStorageT m)
instance Control.Monad.Morph.MFunctor Hasura.Metadata.Class.MetadataStorageT
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Metadata.Class.MetadataStorageT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Hasura.Metadata.Class.MetadataStorageT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.Metadata.Class.MetadataStorageT
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.Metadata.Class.MetadataStorageT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.Metadata.Class.MetadataStorageT m)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr (Hasura.Metadata.Class.MetadataStorageT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.Metadata.Class.MetadataStorageT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.Metadata.Class.MetadataStorageT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.Metadata.Class.MetadataStorageT m)
instance Hasura.Metadata.Class.MonadMetadataStorageQueryAPI m => Hasura.Metadata.Class.MonadMetadataStorageQueryAPI (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Metadata.Class.MonadMetadataStorageQueryAPI m => Hasura.Metadata.Class.MonadMetadataStorageQueryAPI (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.Metadata.Class.MonadMetadataStorageQueryAPI m => Hasura.Metadata.Class.MonadMetadataStorageQueryAPI (Hasura.Tracing.TraceT m)
instance Hasura.Metadata.Class.MonadMetadataStorageQueryAPI m => Hasura.Metadata.Class.MonadMetadataStorageQueryAPI (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Metadata.Class.MonadMetadataStorageQueryAPI m => Hasura.Metadata.Class.MonadMetadataStorageQueryAPI (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance (GHC.Base.Monad m, GHC.Base.Monad (t m), Control.Monad.Trans.Class.MonadTrans t, Hasura.Metadata.Class.MonadMetadataStorage (Hasura.Metadata.Class.MetadataStorageT m)) => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.Metadata.Class.MetadataStorageT (t m))
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.Tracing.TraceT m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.Except.ExceptT Hasura.Base.Error.QErr m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)

module Hasura.Server.Limits

-- | Resource limits, represented by a function which modifies IO actions
--   to enforce those limits by throwing errors using <a>MonadError</a> in
--   the case where they are exceeded.
data ResourceLimits
ResourceLimits :: (forall m a. (MonadBaseControl IO m, MonadError QErr m) => m a -> m a) -> ResourceLimits
[runResourceLimits] :: ResourceLimits -> forall m a. (MonadBaseControl IO m, MonadError QErr m) => m a -> m a

-- | Monads which support resource (memory, CPU time, etc.) limiting
class Monad m => HasResourceLimits m
askHTTPHandlerLimit :: HasResourceLimits m => m ResourceLimits
askGraphqlOperationLimit :: HasResourceLimits m => RequestId -> m (UserInfo -> ApiLimit -> ResourceLimits)
askHTTPHandlerLimit :: (HasResourceLimits m, m ~ t n, MonadTrans t, HasResourceLimits n) => m ResourceLimits
askGraphqlOperationLimit :: (HasResourceLimits m, m ~ t n, MonadTrans t, HasResourceLimits n) => RequestId -> m (UserInfo -> ApiLimit -> ResourceLimits)
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Hasura.Tracing.TraceT m)
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Hasura.Metadata.Class.MetadataStorageT m)

module Hasura.RQL.Types.Run
data RunCtx
RunCtx :: UserInfo -> Manager -> ServerConfigCtx -> RunCtx
[_rcUserInfo] :: RunCtx -> UserInfo
[_rcHttpMgr] :: RunCtx -> Manager
[_rcServerConfigCtx] :: RunCtx -> ServerConfigCtx
newtype RunT m a
RunT :: ReaderT RunCtx (ExceptT QErr m) a -> RunT m a
[unRunT] :: RunT m a -> ReaderT RunCtx (ExceptT QErr m) a
peelRun :: RunCtx -> RunT m a -> ExceptT QErr m a
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.RQL.Types.Run.RunT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.RQL.Types.Run.RunT m)
instance Hasura.Tracing.MonadTrace m => Hasura.Tracing.MonadTrace (Hasura.RQL.Types.Run.RunT m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.RQL.Types.Run.RunT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.Types.Run.RunT m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Hasura.RQL.Types.Run.RunCtx (Hasura.RQL.Types.Run.RunT m)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr (Hasura.RQL.Types.Run.RunT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.Types.Run.RunT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.RQL.Types.Run.RunT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.Types.Run.RunT m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorageQueryAPI (Hasura.RQL.Types.Run.RunT m)
instance GHC.Base.Monad m => Hasura.Session.UserInfoM (Hasura.RQL.Types.Run.RunT m)
instance GHC.Base.Monad m => Network.HTTP.Client.Manager.HasHttpManagerM (Hasura.RQL.Types.Run.RunT m)
instance GHC.Base.Monad m => Hasura.Server.Types.HasServerConfigCtx (Hasura.RQL.Types.Run.RunT m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Hasura.RQL.Types.Run.RunT m)

module Hasura.RQL.DDL.Network
runAddHostToTLSAllowlist :: (QErrM m, CacheRWM m, MetadataM m) => TlsAllow -> m EncJSON
runDropHostFromTLSAllowlist :: (QErrM m, CacheRWM m, MetadataM m) => DropHostFromTLSAllowlist -> m EncJSON
addHostToTLSAllowList :: TlsAllow -> MetadataModifier
dropHostFromAllowList :: String -> MetadataModifier
checkForHostnameInAllowlistObject :: String -> TlsAllow -> Bool
checkForHostInTLSAllowlist :: String -> [TlsAllow] -> Bool

module Hasura.RQL.DDL.Endpoint
runCreateEndpoint :: (CacheRWM m, MetadataM m, MonadMetadataStorageQueryAPI m) => CreateEndpoint -> m EncJSON
runDropEndpoint :: (CacheRWM m, MetadataM m, MonadMetadataStorageQueryAPI m) => DropEndpoint -> m EncJSON
dropEndpointInMetadata :: EndpointName -> MetadataModifier
checkExists :: (MetadataM m, MonadError QErr m) => EndpointName -> m ()

module Hasura.RQL.DDL.Action
getActionInfo :: (QErrM m, CacheRM m) => ActionName -> m ActionInfo
data CreateAction
CreateAction :: ActionName -> ActionDefinitionInput -> Maybe Text -> CreateAction
[_caName] :: CreateAction -> ActionName
[_caDefinition] :: CreateAction -> ActionDefinitionInput
[_caComment] :: CreateAction -> Maybe Text
caName :: Lens' CreateAction ActionName
caDefinition :: Lens' CreateAction ActionDefinitionInput
caComment :: Lens' CreateAction (Maybe Text)
runCreateAction :: (QErrM m, CacheRWM m, MetadataM m) => CreateAction -> m EncJSON
resolveAction :: QErrM m => Environment -> AnnotatedCustomTypes -> ActionDefinitionInput -> BackendMap ScalarMap -> m (ResolvedActionDefinition, AnnotatedOutputType)
data UpdateAction
UpdateAction :: ActionName -> ActionDefinitionInput -> Maybe Text -> UpdateAction
[_uaName] :: UpdateAction -> ActionName
[_uaDefinition] :: UpdateAction -> ActionDefinitionInput
[_uaComment] :: UpdateAction -> Maybe Text
uaName :: Lens' UpdateAction ActionName
uaDefinition :: Lens' UpdateAction ActionDefinitionInput
uaComment :: Lens' UpdateAction (Maybe Text)
runUpdateAction :: forall m. (QErrM m, CacheRWM m, MetadataM m) => UpdateAction -> m EncJSON
newtype ClearActionData
ClearActionData :: Bool -> ClearActionData
[unClearActionData] :: ClearActionData -> Bool
shouldClearActionData :: ClearActionData -> Bool
defaultClearActionData :: ClearActionData
data DropAction
DropAction :: ActionName -> Maybe ClearActionData -> DropAction
[_daName] :: DropAction -> ActionName
[_daClearData] :: DropAction -> Maybe ClearActionData
runDropAction :: (CacheRWM m, MetadataM m, MonadMetadataStorageQueryAPI m) => DropAction -> m EncJSON
dropActionInMetadata :: ActionName -> MetadataModifier
newtype ActionMetadataField
ActionMetadataField :: Text -> ActionMetadataField
[unActionMetadataField] :: ActionMetadataField -> Text
doesActionPermissionExist :: Metadata -> ActionName -> RoleName -> Bool
data CreateActionPermission
CreateActionPermission :: ActionName -> RoleName -> Maybe Value -> Maybe Text -> CreateActionPermission
[_capAction] :: CreateActionPermission -> ActionName
[_capRole] :: CreateActionPermission -> RoleName
[_capDefinition] :: CreateActionPermission -> Maybe Value
[_capComment] :: CreateActionPermission -> Maybe Text
runCreateActionPermission :: (QErrM m, CacheRWM m, MetadataM m) => CreateActionPermission -> m EncJSON
data DropActionPermission
DropActionPermission :: ActionName -> RoleName -> DropActionPermission
[_dapAction] :: DropActionPermission -> ActionName
[_dapRole] :: DropActionPermission -> RoleName
runDropActionPermission :: (QErrM m, CacheRWM m, MetadataM m) => DropActionPermission -> m EncJSON
dropActionPermissionInMetadata :: ActionName -> RoleName -> MetadataModifier
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.DropActionPermission
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.DropActionPermission
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.DropActionPermission
instance GHC.Show.Show Hasura.RQL.DDL.Action.DropActionPermission
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.CreateActionPermission
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.ActionMetadataField
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.ActionMetadataField
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.ActionMetadataField
instance GHC.Show.Show Hasura.RQL.DDL.Action.ActionMetadataField
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.DropAction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.DropAction
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.ClearActionData
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.ClearActionData
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.ClearActionData
instance GHC.Show.Show Hasura.RQL.DDL.Action.ClearActionData
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.DropAction
instance GHC.Show.Show Hasura.RQL.DDL.Action.DropAction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.UpdateAction
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.CreateAction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.CreateAction


-- | This module holds functions and data types used for logging at the
--   GraphQL layer. In contrast with, logging at the HTTP server layer.
module Hasura.GraphQL.Logging

-- | A GraphQL query, optionally generated SQL, and the request id makes up
--   the | <a>QueryLog</a>
data QueryLog
QueryLog :: !GQLReqUnparsed -> !Maybe (RootFieldAlias, GeneratedQuery) -> !RequestId -> !QueryLogKind -> QueryLog
[_qlQuery] :: QueryLog -> !GQLReqUnparsed
[_qlGeneratedSql] :: QueryLog -> !Maybe (RootFieldAlias, GeneratedQuery)
[_qlRequestId] :: QueryLog -> !RequestId
[_qlKind] :: QueryLog -> !QueryLogKind
data QueryLogKind
QueryLogKindDatabase :: QueryLogKind
QueryLogKindAction :: QueryLogKind
QueryLogKindRemoteSchema :: QueryLogKind
QueryLogKindCached :: QueryLogKind
QueryLogKindIntrospection :: QueryLogKind
data GeneratedQuery
GeneratedQuery :: Text -> Value -> GeneratedQuery
[_gqQueryString] :: GeneratedQuery -> Text
[_gqPreparedArgs] :: GeneratedQuery -> Value
class Monad m => MonadQueryLog m
logQueryLog :: MonadQueryLog m => Logger Hasura -> QueryLog -> m ()
instance Hasura.GraphQL.Logging.MonadQueryLog m => Hasura.GraphQL.Logging.MonadQueryLog (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Logging.MonadQueryLog m => Hasura.GraphQL.Logging.MonadQueryLog (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.GraphQL.Logging.MonadQueryLog m => Hasura.GraphQL.Logging.MonadQueryLog (Hasura.Tracing.TraceT m)
instance Hasura.GraphQL.Logging.MonadQueryLog m => Hasura.GraphQL.Logging.MonadQueryLog (Hasura.Metadata.Class.MetadataStorageT m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Logging.QueryLog
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Logging.QueryLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Logging.GeneratedQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Logging.QueryLogKind

module Hasura.GraphQL.Schema.Common

-- | Aggregation of contextual information required to build the schema.
data SchemaContext
SchemaContext :: SchemaKind -> RemoteRelationshipParserBuilder -> RoleName -> SchemaContext

-- | the kind of schema being built
[scSchemaKind] :: SchemaContext -> SchemaKind

-- | how to process remote relationships
[scRemoteRelationshipParserBuilder] :: SchemaContext -> RemoteRelationshipParserBuilder

-- | the role for which the schema is being built
[scRole] :: SchemaContext -> RoleName

-- | The kind of schema we're building, and its associated options.
data SchemaKind
HasuraSchema :: SchemaKind
RelaySchema :: NodeInterfaceParserBuilder -> SchemaKind
isHasuraSchema :: SchemaKind -> Bool

-- | The set of common constraints required to build the schema.
type MonadBuildSchemaBase r m n = (MonadError QErr m, MonadReader r m, MonadMemoize m, MonadParse n, Has SchemaOptions r, Has SchemaContext r, Has MkTypename r, Has CustomizeRemoteFieldName r, Has NamingCase r)

-- | How a remote relationship field should be processed when building a
--   schema. Injecting this function from the top level avoids having to
--   know how to do top-level dispatch from deep within the schema code.
--   
--   Note: the inner function type uses an existential qualifier: it is
--   expected that the given function will work for _any_ monad <tt>m</tt>
--   that has the relevant constraints. This prevents us from passing a
--   function that is specfic to the monad in which the schema construction
--   will run, but avoids having to propagate type annotations to each call
--   site.
newtype RemoteRelationshipParserBuilder
RemoteRelationshipParserBuilder :: (forall lhsJoinField r n m. MonadBuildSchemaBase r m n => RemoteFieldInfo lhsJoinField -> m (Maybe [FieldParser n (RemoteRelationshipField UnpreparedValue)])) -> RemoteRelationshipParserBuilder

-- | A <a>RemoteRelationshipParserBuilder</a> that ignores the field
--   altogether, that can be used in tests or to build a source or remote
--   schema in isolation.
ignoreRemoteRelationship :: RemoteRelationshipParserBuilder

-- | How to build the <tt>Relay</tt> node.
--   
--   Similarly to what we do for remote relationships, we pass in the
--   context the builder function required to build the <tt>Node</tt>
--   interface, in order to avoid the cross-sources cycles it creates
--   otherwise.
newtype NodeInterfaceParserBuilder
NodeInterfaceParserBuilder :: (forall r n m. MonadBuildSchemaBase r m n => m (Parser 'Output n NodeMap)) -> NodeInterfaceParserBuilder
[runNodeBuilder] :: NodeInterfaceParserBuilder -> forall r n m. MonadBuildSchemaBase r m n => m (Parser 'Output n NodeMap)
retrieve :: (MonadReader r m, Has a r) => (a -> b) -> m b
type MonadBuildSourceSchema r m n = MonadBuildSchemaBase r m n
runSourceSchema :: SchemaContext -> SchemaOptions -> ReaderT (SchemaContext, SchemaOptions, MkTypename, CustomizeRemoteFieldName, NamingCase) m a -> m a
type MonadBuildRemoteSchema r m n = MonadBuildSchemaBase r m n
runRemoteSchema :: SchemaContext -> SchemaOptions -> ReaderT (SchemaContext, SchemaOptions, MkTypename, CustomizeRemoteFieldName, NamingCase) m a -> m a
type SelectExp b = AnnSimpleSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type StreamSelectExp b = AnnSimpleStreamSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type AggSelectExp b = AnnAggregateSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type ConnectionSelectExp b = ConnectionSelect b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type SelectArgs b = SelectArgsG b (UnpreparedValue b)
type SelectStreamArgs b = SelectStreamArgsG b (UnpreparedValue b)
type TablePerms b = TablePermG b (UnpreparedValue b)
type AnnotatedFields b = AnnFieldsG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type AnnotatedField b = AnnFieldG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type ConnectionFields b = ConnectionFields b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type EdgeFields b = EdgeFields b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type AnnotatedActionFields = ActionFieldsG (RemoteRelationshipField UnpreparedValue)
type AnnotatedActionField = ActionFieldG (RemoteRelationshipField UnpreparedValue)
data RemoteSchemaParser n
RemoteSchemaParser :: [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> RemoteSchemaParser n
[piQuery] :: RemoteSchemaParser n -> [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))]
[piMutation] :: RemoteSchemaParser n -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))]
[piSubscription] :: RemoteSchemaParser n -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))]
getTableRoles :: BackendSourceInfo -> [RoleName]

-- | Looks up table information for the given table name. This function
--   should never fail, since the schema cache construction process is
--   supposed to ensure all dependencies are resolved. TODO: deduplicate
--   this with <a>CacheRM</a>.
askTableInfo :: forall b m. (Backend b, MonadError QErr m) => SourceInfo b -> TableName b -> m (TableInfo b)

-- | Whether the request is sent with
--   `x-hasura-use-backend-only-permissions` set to <tt>true</tt>.
data Scenario
Backend :: Scenario
Frontend :: Scenario
textToName :: MonadError QErr m => Text -> m Name
partialSQLExpToUnpreparedValue :: PartialSQLExp b -> UnpreparedValue b
mapField :: Functor m => InputFieldsParser m (Maybe a) -> (a -> b) -> InputFieldsParser m (Maybe b)
parsedSelectionsToFields :: (Text -> a) -> InsOrdHashMap Name (ParsedSelection a) -> Fields a
numericAggOperators :: [Name]
comparisonAggOperators :: [Name]
mkDescriptionWith :: Maybe PGDescription -> Text -> Description
takeValidTables :: forall b. Backend b => TableCache b -> TableCache b
takeValidFunctions :: forall b. FunctionCache b -> FunctionCache b
requiredFieldParser :: (Functor n, Functor m) => (a -> b) -> m (FieldParser n a) -> m (Maybe (FieldParser n b))
optionalFieldParser :: (Functor n, Functor m) => (a -> b) -> m (Maybe (FieldParser n a)) -> m (Maybe (FieldParser n b))

-- | Builds the type name for referenced enum tables.
mkEnumTypeName :: forall b m r. (Backend b, MonadReader r m, Has MkTypename r, MonadError QErr m, Has NamingCase r) => EnumReference b -> m Name
addEnumSuffix :: (MonadReader r m, Has MkTypename r) => GQLNameIdentifier -> Maybe Name -> NamingCase -> m Name
peelWithOrigin :: MonadParse m => Parser 'Both m a -> Parser 'Both m (ValueWithOrigin a)
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Common.Scenario
instance GHC.Show.Show Hasura.GraphQL.Schema.Common.Scenario
instance GHC.Enum.Enum Hasura.GraphQL.Schema.Common.Scenario

module Hasura.GraphQL.Schema.Remote
buildRemoteParser :: forall r m n. MonadBuildRemoteSchema r m n => IntrospectionResult -> RemoteSchemaRelationships -> RemoteSchemaInfo -> m (RemoteSchemaParser n)
makeResultCustomizer :: RemoteSchemaCustomizer -> GraphQLField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable -> ResultCustomizer
buildRawRemoteParser :: forall r m n. MonadBuildRemoteSchema r m n => IntrospectionResult -> RemoteSchemaRelationships -> RemoteSchemaInfo -> m ([FieldParser n (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable)], Maybe [FieldParser n (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable)], Maybe [FieldParser n (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable)])

-- | Helper, used to track whether an input value was altered during its
--   parsing. There are two possible sources of alteration: - preset
--   values, and - type name customizations. They might force evaluation of
--   variables, and encapsulation of sub-JSON expressions as new variables.
--   Each parser indicates whether such alteration took place within its
--   part of the tree. See Note [Variable expansion in remote schema input
--   parsers] for more information.
newtype Altered
Altered :: Bool -> Altered
[getAltered] :: Altered -> Bool

-- | <a>inputValueDefinitionParser</a> accepts a
--   <a>InputValueDefinition</a> and will return an
--   <a>InputFieldsParser</a> for it. If a non <a>Input</a> GraphQL type is
--   found in the 'type' of the <tt>InputValueDefinition</tt> then an error
--   will be thrown.
--   
--   Each parser also returns a boolean that indicates whether the parsed
--   value was altered by presets. Presets might force the evaluation of
--   variables that would otherwise be transmitted unmodified.
inputValueDefinitionParser :: forall r m n. MonadBuildRemoteSchema r m n => RemoteSchemaIntrospection -> InputValueDefinition -> m (InputFieldsParser n (Maybe (Altered, Value RemoteSchemaVariable)))

-- | remoteFieldScalarParser attempts to parse a scalar value for a given
--   remote field
--   
--   We do not attempt to verify that the literal is correct! Some GraphQL
--   implementations, including ours, are a bit flexible with the
--   intepretations of literals; for instance, there are several places in
--   our schema where we declare something to be an <a>Int</a>, but
--   actually accept <a>String</a> literals. We do however peform variable
--   type-checking.
--   
--   If we encounter a JSON value, it means that we were introspecting a
--   query variable. To call the remote schema, we need a graphql value; we
--   therefore need to treat that JSON expression as if it were a query
--   variable of its own. To avoid ending up with one such variable per
--   scalar in the query, we also track alterations, to apply
--   optimizations. See Note [Variable expansion in remote schema input
--   parsers] for more information.
--   
--   If the value contains a variable with a customized type name then we
--   need to consider it to be altered to ensure that the original type
--   name is passed to the remote server.
remoteFieldScalarParser :: MonadParse n => MkTypename -> ScalarTypeDefinition -> Parser 'Both n (Altered, Value RemoteSchemaVariable)
remoteFieldEnumParser :: MonadParse n => MkTypename -> EnumTypeDefinition -> Parser 'Both n (Altered, Value RemoteSchemaVariable)

-- | remoteInputObjectParser returns an input parser for a given
--   <a>InputObjectTypeDefinition</a>
--   
--   Now, this is tricky! We are faced with two contradicting constraints
--   here. On one hand, the GraphQL spec forbids us from creating empty
--   input objects. This means that if all the arguments have presets, we
--   CANNOT use the parser this function creates, and the caller cannot
--   create a field for this object (and instead should use <tt>pure</tt>
--   to include the preset values in the result of parsing the fields).
--   
--   One way we could fix this would be to change the type of this function
--   to return a `Maybe Parser`, inspect the result of
--   <a>argumentsParser</a>, and return <tt>Nothing</tt> when we realize
--   that there aren't any actual field in it (or at least return a value
--   that propagates the preset values). But this would contradict our
--   second constraint: this function needs to be memoized!
--   
--   At time of writing, we can't memoize functions that return arbitrary
--   functors of Parsers; so no memoizing Maybe Parser or Either Presets
--   Parser. Which means that we would need to first call
--   <a>argumentsParser</a>, then memoize the <a>Just</a> branch that
--   builds the actual Parser. The problem is that the recursive call ro
--   remoteSchemaInputObject is within <a>argumentsParser</a>, meaning the
--   call to it MUST be in the memoized branch!
--   
--   This is why, in the end, we do the following: we first test whether
--   there is any non-preset field: if yes, we memoize that branch and
--   proceed as normal. Otherwise we can omit the memoization: we know for
--   sure that the preset fields won't generate a recursive call!
remoteInputObjectParser :: forall r m n. MonadBuildRemoteSchema r m n => RemoteSchemaIntrospection -> InputObjectTypeDefinition RemoteSchemaInputValueDefinition -> m (Either (InputFieldsParser n (Altered, Value RemoteSchemaVariable)) (Parser 'Input n (Altered, Value RemoteSchemaVariable)))

-- | Variable expansion optimization. Since each parser returns a value
--   that indicates whether it was altered, we can detect when no
--   alteration took place, and replace the parsed and expanded value by
--   its original. See Note [Variable expansion in remote schema input
--   parsers] for more information.
shortCircuitIfUnaltered :: forall k n. ('Input <: k, MonadParse n) => Parser k n (Maybe (Altered, Value RemoteSchemaVariable)) -> Parser k n (Maybe (Altered, Value RemoteSchemaVariable))

-- | argumentsParser is used for creating an argument parser for remote
--   fields, This function is called for field arguments and input object
--   fields. This function works in the following way:
--   
--   <ul>
--   <li>if a field is not preset, we recursively call
--   <a>inputValueDefinitionParser</a> on it</li>
--   <li>otherwise, we use the preset</li>
--   </ul>
--   
--   For example, consider the following input objects:
--   
--   input MessageWhereInpObj { id: IntCompareObj name: StringCompareObj }
--   
--   input IntCompareObj { eq : Int @preset(value: 2) gt : Int lt : Int }
--   
--   parsing a MessageWhereInpObj will result in the following call tree:
--   
--   <ul>
--   <li>&gt; argumentsParser MessageWhereInpObj</li>
--   <li>&gt; id =&gt; inputValueDefinitionParser IntCompareObj</li>
--   <li>&gt; remoteInputObjectParser IntCompareObj</li>
--   <li>&gt; argumentsParser IntCompareObj</li>
--   <li>&gt; eq =&gt; using preset, no recursion</li>
--   <li>&gt; gt =&gt; inputValueDefinitionParser Int</li>
--   <li>&gt; remoteFieldScalarParser Int</li>
--   <li>&gt; lt =&gt; inputValueDefinitionParser Int</li>
--   <li>&gt; remoteFieldScalarParser Int</li>
--   <li>&gt; name =&gt; inputValueDefinitionParser StringCompareObj</li>
--   <li>&gt; ...</li>
--   </ul>
--   
--   Furthermore, like all other input parsers in this file,
--   <a>argumentsParser</a> indicates whether this part of the tree was
--   altered during parsing; if any of the fields is preset, or recursively
--   contains values that contain presets further down, then this result is
--   labelled as altered.
argumentsParser :: forall r m n. MonadBuildRemoteSchema r m n => ArgumentsDefinition RemoteSchemaInputValueDefinition -> RemoteSchemaIntrospection -> m (InputFieldsParser n (Altered, HashMap Name (Value RemoteSchemaVariable)))
aggregateListAndAlteration :: [Maybe (Altered, a)] -> (Altered, [a])
remoteSchemaRelationships :: forall r n m. MonadBuildRemoteSchema r m n => RemoteSchemaRelationships -> Name -> m [FieldParser n (SchemaRemoteRelationshipSelect (RemoteRelationshipField UnpreparedValue))]

-- | <a>remoteSchemaObject</a> returns a output parser for a given
--   <tt>ObjectTypeDefinition</tt>.
remoteSchemaObject :: forall r m n. MonadBuildRemoteSchema r m n => RemoteSchemaIntrospection -> RemoteSchemaRelationships -> ObjectTypeDefinition RemoteSchemaInputValueDefinition -> m (Parser 'Output n (ObjectSelectionSet (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))

-- | <a>remoteSchemaInterface</a> returns a output parser for a given
--   <tt>InterfaceTypeDefinition</tt>. Also check Note [Querying remote
--   schema interfaces]
remoteSchemaInterface :: forall r m n. MonadBuildRemoteSchema r m n => RemoteSchemaIntrospection -> RemoteSchemaRelationships -> InterfaceTypeDefinition [Name] RemoteSchemaInputValueDefinition -> m (Parser 'Output n (DeduplicatedSelectionSet (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))

-- | <a>remoteSchemaUnion</a> returns a output parser for a given
--   <tt>UnionTypeDefinition</tt>.
remoteSchemaUnion :: forall r m n. MonadBuildRemoteSchema r m n => RemoteSchemaIntrospection -> RemoteSchemaRelationships -> UnionTypeDefinition -> m (Parser 'Output n (DeduplicatedSelectionSet (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))
remoteFieldFromDefinition :: forall r m n. MonadBuildRemoteSchema r m n => RemoteSchemaIntrospection -> Name -> RemoteSchemaRelationships -> FieldDefinition RemoteSchemaInputValueDefinition -> m (FieldParser n (GraphQLField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))

-- | <a>remoteFieldFromName</a> accepts a GraphQL name and searches for its
--   definition in the <a>RemoteSchemaIntrospection</a>.
remoteFieldFromName :: forall r m n. MonadBuildRemoteSchema r m n => RemoteSchemaIntrospection -> RemoteSchemaRelationships -> Name -> Name -> Maybe Description -> Name -> ArgumentsDefinition RemoteSchemaInputValueDefinition -> m (FieldParser n (GraphQLField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))

-- | <a>remoteField</a> accepts a <a>TypeDefinition</a> and will returns a
--   <a>FieldParser</a> for it. Note that the <a>TypeDefinition</a> should
--   be of the GraphQL <a>Output</a> kind, when an GraphQL <a>Input</a>
--   kind is provided, then error will be thrown.
remoteField :: forall r m n. MonadBuildRemoteSchema r m n => RemoteSchemaIntrospection -> RemoteSchemaRelationships -> Name -> Name -> Maybe Description -> ArgumentsDefinition RemoteSchemaInputValueDefinition -> TypeDefinition [Name] RemoteSchemaInputValueDefinition -> m (FieldParser n (GraphQLField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))

-- | helper function to get a parser of an object with it's name This
--   function is called from <a>remoteSchemaInterface</a> and
--   <a>remoteSchemaObject</a> functions. Both of these have a slightly
--   different implementation of <tt>getObject</tt>, which is the reason
--   <tt>getObject</tt> is an argument to this function
getObjectParser :: forall r m n. MonadBuildRemoteSchema r m n => RemoteSchemaIntrospection -> RemoteSchemaRelationships -> (Name -> m (ObjectTypeDefinition RemoteSchemaInputValueDefinition)) -> Name -> m (Parser 'Output n (Name, ObjectSelectionSet (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))
customizeRemoteNamespace :: forall n. MonadParse n => RemoteSchemaInfo -> Name -> [FieldParser n (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable)] -> [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))]
withRemoteSchemaCustomization :: forall m r a. (MonadReader r m, Has MkTypename r, Has CustomizeRemoteFieldName r) => RemoteSchemaCustomizer -> m a -> m a
instance GHC.Base.Monoid Hasura.GraphQL.Schema.Remote.Altered
instance GHC.Base.Semigroup Hasura.GraphQL.Schema.Remote.Altered
instance GHC.Show.Show Hasura.GraphQL.Schema.Remote.Altered

module Hasura.GraphQL.RemoteServer

-- | Make an introspection query to the remote graphql server for the data
--   we need to present and stitch the remote schema. This powers
--   add_remote_schema, and also is called by schema cache rebuilding code
--   in <a>Hasura.RQL.DDL.Schema.Cache</a>.
fetchRemoteSchema :: forall m. (MonadIO m, MonadError QErr m, MonadTrace m) => Environment -> Manager -> RemoteSchemaName -> ValidatedRemoteSchemaDef -> m RemoteSchemaCtx

-- | Sends a GraphQL query to the given server.
execRemoteGQ :: (MonadIO m, MonadError QErr m, MonadTrace m) => Environment -> Manager -> UserInfo -> [Header] -> ValidatedRemoteSchemaDef -> GQLReqOutgoing -> m (DiffTime, [Header], ByteString)
validateSchemaCustomizations :: forall m. MonadError QErr m => RemoteSchemaCustomizer -> RemoteSchemaIntrospection -> m ()
validateSchemaCustomizationsConsistent :: forall m. MonadError QErr m => RemoteSchemaCustomizer -> RemoteSchemaIntrospection -> m ()
validateSchemaCustomizationsDistinct :: forall m. MonadError QErr m => RemoteSchemaCustomizer -> RemoteSchemaIntrospection -> m ()
introspectionQuery :: GQLReqOutgoing

-- | Parsing the introspection query result. We use this newtype wrapper to
--   avoid orphan instances and parse JSON in the way that we need for
--   GraphQL introspection results.
newtype FromIntrospection a
FromIntrospection :: a -> FromIntrospection a
[fromIntrospection] :: FromIntrospection a -> a
getCustomizer :: IntrospectionResult -> Maybe RemoteSchemaCustomization -> RemoteSchemaCustomizer
pErr :: MonadFail m => Text -> m a
kindErr :: MonadFail m => Text -> Text -> m a
throwRemoteSchema :: QErrM m => Text -> m a
throwRemoteSchemaHttp :: QErrM m => EnvRecord URI -> HttpException -> m a
instance GHC.Base.Functor Hasura.GraphQL.RemoteServer.FromIntrospection
instance GHC.Generics.Generic (Hasura.GraphQL.RemoteServer.FromIntrospection a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.RemoteServer.FromIntrospection a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.RemoteServer.FromIntrospection a)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.Description)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.ScalarTypeDefinition)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.ObjectTypeDefinition Language.GraphQL.Draft.Syntax.InputValueDefinition))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.FieldDefinition a))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.GType)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.InputValueDefinition)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.Value Data.Void.Void))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.InterfaceTypeDefinition [Language.GraphQL.Draft.Syntax.Name] Language.GraphQL.Draft.Syntax.InputValueDefinition))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.UnionTypeDefinition)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.EnumTypeDefinition)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.EnumValueDefinition)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.InputObjectTypeDefinition Language.GraphQL.Draft.Syntax.InputValueDefinition))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.TypeDefinition [Language.GraphQL.Draft.Syntax.Name] Language.GraphQL.Draft.Syntax.InputValueDefinition))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Hasura.RQL.Types.SchemaCache.IntrospectionResult)


-- | <h1>Scheduled Triggers</h1>
--   
--   This module implements the functionality of invoking webhooks during
--   specified time events aka scheduled events. The scheduled events are
--   the events generated by the graphql-engine using the cron triggers
--   or/and a scheduled event can be created by the user at a specified
--   time with the payload, webhook, headers and the retry configuration.
--   Scheduled events are modeled using rows in Postgres with a
--   <tt>timestamp</tt> column.
--   
--   This module implements scheduling and delivery of scheduled events:
--   
--   <ol>
--   <li>Scheduling a cron event involves creating new cron events. New
--   cron events are created based on the cron schedule and the number of
--   scheduled events that are already present in the scheduled events
--   buffer. The graphql-engine computes the new scheduled events and
--   writes them to the database.(Generator)</li>
--   <li>Delivering a scheduled event involves reading undelivered
--   scheduled events from the database and delivering them to the webhook
--   server. (Processor)</li>
--   </ol>
--   
--   The rationale behind separating the event scheduling and event
--   delivery mechanism into two different threads is that the scheduling
--   and delivering of the scheduled events are not directly dependent on
--   each other. The generator will almost always try to create scheduled
--   events which are supposed to be delivered in the future (timestamp
--   &gt; current_timestamp) and the processor will fetch scheduled events
--   of the past (timestamp &lt; current_timestamp). So, the set of the
--   scheduled events generated by the generator and the processor will
--   never be the same. The point here is that they're not correlated to
--   each other. They can be split into different threads for a better
--   performance.
--   
--   <h2>Implementation</h2>
--   
--   The scheduled triggers eventing is being implemented in the metadata
--   storage. All functions that make interaction to storage system are
--   abstracted in the @<a>MonadMetadataStorage</a> class.
--   
--   During the startup, two threads are started:
--   
--   <ol>
--   <li>Generator: Fetches the list of scheduled triggers from cache and
--   generates the scheduled events.<ul><li>Additional events will be
--   generated only if there are fewer than 100 scheduled
--   events.</li><li>The upcoming events timestamp will be generated
--   using:<ul><li>cron schedule of the scheduled trigger</li><li>max
--   timestamp of the scheduled events that already exist or
--   current_timestamp(when no scheduled events exist)</li><li>The
--   timestamp of the scheduled events is stored with timezone because
--   `SELECT NOW()` returns timestamp with timezone, so it's good to
--   compare two things of the same type.</li></ul></li></ul>This
--   effectively corresponds to doing an INSERT with values containing
--   specific timestamp.</li>
--   <li>Processor: Fetches the undelivered cron events and the scheduled
--   events from the database and which have timestamp lesser than the
--   current timestamp and then process them.</li>
--   </ol>
--   
--   TODO - Consider and document ordering guarantees - do we have any in
--   the presence of multiple hasura instances? - If we have nothing useful
--   to say about ordering, then consider processing events asynchronously,
--   so that a slow webhook doesn't cause everything subsequent to be
--   delayed
module Hasura.Eventing.ScheduledTrigger

-- | runCronEventsGenerator makes sure that all the cron triggers have an
--   adequate buffer of cron events.
runCronEventsGenerator :: (MonadIO m, MonadMetadataStorage (MetadataStorageT m)) => Logger Hasura -> IO SchemaCache -> m void
insertCronEventsFor :: MonadMetadataStorage m => [(CronTriggerInfo, CronTriggerStats)] -> m ()
generateCronEventsFrom :: UTCTime -> CronTriggerInfo -> [CronEventSeed]

-- | Generates next <tt>n events starting </tt>from according to
--   <a>CronSchedule</a>
generateScheduleTimes :: UTCTime -> Int -> CronSchedule -> [UTCTime]
processCronEvents :: (MonadIO m, HasReporter m, MonadMetadataStorage (MetadataStorageT m)) => Logger Hasura -> Manager -> [CronEvent] -> IO SchemaCache -> TVar (Set CronEventId) -> m ()
processOneOffScheduledEvents :: (MonadIO m, HasReporter m, MonadMetadataStorage (MetadataStorageT m)) => Environment -> Logger Hasura -> Manager -> [OneOffScheduledEvent] -> TVar (Set OneOffScheduledEventId) -> m ()
processScheduledTriggers :: (MonadIO m, HasReporter m, MonadMetadataStorage (MetadataStorageT m)) => Environment -> Logger Hasura -> Manager -> IO SchemaCache -> LockedEventsCtx -> m (Forever m)
processScheduledEvent :: (MonadReader r m, Has Manager r, Has (Logger Hasura) r, MonadIO m, HasReporter m, MonadMetadataStorage m) => ScheduledEventId -> [EventHeaderInfo] -> RetryContext -> ScheduledEventWebhookPayload -> EnvRecord ResolvedWebhook -> ScheduledEventType -> m ()
processError :: (MonadIO m, MonadMetadataStorage m) => ScheduledEventId -> RetryContext -> [HeaderConf] -> ScheduledEventType -> Value -> HTTPErr a -> m ()
retryOrMarkError :: (MonadIO m, MonadMetadataStorage m) => ScheduledEventId -> RetryContext -> HTTPErr a -> ScheduledEventType -> m ()
processSuccess :: MonadMetadataStorage m => ScheduledEventId -> [HeaderConf] -> ScheduledEventType -> Value -> HTTPResp a -> m ()
processDead :: MonadMetadataStorage m => ScheduledEventId -> ScheduledEventType -> m ()
mkInvocation :: ScheduledEventId -> Maybe Int -> [HeaderConf] -> SerializableBlob -> [HeaderConf] -> Value -> Invocation 'ScheduledType

-- | Get cron trigger stats for cron jobs with fewer than 100 future
--   reified events in the database
--   
--   The point here is to maintain a certain number of future events so the
--   user can kind of see what's coming up, and obviously to give
--   <a>processCronEvents</a> something to do.
getDeprivedCronTriggerStatsTx :: [TriggerName] -> TxE QErr [CronTriggerStats]
getScheduledEventsForDeliveryTx :: TxE QErr ([CronEvent], [OneOffScheduledEvent])
insertInvocationTx :: Invocation 'ScheduledType -> ScheduledEventType -> TxE QErr ()
setScheduledEventOpTx :: ScheduledEventId -> ScheduledEventOp -> ScheduledEventType -> TxE QErr ()
unlockScheduledEventsTx :: ScheduledEventType -> [ScheduledEventId] -> TxE QErr Int
unlockAllLockedScheduledEventsTx :: TxE QErr ()
insertCronEventsTx :: [CronEventSeed] -> TxE QErr ()
insertOneOffScheduledEventTx :: OneOffEvent -> TxE QErr EventId
dropFutureCronEventsTx :: ClearCronEvents -> TxE QErr ()
cronEventsTable :: QualifiedTable
mkScheduledEventStatusFilter :: [ScheduledEventStatus] -> BoolExp
scheduledTimeOrderBy :: OrderByExp

-- | Build a select expression which outputs total count and list of json
--   rows with pagination limit and offset applied
mkPaginationSelectExp :: Select -> ScheduledEventPagination -> Select
withCount :: (Int, AltJ a) -> WithTotalCount a
getOneOffScheduledEventsTx :: ScheduledEventPagination -> [ScheduledEventStatus] -> TxE QErr (WithTotalCount [OneOffScheduledEvent])
getCronEventsTx :: TriggerName -> ScheduledEventPagination -> [ScheduledEventStatus] -> TxE QErr (WithTotalCount [CronEvent])
deleteScheduledEventTx :: ScheduledEventId -> ScheduledEventType -> TxE QErr ()
invocationFieldExtractors :: QualifiedTable -> [Extractor]
mkEventIdBoolExp :: QualifiedTable -> EventId -> BoolExp
getInvocationsTx :: GetInvocationsBy -> ScheduledEventPagination -> TxE QErr (WithTotalCount [ScheduledEventInvocation])
data EventTables
EventTables :: QualifiedTable -> QualifiedTable -> QualifiedTable -> EventTables
[etOneOffInvocationsTable] :: EventTables -> QualifiedTable
[etCronInvocationsTable] :: EventTables -> QualifiedTable
[etCronEventsTable] :: EventTables -> QualifiedTable
getInvocationsQueryNoPagination :: EventTables -> GetInvocationsBy -> Select
getInvocationsQuery :: EventTables -> GetInvocationsBy -> ScheduledEventPagination -> Select

module Hasura.RQL.DDL.ScheduledTrigger
populateInitialCronTriggerEvents :: (MonadIO m, MonadMetadataStorageQueryAPI m) => CronSchedule -> TriggerName -> m ()

-- | runCreateCronTrigger will update a existing cron trigger when the
--   <tt>replace</tt> value is set to <tt>true</tt> and when replace is
--   <tt>false</tt> a new cron trigger will be created
runCreateCronTrigger :: (CacheRWM m, MonadIO m, MetadataM m, MonadMetadataStorageQueryAPI m) => CreateCronTrigger -> m EncJSON
resolveCronTrigger :: QErrM m => Environment -> CronTriggerMetadata -> m CronTriggerInfo
updateCronTrigger :: (CacheRWM m, MonadIO m, MetadataM m, MonadMetadataStorageQueryAPI m) => CronTriggerMetadata -> m EncJSON
runDeleteCronTrigger :: (CacheRWM m, MetadataM m, MonadMetadataStorageQueryAPI m) => ScheduledTriggerName -> m EncJSON
dropCronTriggerInMetadata :: TriggerName -> MetadataModifier
runCreateScheduledEvent :: MonadMetadataStorageQueryAPI m => CreateScheduledEvent -> m EncJSON
checkExists :: (CacheRM m, MonadError QErr m) => TriggerName -> m ()
runDeleteScheduledEvent :: MonadMetadataStorageQueryAPI m => DeleteScheduledEvent -> m EncJSON
runGetScheduledEvents :: (CacheRM m, MonadMetadataStorageQueryAPI m) => GetScheduledEvents -> m EncJSON
runGetEventInvocations :: (CacheRM m, MonadMetadataStorageQueryAPI m) => GetEventInvocations -> m EncJSON

-- | Metadata API handler to retrieve all the cron triggers from the
--   metadata
runGetCronTriggers :: MetadataM m => m EncJSON


-- | <h1>Event Triggers</h1>
--   
--   Event triggers are like ordinary SQL triggers, except instead of
--   calling a SQL procedure, they call a webhook. The event delivery
--   mechanism involves coordination between both the database and
--   graphql-engine: only the SQL database knows when the events should
--   fire, but only graphql-engine know how to actually deliver them.
--   
--   Therefore, event triggers are implemented in two parts:
--   
--   <ol>
--   <li>Every event trigger is backed by a bona fide SQL trigger. When the
--   SQL trigger fires, it creates a new record in the
--   hdb_catalog.event_log table.</li>
--   <li>Concurrently, a thread in graphql-engine monitors the
--   hdb_catalog.event_log table for new events. When new event(s) are
--   found, it uses the information (URL,payload and headers) stored in the
--   event to deliver the event to the webhook.</li>
--   </ol>
--   
--   The creation and deletion of SQL trigger itself is managed by the
--   metadata DDL APIs (see Hasura.RQL.DDL.EventTrigger), so this module
--   focuses on event delivery.
--   
--   Most of the subtleties involve guaranteeing reliable delivery of
--   events: we guarantee that every event will be delivered at least once,
--   even if graphql-engine crashes. This means we have to record the state
--   of each event in the database, and we have to retry failed requests at
--   a regular (user-configurable) interval.
module Hasura.Eventing.EventTrigger
newtype EventInternalErr
EventInternalErr :: QErr -> EventInternalErr

-- | See Note [Maintenance Mode]
data EventEngineCtx
EventEngineCtx :: TVar Int -> DiffTime -> NonNegativeInt -> EventEngineCtx
[_eeCtxEventThreadsCapacity] :: EventEngineCtx -> TVar Int
[_eeCtxFetchInterval] :: EventEngineCtx -> DiffTime
[_eeCtxFetchSize] :: EventEngineCtx -> NonNegativeInt
data DeliveryInfo
DeliveryInfo :: Int -> Int -> DeliveryInfo
[diCurrentRetry] :: DeliveryInfo -> Int
[diMaxRetries] :: DeliveryInfo -> Int
newtype QualifiedTableStrict
QualifiedTableStrict :: QualifiedTable -> QualifiedTableStrict
[getQualifiedTable] :: QualifiedTableStrict -> QualifiedTable
data EventPayload (b :: BackendType)
EventPayload :: EventId -> TableName b -> TriggerMetadata -> Value -> DeliveryInfo -> UTCTime -> EventPayload (b :: BackendType)
[epId] :: EventPayload (b :: BackendType) -> EventId
[epTable] :: EventPayload (b :: BackendType) -> TableName b
[epTrigger] :: EventPayload (b :: BackendType) -> TriggerMetadata
[epEvent] :: EventPayload (b :: BackendType) -> Value
[epDeliveryInfo] :: EventPayload (b :: BackendType) -> DeliveryInfo
[epCreatedAt] :: EventPayload (b :: BackendType) -> UTCTime
defaultMaxEventThreads :: PositiveInt
defaultFetchInterval :: DiffTime
initEventEngineCtx :: Int -> DiffTime -> NonNegativeInt -> STM EventEngineCtx
saveLockedEventTriggerEvents :: MonadIO m => SourceName -> [EventId] -> TVar (HashMap SourceName (Set EventId)) -> m ()
removeEventTriggerEventFromLockedEvents :: MonadIO m => SourceName -> EventId -> TVar (HashMap SourceName (Set EventId)) -> m ()
type BackendEventWithSource = AnyBackend EventWithSource
type FetchEventArguments = ([BackendEventWithSource], Int, Bool)

-- | Service events from our in-DB queue.
--   
--   There are a few competing concerns and constraints here; we want to...
--   - fetch events in batches for lower DB pressure - don't fetch more
--   than N at a time (since that can mean: space leak, less effective
--   scale out, possible double sends for events we've checked out on exit
--   (TODO clean shutdown procedure)) - try not to cause webhook workers to
--   stall waiting on DB fetch - limit webhook HTTP concurrency per
--   HASURA_GRAPHQL_EVENTS_HTTP_POOL_SIZE
processEventQueue :: forall m. (MonadIO m, HasReporter m, MonadBaseControl IO m, Forall (Pure m), MonadMask m) => Logger Hasura -> Manager -> IO SchemaCache -> EventEngineCtx -> LockedEventsCtx -> ServerMetrics -> EventTriggerMetrics -> MaintenanceMode () -> m (Forever m)
createEventPayload :: RetryConf -> Event b -> EventPayload b
processSuccess :: forall b m a. (MonadIO m, BackendEventTrigger b) => SourceConfig b -> Event b -> [HeaderConf] -> Value -> MaintenanceMode MaintenanceModeVersion -> HTTPResp a -> m (Either QErr ())
processError :: forall b m a. (MonadIO m, BackendEventTrigger b) => SourceConfig b -> Event b -> RetryConf -> [HeaderConf] -> Value -> MaintenanceMode MaintenanceModeVersion -> HTTPErr a -> m (Either QErr ())
retryOrSetError :: MonadIO m => Event b -> RetryConf -> HTTPErr a -> m ProcessEventError
mkInvocation :: EventId -> Value -> Maybe Int -> [HeaderConf] -> SerializableBlob -> [HeaderConf] -> Invocation 'EventType
logQErr :: (MonadReader r m, Has (Logger Hasura) r, MonadIO m) => QErr -> m ()
getEventTriggerInfoFromEvent :: forall b. Backend b => SchemaCache -> Event b -> Either Text (EventTriggerInfo b)
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.QualifiedTableStrict
instance GHC.Show.Show Hasura.Eventing.EventTrigger.QualifiedTableStrict
instance GHC.Generics.Generic (Hasura.Eventing.EventTrigger.EventPayload b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Eventing.EventTrigger.EventPayload b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Eventing.EventTrigger.EventPayload b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.EventTrigger.EventPayload b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.QualifiedTableStrict
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.DeliveryInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Eventing.EventTrigger.DeliveryInfo
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.EventInternalErr
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.DeliveryInfo
instance GHC.Show.Show Hasura.Eventing.EventTrigger.DeliveryInfo
instance Hasura.Logging.ToEngineLog Hasura.Eventing.EventTrigger.EventInternalErr Hasura.Logging.Hasura


-- | Postgres Translate BoolExp
--   
--   Convert IR boolean expressions to Postgres-specific SQL expressions.
module Hasura.Backends.Postgres.Translate.BoolExp
equalsBoolExpBuilder :: SQLExpression ('Postgres pgKind) -> SQLExpression ('Postgres pgKind) -> BoolExp
notEqualsBoolExpBuilder :: SQLExpression ('Postgres pgKind) -> SQLExpression ('Postgres pgKind) -> BoolExp
annBoolExp :: (QErrM m, TableCoreInfoRM b m, BackendMetadata b) => BoolExpRHSParser b m v -> TableName b -> FieldInfoMap (FieldInfo b) -> GBoolExp b ColExp -> m (AnnBoolExp b v)
annColExp :: (QErrM m, TableCoreInfoRM b m, BackendMetadata b) => BoolExpRHSParser b m v -> TableName b -> FieldInfoMap (FieldInfo b) -> ColExp -> m (AnnBoolExpFld b v)

-- | Translate an IR boolean expression to an SQL boolean expression.
--   References to columns etc are relative to the given
--   <a>rootReference</a>.
toSQLBoolExp :: forall pgKind. Backend ('Postgres pgKind) => Qual -> AnnBoolExpSQL ('Postgres pgKind) -> BoolExp

-- | The table context of boolean expression translation. This is used to
--   resolve references to fields, as those may refer to the so-called
--   'root table' (identified by a <a>$</a>-sign in the expression input
--   syntax) or the <tt>current</tt> table.
data BoolExpCtx
BoolExpCtx :: Qual -> Qual -> BoolExpCtx

-- | Reference to the current tabular value.
[currTableReference] :: BoolExpCtx -> Qual

-- | Reference to the root tabular value.
[rootReference] :: BoolExpCtx -> Qual

-- | The monad that carries the translation of boolean expressions. This
--   supports the generation of fresh names for aliasing sub-expressions
--   and maintains the table context of the expressions being translated.
newtype BoolExpM a
BoolExpM :: ReaderT BoolExpCtx (State Word64) a -> BoolExpM a
[unBoolExpM] :: BoolExpM a -> ReaderT BoolExpCtx (State Word64) a

-- | Translate a <a>GBoolExp</a> with annotated SQLExpressions in the
--   leaves into a bare SQL Boolean Expression.
translateBoolExp :: forall pgKind. Backend ('Postgres pgKind) => AnnBoolExpSQL ('Postgres pgKind) -> BoolExpM BoolExp
data LHSField b
LColumn :: FieldName -> LHSField b
LComputedField :: QualifiedFunction -> FunctionArgsExp b (SQLExpression b) -> LHSField b
mkComputedFieldFunctionExp :: Qual -> QualifiedFunction -> FunctionArgsExp ('Postgres pgKind) (SQLExpression ('Postgres pgKind)) -> Maybe TableAlias -> FunctionExp
mkFieldCompExp :: Qual -> Qual -> LHSField ('Postgres pgKind) -> OpExpG ('Postgres pgKind) SQLExp -> BoolExp
instance Control.Monad.State.Class.MonadState GHC.Word.Word64 Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM
instance Control.Monad.Reader.Class.MonadReader Hasura.Backends.Postgres.Translate.BoolExp.BoolExpCtx Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM
instance GHC.Base.Monad Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM
instance GHC.Base.Applicative Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM
instance GHC.Base.Functor Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM

module Hasura.RQL.DDL.Permission.Internal

-- | Intrepet a <a>PermColSpec</a> column specification, which can either
--   refer to a list of named columns or all columns.
interpColSpec :: [Column b] -> PermColSpec b -> [Column b]
permissionIsDefined :: PermType -> RolePermInfo backend -> Bool
assertPermDefined :: (Backend backend, MonadError QErr m) => RoleName -> PermType -> TableInfo backend -> m ()
newtype CreatePerm a b
CreatePerm :: WithTable b (PermDef b a) -> CreatePerm a b
data CreatePermP1Res a
CreatePermP1Res :: a -> [SchemaDependency] -> CreatePermP1Res a
[cprInfo] :: CreatePermP1Res a -> a
[cprDeps] :: CreatePermP1Res a -> [SchemaDependency]
procBoolExp :: (QErrM m, TableCoreInfoRM b m, BackendMetadata b, GetAggregationPredicatesDeps b) => SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> BoolExp b -> m (AnnBoolExpPartialSQL b, [SchemaDependency])
getDepHeadersFromVal :: Value -> [Text]
getDependentHeaders :: BoolExp b -> HashSet Text
data DropPerm b
DropPerm :: SourceName -> TableName b -> RoleName -> DropPerm b
[dipSource] :: DropPerm b -> SourceName
[dipTable] :: DropPerm b -> TableName b
[dipRole] :: DropPerm b -> RoleName
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.DDL.Permission.Internal.CreatePermP1Res a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.DDL.Permission.Internal.CreatePermP1Res a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b a)) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Permission.Internal.CreatePerm a b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Permission.Internal.DropPerm b)

module Hasura.RQL.DDL.Permission
procSetObj :: forall b m. (QErrM m, BackendMetadata b) => SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> Maybe (ColumnValues b Value) -> m (PreSetColsPartial b, [Text], [SchemaDependency])
type family PermInfo perm
addPermissionToMetadata :: PermDef b a -> TableMetadata b -> TableMetadata b
buildPermInfo :: (BackendMetadata b, QErrM m, TableCoreInfoRM b m, GetAggregationPredicatesDeps b) => SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> RoleName -> PermDefPermission b perm -> m (WithDeps (PermInfo perm b))
doesPermissionExistInMetadata :: forall b. TableMetadata b -> RoleName -> PermType -> Bool
runCreatePerm :: forall m b a. (UserInfoM m, CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => CreatePerm a b -> m EncJSON
runDropPerm :: forall b m. (UserInfoM m, CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => PermType -> DropPerm b -> m EncJSON
buildInsPermInfo :: forall b m. (QErrM m, TableCoreInfoRM b m, BackendMetadata b, GetAggregationPredicatesDeps b) => SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> InsPerm b -> m (WithDeps (InsPermInfo b))

-- | validate the values present in the <tt>query_root_fields</tt> and the
--   <tt>subscription_root_fields</tt> present in the select permission
validateAllowedRootFields :: forall b m. (QErrM m, TableCoreInfoRM b m, BackendMetadata b) => SourceName -> TableName b -> RoleName -> SelPerm b -> m (AllowedRootFields QueryRootFieldType, AllowedRootFields SubscriptionRootFieldType)
buildSelPermInfo :: forall b m. (QErrM m, TableCoreInfoRM b m, BackendMetadata b, GetAggregationPredicatesDeps b) => SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> RoleName -> SelPerm b -> m (WithDeps (SelPermInfo b))
buildUpdPermInfo :: forall b m. (QErrM m, TableCoreInfoRM b m, BackendMetadata b, GetAggregationPredicatesDeps b) => SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> UpdPerm b -> m (WithDeps (UpdPermInfo b))
buildDelPermInfo :: forall b m. (QErrM m, TableCoreInfoRM b m, BackendMetadata b, GetAggregationPredicatesDeps b) => SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> DelPerm b -> m (WithDeps (DelPermInfo b))
data SetPermComment b
SetPermComment :: SourceName -> TableName b -> RoleName -> PermType -> Maybe Text -> SetPermComment b
[apSource] :: SetPermComment b -> SourceName
[apTable] :: SetPermComment b -> TableName b
[apRole] :: SetPermComment b -> RoleName
[apPermission] :: SetPermComment b -> PermType
[apComment] :: SetPermComment b -> Maybe Text
runSetPermComment :: forall b m. (QErrM m, CacheRWM m, MetadataM m, BackendMetadata b) => SetPermComment b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Permission.SetPermComment b)


-- | Functions for updating the metadata (with integrity checking) to
--   incorporate schema changes discovered after applying a user-supplied
--   SQL query. None of these functions modify the schema cache, so it must
--   be reloaded after the metadata is updated.
module Hasura.RQL.DDL.Schema.Rename
data RenameItem (b :: BackendType) a
RenameItem :: TableName b -> a -> a -> RenameItem (b :: BackendType) a
[_riTable] :: RenameItem (b :: BackendType) a -> TableName b
[_riOld] :: RenameItem (b :: BackendType) a -> a
[_riNew] :: RenameItem (b :: BackendType) a -> a
type RenameCol (b :: BackendType) = RenameItem b (Column b)
data RenameField b
RFCol :: RenameCol b -> RenameField b
RFRel :: RenameItem b RelName -> RenameField b
type RenameTable b = (TableName b, TableName b)
data Rename b
RTable :: RenameTable b -> Rename b
RField :: RenameField b -> Rename b
otherDeps :: QErrM m => Text -> SchemaObjId -> m ()

-- | Replace all references to a given table name by its new name across
--   the entire metadata.
--   
--   This function will make use of the metadata dependency graph (see
--   <a>getDependentObjs</a>) to identify all places that refer to the old
--   table name, and replace it accordingly. Most operations will occur
--   within the same source, such as table references in relationships and
--   permissions. Dependencies across sources can happen in the case of
--   cross-source relationships.
--   
--   This function will fail if it encounters a nonsensical dependency; for
--   instance, if there's a dependency from that table to a source.
--   
--   For more information about the dependency graph, see
--   <a>SchemaObjId</a>.
renameTableInMetadata :: forall b m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableName b -> TableName b -> m ()

-- | Replace all references to a given column name by its new name across
--   the entire metadata.
--   
--   This function will make use of the metadata dependency graph (see
--   <a>getDependentObjs</a>) to identify all places that refer to the old
--   column name, and replace it accordingly. Most operations will occur
--   within the same source, such as column references in relationships and
--   permissions. Dependencies across sources can happen in the case of
--   cross-source relationships.
--   
--   This function will fail if it encounters a nonsensical dependency; for
--   instance, if there's a dependency from that table to a source.
--   
--   For more information about the dependency graph, see
--   <a>SchemaObjId</a>.
renameColumnInMetadata :: forall b m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => Column b -> Column b -> SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> m ()
renameRelationshipInMetadata :: forall b m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableName b -> RelName -> RelType -> RelName -> m ()
updateRelDefs :: forall b m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableName b -> RelName -> RenameTable b -> m ()

-- | update fields in permissions
updatePermFlds :: forall b m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableName b -> RoleName -> PermType -> Rename b -> m ()
updateInsPermFlds :: (MonadReader (TableCache b) m, Backend b) => TableName b -> Rename b -> PermDefPermission b InsPerm -> m (PermDefPermission b InsPerm)
updateSelPermFlds :: (MonadReader (TableCache b) m, Backend b) => TableName b -> Rename b -> PermDefPermission b SelPerm -> m (PermDefPermission b SelPerm)
updateUpdPermFlds :: (MonadReader (TableCache b) m, Backend b) => TableName b -> Rename b -> PermDefPermission b UpdPerm -> m (PermDefPermission b UpdPerm)
updateDelPermFlds :: (MonadReader (TableCache b) m, Backend b) => TableName b -> Rename b -> PermDefPermission b DelPerm -> m (PermDefPermission b DelPerm)
updatePreset :: Backend b => TableName b -> RenameField b -> ColumnValues b Value -> ColumnValues b Value
updateCols :: Backend b => TableName b -> RenameField b -> PermColSpec b -> PermColSpec b
updateTableInBoolExp :: Backend b => RenameTable b -> BoolExp b -> BoolExp b
updateFieldInBoolExp :: (MonadReader (TableCache b) m, Backend b) => TableName b -> RenameField b -> BoolExp b -> m (BoolExp b)
updateColExp :: forall b m. (MonadReader (TableCache b) m, Backend b) => TableName b -> RenameField b -> ColExp -> m ColExp
updateColInRel :: forall b m. (CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableName b -> RelName -> RenameCol b -> m ()

-- | Local helper: update a column's name in the left-hand side of a remote
--   relationship.
--   
--   There are two kinds or remote relationships: remote source
--   relationships, across sources, and remote schema relationships, on
--   remote schemas. In both cases, we maintain a mapping from the source
--   table's colunns to what they should be joined against in the target;
--   when a column is renamed, those references must be renamed as well.
--   This function handles both cases.
--   
--   See <a>renameColumnInMetadata</a>.
updateColInRemoteRelationshipLHS :: forall b m. (MonadError QErr m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> RelName -> RenameCol b -> m ()

-- | Local helper: update a column's name in the right-hand side of a
--   remote relationship.
--   
--   In the case of remote _source_ relationships, the mapping from column
--   to column needs to be updated if one of the rhs columns has been
--   renamed. A dependency is tracked from the rhs source's column to the
--   lhs source's relationship: when a rhs source's column has been
--   renamed, this function performs the corresponding update in the lhs
--   source's relationship definition.
--   
--   See <a>renameColumnInMetadata</a>.
updateColInRemoteRelationshipRHS :: forall source target m. (MonadWriter MetadataModifier m, Backend source, Backend target) => SourceName -> TableName source -> RelName -> RenameCol target -> m ()

-- | Local helper: update a table's name in the right-hand side of a remote
--   relationship.
--   
--   In the case of remote _source_ relationships, the relationship
--   definition targets a specific table in the rhs source, and that
--   reference needs to be updated if the targeted table has been renamed.
--   A dependency is tracked from the rhs source's table to the lhs
--   source's relationship: when a rhs table has been renamed, this
--   function performs the corresponding update in the lhs source's
--   relationship definition.
--   
--   See <a>renameTableInMetadata</a>.
updateTableInRemoteRelationshipRHS :: forall source target m. (MonadWriter MetadataModifier m, Backend source, Backend target) => SourceName -> TableName source -> RelName -> RenameTable target -> m ()
updateColInObjRel :: Backend b => TableName b -> TableName b -> RenameCol b -> ObjRelUsing b -> ObjRelUsing b
updateRelChoice :: Backend b => TableName b -> TableName b -> RenameCol b -> ObjRelUsingChoice b -> ObjRelUsingChoice b
updateColInArrRel :: Backend b => TableName b -> TableName b -> RenameCol b -> ArrRelUsing b -> ArrRelUsing b
type ColMap b = HashMap (Column b) (Column b)
getNewCol :: forall b f. Backend b => Functor f => RenameCol b -> TableName b -> f (Column b) -> f (Column b)
updateRelManualConfig :: forall b. Backend b => TableName b -> TableName b -> RenameCol b -> RelManualConfig b -> RelManualConfig b
updateColMap :: forall b. Backend b => TableName b -> TableName b -> RenameCol b -> ColMap b -> ColMap b
possiblyUpdateCustomColumnNames :: forall b m. (MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableName b -> Column b -> Column b -> m ()

module Hasura.RQL.DDL.Relationship
newtype CreateArrRel b
CreateArrRel :: WithTable b (ArrRelDef b) -> CreateArrRel b
[unCreateArrRel] :: CreateArrRel b -> WithTable b (ArrRelDef b)
newtype CreateObjRel b
CreateObjRel :: WithTable b (ObjRelDef b) -> CreateObjRel b
[unCreateObjRel] :: CreateObjRel b -> WithTable b (ObjRelDef b)
runCreateRelationship :: forall m b a. (MonadError QErr m, CacheRWM m, ToJSON a, MetadataM m, Backend b, BackendMetadata b) => RelType -> WithTable b (RelDef a) -> m EncJSON
objRelP2Setup :: forall b m. (QErrM m, Backend b) => SourceName -> TableName b -> HashMap (TableName b) (HashSet (ForeignKey b)) -> RelDef (ObjRelUsing b) -> m (RelInfo b, [SchemaDependency])
arrRelP2Setup :: forall b m. (QErrM m, Backend b) => HashMap (TableName b) (HashSet (ForeignKey b)) -> SourceName -> TableName b -> ArrRelDef b -> m (RelInfo b, [SchemaDependency])
mkFkeyRel :: forall b m. QErrM m => Backend b => RelType -> InsertOrder -> SourceName -> RelName -> TableName b -> TableName b -> NonEmpty (Column b) -> HashMap (TableName b) (HashSet (ForeignKey b)) -> m (RelInfo b, [SchemaDependency])

-- | Try to find a foreign key constraint, identifying a constraint by its
--   set of columns
getRequiredFkey :: (QErrM m, Backend b) => NonEmpty (Column b) -> [ForeignKey b] -> m (ForeignKey b)
drUsingColumnDep :: forall b. Backend b => SourceName -> TableName b -> Column b -> SchemaDependency
data DropRel b
DropRel :: SourceName -> TableName b -> RelName -> Bool -> DropRel b
[_drSource] :: DropRel b -> SourceName
[_drTable] :: DropRel b -> TableName b
[_drRelationship] :: DropRel b -> RelName
[_drCascade] :: DropRel b -> Bool
runDropRel :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => DropRel b -> m EncJSON
purgeRelDep :: forall b m. QErrM m => Backend b => SchemaObjId -> m (TableMetadata b -> TableMetadata b)
data SetRelComment b
SetRelComment :: SourceName -> TableName b -> RelName -> Maybe Text -> SetRelComment b
[arSource] :: SetRelComment b -> SourceName
[arTable] :: SetRelComment b -> TableName b
[arRelationship] :: SetRelComment b -> RelName
[arComment] :: SetRelComment b -> Maybe Text
runSetRelComment :: forall m b. (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => SetRelComment b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.CreateArrRel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.CreateObjRel b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Relationship.SetRelComment b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Relationship.SetRelComment b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Relationship.SetRelComment b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.SetRelComment b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.DropRel b)


module Hasura.RQL.DDL.ComputedField
data AddComputedField b
AddComputedField :: SourceName -> TableName b -> ComputedFieldName -> ComputedFieldDefinition b -> Comment -> AddComputedField b
[_afcSource] :: AddComputedField b -> SourceName
[_afcTable] :: AddComputedField b -> TableName b
[_afcName] :: AddComputedField b -> ComputedFieldName
[_afcDefinition] :: AddComputedField b -> ComputedFieldDefinition b
[_afcComment] :: AddComputedField b -> Comment
runAddComputedField :: forall b m. (BackendMetadata b, MonadError QErr m, CacheRWM m, MetadataM m) => AddComputedField b -> m EncJSON
data DropComputedField b
DropComputedField :: SourceName -> TableName b -> ComputedFieldName -> Bool -> DropComputedField b
[_dccSource] :: DropComputedField b -> SourceName
[_dccTable] :: DropComputedField b -> TableName b
[_dccName] :: DropComputedField b -> ComputedFieldName
[_dccCascade] :: DropComputedField b -> Bool
runDropComputedField :: forall b m. (QErrM m, CacheRWM m, MetadataM m, BackendMetadata b) => DropComputedField b -> m EncJSON
instance GHC.Generics.Generic (Hasura.RQL.DDL.ComputedField.AddComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.ComputedField.DropComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.ComputedField.AddComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.ComputedField.AddComputedField b)


-- | Funtions related to <tt>hdb_catalog</tt> schema prior to metadata
--   separation (catalog version &lt; 43).
module Hasura.RQL.DDL.Schema.LegacyCatalog
saveMetadataToHdbTables :: (MonadTx m, MonadReader SystemDefined m) => MetadataNoSources -> m ()
saveTableToCatalog :: (MonadTx m, MonadReader SystemDefined m) => QualifiedTable -> Bool -> TableConfig ('Postgres 'Vanilla) -> m ()
insertRelationshipToCatalog :: (MonadTx m, MonadReader SystemDefined m, ToJSON a) => QualifiedTable -> RelType -> RelDef a -> m ()
addEventTriggerToCatalog :: (MonadTx m, Backend ('Postgres pgKind)) => QualifiedTable -> EventTriggerConf ('Postgres pgKind) -> m ()
addComputedFieldToCatalog :: MonadTx m => AddComputedField ('Postgres 'Vanilla) -> m ()
addRemoteRelationshipToCatalog :: MonadTx m => CreateFromSourceRelationship ('Postgres 'Vanilla) -> m ()
addFunctionToCatalog :: (MonadTx m, MonadReader SystemDefined m) => QualifiedFunction -> FunctionConfig -> m ()
addRemoteSchemaToCatalog :: RemoteSchemaMetadata -> TxE QErr ()
addCollectionToCatalog :: MonadTx m => CreateCollection -> SystemDefined -> m ()
addCollectionToAllowlistCatalog :: MonadTx m => CollectionName -> m ()
setCustomTypesInCatalog :: MonadTx m => CustomTypes -> m ()
addActionToCatalog :: MonadTx m => CreateAction -> m ()
addActionPermissionToCatalog :: MonadTx m => CreateActionPermission -> m ()
addPermissionToCatalog :: (MonadTx m, Backend b) => QualifiedTable -> PermDef b a -> SystemDefined -> m ()
addCronTriggerToCatalog :: MonadTx m => CronTriggerMetadata -> m ()
parseLegacyRemoteRelationshipDefinition :: MonadError QErr m => Value -> m RemoteRelationshipDefinition
fetchMetadataFromHdbTables :: MonadTx m => m MetadataNoSources
addCronTriggerForeignKeyConstraint :: MonadTx m => m ()

-- | Drops and recreates all “system-defined” metadata, aka metadata for
--   tables and views in the <tt>information_schema</tt> and
--   <tt>hdb_catalog</tt> schemas. These tables and views are tracked to
--   expose them to the console, which allows us to reuse the same
--   functionality we use to implement user-defined APIs to expose the
--   catalog.
--   
--   This process has a long and storied history.
--   
--   In the past, we reused the same machinery we use for CLI migrations to
--   define our own internal metadata migrations. This caused trouble,
--   however, as we’d have to run those migrations in lockstep with our SQL
--   migrations to ensure the two didn’t get out of sync. This in turn
--   caused trouble because those migrations would hit code paths inside
--   <tt>graphql-engine</tt> to add or remove things from the
--   <tt>pg_catalog</tt> tables, and <i>that</i> in turn would fail because
--   we hadn’t finished running the SQL migrations, so we were running a
--   new version of the code against an old version of the schema! That
--   caused #2826.
--   
--   To fix that, #2379 switched to the approach of just dropping and
--   recreating all system metadata every time we run any SQL migrations.
--   But <i>that</i> in turn caused trouble due to the way we were
--   constantly rebuilding the schema cache (#3354), causing us to switch
--   to incremental schema cache construction (#3394). However, although
--   that mostly resolved the problem, we still weren’t totally out of the
--   woods, as the incremental construction was still too slow on slow
--   Postgres instances (#3654).
--   
--   To sidestep the whole issue, as of #3686 we now just create all the
--   system metadata in code here, and we only rebuild the schema cache
--   once, at the very end. This is a little unsatisfying, since it means
--   our internal migrations are “blessed” compared to user-defined CLI
--   migrations. If we improve CLI migrations further in the future, maybe
--   we can switch back to using that approach, instead.
recreateSystemMetadata :: MonadTx m => m ()


-- | Postgres Translate Delete
--   
--   Tranlates an IR delete term to a Postgres SQL DELETE statement.
--   
--   See <a>execDeleteQuery</a>.
module Hasura.Backends.Postgres.Translate.Delete
mkDelete :: Backend ('Postgres pgKind) => AnnDel ('Postgres pgKind) -> SQLDelete


-- | Postgres DDL Function
--   
--   This module describes building information about Postgres functions by
--   validating the passed raw information.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.Function
mkFunctionArgs :: Int -> [QualifiedPGType] -> [FunctionArgName] -> [FunctionArg]
data FunctionIntegrityError
FunctionNameNotGQLCompliant :: FunctionIntegrityError
FunctionVariadic :: FunctionIntegrityError
FunctionReturnNotCompositeType :: FunctionIntegrityError
FunctionReturnNotTable :: FunctionIntegrityError
NonVolatileFunctionAsMutation :: FunctionIntegrityError
FunctionSessionArgumentNotJSON :: FunctionArgName -> FunctionIntegrityError
FunctionInvalidSessionArgument :: FunctionArgName -> FunctionIntegrityError
FunctionInvalidArgumentNames :: [FunctionArgName] -> FunctionIntegrityError
buildFunctionInfo :: forall pgKind m. (Backend ('Postgres pgKind), QErrM m) => SourceName -> QualifiedFunction -> SystemDefined -> FunctionConfig -> FunctionPermissionsMap -> RawFunctionInfo ('Postgres pgKind) -> Maybe Text -> NamingCase -> m (FunctionInfo ('Postgres pgKind), SchemaDependency)
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.Function.FunctionIntegrityError
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.Function.FunctionIntegrityError


-- | Postgres DDL ComputedField
--   
--   How to build the <a>ComputedFieldInfo</a> for a field.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.ComputedField
data ComputedFieldValidateError
CFVENotValidGraphQLName :: ComputedFieldName -> ComputedFieldValidateError
CFVEInvalidTableArgument :: InvalidTableArgument -> ComputedFieldValidateError
CFVEInvalidSessionArgument :: InvalidSessionArgument -> ComputedFieldValidateError
CFVENotBaseReturnType :: PGScalarType -> ComputedFieldValidateError
CFVEReturnTableNotFound :: QualifiedTable -> ComputedFieldValidateError
CFVENoInputArguments :: ComputedFieldValidateError
CFVEFunctionVolatile :: ComputedFieldValidateError
data InvalidTableArgument
ITANotFound :: FunctionArgName -> InvalidTableArgument
ITANotComposite :: FunctionTableArgument -> InvalidTableArgument
ITANotTable :: QualifiedTable -> FunctionTableArgument -> InvalidTableArgument
data InvalidSessionArgument
ISANotFound :: FunctionArgName -> InvalidSessionArgument
ISANotJSON :: FunctionSessionArgument -> InvalidSessionArgument
showError :: QualifiedFunction -> ComputedFieldValidateError -> Text
buildComputedFieldInfo :: forall pgKind m. QErrM m => HashSet QualifiedTable -> QualifiedTable -> HashSet PGCol -> ComputedFieldName -> ComputedFieldDefinition -> PGRawFunctionInfo -> Comment -> m (ComputedFieldInfo ('Postgres pgKind))
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.ComputedField.InvalidTableArgument
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.ComputedField.InvalidTableArgument
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.ComputedField.InvalidSessionArgument
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.ComputedField.InvalidSessionArgument
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.ComputedField.ComputedFieldValidateError
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.ComputedField.ComputedFieldValidateError


-- | Postgres DDL BoolExp
--   
--   How to parse the boolean expressions, specifically for Postgres.
--   
--   See <a>Cache</a> and <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.BoolExp
parseBoolExpOperations :: forall pgKind m v. (Backend ('Postgres pgKind), MonadError QErr m, TableCoreInfoRM ('Postgres pgKind) m) => ValueParser ('Postgres pgKind) m v -> QualifiedTable -> FieldInfoMap (FieldInfo ('Postgres pgKind)) -> ColumnReference ('Postgres pgKind) -> Value -> m [OpExpG ('Postgres pgKind) v]
buildComputedFieldBooleanExp :: forall pgKind m v. (MonadError QErr m, Backend ('Postgres pgKind), TableCoreInfoRM ('Postgres pgKind) m) => BoolExpResolver ('Postgres pgKind) m v -> BoolExpRHSParser ('Postgres pgKind) m v -> TableName ('Postgres pgKind) -> FieldInfoMap (FieldInfo ('Postgres pgKind)) -> ComputedFieldInfo ('Postgres pgKind) -> Value -> m (AnnComputedFieldBoolExp ('Postgres pgKind) v)


-- | Postgres DDL
--   
--   Implements the DDL related methods of the <a>BackendMetadata</a> type
--   class for the Postgres backend, which provides an interface for
--   fetching information about the objects in the database, such as
--   tables, relationships, etc.
module Hasura.Backends.Postgres.DDL
parseCollectableType :: forall pgKind m. (Backend ('Postgres pgKind), MonadError QErr m) => CollectableType (ColumnType ('Postgres pgKind)) -> Value -> m (PartialSQLExp ('Postgres pgKind))
mkTypedSessionVar :: CollectableType (ColumnType ('Postgres pgKind)) -> SessionVariable -> PartialSQLExp ('Postgres pgKind)


-- | Postgres Instances Metadata
--   
--   Defines a <a>BackendMetadata</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.Metadata

-- | We differentiate the handling of metadata between Citus and Vanilla
--   Postgres because Citus imposes limitations on the types of joins that
--   it permits, which then limits the types of relations that we can
--   track.
class PostgresMetadata (pgKind :: PostgresKind)
validateRel :: (PostgresMetadata pgKind, MonadError QErr m) => TableCache ('Postgres pgKind) -> QualifiedTable -> Either (ObjRelDef ('Postgres pgKind)) (ArrRelDef ('Postgres pgKind)) -> m ()
instance Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata 'Hasura.SQL.Backend.Vanilla
instance Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata 'Hasura.SQL.Backend.Citus
instance Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata 'Hasura.SQL.Backend.Cockroach
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind), Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata pgKind, Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata pgKind, Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata pgKind, Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery pgKind) => Hasura.RQL.Types.Metadata.Backend.BackendMetadata ('Hasura.SQL.Backend.Postgres pgKind)

module Hasura.RQL.DML.Internal
newtype DMLP1T m a
DMLP1T :: StateT (Seq PrepArg) m a -> DMLP1T m a
[unDMLP1T] :: DMLP1T m a -> StateT (Seq PrepArg) m a
runDMLP1T :: DMLP1T m a -> m (a, Seq PrepArg)
askPermInfo :: UserInfoM m => Lens' (RolePermInfo ('Postgres 'Vanilla)) (Maybe c) -> TableInfo ('Postgres 'Vanilla) -> m (Maybe c)
getPermInfoMaybe :: RoleName -> Lens' (RolePermInfo ('Postgres 'Vanilla)) (Maybe c) -> TableInfo ('Postgres 'Vanilla) -> Maybe c
assertAskPermInfo :: (UserInfoM m, QErrM m) => PermType -> Lens' (RolePermInfo ('Postgres 'Vanilla)) (Maybe c) -> TableInfo ('Postgres 'Vanilla) -> m c
isTabUpdatable :: RoleName -> TableInfo ('Postgres 'Vanilla) -> Bool
askInsPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (InsPermInfo ('Postgres 'Vanilla))
askSelPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (SelPermInfo ('Postgres 'Vanilla))
askUpdPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (UpdPermInfo ('Postgres 'Vanilla))
askDelPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (DelPermInfo ('Postgres 'Vanilla))
verifyAsrns :: MonadError QErr m => [a -> m ()] -> [a] -> m ()
checkRetCols :: (UserInfoM m, QErrM m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> SelPermInfo ('Postgres 'Vanilla) -> [PGCol] -> m [ColumnInfo ('Postgres 'Vanilla)]
checkSelOnCol :: (UserInfoM m, QErrM m) => SelPermInfo ('Postgres 'Vanilla) -> Column ('Postgres 'Vanilla) -> m ()
checkPermOnCol :: (UserInfoM m, QErrM m) => PermType -> HashSet (Column ('Postgres 'Vanilla)) -> Column ('Postgres 'Vanilla) -> m ()
checkSelectPermOnScalarComputedField :: (UserInfoM m, QErrM m) => SelPermInfo ('Postgres 'Vanilla) -> ComputedFieldName -> m ()
valueParserWithCollectableType :: MonadError QErr m => (ColumnType ('Postgres 'Vanilla) -> Value -> m SQLExp) -> CollectableType (ColumnType ('Postgres 'Vanilla)) -> Value -> m SQLExp
binRHSBuilder :: QErrM m => ColumnType ('Postgres 'Vanilla) -> Value -> DMLP1T m SQLExp
fetchRelTabInfo :: (QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => TableName ('Postgres 'Vanilla) -> m (TableInfo ('Postgres 'Vanilla))
askTableInfoSource :: (QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => TableName ('Postgres 'Vanilla) -> m (TableInfo ('Postgres 'Vanilla))
data SessionVariableBuilder m
SessionVariableBuilder :: SQLExpression ('Postgres 'Vanilla) -> (SessionVarType ('Postgres 'Vanilla) -> SessionVariable -> m (SQLExpression ('Postgres 'Vanilla))) -> SessionVariableBuilder m
[_svbCurrentSession] :: SessionVariableBuilder m -> SQLExpression ('Postgres 'Vanilla)
[_svbVariableParser] :: SessionVariableBuilder m -> SessionVarType ('Postgres 'Vanilla) -> SessionVariable -> m (SQLExpression ('Postgres 'Vanilla))
fetchRelDet :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => RelName -> TableName ('Postgres 'Vanilla) -> m (FieldInfoMap (FieldInfo ('Postgres 'Vanilla)), SelPermInfo ('Postgres 'Vanilla))
checkOnColExp :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => SelPermInfo ('Postgres 'Vanilla) -> SessionVariableBuilder m -> AnnBoolExpFldSQL ('Postgres 'Vanilla) -> m (AnnBoolExpFldSQL ('Postgres 'Vanilla))
convAnnBoolExpPartialSQL :: Applicative f => SessionVariableBuilder f -> AnnBoolExpPartialSQL ('Postgres 'Vanilla) -> f (AnnBoolExpSQL ('Postgres 'Vanilla))
convAnnColumnCaseBoolExpPartialSQL :: Applicative f => SessionVariableBuilder f -> AnnColumnCaseBoolExpPartialSQL ('Postgres 'Vanilla) -> f (AnnColumnCaseBoolExp ('Postgres 'Vanilla) (SQLExpression ('Postgres 'Vanilla)))
convPartialSQLExp :: Applicative f => SessionVariableBuilder f -> PartialSQLExp ('Postgres 'Vanilla) -> f (SQLExpression ('Postgres 'Vanilla))
sessVarFromCurrentSetting :: Applicative f => SessionVariableBuilder f
sessVarFromCurrentSetting' :: CollectableType PGScalarType -> SessionVariable -> SQLExp
fromCurrentSession :: SQLExp -> SessionVariable -> SQLExp
currentSession :: SQLExp
checkSelPerm :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => SelPermInfo ('Postgres 'Vanilla) -> SessionVariableBuilder m -> AnnBoolExpSQL ('Postgres 'Vanilla) -> m (AnnBoolExpSQL ('Postgres 'Vanilla))
convBoolExp :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> SelPermInfo ('Postgres 'Vanilla) -> BoolExp ('Postgres 'Vanilla) -> SessionVariableBuilder m -> TableName ('Postgres 'Vanilla) -> ValueParser ('Postgres 'Vanilla) m (SQLExpression ('Postgres 'Vanilla)) -> m (AnnBoolExpSQL ('Postgres 'Vanilla))
validateHeaders :: (UserInfoM m, QErrM m) => HashSet Text -> m ()
onlyPositiveInt :: MonadError QErr m => Int -> m ()
instance Hasura.Server.Types.HasServerConfigCtx m => Hasura.Server.Types.HasServerConfigCtx (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.Session.UserInfoM m => Hasura.Session.UserInfoM (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.RQL.Types.SchemaCache.SourceM m => Hasura.RQL.Types.SchemaCache.SourceM (Hasura.RQL.DML.Internal.DMLP1T m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.DML.Internal.DMLP1T m)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState (Data.Sequence.Internal.Seq Database.PG.Query.Connection.PrepArg) (Hasura.RQL.DML.Internal.DMLP1T m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.RQL.DML.Internal.DMLP1T
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.DML.Internal.DMLP1T m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.RQL.DML.Internal.DMLP1T m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.DML.Internal.DMLP1T m)

module Hasura.RQL.DML.Count
data CountQueryP1
CountQueryP1 :: QualifiedTable -> (AnnBoolExpSQL ('Postgres 'Vanilla), Maybe (AnnBoolExpSQL ('Postgres 'Vanilla))) -> Maybe [PGCol] -> CountQueryP1
[cqp1Table] :: CountQueryP1 -> QualifiedTable
[cqp1Where] :: CountQueryP1 -> (AnnBoolExpSQL ('Postgres 'Vanilla), Maybe (AnnBoolExpSQL ('Postgres 'Vanilla)))
[cqp1Distinct] :: CountQueryP1 -> Maybe [PGCol]
mkSQLCount :: CountQueryP1 -> Select
validateCountQWith :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => SessionVariableBuilder m -> (ColumnType ('Postgres 'Vanilla) -> Value -> m SQLExp) -> CountQuery -> m CountQueryP1
validateCountQ :: (QErrM m, UserInfoM m, CacheRM m) => CountQuery -> m (CountQueryP1, Seq PrepArg)
countQToTx :: (QErrM m, MonadTx m) => (CountQueryP1, Seq PrepArg) -> m EncJSON
runCount :: (QErrM m, UserInfoM m, CacheRM m, MonadIO m, MonadBaseControl IO m, MonadTrace m, MetadataM m) => CountQuery -> m EncJSON
instance GHC.Classes.Eq Hasura.RQL.DML.Count.CountQueryP1


-- | MSSQL DDL BoolExp
--   
--   How to parse the boolean expressions and operations relevant for
--   MSSQL.
module Hasura.Backends.MSSQL.DDL.BoolExp
parseBoolExpOperations :: forall m v. MonadError QErr m => ValueParser 'MSSQL m v -> TableName -> FieldInfoMap (FieldInfo 'MSSQL) -> ColumnReference 'MSSQL -> Value -> m [OpExpG 'MSSQL v]


-- | MSSQL DDL
--   
--   Implements the DDL related methods of the <a>BackendMetadata</a> type
--   class for the MSSQL backend, which provides an interface for fetching
--   information about the objects in the database, such as tables,
--   relationships, etc.
--   
--   The actual instance is defined in
--   <a>Hasura.Backends.MSSQL.Instances.Metadata</a>.
module Hasura.Backends.MSSQL.DDL
buildComputedFieldInfo :: MonadError QErr m => HashSet (TableName 'MSSQL) -> TableName 'MSSQL -> HashSet (Column 'MSSQL) -> ComputedFieldName -> ComputedFieldDefinition 'MSSQL -> RawFunctionInfo 'MSSQL -> Comment -> m (ComputedFieldInfo 'MSSQL)
fetchAndValidateEnumValues :: Monad m => SourceConfig 'MSSQL -> TableName 'MSSQL -> Maybe (PrimaryKey 'MSSQL (RawColumnInfo 'MSSQL)) -> [RawColumnInfo 'MSSQL] -> m (Either QErr EnumValues)
buildFunctionInfo :: MonadError QErr m => SourceName -> FunctionName 'MSSQL -> SystemDefined -> FunctionConfig -> FunctionPermissionsMap -> RawFunctionInfo 'MSSQL -> Maybe Text -> NamingCase -> m (FunctionInfo 'MSSQL, SchemaDependency)
updateColumnInEventTrigger :: TableName 'MSSQL -> Column 'MSSQL -> Column 'MSSQL -> TableName 'MSSQL -> EventTriggerConf 'MSSQL -> EventTriggerConf 'MSSQL
parseCollectableType :: MonadError QErr m => CollectableType (ColumnType 'MSSQL) -> Value -> m (PartialSQLExp 'MSSQL)
mkTypedSessionVar :: CollectableType (ColumnType 'MSSQL) -> SessionVariable -> PartialSQLExp 'MSSQL
msColumnTypeToScalarType :: ColumnType 'MSSQL -> ScalarType 'MSSQL


-- | MSSQL Instances Metadata
--   
--   Defines a <a>BackendMetadata</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.Metadata
instance Hasura.RQL.Types.Metadata.Backend.BackendMetadata 'Hasura.SQL.Backend.MSSQL

module Hasura.Backends.DataConnector.Adapter.Metadata
resolveSourceConfig' :: MonadIO m => Logger Hasura -> SourceName -> ConnSourceConfig -> BackendSourceKind 'DataConnector -> InsOrdHashMap DataConnectorName DataConnectorOptions -> Environment -> Manager -> m (Either QErr SourceConfig)
validateConfiguration :: MonadError QErr m => SourceName -> DataConnectorName -> ConfigSchemaResponse -> Config -> m ()
resolveDatabaseMetadata' :: Applicative m => SourceMetadata 'DataConnector -> SourceConfig -> SourceTypeCustomization -> m (Either QErr (ResolvedSource 'DataConnector))

-- | Construct a <a>HashSet</a> <a>ForeignKeyMetadata</a>
--   <a>DataConnector</a> to build the foreign key constraints in the table
--   metadata.
buildForeignKeySet :: [Maybe ForeignKeys] -> HashSet (ForeignKeyMetadata 'DataConnector)

-- | This is needed to get permissions to work
parseBoolExpOperations' :: forall m v. (MonadError QErr m, TableCoreInfoRM 'DataConnector m) => ValueParser 'DataConnector m v -> Name -> FieldInfoMap (FieldInfo 'DataConnector) -> ColumnReference 'DataConnector -> Value -> m [OpExpG 'DataConnector v]
parseCollectableType' :: MonadError QErr m => CollectableType (ColumnType 'DataConnector) -> Value -> m (PartialSQLExp 'DataConnector)
mkTypedSessionVar :: CollectableType (ColumnType 'DataConnector) -> SessionVariable -> PartialSQLExp 'DataConnector
columnTypeToScalarType :: ColumnType 'DataConnector -> Type
instance Hasura.RQL.Types.Metadata.Backend.BackendMetadata 'Hasura.SQL.Backend.DataConnector


-- | Translate from the DML to the MySQL dialect.
module Hasura.Backends.MySQL.FromIr
data FieldSource
ExpressionFieldSource :: Aliased Expression -> FieldSource
JoinFieldSource :: Aliased Join -> FieldSource
AggregateFieldSource :: [Aliased Aggregate] -> FieldSource

-- | Most of these errors should be checked for legitimacy.
data Error
UnsupportedOpExpG :: OpExpG 'MySQL Expression -> Error
IdentifierNotSupported :: Error
FunctionNotSupported :: Error
NodesUnsupportedForNow :: Error
ConnectionsNotSupported :: Error

-- | The base monad used throughout this module for all conversion
--   functions.
--   
--   It's a Validate, so it'll continue going when it encounters errors to
--   accumulate as many as possible.
--   
--   It also contains a mapping from entity prefixes to counters. So if my
--   prefix is "table" then there'll be a counter that lets me generate
--   table1, table2, etc. Same for any other prefix needed (e.g. names for
--   joins).
--   
--   A ReaderT is used around this in most of the module too, for setting
--   the current entity that a given field name refers to. See
--   <tt>fromColumn</tt>.
newtype FromIr a
FromIr :: StateT (Map Text Int) (Validate (NonEmpty Error)) a -> FromIr a
[unFromIr] :: FromIr a -> StateT (Map Text Int) (Validate (NonEmpty Error)) a
runFromIr :: FromIr a -> Validate (NonEmpty Error) a
data NameTemplate
ArrayRelationTemplate :: Text -> NameTemplate
ArrayAggregateTemplate :: Text -> NameTemplate
ObjectRelationTemplate :: Text -> NameTemplate
TableTemplate :: Text -> NameTemplate
ForOrderAlias :: Text -> NameTemplate
IndexTemplate :: NameTemplate
generateEntityAlias :: NameTemplate -> FromIr Text

-- | This is really the start where you query the base table, everything
--   else is joins attached to it.
fromQualifiedTable :: TableName -> FromIr From
fromAlias :: From -> EntityAlias
trueExpression :: Expression
existsFieldName :: Text
fromGExists :: GExists 'MySQL Expression -> ReaderT EntityAlias FromIr Select
fromGBoolExp :: GBoolExp 'MySQL Expression -> ReaderT EntityAlias FromIr Expression
fromAnnBoolExp :: GBoolExp 'MySQL (AnnBoolExpFld 'MySQL Expression) -> ReaderT EntityAlias FromIr Expression

-- | For boolean operators, various comparison operators used need special
--   handling to ensure that SQL Server won't outright reject the
--   comparison. See also <tt>shouldCastToVarcharMax</tt>.
fromColumnInfoForBoolExp :: ColumnInfo 'MySQL -> ReaderT EntityAlias FromIr Expression
fromAnnBoolExpFld :: AnnBoolExpFld 'MySQL Expression -> ReaderT EntityAlias FromIr Expression

-- | The context given by the reader is of the previous/parent "remote"
--   table. The WHERE that we're generating goes in the child, "local"
--   query. The <tt>From</tt> passed in as argument is the local table.
--   
--   We should hope to see e.g. "post.category = category.id" for a local
--   table of post and a remote table of category.
--   
--   The left/right columns in <tt>HashMap Column Column</tt> corresponds
--   to the left/right of <tt>select ... join ...</tt>. Therefore
--   left=remote, right=local in this context.
fromMapping :: From -> HashMap Column Column -> ReaderT EntityAlias FromIr [Expression]
fromColumn :: Column -> ReaderT EntityAlias FromIr FieldName
columnNameToFieldName :: Column -> EntityAlias -> FieldName
fromOpExpG :: Expression -> OpExpG 'MySQL Expression -> FromIr Expression
data Args
Args :: Where -> Maybe (NonEmpty OrderBy) -> [Join] -> Top -> Maybe Int -> Proxy (Maybe (NonEmpty FieldName)) -> Map TableName EntityAlias -> Args
[argsWhere] :: Args -> Where
[argsOrderBy] :: Args -> Maybe (NonEmpty OrderBy)
[argsJoins] :: Args -> [Join]
[argsTop] :: Args -> Top
[argsOffset] :: Args -> Maybe Int
[argsDistinct] :: Args -> Proxy (Maybe (NonEmpty FieldName))
[argsExistingJoins] :: Args -> Map TableName EntityAlias
data UnfurledJoin
UnfurledJoin :: Join -> Maybe (TableName, EntityAlias) -> UnfurledJoin
[unfurledJoin] :: UnfurledJoin -> Join

-- | Recorded if we joined onto an object relation.
[unfurledObjectTableAlias] :: UnfurledJoin -> Maybe (TableName, EntityAlias)
fromColumnInfo :: ColumnInfo 'MySQL -> ReaderT EntityAlias FromIr FieldName
tableNameText :: TableName -> Text
aggFieldName :: Text

-- | Unfurl the nested set of object relations (tell'd in the writer) that
--   are terminated by field name (IR.AOCColumn and
--   IR.AOCArrayAggregation).
unfurlAnnOrderByElement :: AnnotatedOrderByElement 'MySQL Expression -> WriterT (Seq UnfurledJoin) (ReaderT EntityAlias FromIr) (FieldName, Maybe ScalarType)

-- | Produce a valid ORDER BY construct, telling about any joins needed on
--   the side.
fromAnnOrderByItemG :: AnnotatedOrderByItemG 'MySQL Expression -> WriterT (Seq UnfurledJoin) (ReaderT EntityAlias FromIr) OrderBy
fromSelectArgsG :: SelectArgsG 'MySQL Expression -> ReaderT EntityAlias FromIr Args

-- | Here is where we project a field as a column expression. If number
--   stringification is on, then we wrap it in a
--   <tt>ToStringExpression</tt> so that it's casted when being projected.
fromAnnColumnField :: AnnColumnField 'MySQL Expression -> ReaderT EntityAlias FromIr Expression
fromRelName :: RelName -> FromIr Text
fromTableAggregateFieldG :: (FieldName, TableAggregateFieldG 'MySQL Void Expression) -> ReaderT EntityAlias FromIr FieldSource
fieldSourceProjections :: FieldSource -> [Projection]
fieldSourceJoin :: FieldSource -> Maybe Join
fromSelectAggregate :: Maybe (EntityAlias, HashMap Column Column) -> AnnSelectG 'MySQL (TableAggregateFieldG 'MySQL Void) Expression -> FromIr Select
fromArrayAggregateSelectG :: AnnRelationSelectG 'MySQL (AnnAggregateSelectG 'MySQL Void Expression) -> ReaderT EntityAlias FromIr Join
fromArraySelectG :: ArraySelectG 'MySQL Void Expression -> ReaderT EntityAlias FromIr Join
fromObjectRelationSelectG :: ObjectRelationSelectG 'MySQL Void Expression -> ReaderT EntityAlias FromIr Join
isEmptyExpression :: Expression -> Bool
fromSelectRows :: AnnSelectG 'MySQL (AnnFieldG 'MySQL Void) Expression -> FromIr Select
fromArrayRelationSelectG :: ArrayRelationSelectG 'MySQL Void Expression -> ReaderT EntityAlias FromIr Join

-- | The main sources of fields, either constants, fields or via joins.
fromAnnFieldsG :: (FieldName, AnnFieldG 'MySQL Void Expression) -> ReaderT EntityAlias FromIr FieldSource
mkSQLSelect :: JsonAggSelect -> AnnSelectG 'MySQL (AnnFieldG 'MySQL Void) Expression -> FromIr Select

-- | Convert from the IR database query into a select.
fromRootField :: QueryDB 'MySQL Void Expression -> FromIr Select
fromMappingFieldNames :: EntityAlias -> HashMap Column Column -> ReaderT EntityAlias FromIr [(FieldName, FieldName)]
fieldTextNames :: AnnFieldsG 'MySQL Void Expression -> [Text]
instance GHC.Show.Show Hasura.Backends.MySQL.FromIr.FieldSource
instance GHC.Classes.Eq Hasura.Backends.MySQL.FromIr.FieldSource
instance GHC.Classes.Eq Hasura.Backends.MySQL.FromIr.Error
instance GHC.Show.Show Hasura.Backends.MySQL.FromIr.Error
instance Control.Monad.Validate.Class.MonadValidate (GHC.Base.NonEmpty Hasura.Backends.MySQL.FromIr.Error) Hasura.Backends.MySQL.FromIr.FromIr
instance GHC.Base.Monad Hasura.Backends.MySQL.FromIr.FromIr
instance GHC.Base.Applicative Hasura.Backends.MySQL.FromIr.FromIr
instance GHC.Base.Functor Hasura.Backends.MySQL.FromIr.FromIr
instance GHC.Show.Show Hasura.Backends.MySQL.FromIr.Args
instance GHC.Show.Show Hasura.Backends.MySQL.FromIr.UnfurledJoin


-- | Planning MySQL queries and subscriptions.
module Hasura.Backends.MySQL.Plan

-- | Plan the query and then produce a forest of actions for the executor.
queryToActionForest :: MonadError QErr m => UserInfo -> QueryDB 'MySQL Void (UnpreparedValue 'MySQL) -> m (HeadAndTail, Forest PlannedAction)
planQuery :: MonadError QErr m => SessionVariables -> QueryDB 'MySQL Void (UnpreparedValue 'MySQL) -> m Select

-- | Prepare a value without any query planning; we just execute the query
--   with the values embedded.
prepareValueQuery :: MonadError QErr m => SessionVariables -> UnpreparedValue 'MySQL -> m Expression


-- | The modules in the <tt>Hasura.Backends.MSSQL.FromIr</tt> namespace
--   translates the RQL IR into TSQL, the SQL dialect of MSSQL, as defined
--   in abstract syntax in <a>Hasura.Backends.MSSQL.Types</a>.
--   
--   The translation happens in the <tt>FromIr</tt> monad, which manages
--   identifier scoping and error collection.
--   
--   The actual rendering of this AST into TSQL text happens in
--   <a>Hasura.Backends.MSSQL.ToQuery</a>.
module Hasura.Backends.MSSQL.FromIr

-- | The central Monad used throughout for all conversion functions.
--   
--   It has the following features:
--   
--   <ul>
--   <li>It's a <a>MonadValidate</a>, so it'll continue going when it
--   encounters <a>Error</a>s to accumulate as many as possible.</li>
--   <li>It has a facility for generating fresh, unique aliases, which lets
--   the translation output retain a resemblance with source names without
--   the translation process needing to be bothered about potential name
--   shadowing. See <a>generateAlias</a>.</li>
--   </ul>
newtype FromIr a
FromIr :: StateT (Map Text Int) (Validate (NonEmpty Error)) a -> FromIr a
[unFromIr] :: FromIr a -> StateT (Map Text Int) (Validate (NonEmpty Error)) a

-- | Run a <a>FromIr</a> action, throwing errors that have been collected
--   using the supplied action.
runFromIr :: MonadError QErr m => FromIr a -> m a

-- | Errors that may happen during translation.
data Error
UnsupportedOpExpG :: OpExpG 'MSSQL Expression -> Error
FunctionNotSupported :: Error

-- | Hints about the type of entity that <a>generateAlias</a> is producing
--   an alias for.
data NameTemplate
ArrayRelationTemplate :: Text -> NameTemplate
ArrayAggregateTemplate :: Text -> NameTemplate
ObjectRelationTemplate :: Text -> NameTemplate
TableTemplate :: Text -> NameTemplate
ForOrderAlias :: Text -> NameTemplate

-- | Generate a fresh alias for a given entity to remove ambiguity and
--   naming conflicts between scopes at the TSQL level.
--   
--   Names are generated in the form <tt>type_name_occurrence</tt>, where:
--   
--   <ul>
--   <li><tt>type</tt> hints at the type of entity,</li>
--   <li><tt>name</tt> refers to the source name being aliased, and</li>
--   <li><tt>occurrence</tt> is an integer counter that distinguishes each
--   occurrence of <tt>type_name</tt>.</li>
--   </ul>
--   
--   Example outputs:
--   
--   <pre>
--   do
--     "ar_articles_1" &lt;- generateAlias (ArrayRelationTemplate "articles")
--     "ar_articles_2" &lt;- generateAlias (ArrayRelationTemplate "articles")
--     "t_users_1"     &lt;- generateAlias (TableTemplate "users")
--   </pre>
generateAlias :: NameTemplate -> FromIr Text
instance GHC.Classes.Eq Hasura.Backends.MSSQL.FromIr.Error
instance GHC.Show.Show Hasura.Backends.MSSQL.FromIr.Error
instance Control.Monad.Validate.Class.MonadValidate (GHC.Base.NonEmpty Hasura.Backends.MSSQL.FromIr.Error) Hasura.Backends.MSSQL.FromIr.FromIr
instance GHC.Base.Monad Hasura.Backends.MSSQL.FromIr.FromIr
instance GHC.Base.Applicative Hasura.Backends.MSSQL.FromIr.FromIr
instance GHC.Base.Functor Hasura.Backends.MSSQL.FromIr.FromIr


-- | This module translates the IR of boolean expressions into TSQL boolean
--   expressions.
--   
--   Boolean expressions typically arise from permissions and where-clause
--   filters.
module Hasura.Backends.MSSQL.FromIr.Expression

-- | Translate boolean expressions into TSQL <a>Expression</a>s.
--   
--   The <a>AnnBoolExpFld</a> references fields and columns. The entity
--   (e.g. table) that binds these columns is supplied in the `ReaderT
--   EntityAlias` environment, such that the columns can be referred to
--   unambiguously.
fromGBoolExp :: GBoolExp 'MSSQL (AnnBoolExpFld 'MSSQL Expression) -> ReaderT EntityAlias FromIr Expression

-- | Translate boolean expressions into TSQL <a>Expression</a>s.
--   
--   The <a>AnnBoolExpFld</a> references fields and columns. The entity
--   (e.g. table) that binds these columns is supplied in the `ReaderT
--   EntityAlias` environment, such that the columns can be referred to
--   unambiguously.
fromAnnBoolExpFld :: AnnBoolExpFld 'MSSQL Expression -> ReaderT EntityAlias FromIr Expression

-- | Scope a translation action to the table bound in a FROM clause.
scopedTo :: From -> ReaderT EntityAlias FromIr a -> ReaderT EntityAlias FromIr a

-- | Translate a column reference occurring in a boolean expression into an
--   equivalent <a>Expression</a>.
--   
--   Different text types support different operators. Therefore we cast
--   some text types to "varchar(max)", which supports the most operators.
fromColumnInfo :: ColumnInfo 'MSSQL -> ReaderT EntityAlias FromIr Expression

-- | Get FieldSource from a TAFExp type table aggregate field
fromColumn :: ColumnName -> ReaderT EntityAlias FromIr FieldName

-- | Translate a single <a>OpExpG</a> operation on a column into an
--   expression.
fromOpExpG :: ColumnInfo 'MSSQL -> OpExpG 'MSSQL Expression -> ReaderT EntityAlias FromIr Expression
nullableBoolEquality :: Expression -> Expression -> Expression
nullableBoolInequality :: Expression -> Expression -> Expression
aliasQualifiedTable :: TableName -> FromIr From


-- | This module defines the translation functions for update mutations.
module Hasura.Backends.MSSQL.FromIr.Update
fromUpdate :: AnnotatedUpdate 'MSSQL -> FromIr Update


-- | This module defines translation functions for queries which select
--   data. Principally this includes translating the <tt>query</tt> root
--   field, but parts are also reused for serving the responses for
--   mutations.
module Hasura.Backends.MSSQL.FromIr.Query

-- | This is the top-level entry point for translation of Query root
--   fields.
fromQueryRootField :: QueryDB 'MSSQL Void Expression -> FromIr Select
fromSelect :: JsonAggSelect -> AnnSelectG 'MSSQL (AnnFieldG 'MSSQL Void) Expression -> FromIr Select

-- | Used in <a>planSourceRelationship</a>, which is in turn used by to
--   implement <tt>mkDBRemoteRelationship</tt> for <tt>BackendExecute</tt>.
--   For more information, see the module/documentation of <a>Source</a>.
fromSourceRelationship :: NonEmpty Object -> HashMap FieldName (ColumnName, ScalarType) -> FieldName -> (FieldName, SourceRelationshipSelection 'MSSQL Void (Const Expression)) -> FromIr Select

-- | Build the <a>FieldSource</a> for the relation field, depending on
--   whether it's an object, array, or aggregate relationship.
fromRemoteRelationFieldsG :: Map TableName EntityAlias -> HashMap ColumnName ColumnName -> (FieldName, SourceRelationshipSelection 'MSSQL Void (Const Expression)) -> ReaderT EntityAlias FromIr FieldSource

-- | Top<i>root-level <a>Select</a>. All descendent</i>sub-translations are
--   collected to produce a root TSQL.Select.
fromSelectRows :: AnnSelectG 'MSSQL (AnnFieldG 'MSSQL Void) Expression -> FromIr Select
mkNodesSelect :: Args -> Where -> Expression -> Top -> From -> [(Int, (FieldName, [FieldSource]))] -> [(Int, Projection)]
mkAggregateSelect :: Args -> Where -> Expression -> From -> [(Int, (FieldName, [Projection]))] -> [(Int, Projection)]
fromSelectAggregate :: Maybe (EntityAlias, HashMap ColumnName ColumnName) -> AnnSelectG 'MSSQL (TableAggregateFieldG 'MSSQL Void) Expression -> FromIr Select
data Args
Args :: Where -> Maybe (NonEmpty OrderBy) -> [Join] -> Top -> Maybe Expression -> Proxy (Maybe (NonEmpty FieldName)) -> Map TableName EntityAlias -> Args
[argsWhere] :: Args -> Where
[argsOrderBy] :: Args -> Maybe (NonEmpty OrderBy)
[argsJoins] :: Args -> [Join]
[argsTop] :: Args -> Top
[argsOffset] :: Args -> Maybe Expression
[argsDistinct] :: Args -> Proxy (Maybe (NonEmpty FieldName))
[argsExistingJoins] :: Args -> Map TableName EntityAlias
fromSelectArgsG :: SelectArgsG 'MSSQL Expression -> ReaderT EntityAlias FromIr Args
fromQualifiedTable :: TableName -> FromIr From
data FieldSource
ExpressionFieldSource :: Aliased Expression -> FieldSource
JoinFieldSource :: JsonCardinality -> Aliased Join -> FieldSource

-- | Get FieldSource from a TAFExp type table aggregate field
fromTableExpFieldG :: (Int, (FieldName, TableAggregateFieldG 'MSSQL Void Expression)) -> Maybe (ReaderT EntityAlias FromIr (Int, Projection))
fromTableAggFieldG :: (Int, (FieldName, TableAggregateFieldG 'MSSQL Void Expression)) -> Maybe (Int, (FieldName, [Projection]))
fromTableNodesFieldG :: Map TableName EntityAlias -> (Int, (FieldName, TableAggregateFieldG 'MSSQL Void Expression)) -> Maybe (ReaderT EntityAlias FromIr (Int, (FieldName, [FieldSource])))
fromAggregateField :: Text -> AggregateField 'MSSQL -> Projection

-- | The main sources of fields, either constants, fields or via joins.
fromAnnFieldsG :: Map TableName EntityAlias -> (FieldName, AnnFieldG 'MSSQL Void Expression) -> ReaderT EntityAlias FromIr FieldSource

-- | Here is where we project a field as a column expression. If number
--   stringification is on, then we wrap it in a <a>ToStringExpression</a>
--   so that it's casted when being projected.
fromAnnColumnField :: AnnColumnField 'MSSQL Expression -> ReaderT EntityAlias FromIr Expression

-- | This is where a field name "foo" is resolved to a fully qualified
--   field name [table].[foo]. The table name comes from EntityAlias in the
--   ReaderT.
fromColumn :: ColumnName -> ReaderT EntityAlias FromIr FieldName
fieldSourceProjections :: FieldSource -> Projection
joinAliasToField :: JoinAlias -> FieldName
fieldSourceJoin :: FieldSource -> Maybe Join
fromObjectRelationSelectG :: Map TableName EntityAlias -> ObjectRelationSelectG 'MSSQL Void Expression -> ReaderT EntityAlias FromIr Join
lookupTableFrom :: Map TableName EntityAlias -> TableName -> FromIr (Either EntityAlias From)
fromArraySelectG :: ArraySelectG 'MSSQL Void Expression -> ReaderT EntityAlias FromIr Join
fromArrayAggregateSelectG :: AnnRelationSelectG 'MSSQL (AnnAggregateSelectG 'MSSQL Void Expression) -> ReaderT EntityAlias FromIr Join
fromArrayRelationSelectG :: ArrayRelationSelectG 'MSSQL Void Expression -> ReaderT EntityAlias FromIr Join
fromRelName :: RelName -> FromIr Text

-- | The context given by the reader is of the previous/parent "remote"
--   table. The WHERE that we're generating goes in the child, "local"
--   query. The <tt>From</tt> passed in as argument is the local table.
--   
--   We should hope to see e.g. "post.category = category.id" for a local
--   table of post and a remote table of category.
--   
--   The left/right columns in <tt>HashMap ColumnName ColumnName</tt>
--   corresponds to the left/right of <tt>select ... join ...</tt>.
--   Therefore left=remote, right=local in this context.
fromMapping :: From -> HashMap ColumnName ColumnName -> ReaderT EntityAlias FromIr [Expression]
selectFromMapping :: Select -> HashMap ColumnName ColumnName -> ReaderT EntityAlias FromIr [Expression]

-- | A version of <tt>JSON_QUERY(..)</tt> that returns a proper json
--   literal, rather than SQL null, which does not compose properly with
--   <tt>FOR JSON</tt> clauses.
safeJsonQueryExpression :: JsonCardinality -> Expression -> Expression
data UnfurledJoin
UnfurledJoin :: Join -> Maybe (TableName, EntityAlias) -> UnfurledJoin
[unfurledJoin] :: UnfurledJoin -> Join

-- | Recorded if we joined onto an object relation.
[unfurledObjectTableAlias] :: UnfurledJoin -> Maybe (TableName, EntityAlias)
fromAnnotatedOrderByItemG :: AnnotatedOrderByItemG 'MSSQL Expression -> WriterT (Seq UnfurledJoin) (ReaderT EntityAlias FromIr) OrderBy

-- | Unfurl the nested set of object relations (tell'd in the writer) that
--   are terminated by field name (IR.AOCColumn and
--   IR.AOCArrayAggregation).
unfurlAnnotatedOrderByElement :: AnnotatedOrderByElement 'MSSQL Expression -> WriterT (Seq UnfurledJoin) (ReaderT EntityAlias FromIr) (FieldName, Maybe ScalarType)
tableNameText :: TableName -> Text
fromColumnInfo :: ColumnInfo 'MSSQL -> ReaderT EntityAlias FromIr FieldName
instance GHC.Show.Show Hasura.Backends.MSSQL.FromIr.Query.Args
instance GHC.Show.Show Hasura.Backends.MSSQL.FromIr.Query.FieldSource
instance GHC.Classes.Eq Hasura.Backends.MSSQL.FromIr.Query.FieldSource
instance GHC.Show.Show Hasura.Backends.MSSQL.FromIr.Query.UnfurledJoin


-- | MSSQL Plan
--   
--   Planning T-SQL queries and subscription by translating IR to
--   MSSQL-specific SQL query types.
module Hasura.Backends.MSSQL.Plan
planQuery :: MonadError QErr m => SessionVariables -> QueryDB 'MSSQL Void (UnpreparedValue 'MSSQL) -> m Select

-- | For more information, see the module/documentation of <a>Source</a>.
planSourceRelationship :: MonadError QErr m => SessionVariables -> NonEmpty Object -> HashMap FieldName (ColumnName, ScalarType) -> FieldName -> (FieldName, SourceRelationshipSelection 'MSSQL Void UnpreparedValue) -> m Select
runIrWrappingRoot :: MonadError QErr m => FromIr Select -> m Select

-- | Prepare a value without any query planning; we just execute the query
--   with the values embedded.
prepareValueQuery :: MonadError QErr m => SessionVariables -> UnpreparedValue 'MSSQL -> m Expression
planSubscription :: MonadError QErr m => InsOrdHashMap Name (QueryDB 'MSSQL Void (UnpreparedValue 'MSSQL)) -> SessionVariables -> m (Reselect, PrepareState)

-- | Collapse a set of selects into a single select that projects these as
--   subselects.
collapseMap :: InsOrdHashMap Name Select -> Reselect
data PrepareState
PrepareState :: [ColumnValue 'MSSQL] -> HashMap Name (ColumnValue 'MSSQL) -> HashSet SessionVariable -> PrepareState
[positionalArguments] :: PrepareState -> [ColumnValue 'MSSQL]
[namedArguments] :: PrepareState -> HashMap Name (ColumnValue 'MSSQL)
[sessionVariables] :: PrepareState -> HashSet SessionVariable
emptyPrepareState :: PrepareState

-- | Prepare a value for multiplexed queries.
prepareValueSubscription :: (MonadState PrepareState m, MonadError QErr m) => HashSet SessionVariable -> UnpreparedValue 'MSSQL -> m Expression
resultIdAlias :: Text
resultVarsAlias :: Text
resultAlias :: Text
rowAlias :: Text


-- | This module defines translation functions that yield the results of
--   mutation requests that return the data of rows that were affected.
module Hasura.Backends.MSSQL.FromIr.MutationResponse

-- | Generate a SQL SELECT statement which outputs the mutation response
--   
--   For multi row inserts:
--   
--   SELECT (SELECT COUNT(*) FROM [with_alias]) AS [affected_rows],
--   (select_from_returning) AS [returning] FOR JSON PATH,
--   INCLUDE_NULL_VALUES, WITHOUT_ARRAY_WRAPPER
--   
--   For single row insert: the selection set is translated to SQL query
--   using @<a>fromSelect</a>
mkMutationOutputSelect :: StringifyNumbers -> Text -> MutationOutputG 'MSSQL Void Expression -> FromIr Select

-- | Generate a SQL SELECT statement which outputs both mutation response
--   and check constraint result.
--   
--   A <tt>check constraint</tt> applies to the data that has been changed,
--   while <tt>permissions</tt> filter the data that is made available.
--   
--   This function applies to <tt>insert</tt> and <tt>update</tt>
--   mutations.
--   
--   The check constraint boolean expression is evaluated on mutated rows
--   in a CASE expression so that the int value "0" is returned when check
--   constraint is true otherwise the int value "1" is returned. We use
--   <a>SUM</a> aggregation on the returned value and if check constraint
--   on any row is not met, the summed value will not equal to "0" (always
--   &gt; 1).
--   
--   <pre>
--   &lt;check_constraint_select&gt; :=
--     SELECT SUM([check_sub_query].[check_evaluation])
--     FROM
--       ( SELECT
--           (CASE WHEN &lt;check_boolean_expression&gt; THEN 0 ELSE 1 END) AS [check_evaluation]
--         FROM
--           [with_alias]
--       ) AS [check_sub_query]
--   
--   &lt;mutation_output_select&gt; :=
--     SELECT
--       (SELECT COUNT(*) FROM [with_alias]) AS [affected_rows],
--       (select_from_returning) AS [returning]
--     FOR JSON PATH, INCLUDE_NULL_VALUES, WITHOUT_ARRAY_WRAPPER
--   
--   SELECT
--     (&lt;mutation_output_select&gt;) AS [mutation_response],
--     (&lt;check_constraint_select&gt;) AS [check_constraint_select]
--   </pre>
selectMutationOutputAndCheckCondition :: Text -> Select -> Expression -> Select


-- | This module defines the translation functions for insert and upsert
--   mutations.
module Hasura.Backends.MSSQL.FromIr.Insert
fromInsert :: AnnotatedInsert 'MSSQL Void Expression -> Insert

-- | Normalize a row by adding missing columns with <tt>DEFAULT</tt> value
--   and sort by column name to make sure all rows are consistent in column
--   values and order.
--   
--   Example: A table "author" is defined as:
--   
--   <pre>
--   CREATE TABLE author ([id] INTEGER NOT NULL PRIMARY KEY, name TEXT NOT NULL, age INTEGER)
--   </pre>
--   
--   Consider the following mutation:
--   
--   <pre>
--   mutation {
--     insert_author(
--       objects: [{id: 1, name: "Foo", age: 21}, {id: 2, name: "Bar"}]
--     ){
--       affected_rows
--     }
--   }
--   </pre>
--   
--   We consider <tt>DEFAULT</tt> value for <tt>age</tt> column which is
--   missing in second insert row.
--   
--   The corresponding <tt>INSERT</tt> statement looks like:
--   
--   <pre>
--   INSERT INTO author (id, name, age)
--     OUTPUT INSERTED.id
--     VALUES (1, 'Foo', 21), (2, 'Bar', DEFAULT)
--   </pre>
normalizeInsertRows :: HashMap (Column 'MSSQL) Expression -> [AnnotatedInsertRow 'MSSQL Expression] -> (HashSet (Column 'MSSQL), [HashMap (Column 'MSSQL) Expression])

-- | Construct a MERGE statement from AnnotatedInsert information. A MERGE
--   statement is responsible for actually inserting and/or updating the
--   data in the table.
toMerge :: TableName -> [AnnotatedInsertRow 'MSSQL Expression] -> [ColumnInfo 'MSSQL] -> IfMatched Expression -> FromIr Merge

-- | As part of an INSERT/UPSERT process, insert VALUES into a temporary
--   table. The content of the temporary table will later be inserted into
--   the original table using a MERGE statement.
--   
--   We insert the values into a temporary table first in order to replace
--   the missing fields with <tt>DEFAULT</tt> in
--   <tt>normalizeInsertRows</tt>, and we can't do that in a MERGE
--   statement directly.
toInsertValuesIntoTempTable :: TempTableName -> AnnotatedInsert 'MSSQL Void Expression -> InsertValuesIntoTempTable


-- | This module defines the translation function for delete mutations.
module Hasura.Backends.MSSQL.FromIr.Delete
fromDelete :: AnnDel 'MSSQL -> FromIr Delete


-- | Responsible for translating and building an MSSQL execution plan for
--   update mutations.
--   
--   This module is used by <a>Hasura.Backends.MSSQL.Instances.Execute</a>.
module Hasura.Backends.MSSQL.Execute.Update

-- | Executes an Update IR AST and return results as JSON.
executeUpdate :: (MonadError QErr m, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceConfig 'MSSQL -> AnnotatedUpdateG 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (ExceptT QErr IO EncJSON)

-- | Converts an Update IR AST to a transaction of three update sql
--   statements.
--   
--   A GraphQL update mutation does two things:
--   
--   <ol>
--   <li>Update rows in a table according to some predicate</li>
--   <li>(Potentially) returns the updated rows (including relationships)
--   as JSON</li>
--   </ol>
--   
--   In order to complete these 2 things we need 3 SQL statements:
--   
--   <ol>
--   <li><tt>SELECT INTO <a>temp_table</a> WHERE <a>false</a></tt> -
--   creates a temporary table with the same schema as the original table
--   in which we'll store the updated rows from the table we are
--   deleting</li>
--   <li><tt>UPDATE SET FROM with OUTPUT</tt> - updates the rows from the
--   table and inserts the updated rows to the temporary table from
--   (1)</li>
--   <li><tt>SELECT</tt> - constructs the <tt>returning</tt> query from the
--   temporary table, including relationships with other tables.</li>
--   </ol>
buildUpdateTx :: AnnotatedUpdate 'MSSQL -> StringifyNumbers -> QueryTagsComment -> TxET QErr IO EncJSON


-- | Responsible for translating and building an MSSQL execution plan for
--   delete mutations.
--   
--   This module is used by <a>Hasura.Backends.MSSQL.Instances.Execute</a>.
module Hasura.Backends.MSSQL.Execute.Insert

-- | Execute and insert/upsert mutation against MS SQL Server. See the
--   documentation for <a>buildInsertTx</a> to see how it's done.
executeInsert :: (MonadError QErr m, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceConfig 'MSSQL -> AnnotatedInsert 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (ExceptT QErr IO EncJSON)

-- | Translates an IR Insert/upsert mutation description to SQL and builds
--   a corresponding transaction to run against MS SQL Server.
--   
--   Execution of a MSSQL insert mutation broadly involves two steps.
--   
--   <pre>
--   insert_table(objects: [
--     {column1: value1, column2: value2},
--     {column1: value3, column2: value4}
--    ],
--    if_matched: {match_columns: [column1], update_columns: [column2]} # Optional field to enable upserting
--   ){
--     affected_rows
--     returning {
--       column1
--       column2
--     }
--   }
--   </pre>
--   
--   <h1>Step 1: Inserting rows into the table</h1>
--   
--   a. Create an empty temporary table with name #inserted to store
--   affected rows (for the response)
--   
--   <pre>
--   SELECT column1, column2 INTO #inserted FROM some_table WHERE (1 &lt;&gt; 1)
--   UNION ALL SELECT column1, column2 FROM some_table WHERE (1 &lt;&gt; 1);
--   </pre>
--   
--   b. If <tt>if_matched</tt> is found: Use MERGE statment to perform
--   upsert
--   
--   b.1 Use #values temporary table to store input object values
--   
--   <pre>
--   SELECT column1, column2 INTO #values FROM some_table WHERE (1 &lt;&gt; 1)
--   </pre>
--   
--   b.2 Insert input object values into the temporary table
--   
--   <pre>
--   INSERT INTO #values (column1, column2) VALUES (value1, value2), (value3, value4)
--   </pre>
--   
--   b.3 Generate an SQL Merge statement to perform either update or insert
--   (upsert) to the table
--   
--   <pre>
--   MERGE some_table AS [target]
--   USING (SELECT column1, column2 from #values) AS [source](column1, column2) ON ([target].column1 = [source].column1)
--   WHEN MATCHED THEN UPDATE SET [column2] = [source].[column2]
--   WHEN NOT MATCHED THEN INSERT (column1, column2) VALUES ([source].column1, [source].column2)
--   OUTPUT INSERTED.column1, INSERTED.column2 INTO #inserted(column1, column2)
--   </pre>
--   
--   <b>NOTE</b>: In <tt>MERGE</tt> statement, we use <tt>SELECT query from
--   a temporary table</tt> as source but not <tt>VALUES</tt> expression
--   because, we can't use <tt>DEFAULT</tt> expression (for missing columns
--   in <tt>objects</tt> field) in <tt>VALUES</tt> expression.
--   
--   <b>else</b>: Generate an SQL Insert statement from the GraphQL insert
--   mutation with OUTPUT expression to fill <tt>#inserted</tt> temporary
--   table with inserted rows
--   
--   <pre>
--   INSERT INTO some_table (column1, column2) OUTPUT INSERTED.column1, INSERTED.column2 INTO #inserted(column1, column2) VALUES (value1, value2), (value3, value4);
--   </pre>
--   
--   <h1>Step 2: Generation of the mutation response</h1>
--   
--   An SQL statement is generated and when executed it returns the
--   mutation selection set containing <tt>affected_rows</tt> and
--   <tt>returning</tt> field values. The statement is generated with
--   multiple sub select queries explained below:
--   
--   a. A SQL Select statement to fetch only inserted rows from temporary
--   table
--   
--   <pre>
--   &lt;table_select&gt; := SELECT * FROM #inserted
--   </pre>
--   
--   The above select statement is referred through a common table
--   expression - <tt>WITH [with_alias] AS (<a>table_select</a>)</tt>
--   
--   b. The <tt>affected_rows</tt> field value is obtained by using
--   <tt>COUNT</tt> aggregation and the <tt>returning</tt> field selection
--   set is translated to a SQL select statement using
--   <tt>mkSQLSelect</tt>.
--   
--   <pre>
--   &lt;mutation_output_select&gt; :=
--     SELECT (SELECT COUNT(*) FROM [with_alias]) AS [affected_rows], (select_from_returning) AS [returning]
--     FOR JSON PATH, INCLUDE_NULL_VALUES, WITHOUT_ARRAY_WRAPPER
--   </pre>
--   
--   c. Evaluate the check constraint using <tt>CASE</tt> expression. We
--   use <tt>SUM</tt> aggregation to check if any inserted row has failed
--   the check constraint.
--   
--   <pre>
--   &lt;check_constraint_select&gt; :=
--     SELECT SUM([check_sub_query].[check_evaluation])
--     FROM
--       ( SELECT
--           (CASE WHEN &lt;check_boolean_expression&gt; THEN 0 ELSE 1 END) AS [check_evaluation]
--         FROM
--           [with_alias]
--       ) AS [check_sub_query]
--   </pre>
--   
--   d. The final select statement look like
--   
--   <pre>
--   WITH "with_alias" AS (&lt;table_select&gt;)
--   SELECT (&lt;mutation_output_select&gt;) AS [mutation_response], (&lt;check_constraint_select&gt;) AS [check_constraint_select]
--   </pre>
--   
--   When executed, the above statement returns a single row with mutation
--   response as a string value and check constraint result as an integer
--   value.
buildInsertTx :: TableName -> Text -> StringifyNumbers -> AnnotatedInsert 'MSSQL Void Expression -> QueryTagsComment -> TxET QErr IO EncJSON

-- | Translates an IR IfMatched clause to SQL and builds a corresponding
--   transaction to run against MS SQL Server.
--   
--   We do this in 2 steps:
--   
--   <ol>
--   <li>Create a temporary table called <tt>#values</tt> which will hold
--   the values the user want to insert, and insert the values into it</li>
--   <li>Build an run a <tt>MERGE</tt> statement to either insert or upsert
--   the values from the temporary table <tt>#values</tt> into the original
--   table, and output the affected rows into another temporary table
--   called <tt>#inserted</tt> which will be used to build a "response" for
--   the user.</li>
--   </ol>
--   
--   Should be used as part of a bigger transaction in
--   <a>buildInsertTx</a>.
buildUpsertTx :: TableName -> AnnotatedInsert 'MSSQL Void Expression -> IfMatched Expression -> QueryTagsComment -> TxET QErr IO ()

-- | Builds a response to the user using the values in the temporary table
--   named #inserted.
buildInsertResponseTx :: StringifyNumbers -> Text -> AnnotatedInsert 'MSSQL Void Expression -> QueryTagsComment -> TxET QErr IO (Text, Int)


-- | Responsible for translating and building an MSSQL execution plan for
--   delete mutations.
--   
--   This module is used by <a>Hasura.Backends.MSSQL.Instances.Execute</a>.
module Hasura.Backends.MSSQL.Execute.Delete

-- | Executes a Delete IR AST and return results as JSON.
executeDelete :: (MonadError QErr m, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceConfig 'MSSQL -> AnnDelG 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (ExceptT QErr IO EncJSON)

-- | Converts a Delete IR AST to a transaction of three delete sql
--   statements.
--   
--   A GraphQL delete mutation does two things:
--   
--   <ol>
--   <li>Deletes rows in a table according to some predicate</li>
--   <li>(Potentially) returns the deleted rows (including relationships)
--   as JSON</li>
--   </ol>
--   
--   In order to complete these 2 things we need 3 SQL statements:
--   
--   <ol>
--   <li><tt>SELECT INTO <a>temp_table</a> WHERE <a>false</a></tt> -
--   creates a temporary table with the same schema as the original table
--   in which we'll store the deleted rows from the table we are
--   deleting</li>
--   <li><tt>DELETE FROM with OUTPUT</tt> - deletes the rows from the table
--   and inserts the deleted rows to the temporary table from (1)</li>
--   <li><tt>SELECT</tt> - constructs the <tt>returning</tt> query from the
--   temporary table, including relationships with other tables.</li>
--   </ol>
buildDeleteTx :: AnnDel 'MSSQL -> StringifyNumbers -> QueryTagsComment -> TxET QErr IO EncJSON

module Hasura.GraphQL.Execute.RemoteJoin.Types

-- | A JoinTree represents the set of operations that need to be executed
--   to enrich the response of a source with data from remote sources. A
--   tree structure is used to capture the locations in the response where
--   the join has to happpen as it offers an efficient traversal mechanism.
--   
--   For a query such as this:
--   
--   { city { name code # weather is a remote relationship weather {
--   forecast } state { # weather is a remote relationship weather {
--   forecast } } } }
--   
--   the join tree would look like [ , ("weather", Leaf
--   RemoteJoinInfoOfWeather), , ("state", [ ("weather", Leaf
--   RemoteJoinInfoOfWeather) ]) ]
--   
--   Note that the same join tree will be emitted even if <tt>city</tt> is
--   of type '[City]' and <a>state</a> is of type [State], we currently do
--   not capture any information if any of the fields in the path expect
--   json arrays. It is similar in spirit to a GraphQL selection set in
--   this regard.
--   
--   This structure is somewhat similar to a prefix tree such as
--   <a>Trie</a>, but has two additional guarantees: - a <a>JoinTree</a> is
--   never empty, - there cannot exist a pair of values for which one's
--   prefix key is a subset of the other: every value is effectively a
--   leaf.
newtype JoinTree a
JoinTree :: NEHashMap QualifiedFieldName (JoinNode a) -> JoinTree a
[unJoinTree] :: JoinTree a -> NEHashMap QualifiedFieldName (JoinNode a)

-- | A field name annotated with an optional type name.
--   
--   To deal with ambiguous join paths, such as those that emerge from
--   GraphQL interfaces or GraphQL unions, we do not just keep track of the
--   fields' name, but also, optionally, of their type. Whenever a
--   selection set is deemed ambiguous, we insert a reserved field in the
--   query to retrieve the typename, <tt>__hasura_internal_typename</tt>;
--   when traversing the join tree, if that key is present, then we use it
--   alongside the field name when querying the join tree (see
--   <tt>traverseObject</tt> in the <tt>Join</tt> module).
--   
--   We use <a>Text</a> for the representation of the field name instead of
--   <a>FieldName</a>, for simplicity: the join tree is only meant to be
--   queried using the values we get in the reponse, which will be
--   unrestricted text.
data QualifiedFieldName
QualifiedFieldName :: Maybe Text -> Text -> QualifiedFieldName
[_qfTypeName] :: QualifiedFieldName -> Maybe Text
[_qfFieldName] :: QualifiedFieldName -> Text

-- | Each leaf associates a mapping from typename to actual join info. This
--   allows to disambiguate between different remote joins with the same
--   name in a given selection set, which might happen with union or
--   interface fragments.
data JoinNode a
Leaf :: a -> JoinNode a
Tree :: JoinTree a -> JoinNode a
type RemoteJoins = JoinTree RemoteJoin

-- | Collect all the remote joins to a remote schema from a join tree.
getRemoteSchemaJoins :: RemoteJoins -> [RemoteSchemaJoin]

-- | An individual join entry point in a <a>JoinTree</a>.
--   
--   Either a join against a source, or against a remote schema. In either
--   case, the constructor will contain that particular join's information
--   (a <a>RemoteSourceJoin</a> or <a>RemoteSchemaJoin</a> respectively)
--   and, recursively, the set of follow-up <a>RemoteJoins</a> from that
--   target, if any.
data RemoteJoin
RemoteJoinSource :: AnyBackend RemoteSourceJoin -> Maybe RemoteJoins -> RemoteJoin
RemoteJoinRemoteSchema :: RemoteSchemaJoin -> Maybe RemoteJoins -> RemoteJoin

-- | A unique id that gets assigned to each <a>RemoteJoin</a> (this is to
--   avoid the requirement of Ord/Hashable implementation for RemoteJoin)
type JoinCallId = Int

-- | Disambiguates between <a>FieldName</a>s which are provided as part of
--   the GraphQL selection provided by the user (i.e. <a>JCSelected</a>)
--   and those which we need to retreive data but which are not expressly
--   requested (i.e. <a>JCPhantom</a>).
--   
--   After processing the remote join, we remove all phantom
--   <a>FieldName</a>s and only return those which fall under the
--   <a>JCSelected</a> branch of this type.
data JoinColumnAlias

-- | This fieldname is already part of the response.
JCSelected :: !FieldName -> JoinColumnAlias

-- | This is explicitly added for the join.
--   
--   Such keys will have to be removed from the response eventually.
JCPhantom :: !FieldName -> JoinColumnAlias

-- | Extracts the field name from the <a>JoinColumnAlias</a>, regardless of
--   whether the field is requested by the user of a "phantom" field.
getAliasFieldName :: JoinColumnAlias -> FieldName

-- | Extracts the list of phantom field names out of a given
--   <a>RemoteJoin</a>, i.e. the name of the fields that must be part of
--   the query but were not requested by the user.
getPhantomFields :: RemoteJoin -> [FieldName]

-- | Extracts an abstracted field mapping for a particular
--   <a>RemoteJoin</a>, using a common representation.
--   
--   The RHS of the mapping uses <a>JoinColumnAlias</a> instead of
--   <a>FieldName</a> to differentiate between selected fields and phantom
--   fields (see <a>JoinColumnAlias</a>).
getJoinColumnMapping :: RemoteJoin -> HashMap FieldName JoinColumnAlias

-- | A <a>RemoteSourceJoin</a> contains all the contextual information
--   required for the execution of a join against a source, translated from
--   the IR's representation of a selection (see <tt>AnnFieldG</tt>).
data RemoteSourceJoin b
RemoteSourceJoin :: !SourceName -> !SourceConfig b -> !SourceRelationshipSelection b Void UnpreparedValue -> !HashMap FieldName (JoinColumnAlias, (Column b, ScalarType b)) -> RemoteSourceJoin b
[_rsjSource] :: RemoteSourceJoin b -> !SourceName
[_rsjSourceConfig] :: RemoteSourceJoin b -> !SourceConfig b
[_rsjRelationship] :: RemoteSourceJoin b -> !SourceRelationshipSelection b Void UnpreparedValue
[_rsjJoinColumns] :: RemoteSourceJoin b -> !HashMap FieldName (JoinColumnAlias, (Column b, ScalarType b))

-- | A <a>RemoteSchemaJoin</a> contains all the contextual information
--   required for the execution of a join against a remote schema,
--   translated from the IR's representation of a selection (see
--   <tt>AnnFieldG</tt>).
data RemoteSchemaJoin
RemoteSchemaJoin :: !HashMap Name (InputValue RemoteSchemaVariable) -> !ResultCustomizer -> !SelectionSet Void RemoteSchemaVariable -> !HashMap FieldName JoinColumnAlias -> !NonEmpty FieldCall -> !RemoteSchemaInfo -> RemoteSchemaJoin

-- | User-provided arguments with variables.
[_rsjArgs] :: RemoteSchemaJoin -> !HashMap Name (InputValue RemoteSchemaVariable)

-- | Customizer for JSON result from the remote server.
[_rsjResultCustomizer] :: RemoteSchemaJoin -> !ResultCustomizer

-- | User-provided selection set of remote field.
[_rsjSelSet] :: RemoteSchemaJoin -> !SelectionSet Void RemoteSchemaVariable

-- | A map of the join column to its alias in the response
[_rsjJoinColumnAliases] :: RemoteSchemaJoin -> !HashMap FieldName JoinColumnAlias

-- | Remote server fields.
[_rsjFieldCall] :: RemoteSchemaJoin -> !NonEmpty FieldCall

-- | The remote schema server info.
[_rsjRemoteSchema] :: RemoteSchemaJoin -> !RemoteSchemaInfo

-- | A map of fieldname to values extracted from each LHS row/object
--   
--   For example, if a remote relationship <tt>weather</tt> on
--   <tt>city</tt> table is defined as follows: city.weather =
--   get_weather(city: city.code, cityState: city.state_code) a join
--   argument for this join would have the values of columns <tt>code</tt>
--   and <tt>state_code</tt> for each <tt>city</tt> row that participates
--   in the join
newtype JoinArgument
JoinArgument :: HashMap FieldName Value -> JoinArgument
[unJoinArgument] :: JoinArgument -> HashMap FieldName Value

-- | A unique id assigned to each join argument
type JoinArgumentId = Int
data JoinArguments
JoinArguments :: !RemoteJoin -> !HashMap JoinArgument JoinArgumentId -> !FieldName -> JoinArguments

-- | The <a>RemoteJoin</a> associated with the join arguments within this
--   structure.
[_jalJoin] :: JoinArguments -> !RemoteJoin

-- | Arguments for which we must fetch a response from the remote, along
--   with the identifiers that are used to stitch the final response
--   together.
--   
--   NOTE: <a>HashMap</a> is used to deduplicate multiple
--   <a>JoinArgument</a>s so that we avoid fetching more data from a remote
--   than is necessary (i.e. in the case of duplicate arguments).
[_jalArguments] :: JoinArguments -> !HashMap JoinArgument JoinArgumentId

-- | The <a>FieldName</a> associated with the "replacement token" for this
--   join argument.
--   
--   NOTE: We need this for query logging; ideally we would use the full
--   path for the GraphQL query associated with this remote join, but we
--   don't have access to that here so this is the next best thing to do.
[_jalFieldName] :: JoinArguments -> !FieldName
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance GHC.Show.Show Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance GHC.Base.Semigroup (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance GHC.Generics.Generic (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance Data.Traversable.Traversable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree
instance Data.Foldable.Foldable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree
instance GHC.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode a)
instance Data.Traversable.Traversable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode
instance GHC.Generics.Generic (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode a)
instance GHC.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode
instance Data.Foldable.Foldable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode a)
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance GHC.Show.Show Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance GHC.Generics.Generic (Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSourceJoin b)
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSchemaJoin
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteJoin
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteJoin
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance GHC.Show.Show Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArguments
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.SourceRelationshipSelection b Data.Void.Void Hasura.RQL.IR.Value.UnpreparedValue), GHC.Show.Show (Hasura.RQL.Types.Backend.SourceConfig b)) => GHC.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSourceJoin b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.SourceRelationshipSelection b Data.Void.Void Hasura.RQL.IR.Value.UnpreparedValue), GHC.Classes.Eq (Hasura.RQL.Types.Backend.SourceConfig b)) => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSourceJoin b)
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSchemaJoin

module Hasura.GraphQL.Execute.RemoteJoin.Collect

-- | Collects remote joins from the a <a>QueryDB</a> if any, and transforms
--   the selection to add new join fields where those occured.
--   
--   Returns the transformed selection set, in which remote fields have
--   been inserted, and for which the <tt>r</tt> type is now <a>Void</a>.
getRemoteJoinsQueryDB :: Backend b => QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> (QueryDB b Void (UnpreparedValue b), Maybe RemoteJoins)

-- | Collects remote joins from the a <a>MutationDB</a> if any, and
--   transforms the selection to add new join fields where those occured.
--   
--   Returns the transformed selection set, in which remote fields have
--   been inserted, and for which the <tt>r</tt> type is now <a>Void</a>.
getRemoteJoinsMutationDB :: Backend b => MutationDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> (MutationDB b Void (UnpreparedValue b), Maybe RemoteJoins)
getRemoteJoinsActionQuery :: ActionQuery (RemoteRelationshipField UnpreparedValue) -> (ActionQuery Void, Maybe RemoteJoins)
getRemoteJoinsActionMutation :: ActionMutation (RemoteRelationshipField UnpreparedValue) -> (ActionMutation Void, Maybe RemoteJoins)
getRemoteJoinsSourceRelation :: Backend b => SourceRelationshipSelection b (RemoteRelationshipField UnpreparedValue) UnpreparedValue -> (SourceRelationshipSelection b Void UnpreparedValue, Maybe RemoteJoins)
getRemoteJoinsGraphQLField :: GraphQLField (RemoteRelationshipField UnpreparedValue) var -> (GraphQLField Void var, Maybe RemoteJoins)
getRemoteJoinsGraphQLSelectionSet :: SelectionSet (RemoteRelationshipField UnpreparedValue) var -> (SelectionSet Void var, Maybe RemoteJoins)

-- | A writer monad used to collect together all remote joins appearing in
--   some data structure.
--   
--   In the functions below, the <a>withField</a> function is used to track
--   the context of the path from the root of the current selection set.
--   
--   It is important that we work bottom-up, and do not <a>collect</a>
--   duplicate field names at any level, because the <a>Semigroup</a>
--   instance for <a>RemoteJoins</a> does not allow for these duplicates.
newtype Collector a
Collector :: (a, Maybe RemoteJoins) -> Collector a
[runCollector] :: Collector a -> (a, Maybe RemoteJoins)

-- | Collect some remote joins appearing at the given field names in the
--   current context.
collect :: NEHashMap QualifiedFieldName RemoteJoin -> Collector ()

-- | Keep track of the given field name in the current path from the root
--   of the selection set.
withField :: Maybe Text -> Text -> Collector a -> Collector a

-- | Traverse a list of fields, while applying <a>withField</a> to keep
--   track of the path within the AST. This function assumes that no type
--   name is required for the <a>QualifiedFieldName</a> and uses
--   <a>Nothing</a>.
traverseFields :: (a -> Collector b) -> Fields a -> Collector (Fields b)
transformAsyncFields :: AsyncActionQueryFieldG (RemoteRelationshipField UnpreparedValue) -> Collector (AsyncActionQueryFieldG Void)
transformMutationOutput :: Backend b => MutationOutputG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> Collector (MutationOutputG b Void (UnpreparedValue b))
transformSyncAction :: AnnActionExecution (RemoteRelationshipField UnpreparedValue) -> Collector (AnnActionExecution Void)
transformSelect :: Backend b => AnnSimpleSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> Collector (AnnSimpleSelectG b Void (UnpreparedValue b))
transformStreamSelect :: Backend b => AnnSimpleStreamSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> Collector (AnnSimpleStreamSelectG b Void (UnpreparedValue b))
transformAggregateSelect :: Backend b => AnnAggregateSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> Collector (AnnAggregateSelectG b Void (UnpreparedValue b))
transformConnectionSelect :: forall b. Backend b => ConnectionSelect b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> Collector (ConnectionSelect b Void (UnpreparedValue b))
transformObjectSelect :: Backend b => AnnObjectSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> Collector (AnnObjectSelectG b Void (UnpreparedValue b))
transformGraphQLField :: GraphQLField (RemoteRelationshipField UnpreparedValue) var -> Collector (GraphQLField Void var)
transformGraphQLSelectionSet :: SelectionSet (RemoteRelationshipField UnpreparedValue) var -> Collector (SelectionSet Void var)

-- | Transforms a source selection set.
--   
--   This function takes an <a>AnnFieldsG</a>, which corresponds to a
--   selection of fields on a source, and extracts remote joins: for every
--   field we encounter that maps to a remote destination (either another
--   source or a remote schema), we replace it with a phantom field and
--   <a>collect</a> the corresponding <a>RemoteJoin</a>.
transformAnnFields :: forall src. Backend src => AnnFieldsG src (RemoteRelationshipField UnpreparedValue) (UnpreparedValue src) -> Collector (AnnFieldsG src Void (UnpreparedValue src))

-- | Transforms an action's selection set.
--   
--   This function takes an <a>ActionFieldsG</a>, which corresponds to a
--   selection of fields on the result of an action, and extracts remote
--   joins: for every field we encounter that maps to a remote destination
--   (either a source or a remote schema), we replace it with a phantom
--   field and <a>collect</a> the corresponding <a>RemoteJoin</a>.
transformActionFields :: ActionFieldsG (RemoteRelationshipField UnpreparedValue) -> Collector ActionFields

-- | Transforms a GraphQL selection set.
--   
--   This function takes an <a>SelectionSet</a>, which corresponds to a
--   selection of fields on a remote GraphQL schema, and extracts remote
--   joins: for every field we encounter that maps to a remote destination
--   (either a source or another remote schema), we replace it with a
--   phantom field and <a>collect</a> the corresponding <a>RemoteJoin</a>.
transformObjectSelectionSet :: Maybe Name -> ObjectSelectionSet (RemoteRelationshipField UnpreparedValue) var -> Collector (ObjectSelectionSet Void var)

-- | Converts a remote relationship field into a <a>RemoteJoin</a> that the
--   execution engine understands.
createRemoteJoin :: HashMap FieldName JoinColumnAlias -> RemoteRelationshipField UnpreparedValue -> RemoteJoin

-- | Constructs a <a>JoinColumnAlias</a> for a given field in a selection
--   set.
--   
--   If the field was already requested, we leave it unchanged, to avoid
--   double-fetching the same information. However, if this field is a
--   "phantom" field, that we only add for the purpose of fetching a join
--   key, we rename it in a way that is guaranteed to avoid conflicts.
--   
--   NOTE: if the <tt>fieldName</tt> argument is a valid GraphQL name, then
--   the constructed alias MUST also be a valid GraphQL name.
getJoinColumnAlias :: (Eq field, Hashable field) => FieldName -> field -> HashMap field FieldName -> [FieldName] -> JoinColumnAlias

-- | Get the fields targeted by some <tt>Traversal</tt> for an arbitrary
--   list of tuples, discarding any elements whose fields cannot be focused
--   upon.
getFields :: Traversal' super sub -> [(any, super)] -> [(any, sub)]
instance Control.Monad.Writer.Class.MonadWriter (GHC.Maybe.Maybe Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteJoins) Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector
instance GHC.Base.Monad Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector
instance GHC.Base.Applicative Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector
instance GHC.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector

module Hasura.GraphQL.Execute.Action.Types
newtype ActionExecution
ActionExecution :: (forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m) => m (EncJSON, ResponseHeaders)) -> ActionExecution
[unActionExecution] :: ActionExecution -> forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m) => m (EncJSON, ResponseHeaders)
data AsyncActionQuerySourceExecution v
AsyncActionQuerySourceExecution :: !SourceName -> !JsonAggSelect -> !ActionLogResponse -> AnnSimpleSelectG ('Postgres 'Vanilla) Void v -> AsyncActionQuerySourceExecution v
[_aaqseSource] :: AsyncActionQuerySourceExecution v -> !SourceName
[_aaqseJsonAggSelect] :: AsyncActionQuerySourceExecution v -> !JsonAggSelect
[_aaqseSelectBuilder] :: AsyncActionQuerySourceExecution v -> !ActionLogResponse -> AnnSimpleSelectG ('Postgres 'Vanilla) Void v
data AsyncActionQueryExecution v

-- | Async actions associated with no relationships.
AAQENoRelationships :: !ActionLogResponse -> Either QErr EncJSON -> AsyncActionQueryExecution v

-- | Async actions with relationships defined to Postgres (as of now, we
--   may have support for other backends as well in further iterations)
--   tables.
AAQEOnSourceDB :: !SourceConfig ('Postgres 'Vanilla) -> !AsyncActionQuerySourceExecution v -> AsyncActionQueryExecution v

-- | A plan to execute async action query
data AsyncActionQueryExecutionPlan
AsyncActionQueryExecutionPlan :: !ActionId -> !AsyncActionQueryExecution (UnpreparedValue ('Postgres 'Vanilla)) -> AsyncActionQueryExecutionPlan
[_aaqepId] :: AsyncActionQueryExecutionPlan -> !ActionId
[_aaqepExecution] :: AsyncActionQueryExecutionPlan -> !AsyncActionQueryExecution (UnpreparedValue ('Postgres 'Vanilla))
data ActionExecutionPlan
AEPSync :: !ActionExecution -> ActionExecutionPlan
AEPAsyncQuery :: !AsyncActionQueryExecutionPlan -> ActionExecutionPlan
AEPAsyncMutation :: !ActionId -> ActionExecutionPlan
newtype ActionContext
ActionContext :: ActionName -> ActionContext
[_acName] :: ActionContext -> ActionName
data ActionWebhookPayload
ActionWebhookPayload :: !ActionContext -> !SessionVariables -> !Value -> !Maybe GQLQueryText -> ActionWebhookPayload
[_awpAction] :: ActionWebhookPayload -> !ActionContext
[_awpSessionVariables] :: ActionWebhookPayload -> !SessionVariables
[_awpInput] :: ActionWebhookPayload -> !Value
[_awpRequestQuery] :: ActionWebhookPayload -> !Maybe GQLQueryText
data ActionWebhookErrorResponse
ActionWebhookErrorResponse :: !Text -> !Maybe Text -> !Maybe Value -> ActionWebhookErrorResponse
[_awerMessage] :: ActionWebhookErrorResponse -> !Text
[_awerCode] :: ActionWebhookErrorResponse -> !Maybe Text
[_awerExtensions] :: ActionWebhookErrorResponse -> !Maybe Value
type ActionWebhookResponse = Value
data ActionRequestInfo
ActionRequestInfo :: !Text -> !Value -> ![HeaderConf] -> !Maybe Request -> ActionRequestInfo
[_areqiUrl] :: ActionRequestInfo -> !Text
[_areqiBody] :: ActionRequestInfo -> !Value
[_areqiHeaders] :: ActionRequestInfo -> ![HeaderConf]
[_areqiTransformedRequest] :: ActionRequestInfo -> !Maybe Request
data ActionResponseInfo
ActionResponseInfo :: !Int -> !Value -> ![HeaderConf] -> ActionResponseInfo
[_aresiStatus] :: ActionResponseInfo -> !Int
[_aresiBody] :: ActionResponseInfo -> !Value
[_aresiHeaders] :: ActionResponseInfo -> ![HeaderConf]
data ActionInternalError
ActionInternalError :: !Value -> !ActionRequestInfo -> !Maybe ActionResponseInfo -> ActionInternalError
[_aieError] :: ActionInternalError -> !Value
[_aieRequest] :: ActionInternalError -> !ActionRequestInfo
[_aieResponse] :: ActionInternalError -> !Maybe ActionResponseInfo
data ActionHandlerLog
ActionHandlerLog :: !Request -> !Maybe Request -> !Int64 -> !Maybe Int64 -> !Int64 -> !ActionName -> ActionHandlerLog
[_ahlRequest] :: ActionHandlerLog -> !Request
[_ahlRequestTrans] :: ActionHandlerLog -> !Maybe Request
[_ahlRequestSize] :: ActionHandlerLog -> !Int64
[_ahlTransformedRequestSize] :: ActionHandlerLog -> !Maybe Int64
[_ahlResponseSize] :: ActionHandlerLog -> !Int64
[_ahlActionName] :: ActionHandlerLog -> !ActionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionHandlerLog
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Execute.Action.Types.ActionHandlerLog Hasura.Logging.Hasura
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionHandlerLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionInternalError
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionInternalError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionRequestInfo
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionRequestInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Action.Types.ActionContext
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionContext
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionContext


-- | Tools for generating fields for Apollo federation
module Hasura.GraphQL.ApolloFederation

-- | Internal parser function for entities field
data ApolloFederationParserFunction n
ApolloFederationParserFunction :: (ApolloFederationAnyType -> n (QueryRootField UnpreparedValue)) -> ApolloFederationParserFunction n
[aafuGetRootField] :: ApolloFederationParserFunction n -> ApolloFederationAnyType -> n (QueryRootField UnpreparedValue)

-- | Haskell representation of _Any scalar
data ApolloFederationAnyType
ApolloFederationAnyType :: Name -> Object -> ApolloFederationAnyType
[afTypename] :: ApolloFederationAnyType -> Name
[afPKValues] :: ApolloFederationAnyType -> Object

-- | Parser for _Any scalar
anyParser :: Parser origin 'Both Parse ApolloFederationAnyType
convertToApolloFedParserFunc :: (Monad n, MonadParse n, Backend b) => SourceInfo b -> TableInfo b -> TablePermG b (UnpreparedValue b) -> StringifyNumbers -> Maybe NamingCase -> NESeq (ColumnInfo b) -> Parser 'Output n (AnnotatedFields b) -> Parser 'Output n (ApolloFederationParserFunction n)
modifyApolloFedParserFunc :: (MonadParse n, Backend b) => SourceInfo b -> TableInfo b -> TablePermG b (UnpreparedValue b) -> StringifyNumbers -> Maybe NamingCase -> NESeq (ColumnInfo b) -> AnnotatedFields b -> ApolloFederationParserFunction n

-- | Creates <tt>_service</tt> <tt>FieldParser</tt> using the schema
--   introspection. This will allow us to process the following query:
--   
--   <pre>
--   query {
--     _service {
--       sdl
--     }
--   }
--   </pre>
mkServiceField :: FieldParser Parse (SchemaIntrospection -> QueryRootField UnpreparedValue)
apolloRootFields :: HashSet ExperimentalFeature -> [(Name, Parser 'Output Parse (ApolloFederationParserFunction Parse))] -> [FieldParser Parse (SchemaIntrospection -> QueryRootField UnpreparedValue)]

-- | Generate sdl from the schema introspection
generateSDL :: SchemaIntrospection -> Text

-- | Filter out schema components from sdl which are not required by apollo
--   federation and wraps it in <tt>TypeSystemDefinition</tt>
filterAndWrapTypeSystemDefinition :: TypeDefinition [Name] InputValueDefinition -> Maybe TypeSystemDefinition

-- | Creates <tt>_entities</tt> <tt>FieldParser</tt> using <a>Parser</a>s
--   for Entity union, schema introspection and a list of all query
--   <a>FieldParser</a>. This will allow us to process the following query:
--   
--   <pre>
--   query ($representations: [_Any!]!) {
--     _entities(representations: $representations) {
--       ... on SomeType {
--         foo
--         bar
--       }
--     }
--   }
--   </pre>
mkEntityUnionFieldParser :: [(Name, Parser 'Output Parse (ApolloFederationParserFunction Parse))] -> FieldParser Parse (QueryRootField UnpreparedValue)

-- | concatenates multiple fields
concatQueryRootFields :: [QueryRootField UnpreparedValue] -> QueryRootField UnpreparedValue
instance GHC.Show.Show Hasura.GraphQL.ApolloFederation.ApolloFederationAnyType


-- | This module defines the type class <a>BackendSchema</a> and auxiliary
--   types.
--   
--   <a>BackendSchema</a> represents the part of the interface that a
--   backend driver presents to the GraphQL Engine core that is responsible
--   for generating the backend's Schema Parsers.
--   
--   The Schema Parsers recognise (and reflect) the schema that a backend
--   exposes.
--   
--   The <a>BackendSchema</a> methods are used by <a>buildGQLContext</a>,
--   which is the core's entrypoint to schema generation.
--   
--   Many of the <a>BackendSchema</a> methods will have default
--   implementations that a backend driver may use. These may be found
--   (chiefly) in the modules:
--   
--   <ul>
--   <li>The module <a>Hasura.GraphQL.Schema.Build</a>, commonly qualified
--   <tt>GSB</tt></li>
--   <li><a>Hasura.GraphQL.Schema.Select</a>, commonly qualified
--   <tt>GSS</tt></li>
--   <li><a>Hasura.GraphQL.Schema.BoolExp</a></li>
--   </ul>
--   
--   For more information see:
--   
--   <ul>
--   <li><a>Technical overview of Schema Generation</a></li>
--   <li>The type <a>Parser</a>, and associated source code notes in the
--   same folder (not exposed with Haddock unfortunately)</li>
--   </ul>
module Hasura.GraphQL.Schema.Backend

-- | Bag of constraints available to the methods of <tt>BackendSchema</tt>.
--   
--   Note that <tt>BackendSchema b</tt> is itself part of this, so a
--   methods may also call other methods. This might seem trivial, but it
--   can be easy to miss when the functions used to implement a class
--   instance are defined in multiple modules.
type MonadBuildSchema b r m n = (BackendSchema b, MonadBuildSourceSchema r m n)

-- | This type class is responsible for generating the schema of a backend.
--   Its methods are called by the common core that orchestrates the
--   various backend drivers.
--   
--   Its purpose in life is to make it convenient to express the GraphQL
--   schema we want to expose for the backends that we support. This means
--   balancing the desire to have consistency with the desire to
--   differentiate the schema of a backend.
--   
--   This means that it is expected to evolve over time as we add new
--   backends, and that you have the license to change it: Whatever form it
--   currently takes only reflects status quo current implementation.
--   
--   The module <a>Hasura.GraphQL.Schema.Build</a> (commonly qualified as
--   <tt>GSB</tt>) provides standard building blocks for implementing many
--   methods of this class. And as such, these two modules are very much
--   expected to evolve in tandem.
--   
--   See <a>Note BackendSchema modelling principles</a>.
class Backend b => BackendSchema (b :: BackendType)
buildTableQueryAndSubscriptionFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> SourceInfo b -> TableName b -> TableInfo b -> GQLNameIdentifier -> m ([FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], Maybe (Name, Parser 'Output n (ApolloFederationParserFunction n)))
buildTableStreamingSubscriptionFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> SourceInfo b -> TableName b -> TableInfo b -> GQLNameIdentifier -> m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableRelayQueryFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> SourceInfo b -> TableName b -> TableInfo b -> GQLNameIdentifier -> NESeq (ColumnInfo b) -> m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableInsertMutationFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> Scenario -> SourceInfo b -> TableName b -> TableInfo b -> GQLNameIdentifier -> m [FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]

-- | This method is responsible for building the GraphQL Schema for
--   mutations backed by <tt>UPDATE</tt> statements on some table, as
--   described in
--   <tt><a>https://hasura.io/docs/latest/graphql/core/databases/postgres/mutations/update.html</a></tt>.
--   
--   The suggested way to implement this is using building blocks in GSB,
--   c.f. its namesake <tt>GSB.</tt><a>buildTableUpdateMutationFields</a>.
buildTableUpdateMutationFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> Scenario -> SourceInfo b -> TableName b -> TableInfo b -> GQLNameIdentifier -> m [FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableDeleteMutationFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> Scenario -> SourceInfo b -> TableName b -> TableInfo b -> GQLNameIdentifier -> m [FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildFunctionQueryFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> SourceInfo b -> FunctionName b -> FunctionInfo b -> TableName b -> m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildFunctionRelayQueryFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> SourceInfo b -> FunctionName b -> FunctionInfo b -> TableName b -> NESeq (ColumnInfo b) -> m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildFunctionMutationFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> SourceInfo b -> FunctionName b -> FunctionInfo b -> TableName b -> m [FieldParser n (MutationDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]

-- | Make a parser for relationships. Default implementaton elides
--   relationships altogether.
mkRelationshipParser :: (BackendSchema b, MonadBuildSchema b r m n) => SourceInfo b -> RelInfo b -> m (Maybe (InputFieldsParser n (Maybe (AnnotatedInsertField b (UnpreparedValue b)))))
relayExtension :: BackendSchema b => Maybe (XRelay b)
nodesAggExtension :: BackendSchema b => Maybe (XNodesAgg b)
streamSubscriptionExtension :: BackendSchema b => Maybe (XStreamingSubscription b)
columnParser :: (BackendSchema b, MonadParse n, MonadError QErr m, MonadReader r m, Has MkTypename r, Has NamingCase r) => ColumnType b -> Nullability -> m (Parser 'Both n (ValueWithOrigin (ColumnValue b)))

-- | Parser for arguments on scalar fields in a selection set
scalarSelectionArgumentsParser :: (BackendSchema b, MonadParse n) => ColumnType b -> InputFieldsParser n (Maybe (ScalarSelectionArguments b))
orderByOperators :: BackendSchema b => SourceInfo b -> NamingCase -> (Name, NonEmpty (Definition EnumValueInfo, (BasicOrderType b, NullsOrderType b)))
comparisonExps :: (BackendSchema b, MonadBuildSchema b r m n) => ColumnType b -> m (Parser 'Input n [ComparisonExp b])

-- | The input fields parser, for "count" aggregate field, yielding a
--   function which generates @'CountType b' from optional "distinct" field
--   value
countTypeInput :: (BackendSchema b, MonadParse n) => Maybe (Parser 'Both n (Column b)) -> InputFieldsParser n (CountDistinct -> CountType b)
aggregateOrderByCountType :: BackendSchema b => ScalarType b

-- | Computed field parser
computedField :: (BackendSchema b, MonadBuildSchema b r m n) => SourceInfo b -> ComputedFieldInfo b -> TableName b -> TableInfo b -> m (Maybe (FieldParser n (AnnotatedField b)))

-- | The public interface for the schema of table queries exposed by a
--   backend.
--   
--   Remote Schemas and the Relay schema are the chief backend-agnostic
--   clients of this typeclass.
--   
--   Some of schema building components in the <a>Hasura.GraphQL.Schema</a>
--   namespace also make use of these methods, ensuring backends expose a
--   consistent schema regardless of the mode it's referenced.
--   
--   Default implementations exist for all of these in <a>Select</a>.
class Backend b => BackendTableSelectSchema (b :: BackendType)
tableArguments :: (BackendTableSelectSchema b, MonadBuildSchemaBase r m n) => SourceInfo b -> TableInfo b -> m (InputFieldsParser n (SelectArgsG b (UnpreparedValue b)))
tableSelectionSet :: (BackendTableSelectSchema b, MonadBuildSchemaBase r m n) => SourceInfo b -> TableInfo b -> m (Maybe (Parser 'Output n (AnnotatedFields b)))
selectTable :: (BackendTableSelectSchema b, MonadBuildSchemaBase r m n) => SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (SelectExp b)))
selectTableAggregate :: (BackendTableSelectSchema b, MonadBuildSchemaBase r m n) => SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (AggSelectExp b)))
type ComparisonExp b = OpExpG b (UnpreparedValue b)


-- | Helper functions for generating the schema of database tables
module Hasura.GraphQL.Schema.Table

-- | Helper function to get the table GraphQL name. A table may have a
--   custom name configured with it. When the custom name exists, the
--   GraphQL nodes that are generated according to the custom name. For
--   example: Let's say, we have a table called `users address`, the name
--   of the table is not GraphQL compliant so we configure the table with a
--   GraphQL compliant name, say <tt>users_address</tt> The generated
--   top-level nodes of this table will be like <tt>users_address</tt>,
--   <tt>insert_users_address</tt> etc
getTableGQLName :: forall b m. (Backend b, MonadError QErr m) => TableInfo b -> m Name

-- | similar to <tt>getTableGQLName</tt> but returns table name as a list
--   with name pieces instead of concatenating schema and table name
--   together.
getTableIdentifierName :: forall b m. (Backend b, MonadError QErr m) => TableInfo b -> m GQLNameIdentifier

-- | Table select columns enum
--   
--   Parser for an enum type that matches the columns of the given table.
--   Used as a parameter for "distinct", among others. Maps to the
--   table_select_column object.
--   
--   Return Nothing if there's no column the current user has "select"
--   permissions for.
tableSelectColumnsEnum :: forall b r m n. (Backend b, MonadBuildSchemaBase r m n) => SourceInfo b -> TableInfo b -> m (Maybe (Parser 'Both n (Column b)))

-- | Table select columns enum of a certain type.
--   
--   Parser for an enum type that matches, of a given table, certain
--   columns which satisfy a predicate. Used as a parameter for aggregation
--   predicate arguments, among others. Maps to the table_select_column
--   object.
--   
--   Return Nothing if there's no column the current user has "select"
--   permissions for.
tableSelectColumnsPredEnum :: forall b r m n. MonadBuildSchema b r m n => (ColumnType b -> Bool) -> Name -> SourceInfo b -> TableInfo b -> m (Maybe (Parser 'Both n (Column b)))

-- | Table update columns enum
--   
--   Parser for an enum type that matches the columns of the given table.
--   Used for conflict resolution in "insert" mutations, among others. Maps
--   to the table_update_column object.
tableUpdateColumnsEnum :: forall b r m n. MonadBuildSchema b r m n => TableInfo b -> m (Maybe (Parser 'Both n (Column b)))
updateColumnsPlaceholderParser :: MonadBuildSchema backend r m n => TableInfo backend -> m (Parser 'Both n (Maybe (Column backend)))
tableSelectPermissions :: RoleName -> TableInfo b -> Maybe (SelPermInfo b)
tableSelectFields :: forall b r m. (Backend b, MonadError QErr m, MonadReader r m, Has SchemaContext r) => SourceInfo b -> TableInfo b -> m [FieldInfo b]
tableColumns :: forall b. TableInfo b -> [ColumnInfo b]

-- | Get the columns of a table that my be selected under the given select
--   permissions.
tableSelectColumns :: forall b r m. (Backend b, MonadError QErr m, MonadReader r m, Has SchemaContext r) => SourceInfo b -> TableInfo b -> m [ColumnInfo b]

-- | Get the columns of a table that my be updated under the given update
--   permissions.
tableUpdateColumns :: forall b. Backend b => RoleName -> TableInfo b -> [ColumnInfo b]

module Hasura.GraphQL.Schema.OrderBy
orderByOperator :: forall b n. (BackendSchema b, MonadParse n) => NamingCase -> SourceInfo b -> Parser 'Both n (Maybe (BasicOrderType b, NullsOrderType b))

-- | Corresponds to an object type for an order by.
--   
--   <pre>
--   input table_order_by {
--     col1: order_by
--     col2: order_by
--     .     .
--     .     .
--     coln: order_by
--     obj-rel: &lt;remote-table&gt;_order_by
--   }
--   </pre>
orderByExp :: forall b r m n. MonadBuildSchema b r m n => SourceInfo b -> TableInfo b -> m (Parser 'Input n [AnnotatedOrderByItemG b (UnpreparedValue b)])
orderByAggregation :: forall b r m n. MonadBuildSchema b r m n => SourceInfo b -> TableInfo b -> m (Parser 'Input n [OrderByItemG b (AnnotatedAggregateOrderBy b)])
orderByOperatorsHasuraCase :: forall b n. (BackendSchema b, MonadParse n) => SourceInfo b -> Parser 'Both n (Maybe (BasicOrderType b, NullsOrderType b))
orderByOperatorsGraphqlCase :: forall b n. (BackendSchema b, MonadParse n) => SourceInfo b -> Parser 'Both n (Maybe (BasicOrderType b, NullsOrderType b))
orderByOperator' :: forall b n. (BackendSchema b, MonadParse n) => NamingCase -> SourceInfo b -> Parser 'Both n (Maybe (BasicOrderType b, NullsOrderType b))
mkOrderByItemG :: forall b a. a -> (BasicOrderType b, NullsOrderType b) -> OrderByItemG b a

module Hasura.GraphQL.Schema.BoolExp

-- | Backends implement this type class to specify the schema of
--   aggregation predicates.
--   
--   The default implementation results in a parser that does not parse
--   anything.
--   
--   The scope of this class is local to the function <a>boolExp</a>. In
--   particular, methods in `class BackendSchema` and `type
--   MonadBuildSchema` should *NOT* include this class as a constraint.
class AggregationPredicatesSchema (b :: BackendType)
aggregationPredicatesParser :: forall r m n. (AggregationPredicatesSchema b, MonadBuildSchemaBase r m n) => SourceInfo b -> TableInfo b -> m (Maybe (InputFieldsParser n [AggregationPredicates b (UnpreparedValue b)]))

-- | <pre>
--   input type_bool_exp {
--     _or: [type_bool_exp!]
--     _and: [type_bool_exp!]
--     _not: type_bool_exp
--     column: type_comparison_exp
--     ...
--   }
--   </pre>
boolExp :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => SourceInfo b -> TableInfo b -> m (Parser 'Input n (AnnBoolExp b (UnpreparedValue b)))
mkBoolOperator :: (MonadParse n, 'Input <: k) => NamingCase -> DangerouslyCollapseBooleans -> GQLNameIdentifier -> Maybe Description -> Parser k n a -> InputFieldsParser n (Maybe a)
equalityOperators :: (MonadParse n, 'Input <: k) => NamingCase -> DangerouslyCollapseBooleans -> Parser k n (UnpreparedValue b) -> Parser k n (UnpreparedValue b) -> [InputFieldsParser n (Maybe (OpExpG b (UnpreparedValue b)))]
comparisonOperators :: (MonadParse n, 'Input <: k) => NamingCase -> DangerouslyCollapseBooleans -> Parser k n (UnpreparedValue b) -> [InputFieldsParser n (Maybe (OpExpG b (UnpreparedValue b)))]
instance (Hasura.RQL.Types.Backend.AggregationPredicates b GHC.Types.~ Data.Functor.Const.Const Data.Void.Void) => Hasura.GraphQL.Schema.BoolExp.AggregationPredicatesSchema b


-- | Generate table selection schema both for ordinary Hasura-type and
--   relay-type queries. All schema with "relay" or "connection" in the
--   name is used exclusively by relay.
module Hasura.GraphQL.Schema.Select

-- | Simple table selection.
--   
--   The field for the table accepts table selection arguments, and expects
--   a selection of fields
--   
--   <pre>
--   table_name(limit: 10) {
--     col1: col1_type
--     col2: col2_type
--   }: [table!]!
--   </pre>
defaultSelectTable :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b) => SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (SelectExp b)))

-- | Simple table connection selection.
--   
--   The field for the table accepts table connection selection argument,
--   and expects a selection of connection fields
--   
--   <pre>
--   table_name_connection(first: 1) {
--     pageInfo: {
--       hasNextPage: Boolean!
--       endCursor: String!
--     }
--     edges: {
--       cursor: String!
--       node: {
--         id: ID!
--         col1: col1_type
--         col2: col2_type
--       }
--     }
--   }: table_nameConnection!
--   </pre>
selectTableConnection :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b, AggregationPredicatesSchema b) => SourceInfo b -> TableInfo b -> Name -> Maybe Description -> PrimaryKeyColumns b -> m (Maybe (FieldParser n (ConnectionSelectExp b)))

-- | Table selection by primary key.
--   
--   <pre>
--   table_name(id: 42) {
--     col1: col1_type
--     col2: col2_type
--   }: table
--   </pre>
--   
--   Returns Nothing if there's nothing that can be selected with current
--   permissions or if there are primary keys the user doesn't have select
--   permissions for.
selectTableByPk :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b) => SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (SelectExp b)))

-- | Table aggregation selection
--   
--   Parser for an aggregation selection of a table. &gt;
--   table_aggregate(limit: 10) { &gt; aggregate: table_aggregate_fields
--   &gt; nodes: [table!]! &gt; } :: table_aggregate!
--   
--   Returns Nothing if there's nothing that can be selected with current
--   permissions.
defaultSelectTableAggregate :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b) => SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (AggSelectExp b)))

-- | Fields of a table
--   
--   <pre>
--   type table{
--     # table columns
--     column_1: column1_type
--     .
--     column_n: columnn_type
--   
--     # table relationships
--     object_relationship: remote_table
--     array_relationship: [remote_table!]!
--   
--     # computed fields
--     computed_field: field_type
--   
--     # remote relationships
--     remote_field: field_type
--   }
--   </pre>
defaultTableSelectionSet :: forall b r m n. (AggregationPredicatesSchema b, BackendTableSelectSchema b, Eq (AnnBoolExp b (UnpreparedValue b)), MonadBuildSchema b r m n) => SourceInfo b -> TableInfo b -> m (Maybe (Parser 'Output n (AnnotatedFields b)))

-- | List of table fields object. Just a <tt><a>nonNullableObjectList</a>
--   wrapper over </tt><a>tableSelectionSet</a>. &gt; table_name: [table!]!
tableSelectionList :: (MonadBuildSchemaBase r m n, BackendTableSelectSchema b) => SourceInfo b -> TableInfo b -> m (Maybe (Parser 'Output n (AnnotatedFields b)))

-- | Converts an output type parser from object_type to [object_type!]!
nonNullableObjectList :: Parser 'Output m a -> Parser 'Output m a

-- | Connection fields of a table
--   
--   <pre>
--   type tableConnection{
--     pageInfo: PageInfo!
--     edges: [tableEdge!]!
--   }
--   </pre>
--   
--   <pre>
--   type PageInfo{
--     startCursor: String!
--     endCursor: String!
--     hasNextPage: Boolean!
--     hasPreviousPage: Boolean!
--   }
--   </pre>
--   
--   <pre>
--   type tableEdge{
--     cursor: String!
--     node: table!
--   }
--   </pre>
tableConnectionSelectionSet :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b) => SourceInfo b -> TableInfo b -> m (Maybe (Parser 'Output n (ConnectionFields b)))

-- | Arguments for a table selection. Default implementation for
--   BackendSchema.
--   
--   <pre>
--   distinct_on: [table_select_column!]
--   limit: Int
--   offset: Int
--   order_by: [table_order_by!]
--   where: table_bool_exp
--   </pre>
defaultTableArgs :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => SourceInfo b -> TableInfo b -> m (InputFieldsParser n (SelectArgs b))

-- | Argument to filter rows returned from table selection &gt; where:
--   table_bool_exp
tableWhereArg :: forall b r m n. (AggregationPredicatesSchema b, MonadBuildSchema b r m n) => SourceInfo b -> TableInfo b -> m (InputFieldsParser n (Maybe (AnnBoolExp b (UnpreparedValue b))))

-- | Argument to sort rows returned from table selection &gt; order_by:
--   [table_order_by!]
tableOrderByArg :: forall b r m n. MonadBuildSchema b r m n => SourceInfo b -> TableInfo b -> m (InputFieldsParser n (Maybe (NonEmpty (AnnotatedOrderByItemG b (UnpreparedValue b)))))

-- | Argument to distinct select on columns returned from table selection
--   &gt; distinct_on: [table_select_column!]
tableDistinctArg :: forall b r m n. MonadBuildSchema b r m n => SourceInfo b -> TableInfo b -> m (InputFieldsParser n (Maybe (NonEmpty (Column b))))

-- | Argument to limit rows returned from table selection &gt; limit:
--   NonNegativeInt
tableLimitArg :: forall n. MonadParse n => InputFieldsParser n (Maybe Int)

-- | Argument to skip some rows, in conjunction with order_by &gt; offset:
--   BigInt
tableOffsetArg :: forall n. MonadParse n => InputFieldsParser n (Maybe Int64)

-- | Arguments for a table connection selection
--   
--   <pre>
--   distinct_on: [table_select_column!]
--   order_by: [table_order_by!]
--   where: table_bool_exp
--   first: Int
--   last: Int
--   before: String
--   after: String
--   </pre>
tableConnectionArgs :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => PrimaryKeyColumns b -> SourceInfo b -> TableInfo b -> m (InputFieldsParser n (SelectArgs b, Maybe (NonEmpty (ConnectionSplit b (UnpreparedValue b))), Maybe ConnectionSlice))

-- | Aggregation fields
--   
--   <pre>
--   type table_aggregate_fields{
--     count(distinct: Boolean, columns: [table_select_column!]): Int!
--     sum: table_sum_fields
--     avg: table_avg_fields
--     stddev: table_stddev_fields
--     stddev_pop: table_stddev_pop_fields
--     variance: table_variance_fields
--     var_pop: table_var_pop_fields
--     max: table_max_fields
--     min: table_min_fields
--   }
--   </pre>
tableAggregationFields :: forall b r m n. MonadBuildSchema b r m n => SourceInfo b -> TableInfo b -> m (Parser 'Output n (AggregateFields b))

-- | An individual field of a table
--   
--   <pre>
--   field_name(arg_name: arg_type, ...): field_type
--   </pre>
fieldSelection :: forall b r m n. (AggregationPredicatesSchema b, BackendTableSelectSchema b, Eq (AnnBoolExp b (UnpreparedValue b)), MonadBuildSchema b r m n) => SourceInfo b -> TableName b -> TableInfo b -> FieldInfo b -> m [FieldParser n (AnnotatedField b)]

-- | Field parsers for a table relationship
relationshipField :: forall b r m n. (AggregationPredicatesSchema b, BackendTableSelectSchema b, Eq (AnnBoolExp b (UnpreparedValue b)), MonadBuildSchema b r m n) => SourceInfo b -> TableName b -> RelInfo b -> m (Maybe [FieldParser n (AnnotatedField b)])
tablePermissionsInfo :: Backend b => SelPermInfo b -> TablePerms b


-- | Generate the GraphQL schema types related to streaming subscriptions.
module Hasura.GraphQL.Schema.SubscriptionStream

-- | Argument to limit the maximum number of results returned in a single
--   batch.
cursorBatchSizeArg :: forall n. MonadParse n => NamingCase -> InputFieldsParser n Int

-- | Cursor ordering enum fields
--   
--   <pre>
--   enum cursor_ordering {
--     ASC
--     DESC
--   }
--   </pre>
cursorOrderingArgParser :: forall n m r. (MonadMemoize m, MonadParse n, Has MkTypename r, Has NamingCase r, MonadReader r m) => m (Parser 'Both n CursorOrdering)

-- | Argument to specify the ordering of the cursor. &gt; ordering:
--   cursor_ordering
cursorOrderingArg :: forall n m r. (MonadMemoize m, MonadParse n, Has MkTypename r, Has NamingCase r, MonadReader r m) => m (InputFieldsParser n (Maybe CursorOrdering))

-- | Input fields parser to parse the value of a table's column &gt;
--   column_name: column_type
streamColumnParserArg :: forall b n m r. (BackendSchema b, MonadMemoize m, MonadParse n, Has MkTypename r, MonadReader r m, MonadError QErr m, Has NamingCase r) => ColumnInfo b -> m (InputFieldsParser n (Maybe (ColumnInfo b, ColumnValue b)))

-- | Input object parser whose keys are the column names and the values are
--   the initial values of those columns from where the streaming should
--   start. &gt; input table_stream_cursor_value_input { &gt; col1:
--   col1_type &gt; col2: col2_type ... &gt; }
streamColumnValueParser :: forall b n m r. (BackendSchema b, MonadMemoize m, MonadParse n, Has MkTypename r, MonadReader r m, MonadError QErr m, Has NamingCase r) => SourceInfo b -> Name -> [ColumnInfo b] -> m (Parser 'Input n [(ColumnInfo b, ColumnValue b)])

-- | Argument to accept the initial value from where the streaming should
--   start. &gt; initial_value: table_stream_cursor_value_input!
streamColumnValueParserArg :: forall b n m r. (BackendSchema b, MonadMemoize m, MonadParse n, Has MkTypename r, MonadReader r m, MonadError QErr m, Has NamingCase r) => SourceInfo b -> Name -> [ColumnInfo b] -> m (InputFieldsParser n [(ColumnInfo b, ColumnValue b)])

-- | Argument to accept the cursor data. At the time of writing this, only
--   a single column cursor is supported and if multiple column cursors are
--   provided, then a parse error is thrown. &gt;
tableStreamColumnArg :: forall n m r b. (BackendSchema b, MonadMemoize m, MonadParse n, Has MkTypename r, MonadReader r m, MonadError QErr m, Has NamingCase r) => SourceInfo b -> Name -> [ColumnInfo b] -> m (InputFieldsParser n [StreamCursorItem b])

-- | Input object that contains the initial value of a column along with
--   how it needs to be ordered. &gt; input table_stream_cursor_input {
--   &gt; initial_value: table_stream_cursor_value_input! &gt; ordering:
--   cursor_ordering &gt; }
tableStreamCursorExp :: forall m n r b. MonadBuildSchema b r m n => SourceInfo b -> TableInfo b -> m (Parser 'Input n [StreamCursorItem b])

-- | Argument to accept the cursor input object. &gt; cursor:
--   [table_stream_cursor_input]!
tableStreamCursorArg :: forall b r m n. MonadBuildSchema b r m n => SourceInfo b -> TableInfo b -> m (InputFieldsParser n [StreamCursorItem b])

-- | Arguments to the streaming subscription field. &gt; table_stream
--   (cursor: [table_stream_cursor_input]!, batch_size: Int!, where:
--   table_bool_exp)
tableStreamArguments :: forall b r m n. (AggregationPredicatesSchema b, MonadBuildSchema b r m n) => SourceInfo b -> TableInfo b -> m (InputFieldsParser n (SelectStreamArgs b))

-- | Field parser for a streaming subscription for a table.
selectStreamTable :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (StreamSelectExp b)))

module Hasura.GraphQL.Schema.Mutation

-- | Construct the parser for a field that can be used to add several rows
--   to a DB table.
--   
--   This function is used to create the insert_tablename root field. The
--   field accepts the following arguments: - objects: the list of objects
--   to insert into the table (see <a>tableFieldsInput</a>) - parser for
--   backend-specific fields, e.g. upsert fields on_conflict or if_matched
insertIntoTable :: forall b r m n. MonadBuildSchema b r m n => BackendTableSelectSchema b => (SourceInfo b -> TableInfo b -> m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> Scenario -> SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Variant of <a>insertIntoTable</a> that inserts a single row.
--   
--   Instead of expecting a list of rows to insert in a <tt>objects</tt>
--   argument, this field instead expects a single <tt>object</tt>. Its
--   selection set is also slightly different: it only allows selecting
--   columns from the row being inserted.
insertOneIntoTable :: forall b r m n. MonadBuildSchema b r m n => BackendTableSelectSchema b => (SourceInfo b -> TableInfo b -> m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> Scenario -> SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Creates the parser for an input object for a row of the given table.
--   
--   This function creates an input object type named
--   "tablename_insert_input" in the GraphQL shema, which has a field for
--   each of the columns of that table that the user has insert permissions
--   for.
--   
--   <pre>
--   {
--    insert_author (
--      objects: [
--        { # tableFieldsInput output
--          name: "John",
--          id:12
--        }
--      ] ...
--    ) ...
--   }
--   </pre>
tableFieldsInput :: forall b r m n. MonadBuildSchema b r m n => SourceInfo b -> TableInfo b -> m (Parser 'Input n (AnnotatedInsertRow b (UnpreparedValue b)))
mkDefaultRelationshipParser :: forall b r m n. MonadBuildSchema b r m n => (SourceInfo b -> TableInfo b -> m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> XNestedInserts b -> SourceInfo b -> RelInfo b -> m (Maybe (InputFieldsParser n (Maybe (AnnotatedInsertField b (UnpreparedValue b)))))

-- | Construct the parser for an input object that represents an insert
--   through an object relationship.
--   
--   When inserting objects into tables, we allow insertions through
--   relationships. This function creates the parser for an object that
--   represents the insertion object across an object relationship; it is
--   co-recursive with <a>tableFieldsInput</a>.
objectRelationshipInput :: forall b r m n. MonadBuildSchema b r m n => (SourceInfo b -> TableInfo b -> m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> SourceInfo b -> TableInfo b -> m (Maybe (Parser 'Input n (SingleObjectInsert b (UnpreparedValue b))))

-- | Construct the parser for an input object that represents an insert
--   through an array relationship.
--   
--   When inserting objects into tables, we allow insertions through
--   relationships. This function creates the parser for an object that
--   represents the insertion object across an array relationship; it is
--   co-recursive with <a>tableFieldsInput</a>.
arrayRelationshipInput :: forall b r m n. MonadBuildSchema b r m n => (SourceInfo b -> TableInfo b -> m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> SourceInfo b -> TableInfo b -> m (Maybe (Parser 'Input n (MultiObjectInsert b (UnpreparedValue b))))

-- | Helper function that creates an <tt>AnnIns</tt> object.
mkInsertObject :: forall b f. BackendSchema b => f (AnnotatedInsertRow b (UnpreparedValue b)) -> TableInfo b -> BackendInsert b (UnpreparedValue b) -> InsPermInfo b -> Maybe (UpdPermInfo b) -> AnnotatedInsertData b f (UnpreparedValue b)

-- | Construct a root field, normally called delete_tablename, that can be
--   used to delete several rows from a DB table
deleteFromTable :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => Scenario -> SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Construct a root field, normally called delete_tablename_by_pk, that
--   can be used to delete an individual rows from a DB table, specified by
--   primary key. Select permissions are required, as the user must be
--   allowed to access all the primary keys of the table.
deleteFromTableByPk :: forall b r m n. MonadBuildSchema b r m n => BackendTableSelectSchema b => Scenario -> SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
mkDeleteObject :: Backend b => TableName b -> [ColumnInfo b] -> DelPermInfo b -> Maybe NamingCase -> (AnnBoolExp b (UnpreparedValue b), MutationOutputG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)) -> AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)

-- | All mutations allow returning results, such as what the updated
--   database rows look like. This parser allows a query to specify what
--   data to fetch.
mutationSelectionSet :: forall b r m n. MonadBuildSchema b r m n => BackendTableSelectSchema b => SourceInfo b -> TableInfo b -> m (Parser 'Output n (MutFldsG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)))

-- | How to specify a database row by primary key.
--   
--   This will give <tt>Nothing</tt> when either there are no primary keys
--   defined for the table or when the given permissions do not permit
--   selecting from all the columns that make up the key.
primaryKeysArguments :: forall b r m n. MonadBuildSchema b r m n => TableInfo b -> m (Maybe (InputFieldsParser n (AnnBoolExp b (UnpreparedValue b))))


-- | This module provides common building blocks for composing Schema
--   Parsers used in the schema of Update Mutations.
module Hasura.GraphQL.Schema.Update

-- | <tt>UpdateOperator b m n op</tt> represents one single update operator
--   for a backend <tt>b</tt>.
--   
--   The type variable <tt>op</tt> is the backend-specific data type that
--   represents update operators, typically in the form of a sum-type with
--   an <tt>UnpreparedValue b</tt> in each constructor.
--   
--   The <tt>UpdateOperator b m n</tt> is a <tt>Functor</tt>. There exist
--   building blocks of common update operators (such as <a>setOp</a>,
--   etc.) which have <tt>op ~ UnpreparedValue b</tt>. The Functor instance
--   lets you wrap the generic update operators in backend-specific tags.
data UpdateOperator b m n op
UpdateOperator :: (ColumnInfo b -> Bool) -> (GQLNameIdentifier -> TableName b -> NonEmpty (ColumnInfo b) -> m (InputFieldsParser n (HashMap (Column b) op))) -> UpdateOperator b m n op
[updateOperatorApplicableColumn] :: UpdateOperator b m n op -> ColumnInfo b -> Bool
[updateOperatorParser] :: UpdateOperator b m n op -> GQLNameIdentifier -> TableName b -> NonEmpty (ColumnInfo b) -> m (InputFieldsParser n (HashMap (Column b) op))

-- | The top-level component for building update operators parsers.
--   
--   <ul>
--   <li>It implements the <tt>preset</tt> functionality from Update
--   Permissions (see
--   &lt;<a>https://hasura.io/docs/latest/graphql/core/auth/authorization/permission-rules.html#column-presets</a>
--   Permissions user docs&gt;). Use the <a>presetColumns</a> function to
--   extract those from the update permissions.</li>
--   <li>It validates that that the update fields parsed are sound when
--   taken as a whole, i.e. that some changes are actually specified
--   (either in the mutation query text or in update preset columns) and
--   that each column is only used in one operator.</li>
--   </ul>
buildUpdateOperators :: forall b r m n op. MonadBuildSchema b r m n => HashMap (Column b) op -> [UpdateOperator b m n op] -> TableInfo b -> m (InputFieldsParser n (HashMap (Column b) op))

-- | The columns that have <tt>preset</tt> definitions applied to them.
--   (see
--   &lt;<a>https://hasura.io/docs/latest/graphql/core/auth/authorization/permission-rules.html#column-presets</a>
--   Permissions user docs&gt;)
presetColumns :: UpdPermInfo b -> HashMap (Column b) (UnpreparedValue b)

-- | Produce an InputFieldsParser from an UpdateOperator, but only if the
--   operator applies to the table (i.e., it admits a non-empty column
--   set).
runUpdateOperator :: forall b r m n op. MonadBuildSchema b r m n => TableInfo b -> UpdateOperator b m n op -> m (Maybe (InputFieldsParser n (HashMap (Column b) op)))

-- | Merge the results of parsed update operators. Throws an error if the
--   same column has been specified in multiple operators.
mergeDisjoint :: forall b m t. (Backend b, MonadParse m) => [HashMap (Column b) t] -> m (HashMap (Column b) t)

-- | Construct a parser for a single update operator.
--   
--   <tt>updateOperator _ "op" fp MkOp ["col1","col2"]</tt> gives a parser
--   that accepts objects in the shape of:
--   
--   <pre>
--   op: {
--     col1: "x",
--     col2: "y"
--   }
--   </pre>
--   
--   And (morally) parses into values:
--   
--   <pre>
--   M.fromList [("col1", MkOp (fp "x")), ("col2", MkOp (fp "y"))]
--   </pre>
updateOperator :: forall n r m b a. (MonadParse n, MonadReader r m, Has MkTypename r, Has NamingCase r, Backend b) => GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier -> (ColumnInfo b -> m (Parser 'Both n a)) -> NonEmpty (ColumnInfo b) -> Description -> Description -> m (InputFieldsParser n (HashMap (Column b) a))
setOp :: forall b n r m. (BackendSchema b, MonadReader r m, Has MkTypename r, Has NamingCase r, MonadError QErr m, MonadParse n) => UpdateOperator b m n (UnpreparedValue b)
incOp :: forall b m n r. (Backend b, MonadReader r m, MonadError QErr m, MonadParse n, BackendSchema b, Has MkTypename r, Has NamingCase r) => UpdateOperator b m n (UnpreparedValue b)

-- | Construct a root field, normally called update_tablename, that can be
--   used to update rows in a DB table specified by filters. Only returns a
--   parser if there are columns the user is allowed to update; otherwise
--   returns Nothing.
updateTable :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => InputFieldsParser n (BackendUpdate b (UnpreparedValue b)) -> Scenario -> SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Construct a root field, normally called
--   <tt>update_tablename_by_pk</tt>, that can be used to update a single
--   in a DB table, specified by primary key. Only returns a parser if
--   there are columns the user is allowed to update and if the user has
--   select permissions on all primary keys; otherwise returns Nothing.
updateTableByPk :: forall b r m n. MonadBuildSchema b r m n => BackendTableSelectSchema b => InputFieldsParser n (BackendUpdate b (UnpreparedValue b)) -> Scenario -> SourceInfo b -> TableInfo b -> Name -> Maybe Description -> m (Maybe (FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
mkUpdateObject :: Backend b => TableName b -> [ColumnInfo b] -> UpdPermInfo b -> Maybe NamingCase -> ((BackendUpdate b (UnpreparedValue b), AnnBoolExp b (UnpreparedValue b)), MutationOutputG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)) -> AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
instance (GHC.Base.Functor m, GHC.Base.Functor n) => GHC.Base.Functor (Hasura.GraphQL.Schema.Update.UpdateOperator b m n)


-- | This module provides building blocks for the GraphQL Schema that the
--   GraphQL Engine presents.
--   
--   The functions defined here are used to serve as default
--   implementations for their namesakes in the <tt>BackendSchema</tt> type
--   class.
--   
--   When, for some backend, you want to implement a new feature that
--   manifests itself visibly in the schema (e.g., if you're developing
--   support for update mutations), this module is likely where your
--   efforts should start.
--   
--   Using these functions help us present a consistent GraphQL schema
--   across different backends.
--   
--   There is a bit of tension however, as sometimes we intentionally do
--   want the GraphQL Schema relating to some backend to be different in
--   some way.
--   
--   It could be that a backend only has limited support for some common
--   feature, or, more interestingly, that some backend just does things
--   differently (c.f. MSSQL's <tt>MERGE</tt> statement with PostgreSQL's
--   <tt>INSERT .. ON CONFLICT</tt>, which are similar enough that we want
--   to use the same overall upsert schema but different enough that we
--   want to use different field names)
--   
--   When you want to implement new schema for a backend, there is overall
--   three different ways do deal with this tension:
--   
--   <ol>
--   <li>You can duplicate existing code and implement the new behavior in
--   the duplicate.</li>
--   <li>You can infuse the new behavior into existing code and switch
--   dynamically at runtime (or via type class instance dispatch, which is
--   the same for our purposes)</li>
--   <li>You can refactor the existing building blocks and compose them
--   differently at use sites to get the desired behavior nuances.</li>
--   </ol>
--   
--   Of these three, steps 1. and 2. are by far the easiest to execute,
--   while 3. requires some critical thought. However, both 1. and 2.
--   produce legacy code that is difficult to maintain and understand.
--   
--   As a guideline, if you find yourself wanting add new behavior to some
--   of these functions it's very likely that you should consider
--   refactoring them instead, thus shifting the responsibility deciding on
--   the correct behavior to use sites.
--   
--   It an ongoing effort to adapt and refactor these building blocks such
--   that they have the sizes and shapes that result in the most elegant
--   uses of them that we can manage.
module Hasura.GraphQL.Schema.Build

-- | Builds field name with proper case. Please note that this is a pure
--   function as all the validation has already been done while preparing
--   <tt>GQLNameIdentifier</tt>.
setFieldNameCase :: NamingCase -> TableInfo b -> CustomRootField -> (GQLNameIdentifier -> GQLNameIdentifier) -> GQLNameIdentifier -> Name

-- | buildTableQueryAndSubscriptionFields builds the field parsers of a
--   table. It returns a tuple with array of field parsers that correspond
--   to the field parsers of the query root and the field parsers of the
--   subscription root
buildTableQueryAndSubscriptionFields :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => MkRootFieldName -> SourceInfo b -> TableName b -> TableInfo b -> GQLNameIdentifier -> m ([FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], Maybe (Name, Parser 'Output n (ApolloFederationParserFunction n)))
buildTableStreamingSubscriptionFields :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => MkRootFieldName -> SourceInfo b -> TableName b -> TableInfo b -> GQLNameIdentifier -> m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableInsertMutationFields :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b) => (SourceInfo b -> TableInfo b -> m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> MkRootFieldName -> Scenario -> SourceInfo b -> TableName b -> TableInfo b -> GQLNameIdentifier -> m [FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]

-- | This function is the basic building block for update mutations. It
--   implements the mutation schema in the general shape described in
--   <tt><a>https://hasura.io/docs/latest/graphql/core/databases/postgres/mutations/update.html</a></tt>.
--   
--   Something that varies between backends is the <tt>update
--   operators</tt> that they support (i.e. the schema fields
--   <tt>_set</tt>, <tt>_inc</tt>, etc., see
--   <a>Hasura.Backends.Postgres.Instances.Schema.updateOperators</a> for
--   an example implementation). Therefore, this function is parameterised
--   over a monadic action that produces the operators that the backend
--   supports in the context of some table and associated update
--   permissions.
--   
--   Apart from this detail, the rest of the arguments are the same as
--   those of <tt>BackendSchema.</tt><a>buildTableUpdateMutationFields</a>.
--   
--   The suggested way to use this is like:
--   
--   <pre>
--   instance BackendSchema MyBackend where
--     ...
--     buildTableUpdateMutationFields = GSB.buildTableUpdateMutationFields myBackendUpdateOperators
--     ...
--   </pre>
buildTableUpdateMutationFields :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => (TableInfo b -> m (InputFieldsParser n (BackendUpdate b (UnpreparedValue b)))) -> MkRootFieldName -> Scenario -> SourceInfo b -> TableName b -> TableInfo b -> GQLNameIdentifier -> m [FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableDeleteMutationFields :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => MkRootFieldName -> Scenario -> SourceInfo b -> TableName b -> TableInfo b -> GQLNameIdentifier -> m [FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildFieldDescription :: Text -> Comment -> Maybe Description


-- | This module defines the schema aspect of the default implementation of
--   aggregation predicates.
module Hasura.GraphQL.Schema.BoolExp.AggregationPredicates

-- | This function is meant to serve as the default schema for Aggregation
--   Predicates represented in the IR by the type
--   <a>AggregationPredicates</a>.
defaultAggregationPredicatesParser :: forall b r m n. (MonadBuildSchemaBase r m n, BackendSchema b, AggregationPredicatesSchema b) => [FunctionSignature b] -> SourceInfo b -> TableInfo b -> m (Maybe (InputFieldsParser n [AggregationPredicatesImplementation b (UnpreparedValue b)]))
data FunctionSignature (b :: BackendType)
FunctionSignature :: Text -> Name -> ArgumentsSignature b -> ScalarType b -> FunctionSignature (b :: BackendType)
[fnName] :: FunctionSignature (b :: BackendType) -> Text
[fnGQLName] :: FunctionSignature (b :: BackendType) -> Name
[fnArguments] :: FunctionSignature (b :: BackendType) -> ArgumentsSignature b
[fnReturnType] :: FunctionSignature (b :: BackendType) -> ScalarType b
data ArgumentsSignature (b :: BackendType)
ArgumentsStar :: ArgumentsSignature (b :: BackendType)
Arguments :: NonEmpty (ArgumentSignature b) -> ArgumentsSignature (b :: BackendType)
data ArgumentSignature (b :: BackendType)
ArgumentSignature :: ScalarType b -> Name -> ArgumentSignature (b :: BackendType)
[argType] :: ArgumentSignature (b :: BackendType) -> ScalarType b
[argName] :: ArgumentSignature (b :: BackendType) -> Name

module Hasura.Backends.Postgres.Schema.Select

-- | User-defined function (AKA custom function)
selectFunction :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> SourceInfo ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> Maybe Description -> m (Maybe (FieldParser n (SelectExp ('Postgres pgKind))))
selectFunctionAggregate :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> SourceInfo ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> Maybe Description -> m (Maybe (FieldParser n (AggSelectExp ('Postgres pgKind))))
selectFunctionConnection :: forall pgKind r m n. (MonadBuildSchema ('Postgres pgKind) r m n, AggregationPredicatesSchema ('Postgres pgKind), BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> SourceInfo ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> Maybe Description -> PrimaryKeyColumns ('Postgres pgKind) -> m (Maybe (FieldParser n (ConnectionSelectExp ('Postgres pgKind))))

-- | Computed field parser
computedFieldPG :: forall pgKind r m n. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => SourceInfo ('Postgres pgKind) -> ComputedFieldInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> m (Maybe (FieldParser n (AnnotatedField ('Postgres pgKind))))

-- | The custom SQL functions' input "args" field parser &gt;
--   function_name(args: function_args)
customSQLFunctionArgs :: MonadBuildSchema ('Postgres pgKind) r m n => SourceInfo ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> Name -> Name -> m (InputFieldsParser n (FunctionArgsExp ('Postgres pgKind) (UnpreparedValue ('Postgres pgKind))))

-- | Parses the arguments to the underlying sql function of a computed
--   field or a custom function. All arguments to the underlying sql
--   function are parsed as an "args" object. Named arguments are expected
--   in a field with the same name, while positional arguments are expected
--   in an field named "arg_$n". Note that collisions are possible, but
--   ignored for now, if a named argument is also named "arg_$n". (FIXME:
--   link to an issue?)
--   
--   If the function requires no argument, or if its only argument is not
--   user-provided (the session argument in the case of custom functions,
--   the table row argument in the case of computed fields), the args
--   object will be omitted.
functionArgs :: forall r m n pgKind. MonadBuildSchema ('Postgres pgKind) r m n => SourceInfo ('Postgres pgKind) -> FunctionTrackedAs ('Postgres pgKind) -> Seq (FunctionInputArgument ('Postgres pgKind)) -> m (InputFieldsParser n (FunctionArgsExp ('Postgres pgKind) (UnpreparedValue ('Postgres pgKind))))
buildFunctionQueryFieldsPG :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> SourceInfo ('Postgres pgKind) -> FunctionName ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> m [FieldParser n (QueryDB ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))]
buildFunctionMutationFieldsPG :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> SourceInfo ('Postgres pgKind) -> FunctionName ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> m [FieldParser n (MutationDB ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))]


-- | Postgres Schema OnConflict
--   
--   This module contains the building blocks for parsing
--   <tt>on_conflict</tt> clauses, which in the Postgres backend are used
--   to implement upsert functionality. These are used by
--   <a>backendInsertParser</a> to construct a postgres-specific schema
--   parser for insert (and upsert) mutations.
module Hasura.Backends.Postgres.Schema.OnConflict

-- | Parser for a field name <tt>on_conflict</tt> of type
--   <tt>tablename_on_conflict</tt>.
--   
--   The <tt>tablename_on_conflict</tt> object is used to generate the
--   <tt>ON CONFLICT</tt> SQL clause, indicating what should be done if an
--   insert raises a conflict.
--   
--   The types ordinarily produced by this parser are only created if the
--   table has unique or primary keys constraints.
--   
--   If there are no columns for which the current role has update
--   permissions, we must still accept an empty list for
--   <tt>update_columns</tt> to support the "ON CONFLICT DO NOTHING" case.
--   We do this by adding a placeholder value to the enum. See
--   <a>https://github.com/hasura/graphql-engine/issues/6804</a>.
onConflictFieldParser :: forall pgKind r m n. (MonadBuildSchema ('Postgres pgKind) r m n, AggregationPredicatesSchema ('Postgres pgKind)) => SourceInfo ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> m (InputFieldsParser n (Maybe (OnConflictClause ('Postgres pgKind) (UnpreparedValue ('Postgres pgKind)))))

-- | Create a parser for the <tt>_on_conflict</tt> object of the given
--   table.
conflictObjectParser :: forall pgKind r m n. (MonadBuildSchema ('Postgres pgKind) r m n, AggregationPredicatesSchema ('Postgres pgKind)) => SourceInfo ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> Maybe (UpdPermInfo ('Postgres pgKind)) -> NonEmpty (UniqueConstraint ('Postgres pgKind)) -> m (Parser 'Input n (OnConflictClause ('Postgres pgKind) (UnpreparedValue ('Postgres pgKind))))

-- | Constructs a Parser for the name of the constraints on a given table.
--   
--   The TableCoreInfo of a given table contains a list of unique or
--   primary key constraints. Given the list of such constraints, this
--   function creates a parser for an enum type that matches it. This
--   function makes no attempt at de-duplicating contraint names, and
--   assumes they are correct.
--   
--   This function can fail if a constraint has a name that cannot be
--   translated to a GraphQL name (see hasura/graphql-engine-mono#1748).
conflictConstraint :: forall pgKind r m n. MonadBuildSchema ('Postgres pgKind) r m n => NonEmpty (UniqueConstraint ('Postgres pgKind)) -> SourceInfo ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> m (Parser 'Both n (UniqueConstraint ('Postgres pgKind)))


-- | MSSQL Schema IfMatched
--   
--   This module contains the building blocks for parsing
--   <tt>if_matched</tt> clauses (represented as <a>IfMatched</a>), which
--   in the MSSQL backend are used to implement upsert functionality.
--   
--   These are used by <a>backendInsertParser</a> to construct a
--   mssql-specific schema parser for insert (and upsert) mutations.
module Hasura.Backends.MSSQL.Schema.IfMatched

-- | Field-parser for:
--   
--   <pre>
--   if_matched: tablename_if_matched
--   
--   input tablename_if_matched {
--     match_columns: [tablename_select_column!]
--     update_columns: [tablename_update_columns!]
--     where: tablename_bool_exp
--   }
--   </pre>
--   
--   Note that the types ordinarily produced by this parser are only
--   created if the active role has <i>both</i> select and update
--   permissions to the table <tt>tablename</tt> defined <i>and</i> these
--   grant non-empty column permissions.
ifMatchedFieldParser :: forall r m n. (MonadBuildSchema 'MSSQL r m n, AggregationPredicatesSchema 'MSSQL) => SourceInfo 'MSSQL -> TableInfo 'MSSQL -> m (InputFieldsParser n (Maybe (IfMatched (UnpreparedValue 'MSSQL))))

-- | Parse a <tt>tablename_if_matched</tt> object.
ifMatchedObjectParser :: forall r m n. (MonadBuildSchema 'MSSQL r m n, AggregationPredicatesSchema 'MSSQL) => SourceInfo 'MSSQL -> TableInfo 'MSSQL -> m (Maybe (Parser 'Input n (IfMatched (UnpreparedValue 'MSSQL))))

-- | Table insert_match_columns enum
--   
--   Parser for an enum type that matches the columns that can be used for
--   insert match_columns for a given table. Maps to the
--   insert_match_columns object.
--   
--   Return Nothing if there's no column the current user has "select"
--   permissions for.
tableInsertMatchColumnsEnum :: forall r m n. MonadBuildSchemaBase r m n => SourceInfo 'MSSQL -> TableInfo 'MSSQL -> m (Maybe (Parser 'Both n (Column 'MSSQL)))

-- | Check whether a column can be used for match_columns.
isMatchColumnValid :: ColumnInfo 'MSSQL -> Bool


-- | Postgres Translate Types
--   
--   Intermediary / helper types used for translating IR to Postgres SQL.
module Hasura.Backends.Postgres.Translate.Types
data SourcePrefixes
SourcePrefixes :: Identifier -> Identifier -> SourcePrefixes

-- | Current source prefix
[_pfThis] :: SourcePrefixes -> Identifier

-- | Base table source row identifier to generate the table's column
--   identifiers for computed field function input parameters
[_pfBase] :: SourcePrefixes -> Identifier

-- | Select portion of rows generated by the query using limit and offset
data SelectSlicing
SelectSlicing :: Maybe Int -> Maybe Int64 -> SelectSlicing
[_ssLimit] :: SelectSlicing -> Maybe Int
[_ssOffset] :: SelectSlicing -> Maybe Int64
data DistinctAndOrderByExpr
ASorting :: (OrderByExp, Maybe DistinctExpr) -> Maybe (OrderByExp, Maybe DistinctExpr) -> DistinctAndOrderByExpr
[_sortAtNode] :: DistinctAndOrderByExpr -> (OrderByExp, Maybe DistinctExpr)
[_sortAtBase] :: DistinctAndOrderByExpr -> Maybe (OrderByExp, Maybe DistinctExpr)

-- | Sorting with -- Note [Optimizing queries using limit/offset])
data SelectSorting
NoSorting :: Maybe DistinctExpr -> SelectSorting
Sorting :: DistinctAndOrderByExpr -> SelectSorting
data SortingAndSlicing
SortingAndSlicing :: SelectSorting -> SelectSlicing -> SortingAndSlicing
[_sasSorting] :: SortingAndSlicing -> SelectSorting
[_sasSlicing] :: SortingAndSlicing -> SelectSlicing
data SelectSource
SelectSource :: Identifier -> FromItem -> BoolExp -> SortingAndSlicing -> SelectSource
[_ssPrefix] :: SelectSource -> Identifier
[_ssFrom] :: SelectSource -> FromItem
[_ssWhere] :: SelectSource -> BoolExp
[_ssSortingAndSlicing] :: SelectSource -> SortingAndSlicing
noSortingAndSlicing :: SortingAndSlicing
noSlicing :: SelectSlicing
orderByForJsonAgg :: SelectSource -> Maybe OrderByExp
data ApplySortingAndSlicing
ApplySortingAndSlicing :: (Maybe OrderByExp, SelectSlicing, Maybe DistinctExpr) -> (Maybe OrderByExp, SelectSlicing, Maybe DistinctExpr) -> ApplySortingAndSlicing
[_applyAtBase] :: ApplySortingAndSlicing -> (Maybe OrderByExp, SelectSlicing, Maybe DistinctExpr)
[_applyAtNode] :: ApplySortingAndSlicing -> (Maybe OrderByExp, SelectSlicing, Maybe DistinctExpr)
applySortingAndSlicing :: SortingAndSlicing -> ApplySortingAndSlicing
data SelectNode
SelectNode :: HashMap ColumnAlias SQLExp -> JoinTree -> SelectNode
[_snExtractors] :: SelectNode -> HashMap ColumnAlias SQLExp
[_snJoinTree] :: SelectNode -> JoinTree
data ObjectSelectSource
ObjectSelectSource :: Identifier -> FromItem -> BoolExp -> ObjectSelectSource
[_ossPrefix] :: ObjectSelectSource -> Identifier
[_ossFrom] :: ObjectSelectSource -> FromItem
[_ossWhere] :: ObjectSelectSource -> BoolExp
objectSelectSourceToSelectSource :: ObjectSelectSource -> SelectSource
data ObjectRelationSource
ObjectRelationSource :: RelName -> HashMap PGCol PGCol -> ObjectSelectSource -> ObjectRelationSource
[_orsRelationshipName] :: ObjectRelationSource -> RelName
[_orsRelationMapping] :: ObjectRelationSource -> HashMap PGCol PGCol
[_orsSelectSource] :: ObjectRelationSource -> ObjectSelectSource
data ArrayRelationSource
ArrayRelationSource :: TableAlias -> HashMap PGCol PGCol -> SelectSource -> ArrayRelationSource
[_arsAlias] :: ArrayRelationSource -> TableAlias
[_arsRelationMapping] :: ArrayRelationSource -> HashMap PGCol PGCol
[_arsSelectSource] :: ArrayRelationSource -> SelectSource
data MultiRowSelectNode
MultiRowSelectNode :: [Extractor] -> SelectNode -> MultiRowSelectNode
[_mrsnTopExtractors] :: MultiRowSelectNode -> [Extractor]
[_mrsnSelectNode] :: MultiRowSelectNode -> SelectNode
data ComputedFieldTableSetSource
ComputedFieldTableSetSource :: FieldName -> SelectSource -> ComputedFieldTableSetSource
[_cftssFieldName] :: ComputedFieldTableSetSource -> FieldName
[_cftssSelectSource] :: ComputedFieldTableSetSource -> SelectSource
data ArrayConnectionSource
ArrayConnectionSource :: TableAlias -> HashMap PGCol PGCol -> Maybe BoolExp -> Maybe ConnectionSlice -> SelectSource -> ArrayConnectionSource
[_acsAlias] :: ArrayConnectionSource -> TableAlias
[_acsRelationMapping] :: ArrayConnectionSource -> HashMap PGCol PGCol
[_acsSplitFilter] :: ArrayConnectionSource -> Maybe BoolExp
[_acsSlice] :: ArrayConnectionSource -> Maybe ConnectionSlice
[_acsSource] :: ArrayConnectionSource -> SelectSource
data JoinTree
JoinTree :: HashMap ObjectRelationSource SelectNode -> HashMap ArrayRelationSource MultiRowSelectNode -> HashMap ArrayConnectionSource MultiRowSelectNode -> HashMap ComputedFieldTableSetSource MultiRowSelectNode -> JoinTree
[_jtObjectRelations] :: JoinTree -> HashMap ObjectRelationSource SelectNode
[_jtArrayRelations] :: JoinTree -> HashMap ArrayRelationSource MultiRowSelectNode
[_jtArrayConnections] :: JoinTree -> HashMap ArrayConnectionSource MultiRowSelectNode
[_jtComputedFieldTableSets] :: JoinTree -> HashMap ComputedFieldTableSetSource MultiRowSelectNode
data PermissionLimitSubQuery

-- | Permission limit
PLSQRequired :: Int -> PermissionLimitSubQuery
PLSQNotRequired :: PermissionLimitSubQuery
type SimilarArrayFields = HashMap FieldName [FieldName]
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SourcePrefixes
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SourcePrefixes
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.SourcePrefixes
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SelectSource
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ObjectRelationSource
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ArrayRelationSource
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ArrayConnectionSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectNode
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.MultiRowSelectNode
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.JoinTree
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.PermissionLimitSubQuery
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.PermissionLimitSubQuery
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.SelectSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ObjectRelationSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ArrayRelationSource
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ArrayConnectionSource
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.SelectNode
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.MultiRowSelectNode
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.JoinTree
instance GHC.Base.Monoid Hasura.Backends.Postgres.Translate.Types.JoinTree
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ArrayConnectionSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ArrayRelationSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ObjectRelationSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SelectSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SourcePrefixes


-- | Stuff gutted from Translate.Select
module Hasura.Backends.Postgres.Translate.Select.Internal.JoinTree

-- | This is the lowest level function which deals with <tt>MonadWriter
--   JoinTree</tt>, whose purpose is to essentially create the selection
--   tree across relationships.
--   
--   Each type of relationship uses a different kind of update function;
--   see <a>withWriteObjectRelation</a>, <a>withWriteArrayRelation</a>,
--   <a>withWriteArrayConnection</a>, and
--   <a>withWriteComputedFieldTableSet</a>.
--   
--   See the definition of <a>JoinTree</a> for details before diving
--   further (particularly its components and Monoid instance).
withWriteJoinTree :: MonadWriter JoinTree m => (JoinTree -> b -> JoinTree) -> m (a, b) -> m a
withWriteObjectRelation :: MonadWriter JoinTree m => m (ObjectRelationSource, HashMap ColumnAlias SQLExp, a) -> m a
withWriteArrayRelation :: MonadWriter JoinTree m => m (ArrayRelationSource, Extractor, HashMap ColumnAlias SQLExp, a) -> m a
withWriteArrayConnection :: MonadWriter JoinTree m => m (ArrayConnectionSource, Extractor, HashMap ColumnAlias SQLExp, a) -> m a
withWriteComputedFieldTableSet :: MonadWriter JoinTree m => m (ComputedFieldTableSetSource, Extractor, HashMap ColumnAlias SQLExp, a) -> m a


-- | Stuff gutted from Translate.Select
module Hasura.Backends.Postgres.Translate.Select.Internal.Aliases

-- | Generate alias for order by extractors
mkAnnOrderByAlias :: Identifier -> FieldName -> SimilarArrayFields -> AnnotatedOrderByElement ('Postgres pgKind) v -> ColumnAlias
mkUniqArrayRelationAlias :: FieldName -> [FieldName] -> Identifier
mkArrayRelationTableAlias :: Identifier -> FieldName -> [FieldName] -> Identifier
mkObjectRelationTableAlias :: Identifier -> RelName -> Identifier
mkComputedFieldTableAlias :: Identifier -> FieldName -> Identifier
mkBaseTableAlias :: Identifier -> TableAlias
mkBaseTableColumnAlias :: Identifier -> PGCol -> ColumnAlias
mkAggregateOrderByAlias :: AnnotatedAggregateOrderBy ('Postgres pgKind) -> ColumnAlias
mkOrderByFieldName :: ToTxt a => a -> FieldName
mkArrayRelationSourcePrefix :: Identifier -> FieldName -> HashMap FieldName [FieldName] -> FieldName -> Identifier
mkArrayRelationAlias :: FieldName -> HashMap FieldName [FieldName] -> FieldName -> TableAlias


-- | Stuff gutted from Translate.Select.
module Hasura.Backends.Postgres.Translate.Select.Internal.Helpers

-- | First element extractor expression from given record set For example:-
--   To get first "id" column from given row set, the function generates
--   the SQL expression AS `(array_agg("id"))[1]`
mkFirstElementExp :: SQLExp -> SQLExp

-- | Last element extractor expression from given record set. For example:-
--   To get first "id" column from given row set, the function generates
--   the SQL expression AS `(array_agg("id"))[array_length(array_agg("id"),
--   1)]`
mkLastElementExp :: SQLExp -> SQLExp
cursorIdentifier :: Identifier
startCursorIdentifier :: Identifier
endCursorIdentifier :: Identifier
hasPreviousPageIdentifier :: Identifier
hasNextPageIdentifier :: Identifier
pageInfoSelectAliasIdentifier :: Identifier
cursorsSelectAliasIdentifier :: Identifier
encodeBase64 :: SQLExp -> SQLExp
fromTableRowArgs :: Identifier -> FunctionArgsExpG (ArgumentExp SQLExp) -> FunctionArgs
selectFromToFromItem :: Identifier -> SelectFrom ('Postgres pgKind) -> FromItem

-- | Converts a function name to an <a>Identifier</a>.
--   
--   If the schema name is public, it will just use its name, otherwise it
--   will prefix it by the schema name.
functionToIdentifier :: QualifiedFunction -> Identifier
withJsonBuildObj :: FieldName -> [SQLExp] -> (ColumnAlias, SQLExp)

-- | Forces aggregation
withForceAggregation :: TypeAnn -> SQLExp -> SQLExp


-- | This module defines the type class <a>PostgresAnnotatedFieldJSON</a>.
module Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON
class PostgresAnnotatedFieldJSON (pgKind :: PostgresKind)
annRowToJson :: PostgresAnnotatedFieldJSON pgKind => FieldName -> [(FieldName, SQLExp)] -> (ColumnAlias, SQLExp)
pgAnnRowToJson :: FieldName -> [(FieldName, SQLExp)] -> (ColumnAlias, SQLExp)
instance Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON.PostgresAnnotatedFieldJSON 'Hasura.SQL.Backend.Vanilla
instance Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON.PostgresAnnotatedFieldJSON 'Hasura.SQL.Backend.Citus
instance Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON.PostgresAnnotatedFieldJSON 'Hasura.SQL.Backend.Cockroach


-- | This module contains worker definitions pertaining to generating
--   <tt>Select</tt> AST nodes.
--   
--   NOTE: <a>generateSQLSelect</a> is mutually recursive with
--   <a>connectionToSelectWith</a>, thus these two cohabitate in this
--   module.
module Hasura.Backends.Postgres.Translate.Select.Internal.GenerateSelect
generateSQLSelect :: BoolExp -> SelectSource -> SelectNode -> Select
generateSQLSelectFromArrayNode :: SelectSource -> MultiRowSelectNode -> BoolExp -> Select
mkJoinCond :: TableAlias -> HashMap PGCol PGCol -> BoolExp
connectionToSelectWith :: TableAlias -> ArrayConnectionSource -> MultiRowSelectNode -> SelectWithG Select


-- | Extractors are a pair of an SQL expression and an alias; they get
--   translated like "[SELECT ...] <a>expr</a> as <a>alias</a>"
module Hasura.Backends.Postgres.Translate.Select.Internal.Extractor
aggregateFieldsToExtractorExps :: Identifier -> AggregateFields ('Postgres pgKind) -> [(ColumnAlias, SQLExp)]
mkAggregateOrderByExtractorAndFields :: forall pgKind. Backend ('Postgres pgKind) => AnnotatedAggregateOrderBy ('Postgres pgKind) -> (Extractor, AggregateFields ('Postgres pgKind))
withJsonAggExtr :: PermissionLimitSubQuery -> Maybe OrderByExp -> ColumnAlias -> SQLExp
asSingleRowExtr :: ColumnAlias -> SQLExp
asJsonAggExtr :: JsonAggSelect -> ColumnAlias -> PermissionLimitSubQuery -> Maybe OrderByExp -> Extractor


-- | This module relates to the processing of Order-By clauses.
module Hasura.Backends.Postgres.Translate.Select.Internal.OrderBy
processOrderByItems :: forall pgKind m. (MonadReader StringifyNumbers m, MonadWriter JoinTree m, Backend ('Postgres pgKind)) => Identifier -> FieldName -> SimilarArrayFields -> Maybe (NonEmpty PGCol) -> Maybe (NonEmpty (AnnotatedOrderByItem ('Postgres pgKind))) -> m ([(ColumnAlias, SQLExp)], SelectSorting, Maybe SQLExp)
applyDistinctOnAtBase :: NonEmpty PGCol -> DistinctExpr
applyDistinctOnAtNode :: Identifier -> NonEmpty PGCol -> (DistinctExpr, [(ColumnAlias, SQLExp)])


-- | This module defines functions that translate from the Postgres IR into
--   Postgres SQL AST.
--   
--   NOTE: These functions <a>processAnnAggregateSelect</a>,
--   <a>processAnnSimpleSelect</a>, <a>processConnectionSelect</a>, are all
--   mutually recursive.
--   
--   These functions are generally called from the top level functions in
--   Translate.Select, and the call stack looks like:
--   
--   <ul>
--   <li><tt>selectQuerySQL</tt> -&gt; <tt>mkSQLSelect</tt> -&gt;
--   <a>processAnnSimpleSelect</a> -&gt;
--   <a>processSelectParams</a>/<a>processAnnFields</a></li>
--   <li><tt>selectAggregateQuerySQL</tt> -&gt; <tt>mkAggregateSelect</tt>
--   -&gt; <a>processAnnAggregateSelect</a> -&gt;
--   <a>processSelectParams</a>/<a>processAnnFields</a></li>
--   <li><tt>connetionSelectQuerySQL</tt> -&gt; <tt>mkConnectionSelect</tt>
--   -&gt; <tt>processConnectionSelection</tt> -&gt;
--   <a>processSelectParams</a></li>
--   </ul>
--   
--   <a>SelectSource</a> consists of a prefix, a source, a boolean
--   conditional expression, and info on whether sorting or slicing is done
--   (needed to handle the LIMIT optimisation)
module Hasura.Backends.Postgres.Translate.Select.Internal.Process
processSelectParams :: forall pgKind m. (MonadReader StringifyNumbers m, MonadWriter JoinTree m, Backend ('Postgres pgKind)) => SourcePrefixes -> FieldName -> SimilarArrayFields -> SelectFrom ('Postgres pgKind) -> PermissionLimitSubQuery -> TablePerm ('Postgres pgKind) -> SelectArgs ('Postgres pgKind) -> m (SelectSource, [(ColumnAlias, SQLExp)], Maybe SQLExp)
processAnnAggregateSelect :: forall pgKind m. (MonadReader StringifyNumbers m, MonadWriter JoinTree m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => SourcePrefixes -> FieldName -> AnnAggregateSelect ('Postgres pgKind) -> m (SelectSource, HashMap ColumnAlias SQLExp, Extractor)
processAnnFields :: forall pgKind m. (MonadReader StringifyNumbers m, MonadWriter JoinTree m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => Identifier -> FieldName -> SimilarArrayFields -> AnnFields ('Postgres pgKind) -> Maybe NamingCase -> m (ColumnAlias, SQLExp)
mkSimilarArrayFields :: forall pgKind v. (Backend ('Postgres pgKind), Eq v) => AnnFieldsG ('Postgres pgKind) Void v -> Maybe (NonEmpty (AnnotatedOrderByItemG ('Postgres pgKind) v)) -> SimilarArrayFields
processArrayRelation :: forall pgKind m. (MonadReader StringifyNumbers m, MonadWriter JoinTree m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => SourcePrefixes -> FieldName -> TableAlias -> ArraySelect ('Postgres pgKind) -> Maybe NamingCase -> m ()
aggregateFieldToExp :: AggregateFields ('Postgres pgKind) -> StringifyNumbers -> SQLExp
processAnnSimpleSelect :: forall pgKind m. (MonadReader StringifyNumbers m, MonadWriter JoinTree m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => SourcePrefixes -> FieldName -> PermissionLimitSubQuery -> AnnSimpleSelect ('Postgres pgKind) -> m (SelectSource, HashMap ColumnAlias SQLExp)
processConnectionSelect :: forall pgKind m. (MonadReader StringifyNumbers m, MonadWriter JoinTree m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => SourcePrefixes -> FieldName -> TableAlias -> HashMap PGCol PGCol -> ConnectionSelect ('Postgres pgKind) Void SQLExp -> m (ArrayConnectionSource, Extractor, HashMap ColumnAlias SQLExp)


-- | This module defines the top-level translation functions pertaining to
--   streaming selects into Postgres AST.
--   
--   Streaming subscriptions are subscriptions based on a user-provided
--   cursor column. Unlike live queries, streaming subscriptions can be
--   used to only get the part that has changed in the query's response,
--   although this will be dependent on the user's choice of the cursor
--   column. The streaming starts from the initial value provided by the
--   user.
module Hasura.Backends.Postgres.Translate.Select.Streaming
selectStreamQuerySQL :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => AnnSimpleStreamSelect ('Postgres pgKind) -> Query
mkStreamSQLSelect :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => AnnSimpleStreamSelect ('Postgres pgKind) -> Select


-- | This module defines the top-level translation functions pertaining to
--   queries that are not aggregation queries, i.e. so-called "simple"
--   selects into Postgres AST.
module Hasura.Backends.Postgres.Translate.Select.Simple

-- | Translates IR to Postgres queries for simple SELECTs (select queries
--   that are not aggregations, including subscriptions).
--   
--   See <a>mkSQLSelect</a> for the Postgres AST.
selectQuerySQL :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => JsonAggSelect -> AnnSimpleSelect ('Postgres pgKind) -> Query
mkSQLSelect :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => JsonAggSelect -> AnnSimpleSelect ('Postgres pgKind) -> Select


-- | This module defines the top-level translation functions pertaining to
--   translating Connection (i.e. Relay) queries into Postgres AST.
module Hasura.Backends.Postgres.Translate.Select.Connection

-- | Translates IR to Postgres queries for "connection" queries (used for
--   Relay).
--   
--   See <a>mkConnectionSelect</a> for the Postgres AST.
connectionSelectQuerySQL :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => ConnectionSelect ('Postgres pgKind) Void SQLExp -> Query
mkConnectionSelect :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => ConnectionSelect ('Postgres pgKind) Void SQLExp -> SelectWithG Select


-- | This module defines the top-level translation functions pertaining to
--   queries that use aggregation (i.e., <i>not</i> so-called "simple"
--   selects) into Postgres AST.
module Hasura.Backends.Postgres.Translate.Select.Aggregate

-- | Translates IR to Postgres queries for aggregated SELECTs.
--   
--   See <a>mkAggregateSelect</a> for the Postgres AST.
selectAggregateQuerySQL :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => AnnAggregateSelect ('Postgres pgKind) -> Query
mkAggregateSelect :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => AnnAggregateSelect ('Postgres pgKind) -> Select


-- | Postgres Translate Select
--   
--   This module is a translation layer between IR and postgres-specific
--   select queries.
--   
--   There are four main types of selects (as distinguished from the IR):
--   
--   <ul>
--   <li>"simple" selects</li>
--   <li>aggregate selects</li>
--   <li>connection selects (used for relay)</li>
--   <li>streaming selects (see
--   Hasura.Backends.Postgres.Translate.Select.Streaming for details)</li>
--   </ul>
module Hasura.Backends.Postgres.Translate.Select

module Hasura.RQL.DML.Select
type SelectQExt = SelectG (ExtCol ('Postgres 'Vanilla)) (BoolExp ('Postgres 'Vanilla)) Int
data ExtCol (b :: BackendType)
ECSimple :: Column b -> ExtCol (b :: BackendType)
ECRel :: RelName -> Maybe RelName -> SelectQExt -> ExtCol (b :: BackendType)
convSelCol :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> SelPermInfo ('Postgres 'Vanilla) -> SelCol -> m [ExtCol ('Postgres 'Vanilla)]
convWildcard :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> SelPermInfo ('Postgres 'Vanilla) -> Wildcard -> m [ExtCol ('Postgres 'Vanilla)]
resolveStar :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> SelPermInfo ('Postgres 'Vanilla) -> SelectQ -> m SelectQExt
convOrderByElem :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => SessionVariableBuilder m -> (FieldInfoMap (FieldInfo ('Postgres 'Vanilla)), SelPermInfo ('Postgres 'Vanilla)) -> OrderByCol -> m (AnnotatedOrderByElement ('Postgres 'Vanilla) SQLExp)
convSelectQ :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m, HasServerConfigCtx m) => TableName ('Postgres 'Vanilla) -> FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> SelPermInfo ('Postgres 'Vanilla) -> SelectQExt -> SessionVariableBuilder m -> ValueParser ('Postgres 'Vanilla) m SQLExp -> m (AnnSimpleSelect ('Postgres 'Vanilla))
convExtSimple :: (UserInfoM m, QErrM m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> SelPermInfo ('Postgres 'Vanilla) -> PGCol -> m (ColumnInfo ('Postgres 'Vanilla), Maybe (AnnColumnCaseBoolExpPartialSQL ('Postgres 'Vanilla)))
convExtRel :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m, HasServerConfigCtx m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> RelName -> Maybe RelName -> SelectQExt -> SessionVariableBuilder m -> ValueParser ('Postgres 'Vanilla) m SQLExp -> m (Either (ObjectRelationSelect ('Postgres 'Vanilla)) (ArraySelect ('Postgres 'Vanilla)))
convSelectQuery :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m, HasServerConfigCtx m) => SessionVariableBuilder m -> ValueParser ('Postgres 'Vanilla) m SQLExp -> SelectQuery -> m (AnnSimpleSelect ('Postgres 'Vanilla))
selectP2 :: JsonAggSelect -> (AnnSimpleSelect ('Postgres 'Vanilla), Seq PrepArg) -> TxE QErr EncJSON
phaseOne :: (QErrM m, UserInfoM m, CacheRM m, HasServerConfigCtx m) => SelectQuery -> m (AnnSimpleSelect ('Postgres 'Vanilla), Seq PrepArg)
phaseTwo :: MonadTx m => (AnnSimpleSelect ('Postgres 'Vanilla), Seq PrepArg) -> m EncJSON
runSelect :: (QErrM m, UserInfoM m, CacheRM m, HasServerConfigCtx m, MonadIO m, MonadBaseControl IO m, MonadTrace m, MetadataM m) => SelectQuery -> m EncJSON


-- | Postgres Execute subscription
--   
--   Multiplex is an optimization which allows us to group similar queries
--   into a single query, and routing the response rows afterwards. See
--   <a>https://hasura.io/docs/latest/graphql/core/databases/postgres/subscriptions/execution-and-performance.html</a>
--   for more details
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Subscription

-- | Internal: Used to collect information about various parameters of a
--   subscription field's AST as we resolve them to SQL expressions.
data QueryParametersInfo (b :: BackendType)
QueryParametersInfo :: HashMap Name (ColumnValue b) -> Seq (ColumnValue b) -> HashSet SessionVariable -> QueryParametersInfo (b :: BackendType)
[_qpiReusableVariableValues] :: QueryParametersInfo (b :: BackendType) -> HashMap Name (ColumnValue b)
[_qpiSyntheticVariableValues] :: QueryParametersInfo (b :: BackendType) -> Seq (ColumnValue b)

-- | The session variables that are referenced in the query root fld's AST.
--   This information is used to determine a cohort's required session
--   variables
[_qpiReferencedSessionVariables] :: QueryParametersInfo (b :: BackendType) -> HashSet SessionVariable
qpiSyntheticVariableValues :: forall b_ayfBz. Lens' (QueryParametersInfo b_ayfBz) (Seq (ColumnValue b_ayfBz))
qpiReusableVariableValues :: forall b_ayfBz. Lens' (QueryParametersInfo b_ayfBz) (HashMap Name (ColumnValue b_ayfBz))
qpiReferencedSessionVariables :: forall b_ayfBz. Lens' (QueryParametersInfo b_ayfBz) (HashSet SessionVariable)

-- | Checks if the provided arguments are valid values for their
--   corresponding types. | Generates SQL of the format "select
--   <tt>v1</tt>::t1, <tt>v2</tt>::t2 ..."
validateVariables :: forall pgKind f m. (Traversable f, MonadError QErr m, MonadIO m) => PGExecCtx -> f (ColumnValue ('Postgres pgKind)) -> m (ValidatedVariables f)
newtype MultiplexedQuery
MultiplexedQuery :: Query -> MultiplexedQuery
[unMultiplexedQuery] :: MultiplexedQuery -> Query
toSQLFromItem :: (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => TableAlias -> QueryDB ('Postgres pgKind) Void SQLExp -> FromItem
mkMultiplexedQuery :: (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => InsOrdHashMap Name (QueryDB ('Postgres pgKind) Void SQLExp) -> MultiplexedQuery
mkStreamingMultiplexedQuery :: (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => (Name, QueryDB ('Postgres pgKind) Void SQLExp) -> MultiplexedQuery

-- | Resolves an <a>UnresolvedVal</a> by converting <a>UVPG</a> values to
--   SQL expressions that refer to the <tt>result_vars</tt> input object,
--   collecting information about various parameters of the query along the
--   way.
resolveMultiplexedValue :: (MonadState (QueryParametersInfo ('Postgres pgKind)) m, MonadError QErr m) => SessionVariables -> UnpreparedValue ('Postgres pgKind) -> m SQLExp
executeMultiplexedQuery :: MonadTx m => MultiplexedQuery -> [(CohortId, CohortVariables)] -> m [(CohortId, ByteString)]
executeStreamingMultiplexedQuery :: MonadTx m => MultiplexedQuery -> [(CohortId, CohortVariables)] -> m [(CohortId, ByteString, AltJ CursorVariableValues)]

-- | Internal; used by both <a>executeMultiplexedQuery</a>,
--   <a>executeStreamingMultiplexedQuery</a> and
--   <tt>pgDBSubscriptionExplain</tt>.
executeQuery :: (MonadTx m, FromRow a) => Query -> [(CohortId, CohortVariables)] -> m [a]
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.Subscription.MultiplexedQuery
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Subscription.MultiplexedQuery
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.Execute.Subscription.MultiplexedQuery
instance GHC.Base.Monoid (Hasura.Backends.Postgres.Execute.Subscription.QueryParametersInfo b)
instance GHC.Base.Semigroup (Hasura.Backends.Postgres.Execute.Subscription.QueryParametersInfo b)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Execute.Subscription.QueryParametersInfo b)


-- | Postgres Translate Returning
--   
--   Combinators and helpers for dealing with GraphQL returning statements.
module Hasura.Backends.Postgres.Translate.Returning

-- | The postgres common table expression (CTE) for mutation queries. This
--   CTE expression is used to generate mutation field output expression,
--   see Note [Mutation output expression].
data MutationCTE

-- | A Mutation with check constraint validation (Insert or Update)
MCCheckConstraint :: TopLevelCTE -> MutationCTE

-- | A Select statement which emits mutated table rows
MCSelectValues :: Select -> MutationCTE

-- | A Delete statement
MCDelete :: SQLDelete -> MutationCTE
getMutationCTE :: MutationCTE -> TopLevelCTE
checkPermissionRequired :: MutationCTE -> Bool
pgColsToSelFlds :: forall pgKind. Backend ('Postgres pgKind) => [ColumnInfo ('Postgres pgKind)] -> [(FieldName, AnnField ('Postgres pgKind))]
mkDefaultMutFlds :: Backend ('Postgres pgKind) => Maybe [ColumnInfo ('Postgres pgKind)] -> MutationOutput ('Postgres pgKind)
mkMutFldExp :: (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => Identifier -> Maybe Int -> StringifyNumbers -> Maybe NamingCase -> MutFld ('Postgres pgKind) -> SQLExp
toFIIdentifier :: Identifier -> FIIdentifier

-- | Generate mutation output expression with given mutation CTE statement.
--   See Note [Mutation output expression].
mkMutationOutputExp :: (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> Maybe Int -> MutationCTE -> MutationOutput ('Postgres pgKind) -> StringifyNumbers -> Maybe NamingCase -> SelectWith
mkCheckErrorExp :: IsIdentifier a => a -> SQLExp
checkConstraintIdentifier :: Identifier
asCheckErrorExtractor :: SQLExp -> Extractor
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Returning.MutationCTE
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Returning.MutationCTE


-- | Postgres Translate Insert
--   
--   Translates IR inserts to Postgres-specific SQL INSERT statements.
module Hasura.Backends.Postgres.Translate.Insert
mkInsertCTE :: Backend ('Postgres pgKind) => InsertQueryP1 ('Postgres pgKind) -> TopLevelCTE
toSQLConflict :: Backend ('Postgres pgKind) => QualifiedTable -> OnConflictClause ('Postgres pgKind) SQLExp -> SQLConflict

-- | Annotates the check constraint expression with <tt>boolean</tt>
--   (<a>check-condition</a>)::boolean
insertCheckConstraint :: BoolExp -> SQLExp

-- | When inserting data, we might need to also enforce the update check
--   condition, because we might fall back to an update via an <tt>ON
--   CONFLICT</tt> clause.
--   
--   We generate something which looks like
--   
--   <pre>
--   INSERT INTO
--     ...
--   ON CONFLICT DO UPDATE SET
--     ...
--   RETURNING
--     *,
--     CASE WHEN xmax = 0
--       THEN {insert_cond}
--       ELSE {update_cond}
--     END
--       AS "check__constraint"
--   </pre>
--   
--   See <tt><a>https://stackoverflow.com/q/34762732</a></tt> for more
--   information on the use of the <tt>xmax</tt> system column.
insertOrUpdateCheckExpr :: QualifiedTable -> Maybe (OnConflictClause ('Postgres pgKind) SQLExp) -> BoolExp -> Maybe BoolExp -> Extractor


-- | Postgres Translate Update
--   
--   Translates IR update to Postgres-specific SQL UPDATE statements.
module Hasura.Backends.Postgres.Translate.Update
data UpdateCTE

-- | Used for <i>update_table</i> and <i>update_table_by_pk</i>.
Update :: TopLevelCTE -> UpdateCTE

-- | Used for <i>update_table_many</i>.
MultiUpdate :: [TopLevelCTE] -> UpdateCTE

-- | Create the update CTE.
mkUpdateCTE :: forall pgKind. Backend ('Postgres pgKind) => AnnotatedUpdate ('Postgres pgKind) -> UpdateCTE
expandOperator :: [ColumnInfo ('Postgres pgKind)] -> (PGCol, UpdateOpExpression SQLExp) -> SetExpItem


-- | Postgres Instances Schema
--   
--   Defines a <a>BackendSchema</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.Schema

-- | This class is an implementation detail of <a>BackendSchema</a>. Some
--   functions of <a>BackendSchema</a> differ across different Postgres
--   "kinds", or call to functions (such as those related to Relay) that
--   have not been generalized to all kinds of Postgres and still
--   explicitly work on Vanilla Postgres. This class allows each "kind" to
--   specify its own specific implementation. All common code is directly
--   part of <a>BackendSchema</a>.
--   
--   Note: Users shouldn't ever put this as a constraint. Use
--   `BackendSchema ('Postgres pgKind)` instead.
class PostgresSchema (pgKind :: PostgresKind)
pgkBuildTableRelayQueryFields :: forall r m n. (PostgresSchema pgKind, MonadBuildSchema ('Postgres pgKind) r m n) => MkRootFieldName -> SourceInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> GQLNameIdentifier -> NESeq (ColumnInfo ('Postgres pgKind)) -> m [FieldParser n (QueryDB ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))]
pgkBuildFunctionRelayQueryFields :: forall r m n. (PostgresSchema pgKind, MonadBuildSchema ('Postgres pgKind) r m n) => MkRootFieldName -> SourceInfo ('Postgres pgKind) -> FunctionName ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> NESeq (ColumnInfo ('Postgres pgKind)) -> m [FieldParser n (QueryDB ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))]
pgkRelayExtension :: PostgresSchema pgKind => Maybe (XRelay ('Postgres pgKind))

-- | The aggregation functions that are supported by postgres variants.
--   TODO: Add more.
_aggregationFunctions :: [FunctionSignature ('Postgres pgKind)]
backendInsertParser :: forall pgKind m r n. MonadBuildSchema ('Postgres pgKind) r m n => SourceInfo ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> m (InputFieldsParser n (BackendInsert pgKind (UnpreparedValue ('Postgres pgKind))))
buildTableRelayQueryFields :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> SourceInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> GQLNameIdentifier -> NESeq (ColumnInfo ('Postgres pgKind)) -> m [FieldParser n (QueryDB ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))]
pgkBuildTableUpdateMutationFields :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> Scenario -> SourceInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> GQLNameIdentifier -> m [FieldParser n (AnnotatedUpdateG ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))]

-- | Create a parser for <tt>update_table_many</tt>. This function is very
--   similar to both <a>buildTableUpdateMutationFields</a> and
--   <a>updateTable</a>.
--   
--   It is similar to the former because of its shape: has to deal with
--   grabbing the casing, deals with update permissions, etc.
--   
--   It is similar to the latter because it deals with creating the
--   parser<i>subselection</i>etc.
--   
--   The reason this function exists here is because it is Postgres
--   specific. It would not fit very well next to the functions mentioned
--   above.
--   
--   However, if you are trying to implement this feature for other
--   backends, please consider making this function similar to
--   <i>updateTable</i> and moving it there. Note: this will likely require
--   adding a type or a function to <a>BackendSchema</a>.
updateTableMany :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> Scenario -> SourceInfo ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> GQLNameIdentifier -> m (Maybe (FieldParser n (AnnotatedUpdateG ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))))

-- | Create a parser for the updates section of the
--   <tt>update_table_many</tt> update.
--   
--   It parses a list with two fields: 'where', and an update expression
--   (set<i>inc</i>etc).
mkMultiRowUpdateParser :: forall pgKind r m n. MonadBuildSchema ('Postgres pgKind) r m n => SourceInfo ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> UpdPermInfo ('Postgres pgKind) -> m (InputFieldsParser n (BackendUpdate pgKind (UnpreparedValue ('Postgres pgKind))))
buildFunctionRelayQueryFields :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> SourceInfo ('Postgres pgKind) -> FunctionName ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> NESeq (ColumnInfo ('Postgres pgKind)) -> m [FieldParser n (QueryDB ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))]
columnParser :: (MonadParse n, MonadError QErr m, MonadReader r m, Has MkTypename r, Has NamingCase r) => ColumnType ('Postgres pgKind) -> Nullability -> m (Parser 'Both n (ValueWithOrigin (ColumnValue ('Postgres pgKind))))
pgScalarSelectionArgumentsParser :: MonadParse n => ColumnType ('Postgres pgKind) -> InputFieldsParser n (Maybe (ScalarSelectionArguments ('Postgres pgKind)))
orderByOperatorsHasuraCase :: (Name, NonEmpty (Definition EnumValueInfo, (BasicOrderType ('Postgres pgKind), NullsOrderType ('Postgres pgKind))))
orderByOperatorsGraphqlCase :: (Name, NonEmpty (Definition EnumValueInfo, (BasicOrderType ('Postgres pgKind), NullsOrderType ('Postgres pgKind))))

-- | Do NOT use this function directly, this should be used via
--   <tt>orderByOperatorsHasuraCase</tt> or
--   <tt>orderByOperatorsGraphqlCase</tt>
orderByOperators :: NamingCase -> (Name, NonEmpty (Definition EnumValueInfo, (BasicOrderType ('Postgres pgKind), NullsOrderType ('Postgres pgKind))))
comparisonExps :: forall pgKind m n r. (BackendSchema ('Postgres pgKind), MonadMemoize m, MonadParse n, MonadError QErr m, MonadReader r m, Has SchemaOptions r, Has MkTypename r, Has NamingCase r) => ColumnType ('Postgres pgKind) -> m (Parser 'Input n [ComparisonExp ('Postgres pgKind)])
geographyWithinDistanceInput :: forall pgKind m n r. (MonadMemoize m, MonadParse n, MonadError QErr m, MonadReader r m, Has MkTypename r, Has NamingCase r) => m (Parser 'Input n (DWithinGeogOp (UnpreparedValue ('Postgres pgKind))))
geometryWithinDistanceInput :: forall pgKind m n r. (MonadMemoize m, MonadParse n, MonadError QErr m, MonadReader r m, Has MkTypename r, Has NamingCase r) => m (Parser 'Input n (DWithinGeomOp (UnpreparedValue ('Postgres pgKind))))
intersectsNbandGeomInput :: forall pgKind m n r. (MonadMemoize m, MonadParse n, MonadError QErr m, MonadReader r m, Has MkTypename r, Has NamingCase r) => m (Parser 'Input n (STIntersectsNbandGeommin (UnpreparedValue ('Postgres pgKind))))
intersectsGeomNbandInput :: forall pgKind m n r. (MonadMemoize m, MonadParse n, MonadError QErr m, MonadReader r m, Has MkTypename r, Has NamingCase r) => m (Parser 'Input n (STIntersectsGeomminNband (UnpreparedValue ('Postgres pgKind))))
countTypeInput :: MonadParse n => Maybe (Parser 'Both n (Column ('Postgres pgKind))) -> InputFieldsParser n (CountDistinct -> CountType ('Postgres pgKind))

-- | Update operator that prepends a value to a column containing jsonb
--   arrays.
--   
--   Note: Currently this is Postgres specific because json columns have
--   not been ported to other backends yet.
prependOp :: forall pgKind m n r. (BackendSchema ('Postgres pgKind), MonadReader r m, MonadError QErr m, MonadParse n, Has MkTypename r, Has NamingCase r) => UpdateOperator ('Postgres pgKind) m n (UnpreparedValue ('Postgres pgKind))

-- | Update operator that appends a value to a column containing jsonb
--   arrays.
--   
--   Note: Currently this is Postgres specific because json columns have
--   not been ported to other backends yet.
appendOp :: forall pgKind m n r. (BackendSchema ('Postgres pgKind), MonadReader r m, MonadError QErr m, MonadParse n, Has MkTypename r, Has NamingCase r) => UpdateOperator ('Postgres pgKind) m n (UnpreparedValue ('Postgres pgKind))

-- | Update operator that deletes a value at a specified key from a column
--   containing jsonb objects.
--   
--   Note: Currently this is Postgres specific because json columns have
--   not been ported to other backends yet.
deleteKeyOp :: forall pgKind m n r. (BackendSchema ('Postgres pgKind), MonadReader r m, MonadError QErr m, MonadParse n, Has MkTypename r, Has NamingCase r) => UpdateOperator ('Postgres pgKind) m n (UnpreparedValue ('Postgres pgKind))

-- | Update operator that deletes a value at a specific index from a column
--   containing jsonb arrays.
--   
--   Note: Currently this is Postgres specific because json columns have
--   not been ported to other backends yet.
deleteElemOp :: forall pgKind m n r. (BackendSchema ('Postgres pgKind), MonadReader r m, MonadError QErr m, MonadParse n, Has MkTypename r, Has NamingCase r) => UpdateOperator ('Postgres pgKind) m n (UnpreparedValue ('Postgres pgKind))

-- | Update operator that deletes a field at a certan path from a column
--   containing jsonb objects.
--   
--   Note: Currently this is Postgres specific because json columns have
--   not been ported to other backends yet.
deleteAtPathOp :: forall pgKind m n r. (BackendSchema ('Postgres pgKind), MonadReader r m, MonadError QErr m, MonadParse n, Has MkTypename r, Has NamingCase r) => UpdateOperator ('Postgres pgKind) m n [UnpreparedValue ('Postgres pgKind)]

-- | The update operators that we support on Postgres.
updateOperators :: forall pgKind m n r. MonadBuildSchema ('Postgres pgKind) r m n => TableInfo ('Postgres pgKind) -> UpdPermInfo ('Postgres pgKind) -> m (InputFieldsParser n (HashMap (Column ('Postgres pgKind)) (UpdateOpExpression (UnpreparedValue ('Postgres pgKind)))))
instance Hasura.Backends.Postgres.Instances.Schema.PostgresSchema 'Hasura.SQL.Backend.Vanilla
instance Hasura.Backends.Postgres.Instances.Schema.PostgresSchema 'Hasura.SQL.Backend.Citus
instance Hasura.Backends.Postgres.Instances.Schema.PostgresSchema 'Hasura.SQL.Backend.Cockroach
instance (Hasura.Backends.Postgres.Instances.Schema.PostgresSchema pgKind, Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind), Hasura.SQL.Tag.HasTag ('Hasura.SQL.Backend.Postgres pgKind)) => Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema ('Hasura.SQL.Backend.Postgres pgKind)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind), Hasura.Backends.Postgres.Instances.Schema.PostgresSchema pgKind) => Hasura.GraphQL.Schema.Backend.BackendSchema ('Hasura.SQL.Backend.Postgres pgKind)
instance Hasura.GraphQL.Schema.BoolExp.AggregationPredicatesSchema ('Hasura.SQL.Backend.Postgres pgKind)

module Hasura.GraphQL.Schema.Action

-- | actionExecute is used to execute either a query action or a
--   synchronous mutation action. A query action or a synchronous mutation
--   action accepts the field name and input arguments and a selectionset.
--   The input argument and selectionset types are defined by the user.
--   
--   <pre>
--   action_name(action_input_arguments) {
--     col1: col1_type
--     col2: col2_type
--   }
--   </pre>
actionExecute :: forall r m n. MonadBuildSchemaBase r m n => AnnotatedCustomTypes -> ActionInfo -> m (Maybe (FieldParser n (AnnActionExecution (RemoteRelationshipField UnpreparedValue))))

-- | actionAsyncMutation is used to execute a asynchronous mutation action.
--   An asynchronous action expects the field name and the input arguments
--   to the action. A selectionset is *not* expected. An action ID (UUID)
--   will be returned after performing the action
--   
--   <pre>
--   action_name(action_input_arguments)
--   </pre>
actionAsyncMutation :: forall r m n. MonadBuildSchemaBase r m n => HashMap Name AnnotatedInputType -> ActionInfo -> m (Maybe (FieldParser n AnnActionMutationAsync))

-- | actionAsyncQuery is used to query/subscribe to the result of an
--   asynchronous mutation action. The only input argument to an
--   asynchronous mutation action is the action ID (UUID) and a selection
--   set is expected, the selection set contains 4 fields namely <a>id</a>,
--   <tt>created_at</tt>,<tt>errors</tt> and <tt>output</tt>. The result of
--   the action can be queried through the <tt>output</tt> field.
--   
--   <pre>
--   action_name (id: UUID!) {
--     id: UUID!
--     created_at: timestampz!
--     errors: JSON
--     output: user_defined_type!
--   }
--   </pre>
actionAsyncQuery :: forall r m n. MonadBuildSchema ('Postgres 'Vanilla) r m n => HashMap Name AnnotatedObjectType -> ActionInfo -> m (Maybe (FieldParser n (AnnActionAsyncQuery ('Postgres 'Vanilla) (RemoteRelationshipField UnpreparedValue))))

-- | Async action's unique id
actionIdParser :: MonadParse n => Parser 'Both n ActionId
actionOutputFields :: forall r m n. MonadBuildSchemaBase r m n => GType -> AnnotatedObjectType -> HashMap Name AnnotatedObjectType -> m (Parser 'Output n AnnotatedActionFields)
actionInputArguments :: forall r m n. MonadBuildSchemaBase r m n => HashMap Name AnnotatedInputType -> [ArgumentDefinition (GType, AnnotatedInputType)] -> m (InputFieldsParser n Value)
mkArgumentInputFieldParser :: forall m k. (MonadParse m, 'Input <: k) => Name -> Maybe Description -> GType -> Parser k m Value -> InputFieldsParser m (Maybe Value)
customScalarParser :: MonadParse m => AnnotatedScalarType -> Parser 'Both m Value
customEnumParser :: MonadParse m => EnumTypeDefinition -> Parser 'Both m Value


-- | Postgres-specific schema combinators. Those should be moved to the
--   corresponding instance of <tt>BackendSchema</tt>, when actions are
--   generalized.
module Hasura.GraphQL.Schema.Postgres
buildActionQueryFields :: MonadBuildSchema ('Postgres 'Vanilla) r m n => AnnotatedCustomTypes -> ActionInfo -> m [FieldParser n (QueryRootField UnpreparedValue)]
buildActionMutationFields :: MonadBuildSchema ('Postgres 'Vanilla) r m n => AnnotatedCustomTypes -> ActionInfo -> m [FieldParser n (MutationRootField UnpreparedValue)]
buildActionSubscriptionFields :: MonadBuildSchema ('Postgres 'Vanilla) r m n => AnnotatedCustomTypes -> ActionInfo -> m [FieldParser n (QueryRootField UnpreparedValue)]


-- | Postgres Execute Mutation
--   
--   Generic combinators for translating and excecuting IR mutation
--   statements. Used by the specific mutation modules, e.g. <a>Insert</a>.
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Mutation
data MutateResp (b :: BackendType) a
MutateResp :: Int -> [ColumnValues b a] -> MutateResp (b :: BackendType) a
[_mrAffectedRows] :: MutateResp (b :: BackendType) a -> Int
[_mrReturningColumns] :: MutateResp (b :: BackendType) a -> [ColumnValues b a]
data Mutation (b :: BackendType)
Mutation :: QualifiedTable -> (MutationCTE, Seq PrepArg) -> MutationOutput b -> [ColumnInfo b] -> StringifyNumbers -> Maybe NamingCase -> Mutation (b :: BackendType)
[_mTable] :: Mutation (b :: BackendType) -> QualifiedTable
[_mQuery] :: Mutation (b :: BackendType) -> (MutationCTE, Seq PrepArg)
[_mOutput] :: Mutation (b :: BackendType) -> MutationOutput b
[_mCols] :: Mutation (b :: BackendType) -> [ColumnInfo b]
[_mStrfyNum] :: Mutation (b :: BackendType) -> StringifyNumbers
[_mNamingConvention] :: Mutation (b :: BackendType) -> Maybe NamingCase
mkMutation :: UserInfo -> QualifiedTable -> (MutationCTE, Seq PrepArg) -> MutationOutput ('Postgres pgKind) -> [ColumnInfo ('Postgres pgKind)] -> StringifyNumbers -> Maybe NamingCase -> Mutation ('Postgres pgKind)
runMutation :: (MonadTx m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => Mutation ('Postgres pgKind) -> m EncJSON
mutateAndReturn :: (MonadTx m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => Mutation ('Postgres pgKind) -> m EncJSON
execUpdateQuery :: forall pgKind m. (MonadTx m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => StringifyNumbers -> Maybe NamingCase -> UserInfo -> (AnnotatedUpdate ('Postgres pgKind), Seq PrepArg) -> m EncJSON
execDeleteQuery :: forall pgKind m. (MonadTx m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => StringifyNumbers -> Maybe NamingCase -> UserInfo -> (AnnDel ('Postgres pgKind), Seq PrepArg) -> m EncJSON
execInsertQuery :: (MonadTx m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => StringifyNumbers -> Maybe NamingCase -> UserInfo -> (InsertQueryP1 ('Postgres pgKind), Seq PrepArg) -> m EncJSON
mutateAndSel :: forall pgKind m. (MonadTx m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => Mutation ('Postgres pgKind) -> m EncJSON
withCheckPermission :: MonadError QErr m => m (a, Bool) -> m a
executeMutationOutputQuery :: forall pgKind m. (MonadTx m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> Maybe Int -> MutationCTE -> MutationOutput ('Postgres pgKind) -> StringifyNumbers -> Maybe NamingCase -> [PrepArg] -> m EncJSON
mutateAndFetchCols :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> (MutationCTE, Seq PrepArg) -> StringifyNumbers -> Maybe NamingCase -> TxE QErr (MutateResp ('Postgres pgKind) TxtEncodedVal)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)

module Hasura.RQL.DML.Update
convInc :: QErrM m => ValueParser ('Postgres 'Vanilla) m SQLExp -> PGCol -> ColumnType ('Postgres 'Vanilla) -> Value -> m (PGCol, SQLExp)
convMul :: QErrM m => ValueParser ('Postgres 'Vanilla) m SQLExp -> PGCol -> ColumnType ('Postgres 'Vanilla) -> Value -> m (PGCol, SQLExp)
convSet :: QErrM m => ValueParser ('Postgres 'Vanilla) m SQLExp -> PGCol -> ColumnType ('Postgres 'Vanilla) -> Value -> m (PGCol, SQLExp)
convDefault :: Monad m => PGCol -> ColumnType ('Postgres 'Vanilla) -> () -> m (PGCol, SQLExp)
convOp :: (UserInfoM m, QErrM m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> [PGCol] -> UpdPermInfo ('Postgres 'Vanilla) -> [(PGCol, a)] -> (PGCol -> ColumnType ('Postgres 'Vanilla) -> a -> m (PGCol, SQLExp)) -> m [(PGCol, SQLExp)]
validateUpdateQueryWith :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => SessionVariableBuilder m -> ValueParser ('Postgres 'Vanilla) m SQLExp -> UpdateQuery -> m (AnnotatedUpdate ('Postgres 'Vanilla))
validateUpdateQuery :: (QErrM m, UserInfoM m, CacheRM m) => UpdateQuery -> m (AnnotatedUpdate ('Postgres 'Vanilla), Seq PrepArg)
runUpdate :: forall m. (QErrM m, UserInfoM m, CacheRM m, HasServerConfigCtx m, MonadBaseControl IO m, MonadIO m, MonadTrace m, MetadataM m) => UpdateQuery -> m EncJSON

module Hasura.RQL.DML.Insert
convObj :: (UserInfoM m, QErrM m) => (ColumnType ('Postgres 'Vanilla) -> Value -> m SQLExp) -> HashMap PGCol SQLExp -> HashMap PGCol SQLExp -> FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> InsObj ('Postgres 'Vanilla) -> m ([PGCol], [SQLExp])
validateInpCols :: MonadError QErr m => [PGCol] -> [PGCol] -> m ()
buildConflictClause :: (UserInfoM m, QErrM m) => SessionVariableBuilder m -> TableInfo ('Postgres 'Vanilla) -> [PGCol] -> OnConflict -> m (OnConflictClause ('Postgres 'Vanilla) SQLExp)
convInsertQuery :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => (Value -> m [InsObj ('Postgres 'Vanilla)]) -> SessionVariableBuilder m -> (ColumnType ('Postgres 'Vanilla) -> Value -> m SQLExp) -> InsertQuery -> m (InsertQueryP1 ('Postgres 'Vanilla))
convInsQ :: (QErrM m, UserInfoM m, CacheRM m) => InsertQuery -> m (InsertQueryP1 ('Postgres 'Vanilla), Seq PrepArg)
runInsert :: forall m. (QErrM m, UserInfoM m, CacheRM m, HasServerConfigCtx m, MonadIO m, MonadTrace m, MonadBaseControl IO m, MetadataM m) => InsertQuery -> m EncJSON
decodeInsObjs :: (UserInfoM m, QErrM m) => Value -> m [InsObj ('Postgres 'Vanilla)]

module Hasura.RQL.DML.Delete
validateDeleteQWith :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => SessionVariableBuilder m -> (ColumnType ('Postgres 'Vanilla) -> Value -> m SQLExp) -> DeleteQuery -> m (AnnDel ('Postgres 'Vanilla))
validateDeleteQ :: (QErrM m, UserInfoM m, CacheRM m) => DeleteQuery -> m (AnnDel ('Postgres 'Vanilla), Seq PrepArg)
runDelete :: forall m. (QErrM m, UserInfoM m, CacheRM m, HasServerConfigCtx m, MonadIO m, MonadTrace m, MonadBaseControl IO m, MetadataM m) => DeleteQuery -> m EncJSON


-- | Postgres Execute Insert
--   
--   Translates and executes IR to Postgres-specific SQL.
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Insert
convertToSQLTransaction :: forall pgKind m. (MonadTx m, MonadIO m, MonadTrace m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => AnnotatedInsert ('Postgres pgKind) Void SQLExp -> UserInfo -> Seq PrepArg -> StringifyNumbers -> Maybe NamingCase -> m EncJSON
insertMultipleObjects :: forall pgKind m. (MonadTx m, MonadIO m, MonadTrace m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => MultiObjectInsert ('Postgres pgKind) SQLExp -> HashMap PGCol SQLExp -> UserInfo -> MutationOutput ('Postgres pgKind) -> Seq PrepArg -> StringifyNumbers -> Maybe NamingCase -> m EncJSON
insertObject :: forall pgKind m. (MonadTx m, MonadIO m, MonadTrace m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => SingleObjectInsert ('Postgres pgKind) SQLExp -> HashMap PGCol SQLExp -> UserInfo -> Seq PrepArg -> StringifyNumbers -> Maybe NamingCase -> m (Int, Maybe (ColumnValues ('Postgres pgKind) TxtEncodedVal))
insertObjRel :: forall pgKind m. (MonadTx m, MonadIO m, MonadTrace m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => Seq PrepArg -> UserInfo -> StringifyNumbers -> Maybe NamingCase -> ObjectRelationInsert ('Postgres pgKind) SQLExp -> m (Int, [(PGCol, SQLExp)])
insertArrRel :: (MonadTx m, MonadIO m, MonadTrace m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => [(PGCol, SQLExp)] -> UserInfo -> Seq PrepArg -> StringifyNumbers -> Maybe NamingCase -> ArrayRelationInsert ('Postgres pgKind) SQLExp -> m Int

-- | Validate an insert object based on insert columns, insert object
--   relations and additional columns from parent:
--   
--   <ul>
--   <li>There should be no overlap between <tt>insCols</tt> and
--   <tt>addCols</tt>.</li>
--   <li>There should be no overlap between any object relationship columns
--   and <tt>insCols</tt> and <tt>addCols</tt>.</li>
--   </ul>
validateInsert :: MonadError QErr m => [PGCol] -> [RelInfo ('Postgres pgKind)] -> [PGCol] -> m ()
mkInsertQ :: Backend ('Postgres pgKind) => QualifiedTable -> Maybe (OnConflictClause ('Postgres pgKind) SQLExp) -> HashMap PGCol SQLExp -> (AnnBoolExpSQL ('Postgres pgKind), Maybe (AnnBoolExpSQL ('Postgres pgKind))) -> TopLevelCTE
fetchFromColVals :: MonadError QErr m => ColumnValues ('Postgres pgKind) TxtEncodedVal -> [ColumnInfo ('Postgres pgKind)] -> m [(PGCol, SQLExp)]
decodeEncJSON :: (FromJSON a, QErrM m) => EncJSON -> m a

module Hasura.Backends.MySQL.Instances.Schema
mysqlTableArgs :: forall r m n. MonadBuildSchema 'MySQL r m n => SourceInfo 'MySQL -> TableInfo 'MySQL -> m (InputFieldsParser n (SelectArgsG 'MySQL (UnpreparedValue 'MySQL)))
bsParser :: MonadParse m => Parser 'Both m ByteString
columnParser' :: (MonadParse n, MonadError QErr m, MonadReader r m, Has MkTypename r, Has NamingCase r) => ColumnType 'MySQL -> Nullability -> m (Parser 'Both n (ValueWithOrigin (ColumnValue 'MySQL)))
orderByOperators' :: NamingCase -> (Name, NonEmpty (Definition EnumValueInfo, (BasicOrderType 'MySQL, NullsOrderType 'MySQL)))

-- | TODO: Make this as thorough as the one for MSSQL/PostgreSQL
comparisonExps' :: forall m n r. (BackendSchema 'MySQL, MonadMemoize m, MonadParse n, MonadError QErr m, MonadReader r m, Has MkTypename r, Has NamingCase r) => ColumnType 'MySQL -> m (Parser 'Input n [ComparisonExp 'MySQL])
mysqlCountTypeInput :: MonadParse n => Maybe (Parser 'Both n (Column 'MySQL)) -> InputFieldsParser n (CountDistinct -> CountType 'MySQL)
instance Hasura.GraphQL.Schema.Backend.BackendSchema 'Hasura.SQL.Backend.MySQL
instance Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema 'Hasura.SQL.Backend.MySQL


-- | MSSQL Instances Schema
--   
--   Defines a <a>BackendSchema</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.Schema
backendInsertParser :: forall m r n. MonadBuildSchema 'MSSQL r m n => SourceInfo 'MSSQL -> TableInfo 'MSSQL -> m (InputFieldsParser n (BackendInsert (UnpreparedValue 'MSSQL)))
msBuildTableUpdateMutationFields :: MonadBuildSchema 'MSSQL r m n => MkRootFieldName -> Scenario -> SourceInfo 'MSSQL -> TableName 'MSSQL -> TableInfo 'MSSQL -> GQLNameIdentifier -> m [FieldParser n (AnnotatedUpdateG 'MSSQL (RemoteRelationshipField UnpreparedValue) (UnpreparedValue 'MSSQL))]
msTableArgs :: forall r m n. MonadBuildSchema 'MSSQL r m n => SourceInfo 'MSSQL -> TableInfo 'MSSQL -> m (InputFieldsParser n (SelectArgsG 'MSSQL (UnpreparedValue 'MSSQL)))
msColumnParser :: (MonadParse n, MonadError QErr m, MonadReader r m, Has MkTypename r, Has NamingCase r) => ColumnType 'MSSQL -> Nullability -> m (Parser 'Both n (ValueWithOrigin (ColumnValue 'MSSQL)))
msOrderByOperators :: NamingCase -> (Name, NonEmpty (Definition EnumValueInfo, (BasicOrderType 'MSSQL, NullsOrderType 'MSSQL)))
msComparisonExps :: forall m n r. (BackendSchema 'MSSQL, MonadMemoize m, MonadParse n, MonadError QErr m, MonadReader r m, Has SchemaOptions r, Has MkTypename r, Has NamingCase r) => ColumnType 'MSSQL -> m (Parser 'Input n [ComparisonExp 'MSSQL])
msCountTypeInput :: MonadParse n => Maybe (Parser 'Both n (Column 'MSSQL)) -> InputFieldsParser n (CountDistinct -> CountType 'MSSQL)
instance Hasura.GraphQL.Schema.Backend.BackendSchema 'Hasura.SQL.Backend.MSSQL
instance Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema 'Hasura.SQL.Backend.MSSQL

module Hasura.Backends.DataConnector.Plan
data QueryPlan
QueryPlan :: QueryRequest -> (forall m. MonadError QErr m => QueryResponse -> m Encoding) -> QueryPlan
[_qpRequest] :: QueryPlan -> QueryRequest
[_qpResponseReshaper] :: QueryPlan -> forall m. MonadError QErr m => QueryResponse -> m Encoding
data FieldsAndAggregates
FieldsAndAggregates :: HashMap FieldName Field -> HashMap FieldName Aggregate -> FieldsAndAggregates
[_faaFields] :: FieldsAndAggregates -> HashMap FieldName Field
[_faaAggregates] :: FieldsAndAggregates -> HashMap FieldName Aggregate
newtype FieldPrefix
FieldPrefix :: Maybe FieldName -> FieldPrefix
noPrefix :: FieldPrefix
prefixWith :: FieldName -> FieldPrefix
applyPrefix :: FieldPrefix -> FieldName -> FieldName

-- | Extract the <a>Q</a> from a <tt>Plan</tt> and render it as
--   <a>Text</a>.
--   
--   NOTE: This is for logging and debug purposes only.
renderQuery :: QueryRequest -> Text

-- | Map a 'QueryDB <a>DataConnector</a> term into a <tt>Plan</tt>
mkPlan :: forall m. MonadError QErr m => SessionVariables -> SourceConfig -> QueryDB 'DataConnector Void (UnpreparedValue 'DataConnector) -> m QueryPlan

-- | Validate if a <a>Q</a> contains any relationships.
queryHasRelations :: QueryRequest -> Bool
data Cardinality
Single :: Cardinality
Many :: Cardinality
reshapeResponseToQueryShape :: MonadError QErr m => QueryDB 'DataConnector Void (UnpreparedValue 'DataConnector) -> QueryResponse -> m Encoding
reshapeSimpleSelectRows :: MonadError QErr m => Cardinality -> AnnFieldsG 'DataConnector Void (UnpreparedValue 'DataConnector) -> QueryResponse -> m Encoding
reshapeTableAggregateFields :: MonadError QErr m => TableAggregateFieldsG 'DataConnector Void (UnpreparedValue 'DataConnector) -> QueryResponse -> m Encoding
reshapeAggregateFields :: MonadError QErr m => FieldPrefix -> AggregateFields 'DataConnector -> KeyMap Value -> m Encoding
reshapeAnnFields :: MonadError QErr m => FieldPrefix -> AnnFieldsG 'DataConnector Void (UnpreparedValue 'DataConnector) -> KeyMap FieldValue -> m Encoding
encodeAssocListAsObject :: [(Text, Encoding)] -> Encoding
reshapeField :: MonadError QErr m => AnnFieldG 'DataConnector Void (UnpreparedValue 'DataConnector) -> m FieldValue -> m Encoding
reshapeAnnRelationSelect :: MonadError QErr m => (Fields (fieldType (UnpreparedValue 'DataConnector)) -> QueryResponse -> m Encoding) -> AnnRelationSelectG 'DataConnector (AnnSelectG 'DataConnector fieldType (UnpreparedValue 'DataConnector)) -> FieldValue -> m Encoding
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.FieldsAndAggregates
instance GHC.Show.Show Hasura.Backends.DataConnector.Plan.FieldsAndAggregates
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.FieldPrefix
instance GHC.Show.Show Hasura.Backends.DataConnector.Plan.FieldPrefix
instance GHC.Base.Semigroup Hasura.Backends.DataConnector.Plan.FieldPrefix
instance GHC.Base.Monoid Hasura.Backends.DataConnector.Plan.FieldPrefix
instance GHC.Base.Semigroup Hasura.Backends.DataConnector.Plan.FieldsAndAggregates
instance GHC.Base.Monoid Hasura.Backends.DataConnector.Plan.FieldsAndAggregates

module Hasura.Backends.DataConnector.Adapter.Schema
experimentalBuildTableRelayQueryFields :: MonadBuildSchema 'DataConnector r m n => MkRootFieldName -> SourceInfo 'DataConnector -> TableName 'DataConnector -> TableInfo 'DataConnector -> GQLNameIdentifier -> NESeq (ColumnInfo 'DataConnector) -> m [FieldParser n a]
columnParser' :: (MonadParse n, MonadError QErr m) => ColumnType 'DataConnector -> Nullability -> m (Parser 'Both n (ValueWithOrigin (ColumnValue 'DataConnector)))
orderByOperators' :: SourceInfo 'DataConnector -> NamingCase -> (Name, NonEmpty (Definition EnumValueInfo, (BasicOrderType 'DataConnector, NullsOrderType 'DataConnector)))
comparisonExps' :: forall m n r. (BackendSchema 'DataConnector, MonadMemoize m, MonadParse n, MonadError QErr m, MonadReader r m, Has SchemaOptions r, Has NamingCase r) => ColumnType 'DataConnector -> m (Parser 'Input n [ComparisonExp 'DataConnector])
tableArgs' :: forall r m n. MonadBuildSchema 'DataConnector r m n => SourceInfo 'DataConnector -> TableInfo 'DataConnector -> m (InputFieldsParser n (SelectArgsG 'DataConnector (UnpreparedValue 'DataConnector)))
countTypeInput' :: MonadParse n => Maybe (Parser 'Both n Name) -> InputFieldsParser n (CountDistinct -> CountAggregate)
instance Hasura.GraphQL.Schema.Backend.BackendSchema 'Hasura.SQL.Backend.DataConnector
instance Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema 'Hasura.SQL.Backend.DataConnector

module Hasura.Backends.BigQuery.Instances.Schema
bqColumnParser :: (MonadParse n, MonadError QErr m, MonadReader r m, Has MkTypename r, Has NamingCase r) => ColumnType 'BigQuery -> Nullability -> m (Parser 'Both n (ValueWithOrigin (ColumnValue 'BigQuery)))
bqOrderByOperators :: NamingCase -> (Name, NonEmpty (Definition EnumValueInfo, (BasicOrderType 'BigQuery, NullsOrderType 'BigQuery)))
bqComparisonExps :: forall m n r. MonadBuildSchema 'BigQuery r m n => ColumnType 'BigQuery -> m (Parser 'Input n [ComparisonExp 'BigQuery])
bqCountTypeInput :: MonadParse n => Maybe (Parser 'Both n (Column 'BigQuery)) -> InputFieldsParser n (CountDistinct -> CountType 'BigQuery)
geographyWithinDistanceInput :: forall m n r. (MonadMemoize m, MonadBuildSchema 'BigQuery r m n) => m (Parser 'Input n (DWithinGeogOp (UnpreparedValue 'BigQuery)))

-- | Computed field parser.
bqComputedField :: forall r m n. MonadBuildSchema 'BigQuery r m n => SourceInfo 'BigQuery -> ComputedFieldInfo 'BigQuery -> TableName 'BigQuery -> TableInfo 'BigQuery -> m (Maybe (FieldParser n (AnnotatedField 'BigQuery)))
instance Hasura.GraphQL.Schema.Backend.BackendSchema 'Hasura.SQL.Backend.BigQuery
instance Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema 'Hasura.SQL.Backend.BigQuery

module Hasura.GraphQL.Schema.Instances

module Hasura.GraphQL.Schema.RemoteRelationship

-- | Remote relationship field parsers
remoteRelationshipField :: SourceCache -> RemoteSchemaMap -> RemoteSchemaPermissions -> RemoteRelationshipParserBuilder

-- | Parser(s) for remote relationship fields to a remote schema
remoteRelationshipToSchemaField :: forall r m n lhsJoinField. MonadBuildSchemaBase r m n => RemoteSchemaMap -> RemoteSchemaPermissions -> HashMap FieldName lhsJoinField -> RemoteSchemaFieldInfo -> m (Maybe (FieldParser n (RemoteSchemaSelect (RemoteRelationshipField UnpreparedValue))))
lookupNestedFieldType' :: (MonadMemoize m, MonadError QErr m) => Name -> RemoteSchemaIntrospection -> FieldCall -> m GType
lookupNestedFieldType :: (MonadMemoize m, MonadError QErr m) => Name -> RemoteSchemaIntrospection -> NonEmpty FieldCall -> m GType

-- | Parser(s) for remote relationship fields to a database table. Note
--   that when the target is a database table, an array relationship
--   declaration would have the <tt>_aggregate</tt> field in addition to
--   the array relationship field, hence [FieldParser ...] instead of
--   <a>FieldParser</a>
remoteRelationshipToSourceField :: forall r m n tgt. (MonadBuildSchemaBase r m n, BackendSchema tgt, BackendTableSelectSchema tgt) => SourceCache -> RemoteSourceFieldInfo tgt -> m [FieldParser n (RemoteSourceSelect (RemoteRelationshipField UnpreparedValue) UnpreparedValue tgt)]


-- | This module only exposes one function, <a>nodeField</a>, which is used
--   at the root level of the schema to create the <tt>node</tt> field in
--   the Relay API schema.
module Hasura.GraphQL.Schema.Relay

-- | Constructs the parser for the node interface.
--   
--   As mentioned in Note [Internal Relay HashMap], this function must
--   parse an incoming query for ANY potential matching table. Its
--   resulting parser returns a <a>NodeMap</a>: a container that, to a
--   source name and a table name, associates both the parsed fields and
--   all the relevant table information required to craft a request.
nodeInterface :: SourceCache -> NodeInterfaceParserBuilder

-- | Creates a field parser for the top-level "node" field in the
--   QueryRoot.
--   
--   It exepcts one argument, the node id. It looks for the targeted table
--   in the <a>NodeMap</a> returned by <a>nodeInterface</a>, and, if
--   successful, attempts to craft a corresponding <tt>QueryRootField</tt>
--   that will extract the requested row.
nodeField :: forall m n r. SourceCache -> MonadBuildSchemaBase r m n => m (FieldParser n (QueryRootField UnpreparedValue))

module Hasura.GraphQL.Schema

-- | Builds the full GraphQL context for a given query type.
--   
--   A <a>GQLContext</a> stores how an incoming request should be
--   processed: how to translate each incoming field of a request into a
--   corresponding semantic representation. There is a different one per
--   <tt>Role</tt>, as each role might have different permissions, and
--   therefore not access to the same set of objects in the schema.
--   
--   This function takes all necessary information from the metadata, and
--   the <a>GraphQLQueryType</a>, and builds all relevant contexts: a hash
--   map from <a>RoleName</a> to their <a>GQLContext</a> and the "default"
--   context for unauthenticated users.
--   
--   When building the schema for each role, we treat the remote schemas as
--   "second-class citizens" compared to sources; more specifically, we
--   attempt to detect whether the inclusion of a given remote schema would
--   result in root fields conflict, and only keep schemas that don't
--   generate any. This results in a partial schema being available to the
--   users, and a better error message than would arise from
--   <a>safeSelectionSet</a>.
buildGQLContext :: forall m. (MonadError QErr m, MonadIO m) => ServerConfigCtx -> GraphQLQueryType -> SourceCache -> HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject) -> ActionCache -> AnnotatedCustomTypes -> m (SchemaIntrospection, HashMap RoleName (RoleContext GQLContext), GQLContext, HashSet InconsistentMetadata)

-- | Build the <tt>QueryHasura</tt> context for a given role.
buildRoleContext :: forall m. (MonadError QErr m, MonadIO m) => (SQLGenCtx, InferFunctionPermissions) -> SourceCache -> HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject) -> [ActionInfo] -> AnnotatedCustomTypes -> RoleName -> RemoteSchemaPermissions -> HashSet ExperimentalFeature -> Maybe NamingCase -> m (RoleContext GQLContext, HashSet InconsistentMetadata, SchemaIntrospection)
buildRelayRoleContext :: forall m. (MonadError QErr m, MonadIO m) => (SQLGenCtx, InferFunctionPermissions) -> SourceCache -> [ActionInfo] -> AnnotatedCustomTypes -> RoleName -> HashSet ExperimentalFeature -> Maybe NamingCase -> m (RoleContext GQLContext)

-- | Builds the schema context for unauthenticated users.
--   
--   This context is used whenever the user queries the engine with a role
--   that is unknown, and therefore not present in the context map. Before
--   remote schema permissions were introduced, remotes were considered to
--   be a public entity, and we therefore allowed an unknown role also to
--   query the remotes. To maintain backwards compatibility, we check if
--   remote schema permissions are enabled; remote schemas will only be
--   available to unauthenticated users if permissions aren't enabled.
unauthenticatedContext :: forall m. (MonadError QErr m, MonadIO m) => HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject) -> RemoteSchemaPermissions -> m (GQLContext, HashSet InconsistentMetadata)
buildAndValidateRemoteSchemas :: forall m. (MonadError QErr m, MonadIO m) => HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject) -> [FieldParser Parse (NamespacedField (QueryRootField UnpreparedValue))] -> [FieldParser Parse (NamespacedField (MutationRootField UnpreparedValue))] -> RoleName -> RemoteSchemaPermissions -> ReaderT (SchemaContext, SchemaOptions, MkTypename, CustomizeRemoteFieldName, NamingCase) (MemoizeT m) ([RemoteSchemaParser Parse], HashSet InconsistentMetadata)
buildRemoteSchemaParser :: forall m. (MonadError QErr m, MonadIO m) => RemoteSchemaPermissions -> RoleName -> RemoteSchemaCtx -> ReaderT (SchemaContext, SchemaOptions, MkTypename, CustomizeRemoteFieldName, NamingCase) (MemoizeT m) (Maybe (RemoteSchemaParser Parse))

-- | <a>buildQueryAndSubscriptionFields</a> builds the query and the
--   subscription fields of the tables tracked in the source. The query
--   root fields and the subscription root fields may not be equal because
--   a root field may be enabled in the <tt>query_root_field</tt> and not
--   in the <tt>subscription_root_field</tt>, so a tuple of array of field
--   parsers corresponding to query field parsers and subscription field
--   parsers.
buildQueryAndSubscriptionFields :: forall b r m n. MonadBuildSchema b r m n => MkRootFieldName -> SourceInfo b -> TableCache b -> FunctionCache b -> m ([FieldParser n (QueryRootField UnpreparedValue)], [FieldParser n (SubscriptionRootField UnpreparedValue)], [(Name, Parser 'Output n (ApolloFederationParserFunction n))])
buildRelayQueryAndSubscriptionFields :: forall b r m n. MonadBuildSchema b r m n => MkRootFieldName -> SourceInfo b -> TableCache b -> FunctionCache b -> m ([FieldParser n (QueryRootField UnpreparedValue)], [FieldParser n (SubscriptionRootField UnpreparedValue)])
buildMutationFields :: forall b r m n. MonadBuildSchema b r m n => MkRootFieldName -> Scenario -> SourceInfo b -> TableCache b -> FunctionCache b -> m [FieldParser n (MutationRootField UnpreparedValue)]

-- | Prepare the parser for query-type GraphQL requests, but with
--   introspection for queries, mutations and subscriptions built in.
buildQueryParser :: forall n m. (MonadMemoize m, MonadError QErr m, MonadParse n) => [FieldParser n (NamespacedField (QueryRootField UnpreparedValue))] -> [FieldParser n (SchemaIntrospection -> QueryRootField UnpreparedValue)] -> [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> [FieldParser n (QueryRootField UnpreparedValue)] -> Maybe (Parser 'Output n (RootFieldMap (MutationRootField UnpreparedValue))) -> Maybe (Parser 'Output n (RootFieldMap (QueryRootField UnpreparedValue))) -> m (Parser 'Output n (RootFieldMap (QueryRootField UnpreparedValue)))

-- | Builds a <tt>Schema</tt> at query parsing time
parseBuildIntrospectionSchema :: MonadParse m => Type 'Output -> Maybe (Type 'Output) -> Maybe (Type 'Output) -> m Schema
queryWithIntrospectionHelper :: forall n m. (MonadMemoize m, MonadParse n, MonadError QErr m) => [FieldParser n (NamespacedField (QueryRootField UnpreparedValue))] -> Maybe (Parser 'Output n (RootFieldMap (MutationRootField UnpreparedValue))) -> Maybe (Parser 'Output n (RootFieldMap (QueryRootField UnpreparedValue))) -> m (Parser 'Output n (RootFieldMap (QueryRootField UnpreparedValue)))
queryRootFromFields :: forall n m. (MonadError QErr m, MonadParse n) => [FieldParser n (NamespacedField (QueryRootField UnpreparedValue))] -> m (Parser 'Output n (RootFieldMap (QueryRootField UnpreparedValue)))
buildMutationParser :: forall n m. (MonadMemoize m, MonadError QErr m, MonadParse n) => [FieldParser n (NamespacedField (MutationRootField UnpreparedValue))] -> [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> [FieldParser n (MutationRootField UnpreparedValue)] -> m (Maybe (Parser 'Output n (RootFieldMap (MutationRootField UnpreparedValue))))

-- | Prepare the parser for subscriptions. Every postgres query field is
--   exposed as a subscription along with fields to get the status of
--   asynchronous actions.
buildSubscriptionParser :: forall n m. (MonadMemoize m, MonadError QErr m, MonadParse n) => [FieldParser n (NamespacedField (QueryRootField UnpreparedValue))] -> [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> [FieldParser n (QueryRootField UnpreparedValue)] -> m (Maybe (Parser 'Output n (RootFieldMap (QueryRootField UnpreparedValue))))

-- | Calls <a>safeSelectionSet</a>, and rethrows any error as a
--   <a>QErr</a>.
safeSelectionSet :: forall n m a. (QErrM n, MonadParse m) => Name -> Maybe Description -> [FieldParser m a] -> n (Parser 'Output m (InsOrdHashMap Name (ParsedSelection a)))

-- | Apply a source's customization options to a list of its fields.
customizeFields :: forall f n db remote action. (Functor f, MonadParse n) => SourceCustomization -> MkTypename -> f [FieldParser n (RootField db remote action Value)] -> f [FieldParser n (NamespacedField (RootField db remote action Value))]

-- | All the <a>BackendSchema</a> methods produce something of the form
--   <tt>m [FieldParser n a]</tt>, where <tt>a</tt> is something specific
--   to what is being parsed by the given method.
--   
--   In order to build the complete schema these must be homogenised and be
--   annotated with query-tag data, which this function makes easy. This
--   function converts a single field parser. <tt>mkRootFields</tt>
--   transforms a list of field parsers.
mkRootField :: forall b n a db remote action raw. (HasTag b, Functor n) => SourceName -> SourceConfig b -> Maybe QueryTagsConfig -> (a -> db b) -> FieldParser n a -> FieldParser n (RootField db remote action raw)

-- | <a>mkRootFields</a> is <a>mkRootField</a> applied on a list of
--   <a>FieldParser</a>.
mkRootFields :: forall b m n a db remote action raw. (HasTag b, Functor m, Functor n) => SourceName -> SourceConfig b -> Maybe QueryTagsConfig -> (a -> db b) -> m [FieldParser n a] -> m [FieldParser n (RootField db remote action raw)]
takeExposedAs :: FunctionExposedAs -> FunctionCache b -> FunctionCache b
subscriptionRoot :: Name
mutationRoot :: Name
queryRoot :: Name
finalizeParser :: Parser 'Output Parse a -> ParserFn a
throwOnConflictingDefinitions :: QErrM m => Either ConflictingDefinitions a -> m a
typenameToNamespacedRawRF :: ParsedSelection (NamespacedField (RootField db remote action Value)) -> NamespacedField (RootField db remote action Value)
typenameToRawRF :: ParsedSelection (RootField db remote action Value) -> RootField db remote action Value


-- | Translate from the DML to the BigQuery dialect.
module Hasura.Backends.BigQuery.FromIr

-- | Most of these errors should be checked for legitimacy.
data Error
FromTypeUnsupported :: SelectFromG 'BigQuery Expression -> Error
NoOrderSpecifiedInOrderBy :: Error
MalformedAgg :: Error
FieldTypeUnsupportedForNow :: AnnFieldG 'BigQuery Void Expression -> Error
AggTypeUnsupportedForNow :: TableAggregateFieldG 'BigQuery Void Expression -> Error
NodesUnsupportedForNow :: TableAggregateFieldG 'BigQuery Void Expression -> Error
NoProjectionFields :: Error
NoAggregatesMustBeABug :: Error
UnsupportedArraySelect :: ArraySelectG 'BigQuery Void Expression -> Error
UnsupportedOpExpG :: OpExpG 'BigQuery Expression -> Error
UnsupportedSQLExp :: Expression -> Error
UnsupportedDistinctOn :: Error
UnexpectedEmptyList :: Error
InvalidIntegerishSql :: Expression -> Error
ConnectionsNotSupported :: Error
ActionsNotSupported :: Error

-- | <a>https://github.com/hasura/graphql-engine/issues/8526</a>
ComputedFieldsBooleanExpressionNotSupported :: Error

-- | <a>https://github.com/hasura/graphql-engine/issues/8526</a>
ComputedFieldsOrderByNotSupported :: Error

-- | <a>https://github.com/hasura/graphql-engine/issues/8521</a>
ScalarComputedFieldsNotSupported :: Error
NoParentEntityInternalError :: Error

-- | The base monad used throughout this module for all conversion
--   functions.
--   
--   It's a Validate, so it'll continue going when it encounters errors to
--   accumulate as many as possible.
--   
--   It also contains a mapping from entity prefixes to counters. So if my
--   prefix is "table" then there'll be a counter that lets me generate
--   table1, table2, etc. Same for any other prefix needed (e.g. names for
--   joins).
--   
--   A ReaderT is used around this in most of the module too, for setting
--   the current entity that a given field name refers to. See
--   <tt>fromColumn</tt>.
newtype FromIr a
FromIr :: ReaderT FromIrReader (StateT FromIrState (Validate (NonEmpty Error))) a -> FromIr a
[unFromIr] :: FromIr a -> ReaderT FromIrReader (StateT FromIrState (Validate (NonEmpty Error))) a
data FromIrState
FromIrState :: Map Text Int -> FromIrState
[indices] :: FromIrState -> Map Text Int
data FromIrReader
FromIrReader :: FromIrConfig -> FromIrReader
[config] :: FromIrReader -> FromIrConfig

-- | Config values for the from-IR translator.
data FromIrConfig
FromIrConfig :: Top -> FromIrConfig

-- | Applies globally to all selects, and may be reduced to something even
--   smaller by permission/user args.
[globalSelectLimit] :: FromIrConfig -> Top

-- | A default config.
defaultFromIrConfig :: FromIrConfig

-- | Alias of parent SELECT FROM. Functions underlying computed fields
--   requires column values from the table that is being used in FROM
--   clause of parent SELECT.
--   
--   Example SQL:
--   
--   <pre>
--   SELECT
--     `t_author1`.`id` AS `id`,
--     `t_author1`.`name` AS `name`,
--     ARRAY(
--       SELECT
--         AS STRUCT `id`,
--         `title`,
--         `content`
--       FROM
--         UNNEST(
--           ARRAY(
--             SELECT
--               AS STRUCT *
--             FROM `hasura_test`.`fetch_articles`(`id` =&gt; `t_author1`.`id`)
--           )
--         )
--         LIMIT 1000
--     ) AS `articles`
--   FROM
--     `hasura_test`.`author` AS `t_author1`
--   </pre>
--   
--   Where <tt>t_author1</tt> is the @<tt>ParentSelectFromIdentity</tt>
data ParentSelectFromEntity

-- | There's no parent entity
NoParentEntity :: ParentSelectFromEntity

-- | Alias of the parent SELECT FROM
ParentEntityAlias :: EntityAlias -> ParentSelectFromEntity
runFromIr :: FromIrConfig -> FromIr a -> Validate (NonEmpty Error) a
bigQuerySourceConfigToFromIrConfig :: BigQuerySourceConfig -> FromIrConfig

-- | Here is where we apply a top-level annotation to the select to
--   indicate to the data loader that this select ought to produce a single
--   object or an array.
mkSQLSelect :: JsonAggSelect -> AnnSelectG 'BigQuery (AnnFieldG 'BigQuery Void) Expression -> FromIr Select

-- | Convert from the IR database query into a select.
fromRootField :: QueryDB 'BigQuery Void Expression -> FromIr Select
fromUnnestedJSON :: Expression -> [(ColumnName, ScalarType)] -> [FieldName] -> FromIr From
fromSelectRows :: ParentSelectFromEntity -> AnnSelectG 'BigQuery (AnnFieldG 'BigQuery Void) Expression -> FromIr PartitionableSelect

-- | Simulates DISTINCT ON for BigQuery using ROW_NUMBER() partitioned over
--   distinct fields
--   
--   Example:
--   
--   For a GraphQL query: <tt> hasura_test_article(distinct_on: author_id,
--   order_by: [{author_id: asc}, {created_at: asc}]) { id title } </tt>
--   
--   it should produce from a query without a <tt>distinct_on</tt> clause:
--   
--   SELECT <a>id</a>, <tt>title</tt> FROM
--   <tt>hasura_test</tt>.<tt>article</tt> ORDER BY <tt>author_id</tt> ASC,
--   <tt>created_at</tt> ASC
--   
--   a query of the following form:
--   
--   SELECT <a>id</a>, <tt>title</tt> FROM (SELECT *, ROW_NUMBER() OVER
--   (PARTITION BY <tt>author_id</tt> ORDER BY <tt>created_at</tt> ASC) as
--   <tt>idx1</tt> FROM <tt>hasura_test</tt>.<tt>article</tt>) as
--   <tt>t_article1</tt> WHERE (<tt>t_article1</tt>.<tt>idx1</tt> = 1)
--   ORDER BY <tt>t_article1</tt>.<tt>author_id</tt> ASC
--   
--   Note: this method returns PartitionableSelect as it could be joined
--   using an array relation which requires extra fields added to the
--   PARTITION BY clause to return proper results
simulateDistinctOn :: Select -> NonEmpty ColumnName -> Maybe (NonEmpty OrderBy) -> FromIr PartitionableSelect
fromSelectAggregate :: Maybe (EntityAlias, HashMap ColumnName ColumnName) -> AnnSelectG 'BigQuery (TableAggregateFieldG 'BigQuery Void) Expression -> FromIr Select
data Args
Args :: Where -> Maybe (NonEmpty OrderBy) -> [Join] -> Top -> Maybe Int64 -> Maybe (NonEmpty ColumnName) -> Map TableName EntityAlias -> Args
[argsWhere] :: Args -> Where
[argsOrderBy] :: Args -> Maybe (NonEmpty OrderBy)
[argsJoins] :: Args -> [Join]
[argsTop] :: Args -> Top
[argsOffset] :: Args -> Maybe Int64
[argsDistinct] :: Args -> Maybe (NonEmpty ColumnName)
[argsExistingJoins] :: Args -> Map TableName EntityAlias
data UnfurledJoin
UnfurledJoin :: Join -> Maybe (TableName, EntityAlias) -> UnfurledJoin
[unfurledJoin] :: UnfurledJoin -> Join

-- | Recorded if we joined onto an object relation.
[unfurledObjectTableAlias] :: UnfurledJoin -> Maybe (TableName, EntityAlias)
fromSelectArgsG :: SelectArgsG 'BigQuery Expression -> ReaderT EntityAlias FromIr Args

-- | Produce a valid ORDER BY construct, telling about any joins needed on
--   the side.
fromAnnotatedOrderByItemG :: AnnotatedOrderByItemG 'BigQuery Expression -> WriterT (Seq UnfurledJoin) (ReaderT EntityAlias FromIr) OrderBy

-- | Unfurl the nested set of object relations (tell'd in the writer) that
--   are terminated by field name (Ir.AOCColumn and
--   Ir.AOCArrayAggregation).
unfurlAnnotatedOrderByElement :: AnnotatedOrderByElement 'BigQuery Expression -> WriterT (Seq UnfurledJoin) (ReaderT EntityAlias FromIr) FieldName
tableNameText :: TableName -> Text

-- | This is really the start where you query the base table, everything
--   else is joins attached to it.
fromQualifiedTable :: TableName -> FromIr From

-- | Build a @<a>From</a> expression out of a function that returns a set
--   of rows.
fromFunction :: ParentSelectFromEntity -> FunctionName -> [ArgumentExp Expression] -> HashMap Text (ArgumentExp Expression) -> FromIr From
fromAnnBoolExp :: GBoolExp 'BigQuery (AnnBoolExpFld 'BigQuery Expression) -> ReaderT EntityAlias FromIr Expression
fromAnnBoolExpFld :: AnnBoolExpFld 'BigQuery Expression -> ReaderT EntityAlias FromIr Expression
fromColumnInfo :: ColumnInfo 'BigQuery -> ReaderT EntityAlias FromIr FieldName
fromGExists :: GExists 'BigQuery Expression -> ReaderT EntityAlias FromIr Select
data FieldSource
ExpressionFieldSource :: Aliased Expression -> FieldSource
JoinFieldSource :: Aliased Join -> FieldSource
AggregateFieldSource :: Text -> NonEmpty (Aliased Aggregate) -> FieldSource
ArrayAggFieldSource :: Aliased ArrayAgg -> Maybe [FieldSource] -> FieldSource
fromTableAggregateFieldG :: Args -> Top -> (FieldName, TableAggregateFieldG 'BigQuery Void Expression) -> ReaderT EntityAlias FromIr FieldSource
fromAggregateField :: AggregateField 'BigQuery -> ReaderT EntityAlias FromIr Aggregate

-- | The main sources of fields, either constants, fields or via joins.
fromAnnFieldsG :: Map TableName EntityAlias -> (FieldName, AnnFieldG 'BigQuery Void Expression) -> ReaderT EntityAlias FromIr FieldSource

-- | Here is where we project a field as a column expression. If number
--   stringification is on, then we wrap it in a <a>ToStringExpression</a>
--   so that it's casted when being projected.
fromAnnColumnField :: AnnColumnField 'BigQuery Expression -> ReaderT EntityAlias FromIr Expression

-- | This is where a field name "foo" is resolved to a fully qualified
--   field name [table].[foo]. The table name comes from EntityAlias in the
--   ReaderT.
fromColumn :: ColumnName -> ReaderT EntityAlias FromIr FieldName
fieldSourceProjections :: Bool -> FieldSource -> FromIr (NonEmpty Projection)
fieldSourceJoins :: FieldSource -> Maybe [Join]

-- | Produce the join for an object relation. We produce a normal select,
--   but then include join fields. Then downstream, the DataLoader will
--   execute the lhs select and rhs join in separate server queries, then
--   do a Haskell-native join on the join fields.
--   
--   See also <a>fromArrayRelationSelectG</a> for similar example.
fromObjectRelationSelectG :: Map TableName EntityAlias -> ObjectRelationSelectG 'BigQuery Void Expression -> ReaderT EntityAlias FromIr Join
_lookupTableFrom :: Map TableName EntityAlias -> TableName -> FromIr (Either EntityAlias From)
fromArraySelectG :: ArraySelectG 'BigQuery Void Expression -> ReaderT EntityAlias FromIr Join

-- | Generate a select field @<a>Expression</a> for a computed field
--   
--   <pre>
--   ARRAY(
--     SELECT
--       AS STRUCT
--       `column_1`,
--       `column_2`,
--       `column_3`
--     FROM
--       UNNEST(
--         ARRAY(
--             SELECT AS STRUCT *
--             FROM `dataset`.`function_name`(`argument_name` =&gt; `parent_entity`.`column`)
--         )
--       )
--     LIMIT 1000 -- global limit
--   ) AS `field_name`
--   </pre>
--   
--   Using <tt>LIMIT</tt> right after 'FROM <a>function</a>' expression
--   raises query exception. To avoid this problem, we are packing and
--   unpacking the rows returned from the function using <tt>ARRAY</tt> and
--   <tt>UNNEST</tt>, then applying LIMIT. Somehow this is working with
--   exact reason being unknown. See
--   <a>https://github.com/hasura/graphql-engine/issues/8562</a> for more
--   details.
fromComputedFieldSelect :: ComputedFieldSelect 'BigQuery Void Expression -> ReaderT EntityAlias FromIr Expression

-- | Produce the join for an array aggregate relation. We produce a normal
--   select, but then include join fields. Then downstream, the DataLoader
--   will execute the lhs select and rhs join in separate server queries,
--   then do a Haskell-native join on the join fields.
--   
--   See also <a>fromArrayRelationSelectG</a> for similar example.
fromArrayAggregateSelectG :: AnnRelationSelectG 'BigQuery (AnnAggregateSelectG 'BigQuery Void Expression) -> ReaderT EntityAlias FromIr Join

-- | Produce a join for an array relation.
--   
--   Array relations in PG/MSSQL are expressed using LEFT OUTER JOIN
--   LATERAL or OUTER APPLY, which are essentially producing for each row
--   on the left an array of the result from the right. Which is absolutely
--   what you want for the array relationship.
--   
--   BigQuery doesn't support that. Therefore we are instead performing one
--   big array aggregation, for ALL rows in the table - there is no join
--   occurring on the left-hand-side table, grouped by join fields. The
--   data-loader will perform the LHS query and the RHS query separately.
--   
--   What we do have is a GROUP BY and make sure that the join fields are
--   included in the output. Finally, in the
--   DataLoader.Plan/DataLoader.Execute, we implement a Haskell-native join
--   of the left-hand-side table and the right-hand-side table.
--   
--   Data looks like:
--   
--   join_field_a | join_field_b | aggFieldName (array type) 1 | 1 | [ { x:
--   1, y: 2 }, ... ] 1 | 2 | [ { x: 1, y: 2 }, ... ]
--   
--   etc.
--   
--   We want to produce a query that looks like:
--   
--   SELECT artist_other_id, -- For joining.
--   
--   array_agg(struct(album_self_id, title)) as aggFieldName
--   
--   <ul>
--   <li>- ^ Aggregating the actual data.</li>
--   </ul>
--   
--   FROM (SELECT *, -- Get everything, plus the row number:
--   
--   ROW_NUMBER() OVER(PARTITION BY artist_other_id) artist_album_index
--   
--   FROM hasura.Album ORDER BY album_self_id ASC
--   
--   <ul>
--   <li>- ^ Order by here is important for stable results. Any order by
--   clauses for the album should appear here, NOT IN THE ARRAY_AGG.</li>
--   </ul>
--   
--   )
--   
--   AS indexed_album
--   
--   WHERE artist_album_index &gt; 1 -- ^ Here is where offsetting occurs.
--   
--   GROUP BY artist_other_id -- ^ Group by for joining.
--   
--   ORDER BY artist_other_id; ^ Ordering for the artist table should
--   appear here.
--   
--   Note: if original select already uses a PARTITION BY internally (for
--   distinct_on) join fields are added to partition expressions to give
--   proper semantics of distinct_on combined with an array relation
fromArrayRelationSelectG :: ArrayRelationSelectG 'BigQuery Void Expression -> ReaderT EntityAlias FromIr Join

-- | For entity projections, convert any entity aliases to their field
--   names. ArrayEntityProjection and ExpressionProjection get converted to
--   aliases to fields with the same names as all the expressions have
--   already aliases applied in select from ArrayAgg (created in
--   Hasura.Backends.BigQuery.ToQuery.fromArrayAgg)
aliasToFieldProjection :: EntityAlias -> Projection -> Projection
fromRelName :: RelName -> FromIr Text

-- | The context given by the reader is of the previous/parent "remote"
--   table. The WHERE that we're generating goes in the child, "local"
--   query. The <tt>From</tt> passed in as argument is the local table.
--   
--   We should hope to see e.g. "post.category = category.id" for a local
--   table of post and a remote table of category.
--   
--   The left/right columns in <tt>HashMap ColumnName ColumnName</tt>
--   corresponds to the left/right of <tt>select ... join ...</tt>.
--   Therefore left=remote, right=local in this context.
fromMapping :: From -> HashMap ColumnName ColumnName -> ReaderT EntityAlias FromIr [Expression]

-- | Given an alias for the remote table, and a map of local-to-remote
--   column name pairings, produce <a>FieldName</a> pairings (column names
--   paired with their associated table names).
--   
--   For example, we might convert the following:
--   
--   <pre>
--   [ ( ColumnName { columnName = "author_id" }
--     , ColumnName { columnName = "id" }
--     )
--   ]
--   </pre>
--   
--   ... into something like this:
--   
--   <pre>
--   ( FieldName
--       { fieldName = "id"
--       , fieldNameEntity = "t_author1"
--       }
--   , FieldName
--       { fieldName = "author_id"
--       , fieldNameEntity = "t_article1"
--       }
--   )
--   </pre>
--   
--   Note that the columns <b>flip around</b> for the output. The input map
--   is <tt>(local, remote)</tt>.
fromMappingFieldNames :: EntityAlias -> HashMap ColumnName ColumnName -> ReaderT EntityAlias FromIr [(FieldName, FieldName)]
fromOpExpG :: Expression -> OpExpG 'BigQuery Expression -> FromIr Expression
fromBackendSpecificOpExpG :: Expression -> BooleanOperators Expression -> Expression
nullableBoolEquality :: Expression -> Expression -> Expression
nullableBoolInequality :: Expression -> Expression -> Expression
fromGBoolExp :: GBoolExp 'BigQuery Expression -> ReaderT EntityAlias FromIr Expression

-- | Attempt to refine a list into a <a>NonEmpty</a>. If the given list is
--   empty, this will <a>refute</a> the computation with an
--   <a>UnexpectedEmptyList</a> error.
toNonEmpty :: MonadValidate (NonEmpty Error) m => [x] -> m (NonEmpty x)

-- | Get the remote field from a pair (see <a>fromMappingFieldNames</a> for
--   more information) and produce a <a>Projection</a>.
prepareJoinFieldProjection :: (FieldName, FieldName) -> Projection
selectProjectionsFromFieldSources :: Bool -> [FieldSource] -> FromIr (NonEmpty Projection)
trueExpression :: Expression
aggFieldName :: Text
existsFieldName :: Text
data NameTemplate
ArrayRelationTemplate :: Text -> NameTemplate
ArrayAggregateTemplate :: Text -> NameTemplate
ObjectRelationTemplate :: Text -> NameTemplate
TableTemplate :: Text -> NameTemplate
ForOrderAlias :: Text -> NameTemplate
IndexTemplate :: NameTemplate
UnnestTemplate :: NameTemplate
FunctionTemplate :: FunctionName -> NameTemplate
generateEntityAlias :: NameTemplate -> FromIr EntityAlias
fromAlias :: From -> EntityAlias
fieldTextNames :: AnnFieldsG 'BigQuery Void Expression -> [Text]
unEntityAlias :: EntityAlias -> Text
getGlobalTop :: FromIr Top
instance Control.Monad.Validate.Class.MonadValidate (GHC.Base.NonEmpty Hasura.Backends.BigQuery.FromIr.Error) Hasura.Backends.BigQuery.FromIr.FromIr
instance GHC.Base.Monad Hasura.Backends.BigQuery.FromIr.FromIr
instance GHC.Base.Applicative Hasura.Backends.BigQuery.FromIr.FromIr
instance GHC.Base.Functor Hasura.Backends.BigQuery.FromIr.FromIr
instance GHC.Show.Show Hasura.Backends.BigQuery.FromIr.Args
instance GHC.Show.Show Hasura.Backends.BigQuery.FromIr.UnfurledJoin
instance GHC.Show.Show Hasura.Backends.BigQuery.FromIr.FieldSource
instance GHC.Classes.Eq Hasura.Backends.BigQuery.FromIr.FieldSource
instance GHC.Show.Show Hasura.Backends.BigQuery.FromIr.Error


-- | Planning T-SQL queries and subscriptions.
module Hasura.Backends.BigQuery.Plan
planNoPlan :: MonadError QErr m => FromIrConfig -> UserInfo -> QueryDB 'BigQuery Void (UnpreparedValue 'BigQuery) -> m Select

-- | Prepare a value without any query planning; we just execute the query
--   with the values embedded.
prepareValueNoPlan :: MonadError QErr m => SessionVariables -> UnpreparedValue 'BigQuery -> m Expression


-- | Execute a Select query against the BigQuery REST API.
module Hasura.Backends.BigQuery.Execute

-- | A set of records produced by the database. These are joined together.
--   There are all sorts of optimizations possible here, from using a
--   matrix/flat vector, unboxed sums for Value, etc. Presently we choose a
--   naive implementation in the interest of getting other work done.
data RecordSet
RecordSet :: Vector (InsOrdHashMap FieldNameText OutputValue) -> Maybe [Text] -> RecordSet
[$sel:rows:RecordSet] :: RecordSet -> Vector (InsOrdHashMap FieldNameText OutputValue)
[$sel:wantedFields:RecordSet] :: RecordSet -> Maybe [Text]

-- | As opposed to BigQuery.FieldName which is a qualified name, this is
--   just the unqualified text name itself.
newtype FieldNameText
FieldNameText :: Text -> FieldNameText
data OutputValue
DecimalOutputValue :: Decimal -> OutputValue
BigDecimalOutputValue :: BigDecimal -> OutputValue
IntegerOutputValue :: Int64 -> OutputValue
FloatOutputValue :: Float64 -> OutputValue
GeographyOutputValue :: Geography -> OutputValue
TextOutputValue :: Text -> OutputValue
TimestampOutputValue :: Timestamp -> OutputValue
DateOutputValue :: Date -> OutputValue
TimeOutputValue :: Time -> OutputValue
DatetimeOutputValue :: Datetime -> OutputValue
BytesOutputValue :: Base64 -> OutputValue
BoolOutputValue :: Bool -> OutputValue
ArrayOutputValue :: Vector OutputValue -> OutputValue
RecordOutputValue :: InsOrdHashMap FieldNameText OutputValue -> OutputValue
NullOutputValue :: OutputValue
data ExecuteReader
ExecuteReader :: BigQuerySourceConfig -> ExecuteReader
[$sel:sourceConfig:ExecuteReader] :: ExecuteReader -> BigQuerySourceConfig
data ExecuteProblem
GetJobDecodeProblem :: String -> ExecuteProblem
CreateQueryJobDecodeProblem :: String -> ExecuteProblem
InsertDatasetDecodeProblem :: String -> ExecuteProblem
ExecuteRunBigQueryProblem :: BigQueryProblem -> ExecuteProblem
RESTRequestNonOK :: Status -> Value -> ExecuteProblem

-- | We use this to hide certain details from the front-end, while allowing
--   them in tests. We have not actually decided whether showing the
--   details is insecure, but until we decide otherwise, it's probably best
--   to err on the side of caution.
data ShowDetails
HideDetails :: ShowDetails
InsecurelyShowDetails :: ShowDetails
executeProblemMessage :: ShowDetails -> ExecuteProblem -> Text

-- | Execute monad; as queries are performed, the record sets are stored in
--   the map.
newtype Execute a
Execute :: ReaderT ExecuteReader (ExceptT ExecuteProblem IO) a -> Execute a
[$sel:unExecute:Execute] :: Execute a -> ReaderT ExecuteReader (ExceptT ExecuteProblem IO) a

-- | Big query parameters must be accompanied by an explicit type
--   signature.
data BigQueryType
DECIMAL :: BigQueryType
INTEGER :: BigQueryType
FLOAT :: BigQueryType
BYTES :: BigQueryType
STRING :: BigQueryType
BOOL :: BigQueryType
ARRAY :: BigQueryType -> BigQueryType
GEOGRAPHY :: BigQueryType
DATE :: BigQueryType
TIMESTAMP :: BigQueryType
DATETIME :: BigQueryType
TIME :: BigQueryType
BIGDECIMAL :: BigQueryType
data BigQuery
BigQuery :: Text -> InsOrdHashMap ParameterName Parameter -> BigQuery
[$sel:query:BigQuery] :: BigQuery -> Text
[$sel:parameters:BigQuery] :: BigQuery -> InsOrdHashMap ParameterName Parameter
data Parameter
Parameter :: BigQueryType -> Value -> Parameter
[$sel:typ:Parameter] :: Parameter -> BigQueryType
[$sel:value:Parameter] :: Parameter -> Value
newtype ParameterName
ParameterName :: Text -> ParameterName
data BigQueryField
BigQueryField :: FieldNameText -> BigQueryFieldType -> Mode -> BigQueryField
[$sel:name:BigQueryField] :: BigQueryField -> FieldNameText
[$sel:typ:BigQueryField] :: BigQueryField -> BigQueryFieldType
[$sel:mode:BigQueryField] :: BigQueryField -> Mode
data BigQueryFieldType
FieldSTRING :: BigQueryFieldType
FieldBYTES :: BigQueryFieldType
FieldINTEGER :: BigQueryFieldType
FieldFLOAT :: BigQueryFieldType
FieldBOOL :: BigQueryFieldType
FieldTIMESTAMP :: BigQueryFieldType
FieldDATE :: BigQueryFieldType
FieldTIME :: BigQueryFieldType
FieldDATETIME :: BigQueryFieldType
FieldGEOGRAPHY :: BigQueryFieldType
FieldDECIMAL :: BigQueryFieldType
FieldBIGDECIMAL :: BigQueryFieldType
FieldSTRUCT :: Vector BigQueryField -> BigQueryFieldType
data Mode
Nullable :: Mode
NotNullable :: Mode
Repeated :: Mode
data IsNullable
IsNullable :: IsNullable
IsRequired :: IsNullable

-- | Delay between attempts to get job results if the job is incomplete.
streamDelaySeconds :: DiffTime
bigQueryProjectUrl :: Text -> String
runExecute :: MonadIO m => BigQuerySourceConfig -> Execute RecordSet -> m (Either ExecuteProblem RecordSet)
executeSelect :: Select -> Execute RecordSet

-- | This is needed to strip out unneeded fields (join keys) in the final
--   query. This is a relic of the data loader approach. A later
--   improvement would be to update the FromIr code to explicitly reselect
--   the query. But the purpose of this commit is to drop the dataloader
--   code and not modify the from IR code which is more delicate.
getFinalRecordSet :: RecordSet -> Execute RecordSet
selectToBigQuery :: Select -> BigQuery

-- | Make a BigQuery type for the given value.
valueType :: Value -> BigQueryType

-- | Make a JSON representation of the type of the given value.
valueToBigQueryJson :: Value -> Value

-- | TODO: WARNING: This function hasn't been tested on Big Data(tm), and
--   therefore I was unable to get BigQuery to produce paginated results
--   that would contain the <a>$sel:pageToken:JobResults</a> field in the
--   JSON response. Until that test has been done, we should consider this
--   a preliminary implementation.
streamBigQuery :: MonadIO m => BigQueryConnection -> BigQuery -> m (Either ExecuteProblem RecordSet)

-- | Execute a query without expecting any output (e.g. CREATE TABLE or
--   INSERT)
executeBigQuery :: MonadIO m => BigQueryConnection -> BigQuery -> m (Either ExecuteProblem ())
data JobResults
JobResults :: Maybe Text -> RecordSet -> JobResults
[$sel:pageToken:JobResults] :: JobResults -> Maybe Text
[$sel:recordSet:JobResults] :: JobResults -> RecordSet
data JobResultsResponse
JobIncomplete :: JobResultsResponse
JobComplete :: JobResults -> JobResultsResponse
data Fetch
Fetch :: Maybe Text -> Fetch
[$sel:pageToken:Fetch] :: Fetch -> Maybe Text

-- | Get results of a job.
getJobResults :: MonadIO m => BigQueryConnection -> Job -> Fetch -> m (Either ExecuteProblem JobResultsResponse)
data Job
Job :: Text -> Text -> Text -> Job
[$sel:state:Job] :: Job -> Text
[$sel:jobId:Job] :: Job -> Text
[$sel:location:Job] :: Job -> Text

-- | Make a Request return <tt>JSON</tt>
jsonRequestHeader :: Request -> Request

-- | Create a job asynchronously.
createQueryJob :: (MonadError ExecuteProblem m, MonadIO m) => BigQueryConnection -> BigQuery -> m Job
data Dataset
Dataset :: Text -> Dataset
[$sel:datasetId:Dataset] :: Dataset -> Text

-- | Delete a dataset
deleteDataset :: (MonadError ExecuteProblem m, MonadIO m) => BigQueryConnection -> Text -> m ()

-- | Run request and map errors into ExecuteProblem
runBigQueryExcept :: (MonadError ExecuteProblem m, MonadIO m) => BigQueryConnection -> Request -> m (Response ByteString)

-- | Insert a new dataset
insertDataset :: (MonadError ExecuteProblem m, MonadIO m) => BigQueryConnection -> Text -> m Dataset

-- | Parse given @<tt>ByteString</tt> as JSON value. If not a valid JSON,
--   encode to plain text.
parseAsJsonOrText :: ByteString -> Value
parseRecordSetPayload :: Object -> Parser RecordSet
parseRow :: Vector BigQueryField -> Value -> Parser (InsOrdHashMap FieldNameText OutputValue)

-- | Parse a row, which at the top-level of the "rows" output has no
--   {"v":..} wrapper. But when appearing nestedly, does have the wrapper.
--   See <a>parseBigQueryValue</a>.
parseBigQueryRow :: Vector BigQueryField -> Value -> Parser OutputValue
parseBigQueryValue :: IsNullable -> BigQueryFieldType -> Value -> Parser OutputValue

-- | Parse upstream timestamp value in epoch milliseconds and convert it to
--   calendar date time format
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#timestamp_type</a>
parseTimestamp :: Value -> Parser Timestamp
parseBigQueryField :: BigQueryField -> Value -> Parser (FieldNameText, OutputValue)
has_v :: IsNullable -> (Value -> Parser OutputValue) -> Value -> Parser OutputValue
has_v_generic :: (Value -> Parser a) -> Value -> Parser a
instance Data.String.IsString Hasura.Backends.BigQuery.Execute.FieldNameText
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Execute.FieldNameText
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.FieldNameText
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Execute.FieldNameText
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Execute.FieldNameText
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Execute.FieldNameText
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.FieldNameText
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Execute.OutputValue
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Execute.OutputValue
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.OutputValue
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.RecordSet
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Execute.ExecuteProblem
instance Control.Monad.Error.Class.MonadError Hasura.Backends.BigQuery.Execute.ExecuteProblem Hasura.Backends.BigQuery.Execute.Execute
instance Control.Monad.IO.Class.MonadIO Hasura.Backends.BigQuery.Execute.Execute
instance Control.Monad.Reader.Class.MonadReader Hasura.Backends.BigQuery.Execute.ExecuteReader Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Base.Monad Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Base.Applicative Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Base.Functor Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Execute.BigQueryType
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.BigQueryType
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.Parameter
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Execute.ParameterName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Execute.ParameterName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Execute.ParameterName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Execute.ParameterName
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.ParameterName
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.BigQuery
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.Mode
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.BigQueryFieldType
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.BigQueryField
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.JobResults
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.JobResultsResponse
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.Fetch
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.Job
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.Dataset
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.Dataset
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.Job
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.JobResultsResponse
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.JobResults
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.BigQueryField
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.Mode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Execute.BigQueryType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Execute.ExecuteProblem
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Execute.OutputValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Execute.OutputValue

module Hasura.Backends.BigQuery.DDL.Source
defaultGlobalSelectLimit :: Int64
defaultRetryLimit :: Int
defaultRetryBaseDelay :: Microseconds
resolveSourceConfig :: MonadIO m => Logger Hasura -> SourceName -> BigQueryConnSourceConfig -> BackendSourceKind 'BigQuery -> BackendConfig 'BigQuery -> Environment -> manager -> m (Either QErr BigQuerySourceConfig)
readNonNegative :: (MonadError QErr m, Num a, Ord a, FromJSON a, Read a) => Text -> Text -> m a
resolveSource :: MonadIO m => BigQuerySourceConfig -> SourceTypeCustomization -> m (Either QErr (ResolvedSource 'BigQuery))
restTypeToScalarType :: RestType -> ScalarType
restTableReferenceToTableName :: RestTableReference -> TableName
postDropSourceHook :: MonadIO m => BigQuerySourceConfig -> TableEventTriggers 'BigQuery -> m ()


-- | BigQuery DDL ComputedField
--   
--   Implementation to build <a>ComputedFieldInfo</a> for a BigQuery table
--   from metadata
module Hasura.Backends.BigQuery.DDL.ComputedField

-- | Errors that occur when validating and building computed fields.
data ComputedFieldError
CFENoArgumentType :: FunctionArgName -> ComputedFieldError
CFENotTableValuedFunction :: ComputedFieldError
CFENoInputArguments :: ComputedFieldError
CFENoArgumentName :: ComputedFieldError
CFEInvalidArgumentName :: FunctionArgName -> ComputedFieldError
CFEInvalidColumnName :: TableName -> ColumnName -> ComputedFieldError
CFEReturnTableNotTracked :: TableName -> ComputedFieldError
CFENeedReturnTableName :: ComputedFieldError
CFENotRelevantReturnTable :: TableName -> ComputedFieldError
CFEReturnTableSchemaError :: ReturnTableSchemaError -> ComputedFieldError

-- | Errors that occur when validating returning table schema fields
data ReturnTableSchemaError
RTSENoFieldName :: ReturnTableSchemaError
RTSENoType :: Text -> ReturnTableSchemaError
RTSENotValidGraphQLName :: Text -> ReturnTableSchemaError

-- | Generate read-able error message
showError :: FunctionName -> ComputedFieldError -> Text

-- | Validate computed field metadata and build field information
buildComputedFieldInfo :: forall m. MonadError QErr m => HashSet TableName -> TableName -> HashSet ColumnName -> ComputedFieldName -> ComputedFieldDefinition -> RestRoutine -> Comment -> m (ComputedFieldInfo 'BigQuery)

module Hasura.Backends.BigQuery.DDL.BoolExp
parseBoolExpOperations :: forall m v. MonadError QErr m => ValueParser 'BigQuery m v -> TableName -> FieldInfoMap (FieldInfo 'BigQuery) -> ColumnReference 'BigQuery -> Value -> m [OpExpG 'BigQuery v]

module Hasura.Backends.BigQuery.DDL
fetchAndValidateEnumValues :: Monad m => SourceConfig 'BigQuery -> TableName 'BigQuery -> Maybe (PrimaryKey 'BigQuery (RawColumnInfo 'BigQuery)) -> [RawColumnInfo 'BigQuery] -> m (Either QErr EnumValues)
buildFunctionInfo :: MonadError QErr m => SourceName -> FunctionName 'BigQuery -> SystemDefined -> FunctionConfig -> FunctionPermissionsMap -> RawFunctionInfo 'BigQuery -> Maybe Text -> NamingCase -> m (FunctionInfo 'BigQuery, SchemaDependency)
updateColumnInEventTrigger :: TableName 'BigQuery -> Column 'BigQuery -> Column 'BigQuery -> TableName 'BigQuery -> EventTriggerConf 'BigQuery -> EventTriggerConf 'BigQuery
parseCollectableType :: MonadError QErr m => CollectableType (ColumnType 'BigQuery) -> Value -> m (PartialSQLExp 'BigQuery)
mkTypedSessionVar :: CollectableType (ColumnType 'BigQuery) -> SessionVariable -> PartialSQLExp 'BigQuery
msColumnTypeToScalarType :: ColumnType 'BigQuery -> ScalarType 'BigQuery

module Hasura.Backends.BigQuery.Instances.Metadata
instance Hasura.RQL.Types.Metadata.Backend.BackendMetadata 'Hasura.SQL.Backend.BigQuery

module Hasura.RQL.Types.Metadata.Instances


-- | Telemetry types
--   
--   Define anonymized metrics regarding usage of various features of
--   Hasura.
module Hasura.Server.Telemetry.Types
data RelationshipMetric
RelationshipMetric :: Int -> Int -> RelationshipMetric
[_rmManual] :: RelationshipMetric -> Int
[_rmAuto] :: RelationshipMetric -> Int
data PermissionMetric
PermissionMetric :: Int -> Int -> Int -> Int -> Int -> PermissionMetric
[_pmSelect] :: PermissionMetric -> Int
[_pmInsert] :: PermissionMetric -> Int
[_pmUpdate] :: PermissionMetric -> Int
[_pmDelete] :: PermissionMetric -> Int
[_pmRoles] :: PermissionMetric -> Int
data ActionMetric
ActionMetric :: Int -> Int -> Int -> Int -> Int -> ActionMetric
[_amSynchronous] :: ActionMetric -> Int
[_amAsynchronous] :: ActionMetric -> Int
[_amQueryActions] :: ActionMetric -> Int
[_amTypeRelationships] :: ActionMetric -> Int
[_amCustomTypes] :: ActionMetric -> Int
data Metrics
Metrics :: Int -> Int -> Int -> RelationshipMetric -> PermissionMetric -> Int -> Int -> Maybe Int -> Maybe ServiceTimingMetrics -> Maybe ActionMetric -> Metrics
[_mtTables] :: Metrics -> Int
[_mtViews] :: Metrics -> Int
[_mtEnumTables] :: Metrics -> Int
[_mtRelationships] :: Metrics -> RelationshipMetric
[_mtPermissions] :: Metrics -> PermissionMetric
[_mtEventTriggers] :: Metrics -> Int
[_mtFunctions] :: Metrics -> Int
[_mtRemoteSchemas] :: Metrics -> Maybe Int
[_mtServiceTimings] :: Metrics -> Maybe ServiceTimingMetrics
[_mtActions] :: Metrics -> Maybe ActionMetric
data SourceMetadata
SourceMetadata :: Maybe DbUid -> BackendType -> Maybe DbVersion -> SourceMetadata
[_smDbUid] :: SourceMetadata -> Maybe DbUid
[_smDbKind] :: SourceMetadata -> BackendType
[_smDbVersion] :: SourceMetadata -> Maybe DbVersion
data HasuraTelemetry
HasuraTelemetry :: MetadataDbId -> InstanceId -> Version -> Maybe CI -> SourceMetadata -> Metrics -> HasuraTelemetry
[_htMetadataDbUid] :: HasuraTelemetry -> MetadataDbId
[_htInstanceUid] :: HasuraTelemetry -> InstanceId
[_htHasuraVersion] :: HasuraTelemetry -> Version
[_htCi] :: HasuraTelemetry -> Maybe CI
[_htSourceMetadata] :: HasuraTelemetry -> SourceMetadata
[_htMetrics] :: HasuraTelemetry -> Metrics

-- | The telemetry table to which we'll add telemetry.
newtype Topic
Topic :: Text -> Topic
[getTopic] :: Topic -> Text
data TelemetryPayload
TelemetryPayload :: Topic -> HasuraTelemetry -> TelemetryPayload
[_tpTopic] :: TelemetryPayload -> Topic
[_tpData] :: TelemetryPayload -> HasuraTelemetry
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.TelemetryPayload
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Types.Topic
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.Topic
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.Topic
instance GHC.Show.Show Hasura.Server.Telemetry.Types.Topic
instance GHC.Show.Show Hasura.Server.Telemetry.Types.TelemetryPayload
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.HasuraTelemetry
instance GHC.Show.Show Hasura.Server.Telemetry.Types.HasuraTelemetry
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.SourceMetadata
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.SourceMetadata
instance GHC.Show.Show Hasura.Server.Telemetry.Types.SourceMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.Metrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.Metrics
instance GHC.Show.Show Hasura.Server.Telemetry.Types.Metrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.ActionMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.ActionMetric
instance GHC.Show.Show Hasura.Server.Telemetry.Types.ActionMetric
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.PermissionMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.PermissionMetric
instance GHC.Show.Show Hasura.Server.Telemetry.Types.PermissionMetric
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.RelationshipMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.RelationshipMetric
instance GHC.Show.Show Hasura.Server.Telemetry.Types.RelationshipMetric


-- | Send anonymized metrics to the telemetry server regarding usage of
--   various features of Hasura.
--   
--   The general workflow for telemetry is as follows:
--   
--   <ol>
--   <li>We generate metrics for each backend in the graphql-engine code
--   and send it to <a>telemetryUrl</a>. The relevant types can be found in
--   <a>Hasura.Server.Telemetry.Types</a>.</li>
--   <li>The <a>telemetryUrl</a> endpoint is handled by code in:
--   <a>https://github.com/hasura/hasura-analytics/tree/hge-upgrade</a>,
--   specifically <a>manager/main.go</a> and <a>manager/analytics.go</a>.
--   This server endpoint receives the telemetry payload and sends it to
--   another graphql-engine which runs locally and is backed by a postgres
--   database. The database schema for the telemetry endpoint can also be
--   found in the same repo under <a>hge/migrations/</a>.</li>
--   <li>The information from the postgres db can be viewed in Metabase:
--   <a>https://metabase.telemetry.hasura.io/browse/2/schema/public</a>.</li>
--   </ol>
--   
--   For more information about telemetry in general, visit the user-facing
--   docs on the topic:
--   <a>https://hasura.io/docs/latest/graphql/core/guides/telemetry</a>.
module Hasura.Server.Telemetry

-- | Logging related
data TelemetryLog
TelemetryLog :: !LogLevel -> !Text -> !Text -> !Maybe TelemetryHttpError -> TelemetryLog
[_tlLogLevel] :: TelemetryLog -> !LogLevel
[_tlType] :: TelemetryLog -> !Text
[_tlMessage] :: TelemetryLog -> !Text
[_tlHttpError] :: TelemetryLog -> !Maybe TelemetryHttpError
data TelemetryHttpError
TelemetryHttpError :: !Maybe Status -> !Text -> !Maybe HttpException -> !Maybe Text -> TelemetryHttpError
[tlheStatus] :: TelemetryHttpError -> !Maybe Status
[tlheUrl] :: TelemetryHttpError -> !Text
[tlheHttpException] :: TelemetryHttpError -> !Maybe HttpException
[tlheResponse] :: TelemetryHttpError -> !Maybe Text
mkHttpError :: Text -> Maybe (Response ByteString) -> Maybe HttpException -> TelemetryHttpError
mkTelemetryLog :: Text -> Text -> Maybe TelemetryHttpError -> TelemetryLog
telemetryUrl :: Text

-- | An infinite loop that sends updated telemetry data (<a>Metrics</a>)
--   every 24 hours. The send time depends on when the server was started
--   and will naturally drift.
runTelemetry :: Logger Hasura -> Manager -> IO SchemaCache -> MetadataDbId -> InstanceId -> PGVersion -> IO void

-- | Generate a telemetry payload for a specific source by computing their
--   relevant metrics. Additional information that may not be relevant to a
--   particular source such as service timing, remote schemas and actions,
--   will be reported only with the default source.
mkTelemetryPayload :: forall (b :: BackendType). HasTag b => MetadataDbId -> InstanceId -> Version -> PGVersion -> Maybe CI -> ServiceTimingMetrics -> RemoteSchemaMap -> ActionCache -> SourceInfo b -> TelemetryPayload

-- | Compute the relevant metrics for a specific source.
computeMetrics :: forall (b :: BackendType). SourceInfo b -> Maybe ServiceTimingMetrics -> Maybe RemoteSchemaMap -> Maybe ActionCache -> Metrics

-- | Compute the relevant metrics for actions from the action cache.
computeActionsMetrics :: ActionCache -> ActionMetric

-- | Decide which topic (telemetry table) we should use based on the
--   version.
versionToTopic :: Version -> Topic
instance GHC.Show.Show Hasura.Server.Telemetry.TelemetryHttpError
instance GHC.Show.Show Hasura.Server.Telemetry.TelemetryLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.TelemetryLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Telemetry.TelemetryLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.TelemetryHttpError


module Hasura.RQL.DDL.Schema.Function
newtype TrackFunction b
TrackFunction :: FunctionName b -> TrackFunction b
[tfName] :: TrackFunction b -> FunctionName b

-- | Track function, Phase 1: Validate function tracking operation. Fails
--   if function is already being tracked, or if a table with the same name
--   is being tracked.
trackFunctionP1 :: forall b m. (CacheRM m, QErrM m, Backend b) => SourceName -> FunctionName b -> m ()
trackFunctionP2 :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => SourceName -> FunctionName b -> FunctionConfig -> Maybe Text -> m EncJSON
handleMultipleFunctions :: forall b m a. (QErrM m, Backend b) => FunctionName b -> [a] -> m a
runTrackFunc :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => TrackFunction b -> m EncJSON

-- | JSON API payload for v2 of <tt>track_function</tt>:
--   
--   
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/schema-metadata-api/custom-functions.html#track-function-v2</a>
data TrackFunctionV2 (b :: BackendType)
TrackFunctionV2 :: SourceName -> FunctionName b -> FunctionConfig -> Maybe Text -> TrackFunctionV2 (b :: BackendType)
[_tfv2Source] :: TrackFunctionV2 (b :: BackendType) -> SourceName
[_tfv2Function] :: TrackFunctionV2 (b :: BackendType) -> FunctionName b
[_tfv2Configuration] :: TrackFunctionV2 (b :: BackendType) -> FunctionConfig
[_tfv2Comment] :: TrackFunctionV2 (b :: BackendType) -> Maybe Text
runTrackFunctionV2 :: forall b m. (BackendMetadata b, QErrM m, CacheRWM m, MetadataM m) => TrackFunctionV2 b -> m EncJSON

-- | JSON API payload for <tt>untrack_function</tt>:
--   
--   
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/schema-metadata-api/custom-functions.html#untrack-function</a>
data UnTrackFunction b
UnTrackFunction :: FunctionName b -> SourceName -> UnTrackFunction b
[_utfFunction] :: UnTrackFunction b -> FunctionName b
[_utfSource] :: UnTrackFunction b -> SourceName
runUntrackFunc :: forall b m. (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => UnTrackFunction b -> m EncJSON
data FunctionPermissionArgument b
FunctionPermissionArgument :: FunctionName b -> SourceName -> RoleName -> FunctionPermissionArgument b
[_afpFunction] :: FunctionPermissionArgument b -> FunctionName b
[_afpSource] :: FunctionPermissionArgument b -> SourceName
[_afpRole] :: FunctionPermissionArgument b -> RoleName
runCreateFunctionPermission :: forall b m. (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => FunctionPermissionArgument b -> m EncJSON
dropFunctionPermissionInMetadata :: forall b. BackendMetadata b => SourceName -> FunctionName b -> RoleName -> MetadataModifier
doesFunctionPermissionExist :: forall b. BackendMetadata b => Metadata -> SourceName -> FunctionName b -> RoleName -> Bool
runDropFunctionPermission :: forall m b. (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => FunctionPermissionArgument b -> m EncJSON

-- | Represents the payload of the API command
--   <tt>pg_set_function_customization</tt>.
--   
--   See the Hasura API reference for a detailed description.
data SetFunctionCustomization b
SetFunctionCustomization :: SourceName -> FunctionName b -> FunctionConfig -> SetFunctionCustomization b
[_sfcSource] :: SetFunctionCustomization b -> SourceName
[_sfcFunction] :: SetFunctionCustomization b -> FunctionName b
[_sfcConfiguration] :: SetFunctionCustomization b -> FunctionConfig

-- | Changes the custom names of a function. Used in the API command
--   <tt>pg_set_function_customization</tt>.
runSetFunctionCustomization :: forall b m. (QErrM m, CacheRWM m, MetadataM m, Backend b, BackendMetadata b) => SetFunctionCustomization b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Function.TrackFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Schema.Function.TrackFunction b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Function.SetFunctionCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Function.SetFunctionCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Function.SetFunctionCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Function.FunctionPermissionArgument b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Function.UnTrackFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Function.TrackFunctionV2 b)


-- | Types/functions shared between modules that implement
--   <a>Hasura.RQL.DDL.Schema.Cache</a>. Other modules should not import
--   this module directly.
module Hasura.RQL.DDL.Schema.Cache.Common

-- | <a>InvalidationKeys</a> used to apply requested
--   <a>CacheInvalidations</a>.
data InvalidationKeys
InvalidationKeys :: InvalidationKey -> HashMap RemoteSchemaName InvalidationKey -> HashMap SourceName InvalidationKey -> InvalidationKeys
[_ikMetadata] :: InvalidationKeys -> InvalidationKey
[_ikRemoteSchemas] :: InvalidationKeys -> HashMap RemoteSchemaName InvalidationKey
[_ikSources] :: InvalidationKeys -> HashMap SourceName InvalidationKey
ikSources :: Lens' InvalidationKeys (HashMap SourceName InvalidationKey)
ikRemoteSchemas :: Lens' InvalidationKeys (HashMap RemoteSchemaName InvalidationKey)
ikMetadata :: Lens' InvalidationKeys InvalidationKey
initialInvalidationKeys :: InvalidationKeys
invalidateKeys :: CacheInvalidations -> InvalidationKeys -> InvalidationKeys
data TableBuildInput b
TableBuildInput :: TableName b -> Bool -> TableConfig b -> Maybe ApolloFederationConfig -> TableBuildInput b
[_tbiName] :: TableBuildInput b -> TableName b
[_tbiIsEnum] :: TableBuildInput b -> Bool
[_tbiConfiguration] :: TableBuildInput b -> TableConfig b
[_tbiApolloFederationConfig] :: TableBuildInput b -> Maybe ApolloFederationConfig
data NonColumnTableInputs b
NonColumnTableInputs :: TableName b -> [ObjRelDef b] -> [ArrRelDef b] -> [ComputedFieldMetadata b] -> [RemoteRelationship] -> NonColumnTableInputs b
[_nctiTable] :: NonColumnTableInputs b -> TableName b
[_nctiObjectRelationships] :: NonColumnTableInputs b -> [ObjRelDef b]
[_nctiArrayRelationships] :: NonColumnTableInputs b -> [ArrRelDef b]
[_nctiComputedFields] :: NonColumnTableInputs b -> [ComputedFieldMetadata b]
[_nctiRemoteRelationships] :: NonColumnTableInputs b -> [RemoteRelationship]
data TablePermissionInputs b
TablePermissionInputs :: TableName b -> [InsPermDef b] -> [SelPermDef b] -> [UpdPermDef b] -> [DelPermDef b] -> TablePermissionInputs b
[_tpiTable] :: TablePermissionInputs b -> TableName b
[_tpiInsert] :: TablePermissionInputs b -> [InsPermDef b]
[_tpiSelect] :: TablePermissionInputs b -> [SelPermDef b]
[_tpiUpdate] :: TablePermissionInputs b -> [UpdPermDef b]
[_tpiDelete] :: TablePermissionInputs b -> [DelPermDef b]
mkTableInputs :: TableMetadata b -> (TableBuildInput b, NonColumnTableInputs b, TablePermissionInputs b)

-- | The direct output of <tt>buildSchemaCacheRule</tt>. Contains most of
--   the things necessary to build a schema cache, but dependencies and
--   inconsistent metadata objects are collected via a separate
--   <a>MonadWriter</a> side channel.
data BuildOutputs
BuildOutputs :: SourceCache -> ActionCache -> HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject) -> InlinedAllowlist -> AnnotatedCustomTypes -> HashMap TriggerName CronTriggerInfo -> HashMap EndpointName (EndpointMetadata GQLQueryWithText) -> ApiLimit -> MetricsConfig -> HashMap RoleName Role -> [TlsAllow] -> QueryCollections -> BuildOutputs
[_boSources] :: BuildOutputs -> SourceCache
[_boActions] :: BuildOutputs -> ActionCache

-- | We preserve the <a>MetadataObject</a> from the original catalog
--   metadata in the output so we can reuse it later if we need to mark the
--   remote schema inconsistent during GraphQL schema generation (because
--   of field conflicts).
[_boRemoteSchemas] :: BuildOutputs -> HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject)
[_boAllowlist] :: BuildOutputs -> InlinedAllowlist
[_boCustomTypes] :: BuildOutputs -> AnnotatedCustomTypes
[_boCronTriggers] :: BuildOutputs -> HashMap TriggerName CronTriggerInfo
[_boEndpoints] :: BuildOutputs -> HashMap EndpointName (EndpointMetadata GQLQueryWithText)
[_boApiLimits] :: BuildOutputs -> ApiLimit
[_boMetricsConfig] :: BuildOutputs -> MetricsConfig
[_boRoles] :: BuildOutputs -> HashMap RoleName Role
[_boTlsAllowlist] :: BuildOutputs -> [TlsAllow]
[_boQueryCollections] :: BuildOutputs -> QueryCollections
boTlsAllowlist :: Lens' BuildOutputs [TlsAllow]
boSources :: Lens' BuildOutputs SourceCache
boRoles :: Lens' BuildOutputs (HashMap RoleName Role)
boRemoteSchemas :: Lens' BuildOutputs (HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject))
boQueryCollections :: Lens' BuildOutputs QueryCollections
boMetricsConfig :: Lens' BuildOutputs MetricsConfig
boEndpoints :: Lens' BuildOutputs (HashMap EndpointName (EndpointMetadata GQLQueryWithText))
boCustomTypes :: Lens' BuildOutputs AnnotatedCustomTypes
boCronTriggers :: Lens' BuildOutputs (HashMap TriggerName CronTriggerInfo)
boApiLimits :: Lens' BuildOutputs ApiLimit
boAllowlist :: Lens' BuildOutputs InlinedAllowlist
boActions :: Lens' BuildOutputs ActionCache

-- | Parameters required for schema cache build
data CacheBuildParams
CacheBuildParams :: Manager -> SourceResolver ('Postgres 'Vanilla) -> SourceResolver 'MSSQL -> ServerConfigCtx -> CacheBuildParams
[_cbpManager] :: CacheBuildParams -> Manager
[_cbpPGSourceResolver] :: CacheBuildParams -> SourceResolver ('Postgres 'Vanilla)
[_cbpMSSQLSourceResolver] :: CacheBuildParams -> SourceResolver 'MSSQL
[_cbpServerConfigCtx] :: CacheBuildParams -> ServerConfigCtx

-- | The monad in which @<a>RebuildableSchemaCache</a> is being run
newtype CacheBuild a
CacheBuild :: ReaderT CacheBuildParams (ExceptT QErr IO) a -> CacheBuild a
runCacheBuild :: (MonadIO m, MonadError QErr m) => CacheBuildParams -> CacheBuild a -> m a
runCacheBuildM :: (MonadIO m, MonadError QErr m, HasHttpManagerM m, HasServerConfigCtx m, MonadResolveSource m) => CacheBuild a -> m a
data RebuildableSchemaCache
RebuildableSchemaCache :: SchemaCache -> InvalidationKeys -> Rule (ReaderT BuildReason CacheBuild) (Metadata, InvalidationKeys) SchemaCache -> RebuildableSchemaCache
[lastBuiltSchemaCache] :: RebuildableSchemaCache -> SchemaCache
[_rscInvalidationMap] :: RebuildableSchemaCache -> InvalidationKeys
[_rscRebuild] :: RebuildableSchemaCache -> Rule (ReaderT BuildReason CacheBuild) (Metadata, InvalidationKeys) SchemaCache
bindErrorA :: (ArrowChoice arr, ArrowKleisli m arr, ArrowError e arr, MonadError e m) => arr (m a) a
withRecordDependencies :: ArrowWriter (Seq CollectedInfo) arr => WriterA (Seq SchemaDependency) arr (e, s) a -> arr (e, (MetadataObject, (SchemaObjId, s))) a
noDuplicates :: MonadWriter (Seq CollectedInfo) m => (a -> MetadataObject) -> [a] -> m (Maybe a)

-- | Processes a list of catalog metadata into a map of processed
--   information, marking any duplicate entries inconsistent.
buildInfoMap :: (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectedInfo) arr, Eq k, Hashable k) => (a -> k) -> (a -> MetadataObject) -> ((e, a) `arr` Maybe b) -> (e, [a]) `arr` HashMap k b

-- | Like <tt>buildInfo</tt>, but includes each processed info’s associated
--   <a>MetadataObject</a> in the result. This is useful if the results
--   will be further processed, and the <a>MetadataObject</a> is still
--   needed to mark the object inconsistent.
buildInfoMapPreservingMetadata :: (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectedInfo) arr, Eq k, Hashable k) => (a -> k) -> (a -> MetadataObject) -> ((e, a) `arr` Maybe b) -> (e, [a]) `arr` HashMap k (b, MetadataObject)
addTableContext :: Backend b => TableName b -> Text -> Text
instance Control.Monad.Unique.MonadUnique Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.Base.MonadBase GHC.Types.IO Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.IO.Class.MonadIO Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.Reader.Class.MonadReader Hasura.RQL.DDL.Schema.Cache.Common.CacheBuildParams Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Base.Monad Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Base.Applicative Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Base.Functor Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Network.HTTP.Client.Manager.HasHttpManagerM Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Hasura.Server.Types.HasServerConfigCtx Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Hasura.RQL.Types.Source.MonadResolveSource Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.Common.NonColumnTableInputs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.Common.NonColumnTableInputs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Cache.Common.NonColumnTableInputs b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.Common.TablePermissionInputs b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Backend.TableName b)) => GHC.Show.Show (Hasura.RQL.DDL.Schema.Cache.Common.TablePermissionInputs b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Backend.TableName b)) => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.Common.TablePermissionInputs b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.DDL.Schema.Cache.Common.TablePermissionInputs b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance GHC.Generics.Generic Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance GHC.Show.Show Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance Hasura.Incremental.Select.Select Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys


module Hasura.RQL.DDL.Schema.Table
data TrackTable b
TrackTable :: SourceName -> TableName b -> Bool -> Maybe ApolloFederationConfig -> TrackTable b
[tSource] :: TrackTable b -> SourceName
[tName] :: TrackTable b -> TableName b
[tIsEnum] :: TrackTable b -> Bool
[tApolloFedConfig] :: TrackTable b -> Maybe ApolloFederationConfig
data SetTableIsEnum
SetTableIsEnum :: SourceName -> QualifiedTable -> Bool -> SetTableIsEnum
[stieSource] :: SetTableIsEnum -> SourceName
[stieTable] :: SetTableIsEnum -> QualifiedTable
[stieIsEnum] :: SetTableIsEnum -> Bool
data UntrackTable b
UntrackTable :: SourceName -> TableName b -> Bool -> UntrackTable b
[utSource] :: UntrackTable b -> SourceName
[utTable] :: UntrackTable b -> TableName b
[utCascade] :: UntrackTable b -> Bool
isTableTracked :: forall b. Backend b => SourceInfo b -> TableName b -> Bool

-- | Track table/view, Phase 1: Validate table tracking operation. Fails if
--   table is already being tracked, or if a function with the same name is
--   being tracked.
trackExistingTableOrViewP1 :: forall b m. (QErrM m, CacheRWM m, Backend b, MetadataM m) => SourceName -> TableName b -> m ()

-- | Check whether a given name would conflict with the current schema by
--   doing an internal introspection
checkConflictingNode :: forall m. MonadError QErr m => SchemaCache -> Text -> m ()
trackExistingTableOrViewP2 :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => SourceName -> TableName b -> Bool -> TableConfig b -> Maybe ApolloFederationConfig -> m EncJSON
runTrackTableQ :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => TrackTable b -> m EncJSON
data TrackTableV2 b
TrackTableV2 :: TrackTable b -> TableConfig b -> TrackTableV2 b
[ttv2Table] :: TrackTableV2 b -> TrackTable b
[ttv2Configuration] :: TrackTableV2 b -> TableConfig b
runTrackTableV2Q :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => TrackTableV2 b -> m EncJSON
runSetExistingTableIsEnumQ :: (MonadError QErr m, CacheRWM m, MetadataM m) => SetTableIsEnum -> m EncJSON
data SetTableCustomization b
SetTableCustomization :: SourceName -> TableName b -> TableConfig b -> SetTableCustomization b
[_stcSource] :: SetTableCustomization b -> SourceName
[_stcTable] :: SetTableCustomization b -> TableName b
[_stcConfiguration] :: SetTableCustomization b -> TableConfig b
data SetTableCustomFields
SetTableCustomFields :: SourceName -> QualifiedTable -> TableCustomRootFields -> HashMap (Column ('Postgres 'Vanilla)) Name -> SetTableCustomFields
[_stcfSource] :: SetTableCustomFields -> SourceName
[_stcfTable] :: SetTableCustomFields -> QualifiedTable
[_stcfCustomRootFields] :: SetTableCustomFields -> TableCustomRootFields
[_stcfCustomColumnNames] :: SetTableCustomFields -> HashMap (Column ('Postgres 'Vanilla)) Name
runSetTableCustomFieldsQV2 :: (QErrM m, CacheRWM m, MetadataM m) => SetTableCustomFields -> m EncJSON
runSetTableCustomization :: forall b m. (QErrM m, CacheRWM m, MetadataM m, Backend b, BackendMetadata b) => SetTableCustomization b -> m EncJSON
unTrackExistingTableOrViewP1 :: forall b m. (CacheRM m, QErrM m, Backend b) => UntrackTable b -> m ()
unTrackExistingTableOrViewP2 :: forall b m. (CacheRWM m, QErrM m, MetadataM m, BackendMetadata b, BackendEventTrigger b, MonadIO m) => UntrackTable b -> m EncJSON
runUntrackTableQ :: forall b m. (CacheRWM m, QErrM m, MetadataM m, BackendMetadata b, BackendEventTrigger b, MonadIO m) => UntrackTable b -> m EncJSON

-- | Builds an initial table cache. Does not fill in permissions or event
--   triggers, and the returned <tt>FieldInfoMap</tt>s only contain
--   columns, not relationships; those pieces of information are filled in
--   later.
buildTableCache :: forall arr m b. (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectedInfo) arr, ArrowCache m arr, MonadIO m, MonadBaseControl IO m, BackendMetadata b) => (SourceName, SourceConfig b, DBTablesMetadata b, [TableBuildInput b], Dependency InvalidationKey, NamingCase) `arr` HashMap (TableName b) (TableCoreInfoG b (ColumnInfo b) (ColumnInfo b))
data SetApolloFederationConfig b
SetApolloFederationConfig :: SourceName -> TableName b -> Maybe ApolloFederationConfig -> SetApolloFederationConfig b
[_safcSource] :: SetApolloFederationConfig b -> SourceName
[_safcTable] :: SetApolloFederationConfig b -> TableName b

-- | Apollo Federation config for the table, setting <a>Nothing</a> would
--   disable Apollo Federation support on the table.
[_safcApolloFederationConfig] :: SetApolloFederationConfig b -> Maybe ApolloFederationConfig
runSetApolloFederationConfig :: forall b m. (QErrM m, CacheRWM m, MetadataM m, Backend b, BackendMetadata b) => SetApolloFederationConfig b -> m EncJSON
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Table.SetTableIsEnum
instance GHC.Show.Show Hasura.RQL.DDL.Schema.Table.SetTableIsEnum
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Table.TrackTableV2 b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Table.TrackTableV2 b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Table.SetTableCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Table.SetTableCustomization b)
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Table.SetTableCustomFields
instance GHC.Show.Show Hasura.RQL.DDL.Schema.Table.SetTableCustomFields
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Table.TrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Table.TrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Table.UntrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Table.UntrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Table.SetApolloFederationConfig b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.Table.SetTableCustomFields
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Table.SetTableCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Table.TrackTableV2 b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Table.UntrackTable b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.Table.SetTableIsEnum
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Table.TrackTable b)

module Hasura.RQL.DDL.Schema.Diff
data FunctionMeta b
FunctionMeta :: OID -> FunctionName b -> FunctionVolatility -> FunctionMeta b
[fmOid] :: FunctionMeta b -> OID
[fmFunction] :: FunctionMeta b -> FunctionName b
[fmType] :: FunctionMeta b -> FunctionVolatility
data ComputedFieldMeta b
ComputedFieldMeta :: ComputedFieldName -> FunctionMeta b -> ComputedFieldMeta b
[ccmName] :: ComputedFieldMeta b -> ComputedFieldName
[ccmFunctionMeta] :: ComputedFieldMeta b -> FunctionMeta b
data TableMeta (b :: BackendType)
TableMeta :: TableName b -> DBTableMetadata b -> [ComputedFieldMeta b] -> TableMeta (b :: BackendType)
[tmTable] :: TableMeta (b :: BackendType) -> TableName b
[tmInfo] :: TableMeta (b :: BackendType) -> DBTableMetadata b
[tmComputedFields] :: TableMeta (b :: BackendType) -> [ComputedFieldMeta b]
data ComputedFieldDiff (b :: BackendType)
ComputedFieldDiff :: [ComputedFieldName] -> [(ComputedFieldMeta b, ComputedFieldMeta b)] -> [(ComputedFieldName, FunctionName b)] -> ComputedFieldDiff (b :: BackendType)
[_cfdDropped] :: ComputedFieldDiff (b :: BackendType) -> [ComputedFieldName]
[_cfdAltered] :: ComputedFieldDiff (b :: BackendType) -> [(ComputedFieldMeta b, ComputedFieldMeta b)]
[_cfdOverloaded] :: ComputedFieldDiff (b :: BackendType) -> [(ComputedFieldName, FunctionName b)]
data TableDiff (b :: BackendType)
TableDiff :: Maybe (TableName b) -> [Column b] -> [(RawColumnInfo b, RawColumnInfo b)] -> [ConstraintName b] -> ComputedFieldDiff b -> [ConstraintName b] -> Maybe PGDescription -> TableDiff (b :: BackendType)
[_tdNewName] :: TableDiff (b :: BackendType) -> Maybe (TableName b)
[_tdDroppedCols] :: TableDiff (b :: BackendType) -> [Column b]
[_tdAlteredCols] :: TableDiff (b :: BackendType) -> [(RawColumnInfo b, RawColumnInfo b)]
[_tdDroppedFKeyCons] :: TableDiff (b :: BackendType) -> [ConstraintName b]
[_tdComputedFields] :: TableDiff (b :: BackendType) -> ComputedFieldDiff b
[_tdUniqOrPriCons] :: TableDiff (b :: BackendType) -> [ConstraintName b]
[_tdNewDescription] :: TableDiff (b :: BackendType) -> Maybe PGDescription
getTableDiff :: Backend b => TableMeta b -> TableMeta b -> TableDiff b
getTableChangeDeps :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> TableName b -> TableDiff b -> m [SchemaObjId]
data TablesDiff (b :: BackendType)
TablesDiff :: [TableName b] -> [(TableName b, TableDiff b)] -> TablesDiff (b :: BackendType)
[_sdDroppedTables] :: TablesDiff (b :: BackendType) -> [TableName b]
[_sdAlteredTables] :: TablesDiff (b :: BackendType) -> [(TableName b, TableDiff b)]
getTablesDiff :: Backend b => [TableMeta b] -> [TableMeta b] -> TablesDiff b
getIndirectDependenciesFromTableDiff :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> TablesDiff b -> m [SchemaObjId]
data FunctionsDiff b
FunctionsDiff :: [FunctionName b] -> [(FunctionName b, FunctionVolatility)] -> FunctionsDiff b
[fdDropped] :: FunctionsDiff b -> [FunctionName b]
[fdAltered] :: FunctionsDiff b -> [(FunctionName b, FunctionVolatility)]
getFunctionsDiff :: [FunctionMeta b] -> [FunctionMeta b] -> FunctionsDiff b
getOverloadedFunctions :: Backend b => [FunctionName b] -> [FunctionMeta b] -> [FunctionName b]
processTablesDiff :: forall b m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableCache b -> TablesDiff b -> m ()
alterTableInMetadata :: forall m b. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableCoreInfo b -> TableDiff b -> m ()
dropTablesInMetadata :: forall b m. (MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> [TableName b] -> m ()
alterColumnsInMetadata :: forall b m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> [(RawColumnInfo b, RawColumnInfo b)] -> FieldInfoMap (FieldInfo b) -> SchemaCache -> TableName b -> m ()
removeDroppedColumnsFromMetadataField :: forall b m. (MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> [Column b] -> TableCoreInfo b -> m ()
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.TableMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Diff.TableMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Diff.ComputedFieldDiff b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.ComputedFieldDiff b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Diff.FunctionsDiff b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.FunctionsDiff b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)

module Hasura.RQL.DDL.Schema.Cache.Permission
mkBooleanPermissionMap :: (RoleName -> a) -> HashMap RoleName a -> OrderedRoles -> HashMap RoleName a

-- | <a>OrderedRoles</a> is a data type to hold topologically sorted roles
--   according to each role's parent roles, see <a>orderRoles</a> for more
--   details.
newtype OrderedRoles
OrderedRoles :: [Role] -> OrderedRoles
[_unOrderedRoles] :: OrderedRoles -> [Role]

-- | <a>orderRoles</a> is used to order the roles, in such a way that given
--   a role R with n parent roles - PR1, PR2 .. PRn, then the
--   <a>orderRoles</a> function will order the roles in such a way that all
--   the parent roles precede the role R. Note that the order of the parent
--   roles itself doesn't matter as long as they precede the roles on which
--   they are dependent on.
--   
--   For example, the orderRoles may return `[PR1, PR3, PR2, ... PRn, R]`
--   or `[PR5, PR3, PR1 ... R]`, both of them are correct because all the
--   parent roles precede the inherited role R, assuming the parent roles
--   themselves don't have any parents for the sake of this example.
orderRoles :: MonadError QErr m => [Role] -> m OrderedRoles

-- | <a>resolveCheckPermission</a> is a helper function which will convert
--   the indermediate type <a>CheckPermission</a> to its original type. It
--   will record any metadata inconsistencies, if exists.
resolveCheckPermission :: forall m p. MonadWriter (Seq CollectedInfo) m => CheckPermission p -> RoleName -> InconsistentRoleEntity -> m (Maybe p)
resolveCheckTablePermission :: forall b perm m. (MonadWriter (Seq CollectedInfo) m, BackendMetadata b) => CheckPermission perm -> Maybe (RolePermInfo b) -> (RolePermInfo b -> Maybe perm) -> RoleName -> SourceName -> TableName b -> PermType -> m (Maybe perm)
buildTablePermissions :: forall b m arr. (ArrowChoice arr, ArrowDistribute arr, ArrowCache m arr, MonadError QErr m, ArrowWriter (Seq CollectedInfo) arr, BackendMetadata b, Cacheable (Proxy b), GetAggregationPredicatesDeps b) => (Proxy b, SourceName, Dependency (TableCoreCache b), FieldInfoMap (FieldInfo b), TablePermissionInputs b, OrderedRoles) `arr` RolePermInfoMap b
mkPermissionMetadataObject :: forall b a. BackendMetadata b => SourceName -> TableName b -> PermDef b a -> MetadataObject
mkRemoteSchemaPermissionMetadataObject :: AddRemoteSchemaPermission -> MetadataObject
withPermission :: forall bknd a b c s arr. (ArrowChoice arr, ArrowWriter (Seq CollectedInfo) arr, BackendMetadata bknd) => WriterA (Seq SchemaDependency) (ErrorA QErr arr) (a, s) b -> (a, ((SourceName, TableName bknd, PermDef bknd c, Proxy bknd), s)) `arr` Maybe b
buildPermission :: forall b a arr m. (ArrowChoice arr, ArrowWriter (Seq CollectedInfo) arr, ArrowCache m arr, Cacheable (a b), Cacheable (Proxy b), MonadError QErr m, BackendMetadata b, GetAggregationPredicatesDeps b) => (Proxy b, Dependency (TableCoreCache b), SourceName, TableName b, FieldInfoMap (FieldInfo b), Maybe (PermDef b a)) `arr` Maybe (PermInfo a b)
instance GHC.Generics.Generic Hasura.RQL.DDL.Schema.Cache.Permission.OrderedRoles
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Cache.Permission.OrderedRoles
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.RQL.DDL.Schema.Cache.Permission.OrderedRoles

module Hasura.RQL.DDL.Schema.Cache.Fields
addNonColumnFields :: forall b arr m. (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectedInfo) arr, ArrowKleisli m arr, MonadError QErr m, BackendMetadata b) => (HashMap SourceName (AnyBackend PartiallyResolvedSource), SourceName, HashMap (TableName b) (TableCoreInfoG b (ColumnInfo b) (ColumnInfo b)), FieldInfoMap (ColumnInfo b), RemoteSchemaMap, DBFunctionsMetadata b, NonColumnTableInputs b) `arr` FieldInfoMap (FieldInfo b)
mkRelationshipMetadataObject :: forall b a. (ToJSON a, Backend b) => RelType -> (SourceName, TableName b, RelDef a) -> MetadataObject
buildObjectRelationship :: (ArrowChoice arr, ArrowWriter (Seq CollectedInfo) arr, Backend b) => (HashMap (TableName b) (HashSet (ForeignKey b)), (SourceName, TableName b, ObjRelDef b)) `arr` Maybe (RelInfo b)
buildArrayRelationship :: (ArrowChoice arr, ArrowWriter (Seq CollectedInfo) arr, Backend b) => (HashMap (TableName b) (HashSet (ForeignKey b)), (SourceName, TableName b, ArrRelDef b)) `arr` Maybe (RelInfo b)
buildRelationship :: forall m b a. (MonadWriter (Seq CollectedInfo) m, ToJSON a, Backend b) => SourceName -> TableName b -> (RelDef a -> Either QErr (RelInfo b, [SchemaDependency])) -> RelType -> RelDef a -> m (Maybe (RelInfo b))
mkComputedFieldMetadataObject :: forall b. Backend b => (SourceName, TableName b, ComputedFieldMetadata b) -> MetadataObject
buildComputedField :: forall b m. (MonadWriter (Seq CollectedInfo) m, BackendMetadata b) => HashSet (TableName b) -> HashSet (Column b) -> SourceName -> DBFunctionsMetadata b -> TableName b -> ComputedFieldMetadata b -> m (Either QErr (Maybe (ComputedFieldInfo b)))
mkRemoteRelationshipMetadataObject :: forall b. Backend b => (SourceName, TableName b, RemoteRelationship) -> MetadataObject
buildRemoteRelationship :: forall b m. (MonadWriter (Seq CollectedInfo) m, BackendMetadata b) => HashMap SourceName (AnyBackend PartiallyResolvedSource) -> HashMap FieldName (DBJoinField b) -> RemoteSchemaMap -> (SourceName, TableName b, RemoteRelationship) -> m (Either QErr (Maybe (RemoteFieldInfo (DBJoinField b))))

module Hasura.RQL.DDL.Schema.Cache.Dependencies

-- | Processes collected <tt>CIDependency</tt> values into a <a>DepMap</a>,
--   performing integrity checking to ensure the dependencies actually
--   exist. If a dependency is missing, its transitive dependents are
--   removed from the cache, and <a>InconsistentMetadata</a>s are returned.
resolveDependencies :: (ArrowKleisli m arr, QErrM m) => (BuildOutputs, [(MetadataObject, SchemaObjId, SchemaDependency)]) `arr` (BuildOutputs, [InconsistentMetadata], DepMap)
performIteration :: QErrM m => Int -> BuildOutputs -> [InconsistentMetadata] -> HashMap SchemaObjId [(MetadataObject, SchemaDependency)] -> m (BuildOutputs, [InconsistentMetadata], DepMap)
pruneDanglingDependents :: BuildOutputs -> HashMap SchemaObjId [(MetadataObject, SchemaDependency)] -> ([InconsistentMetadata], HashMap SchemaObjId [(MetadataObject, SchemaDependency)])
deleteMetadataObject :: MetadataObjId -> BuildOutputs -> BuildOutputs


-- | <h1>Remote Schema Permissions Validation</h1>
--   
--   This module parses the GraphQL IDL (Schema Document) that's provided
--   by the user for configuring permissions for remote schemas to a schema
--   introspection object, which is then used to construct the remote
--   schema for the particular role.
--   
--   This module does two things essentially:
--   
--   <ol>
--   <li>Checks if the given schema document is a subset of the upstream
--   remote schema document. This is done by checking if all the objects,
--   interfaces, unions, enums, scalars and input objects provided in the
--   schema document exist in the upstream remote schema too. We validate
--   the fields, directives and arguments too, wherever applicable.</li>
--   <li>Parse the <tt>preset</tt> directives (if any) on input object
--   fields or argument fields. A <tt>preset</tt> directive is used to
--   specify any preset argument on a field, it can be either a static
--   value or session variable value. There is some validation done on
--   preset directives. For example: - Preset directives can only be
--   specified at <tt>ARGUMENT_DEFINITION</tt> or
--   <tt>INPUT_FIELD_DEFINITION</tt> - A field expecting object cannot have
--   a scalar/enum preset directive and vice versa.</li>
--   </ol>
--   
--   If a preset directive value is a session variable (like `x-hasura-*`),
--   then it's considered to be a session variable value. In the case, the
--   user wants to treat the session variable value literally, they can add
--   the <tt>static</tt> key to the preset directive to indicate that the
--   value provided should be considered literally. For example:
--   
--   `user(id: Int @preset(value: "x-hasura-user-id", static: true))
--   
--   In this case `x-hasura-user-id` will be considered literally.
--   
--   For validation, we use the <a>MonadValidate</a> monad transformer to
--   collect as many errors as possible and then report all those errors at
--   one go to the user.
module Hasura.RQL.DDL.RemoteSchema.Permission
data FieldDefinitionType
ObjectField :: FieldDefinitionType
InterfaceField :: FieldDefinitionType
EnumField :: FieldDefinitionType
data ArgumentDefinitionType
InputObjectArgument :: ArgumentDefinitionType
DirectiveArgument :: ArgumentDefinitionType
data PresetInputTypeInfo
PresetScalar :: Name -> PresetInputTypeInfo
PresetEnum :: Name -> [EnumValue] -> PresetInputTypeInfo
PresetInputObject :: [InputValueDefinition] -> PresetInputTypeInfo
data GraphQLType
Enum :: GraphQLType
InputObject :: GraphQLType
Object :: GraphQLType
Interface :: GraphQLType
Union :: GraphQLType
Scalar :: GraphQLType
Directive :: GraphQLType
Field :: FieldDefinitionType -> GraphQLType
Argument :: ArgumentDefinitionType -> GraphQLType
data RoleBasedSchemaValidationError

-- | error to indicate that a type provided by the user differs from the
--   corresponding type defined in the upstream remote schema
NonMatchingType :: Name -> GraphQLType -> GType -> GType -> RoleBasedSchemaValidationError

-- | error to indicate when a type definition doesn't exist in the upstream
--   remote schema
TypeDoesNotExist :: GraphQLType -> Name -> RoleBasedSchemaValidationError

-- | error to indicate when the default value of an argument differs from
--   the default value of the corresponding argument
NonMatchingDefaultValue :: Name -> Name -> Maybe (Value Void) -> Maybe (Value Void) -> RoleBasedSchemaValidationError

-- | error to indicate when a given input argument doesn't exist in the
--   corresponding upstream input object
NonExistingInputArgument :: Name -> Name -> RoleBasedSchemaValidationError
MissingNonNullableArguments :: Name -> NonEmpty Name -> RoleBasedSchemaValidationError

-- | error to indicate when a given directive argument doesn't exist in the
--   corresponding upstream directive
NonExistingDirectiveArgument :: Name -> GraphQLType -> Name -> NonEmpty Name -> RoleBasedSchemaValidationError

-- | error to indicate when a given field doesn't exist in a field type
--   (Object/Interface)
NonExistingField :: (FieldDefinitionType, Name) -> Name -> RoleBasedSchemaValidationError

-- | error to indicate when member types of an Union don't exist in the
--   corresponding upstream union
NonExistingUnionMemberTypes :: Name -> NonEmpty Name -> RoleBasedSchemaValidationError

-- | error to indicate when an object is trying to implement an interface
--   which exists in the schema document but the interface doesn't exist in
--   the upstream remote.
CustomInterfacesNotAllowed :: Name -> NonEmpty Name -> RoleBasedSchemaValidationError

-- | error to indicate when object implements interfaces that don't exist
ObjectImplementsNonExistingInterfaces :: Name -> NonEmpty Name -> RoleBasedSchemaValidationError

-- | error to indicate enum values in an enum do not exist in the
--   corresponding upstream enum
NonExistingEnumValues :: Name -> NonEmpty Name -> RoleBasedSchemaValidationError

-- | error to indicate when the user provided schema contains more than one
--   schema definition
MultipleSchemaDefinitionsFound :: RoleBasedSchemaValidationError

-- | error to indicate when the schema definition doesn't contain the query
--   root.
MissingQueryRoot :: RoleBasedSchemaValidationError
DuplicateTypeNames :: NonEmpty Name -> RoleBasedSchemaValidationError
DuplicateDirectives :: (GraphQLType, Name) -> NonEmpty Name -> RoleBasedSchemaValidationError
DuplicateFields :: (FieldDefinitionType, Name) -> NonEmpty Name -> RoleBasedSchemaValidationError
DuplicateArguments :: Name -> NonEmpty Name -> RoleBasedSchemaValidationError
DuplicateEnumValues :: Name -> NonEmpty Name -> RoleBasedSchemaValidationError
InvalidPresetDirectiveLocation :: RoleBasedSchemaValidationError
MultiplePresetDirectives :: (GraphQLType, Name) -> RoleBasedSchemaValidationError
NoPresetArgumentFound :: RoleBasedSchemaValidationError
InvalidPresetArgument :: Name -> RoleBasedSchemaValidationError
ExpectedInputTypeButGotOutputType :: Name -> RoleBasedSchemaValidationError
EnumValueNotFound :: Name -> Name -> RoleBasedSchemaValidationError
ExpectedEnumValue :: Name -> Value Void -> RoleBasedSchemaValidationError
KeyDoesNotExistInInputObject :: Name -> Name -> RoleBasedSchemaValidationError
ExpectedInputObject :: Name -> Value Void -> RoleBasedSchemaValidationError
ExpectedScalarValue :: Name -> Value Void -> RoleBasedSchemaValidationError
DisallowSessionVarForListType :: Name -> RoleBasedSchemaValidationError
InvalidStaticValue :: RoleBasedSchemaValidationError

-- | Error to indicate we're comparing non corresponding type definitions.
--   Ideally, this error will never occur unless there's a programming
--   error
UnexpectedNonMatchingNames :: Name -> Name -> GraphQLType -> RoleBasedSchemaValidationError
showRoleBasedSchemaValidationError :: RoleBasedSchemaValidationError -> Text
lookupInputType :: SchemaDocument -> Name -> Maybe PresetInputTypeInfo

-- | <a>parsePresetValue</a> constructs a GraphQL value when an input value
--   definition contains a preset with it. This function checks if the
--   given preset value is a legal value to the field that's specified it.
--   For example: A scalar input value cannot contain an input object
--   value. When the preset value is a session variable, we treat it as a
--   session variable whose value will be resolved while the query is
--   executed. In the case of session variables preset, we make the GraphQL
--   value as a Variable value and during the execution we resolve all
--   these "session variable" variable(s) and then query the remote server.
parsePresetValue :: forall m. (MonadValidate [RoleBasedSchemaValidationError] m, MonadReader SchemaDocument m) => GType -> Name -> Bool -> Value Void -> m (Value RemoteSchemaVariable)
parsePresetDirective :: forall m. (MonadValidate [RoleBasedSchemaValidationError] m, MonadReader SchemaDocument m) => GType -> Name -> Directive Void -> m (Value RemoteSchemaVariable)

-- | validateDirective checks if the arguments of a given directive is a
--   subset of the corresponding upstream directive arguments *NOTE*: This
--   function assumes that the <tt>providedDirective</tt> and the
--   <tt>upstreamDirective</tt> have the same name.
validateDirective :: MonadValidate [RoleBasedSchemaValidationError] m => Directive a -> Directive a -> (GraphQLType, Name) -> m ()

-- | validateDirectives checks if the <tt>providedDirectives</tt> are a
--   subset of <tt>upstreamDirectives</tt> and then validate each of the
--   directives by calling the <a>validateDirective</a>
validateDirectives :: MonadValidate [RoleBasedSchemaValidationError] m => [Directive a] -> [Directive a] -> TypeSystemDirectiveLocation -> (GraphQLType, Name) -> m (Maybe (Directive a))

-- | <a>validateEnumTypeDefinition</a> checks the validity of an enum
--   definition provided by the user against the corresponding upstream
--   enum. The function does the following things: 1. Validates the
--   directives (if any) 2. For each enum provided, check if the enum
--   values are a subset of the enum values of the corresponding upstream
--   enum *NOTE*: This function assumes that the <tt>providedEnum</tt> and
--   the <tt>upstreamEnum</tt> have the same name.
validateEnumTypeDefinition :: MonadValidate [RoleBasedSchemaValidationError] m => EnumTypeDefinition -> EnumTypeDefinition -> m EnumTypeDefinition

-- | <a>validateInputValueDefinition</a> validates a given input value
--   definition , against the corresponding upstream input value
--   definition. Two things are validated to do the same, the type and the
--   default value of the input value definitions should be equal.
validateInputValueDefinition :: (MonadValidate [RoleBasedSchemaValidationError] m, MonadReader SchemaDocument m) => InputValueDefinition -> InputValueDefinition -> Name -> m RemoteSchemaInputValueDefinition

-- | <a>validateArguments</a> validates the provided arguments against the
--   corresponding upstream remote schema arguments.
validateArguments :: (MonadValidate [RoleBasedSchemaValidationError] m, MonadReader SchemaDocument m) => ArgumentsDefinition InputValueDefinition -> ArgumentsDefinition RemoteSchemaInputValueDefinition -> Name -> m [RemoteSchemaInputValueDefinition]
validateInputObjectTypeDefinition :: (MonadValidate [RoleBasedSchemaValidationError] m, MonadReader SchemaDocument m) => InputObjectTypeDefinition InputValueDefinition -> InputObjectTypeDefinition RemoteSchemaInputValueDefinition -> m (InputObjectTypeDefinition RemoteSchemaInputValueDefinition)
validateFieldDefinition :: (MonadValidate [RoleBasedSchemaValidationError] m, MonadReader SchemaDocument m) => FieldDefinition InputValueDefinition -> FieldDefinition RemoteSchemaInputValueDefinition -> (FieldDefinitionType, Name) -> m (FieldDefinition RemoteSchemaInputValueDefinition)
validateFieldDefinitions :: (MonadValidate [RoleBasedSchemaValidationError] m, MonadReader SchemaDocument m) => [FieldDefinition InputValueDefinition] -> [FieldDefinition RemoteSchemaInputValueDefinition] -> (FieldDefinitionType, Name) -> m [FieldDefinition RemoteSchemaInputValueDefinition]
validateInterfaceDefinition :: (MonadValidate [RoleBasedSchemaValidationError] m, MonadReader SchemaDocument m) => InterfaceTypeDefinition () InputValueDefinition -> InterfaceTypeDefinition [Name] RemoteSchemaInputValueDefinition -> m (InterfaceTypeDefinition () RemoteSchemaInputValueDefinition)
validateScalarDefinition :: MonadValidate [RoleBasedSchemaValidationError] m => ScalarTypeDefinition -> ScalarTypeDefinition -> m ScalarTypeDefinition
validateUnionDefinition :: MonadValidate [RoleBasedSchemaValidationError] m => UnionTypeDefinition -> UnionTypeDefinition -> m UnionTypeDefinition
validateObjectDefinition :: (MonadValidate [RoleBasedSchemaValidationError] m, MonadReader SchemaDocument m) => ObjectTypeDefinition InputValueDefinition -> ObjectTypeDefinition RemoteSchemaInputValueDefinition -> HashSet Name -> m (ObjectTypeDefinition RemoteSchemaInputValueDefinition)

-- | helper function to validate the schema definitions mentioned in the
--   schema document.
validateSchemaDefinitions :: MonadValidate [RoleBasedSchemaValidationError] m => [SchemaDefinition] -> m (Maybe Name, Maybe Name, Maybe Name)

-- | Construction of the <tt>possibleTypes</tt> map for interfaces, while
--   parsing the user provided Schema document, it doesn't include the
--   <tt>possibleTypes</tt>, so constructing here, manually.
createPossibleTypesMap :: [ObjectTypeDefinition RemoteSchemaInputValueDefinition] -> HashMap Name [Name]
partitionTypeSystemDefinitions :: [TypeSystemDefinition] -> ([SchemaDefinition], [TypeDefinition () InputValueDefinition])

-- | getSchemaDocIntrospection converts the
--   <tt>PartitionedTypeDefinitions</tt> to <a>IntrospectionResult</a>
--   because the function <tt>buildRemoteParser</tt> function which builds
--   the remote schema parsers accepts an <a>IntrospectionResult</a>. The
--   conversion involves converting `G.TypeDefinition ()` to
--   `G.TypeDefinition [G.Name]`. The `[G.Name]` here being the list of
--   object names that an interface implements. This is needed to be done
--   here by-hand because while specifying the <tt>SchemaDocument</tt>
--   through the GraphQL DSL, it doesn't include the <tt>possibleTypes</tt>
--   along with an object.
getSchemaDocIntrospection :: [TypeDefinition () RemoteSchemaInputValueDefinition] -> (Maybe Name, Maybe Name, Maybe Name) -> IntrospectionResult

-- | validateRemoteSchema accepts two arguments, the
--   <tt>SchemaDocument</tt> of the role-based schema, that is provided by
--   the user and the <tt>SchemaIntrospection</tt> of the upstream remote
--   schema. This function, in turn calls the other validation functions
--   for scalars, enums, unions, interfaces,input objects and objects.
validateRemoteSchema :: (MonadValidate [RoleBasedSchemaValidationError] m, MonadReader SchemaDocument m) => RemoteSchemaIntrospection -> m IntrospectionResult
resolveRoleBasedRemoteSchema :: MonadError QErr m => SchemaDocument -> RemoteSchemaCtx -> m (IntrospectionResult, [SchemaDependency])
instance GHC.Classes.Eq Hasura.RQL.DDL.RemoteSchema.Permission.FieldDefinitionType
instance GHC.Show.Show Hasura.RQL.DDL.RemoteSchema.Permission.FieldDefinitionType
instance GHC.Classes.Eq Hasura.RQL.DDL.RemoteSchema.Permission.ArgumentDefinitionType
instance GHC.Show.Show Hasura.RQL.DDL.RemoteSchema.Permission.ArgumentDefinitionType
instance GHC.Classes.Ord Hasura.RQL.DDL.RemoteSchema.Permission.PresetInputTypeInfo
instance GHC.Generics.Generic Hasura.RQL.DDL.RemoteSchema.Permission.PresetInputTypeInfo
instance GHC.Classes.Eq Hasura.RQL.DDL.RemoteSchema.Permission.PresetInputTypeInfo
instance GHC.Show.Show Hasura.RQL.DDL.RemoteSchema.Permission.PresetInputTypeInfo
instance GHC.Classes.Eq Hasura.RQL.DDL.RemoteSchema.Permission.GraphQLType
instance GHC.Show.Show Hasura.RQL.DDL.RemoteSchema.Permission.GraphQLType
instance GHC.Classes.Eq Hasura.RQL.DDL.RemoteSchema.Permission.RoleBasedSchemaValidationError
instance GHC.Show.Show Hasura.RQL.DDL.RemoteSchema.Permission.RoleBasedSchemaValidationError
instance Data.Text.Extended.ToTxt Hasura.RQL.DDL.RemoteSchema.Permission.GraphQLType
instance Data.Text.Extended.ToTxt Hasura.RQL.DDL.RemoteSchema.Permission.ArgumentDefinitionType
instance Data.Text.Extended.ToTxt Hasura.RQL.DDL.RemoteSchema.Permission.FieldDefinitionType

module Hasura.RQL.DDL.RemoteSchema
runAddRemoteSchema :: (QErrM m, CacheRWM m, MonadIO m, HasHttpManagerM m, MetadataM m, MonadTrace m) => Environment -> AddRemoteSchemaQuery -> m EncJSON
doesRemoteSchemaPermissionExist :: Metadata -> RemoteSchemaName -> RoleName -> Bool
runAddRemoteSchemaPermissions :: (QErrM m, CacheRWM m, HasServerConfigCtx m, MetadataM m) => AddRemoteSchemaPermission -> m EncJSON
runDropRemoteSchemaPermissions :: (QErrM m, CacheRWM m, MetadataM m) => DropRemoteSchemaPermissions -> m EncJSON
addRemoteSchemaP1 :: (QErrM m, CacheRM m) => RemoteSchemaName -> m ()
addRemoteSchemaP2Setup :: (QErrM m, MonadIO m, HasHttpManagerM m, MonadTrace m) => Environment -> AddRemoteSchemaQuery -> m RemoteSchemaCtx
runRemoveRemoteSchema :: (QErrM m, UserInfoM m, CacheRWM m, MetadataM m) => RemoteSchemaNameQuery -> m EncJSON
removeRemoteSchemaP1 :: (UserInfoM m, QErrM m, CacheRM m) => RemoteSchemaName -> m [RoleName]
runReloadRemoteSchema :: (QErrM m, CacheRWM m, MetadataM m) => RemoteSchemaNameQuery -> m EncJSON
runIntrospectRemoteSchema :: (CacheRM m, QErrM m) => RemoteSchemaNameQuery -> m EncJSON
runUpdateRemoteSchema :: (QErrM m, CacheRWM m, MonadIO m, HasHttpManagerM m, MetadataM m, MonadTrace m) => Environment -> AddRemoteSchemaQuery -> m EncJSON


-- | Top-level functions concerned specifically with operations on the
--   schema cache, such as rebuilding it from the catalog and incorporating
--   schema changes. See the module documentation for
--   <a>Hasura.RQL.DDL.Schema</a> for more details.
--   
--   <b>Note</b>: this module is <b>mutually recursive</b> with other
--   <tt>Hasura.RQL.DDL.Schema.*</tt> modules, which both define pieces of
--   the implementation of building the schema cache and define handlers
--   that trigger schema cache rebuilds.
module Hasura.RQL.DDL.Schema.Cache
buildRebuildableSchemaCache :: Logger Hasura -> Environment -> Metadata -> CacheBuild RebuildableSchemaCache
buildRebuildableSchemaCacheWithReason :: BuildReason -> Logger Hasura -> Environment -> Metadata -> CacheBuild RebuildableSchemaCache
newtype CacheRWT m a
CacheRWT :: StateT (RebuildableSchemaCache, CacheInvalidations) m a -> CacheRWT m a
runCacheRWT :: Functor m => RebuildableSchemaCache -> CacheRWT m a -> m (a, RebuildableSchemaCache, CacheInvalidations)
buildSchemaCacheRule :: (ArrowChoice arr, ArrowDistribute arr, ArrowCache m arr, MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadReader BuildReason m, HasHttpManagerM m, MonadResolveSource m, HasServerConfigCtx m) => Logger Hasura -> Environment -> (Metadata, InvalidationKeys) `arr` SchemaCache
buildRemoteSchemaRemoteRelationship :: forall arr m. (ArrowChoice arr, ArrowWriter (Seq CollectedInfo) arr, ArrowKleisli m arr, MonadError QErr m) => ((HashMap SourceName (AnyBackend PartiallyResolvedSource), RemoteSchemaMap), (RemoteSchemaName, RemoteSchemaIntrospection, Name, RemoteRelationship)) `arr` Maybe (RemoteFieldInfo Name)
mkRemoteSchemaRemoteRelationshipMetadataObject :: (RemoteSchemaName, Name, RemoteRelationship) -> MetadataObject
data BackendConfigAndSourceMetadata b
BackendConfigAndSourceMetadata :: BackendConfig b -> SourceMetadata b -> BackendConfigAndSourceMetadata b
[_bcasmBackendConfig] :: BackendConfigAndSourceMetadata b -> BackendConfig b
[_bcasmSourceMetadata] :: BackendConfigAndSourceMetadata b -> SourceMetadata b
joinBackendConfigsToSources :: BackendMap BackendConfigWrapper -> InsOrdHashMap SourceName (AnyBackend SourceMetadata) -> InsOrdHashMap SourceName (AnyBackend BackendConfigAndSourceMetadata)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Server.Types.HasServerConfigCtx m => Hasura.Server.Types.HasServerConfigCtx (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Tracing.MonadTrace m => Hasura.Tracing.MonadTrace (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Metadata.Class.MonadMetadataStorageQueryAPI m => Hasura.Metadata.Class.MonadMetadataStorageQueryAPI (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Network.HTTP.Client.Manager.HasHttpManagerM m => Network.HTTP.Client.Manager.HasHttpManagerM (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Session.UserInfoM m => Hasura.Session.UserInfoM (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.BackendConfigAndSourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Cache.BackendConfigAndSourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.BackendConfigAndSourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.Incremental.Internal.Dependency.Cacheable (Hasura.RQL.DDL.Schema.Cache.BackendConfigAndSourceMetadata b)
instance Control.Monad.Trans.Class.MonadTrans Hasura.RQL.DDL.Schema.Cache.CacheRWT
instance GHC.Base.Monad m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr m, Network.HTTP.Client.Manager.HasHttpManagerM m, Hasura.RQL.Types.Source.MonadResolveSource m, Hasura.Server.Types.HasServerConfigCtx m) => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)


-- | This module (along with the various <tt>Hasura.RQL.DDL.Schema.*</tt>
--   modules) provides operations to load and modify the Hasura catalog and
--   schema cache.
--   
--   <ul>
--   <li>The <i>catalog</i> refers to the set of PostgreSQL tables and
--   views that store all schema information known by Hasura. This includes
--   any tracked Postgres tables, views, and functions, all remote schemas,
--   and any additionaly Hasura-specific information such as permissions
--   and relationships.</li>
--   </ul>
--   
--   Primitive functions for loading and modifying the catalog are defined
--   in <a>Hasura.RQL.DDL.Schema.Catalog</a>, but most uses are wrapped by
--   other functions to synchronize catalog information with the
--   information in the schema cache.
--   
--   <ul>
--   <li>The <i>schema cache</i> is a process-global value of type
--   <tt>SchemaCache</tt> that stores an in-memory representation of the
--   data stored in the catalog. The in-memory representation is not
--   identical to the data in the catalog, since it has some
--   post-processing applied to it in order to make it easier to consume
--   for other parts of the system, such as GraphQL schema generation. For
--   example, although column information is represented by
--   <tt>RawColumnInfo</tt>, the schema cache contains “processed”
--   <tt>ColumnInfo</tt> values, instead.</li>
--   </ul>
--   
--   Ultimately, the catalog is the source of truth for all information
--   contained in the schema cache, but to avoid rebuilding the entire
--   schema cache on every change to the catalog, various functions
--   incrementally update the cache when they modify the catalog.
module Hasura.RQL.DDL.Schema
data RunSQLRes
RunSQLRes :: Text -> Value -> RunSQLRes
[rrResultType] :: RunSQLRes -> Text
[rrResult] :: RunSQLRes -> Value
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Schema.RunSQLRes
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.RunSQLRes
instance Database.PG.Query.Class.FromRes Hasura.RQL.DDL.Schema.RunSQLRes
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.RunSQLRes
instance GHC.Show.Show Hasura.RQL.DDL.Schema.RunSQLRes

module Hasura.RQL.DDL.Relationship.Rename
data RenameRel b
RenameRel :: SourceName -> TableName b -> RelName -> RelName -> RenameRel b
[_rrSource] :: RenameRel b -> SourceName
[_rrTable] :: RenameRel b -> TableName b
[_rrName] :: RenameRel b -> RelName
[_rrNewName] :: RenameRel b -> RelName
renameRelP2 :: forall b m. (QErrM m, CacheRM m, BackendMetadata b) => SourceName -> TableName b -> RelName -> RelInfo b -> m MetadataModifier
runRenameRel :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => RenameRel b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.Rename.RenameRel b)


-- | Postgres DDL RunSQL
--   
--   Escape hatch for running raw SQL against a postgres database.
--   
--   <a>runRunSQL</a> executes the provided raw SQL.
--   
--   <a>isSchemaCacheBuildRequiredRunSQL</a> checks for known
--   schema-mutating keywords in the raw SQL text.
--   
--   See <a>V2Query</a> and <a>Query</a>.
module Hasura.Backends.Postgres.DDL.RunSQL
data RunSQL
RunSQL :: Text -> SourceName -> Bool -> Maybe Bool -> TxAccess -> RunSQL
[rSql] :: RunSQL -> Text
[rSource] :: RunSQL -> SourceName
[rCascade] :: RunSQL -> Bool
[rCheckMetadataConsistency] :: RunSQL -> Maybe Bool
[rTxAccessMode] :: RunSQL -> TxAccess

-- | Check for known schema-mutating keywords in the raw SQL text.
--   
--   See Note [Checking metadata consistency in run_sql].
isSchemaCacheBuildRequiredRunSQL :: RunSQL -> Bool

-- | Fetch metadata of tracked tables<i>functions and build
--   @<a>TableMeta</a></i><tt><a>FunctionMeta</a> to calculate diff later
--   in </tt><a>withMetadataCheck</a>.
fetchTablesFunctionsMetadata :: forall pgKind m. (ToMetadataFetchQuery pgKind, FetchTableMetadata pgKind, FetchFunctionMetadata pgKind, BackendMetadata ('Postgres pgKind), MonadTx m) => TableCache ('Postgres pgKind) -> [TableName ('Postgres pgKind)] -> [FunctionName ('Postgres pgKind)] -> m ([TableMeta ('Postgres pgKind)], [FunctionMeta ('Postgres pgKind)])

-- | Used as an escape hatch to run raw SQL against a database.
runRunSQL :: forall (pgKind :: PostgresKind) m. (BackendMetadata ('Postgres pgKind), ToMetadataFetchQuery pgKind, FetchTableMetadata pgKind, FetchFunctionMetadata pgKind, CacheRWM m, HasServerConfigCtx m, MetadataM m, MonadBaseControl IO m, MonadError QErr m, MonadIO m, MonadTrace m, UserInfoM m) => RunSQL -> m EncJSON

-- | <tt><a>withMetadataCheck</a> source cascade txAccess runSQLQuery</tt>
--   executes <tt>runSQLQuery</tt> and checks if the schema changed as a
--   result. If it did, it checks to ensure the changes do not violate any
--   integrity constraints, and if not, incorporates them into the schema
--   cache. TODO(antoine): shouldn't this be generalized?
withMetadataCheck :: forall (pgKind :: PostgresKind) a m. (BackendMetadata ('Postgres pgKind), ToMetadataFetchQuery pgKind, FetchTableMetadata pgKind, FetchFunctionMetadata pgKind, CacheRWM m, HasServerConfigCtx m, MetadataM m, MonadBaseControl IO m, MonadError QErr m, MonadIO m) => SourceName -> Bool -> TxAccess -> TxET QErr m a -> m a

-- | <tt>'runTxWithMetadataCheck source sourceConfig txAccess tableCache
--   functionCache cascadeDependencies tx' checks for changes in GraphQL
--   Engine metadata when a </tt><tt>tx</tt> is executed on the database
--   alters Postgres schema of tables and functions. If any indirect
--   dependencies (Eg. remote table dependence of a relationship) are found
--   and @<tt>cascadeDependencies</tt> is False, then an exception is
--   raised.
runTxWithMetadataCheck :: forall m a (pgKind :: PostgresKind). (BackendMetadata ('Postgres pgKind), ToMetadataFetchQuery pgKind, FetchTableMetadata pgKind, FetchFunctionMetadata pgKind, CacheRWM m, MonadIO m, MonadBaseControl IO m, MonadError QErr m) => SourceName -> SourceConfig ('Postgres pgKind) -> TxAccess -> TableCache ('Postgres pgKind) -> FunctionCache ('Postgres pgKind) -> Bool -> TxET QErr m a -> m (a, MetadataModifier)

-- | Fetch list of tables and functions with provided oids
fetchTablesFunctionsFromOids :: MonadIO m => [OID] -> [OID] -> TxET QErr m ([TableName ('Postgres pgKind)], [FunctionName ('Postgres pgKind)])
getComputedFields :: TableInfo ('Postgres pgKind) -> [ComputedFieldInfo ('Postgres pgKind)]
getComputedFieldFunctions :: TableInfo ('Postgres pgKind) -> [FunctionName ('Postgres pgKind)]
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.RunSQL.RunSQL
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.RunSQL.RunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.DDL.RunSQL.RunSQL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.DDL.RunSQL.RunSQL

module Hasura.Backends.MySQL.SQL
data RunSQL
RunSQL :: Text -> SourceName -> RunSQL
[_Sql] :: RunSQL -> Text
[_Source] :: RunSQL -> SourceName
runSQL :: (MonadIO m, CacheRWM m, MonadError QErr m, MetadataM m) => RunSQL -> m EncJSON
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MySQL.SQL.RunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MySQL.SQL.RunSQL
instance GHC.Classes.Eq Hasura.Backends.MySQL.SQL.RunSQL
instance GHC.Show.Show Hasura.Backends.MySQL.SQL.RunSQL


-- | MSSQL DDL RunSQL
--   
--   Provides primitives for running raw text SQL on MSSQL backends.
module Hasura.Backends.MSSQL.DDL.RunSQL
data MSSQLRunSQL
MSSQLRunSQL :: Text -> SourceName -> Bool -> Maybe Bool -> MSSQLRunSQL
[_mrsSql] :: MSSQLRunSQL -> Text
[_mrsSource] :: MSSQLRunSQL -> SourceName
[_mrsCascade] :: MSSQLRunSQL -> Bool
[_mrsCheckMetadataConsistency] :: MSSQLRunSQL -> Maybe Bool
runSQL :: forall m. (MonadIO m, MonadBaseControl IO m, CacheRWM m, MonadError QErr m, MetadataM m) => MSSQLRunSQL -> m EncJSON
isSchemaCacheBuildRequiredRunSQL :: MSSQLRunSQL -> Bool
toResult :: [[(Column, Value)]] -> RunSQLRes
instance GHC.Classes.Eq Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL
instance GHC.Show.Show Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL


-- | Working example:
--   
--   $ curl -XPOST <a>http://localhost:8080/v2/query</a> -d @- &lt;&lt;EOF
--   { "type":"bigquery_run_sql", "args": { "sql":"select 3 * 4 as foo,
--   "Hello, World!" as bar", "source":"chinook" } } EOF
--   {"result_type":<a>TuplesOk</a>,"result":[["foo","bar"],["12","Hello,
--   World!"]]}
module Hasura.Backends.BigQuery.DDL.RunSQL
data BigQueryRunSQL
BigQueryRunSQL :: Text -> SourceName -> BigQueryRunSQL
[_mrsSql] :: BigQueryRunSQL -> Text
[_mrsSource] :: BigQueryRunSQL -> SourceName
runSQL :: (MonadIO m, CacheRWM m, MonadError QErr m, MetadataM m) => BigQueryRunSQL -> m EncJSON

-- | The SQL query in the request is ignored
runDatabaseInspection :: (MonadIO m, CacheRWM m, MonadError QErr m, MetadataM m) => BigQueryRunSQL -> m EncJSON
runSQL_ :: (MonadIO m, CacheRWM m, MonadError QErr m, MetadataM m) => (RecordSet -> Value) -> BigQueryRunSQL -> m EncJSON
recordSetAsHeaderAndRows :: RecordSet -> Value
recordSetAsSchema :: RecordSet -> Value
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL
instance GHC.Classes.Eq Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL
instance GHC.Show.Show Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL

module Hasura.GraphQL.Execute.Backend

-- | This typeclass enacapsulates how a given backend translates a root
--   field into an execution plan. For now, each root field maps to one
--   execution step, but in the future, when we have a client-side
--   dataloader, each root field might translate into a multi-step plan.
class (Backend b, ToTxt (MultiplexedQuery b), Monad (ExecutionMonad b)) => BackendExecute (b :: BackendType) where {
    type family PreparedQuery b :: Type;
    type family MultiplexedQuery b :: Type;
    type family ExecutionMonad b :: Type -> Type;
}
mkDBQueryPlan :: forall m. (BackendExecute b, MonadError QErr m, MonadQueryTags m, MonadReader QueryTagsComment m) => UserInfo -> Environment -> SourceName -> SourceConfig b -> QueryDB b Void (UnpreparedValue b) -> m (DBStepInfo b)
mkDBMutationPlan :: forall m. (BackendExecute b, MonadError QErr m, MonadQueryTags m, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceName -> SourceConfig b -> MutationDB b Void (UnpreparedValue b) -> m (DBStepInfo b)
mkLiveQuerySubscriptionPlan :: forall m. (BackendExecute b, MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadReader QueryTagsComment m) => UserInfo -> SourceName -> SourceConfig b -> Maybe Name -> RootFieldMap (QueryDB b Void (UnpreparedValue b)) -> m (SubscriptionQueryPlan b (MultiplexedQuery b))
mkDBStreamingSubscriptionPlan :: forall m. (BackendExecute b, MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadReader QueryTagsComment m) => UserInfo -> SourceName -> SourceConfig b -> (RootFieldAlias, QueryDB b Void (UnpreparedValue b)) -> m (SubscriptionQueryPlan b (MultiplexedQuery b))
mkDBQueryExplain :: forall m. (BackendExecute b, MonadError QErr m) => RootFieldAlias -> UserInfo -> SourceName -> SourceConfig b -> QueryDB b Void (UnpreparedValue b) -> m (AnyBackend DBStepInfo)
mkSubscriptionExplain :: (BackendExecute b, MonadError QErr m, MonadIO m, MonadBaseControl IO m) => SubscriptionQueryPlan b (MultiplexedQuery b) -> m SubscriptionQueryPlanExplanation
mkDBRemoteRelationshipPlan :: forall m. (BackendExecute b, MonadError QErr m, MonadQueryTags m) => UserInfo -> SourceName -> SourceConfig b -> NonEmpty Object -> HashMap FieldName (Column b, ScalarType b) -> FieldName -> (FieldName, SourceRelationshipSelection b Void UnpreparedValue) -> m (DBStepInfo b)

-- | This is a helper function to convert a remote source's relationship to
--   a normal relationship to a temporary table. This function can be used
--   to implement executeRemoteRelationship function in databases which
--   support constructing a temporary table for a list of json objects.
convertRemoteSourceRelationship :: forall b. Backend b => HashMap (Column b) (Column b) -> SelectFromG b (UnpreparedValue b) -> Column b -> ColumnType b -> (FieldName, SourceRelationshipSelection b Void UnpreparedValue) -> QueryDB b Void (UnpreparedValue b)
data DBStepInfo b
DBStepInfo :: SourceName -> SourceConfig b -> Maybe (PreparedQuery b) -> ExecutionMonad b EncJSON -> DBStepInfo b
[dbsiSourceName] :: DBStepInfo b -> SourceName
[dbsiSourceConfig] :: DBStepInfo b -> SourceConfig b
[dbsiPreparedQuery] :: DBStepInfo b -> Maybe (PreparedQuery b)
[dbsiAction] :: DBStepInfo b -> ExecutionMonad b EncJSON

-- | The result of an explain query: for a given root field (denoted by its
--   name): the generated SQL query, and the detailed explanation obtained
--   from the database (if any). We mostly use this type as an intermediary
--   step, and immediately tranform any value we obtain into an equivalent
--   JSON representation.
data ExplainPlan
ExplainPlan :: !RootFieldAlias -> !Maybe Text -> !Maybe [Text] -> ExplainPlan
[_fpField] :: ExplainPlan -> !RootFieldAlias
[_fpSql] :: ExplainPlan -> !Maybe Text
[_fpPlan] :: ExplainPlan -> !Maybe [Text]

-- | One execution step to processing a GraphQL query (e.g. one root
--   field).
data ExecutionStep

-- | A query to execute against the database
[ExecStepDB] :: ResponseHeaders -> AnyBackend DBStepInfo -> Maybe RemoteJoins -> ExecutionStep

-- | Execute an action
[ExecStepAction] :: ActionExecutionPlan -> ActionsInfo -> Maybe RemoteJoins -> ExecutionStep

-- | A graphql query to execute against a remote schema
[ExecStepRemote] :: !RemoteSchemaInfo -> !ResultCustomizer -> !GQLReqOutgoing -> Maybe RemoteJoins -> ExecutionStep

-- | Output a plain JSON object
[ExecStepRaw] :: Value -> ExecutionStep
[ExecStepMulti] :: [ExecutionStep] -> ExecutionStep

-- | The series of steps that need to be executed for a given query. For
--   now, those steps are all independent. In the future, when we implement
--   a client-side dataloader and generalized joins, this will need to be
--   changed into an annotated tree.
type ExecutionPlan = RootFieldMap ExecutionStep
class (Monad m) => MonadQueryTags m

-- | Creates Query Tags. These are appended to the Generated SQL. Helps
--   users to use native database monitoring tools to get some
--   'application-context'.
createQueryTags :: MonadQueryTags m => QueryTagsAttributes -> Maybe QueryTagsConfig -> Tagged m QueryTagsComment
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Backend.ExplainPlan
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Backend.ExplainPlan
instance GHC.Show.Show Hasura.GraphQL.Execute.Backend.ExplainPlan
instance Hasura.GraphQL.Execute.Backend.MonadQueryTags m => Hasura.GraphQL.Execute.Backend.MonadQueryTags (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.GraphQL.Execute.Backend.MonadQueryTags m => Hasura.GraphQL.Execute.Backend.MonadQueryTags (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Execute.Backend.MonadQueryTags m => Hasura.GraphQL.Execute.Backend.MonadQueryTags (Hasura.Tracing.TraceT m)
instance Hasura.GraphQL.Execute.Backend.MonadQueryTags m => Hasura.GraphQL.Execute.Backend.MonadQueryTags (Hasura.Metadata.Class.MetadataStorageT m)
instance Hasura.GraphQL.Execute.Backend.MonadQueryTags m => Hasura.GraphQL.Execute.Backend.MonadQueryTags (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance Hasura.GraphQL.Execute.Backend.MonadQueryTags m => Hasura.GraphQL.Execute.Backend.MonadQueryTags (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.GraphQL.Execute.Backend.MonadQueryTags m => Hasura.GraphQL.Execute.Backend.MonadQueryTags (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.GraphQL.Execute.Backend.MonadQueryTags m => Hasura.GraphQL.Execute.Backend.MonadQueryTags (Hasura.RQL.Types.Run.RunT m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Backend.ExplainPlan


-- | The RQL query ('<i>v2</i>query')
module Hasura.Server.API.V2Query
data RQLQuery
RQInsert :: !InsertQuery -> RQLQuery
RQSelect :: !SelectQuery -> RQLQuery
RQUpdate :: !UpdateQuery -> RQLQuery
RQDelete :: !DeleteQuery -> RQLQuery
RQCount :: !CountQuery -> RQLQuery
RQRunSql :: !RunSQL -> RQLQuery
RQMssqlRunSql :: !MSSQLRunSQL -> RQLQuery
RQCitusRunSql :: !RunSQL -> RQLQuery
RQCockroachRunSql :: !RunSQL -> RQLQuery
RQMysqlRunSql :: !RunSQL -> RQLQuery
RQBigqueryRunSql :: !BigQueryRunSQL -> RQLQuery
RQBigqueryDatabaseInspection :: !BigQueryRunSQL -> RQLQuery
RQBulk :: ![RQLQuery] -> RQLQuery
runQuery :: (MonadIO m, MonadBaseControl IO m, MonadTrace m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m) => Environment -> InstanceId -> UserInfo -> RebuildableSchemaCache -> Manager -> ServerConfigCtx -> RQLQuery -> m (EncJSON, RebuildableSchemaCache)
queryModifiesSchema :: RQLQuery -> Bool
runQueryM :: (MonadError QErr m, MonadIO m, MonadBaseControl IO m, UserInfoM m, CacheRWM m, HasServerConfigCtx m, MonadTrace m, MetadataM m, MonadQueryTags m) => Environment -> RQLQuery -> m EncJSON
queryModifiesUserDB :: RQLQuery -> Bool
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.V2Query.RQLQuery
instance GHC.Generics.Generic Hasura.Server.API.V2Query.RQLQuery

module Hasura.GraphQL.Transport.Backend

-- | This typeclass enacapsulates how a given backend sends queries and
--   mutations over the network. Each backend is currently responsible for
--   both logging and tracing, for now.
class BackendExecute b => BackendTransport (b :: BackendType)
runDBQuery :: forall m. (BackendTransport b, MonadIO m, MonadError QErr m, MonadQueryLog m, MonadTrace m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> SourceConfig b -> ExecutionMonad b EncJSON -> Maybe (PreparedQuery b) -> m (DiffTime, EncJSON)
runDBMutation :: forall m. (BackendTransport b, MonadIO m, MonadError QErr m, MonadQueryLog m, MonadTrace m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> SourceConfig b -> ExecutionMonad b EncJSON -> Maybe (PreparedQuery b) -> m (DiffTime, EncJSON)
runDBSubscription :: forall m. (BackendTransport b, MonadIO m) => SourceConfig b -> MultiplexedQuery b -> [(CohortId, CohortVariables)] -> m (DiffTime, Either QErr [(CohortId, ByteString)])
runDBStreamingSubscription :: forall m. (BackendTransport b, MonadIO m) => SourceConfig b -> MultiplexedQuery b -> [(CohortId, CohortVariables)] -> m (DiffTime, Either QErr [(CohortId, ByteString, CursorVariableValues)])
runDBQueryExplain :: forall m. (BackendTransport b, MonadIO m, MonadError QErr m) => DBStepInfo b -> m EncJSON

module Hasura.GraphQL.Execute.Remote
getVariableDefinitionAndValue :: Variable -> (VariableDefinition, (Name, Value))
unresolveVariables :: forall fragments. Functor fragments => SelectionSet fragments Variable -> SelectionSet fragments Name
collectVariables :: forall fragments var. (Foldable fragments, Hashable var, Eq var) => SelectionSet fragments var -> HashSet var
buildExecStepRemote :: RemoteSchemaInfo -> ResultCustomizer -> OperationType -> GraphQLField Void Variable -> Maybe RemoteJoins -> Maybe OperationName -> ExecutionStep

-- | Association between keys uniquely identifying some remote JSON
--   variable and an <a>Int</a> identifier that will be used to construct a
--   valid variable name to be used in a GraphQL query.
newtype RemoteJSONVariableMap
RemoteJSONVariableMap :: HashMap RemoteJSONVariableKey Int -> RemoteJSONVariableMap

-- | A unique identifier for some remote JSON variable whose name will need
--   to be substituted when constructing a GraphQL query.
--   
--   For a detailed explanation of this behavior, see the following
--   comment:
--   <a>https://github.com/hasura/graphql-engine/issues/7170#issuecomment-880838970</a>
data RemoteJSONVariableKey
RemoteJSONVariableKey :: !GType -> !Value -> RemoteJSONVariableKey

-- | Resolves a <a>RemoteSchemaVariable</a> into a GraphQL <a>Variable</a>.
--   
--   A <a>RemoteSchemaVariable</a> can either be a query variable (i.e. a
--   variable provided in the query) or it can be a
--   <a>SessionPresetVariable</a> (in which case we look up the value of
--   the session variable and coerce it into the appropriate type and then
--   construct the GraphQL <a>Variable</a>).
--   
--   NOTE: The session variable preset is a hard preset (i.e. if the
--   session variable doesn't exist, an error will be thrown).
--   
--   The name of the GraphQL variable generated will be a GraphQL-ized
--   version of the session variable (i.e. <a>-</a> will be replaced with
--   '_'), since session variables are not valid GraphQL names.
--   
--   Additionally, we need to handle partially traversed JSON values;
--   likewise, we create a new variable out of thin air.
--   
--   For example, considering the following schema for a role:
--   
--   input UserName { firstName : String! @preset(value:<a>Foo</a>)
--   lastName : String! }
--   
--   type Query { user( user_id: Int! @preset(value:"x-hasura-user-id")
--   user_name: UserName! ): User }
--   
--   and the incoming query to the graphql-engine is:
--   
--   query($foo: UserName!) { user(user_name: $foo) { id name } }
--   
--   with variables:
--   
--   { "foo": {"lastName": <a>Bar</a>} }
--   
--   After resolving the session argument presets, the query that will be
--   sent to the remote server will be:
--   
--   query ($x_hasura_user_id: Int!, $hasura_json_var_1: String!) { user
--   (user_id: $x_hasura_user_id, user_name: {firstName: <a>Foo</a>,
--   lastName: $hasura_json_var_1}) { id name } }
resolveRemoteVariable :: MonadError QErr m => UserInfo -> RemoteSchemaVariable -> StateT RemoteJSONVariableMap m Variable

-- | TODO: Documentation.
resolveRemoteField :: MonadError QErr m => UserInfo -> RemoteSchemaRootField r RemoteSchemaVariable -> StateT RemoteJSONVariableMap m (RemoteSchemaRootField r Variable)

-- | TODO: Documentation.
runVariableCache :: Monad m => StateT RemoteJSONVariableMap m a -> m a
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Remote.RemoteJSONVariableKey
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Remote.RemoteJSONVariableKey
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Remote.RemoteJSONVariableKey
instance GHC.Base.Semigroup Hasura.GraphQL.Execute.Remote.RemoteJSONVariableMap
instance GHC.Base.Monoid Hasura.GraphQL.Execute.Remote.RemoteJSONVariableMap
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Remote.RemoteJSONVariableMap


-- | How to construct and execute a call to a remote schema for a remote
--   join.
--   
--   There are three steps required to do this: 1. construct the call:
--   given the requested fields, the phantom fields, the values extracted
--   by the LHS, construct a GraphQL query 2. execute that GraphQL query
--   over the network 3. build a index of the variables out of the response
--   
--   This can be done as one function, but we also export the individual
--   steps for debugging / test purposes. We congregate all intermediary
--   state in the opaque <a>RemoteSchemaCall</a> type.
module Hasura.GraphQL.Execute.RemoteJoin.RemoteSchema

-- | Construct and execute a call to a remote schema for a remote join.
makeRemoteSchemaJoinCall :: MonadError QErr m => (GQLReqOutgoing -> m ByteString) -> UserInfo -> RemoteSchemaJoin -> IntMap JoinArgument -> m (Maybe (IntMap Value))

-- | Intermediate type containing all of the information required to
--   perform a remote schema call, constructed from the static join
--   information.
data RemoteSchemaCall
RemoteSchemaCall :: ResultCustomizer -> GQLReqOutgoing -> IntMap ResponsePath -> RemoteSchemaCall
[rscCustomizer] :: RemoteSchemaCall -> ResultCustomizer
[rscGQLRequest] :: RemoteSchemaCall -> GQLReqOutgoing
[rscResponsePaths] :: RemoteSchemaCall -> IntMap ResponsePath

-- | Used to extract the value from a remote schema response.
--   
--   For example: if a remote relationship is defined to retrieve data from
--   some deeply nested field, this is the path towards that deeply nested
--   field.
newtype ResponsePath
ResponsePath :: NonEmpty Name -> ResponsePath

-- | Constructs a <a>RemoteSchemaCall</a> from some static information,
--   such as the definition of the join, and dynamic information such as
--   the user's information and the map of join arguments.
buildRemoteSchemaCall :: MonadError QErr m => RemoteSchemaJoin -> IntMap JoinArgument -> UserInfo -> m (Maybe RemoteSchemaCall)

-- | Fold nested <a>FieldCall</a>s into a bare <tt>Field</tt>, inserting
--   the passed selection set at the leaf of the tree we construct.
fieldCallsToField :: forall m. MonadError QErr m => HashMap Name (InputValue RemoteSchemaVariable) -> HashMap Name (Value Void) -> SelectionSet NoFragments RemoteSchemaVariable -> Name -> NonEmpty FieldCall -> m (Field NoFragments RemoteSchemaVariable)

-- | Create an argument map using the inputs taken from the left hand side.
createArguments :: MonadError QErr m => HashMap Name (Value Void) -> RemoteArguments -> m (HashMap Name (Value Void))

-- | Combine two GraphQL values together.
--   
--   This is used to combine different input arguments into one. This
--   function can only combine objects or lists pairwise, and fails if it
--   has to combine any other combination of values.
--   
--   <pre>
--   &gt;&gt;&gt; combineValues (Object (fromList [("id", Number 1)]) (Object (fromList [("name", String "foo")])
--   Object (fromList [("id", Number 1), ("name", String "foo")])
--   </pre>
combineValues :: MonadError QErr m => Name -> Value RemoteSchemaVariable -> Value RemoteSchemaVariable -> m (Value RemoteSchemaVariable)

-- | Craft a GraphQL query document from the list of fields.
fieldsToRequest :: NonEmpty (Field NoFragments Variable) -> GQLReqOutgoing

-- | Sends the call over the network, and parse the resulting ByteString.
executeRemoteSchemaCall :: MonadError QErr m => (GQLReqOutgoing -> m ByteString) -> RemoteSchemaCall -> m Object

-- | Construct a join index from the remote source's <a>Value</a> response.
--   
--   This function extracts from the <tt>RemoteJoinCall</tt> a mapping from
--   <a>JoinArgumentId</a> to <a>ResponsePath</a>: from an integer that
--   uniquely identifies a join argument to the "path" at which we expect
--   that value in the response. With it, and with the actual reponse JSON
--   value obtained from the remote server, it constructs a corresponding
--   mapping of, for each argument, its extracted value.
--   
--   If the response does not have value at any of the provided
--   <a>ResponsePath</a>s, throw a generic <a>QErr</a>.
--   
--   NOTE(jkachmar): If we switch to an <a>Applicative</a> validator, we
--   can collect more than one missing <a>ResponsePath</a>s (rather than
--   short-circuiting on the first missing value).
buildJoinIndex :: forall m. MonadError QErr m => RemoteSchemaCall -> Object -> m (IntMap Value)
parseGraphQLName :: MonadError QErr m => Text -> m Name
ordJSONValueToGValue :: MonadError QErr n => Value -> n (Value Void)
instance GHC.Show.Show Hasura.GraphQL.Execute.RemoteJoin.RemoteSchema.ResponsePath
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.RemoteSchema.ResponsePath


-- | Postgres Execute Prepare
--   
--   Deals with translating (session) variables to SQL expressions. Uses a
--   state monad to keep track of things like variables and generating
--   fresh variable names.
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Prepare
type PlanVariables = HashMap Name Int

-- | The value is (Q.PrepArg, PGScalarValue) because we want to log the
--   human-readable value of the prepared argument and not the binary
--   encoding in PG format
type PrepArgMap = IntMap (PrepArg, PGScalarValue)
data PlanningSt
PlanningSt :: Int -> PlanVariables -> PrepArgMap -> PlanningSt
[_psArgNumber] :: PlanningSt -> Int
[_psVariables] :: PlanningSt -> PlanVariables
[_psPrepped] :: PlanningSt -> PrepArgMap
initPlanningSt :: PlanningSt

-- | If we're preparing a value with planning state, we favour referring to
--   values by their prepared argument index. If the value refers to a
--   session value, we look for it in prepared value (1) and access the
--   particular keys using the JSONB <tt>-&gt;&gt;</tt> accessor.
prepareWithPlan :: (MonadState PlanningSt m, MonadError QErr m) => UserInfo -> UnpreparedValue ('Postgres pgKind) -> m SQLExp

-- | If we're <i>not</i> using a prepared statement, substitution is pretty
--   naïve: we resolve session variable names, ignore parameter names, and
--   substitute into the <a>SQLExp</a>.
prepareWithoutPlan :: MonadError QErr m => UserInfo -> UnpreparedValue ('Postgres pgKind) -> m SQLExp

-- | The map of user session variables is always given the number (1) as
--   its variable argument number (see <a>getVarArgNum</a>). If we want to
--   refer to a particular variable in this map, we use JSONB functions to
--   interrogate variable (1).
withUserVars :: SessionVariables -> PrepArgMap -> PrepArgMap

-- | In prepared statements, we refer to variables by a number, not their
--   name. If the statement already refers to a variable, then we'll
--   already have a number for it, and so we just return that. Otherwise,
--   we produce a new number, and that will refer to the variable from now
--   on.
getVarArgNum :: MonadState PlanningSt m => Name -> m Int

-- | Add a prepared argument to the prepared argument map. These are keyed
--   by the variable argument numbers, which can be computed using
--   <a>getVarArgNum</a>.
addPrepArg :: MonadState PlanningSt m => Int -> (PrepArg, PGScalarValue) -> m ()

-- | Get <a>_psArgNumber</a> from inside the <a>PlanningSt</a> and
--   increment it for the next operation. Think of this as a pure analogue
--   to <a>newUnique</a>.
getNextArgNum :: MonadState PlanningSt m => m Int
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.Prepare.PlanningSt
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Prepare.PlanningSt

module Hasura.GraphQL.Execute.Action
fetchActionLogResponses :: (MonadError QErr m, MonadMetadataStorage (MetadataStorageT m), Foldable t) => t ActionId -> m (ActionLogResponseMap, Bool)
runActionExecution :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m, MonadMetadataStorage (MetadataStorageT m)) => UserInfo -> ActionExecutionPlan -> m (DiffTime, (EncJSON, Maybe ResponseHeaders))

-- | This function is generally used on the result of
--   <tt>selectQuerySQL</tt>, <tt>selectAggregateQuerySQL</tt> or
--   <tt>connectionSelectSQL</tt> to run said query and get back the
--   resulting JSON.
asSingleRowJsonResp :: Query -> [PrepArg] -> TxE QErr EncJSON

-- | Synchronously execute webhook handler and resolve response to action
--   "output"
resolveActionExecution :: Environment -> Logger Hasura -> UserInfo -> AnnActionExecution Void -> ActionExecContext -> Maybe GQLQueryText -> ActionExecution
throwUnexpected :: MonadError QErr m => Text -> m ()
validateResponseObject :: MonadError QErr m => KeyMap Value -> ActionOutputFields -> m ()
validateResponse :: MonadError QErr m => Value -> GraphQLType -> ActionOutputFields -> m ()

-- | Build action response from the Webhook JSON response when there are no
--   relationships defined
makeActionResponseNoRelations :: ActionFields -> GraphQLType -> ActionOutputFields -> Bool -> ActionWebhookResponse -> Value
gTypeContains :: (GType -> ActionOutputFields -> Bool) -> GType -> ActionOutputFields -> Bool
isCustomScalar :: GType -> ActionOutputFields -> Bool

-- | Resolve asynchronous action mutation which returns only the action
--   uuid
resolveActionMutationAsync :: MonadMetadataStorage m => AnnActionMutationAsync -> [Header] -> SessionVariables -> m ActionId

-- | See Note: [Resolving async action query]
resolveAsyncActionQuery :: UserInfo -> AnnActionAsyncQuery ('Postgres 'Vanilla) Void -> AsyncActionQueryExecution (UnpreparedValue ('Postgres 'Vanilla))

-- | Process async actions from hdb_catalog.hdb_action_log table. This
--   functions is executed in a background thread. See Note [Async action
--   architecture] above
asyncActionsProcessor :: forall m. (MonadIO m, MonadBaseControl IO m, Forall (Pure m), HasReporter m, MonadMetadataStorage (MetadataStorageT m)) => Environment -> Logger Hasura -> IO SchemaCache -> TVar (Set LockedActionEventId) -> Manager -> Milliseconds -> Maybe GQLQueryText -> m (Forever m)
callWebhook :: forall m r. (MonadIO m, MonadError QErr m, MonadTrace m, MonadReader r m, Has (Logger Hasura) r) => Environment -> Manager -> GraphQLType -> ActionOutputFields -> [Header] -> [HeaderConf] -> Bool -> EnvRecord ResolvedWebhook -> ActionWebhookPayload -> Timeout -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> m (ActionWebhookResponse, ResponseHeaders)
processOutputSelectionSet :: ArgumentExp v -> GraphQLType -> [(PGCol, PGScalarType)] -> ActionFields -> StringifyNumbers -> AnnSimpleSelectG ('Postgres 'Vanilla) Void v
actionFieldToAnnField :: ActionFieldG Void -> AnnFieldG ('Postgres 'Vanilla) Void v
mkJsonAggSelect :: GraphQLType -> JsonAggSelect
insertActionTx :: ActionName -> SessionVariables -> [Header] -> Value -> TxE QErr ActionId
fetchUndeliveredActionEventsTx :: TxE QErr [ActionLogItem]
setActionStatusTx :: ActionId -> AsyncActionStatus -> TxE QErr ()
fetchActionResponseTx :: ActionId -> TxE QErr ActionLogResponse
clearActionDataTx :: ActionName -> TxE QErr ()
setProcessingActionLogsToPendingTx :: LockedActionIdArray -> TxE QErr ()


-- | Postgres Instances Execute
--   
--   This module implements the needed functionality for implementing a
--   <a>BackendExecute</a> instance for Postgres, which defines an
--   interface for translating a root field into an execution plan and
--   interacting with a database.
--   
--   This module includes the Postgres implementation of queries,
--   mutations, and more.
module Hasura.Backends.Postgres.Instances.Execute
data PreparedSql
PreparedSql :: Query -> PrepArgMap -> PreparedSql
[_psQuery] :: PreparedSql -> Query
[_psPrepArgs] :: PreparedSql -> PrepArgMap
pgDBQueryPlan :: forall pgKind m. (MonadError QErr m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => UserInfo -> Environment -> SourceName -> SourceConfig ('Postgres pgKind) -> QueryDB ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind)) -> m (DBStepInfo ('Postgres pgKind))
pgDBQueryExplain :: forall pgKind m. (MonadError QErr m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => RootFieldAlias -> UserInfo -> SourceName -> SourceConfig ('Postgres pgKind) -> QueryDB ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind)) -> m (AnyBackend DBStepInfo)
pgDBSubscriptionExplain :: (MonadError QErr m, MonadIO m, MonadBaseControl IO m) => SubscriptionQueryPlan ('Postgres pgKind) (MultiplexedQuery ('Postgres pgKind)) -> m SubscriptionQueryPlanExplanation
convertDelete :: forall pgKind m. (MonadError QErr m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => UserInfo -> AnnDelG ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind)) -> StringifyNumbers -> m (TraceT (TxET QErr IO) EncJSON)
convertUpdate :: forall pgKind m. (MonadError QErr m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => UserInfo -> AnnotatedUpdateG ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind)) -> StringifyNumbers -> m (TraceT (TxET QErr IO) EncJSON)
convertInsert :: forall pgKind m. (MonadError QErr m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => UserInfo -> AnnotatedInsert ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind)) -> StringifyNumbers -> m (TraceT (TxET QErr IO) EncJSON)

-- | A pared-down version of <a>convertQuerySelSet</a>, for use in
--   execution of special case of SQL function mutations (see
--   <a>MDBFunction</a>).
convertFunction :: forall pgKind m. (MonadError QErr m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => UserInfo -> JsonAggSelect -> AnnSimpleSelectG ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind)) -> m (TraceT (TxET QErr IO) EncJSON)
pgDBMutationPlan :: forall pgKind m. (MonadError QErr m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceName -> SourceConfig ('Postgres pgKind) -> MutationDB ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind)) -> m (DBStepInfo ('Postgres pgKind))
pgDBLiveQuerySubscriptionPlan :: forall pgKind m. (MonadError QErr m, MonadIO m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => UserInfo -> SourceName -> SourceConfig ('Postgres pgKind) -> Maybe Name -> RootFieldMap (QueryDB ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind))) -> m (SubscriptionQueryPlan ('Postgres pgKind) (MultiplexedQuery ('Postgres pgKind)))
pgDBStreamingSubscriptionPlan :: forall pgKind m. (MonadError QErr m, MonadIO m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, MonadReader QueryTagsComment m) => UserInfo -> SourceName -> SourceConfig ('Postgres pgKind) -> (RootFieldAlias, QueryDB ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind))) -> m (SubscriptionQueryPlan ('Postgres pgKind) (MultiplexedQuery ('Postgres pgKind)))
mkCurPlanTx :: UserInfo -> PreparedSql -> (TraceT (TxET QErr IO) EncJSON, Maybe PreparedSql)

-- | This function is generally used on the result of
--   <tt>selectQuerySQL</tt>, <tt>selectAggregateQuerySQL</tt> or
--   <tt>connectionSelectSQL</tt> to run said query and get back the
--   resulting JSON.
asSingleRowJsonResp :: Query -> [PrepArg] -> TxE QErr EncJSON
irToRootFieldPlan :: (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => PrepArgMap -> QueryDB ('Postgres pgKind) Void SQLExp -> PreparedSql
appendPreparedSQLWithQueryTags :: PreparedSql -> QueryTagsComment -> PreparedSql
appendSQLWithQueryTags :: Query -> QueryTagsComment -> Query

-- | Construct an action (i.e. <a>DBStepInfo</a>) which can marshal some
--   remote relationship information into a form that Postgres can query
--   against.
pgDBRemoteRelationshipPlan :: forall pgKind m. (MonadError QErr m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => UserInfo -> SourceName -> SourceConfig ('Postgres pgKind) -> NonEmpty Object -> HashMap FieldName (Column ('Postgres pgKind), ScalarType ('Postgres pgKind)) -> FieldName -> (FieldName, SourceRelationshipSelection ('Postgres pgKind) Void UnpreparedValue) -> m (DBStepInfo ('Postgres pgKind))
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind), Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON.PostgresAnnotatedFieldJSON pgKind) => Hasura.GraphQL.Execute.Backend.BackendExecute ('Hasura.SQL.Backend.Postgres pgKind)


-- | Postgres Instances Transport
--   
--   Defines the MSSQL instance of <a>BackendTransport</a> and how to
--   interact with the database for running queries, mutations,
--   subscriptions, and so on.
module Hasura.Backends.Postgres.Instances.Transport
runPGQuery :: (MonadIO m, MonadError QErr m, MonadQueryLog m, MonadTrace m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> SourceConfig ('Postgres pgKind) -> TraceT (TxET QErr IO) EncJSON -> Maybe PreparedSql -> m (DiffTime, EncJSON)
runPGMutation :: (MonadIO m, MonadError QErr m, MonadQueryLog m, MonadTrace m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> SourceConfig ('Postgres pgKind) -> TraceT (TxET QErr IO) EncJSON -> Maybe PreparedSql -> m (DiffTime, EncJSON)
runPGSubscription :: MonadIO m => SourceConfig ('Postgres pgKind) -> MultiplexedQuery ('Postgres pgKind) -> [(CohortId, CohortVariables)] -> m (DiffTime, Either QErr [(CohortId, ByteString)])
runPGStreamingSubscription :: MonadIO m => SourceConfig ('Postgres pgKind) -> MultiplexedQuery ('Postgres pgKind) -> [(CohortId, CohortVariables)] -> m (DiffTime, Either QErr [(CohortId, ByteString, CursorVariableValues)])
runPGQueryExplain :: forall pgKind m. (MonadIO m, MonadError QErr m) => DBStepInfo ('Postgres pgKind) -> m EncJSON
mkQueryLog :: GQLReqUnparsed -> RootFieldAlias -> Maybe PreparedSql -> RequestId -> QueryLog
runPGMutationTransaction :: (MonadIO m, MonadError QErr m, MonadQueryLog m, MonadTrace m) => RequestId -> GQLReqUnparsed -> UserInfo -> Logger Hasura -> SourceConfig ('Postgres pgKind) -> RootFieldMap (DBStepInfo ('Postgres pgKind)) -> m (DiffTime, RootFieldMap EncJSON)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.SQL.Backend.Postgres pgKind), Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON.PostgresAnnotatedFieldJSON pgKind) => Hasura.GraphQL.Transport.Backend.BackendTransport ('Hasura.SQL.Backend.Postgres pgKind)

module Hasura.Backends.MySQL.Instances.Execute
mysqlDBQueryPlan :: forall m. MonadError QErr m => UserInfo -> Environment -> SourceName -> SourceConfig 'MySQL -> QueryDB 'MySQL Void (UnpreparedValue 'MySQL) -> m (DBStepInfo 'MySQL)
mysqlDBQueryExplain :: MonadError QErr m => RootFieldAlias -> UserInfo -> SourceName -> SourceConfig 'MySQL -> QueryDB 'MySQL Void (UnpreparedValue 'MySQL) -> m (AnyBackend DBStepInfo)
selectSQLTextForQuery :: Select -> Query
encJFromRecordSet :: RecordSet -> EncJSON
encJFromOutputValue :: OutputValue -> EncJSON
instance Hasura.GraphQL.Execute.Backend.BackendExecute 'Hasura.SQL.Backend.MySQL

module Hasura.Backends.MySQL.Instances.Transport
runQuery :: (MonadIO m, MonadQueryLog m, MonadTrace m, MonadError QErr m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> SourceConfig 'MySQL -> TraceT (ExceptT QErr IO) EncJSON -> Maybe (PreparedQuery 'MySQL) -> m (DiffTime, EncJSON)
run :: (MonadIO m, MonadError QErr m) => ExceptT QErr IO a -> m a
runQueryExplain :: (MonadIO m, MonadError QErr m) => DBStepInfo 'MySQL -> m EncJSON
mkQueryLog :: GQLReqUnparsed -> RootFieldAlias -> Maybe (PreparedQuery 'MySQL) -> RequestId -> QueryLog
instance Hasura.GraphQL.Transport.Backend.BackendTransport 'Hasura.SQL.Backend.MySQL

module Hasura.Backends.DataConnector.Adapter.Execute
toExplainPlan :: RootFieldAlias -> QueryRequest -> ExplainPlan
buildAction :: (MonadIO m, MonadTrace m, MonadError QErr m) => SourceName -> SourceConfig -> QueryPlan -> AgentClientT m EncJSON
instance Hasura.GraphQL.Execute.Backend.BackendExecute 'Hasura.SQL.Backend.DataConnector

module Hasura.Backends.DataConnector.Adapter.Transport
runDBQuery' :: (MonadIO m, MonadError QErr m, MonadTrace m, MonadQueryLog m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> SourceConfig -> AgentClientT (TraceT (ExceptT QErr IO)) a -> Maybe QueryRequest -> m (DiffTime, a)
mkQueryLog :: GQLReqUnparsed -> RootFieldAlias -> Maybe QueryRequest -> RequestId -> QueryLog
runDBQueryExplain' :: (MonadIO m, MonadError QErr m) => DBStepInfo 'DataConnector -> m EncJSON
instance Hasura.GraphQL.Transport.Backend.BackendTransport 'Hasura.SQL.Backend.DataConnector

module Hasura.Backends.BigQuery.Instances.Execute
bqDBQueryPlan :: forall m. MonadError QErr m => UserInfo -> Environment -> SourceName -> SourceConfig 'BigQuery -> QueryDB 'BigQuery Void (UnpreparedValue 'BigQuery) -> m (DBStepInfo 'BigQuery)

-- | Convert the dataloader's <tt>RecordSet</tt> type to JSON.
recordSetToEncJSON :: Cardinality -> RecordSet -> EncJSON
bqDBMutationPlan :: forall m. MonadError QErr m => UserInfo -> StringifyNumbers -> SourceName -> SourceConfig 'BigQuery -> MutationDB 'BigQuery Void (UnpreparedValue 'BigQuery) -> m (DBStepInfo 'BigQuery)
bqDBQueryExplain :: MonadError QErr m => RootFieldAlias -> UserInfo -> SourceName -> SourceConfig 'BigQuery -> QueryDB 'BigQuery Void (UnpreparedValue 'BigQuery) -> m (AnyBackend DBStepInfo)

-- | Get the SQL text for a select, with parameters left as $1, $2, ..
--   holes.
selectSQLTextForExplain :: Select -> Text

-- | Construct an action (i.e. <a>DBStepInfo</a>) which can marshal some
--   remote relationship information into a form that BigQuery can query
--   against.
--   
--   XXX: Currently unimplemented; the Postgres implementation uses
--   <tt>jsonb_to_recordset</tt> to query the remote relationship, however
--   this functionality doesn't exist in BigQuery.
--   
--   NOTE: The following typeclass constraints will be necessary when
--   implementing this function for real:
--   
--   <pre>
--   MonadQueryTags m
--   Backend 'BigQuery
--   </pre>
bqDBRemoteRelationshipPlan :: forall m. MonadError QErr m => UserInfo -> SourceName -> SourceConfig 'BigQuery -> NonEmpty Object -> HashMap FieldName (Column 'BigQuery, ScalarType 'BigQuery) -> FieldName -> (FieldName, SourceRelationshipSelection 'BigQuery Void UnpreparedValue) -> m (DBStepInfo 'BigQuery)
instance Hasura.GraphQL.Execute.Backend.BackendExecute 'Hasura.SQL.Backend.BigQuery

module Hasura.Backends.BigQuery.Instances.Transport
runQuery :: (MonadIO m, MonadQueryLog m, MonadTrace m, MonadError QErr m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> SourceConfig 'BigQuery -> TraceT (ExceptT QErr IO) EncJSON -> Maybe Text -> m (DiffTime, EncJSON)
runQueryExplain :: (MonadIO m, MonadError QErr m) => DBStepInfo 'BigQuery -> m EncJSON
runMutation :: MonadError QErr m => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> SourceConfig 'BigQuery -> TraceT (ExceptT QErr IO) EncJSON -> Maybe Text -> m (DiffTime, EncJSON)
run :: (MonadIO m, MonadError QErr m) => ExceptT QErr IO a -> m a
mkQueryLog :: GQLReqUnparsed -> RootFieldAlias -> Maybe Text -> RequestId -> QueryLog
instance Hasura.GraphQL.Transport.Backend.BackendTransport 'Hasura.SQL.Backend.BigQuery

module Hasura.RQL.DDL.GraphqlSchemaIntrospection
runSetGraphqlSchemaIntrospectionOptions :: (MonadError QErr m, MetadataM m, CacheRWM m) => SetGraphqlIntrospectionOptions -> m EncJSON


-- | MSSQL SQL Value
--   
--   Provide a function to translate from a column value to its literal
--   (textual) value specific to MSSQL. Used in the <tt>BackendExecute</tt>
--   instance.
module Hasura.Backends.MSSQL.SQL.Value
txtEncodedVal :: Value -> TxtEncodedVal
txtEncodedColVal :: ColumnValue 'MSSQL -> TxtEncodedVal


-- | MSSQL Instances Execute
--   
--   Defines a <a>BackendExecute</a> type class instance for MSSQL.
--   
--   This module implements the needed functionality for implementing a
--   <a>BackendExecute</a> instance for MSSQL, which defines an interface
--   for translating a root field into an execution plan and interacting
--   with a database.
--   
--   This module includes the MSSQL implementation of queries, mutations,
--   and more.
module Hasura.Backends.MSSQL.Instances.Execute
data MultiplexedQuery'
MultiplexedQuery' :: Reselect -> QueryTagsComment -> MultiplexedQuery'
[reselect] :: MultiplexedQuery' -> Reselect
[subscriptionQueryTagsComment] :: MultiplexedQuery' -> QueryTagsComment
msDBQueryPlan :: forall m. (MonadError QErr m, MonadReader QueryTagsComment m) => UserInfo -> Environment -> SourceName -> SourceConfig 'MSSQL -> QueryDB 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (DBStepInfo 'MSSQL)
runShowplan :: MonadIO m => Query -> TxET QErr m [Text]
msDBQueryExplain :: MonadError QErr m => RootFieldAlias -> UserInfo -> SourceName -> SourceConfig 'MSSQL -> QueryDB 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (AnyBackend DBStepInfo)
msDBSubscriptionExplain :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => SubscriptionQueryPlan 'MSSQL (MultiplexedQuery 'MSSQL) -> m SubscriptionQueryPlanExplanation

-- | Producing the correct SQL-level list comprehension to multiplex a
--   query Problem description:
--   
--   Generate a query that repeats the same query N times but with certain
--   slots replaced:
--   
--   <ul>
--   <li><i> Select x y | (x,y) &lt;- [..</i> ]</li>
--   </ul>
--   
--   Caution: Be aware that this query has a <tt>FOR JSON</tt> clause at
--   the top-level and hence its results may be split up across multiple
--   rows. Use <a>forJsonQueryE</a> to handle this.
multiplexRootReselect :: [(CohortId, CohortVariables)] -> Reselect -> Select
msDBMutationPlan :: forall m. (MonadError QErr m, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceName -> SourceConfig 'MSSQL -> MutationDB 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (DBStepInfo 'MSSQL)
msDBLiveQuerySubscriptionPlan :: forall m. (MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadReader QueryTagsComment m) => UserInfo -> SourceName -> SourceConfig 'MSSQL -> Maybe Name -> RootFieldMap (QueryDB 'MSSQL Void (UnpreparedValue 'MSSQL)) -> m (SubscriptionQueryPlan 'MSSQL (MultiplexedQuery 'MSSQL))
prepareStateCohortVariables :: (MonadError QErr m, MonadIO m, MonadBaseControl IO m) => SourceConfig 'MSSQL -> SessionVariables -> PrepareState -> m CohortVariables

-- | Ensure that the set of variables (with value instantiations) that
--   occur in a (RQL) query produce a well-formed and executable (SQL)
--   query when considered in isolation.
--   
--   This helps avoiding cascading failures in multiplexed queries.
--   
--   c.f. <a>https://github.com/hasura/graphql-engine-mono/issues/1210</a>.
validateVariables :: (MonadError QErr m, MonadIO m, MonadBaseControl IO m) => SourceConfig 'MSSQL -> SessionVariables -> PrepareState -> m (ValidatedQueryVariables, ValidatedSyntheticVariables)

-- | Construct an action (i.e. <a>DBStepInfo</a>) which can marshal some
--   remote relationship information into a form that SQL Server can query
--   against.
--   
--   XXX: Currently unimplemented; the Postgres implementation uses
--   <tt>jsonb_to_recordset</tt> to query the remote relationship, however
--   this functionality doesn't exist in SQL Server.
--   
--   NOTE: The following typeclass constraints will be necessary when
--   implementing this function for real:
--   
--   <pre>
--   MonadQueryTags m
--   Backend 'MSSQL
--   </pre>
msDBRemoteRelationshipPlan :: forall m. MonadError QErr m => UserInfo -> SourceName -> SourceConfig 'MSSQL -> NonEmpty Object -> HashMap FieldName (Column 'MSSQL, ScalarType 'MSSQL) -> FieldName -> (FieldName, SourceRelationshipSelection 'MSSQL Void UnpreparedValue) -> m (DBStepInfo 'MSSQL)
instance Hasura.GraphQL.Execute.Backend.BackendExecute 'Hasura.SQL.Backend.MSSQL
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Instances.Execute.MultiplexedQuery'

module Hasura.GraphQL.Execute.Instances


-- | MSSQL Instances Transport
--   
--   Defines the MSSQL instance of <a>BackendTransport</a> and how to
--   interact with the database for running queries, mutations,
--   subscriptions, and so on.
module Hasura.Backends.MSSQL.Instances.Transport
newtype CohortResult
CohortResult :: (CohortId, Text) -> CohortResult
runQuery :: (MonadIO m, MonadQueryLog m, MonadTrace m, MonadError QErr m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> SourceConfig 'MSSQL -> ExceptT QErr IO EncJSON -> Maybe (PreparedQuery 'MSSQL) -> m (DiffTime, EncJSON)
runQueryExplain :: (MonadIO m, MonadError QErr m) => DBStepInfo 'MSSQL -> m EncJSON
runMutation :: (MonadIO m, MonadQueryLog m, MonadTrace m, MonadError QErr m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> SourceConfig 'MSSQL -> ExceptT QErr IO EncJSON -> Maybe (PreparedQuery 'MSSQL) -> m (DiffTime, EncJSON)
runSubscription :: MonadIO m => SourceConfig 'MSSQL -> MultiplexedQuery 'MSSQL -> [(CohortId, CohortVariables)] -> m (DiffTime, Either QErr [(CohortId, ByteString)])
executeMultiplexedQuery :: MonadIO m => MSSQLExecCtx -> Query -> ExceptT QErr m [(CohortId, ByteString)]
run :: (MonadIO m, MonadError QErr m) => ExceptT QErr IO a -> m a
mkQueryLog :: GQLReqUnparsed -> RootFieldAlias -> Maybe (PreparedQuery 'MSSQL) -> RequestId -> QueryLog
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Instances.Transport.CohortResult
instance Hasura.GraphQL.Transport.Backend.BackendTransport 'Hasura.SQL.Backend.MSSQL

module Hasura.GraphQL.Transport.Instances


-- | How to construct and execute a call to a source for a remote join.
--   
--   There are three steps required to do this: - construct the execution
--   step for that source join - execute that GraphQL query over the
--   network - build a join index of the variables out of the response
--   
--   This can be done as one function, but we also export the individual
--   steps for debugging / test purposes. We congregate all intermediary
--   state in the opaque <a>SourceJoinCall</a> type.
module Hasura.GraphQL.Execute.RemoteJoin.Source

-- | Construct and execute a call to a source for a remote join.
makeSourceJoinCall :: (MonadQueryTags m, MonadError QErr m) => (AnyBackend SourceJoinCall -> m ByteString) -> UserInfo -> AnyBackend RemoteSourceJoin -> FieldName -> IntMap JoinArgument -> m (Maybe (IntMap Value))

-- | Intermediate type that contains all the necessary information to
--   perform a call to a database to perform a join.
data SourceJoinCall b
SourceJoinCall :: RootFieldAlias -> SourceConfig b -> DBStepInfo b -> SourceJoinCall b
[_sjcRootFieldAlias] :: SourceJoinCall b -> RootFieldAlias
[_sjcSourceConfig] :: SourceJoinCall b -> SourceConfig b
[_sjcStepInfo] :: SourceJoinCall b -> DBStepInfo b
buildSourceJoinCall :: (BackendExecute b, MonadQueryTags m, MonadError QErr m) => UserInfo -> FieldName -> IntMap JoinArgument -> RemoteSourceJoin b -> m (Maybe (AnyBackend SourceJoinCall))

-- | Construct a join index from the <tt>EncJSON</tt> response from the
--   source.
--   
--   Unlike with remote schemas, we can make assumptions about the shape of
--   the result, instead of having to keep track of the path within the
--   answer. This function therefore enforces that the answer has the shape
--   we expect, and throws a <a>QErr</a> if it doesn't.
buildJoinIndex :: MonadError QErr m => ByteString -> m (IntMap Value)

module Hasura.GraphQL.Execute.RemoteJoin.Join

-- | Process all remote joins, recursively.
--   
--   Given the result of the first step of an execution and its associated
--   remote joins, process all joins recursively to build the resulting
--   JSON object.
--   
--   This function is a thin wrapper around
--   <tt>processRemoteJoinsWith</tt>, and starts the join tree traversal
--   process by re-parsing the <a>EncJSON</a> value into an introspectable
--   JSON <tt>Value</tt>, and "injects" the required functions to process
--   each join over the network.
processRemoteJoins :: forall m. (MonadError QErr m, MonadIO m, MonadQueryTags m, MonadQueryLog m, MonadTrace m) => RequestId -> Logger Hasura -> Environment -> Manager -> [Header] -> UserInfo -> EncJSON -> Maybe RemoteJoins -> GQLReqUnparsed -> m EncJSON

-- | Fold the join tree.
--   
--   This function takes as an argument the functions that will be used to
--   do the actual network calls; this allows this function not to require
--   <a>MonadIO</a>, allowing it to be used in tests.
foldJoinTreeWith :: (MonadError QErr m, MonadQueryTags m, Traversable f) => (AnyBackend SourceJoinCall -> m ByteString) -> (ValidatedRemoteSchemaDef -> GQLReqOutgoing -> m ByteString) -> UserInfo -> f Value -> RemoteJoins -> m (f Value)

-- | Simple convenient wrapper around <tt>Maybe RemoteJoins</tt>.
forRemoteJoins :: Applicative f => Maybe RemoteJoins -> a -> (RemoteJoins -> f a) -> f a

-- | When traversing a responses's json, wherever the join columns of a
--   remote join are expected, we want to collect these arguments.
--   
--   However looking up by a remote join's definition to collect these
--   arguments does not work because we don't have an <a>Ord</a> or a
--   <a>Hashable</a> instance (it would be a bit of work).
--   
--   So this assigned each remote join a unique integer ID by using just
--   the <a>Eq</a> instance. This ID then can be used for the collection of
--   arguments (which should also be faster).
--   
--   TODO(nicuveo):
--   <a>https://github.com/hasura/graphql-engine-mono/issues/3891</a>.
assignJoinIds :: JoinTree RemoteJoin -> JoinTree (JoinCallId, RemoteJoin)
collectJoinArguments :: forall f m. (MonadError QErr m, Traversable f) => JoinTree (JoinCallId, RemoteJoin) -> f Value -> m (f (CompositeValue ReplacementToken), IntMap JoinArguments)
joinResults :: forall f m. (MonadError QErr m, Traversable f) => IntMap (IntMap Value) -> f (CompositeValue ReplacementToken) -> m (f Value)
type CompositeObject a = InsOrdHashMap Text (CompositeValue a)

-- | A hybrid JSON value representation which captures the context of
--   remote join field in type parameter.
data CompositeValue a
CVOrdValue :: !Value -> CompositeValue a
CVObject :: !CompositeObject a -> CompositeValue a
CVObjectArray :: ![CompositeValue a] -> CompositeValue a
CVFromRemote :: !a -> CompositeValue a
compositeValueToJSON :: CompositeValue Value -> Value

-- | A token used to uniquely identify the results within a join call that
--   are associated with a particular argument.
data ReplacementToken
ReplacementToken :: !JoinCallId -> !JoinArgumentId -> ReplacementToken

-- | Unique identifier for a remote join call.
[_rtCallId] :: ReplacementToken -> !JoinCallId

-- | Unique identifier for an argument to some remote join.
[_rtArgumentId] :: ReplacementToken -> !JoinArgumentId
instance Data.Traversable.Traversable Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue
instance Data.Foldable.Foldable Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue
instance GHC.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue a)

module Hasura.GraphQL.Execute.RemoteJoin

module Network.Wai.Extended

-- | IP Address related code
newtype IpAddress
IpAddress :: ByteString -> IpAddress
[unIpAddress] :: IpAddress -> ByteString
showIPAddress :: IpAddress -> Text
getSourceFromSocket :: Request -> IpAddress
getSourceFromFallback :: Request -> IpAddress
getSource :: Request -> Maybe IpAddress

-- | A type for IP address in numeric string representation.
type NumericAddress = String
showIPv4 :: Word32 -> Bool -> NumericAddress
showIPv6 :: (Word32, Word32, Word32, Word32) -> String

-- | Convert <a>SockAddr</a> to <a>NumericAddress</a>. If the address is
--   IPv4-embedded IPv6 address, the IPv4 is extracted.
showSockAddr :: SockAddr -> NumericAddress
instance GHC.Classes.Eq Network.Wai.Extended.IpAddress
instance GHC.Show.Show Network.Wai.Extended.IpAddress


-- | This is taken from wai-logger and customised for our use
module Hasura.Server.Logging
data StartupLog
StartupLog :: !LogLevel -> !Text -> !Value -> StartupLog
[slLogLevel] :: StartupLog -> !LogLevel
[slKind] :: StartupLog -> !Text
[slInfo] :: StartupLog -> !Value
data PGLog
PGLog :: !LogLevel -> !Text -> PGLog
[plLogLevel] :: PGLog -> !LogLevel
[plMessage] :: PGLog -> !Text
data MetadataLog
MetadataLog :: !LogLevel -> !Text -> !Value -> MetadataLog
[mlLogLevel] :: MetadataLog -> !LogLevel
[mlMessage] :: MetadataLog -> !Text
[mlInfo] :: MetadataLog -> !Value
mkInconsMetadataLog :: [InconsistentMetadata] -> MetadataLog
data WebHookLog
WebHookLog :: !LogLevel -> !Maybe Status -> !Text -> !StdMethod -> !Maybe HttpException -> !Maybe Text -> !Maybe Text -> WebHookLog
[whlLogLevel] :: WebHookLog -> !LogLevel
[whlStatusCode] :: WebHookLog -> !Maybe Status
[whlUrl] :: WebHookLog -> !Text
[whlMethod] :: WebHookLog -> !StdMethod
[whlError] :: WebHookLog -> !Maybe HttpException
[whlResponse] :: WebHookLog -> !Maybe Text
[whlMessage] :: WebHookLog -> !Maybe Text

-- | GQLQueryOperationSuccessLog captures all the data required to
--   construct an HTTP success log.
data GQLQueryOperationSuccessLog
GQLQueryOperationSuccessLog :: !GQLReqUnparsed -> !DiffTime -> !Int64 -> !Int64 -> !ParameterizedQueryHash -> GQLQueryOperationSuccessLog
[gqolQuery] :: GQLQueryOperationSuccessLog -> !GQLReqUnparsed
[gqolQueryExecutionTime] :: GQLQueryOperationSuccessLog -> !DiffTime
[gqolResponseSize] :: GQLQueryOperationSuccessLog -> !Int64
[gqolRequestSize] :: GQLQueryOperationSuccessLog -> !Int64
[gqolParameterizedQueryHash] :: GQLQueryOperationSuccessLog -> !ParameterizedQueryHash

-- | GQLQueryOperationErrorLog captures the request along with the error
--   message
data GQLQueryOperationErrorLog
GQLQueryOperationErrorLog :: !GQLReqUnparsed -> !QErr -> GQLQueryOperationErrorLog
[gqelQuery] :: GQLQueryOperationErrorLog -> !GQLReqUnparsed
[gqelError] :: GQLQueryOperationErrorLog -> !QErr
data GQLBatchQueryOperationLog
GQLQueryOperationSuccess :: !GQLQueryOperationSuccessLog -> GQLBatchQueryOperationLog
GQLQueryOperationError :: !GQLQueryOperationErrorLog -> GQLBatchQueryOperationLog

-- | whether a request is executed in batched mode or not
data RequestMode

-- | this request is batched
RequestModeBatched :: RequestMode

-- | this is a single request
RequestModeSingle :: RequestMode

-- | this request is of a kind for which batching is not done or does not
--   make sense
RequestModeNonBatchable :: RequestMode

-- | the execution of this request failed
RequestModeError :: RequestMode
data CommonHttpLogMetadata
CommonHttpLogMetadata :: !RequestMode -> !Maybe (GQLBatchedReqs GQLBatchQueryOperationLog) -> CommonHttpLogMetadata
[_chlmRequestMode] :: CommonHttpLogMetadata -> !RequestMode
[_chlmBatchOperationLog] :: CommonHttpLogMetadata -> !Maybe (GQLBatchedReqs GQLBatchQueryOperationLog)

-- | The http-log metadata attached to HTTP requests running in the monad
--   <tt>m</tt>, split into a common portion that is present regardless of
--   <tt>m</tt>, and a monad-specific one defined in the <a>HttpLog</a>
--   instance.
--   
--   This allows us to not have to duplicate the code that generates the
--   common part of the metadata across OSS and Pro, so that instances only
--   have to implement the part of it unique to them.
type HttpLogMetadata m = (CommonHttpLogMetadata, ExtraHttpLogMetadata m)
buildHttpLogMetadata :: forall m. HttpLog m => ParameterizedQueryHashList -> RequestMode -> Maybe (GQLBatchedReqs GQLBatchQueryOperationLog) -> HttpLogMetadata m

-- | synonym for clarity, writing `emptyHttpLogMetadata <tt>m` instead of
--   `def </tt>(HttpLogMetadata m)`
emptyHttpLogMetadata :: forall m. HttpLog m => HttpLogMetadata m
data MetadataQueryLoggingMode
MetadataQueryLoggingEnabled :: MetadataQueryLoggingMode
MetadataQueryLoggingDisabled :: MetadataQueryLoggingMode

-- | Setting used to control the information in logs
data LoggingSettings
LoggingSettings :: HashSet (EngineLogType Hasura) -> MetadataQueryLoggingMode -> LoggingSettings

-- | this is only required for the short-term fix in
--   <a>https://github.com/hasura/graphql-engine-mono/issues/1770</a> See
--   Note [Disable query printing when query-log is disabled]
[_lsEnabledLogTypes] :: LoggingSettings -> HashSet (EngineLogType Hasura)
[_lsMetadataQueryLoggingMode] :: LoggingSettings -> MetadataQueryLoggingMode
class Monad m => HttpLog m where {
    
    -- | Extra http-log metadata that we attach when operating in <tt>m</tt>.
    type family ExtraHttpLogMetadata m;
}
emptyExtraHttpLogMetadata :: HttpLog m => ExtraHttpLogMetadata m
buildExtraHttpLogMetadata :: HttpLog m => ParameterizedQueryHashList -> ExtraHttpLogMetadata m
logHttpError :: HttpLog m => Logger Hasura -> LoggingSettings -> Maybe UserInfo -> RequestId -> Request -> (ByteString, Maybe Value) -> QErr -> [Header] -> m ()
logHttpSuccess :: HttpLog m => Logger Hasura -> LoggingSettings -> Maybe UserInfo -> RequestId -> Request -> (ByteString, Maybe Value) -> ByteString -> ByteString -> Maybe (DiffTime, DiffTime) -> Maybe CompressionType -> [Header] -> HttpLogMetadata m -> m ()

-- | Log information about the HTTP request
data HttpInfoLog
HttpInfoLog :: !Status -> !Text -> !IpAddress -> !Text -> !HttpVersion -> !Maybe CompressionType -> ![Header] -> HttpInfoLog
[hlStatus] :: HttpInfoLog -> !Status
[hlMethod] :: HttpInfoLog -> !Text
[hlSource] :: HttpInfoLog -> !IpAddress
[hlPath] :: HttpInfoLog -> !Text
[hlHttpVersion] :: HttpInfoLog -> !HttpVersion
[hlCompression] :: HttpInfoLog -> !Maybe CompressionType

-- | all the request headers
[hlHeaders] :: HttpInfoLog -> ![Header]

-- | Information about a GraphQL/Hasura metadata operation over HTTP
data OperationLog
OperationLog :: !RequestId -> !Maybe SessionVariables -> !Maybe Int64 -> !Maybe Seconds -> !Maybe Seconds -> !Maybe Value -> !Maybe Text -> !Maybe QErr -> !RequestMode -> OperationLog
[olRequestId] :: OperationLog -> !RequestId
[olUserVars] :: OperationLog -> !Maybe SessionVariables
[olResponseSize] :: OperationLog -> !Maybe Int64

-- | Request IO wait time, i.e. time spent reading the full request from
--   the socket.
[olRequestReadTime] :: OperationLog -> !Maybe Seconds

-- | Service time, not including request IO wait time.
[olQueryExecutionTime] :: OperationLog -> !Maybe Seconds
[olQuery] :: OperationLog -> !Maybe Value
[olRawQuery] :: OperationLog -> !Maybe Text
[olError] :: OperationLog -> !Maybe QErr
[olRequestMode] :: OperationLog -> !RequestMode

-- | <tt>BatchOperationSuccessLog</tt> contains the information required
--   for a single successful operation in a batch request for OSS. This
--   type is a subset of the <tt>GQLQueryOperationSuccessLog</tt>
data BatchOperationSuccessLog
BatchOperationSuccessLog :: !Maybe Value -> !Int64 -> !Seconds -> BatchOperationSuccessLog
[_bolQuery] :: BatchOperationSuccessLog -> !Maybe Value
[_bolResponseSize] :: BatchOperationSuccessLog -> !Int64
[_bolQueryExecutionTime] :: BatchOperationSuccessLog -> !Seconds

-- | <tt>BatchOperationSuccessLog</tt> contains the information required
--   for a single erroneous operation in a batch request for OSS. This type
--   is a subset of the <tt>GQLQueryOperationErrorLog</tt>
data BatchOperationErrorLog
BatchOperationErrorLog :: !Maybe Value -> !QErr -> BatchOperationErrorLog
[_belQuery] :: BatchOperationErrorLog -> !Maybe Value
[_belError] :: BatchOperationErrorLog -> !QErr
data BatchOperationLog
BatchOperationSuccess :: !BatchOperationSuccessLog -> BatchOperationLog
BatchOperationError :: !BatchOperationErrorLog -> BatchOperationLog
data HttpLogContext
HttpLogContext :: !HttpInfoLog -> !OperationLog -> !RequestId -> !Maybe (NonEmpty BatchOperationLog) -> HttpLogContext
[hlcHttpInfo] :: HttpLogContext -> !HttpInfoLog
[hlcOperation] :: HttpLogContext -> !OperationLog
[hlcRequestId] :: HttpLogContext -> !RequestId
[hlcBatchedOperations] :: HttpLogContext -> !Maybe (NonEmpty BatchOperationLog)

-- | Check if the <tt>query</tt> field should be included in the http-log
isQueryIncludedInLogs :: Text -> LoggingSettings -> Bool
mkHttpAccessLogContext :: Maybe UserInfo -> LoggingSettings -> RequestId -> Request -> (ByteString, Maybe Value) -> ByteString -> Maybe (DiffTime, DiffTime) -> Maybe CompressionType -> [Header] -> RequestMode -> Maybe (GQLBatchedReqs GQLBatchQueryOperationLog) -> HttpLogContext
mkHttpErrorLogContext :: Maybe UserInfo -> LoggingSettings -> RequestId -> Request -> (ByteString, Maybe Value) -> QErr -> Maybe (DiffTime, DiffTime) -> Maybe CompressionType -> [Header] -> HttpLogContext
data HttpLogLine
HttpLogLine :: !LogLevel -> !HttpLogContext -> HttpLogLine
[_hlLogLevel] :: HttpLogLine -> !LogLevel
[_hlLogLine] :: HttpLogLine -> !HttpLogContext
mkHttpLog :: HttpLogContext -> HttpLogLine

-- | Log warning messages for deprecated environment variables
logDeprecatedEnvVars :: Logger Hasura -> Environment -> SourceCache -> IO ()
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.HttpLogLine Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.HttpLogContext
instance GHC.Classes.Eq Hasura.Server.Logging.BatchOperationLog
instance GHC.Classes.Eq Hasura.Server.Logging.HttpLogContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.BatchOperationLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.BatchOperationErrorLog
instance GHC.Classes.Eq Hasura.Server.Logging.BatchOperationErrorLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.BatchOperationSuccessLog
instance GHC.Classes.Eq Hasura.Server.Logging.BatchOperationSuccessLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.OperationLog
instance GHC.Classes.Eq Hasura.Server.Logging.GQLBatchQueryOperationLog
instance GHC.Classes.Eq Hasura.Server.Logging.RequestMode
instance GHC.Classes.Eq Hasura.Server.Logging.CommonHttpLogMetadata
instance GHC.Classes.Eq Hasura.Server.Logging.MetadataQueryLoggingMode
instance GHC.Show.Show Hasura.Server.Logging.MetadataQueryLoggingMode
instance GHC.Classes.Eq Hasura.Server.Logging.LoggingSettings
instance GHC.Classes.Eq Hasura.Server.Logging.HttpInfoLog
instance GHC.Classes.Eq Hasura.Server.Logging.OperationLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.HttpInfoLog
instance Hasura.Server.Logging.HttpLog m => Hasura.Server.Logging.HttpLog (Hasura.Tracing.TraceT m)
instance Hasura.Server.Logging.HttpLog m => Hasura.Server.Logging.HttpLog (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.Logging.HttpLog m => Hasura.Server.Logging.HttpLog (Hasura.Metadata.Class.MetadataStorageT m)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Logging.MetadataQueryLoggingMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.MetadataQueryLoggingMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.RequestMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.GQLBatchQueryOperationLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.GQLQueryOperationErrorLog
instance GHC.Classes.Eq Hasura.Server.Logging.GQLQueryOperationErrorLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.GQLQueryOperationSuccessLog
instance GHC.Classes.Eq Hasura.Server.Logging.StartupLog
instance GHC.Classes.Eq Hasura.Server.Logging.PGLog
instance GHC.Classes.Eq Hasura.Server.Logging.MetadataLog
instance GHC.Classes.Eq Hasura.Server.Logging.GQLQueryOperationSuccessLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.WebHookLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.WebHookLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.MetadataLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.MetadataLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.PGLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.PGLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.StartupLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.StartupLog Hasura.Logging.Hasura

module Hasura.Server.SchemaCacheRef

-- | A mutable reference to a <a>RebuildableSchemaCache</a>, plus
--   
--   <ul>
--   <li>a write lock,</li>
--   <li>update version tracking, and</li>
--   <li>a gauge metric that tracks the metadata version of the
--   <a>SchemaCache</a>.</li>
--   </ul>
data SchemaCacheRef
SchemaCacheRef :: MVar () -> IORef (RebuildableSchemaCache, SchemaCacheVer) -> Gauge -> SchemaCacheRef

-- | The idea behind explicit locking here is to
--   
--   <ol>
--   <li>Allow maximum throughput for serving requests (<i>v1</i>graphql)
--   (as each request reads the current schemacache)</li>
--   <li>We don't want to process more than one request at any point of
--   time which would modify the schema cache as such queries are
--   expensive.</li>
--   </ol>
--   
--   Another option is to consider removing this lock in place of
--   `_scrCache :: MVar ...` if it's okay or in fact correct to block
--   during schema update in e.g. _wseGCtxMap. Vamshi says: It is
--   theoretically possible to have a situation (in between building new
--   schemacache and before writing it to the IORef) where we serve a
--   request with a stale schemacache but I guess it is an okay trade-off
--   to pay for a higher throughput (I remember doing a bunch of benchmarks
--   to test this hypothesis).
[_scrLock] :: SchemaCacheRef -> MVar ()
[_scrCache] :: SchemaCacheRef -> IORef (RebuildableSchemaCache, SchemaCacheVer)

-- | The gauge metric that tracks the current metadata version.
--   
--   Invariant: This gauge must be updated via
--   <a>updateMetadataVersionGauge</a> whenever the _scrCache IORef is
--   updated.
[_scrMetadataVersionGauge] :: SchemaCacheRef -> Gauge

-- | Build a new <a>SchemaCacheRef</a>
initialiseSchemaCacheRef :: MonadIO m => ServerMetrics -> RebuildableSchemaCache -> m SchemaCacheRef

-- | Set the <a>SchemaCacheRef</a> to the <a>RebuildableSchemaCache</a>
--   produced by the given action.
--   
--   An internal lock ensures that at most one update to the
--   <a>SchemaCacheRef</a> may proceed at a time.
withSchemaCacheUpdate :: (MonadIO m, MonadBaseControl IO m) => SchemaCacheRef -> Logger Hasura -> Maybe (TVar Bool) -> m (a, RebuildableSchemaCache) -> m a

-- | Read the contents of the <a>SchemaCacheRef</a>
readSchemaCacheRef :: SchemaCacheRef -> IO (RebuildableSchemaCache, SchemaCacheVer)

-- | Utility function. Read the latest <a>SchemaCache</a> from the
--   <a>SchemaCacheRef</a>.
--   
--   <pre>
--   getSchemaCache == fmap (lastBuiltSchemaCache . fst) . readSchemaCacheRef
--   </pre>
getSchemaCache :: SchemaCacheRef -> IO SchemaCache

-- | Utility function
logInconsistentMetadata :: Logger Hasura -> [InconsistentMetadata] -> IO ()
updateMetadataVersionGauge :: MonadIO m => Gauge -> RebuildableSchemaCache -> m ()

module Hasura.Server.SchemaUpdate
data ThreadType
TTListener :: ThreadType
TTProcessor :: ThreadType
data SchemaSyncThreadLog
SchemaSyncThreadLog :: !LogLevel -> !ThreadType -> !Value -> SchemaSyncThreadLog
[suelLogLevel] :: SchemaSyncThreadLog -> !LogLevel
[suelThreadType] :: SchemaSyncThreadLog -> !ThreadType
[suelInfo] :: SchemaSyncThreadLog -> !Value
data ThreadError
TEPayloadParse :: !Text -> ThreadError
TEQueryError :: !QErr -> ThreadError
logThreadStarted :: MonadIO m => Logger Hasura -> InstanceId -> ThreadType -> Thread -> m ()

-- | An async thread which listen to Postgres notify to enable schema
--   syncing See Note [Schema Cache Sync]
startSchemaSyncListenerThread :: ForkableMonadIO m => Logger Hasura -> PGPool -> InstanceId -> NonNegative Milliseconds -> TMVar MetadataResourceVersion -> ManagedT m Thread

-- | An async thread which processes the schema sync events See Note
--   [Schema Cache Sync]
startSchemaSyncProcessorThread :: (ForkableMonadIO m, MonadMetadataStorage (MetadataStorageT m), MonadResolveSource m) => Logger Hasura -> Manager -> TMVar MetadataResourceVersion -> SchemaCacheRef -> InstanceId -> ServerConfigCtx -> TVar Bool -> ManagedT m Thread
forcePut :: TMVar a -> a -> IO ()
schemaVersionCheckHandler :: PGPool -> TMVar MetadataResourceVersion -> IO (Either QErr ())
data ErrorState
ErrorState :: !Maybe QErr -> !Maybe MetadataResourceVersion -> ErrorState
[_esLastErrorSeen] :: ErrorState -> !Maybe QErr
[_esLastMetadataVersion] :: ErrorState -> !Maybe MetadataResourceVersion
defaultErrorState :: ErrorState

-- | NOTE: this can be updated to use lenses
updateErrorInState :: ErrorState -> QErr -> MetadataResourceVersion -> ErrorState
isInErrorState :: ErrorState -> Bool
toLogError :: ErrorState -> QErr -> MetadataResourceVersion -> Bool

-- | An IO action that listens to postgres for events and pushes them to a
--   Queue, in a loop forever.
listener :: MonadIO m => Logger Hasura -> PGPool -> TMVar MetadataResourceVersion -> Milliseconds -> m void

-- | An IO action that processes events from Queue, in a loop forever.
processor :: forall m void. (ForkableMonadIO m, MonadMetadataStorage (MetadataStorageT m), MonadResolveSource m) => Logger Hasura -> Manager -> TMVar MetadataResourceVersion -> SchemaCacheRef -> InstanceId -> ServerConfigCtx -> TVar Bool -> m void
refreshSchemaCache :: (MonadIO m, MonadBaseControl IO m, MonadMetadataStorage m, MonadResolveSource m) => MetadataResourceVersion -> InstanceId -> Logger Hasura -> Manager -> SchemaCacheRef -> ThreadType -> ServerConfigCtx -> TVar Bool -> m ()
logInfo :: MonadIO m => Logger Hasura -> ThreadType -> Value -> m ()
logError :: (MonadIO m, ToJSON a) => Logger Hasura -> ThreadType -> a -> m ()
logDebug :: MonadIO m => Logger Hasura -> ThreadType -> String -> m ()
instance GHC.Classes.Eq Hasura.Server.SchemaUpdate.ErrorState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.SchemaUpdate.ThreadError
instance GHC.Classes.Eq Hasura.Server.SchemaUpdate.ThreadType
instance GHC.Classes.Eq Hasura.Server.SchemaUpdate.SchemaSyncThreadLog
instance GHC.Show.Show Hasura.Server.SchemaUpdate.SchemaSyncThreadLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.SchemaUpdate.SchemaSyncThreadLog
instance Hasura.Logging.ToEngineLog Hasura.Server.SchemaUpdate.SchemaSyncThreadLog Hasura.Logging.Hasura
instance GHC.Show.Show Hasura.Server.SchemaUpdate.ThreadType

module Hasura.Server.Auth.WebHook
data AuthHookType
AHTGet :: AuthHookType
AHTPost :: AuthHookType
data AuthHook
AuthHook :: Text -> AuthHookType -> AuthHook
[ahUrl] :: AuthHook -> Text
[ahType] :: AuthHook -> AuthHookType
hookMethod :: AuthHook -> StdMethod

-- | Makes an authentication request to the given AuthHook and returns
--   UserInfo parsed from the response, plus an expiration time if one was
--   returned. Optionally passes a batch of raw GraphQL requests for
--   finer-grained auth. (#2666)
userInfoFromAuthHook :: forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m) => Logger Hasura -> Manager -> AuthHook -> [Header] -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])
mkUserInfoFromResp :: (MonadIO m, MonadError QErr m) => Logger Hasura -> Text -> StdMethod -> Status -> ByteString -> [Header] -> m (UserInfo, Maybe UTCTime, [Header])
instance GHC.Classes.Eq Hasura.Server.Auth.WebHook.AuthHookType
instance GHC.Classes.Eq Hasura.Server.Auth.WebHook.AuthHook
instance GHC.Show.Show Hasura.Server.Auth.WebHook.AuthHook
instance GHC.Show.Show Hasura.Server.Auth.WebHook.AuthHookType

module Hasura.Server.Auth

-- | Typeclass representing the <tt>UserInfo</tt> authorization and
--   resolving effect
class (Monad m) => UserAuthentication m
resolveUserInfo :: UserAuthentication m => Logger Hasura -> Manager -> [Header] -> AuthMode -> Maybe ReqsText -> m (Either QErr (UserInfo, Maybe UTCTime, [Header]))

-- | The hashed admin password. <a>hashAdminSecret</a> is our public
--   interface for constructing the secret.
--   
--   To prevent misuse and leaking we keep this opaque and don't provide
--   instances that could leak information. Likewise for <a>AuthMode</a>.
--   
--   Although this exists only in memory we store only a hash of the admin
--   secret primarily in order to:
--   
--   <ul>
--   <li>prevent theoretical timing attacks from a naive <a>==</a>
--   check</li>
--   <li>prevent misuse or inadvertent leaking of the secret</li>
--   </ul>
newtype AdminSecretHash
AdminSecretHash :: Digest SHA512 -> AdminSecretHash
unsafeMkAdminSecretHash :: Digest SHA512 -> AdminSecretHash
hashAdminSecret :: Text -> AdminSecretHash

-- | The methods we'll use to derive roles for authenticating requests.
--   
--   <tt>Maybe RoleName</tt> below is the optionally-defined role for the
--   unauthenticated (anonymous) user.
--   
--   See:
--   <a>https://hasura.io/docs/latest/graphql/core/auth/authentication/unauthenticated-access.html</a>
data AuthMode
AMNoAuth :: AuthMode
AMAdminSecret :: !HashSet AdminSecretHash -> !Maybe RoleName -> AuthMode
AMAdminSecretAndHook :: !HashSet AdminSecretHash -> !AuthHook -> AuthMode
AMAdminSecretAndJWT :: !HashSet AdminSecretHash -> ![JWTCtx] -> !Maybe RoleName -> AuthMode

-- | Validate the user's requested authentication configuration, launching
--   any required maintenance threads for JWT etc.
--   
--   This must only be run once, on launch.
setupAuthMode :: (ForkableMonadIO m, HasReporter m) => HashSet AdminSecretHash -> Maybe AuthHook -> [JWTConfig] -> Maybe RoleName -> Manager -> Logger Hasura -> ExceptT Text (ManagedT m) AuthMode

-- | Authenticate the request using the headers and the configured
--   <a>AuthMode</a>.
getUserInfoWithExpTime :: forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m) => Logger Hasura -> Manager -> [Header] -> AuthMode -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])
getUserInfoWithExpTime_ :: forall m mgr logger. (MonadIO m, MonadError QErr m) => (logger -> mgr -> AuthHook -> [Header] -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])) -> ([JWTCtx] -> [Header] -> Maybe RoleName -> m (UserInfo, Maybe UTCTime, [Header])) -> logger -> mgr -> [Header] -> AuthMode -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])
instance GHC.Classes.Eq Hasura.Server.Auth.AdminSecretHash
instance GHC.Classes.Ord Hasura.Server.Auth.AdminSecretHash
instance GHC.Classes.Eq Hasura.Server.Auth.AuthMode
instance GHC.Show.Show Hasura.Server.Auth.AuthMode
instance Data.Hashable.Class.Hashable Hasura.Server.Auth.AdminSecretHash
instance GHC.Show.Show Hasura.Server.Auth.AdminSecretHash


-- | Types and classes related to configuration when the server is
--   initialised
module Hasura.Server.Init.Config

-- | The collected default value, env var, and help message for an option.
--   If there should be no default value then use 'Option ()'.
data Option def
Option :: def -> String -> String -> Option def
[_default] :: Option def -> def
[_envVar] :: Option def -> String
[_helpMessage] :: Option def -> String

-- | Helper function for pretty printing <tt>Option a</tt>.
optionPP :: Option a -> (String, String)

-- | Raw HGE Options from the arg parser and the env.
data HGEOptionsRaw impl
HGEOptionsRaw :: PostgresConnInfo (Maybe PostgresConnInfoRaw) -> Maybe String -> HGECommand impl -> HGEOptionsRaw impl
[_horDatabaseUrl] :: HGEOptionsRaw impl -> PostgresConnInfo (Maybe PostgresConnInfoRaw)
[_horMetadataDbUrl] :: HGEOptionsRaw impl -> Maybe String
[_horCommand] :: HGEOptionsRaw impl -> HGECommand impl
horDatabaseUrl :: Lens' (HGEOptionsRaw impl) (PostgresConnInfo (Maybe PostgresConnInfoRaw))
horMetadataDbUrl :: Lens' (HGEOptionsRaw impl) (Maybe String)
horCommand :: Lens' (HGEOptionsRaw impl) (HGECommand impl)

-- | The final processed HGE options.
data HGEOptions impl
HGEOptions :: PostgresConnInfo (Maybe UrlConf) -> Maybe String -> HGECommand impl -> HGEOptions impl
[_hoDatabaseUrl] :: HGEOptions impl -> PostgresConnInfo (Maybe UrlConf)
[_hoMetadataDbUrl] :: HGEOptions impl -> Maybe String
[_hoCommand] :: HGEOptions impl -> HGECommand impl
hoCommand :: Lens' (HGEOptions impl) (HGECommand impl)

-- | Postgres connection info tupled with a retry count.
--   
--   In practice, the <tt>a</tt> here is one of the following: 1. 'Maybe
--   PostgresConnInfoRaw' 2. 'Maybe UrlConf' 3. 'Maybe Text' 4. 'Maybe
--   DatabaseUrl' where <tt>DatabaseUrl</tt> is an alias for <a>Text</a>
--   
--   If it contains a 'Maybe PostgresConnInfoRaw' then you have not yet
--   processed your arg parser results.
data PostgresConnInfo a
PostgresConnInfo :: a -> Maybe Int -> PostgresConnInfo a
[_pciDatabaseConn] :: PostgresConnInfo a -> a
[_pciRetries] :: PostgresConnInfo a -> Maybe Int
pciDatabaseConn :: Lens' (PostgresConnInfo a) a
pciRetries :: Lens' (PostgresConnInfo a) (Maybe Int)

-- | Postgres Connection info in the form of a templated URI string or
--   structured data.
data PostgresConnInfoRaw
PGConnDatabaseUrl :: URLTemplate -> PostgresConnInfoRaw
PGConnDetails :: PostgresConnDetailsRaw -> PostgresConnInfoRaw
mkUrlConnInfo :: String -> PostgresConnInfoRaw
_PGConnDatabaseUrl :: Prism' PostgresConnInfoRaw URLTemplate
_PGConnDetails :: Prism' PostgresConnInfoRaw PostgresConnDetailsRaw
rawConnDetailsToUrl :: PostgresConnDetailsRaw -> URLTemplate

-- | Structured Postgres connection information as provided by the arg
--   parser or env vars.
data PostgresConnDetailsRaw
PostgresConnDetailsRaw :: String -> Int -> String -> String -> String -> Maybe String -> PostgresConnDetailsRaw
[connHost] :: PostgresConnDetailsRaw -> String
[connPort] :: PostgresConnDetailsRaw -> Int
[connUser] :: PostgresConnDetailsRaw -> String
[connPassword] :: PostgresConnDetailsRaw -> String
[connDatabase] :: PostgresConnDetailsRaw -> String
[connOptions] :: PostgresConnDetailsRaw -> Maybe String
rawConnDetailsToUrlText :: PostgresConnDetailsRaw -> Text

-- | The HGE Arg parser Command choices.
--   
--   This is polymorphic so that we can pack either <a>ServeOptionsRaw</a>
--   or <tt>ProServeOptionsRaw</tt> in it.
data HGECommand a
HCServe :: a -> HGECommand a
HCExport :: HGECommand a
HCClean :: HGECommand a
HCVersion :: HGECommand a
HCDowngrade :: !DowngradeOptions -> HGECommand a
_HCServe :: Prism' (HGECommand a) a

-- | The Serve Command options accumulated from the Arg and Env parsers.
--   
--   NOTE: A <a>Nothing</a> value indicates the absence of a particular
--   flag. Hence types such as 'Maybe (HashSet X)' or 'Maybe Bool'.
data ServeOptionsRaw impl
ServeOptionsRaw :: Maybe Port -> Maybe HostPreference -> ConnParamsRaw -> Maybe TxIsolation -> Maybe AdminSecretHash -> AuthHookRaw -> Maybe JWTConfig -> Maybe RoleName -> Maybe CorsConfig -> Bool -> Maybe Text -> Maybe Bool -> Bool -> StringifyNumbers -> Maybe Bool -> Maybe (HashSet API) -> Maybe RefetchInterval -> Maybe BatchSize -> Maybe RefetchInterval -> Maybe BatchSize -> Bool -> Maybe (HashSet (EngineLogType impl)) -> Maybe LogLevel -> Bool -> Maybe Bool -> Maybe PositiveInt -> Maybe (NonNegative Milliseconds) -> Maybe OptionalInterval -> RemoteSchemaPermissions -> Bool -> Maybe KeepAliveDelay -> Maybe InferFunctionPermissions -> MaintenanceMode () -> Maybe OptionalInterval -> Maybe (HashSet ExperimentalFeature) -> Maybe NonNegativeInt -> Maybe (NonNegative Seconds) -> Maybe WSConnectionInitTimeout -> MetadataQueryLoggingMode -> Maybe NamingCase -> Maybe ExtensionsSchema -> ServeOptionsRaw impl
[rsoPort] :: ServeOptionsRaw impl -> Maybe Port
[rsoHost] :: ServeOptionsRaw impl -> Maybe HostPreference
[rsoConnParams] :: ServeOptionsRaw impl -> ConnParamsRaw
[rsoTxIso] :: ServeOptionsRaw impl -> Maybe TxIsolation
[rsoAdminSecret] :: ServeOptionsRaw impl -> Maybe AdminSecretHash
[rsoAuthHook] :: ServeOptionsRaw impl -> AuthHookRaw
[rsoJwtSecret] :: ServeOptionsRaw impl -> Maybe JWTConfig
[rsoUnAuthRole] :: ServeOptionsRaw impl -> Maybe RoleName
[rsoCorsConfig] :: ServeOptionsRaw impl -> Maybe CorsConfig
[rsoEnableConsole] :: ServeOptionsRaw impl -> Bool
[rsoConsoleAssetsDir] :: ServeOptionsRaw impl -> Maybe Text
[rsoEnableTelemetry] :: ServeOptionsRaw impl -> Maybe Bool
[rsoWsReadCookie] :: ServeOptionsRaw impl -> Bool
[rsoStringifyNum] :: ServeOptionsRaw impl -> StringifyNumbers
[rsoDangerousBooleanCollapse] :: ServeOptionsRaw impl -> Maybe Bool
[rsoEnabledAPIs] :: ServeOptionsRaw impl -> Maybe (HashSet API)
[rsoMxRefetchInt] :: ServeOptionsRaw impl -> Maybe RefetchInterval
[rsoMxBatchSize] :: ServeOptionsRaw impl -> Maybe BatchSize
[rsoStreamingMxRefetchInt] :: ServeOptionsRaw impl -> Maybe RefetchInterval
[rsoStreamingMxBatchSize] :: ServeOptionsRaw impl -> Maybe BatchSize
[rsoEnableAllowlist] :: ServeOptionsRaw impl -> Bool
[rsoEnabledLogTypes] :: ServeOptionsRaw impl -> Maybe (HashSet (EngineLogType impl))
[rsoLogLevel] :: ServeOptionsRaw impl -> Maybe LogLevel
[rsoDevMode] :: ServeOptionsRaw impl -> Bool
[rsoAdminInternalErrors] :: ServeOptionsRaw impl -> Maybe Bool
[rsoEventsHttpPoolSize] :: ServeOptionsRaw impl -> Maybe PositiveInt
[rsoEventsFetchInterval] :: ServeOptionsRaw impl -> Maybe (NonNegative Milliseconds)
[rsoAsyncActionsFetchInterval] :: ServeOptionsRaw impl -> Maybe OptionalInterval
[rsoEnableRemoteSchemaPermissions] :: ServeOptionsRaw impl -> RemoteSchemaPermissions
[rsoWebSocketCompression] :: ServeOptionsRaw impl -> Bool
[rsoWebSocketKeepAlive] :: ServeOptionsRaw impl -> Maybe KeepAliveDelay
[rsoInferFunctionPermissions] :: ServeOptionsRaw impl -> Maybe InferFunctionPermissions
[rsoEnableMaintenanceMode] :: ServeOptionsRaw impl -> MaintenanceMode ()
[rsoSchemaPollInterval] :: ServeOptionsRaw impl -> Maybe OptionalInterval

-- | See Note '$experimentalFeatures' at bottom of module
[rsoExperimentalFeatures] :: ServeOptionsRaw impl -> Maybe (HashSet ExperimentalFeature)
[rsoEventsFetchBatchSize] :: ServeOptionsRaw impl -> Maybe NonNegativeInt
[rsoGracefulShutdownTimeout] :: ServeOptionsRaw impl -> Maybe (NonNegative Seconds)
[rsoWebSocketConnectionInitTimeout] :: ServeOptionsRaw impl -> Maybe WSConnectionInitTimeout
[rsoEnableMetadataQueryLoggingEnv] :: ServeOptionsRaw impl -> MetadataQueryLoggingMode

-- | stores global default naming convention
[rsoDefaultNamingConvention] :: ServeOptionsRaw impl -> Maybe NamingCase
[rsoExtensionsSchema] :: ServeOptionsRaw impl -> Maybe ExtensionsSchema

-- | An <a>Int</a> representing a Port number in the range 0 to 65536.
newtype Port
Port :: Int -> Port
[_getPort] :: Port -> Int
mkPort :: Int -> Maybe Port
unsafePort :: Int -> Port
data API
METADATA :: API
GRAPHQL :: API
PGDUMP :: API
DEVELOPER :: API
CONFIG :: API
METRICS :: API
data AuthHookRaw
AuthHookRaw :: Maybe Text -> Maybe AuthHookType -> AuthHookRaw
[ahrUrl] :: AuthHookRaw -> Maybe Text
[ahrType] :: AuthHookRaw -> Maybe AuthHookType

-- | Sleep time interval for recurring activities such as
--   (@<tt>asyncActionsProcessor</tt>) Presently
--   <a>msToOptionalInterval</a> interprets `0` as Skip.
data OptionalInterval

-- | No polling
Skip :: OptionalInterval

-- | Interval time
Interval :: NonNegative Milliseconds -> OptionalInterval
msToOptionalInterval :: NonNegative Milliseconds -> OptionalInterval

-- | The Raw configuration data from the Arg and Env parsers needed to
--   construct a <tt>ConnParams</tt>
data ConnParamsRaw
ConnParamsRaw :: Maybe NonNegativeInt -> Maybe NonNegativeInt -> Maybe NonNegativeInt -> Maybe (NonNegative NominalDiffTime) -> Maybe Bool -> Maybe (NonNegative NominalDiffTime) -> ConnParamsRaw
[rcpStripes] :: ConnParamsRaw -> Maybe NonNegativeInt
[rcpConns] :: ConnParamsRaw -> Maybe NonNegativeInt
[rcpIdleTime] :: ConnParamsRaw -> Maybe NonNegativeInt

-- | Time from connection creation after which to destroy a connection and
--   choose a different/new one.
[rcpConnLifetime] :: ConnParamsRaw -> Maybe (NonNegative NominalDiffTime)
[rcpAllowPrepare] :: ConnParamsRaw -> Maybe Bool

-- | See <tt>HASURA_GRAPHQL_PG_POOL_TIMEOUT</tt>
[rcpPoolTimeout] :: ConnParamsRaw -> Maybe (NonNegative NominalDiffTime)
newtype KeepAliveDelay
KeepAliveDelay :: NonNegative Seconds -> KeepAliveDelay
[unKeepAliveDelay] :: KeepAliveDelay -> NonNegative Seconds

-- | The timeout duration in <a>Seconds</a> for a WebSocket connection.
newtype WSConnectionInitTimeout
WSConnectionInitTimeout :: NonNegative Seconds -> WSConnectionInitTimeout
[unWSConnectionInitTimeout] :: WSConnectionInitTimeout -> NonNegative Seconds

-- | The final Serve Command options accummulated from the Arg Parser and
--   the Environment, fully processed and ready to apply when running the
--   server.
data ServeOptions impl
ServeOptions :: Port -> HostPreference -> ConnParams -> TxIsolation -> HashSet AdminSecretHash -> Maybe AuthHook -> [JWTConfig] -> Maybe RoleName -> CorsConfig -> Bool -> Maybe Text -> Bool -> StringifyNumbers -> Bool -> HashSet API -> LiveQueriesOptions -> StreamQueriesOptions -> Bool -> HashSet (EngineLogType impl) -> LogLevel -> ResponseInternalErrorsConfig -> PositiveInt -> NonNegative Milliseconds -> OptionalInterval -> RemoteSchemaPermissions -> ConnectionOptions -> KeepAliveDelay -> InferFunctionPermissions -> MaintenanceMode () -> OptionalInterval -> HashSet ExperimentalFeature -> NonNegativeInt -> Bool -> NonNegative Seconds -> WSConnectionInitTimeout -> EventingMode -> ReadOnlyMode -> MetadataQueryLoggingMode -> Maybe NamingCase -> ExtensionsSchema -> ServeOptions impl
[soPort] :: ServeOptions impl -> Port
[soHost] :: ServeOptions impl -> HostPreference
[soConnParams] :: ServeOptions impl -> ConnParams
[soTxIso] :: ServeOptions impl -> TxIsolation
[soAdminSecret] :: ServeOptions impl -> HashSet AdminSecretHash
[soAuthHook] :: ServeOptions impl -> Maybe AuthHook
[soJwtSecret] :: ServeOptions impl -> [JWTConfig]
[soUnAuthRole] :: ServeOptions impl -> Maybe RoleName
[soCorsConfig] :: ServeOptions impl -> CorsConfig
[soEnableConsole] :: ServeOptions impl -> Bool
[soConsoleAssetsDir] :: ServeOptions impl -> Maybe Text
[soEnableTelemetry] :: ServeOptions impl -> Bool
[soStringifyNum] :: ServeOptions impl -> StringifyNumbers
[soDangerousBooleanCollapse] :: ServeOptions impl -> Bool
[soEnabledAPIs] :: ServeOptions impl -> HashSet API
[soLiveQueryOpts] :: ServeOptions impl -> LiveQueriesOptions
[soStreamingQueryOpts] :: ServeOptions impl -> StreamQueriesOptions
[soEnableAllowlist] :: ServeOptions impl -> Bool
[soEnabledLogTypes] :: ServeOptions impl -> HashSet (EngineLogType impl)
[soLogLevel] :: ServeOptions impl -> LogLevel
[soResponseInternalErrorsConfig] :: ServeOptions impl -> ResponseInternalErrorsConfig
[soEventsHttpPoolSize] :: ServeOptions impl -> PositiveInt
[soEventsFetchInterval] :: ServeOptions impl -> NonNegative Milliseconds
[soAsyncActionsFetchInterval] :: ServeOptions impl -> OptionalInterval
[soEnableRemoteSchemaPermissions] :: ServeOptions impl -> RemoteSchemaPermissions
[soConnectionOptions] :: ServeOptions impl -> ConnectionOptions
[soWebSocketKeepAlive] :: ServeOptions impl -> KeepAliveDelay
[soInferFunctionPermissions] :: ServeOptions impl -> InferFunctionPermissions
[soEnableMaintenanceMode] :: ServeOptions impl -> MaintenanceMode ()
[soSchemaPollInterval] :: ServeOptions impl -> OptionalInterval

-- | See note '$experimentalFeatures'
[soExperimentalFeatures] :: ServeOptions impl -> HashSet ExperimentalFeature
[soEventsFetchBatchSize] :: ServeOptions impl -> NonNegativeInt
[soDevMode] :: ServeOptions impl -> Bool
[soGracefulShutdownTimeout] :: ServeOptions impl -> NonNegative Seconds
[soWebSocketConnectionInitTimeout] :: ServeOptions impl -> WSConnectionInitTimeout
[soEventingMode] :: ServeOptions impl -> EventingMode

-- | See note '$readOnlyMode'
[soReadOnlyMode] :: ServeOptions impl -> ReadOnlyMode
[soEnableMetadataQueryLogging] :: ServeOptions impl -> MetadataQueryLoggingMode
[soDefaultNamingConvention] :: ServeOptions impl -> Maybe NamingCase
[soExtensionsSchema] :: ServeOptions impl -> ExtensionsSchema

-- | <a>ResponseInternalErrorsConfig</a> represents the encoding of the
--   internal errors in the response to the client.
--   
--   For more details, see this github comment:
--   <a>https://github.com/hasura/graphql-engine/issues/4031#issuecomment-609747705</a>
data ResponseInternalErrorsConfig
InternalErrorsAllRequests :: ResponseInternalErrorsConfig
InternalErrorsAdminOnly :: ResponseInternalErrorsConfig
InternalErrorsDisabled :: ResponseInternalErrorsConfig
shouldIncludeInternal :: RoleName -> ResponseInternalErrorsConfig -> Bool

-- | The Downgrade Command options. These are only sourced from the Arg
--   Parser and are used directly in <a>Migrate</a>.
data DowngradeOptions
DowngradeOptions :: Text -> Bool -> DowngradeOptions
[dgoTargetVersion] :: DowngradeOptions -> Text
[dgoDryRun] :: DowngradeOptions -> Bool
instance Data.Traversable.Traversable Hasura.Server.Init.Config.PostgresConnInfo
instance Data.Foldable.Foldable Hasura.Server.Init.Config.PostgresConnInfo
instance GHC.Base.Functor Hasura.Server.Init.Config.PostgresConnInfo
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Server.Init.Config.PostgresConnInfo a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Server.Init.Config.PostgresConnInfo a)
instance GHC.Show.Show Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance GHC.Read.Read Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance GHC.Classes.Eq Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance GHC.Classes.Eq Hasura.Server.Init.Config.PostgresConnInfoRaw
instance GHC.Show.Show Hasura.Server.Init.Config.PostgresConnInfoRaw
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.Port
instance Hasura.Incremental.Internal.Dependency.Cacheable Hasura.Server.Init.Config.Port
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.Port
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.Port
instance GHC.Generics.Generic Hasura.Server.Init.Config.Port
instance GHC.Classes.Ord Hasura.Server.Init.Config.Port
instance GHC.Classes.Eq Hasura.Server.Init.Config.Port
instance GHC.Show.Show Hasura.Server.Init.Config.Port
instance GHC.Generics.Generic Hasura.Server.Init.Config.API
instance GHC.Read.Read Hasura.Server.Init.Config.API
instance GHC.Classes.Eq Hasura.Server.Init.Config.API
instance GHC.Show.Show Hasura.Server.Init.Config.API
instance GHC.Classes.Eq Hasura.Server.Init.Config.OptionalInterval
instance GHC.Show.Show Hasura.Server.Init.Config.OptionalInterval
instance GHC.Classes.Eq Hasura.Server.Init.Config.ConnParamsRaw
instance GHC.Show.Show Hasura.Server.Init.Config.ConnParamsRaw
instance GHC.Show.Show Hasura.Server.Init.Config.KeepAliveDelay
instance GHC.Classes.Eq Hasura.Server.Init.Config.KeepAliveDelay
instance GHC.Classes.Ord Hasura.Server.Init.Config.WSConnectionInitTimeout
instance GHC.Classes.Eq Hasura.Server.Init.Config.WSConnectionInitTimeout
instance GHC.Show.Show Hasura.Server.Init.Config.WSConnectionInitTimeout
instance GHC.Classes.Eq Hasura.Server.Init.Config.ResponseInternalErrorsConfig
instance GHC.Show.Show Hasura.Server.Init.Config.ResponseInternalErrorsConfig
instance GHC.Classes.Eq Hasura.Server.Init.Config.DowngradeOptions
instance GHC.Show.Show Hasura.Server.Init.Config.DowngradeOptions
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Server.Init.Config.HGECommand a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Server.Init.Config.HGECommand a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.WSConnectionInitTimeout
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.WSConnectionInitTimeout
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.KeepAliveDelay
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.KeepAliveDelay
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.OptionalInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.OptionalInterval
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.API
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.API
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.API
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.Port
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.PostgresConnDetailsRaw


-- | Helpful functions and types for generating log statements and URIs
--   during Options fetching and merging.
module Hasura.Server.Init.Logging
censorQueryItem :: Text -> QueryItem -> QueryItem
censorQuery :: Text -> Query -> Query
updateQuery :: (Query -> Query) -> URI -> URI
censorURI :: Text -> URI -> URI

-- | Generate a <tt>StartupLog</tt> from the Postgres <tt>ConnInfo</tt>.
connInfoToLog :: ConnInfo -> StartupLog

-- | Generate a <tt>StartupLog</tt> from the final <tt>ServeOptions</tt>.
serveOptsToLog :: ToJSON (EngineLogType impl) => ServeOptions impl -> StartupLog
mkGenericStrLog :: LogLevel -> Text -> String -> StartupLog
mkGenericLog :: ToJSON a => LogLevel -> Text -> a -> StartupLog
data StartupTimeInfo
StartupTimeInfo :: !Text -> !Double -> StartupTimeInfo
[_stiMessage] :: StartupTimeInfo -> !Text
[_stiTimeTaken] :: StartupTimeInfo -> !Double
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Logging.StartupTimeInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Logging.StartupTimeInfo

module Hasura.Server.Init.Env

-- | Lookup a key in the application environment then parse the value with
--   a <a>FromEnv</a> instance'
considerEnv :: (Monad m, FromEnv a) => String -> WithEnvT m (Maybe a)

-- | Lookup a list of keys with <a>considerEnv</a> and return the first
--   value to parse successfully.
considerEnvs :: (Monad m, FromEnv a) => [String] -> WithEnvT m (Maybe a)

-- | Lookup a list of keys with <a>withOption</a> and return the first
--   value to parse successfully.
withOptions :: (Monad m, FromEnv option) => Maybe option -> [Option ()] -> WithEnvT m (Maybe option)

-- | Given the parse result for an option and the 'Option def' record for
--   that option, query the environment, and then merge the results from
--   the parser and environment.
withOption :: (Monad m, FromEnv option) => Maybe option -> Option () -> WithEnvT m (Maybe option)

-- | Given the parse result for an option and the 'Option def' record for
--   that option, query the environment, and then merge the results from
--   the parser, environment, and the default.
withOptionDefault :: (Monad m, FromEnv option) => Maybe option -> Option option -> WithEnvT m option

-- | Switches in 'optparse-applicative' have different semantics then
--   ordinary flags. They are always optional and produce a <a>False</a>
--   when absent rather then a <a>Nothing</a>.
--   
--   In HGE we give Env Vars a higher precedence then an absent Switch but
--   the ordinary <tt>withEnv</tt> operation expects a <a>Nothing</a> for
--   an absent arg parser result.
--   
--   This function executes with 'withOption Nothing' when the Switch is
--   absent, otherwise it returns <a>True</a>.
--   
--   An alternative solution would be to make Switches return 'Maybe _',
--   where '_' is an option specific sum type. This would allow us to use
--   <a>withOptionDefault</a> directly. Additionally, all fields of
--   <tt>ServeOptionsRaw</tt> would become <a>Maybe</a> or <tt>First</tt>
--   values which would allow us to write a 'Monoid ServeOptionsRaw'
--   instance for combing different option sources.
withOptionSwitch :: Monad m => Bool -> Option Bool -> WithEnvT m Bool

-- | A <a>Read</a> style parser used for consuming Env Vars and building
--   <tt>ReadM</tt> parsers for 'optparse-applicative'.
class FromEnv a
fromEnv :: FromEnv a => String -> Either String a
type WithEnv = WithEnvT Identity

-- | The monadic context for querying Env Vars.
newtype WithEnvT m a
WithEnvT :: ReaderT [(String, String)] (ExceptT String m) a -> WithEnvT m a
[unWithEnvT] :: WithEnvT m a -> ReaderT [(String, String)] (ExceptT String m) a

-- | Given an environment run a <a>WithEnv</a> action producing either a
--   parse error or an <tt>a</tt>.
runWithEnv :: [(String, String)] -> WithEnv a -> Either String a

-- | Given an environment run a <a>WithEnvT</a> action producing either a
--   parse error or an <tt>a</tt>.
runWithEnvT :: [(String, String)] -> WithEnvT m a -> m (Either String a)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Server.Init.Env.WithEnvT m)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError GHC.Base.String (Hasura.Server.Init.Env.WithEnvT m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader [(GHC.Base.String, GHC.Base.String)] (Hasura.Server.Init.Env.WithEnvT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.Server.Init.Env.WithEnvT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.Server.Init.Env.WithEnvT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.Server.Init.Env.WithEnvT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.Server.Init.Env.WithEnvT
instance Control.Monad.Morph.MFunctor Hasura.Server.Init.Env.WithEnvT
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Internal.DiffTime.DiffTime
instance Hasura.Server.Init.Env.FromEnv GHC.Base.String
instance Hasura.Server.Init.Env.FromEnv Data.Streaming.Network.Internal.HostPreference
instance Hasura.Server.Init.Env.FromEnv Data.Text.Internal.Text
instance Hasura.Server.Init.Env.FromEnv a => Hasura.Server.Init.Env.FromEnv (GHC.Maybe.Maybe a)
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Auth.WebHook.AuthHookType
instance Hasura.Server.Init.Env.FromEnv GHC.Types.Int
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Auth.AdminSecretHash
instance Hasura.Server.Init.Env.FromEnv Hasura.Session.RoleName
instance Hasura.Server.Init.Env.FromEnv GHC.Types.Bool
instance Hasura.Server.Init.Env.FromEnv Hasura.GraphQL.Schema.Options.StringifyNumbers
instance Hasura.Server.Init.Env.FromEnv Hasura.GraphQL.Schema.Options.RemoteSchemaPermissions
instance Hasura.Server.Init.Env.FromEnv Hasura.GraphQL.Schema.Options.InferFunctionPermissions
instance Hasura.Server.Init.Env.FromEnv (Hasura.Server.Types.MaintenanceMode ())
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Logging.MetadataQueryLoggingMode
instance Hasura.Server.Init.Env.FromEnv Database.PG.Query.Transaction.TxIsolation
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Cors.CorsConfig
instance Hasura.Server.Init.Env.FromEnv (Data.HashSet.Internal.HashSet Hasura.Server.Init.Config.API)
instance Hasura.Server.Init.Env.FromEnv Hasura.GraphQL.Schema.NamingCase.NamingCase
instance Hasura.Server.Init.Env.FromEnv (Data.HashSet.Internal.HashSet Hasura.Server.Types.ExperimentalFeature)
instance Hasura.Server.Init.Env.FromEnv Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance Hasura.Server.Init.Env.FromEnv Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Units.Milliseconds
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.OptionalInterval
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Units.Seconds
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.WSConnectionInitTimeout
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.KeepAliveDelay
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Auth.JWT.JWTConfig
instance Hasura.Server.Init.Env.FromEnv [Hasura.Server.Auth.JWT.JWTConfig]
instance Hasura.Logging.EnabledLogTypes impl => Hasura.Server.Init.Env.FromEnv (Data.HashSet.Internal.HashSet (Hasura.Logging.EngineLogType impl))
instance Hasura.Server.Init.Env.FromEnv Hasura.Logging.LogLevel
instance Hasura.Server.Init.Env.FromEnv Data.URL.Template.URLTemplate
instance (GHC.Num.Num a, GHC.Classes.Ord a, Hasura.Server.Init.Env.FromEnv a) => Hasura.Server.Init.Env.FromEnv (Hasura.RQL.Types.Numeric.NonNegative a)
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Numeric.NonNegativeInt
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Numeric.NonNegativeDiffTime
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Numeric.PositiveInt
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.Port
instance Hasura.Server.Init.Env.FromEnv Hasura.Cache.Bounded.CacheSize
instance Hasura.Server.Init.Env.FromEnv Hasura.SQL.Types.ExtensionsSchema


-- | The Downgrade Command Parser
module Hasura.Server.Init.Arg.Command.Downgrade

-- | This implements the mapping between application versions and catalog
--   schema versions.
downgradeShortcuts :: [(String, String)]
downgradeCommandParser :: Parser DowngradeOptions


-- | The Arg Opt.Parser for the <tt>serve</tt> subcommand.
module Hasura.Server.Init.Arg.Command.Serve
serveCommandParser :: EnabledLogTypes impl => Parser (ServeOptionsRaw impl)
parseServerPort :: Parser (Maybe Port)
servePortOption :: Option Port
parseServerHost :: Parser (Maybe HostPreference)
serveHostOption :: Option HostPreference
parseConnParams :: Parser ConnParamsRaw
pgStripesOption :: Option NonNegativeInt
pgConnsOption :: Option NonNegativeInt
pgTimeoutOption :: Option NonNegativeInt
pgConnLifetimeOption :: Option (NonNegative NominalDiffTime)
pgUsePreparedStatementsOption :: Option Bool
pgPoolTimeoutOption :: Option ()
parseTxIsolation :: Parser (Maybe TxIsolation)
txIsolationOption :: Option TxIsolation
parseAdminSecret :: Parser (Maybe AdminSecretHash)
adminSecretOption :: Option ()
parseAccessKey :: Parser (Maybe AdminSecretHash)
accessKeyOption :: Option ()
parseAuthHook :: Parser AuthHookRaw
authHookOption :: Option ()
authHookModeOption :: Option AuthHookType
parseJwtSecret :: Parser (Maybe JWTConfig)
jwtSecretOption :: Option ()
parseUnAuthRole :: Parser (Maybe RoleName)
unAuthRoleOption :: Option ()
parseCorsConfig :: Parser (Maybe CorsConfig)
corsDomainOption :: Option CorsConfig
disableCorsOption :: Option Bool
parseEnableConsole :: Parser Bool
enableConsoleOption :: Option Bool
parseConsoleAssetsDir :: Parser (Maybe Text)
consoleAssetsDirOption :: Option ()
parseEnableTelemetry :: Parser (Maybe Bool)
enableTelemetryOption :: Option Bool
parseWsReadCookie :: Parser Bool
wsReadCookieOption :: Option Bool
parseStringifyNum :: Parser StringifyNumbers
stringifyNumOption :: Option StringifyNumbers
parseDangerousBooleanCollapse :: Parser (Maybe Bool)
dangerousBooleanCollapseOption :: Option Bool
parseEnabledAPIs :: Parser (Maybe (HashSet API))
enabledAPIsOption :: Option (HashSet API)
parseMxRefetchDelay :: Parser (Maybe RefetchInterval)
mxRefetchDelayOption :: Option RefetchInterval
parseMxBatchSize :: Parser (Maybe BatchSize)
mxBatchSizeOption :: Option BatchSize
parseStreamingMxRefetchDelay :: Parser (Maybe RefetchInterval)
streamingMxRefetchDelayOption :: Option RefetchInterval
parseStreamingMxBatchSize :: Parser (Maybe BatchSize)
streamingMxBatchSizeOption :: Option BatchSize
parseEnableAllowlist :: Parser Bool
enableAllowlistOption :: Option Bool
parseEnabledLogs :: forall impl. EnabledLogTypes impl => Parser (Maybe (HashSet (EngineLogType impl)))
enabledLogsOption :: EnabledLogTypes impl => Option (HashSet (EngineLogType impl))
parseLogLevel :: Parser (Maybe LogLevel)
logLevelOption :: Option LogLevel
parsePlanCacheSize :: Parser (Maybe CacheSize)
parseGraphqlDevMode :: Parser Bool
graphqlDevModeOption :: Option Bool
parseGraphqlAdminInternalErrors :: Parser (Maybe Bool)
graphqlAdminInternalErrorsOption :: Option Bool
parseGraphqlEventsHttpPoolSize :: Parser (Maybe PositiveInt)
graphqlEventsHttpPoolSizeOption :: Option PositiveInt
parseGraphqlEventsFetchInterval :: Parser (Maybe (NonNegative Milliseconds))
graphqlEventsFetchIntervalOption :: Option (NonNegative Milliseconds)
parseGraphqlAsyncActionsFetchInterval :: Parser (Maybe OptionalInterval)
asyncActionsFetchIntervalOption :: Option OptionalInterval
parseEnableRemoteSchemaPerms :: Parser RemoteSchemaPermissions
enableRemoteSchemaPermsOption :: Option RemoteSchemaPermissions
parseWebSocketCompression :: Parser Bool
webSocketCompressionOption :: Option Bool
parseWebSocketKeepAlive :: Parser (Maybe KeepAliveDelay)
webSocketKeepAliveOption :: Option KeepAliveDelay
parseInferFunctionPerms :: Parser (Maybe InferFunctionPermissions)
inferFunctionPermsOption :: Option InferFunctionPermissions
parseEnableMaintenanceMode :: Parser (MaintenanceMode ())
enableMaintenanceModeOption :: Option (MaintenanceMode ())
parseSchemaPollInterval :: Parser (Maybe OptionalInterval)
schemaPollIntervalOption :: Option OptionalInterval
parseExperimentalFeatures :: Parser (Maybe (HashSet ExperimentalFeature))
experimentalFeaturesOption :: Option (HashSet ExperimentalFeature)
parseEventsFetchBatchSize :: Parser (Maybe NonNegativeInt)
eventsFetchBatchSizeOption :: Option NonNegativeInt
parseGracefulShutdownTimeout :: Parser (Maybe (NonNegative Seconds))
gracefulShutdownOption :: Option (NonNegative Seconds)
parseWebSocketConnectionInitTimeout :: Parser (Maybe WSConnectionInitTimeout)
webSocketConnectionInitTimeoutOption :: Option WSConnectionInitTimeout
parseEnableMetadataQueryLogging :: Parser MetadataQueryLoggingMode
enableMetadataQueryLoggingOption :: Option MetadataQueryLoggingMode
parseDefaultNamingConvention :: Parser (Maybe NamingCase)
defaultNamingConventionOption :: Option ()
parseExtensionsSchema :: Parser (Maybe ExtensionsSchema)
metadataDBExtensionsSchemaOption :: Option ExtensionsSchema
serveCmdFooter :: Doc

module Hasura.Server.Init.Arg

-- | The Main Arg <a>Parser</a>. It constructs a <a>HGEOptionsRaw</a> term:
--   
--   <ol>
--   <li>'(Config.PostgresConnInfo (Maybe PostgresConnInfoRaw))' - The DB
--   connection. 2: 'Maybe String' - Representing the metadata connection.
--   3: <a>HGECommand</a> <tt>a</tt> - The result of the supplied
--   Subcommand.</li>
--   </ol>
parseHgeOpts :: EnabledLogTypes impl => Parser (HGEOptionsRaw (ServeOptionsRaw impl))
parseHGECommand :: EnabledLogTypes impl => Parser (HGECommand (ServeOptionsRaw impl))
parsePostgresConnInfo :: Parser (PostgresConnInfo (Maybe PostgresConnInfoRaw))
retriesNumOption :: Option ()
parseDatabaseUrl :: Parser (Maybe URLTemplate)
databaseUrlOption :: Option ()
parseRawConnDetails :: Parser (Maybe PostgresConnDetailsRaw)
parseMetadataDbUrl :: Parser (Maybe String)
metadataDbUrlOption :: Option ()
mainCmdFooter :: Doc


-- | Arg and Env Parsing for initialisation of the engine along with
--   corresponding logging and other helper functionality.
--   
--   This module is intended as the interface for options parsing and its
--   submodules should not need to be imported directly.
module Hasura.Server.Init

-- | Query the Metadata DB for the Metadata DB UUID. TODO: Move into a
--   dedicated Metadata module (ala Pro).
getDbId :: TxE QErr MetadataDbId
getPgVersion :: TxE QErr PGVersion

-- | Given the <a>ServeOptionsRaw</a> parsed from the arg parser,
--   postprocess the db url and fetch env vars associated with the main
--   command parser, then process the subcommand raw values if necessary.
mkHGEOptions :: EnabledLogTypes impl => HGEOptionsRaw (ServeOptionsRaw impl) -> WithEnv (HGEOptions (ServeOptions impl))

-- | <tt>PostressConnInfo</tt> is a a tuple of some <tt>a</tt> with a
--   'Maybe Int' representing the retries setting. This function thus takes
--   a retries setting and a <a>PostgresConnInfoRaw</a> from the arg parser
--   and merges those results with the contents of their corresponding env
--   vars.
processPostgresConnInfo :: PostgresConnInfo (Maybe PostgresConnInfoRaw) -> WithEnv (PostgresConnInfo (Maybe UrlConf))

-- | A helper function for <a>processPostgresConnInfo</a> which fetches
--   postgres connection info from the <a>WithEnv</a> and merges it with
--   the arg parser result.
rawConnInfoToUrlConf :: Maybe PostgresConnInfoRaw -> WithEnv (Maybe UrlConf)

-- | Merge the results of the serve subcommmand arg parser with
--   corresponding values from the <a>WithEnv</a> context.
mkServeOptions :: forall impl. EnabledLogTypes impl => ServeOptionsRaw impl -> WithEnv (ServeOptions impl)


-- | Migrations for the Hasura catalog.
--   
--   To add a new migration:
--   
--   <ol>
--   <li>Bump the catalog version number in
--   <tt>src-rsr/catalog_version.txt</tt>.</li>
--   <li>Add a migration script in the <tt>src-rsr<i>migrations</i></tt>
--   directory with the name
--   <tt><a>version</a>_to_<a>version</a>.sql</tt>.</li>
--   <li>Create a downgrade script in the <tt>src-rsr<i>migrations</i></tt>
--   directory with the name
--   <tt><a>version</a>_to_<a>version</a>.sql</tt>.</li>
--   <li>If making a new release, add the mapping from application version
--   to catalog schema version in
--   <tt>src-rsr/catalog_versions.txt</tt>.</li>
--   <li>If appropriate, add the change to
--   <tt>server<i>src-rsr</i>initialise.sql</tt> for fresh installations of
--   hasura.</li>
--   </ol>
--   
--   The Template Haskell code in this module will automatically compile
--   the new migration script into the <tt>graphql-engine</tt> executable.
--   
--   NOTE: Please have a look at the
--   `server<i>documentation</i>migration-guidelines.md` before adding any
--   new migration if you haven't already looked at it
module Hasura.Server.Migrate
data MigrationResult
MRNothingToDo :: MigrationResult
MRInitialized :: MigrationResult

-- | old catalog version
MRMigrated :: Text -> MigrationResult
MRMaintanenceMode :: MigrationResult
data MigrationPair m
MigrationPair :: m () -> Maybe (m ()) -> MigrationPair m
[mpMigrate] :: MigrationPair m -> m ()
[mpDown] :: MigrationPair m -> Maybe (m ())
migrateCatalog :: forall m. (MonadTx m, MonadIO m, MonadBaseControl IO m) => Maybe (SourceConnConfiguration ('Postgres 'Vanilla)) -> ExtensionsSchema -> MaintenanceMode () -> UTCTime -> m (MigrationResult, Metadata)
downgradeCatalog :: forall m. (MonadIO m, MonadTx m) => Maybe (SourceConnConfiguration ('Postgres 'Vanilla)) -> DowngradeOptions -> UTCTime -> m MigrationResult
migrations :: forall m. (MonadIO m, MonadTx m) => Maybe (SourceConnConfiguration ('Postgres 'Vanilla)) -> Bool -> MaintenanceMode () -> [(MetadataCatalogVersion, MigrationPair m)]
multiQ :: MonadTx m => Query -> m ()
instance GHC.Classes.Eq Hasura.Server.Migrate.MigrationResult
instance GHC.Show.Show Hasura.Server.Migrate.MigrationResult
instance Hasura.Logging.ToEngineLog Hasura.Server.Migrate.MigrationResult Hasura.Logging.Hasura


-- | API related to server configuration
module Hasura.Server.API.Config
data JWTInfo
JWTInfo :: !JWTNamespace -> !JWTClaimsFormat -> !Maybe JWTCustomClaimsMap -> JWTInfo
[jwtiClaimsNamespace] :: JWTInfo -> !JWTNamespace
[jwtiClaimsFormat] :: JWTInfo -> !JWTClaimsFormat
[jwtiClaimsMap] :: JWTInfo -> !Maybe JWTCustomClaimsMap
data ServerConfig
ServerConfig :: !Version -> !InferFunctionPermissions -> !RemoteSchemaPermissions -> !Bool -> !Bool -> !Bool -> ![JWTInfo] -> !Bool -> !LiveQueriesOptions -> !SubscriptionsOptions -> !Maybe Text -> !HashSet ExperimentalFeature -> ServerConfig
[scfgVersion] :: ServerConfig -> !Version
[scfgIsFunctionPermissionsInferred] :: ServerConfig -> !InferFunctionPermissions
[scfgIsRemoteSchemaPermissionsEnabled] :: ServerConfig -> !RemoteSchemaPermissions
[scfgIsAdminSecretSet] :: ServerConfig -> !Bool
[scfgIsAuthHookSet] :: ServerConfig -> !Bool
[scfgIsJwtSet] :: ServerConfig -> !Bool
[scfgJwt] :: ServerConfig -> ![JWTInfo]
[scfgIsAllowListEnabled] :: ServerConfig -> !Bool
[scfgLiveQueries] :: ServerConfig -> !LiveQueriesOptions
[scfgStreamingQueries] :: ServerConfig -> !SubscriptionsOptions
[scfgConsoleAssetsDir] :: ServerConfig -> !Maybe Text
[scfgExperimentalFeatures] :: ServerConfig -> !HashSet ExperimentalFeature
runGetConfig :: InferFunctionPermissions -> RemoteSchemaPermissions -> AuthMode -> Bool -> LiveQueriesOptions -> SubscriptionsOptions -> Maybe Text -> HashSet ExperimentalFeature -> ServerConfig
isAdminSecretSet :: AuthMode -> Bool
isAuthHookSet :: AuthMode -> Bool
isJWTSet :: AuthMode -> Bool
getJWTInfo :: AuthMode -> [JWTInfo]
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.API.Config.ServerConfig
instance GHC.Classes.Eq Hasura.Server.API.Config.ServerConfig
instance GHC.Show.Show Hasura.Server.API.Config.ServerConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.API.Config.JWTInfo
instance GHC.Classes.Eq Hasura.Server.API.Config.JWTInfo
instance GHC.Show.Show Hasura.Server.API.Config.JWTInfo

module Hasura.RQL.DDL.Schema.Source
data AddSource b
AddSource :: SourceName -> BackendSourceKind b -> SourceConnConfiguration b -> Bool -> SourceCustomization -> AddSource b
[_asName] :: AddSource b -> SourceName
[_asBackendKind] :: AddSource b -> BackendSourceKind b
[_asConfiguration] :: AddSource b -> SourceConnConfiguration b
[_asReplaceConfiguration] :: AddSource b -> Bool
[_asCustomization] :: AddSource b -> SourceCustomization
runAddSource :: forall m b. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => AddSource b -> m EncJSON
data RenameSource
RenameSource :: SourceName -> SourceName -> RenameSource
[_rmName] :: RenameSource -> SourceName
[_rmNewName] :: RenameSource -> SourceName
runRenameSource :: forall m. (MonadError QErr m, CacheRWM m, MetadataM m) => RenameSource -> m EncJSON
data DropSource
DropSource :: SourceName -> Bool -> DropSource
[_dsName] :: DropSource -> SourceName
[_dsCascade] :: DropSource -> Bool
runDropSource :: forall m r. (MonadError QErr m, CacheRWM m, MonadIO m, MonadBaseControl IO m, MetadataM m, MonadReader r m, Has (Logger Hasura) r) => DropSource -> m EncJSON
dropSourceMetadataModifier :: SourceName -> MetadataModifier
dropSource :: forall m r b. (MonadError QErr m, CacheRWM m, MonadIO m, MonadBaseControl IO m, MetadataM m, MonadReader r m, Has (Logger Hasura) r, BackendMetadata b) => SchemaCache -> DropSource -> SourceInfo b -> m ()
runPostDropSourceHook :: forall m r b. (MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadReader r m, Has (Logger Hasura) r, BackendMetadata b) => SourceName -> SourceInfo b -> m ()
data UpdateSource b
UpdateSource :: SourceName -> Maybe (SourceConnConfiguration b) -> Maybe SourceCustomization -> UpdateSource b
[_usName] :: UpdateSource b -> SourceName
[_usConfiguration] :: UpdateSource b -> Maybe (SourceConnConfiguration b)
[_usCustomization] :: UpdateSource b -> Maybe SourceCustomization
runUpdateSource :: forall m b. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => UpdateSource b -> m EncJSON
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Source.DropSource
instance GHC.Show.Show Hasura.RQL.DDL.Schema.Source.DropSource
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Extended.FromJSONWithContext (Hasura.SQL.Backend.BackendSourceKind b) (Hasura.RQL.DDL.Schema.Source.UpdateSource b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.Source.DropSource
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.Source.RenameSource
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Extended.FromJSONWithContext (Hasura.SQL.Backend.BackendSourceKind b) (Hasura.RQL.DDL.Schema.Source.AddSource b)

module Hasura.RQL.DDL.Metadata
runClearMetadata :: forall m r. (QErrM m, MonadIO m, CacheRWM m, MetadataM m, MonadMetadataStorageQueryAPI m, MonadBaseControl IO m, MonadReader r m, Has (Logger Hasura) r) => ClearMetadata -> m EncJSON

-- | Replace the 'current metadata' with the 'new metadata' The 'new
--   metadata' might come via the 'Import Metadata' in console
runReplaceMetadata :: (CacheRWM m, MetadataM m, MonadIO m, MonadMetadataStorageQueryAPI m, MonadReader r m, Has (Logger Hasura) r) => ReplaceMetadata -> m EncJSON
runReplaceMetadataV1 :: (QErrM m, CacheRWM m, MetadataM m, MonadIO m, MonadMetadataStorageQueryAPI m, MonadReader r m, Has (Logger Hasura) r) => ReplaceMetadataV1 -> m EncJSON
runReplaceMetadataV2 :: forall m r. (QErrM m, CacheRWM m, MetadataM m, MonadIO m, MonadMetadataStorageQueryAPI m, MonadReader r m, Has (Logger Hasura) r) => ReplaceMetadataV2 -> m EncJSON

-- | Only includes the cron triggers with <tt>included_in_metadata</tt> set
--   to <a>True</a>
processCronTriggersMetadata :: Metadata -> Metadata
runExportMetadata :: forall m. (QErrM m, MetadataM m) => ExportMetadata -> m EncJSON
runExportMetadataV2 :: forall m. (QErrM m, MetadataM m) => MetadataResourceVersion -> ExportMetadata -> m EncJSON
runReloadMetadata :: (QErrM m, CacheRWM m, MetadataM m) => ReloadMetadata -> m EncJSON
runDumpInternalState :: (QErrM m, CacheRM m) => DumpInternalState -> m EncJSON
runGetInconsistentMetadata :: (QErrM m, CacheRM m) => GetInconsistentMetadata -> m EncJSON
formatInconsistentObjs :: [InconsistentMetadata] -> Value
runDropInconsistentMetadata :: (QErrM m, CacheRWM m, MetadataM m) => DropInconsistentMetadata -> m EncJSON
purgeMetadataObj :: MetadataObjId -> MetadataModifier
runGetCatalogState :: MonadMetadataStorageQueryAPI m => GetCatalogState -> m EncJSON
runSetCatalogState :: MonadMetadataStorageQueryAPI m => SetCatalogState -> m EncJSON
runSetMetricsConfig :: (MonadIO m, CacheRWM m, MetadataM m, MonadError QErr m) => MetricsConfig -> m EncJSON
runRemoveMetricsConfig :: (MonadIO m, CacheRWM m, MetadataM m, MonadError QErr m) => m EncJSON
data TestTransformError
RequestInitializationError :: HttpException -> TestTransformError
RequestTransformationError :: Request -> TransformErrorBundle -> TestTransformError
runTestWebhookTransform :: QErrM m => TestWebhookTransform -> m EncJSON
interpolateFromEnv :: MonadError QErr m => Environment -> Text -> m Text

-- | Deserialize a JSON or X-WWW-URL-FORMENCODED body from an
--   <a>Request</a> as <a>Value</a>.
decodeBody :: Maybe ByteString -> Value

-- | Attempt to encode a <tt>ByteString</tt> as an Aeson <tt>Value</tt>
jsonToValue :: ByteString -> Maybe Value

-- | Quote a <tt>ByteString</tt> then attempt to encode it as a JSON
--   String. This is necessary for 'x-www-url-formencoded' bodies. They are
--   a list of key/value pairs encoded as a raw <tt>ByteString</tt> with no
--   quoting whereas JSON Strings must be quoted.
formUrlEncodedToValue :: ByteString -> Maybe Value
parseEnvTemplate :: Parser [Either Text Text]
indistinct :: Either a a -> a
packTransformResult :: Either TransformErrorBundle Request -> EncJSON


-- | The RQL query ('<i>v1</i>query')
module Hasura.Server.API.Query
data RQLQueryV1
RQAddExistingTableOrView :: !TrackTable ('Postgres 'Vanilla) -> RQLQueryV1
RQTrackTable :: !TrackTable ('Postgres 'Vanilla) -> RQLQueryV1
RQUntrackTable :: !UntrackTable ('Postgres 'Vanilla) -> RQLQueryV1
RQSetTableIsEnum :: !SetTableIsEnum -> RQLQueryV1
RQSetTableCustomization :: !SetTableCustomization ('Postgres 'Vanilla) -> RQLQueryV1
RQTrackFunction :: !TrackFunction ('Postgres 'Vanilla) -> RQLQueryV1
RQUntrackFunction :: !UnTrackFunction ('Postgres 'Vanilla) -> RQLQueryV1
RQCreateObjectRelationship :: !CreateObjRel ('Postgres 'Vanilla) -> RQLQueryV1
RQCreateArrayRelationship :: !CreateArrRel ('Postgres 'Vanilla) -> RQLQueryV1
RQDropRelationship :: !DropRel ('Postgres 'Vanilla) -> RQLQueryV1
RQSetRelationshipComment :: !SetRelComment ('Postgres 'Vanilla) -> RQLQueryV1
RQRenameRelationship :: !RenameRel ('Postgres 'Vanilla) -> RQLQueryV1
RQAddComputedField :: !AddComputedField ('Postgres 'Vanilla) -> RQLQueryV1
RQDropComputedField :: !DropComputedField ('Postgres 'Vanilla) -> RQLQueryV1
RQCreateRemoteRelationship :: !CreateFromSourceRelationship ('Postgres 'Vanilla) -> RQLQueryV1
RQUpdateRemoteRelationship :: !CreateFromSourceRelationship ('Postgres 'Vanilla) -> RQLQueryV1
RQDeleteRemoteRelationship :: !DeleteFromSourceRelationship ('Postgres 'Vanilla) -> RQLQueryV1
RQCreateInsertPermission :: !CreatePerm InsPerm ('Postgres 'Vanilla) -> RQLQueryV1
RQCreateSelectPermission :: !CreatePerm SelPerm ('Postgres 'Vanilla) -> RQLQueryV1
RQCreateUpdatePermission :: !CreatePerm UpdPerm ('Postgres 'Vanilla) -> RQLQueryV1
RQCreateDeletePermission :: !CreatePerm DelPerm ('Postgres 'Vanilla) -> RQLQueryV1
RQDropInsertPermission :: !DropPerm ('Postgres 'Vanilla) -> RQLQueryV1
RQDropSelectPermission :: !DropPerm ('Postgres 'Vanilla) -> RQLQueryV1
RQDropUpdatePermission :: !DropPerm ('Postgres 'Vanilla) -> RQLQueryV1
RQDropDeletePermission :: !DropPerm ('Postgres 'Vanilla) -> RQLQueryV1
RQSetPermissionComment :: !SetPermComment ('Postgres 'Vanilla) -> RQLQueryV1
RQGetInconsistentMetadata :: !GetInconsistentMetadata -> RQLQueryV1
RQDropInconsistentMetadata :: !DropInconsistentMetadata -> RQLQueryV1
RQInsert :: !InsertQuery -> RQLQueryV1
RQSelect :: !SelectQuery -> RQLQueryV1
RQUpdate :: !UpdateQuery -> RQLQueryV1
RQDelete :: !DeleteQuery -> RQLQueryV1
RQCount :: !CountQuery -> RQLQueryV1
RQBulk :: ![RQLQuery] -> RQLQueryV1
RQAddRemoteSchema :: !AddRemoteSchemaQuery -> RQLQueryV1
RQUpdateRemoteSchema :: !AddRemoteSchemaQuery -> RQLQueryV1
RQRemoveRemoteSchema :: !RemoteSchemaNameQuery -> RQLQueryV1
RQReloadRemoteSchema :: !RemoteSchemaNameQuery -> RQLQueryV1
RQIntrospectRemoteSchema :: !RemoteSchemaNameQuery -> RQLQueryV1
RQCreateEventTrigger :: !CreateEventTriggerQuery ('Postgres 'Vanilla) -> RQLQueryV1
RQDeleteEventTrigger :: !DeleteEventTriggerQuery ('Postgres 'Vanilla) -> RQLQueryV1
RQRedeliverEvent :: !RedeliverEventQuery ('Postgres 'Vanilla) -> RQLQueryV1
RQInvokeEventTrigger :: !InvokeEventTriggerQuery ('Postgres 'Vanilla) -> RQLQueryV1
RQCreateCronTrigger :: !CreateCronTrigger -> RQLQueryV1
RQDeleteCronTrigger :: !ScheduledTriggerName -> RQLQueryV1
RQCreateScheduledEvent :: !CreateScheduledEvent -> RQLQueryV1
RQCreateQueryCollection :: !CreateCollection -> RQLQueryV1
RQRenameQueryCollection :: !RenameCollection -> RQLQueryV1
RQDropQueryCollection :: !DropCollection -> RQLQueryV1
RQAddQueryToCollection :: !AddQueryToCollection -> RQLQueryV1
RQDropQueryFromCollection :: !DropQueryFromCollection -> RQLQueryV1
RQAddCollectionToAllowlist :: !AllowlistEntry -> RQLQueryV1
RQDropCollectionFromAllowlist :: !DropCollectionFromAllowlist -> RQLQueryV1
RQRunSql :: !RunSQL -> RQLQueryV1
RQReplaceMetadata :: !ReplaceMetadata -> RQLQueryV1
RQExportMetadata :: !ExportMetadata -> RQLQueryV1
RQClearMetadata :: !ClearMetadata -> RQLQueryV1
RQReloadMetadata :: !ReloadMetadata -> RQLQueryV1
RQCreateAction :: !CreateAction -> RQLQueryV1
RQDropAction :: !DropAction -> RQLQueryV1
RQUpdateAction :: !UpdateAction -> RQLQueryV1
RQCreateActionPermission :: !CreateActionPermission -> RQLQueryV1
RQDropActionPermission :: !DropActionPermission -> RQLQueryV1
RQCreateRestEndpoint :: !CreateEndpoint -> RQLQueryV1
RQDropRestEndpoint :: !DropEndpoint -> RQLQueryV1
RQDumpInternalState :: !DumpInternalState -> RQLQueryV1
RQSetCustomTypes :: !CustomTypes -> RQLQueryV1
data RQLQueryV2
RQV2TrackTable :: !TrackTableV2 ('Postgres 'Vanilla) -> RQLQueryV2
RQV2SetTableCustomFields :: !SetTableCustomFields -> RQLQueryV2
RQV2TrackFunction :: !TrackFunctionV2 ('Postgres 'Vanilla) -> RQLQueryV2
RQV2ReplaceMetadata :: !ReplaceMetadataV2 -> RQLQueryV2
data RQLQuery
RQV1 :: !RQLQueryV1 -> RQLQuery
RQV2 :: !RQLQueryV2 -> RQLQuery
runQuery :: (MonadIO m, MonadTrace m, MonadBaseControl IO m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m) => Environment -> Logger Hasura -> InstanceId -> UserInfo -> RebuildableSchemaCache -> Manager -> ServerConfigCtx -> RQLQuery -> m (EncJSON, RebuildableSchemaCache)

-- | A predicate that determines whether the given query might
--   modify/rebuild the schema cache. If so, it needs to acquire the global
--   lock on the schema cache so that other queries do not modify it
--   concurrently.
--   
--   Ideally, we would enforce this using the type system — queries for
--   which this function returns <a>False</a> should not be allowed to
--   modify the schema cache. But for now we just ensure consistency by
--   hand.
queryModifiesSchemaCache :: RQLQuery -> Bool

-- | A predicate that determines whether the given query might modify
--   user's Database. If so, when the server is run in safe mode, we should
--   not proceed with those operations.
queryModifiesUserDB :: RQLQuery -> Bool
runQueryM :: (CacheRWM m, UserInfoM m, MonadBaseControl IO m, MonadIO m, HasHttpManagerM m, HasServerConfigCtx m, MonadTrace m, MetadataM m, MonadMetadataStorageQueryAPI m, MonadQueryTags m, MonadReader r m, Has (Logger Hasura) r) => Environment -> RQLQuery -> m EncJSON
requiresAdmin :: RQLQuery -> Bool
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Query.RQLQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Query.RQLQueryV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Query.RQLQueryV2


-- | BackendAPI
--   
--   This module defines the <a>BackendAPI</a> class, alongside a few
--   helpers. Its goal is to delegate to backends the responsibility of
--   creating the parsers for the metadata API. Each backend is expected to
--   provide a list of <a>CommandParser</a>, which in turn is a simple
--   function from command name and command arguments to a corresponding
--   parser. Command parsers can easily be created using the
--   <a>commandParser</a> function.
--   
--   Furthermore, for each set of related features, such as table tracking
--   commands, or permission commands, a helper function is provided, that
--   allows a backend to write its instance by simply listing the set of
--   features it supports.
module Hasura.Server.API.Backend
type CommandParser b = BackendSourceKind b -> Text -> Value -> Parser (Maybe RQLMetadataV1)
class BackendAPI (b :: BackendType)
metadataV1CommandParsers :: BackendAPI b => [CommandParser b]
commandParserWithExplicitParser :: (BackendSourceKind b -> Value -> Parser a) -> Text -> (a -> RQLMetadataV1) -> CommandParser b
commandParser :: FromJSON a => Text -> (a -> RQLMetadataV1) -> CommandParser b
commandParserWithBackendKind :: FromJSONWithContext (BackendSourceKind b) a => Text -> (a -> RQLMetadataV1) -> CommandParser b
sourceCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
tableCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
tablePermissionsCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
functionCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
functionPermissionsCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
relationshipCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
remoteRelationshipCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
eventTriggerCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
computedFieldCommands :: forall (b :: BackendType). Backend b => [CommandParser b]

module Hasura.Backends.MySQL.Instances.API
instance Hasura.Server.API.Backend.BackendAPI 'Hasura.SQL.Backend.MySQL


-- | MSSQL Instances API
--   
--   Defines a <a>BackendAPI</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.API
instance Hasura.Server.API.Backend.BackendAPI 'Hasura.SQL.Backend.MSSQL

module Hasura.Backends.DataConnector.Adapter.API
instance Hasura.Server.API.Backend.BackendAPI 'Hasura.SQL.Backend.DataConnector

module Hasura.Backends.BigQuery.Instances.API
instance Hasura.Server.API.Backend.BackendAPI 'Hasura.SQL.Backend.BigQuery


-- | Postgres Instances API
--   
--   Defines a <a>BackendAPI</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.API
instance Hasura.Server.API.Backend.BackendAPI ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Vanilla)
instance Hasura.Server.API.Backend.BackendAPI ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Citus)
instance Hasura.Server.API.Backend.BackendAPI ('Hasura.SQL.Backend.Postgres 'Hasura.SQL.Backend.Cockroach)

module Hasura.Server.API.Instances


-- | The RQL metadata query ('<i>v1</i>metadata')
module Hasura.Server.API.Metadata
data RQLMetadataV1
RMAddSource :: !AnyBackend AddSource -> RQLMetadataV1
RMDropSource :: DropSource -> RQLMetadataV1
RMRenameSource :: !RenameSource -> RQLMetadataV1
RMUpdateSource :: !AnyBackend UpdateSource -> RQLMetadataV1
RMTrackTable :: !AnyBackend TrackTableV2 -> RQLMetadataV1
RMUntrackTable :: !AnyBackend UntrackTable -> RQLMetadataV1
RMSetTableCustomization :: !AnyBackend SetTableCustomization -> RQLMetadataV1
RMSetApolloFederationConfig :: AnyBackend SetApolloFederationConfig -> RQLMetadataV1
RMPgSetTableIsEnum :: !SetTableIsEnum -> RQLMetadataV1
RMCreateInsertPermission :: !AnyBackend (CreatePerm InsPerm) -> RQLMetadataV1
RMCreateSelectPermission :: !AnyBackend (CreatePerm SelPerm) -> RQLMetadataV1
RMCreateUpdatePermission :: !AnyBackend (CreatePerm UpdPerm) -> RQLMetadataV1
RMCreateDeletePermission :: !AnyBackend (CreatePerm DelPerm) -> RQLMetadataV1
RMDropInsertPermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropSelectPermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropUpdatePermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropDeletePermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMSetPermissionComment :: !AnyBackend SetPermComment -> RQLMetadataV1
RMCreateObjectRelationship :: !AnyBackend CreateObjRel -> RQLMetadataV1
RMCreateArrayRelationship :: !AnyBackend CreateArrRel -> RQLMetadataV1
RMDropRelationship :: !AnyBackend DropRel -> RQLMetadataV1
RMSetRelationshipComment :: !AnyBackend SetRelComment -> RQLMetadataV1
RMRenameRelationship :: !AnyBackend RenameRel -> RQLMetadataV1
RMCreateRemoteRelationship :: !AnyBackend CreateFromSourceRelationship -> RQLMetadataV1
RMUpdateRemoteRelationship :: !AnyBackend CreateFromSourceRelationship -> RQLMetadataV1
RMDeleteRemoteRelationship :: !AnyBackend DeleteFromSourceRelationship -> RQLMetadataV1
RMTrackFunction :: !AnyBackend TrackFunctionV2 -> RQLMetadataV1
RMUntrackFunction :: !AnyBackend UnTrackFunction -> RQLMetadataV1
RMSetFunctionCustomization :: AnyBackend SetFunctionCustomization -> RQLMetadataV1
RMCreateFunctionPermission :: !AnyBackend FunctionPermissionArgument -> RQLMetadataV1
RMDropFunctionPermission :: !AnyBackend FunctionPermissionArgument -> RQLMetadataV1
RMAddComputedField :: !AnyBackend AddComputedField -> RQLMetadataV1
RMDropComputedField :: !AnyBackend DropComputedField -> RQLMetadataV1
RMCreateEventTrigger :: !AnyBackend (Unvalidated1 CreateEventTriggerQuery) -> RQLMetadataV1
RMDeleteEventTrigger :: !AnyBackend DeleteEventTriggerQuery -> RQLMetadataV1
RMRedeliverEvent :: !AnyBackend RedeliverEventQuery -> RQLMetadataV1
RMInvokeEventTrigger :: !AnyBackend InvokeEventTriggerQuery -> RQLMetadataV1
RMAddRemoteSchema :: !AddRemoteSchemaQuery -> RQLMetadataV1
RMUpdateRemoteSchema :: !AddRemoteSchemaQuery -> RQLMetadataV1
RMRemoveRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMReloadRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMIntrospectRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMAddRemoteSchemaPermissions :: !AddRemoteSchemaPermission -> RQLMetadataV1
RMDropRemoteSchemaPermissions :: !DropRemoteSchemaPermissions -> RQLMetadataV1
RMCreateRemoteSchemaRemoteRelationship :: CreateRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMUpdateRemoteSchemaRemoteRelationship :: CreateRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMDeleteRemoteSchemaRemoteRelationship :: DeleteRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMCreateCronTrigger :: !Unvalidated CreateCronTrigger -> RQLMetadataV1
RMDeleteCronTrigger :: !ScheduledTriggerName -> RQLMetadataV1
RMCreateScheduledEvent :: !CreateScheduledEvent -> RQLMetadataV1
RMDeleteScheduledEvent :: !DeleteScheduledEvent -> RQLMetadataV1
RMGetScheduledEvents :: !GetScheduledEvents -> RQLMetadataV1
RMGetEventInvocations :: !GetEventInvocations -> RQLMetadataV1
RMGetCronTriggers :: RQLMetadataV1
RMCreateAction :: !Unvalidated CreateAction -> RQLMetadataV1
RMDropAction :: !DropAction -> RQLMetadataV1
RMUpdateAction :: !Unvalidated UpdateAction -> RQLMetadataV1
RMCreateActionPermission :: !CreateActionPermission -> RQLMetadataV1
RMDropActionPermission :: !DropActionPermission -> RQLMetadataV1
RMCreateQueryCollection :: !CreateCollection -> RQLMetadataV1
RMRenameQueryCollection :: !RenameCollection -> RQLMetadataV1
RMDropQueryCollection :: !DropCollection -> RQLMetadataV1
RMAddQueryToCollection :: !AddQueryToCollection -> RQLMetadataV1
RMDropQueryFromCollection :: !DropQueryFromCollection -> RQLMetadataV1
RMAddCollectionToAllowlist :: !AllowlistEntry -> RQLMetadataV1
RMDropCollectionFromAllowlist :: !DropCollectionFromAllowlist -> RQLMetadataV1
RMUpdateScopeOfCollectionInAllowlist :: !UpdateScopeOfCollectionInAllowlist -> RQLMetadataV1
RMCreateRestEndpoint :: !CreateEndpoint -> RQLMetadataV1
RMDropRestEndpoint :: !DropEndpoint -> RQLMetadataV1
RMDCAddAgent :: !DCAddAgent -> RQLMetadataV1
RMDCDeleteAgent :: !DCDeleteAgent -> RQLMetadataV1
RMListSourceKinds :: !ListSourceKinds -> RQLMetadataV1
RMSetCustomTypes :: !CustomTypes -> RQLMetadataV1
RMSetApiLimits :: !ApiLimit -> RQLMetadataV1
RMRemoveApiLimits :: RQLMetadataV1
RMSetMetricsConfig :: !MetricsConfig -> RQLMetadataV1
RMRemoveMetricsConfig :: RQLMetadataV1
RMAddInheritedRole :: !InheritedRole -> RQLMetadataV1
RMDropInheritedRole :: !DropInheritedRole -> RQLMetadataV1
RMReplaceMetadata :: !ReplaceMetadata -> RQLMetadataV1
RMExportMetadata :: !ExportMetadata -> RQLMetadataV1
RMClearMetadata :: !ClearMetadata -> RQLMetadataV1
RMReloadMetadata :: !ReloadMetadata -> RQLMetadataV1
RMGetInconsistentMetadata :: !GetInconsistentMetadata -> RQLMetadataV1
RMDropInconsistentMetadata :: !DropInconsistentMetadata -> RQLMetadataV1
RMSetGraphqlSchemaIntrospectionOptions :: !SetGraphqlIntrospectionOptions -> RQLMetadataV1
RMAddHostToTLSAllowlist :: !AddHostToTLSAllowlist -> RQLMetadataV1
RMDropHostFromTLSAllowlist :: !DropHostFromTLSAllowlist -> RQLMetadataV1
RMSetQueryTagsConfig :: !SetQueryTagsConfig -> RQLMetadataV1
RMDumpInternalState :: !DumpInternalState -> RQLMetadataV1
RMGetCatalogState :: !GetCatalogState -> RQLMetadataV1
RMSetCatalogState :: !SetCatalogState -> RQLMetadataV1
RMTestWebhookTransform :: !Unvalidated TestWebhookTransform -> RQLMetadataV1
RMBulk :: [RQLMetadataRequest] -> RQLMetadataV1

-- | Parse the Metadata API action type returning a tuple of the
--   <a>BackendSourceKind</a> and the action suffix.
--   
--   For example: <tt>"pg_add_source"</tt> parses as
--   <tt>(PostgresVanillaValue, "add_source")</tt>
parseQueryType :: MonadFail m => Text -> m (AnyBackend BackendSourceKind, Text)
data RQLMetadataV2
RMV2ReplaceMetadata :: !ReplaceMetadataV2 -> RQLMetadataV2
RMV2ExportMetadata :: !ExportMetadata -> RQLMetadataV2
data RQLMetadataRequest
RMV1 :: !RQLMetadataV1 -> RQLMetadataRequest
RMV2 :: !RQLMetadataV2 -> RQLMetadataRequest

-- | The payload for the <tt><i>v1</i>metadata</tt> endpoint. See:
--   
--   
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/metadata-api/index/</a>
data RQLMetadata
RQLMetadata :: !Maybe MetadataResourceVersion -> !RQLMetadataRequest -> RQLMetadata
[_rqlMetadataResourceVersion] :: RQLMetadata -> !Maybe MetadataResourceVersion
[_rqlMetadata] :: RQLMetadata -> !RQLMetadataRequest
runMetadataQuery :: (MonadIO m, MonadBaseControl IO m, MonadTrace m, MonadMetadataStorage m, MonadResolveSource m) => Environment -> Logger Hasura -> InstanceId -> UserInfo -> Manager -> ServerConfigCtx -> RebuildableSchemaCache -> RQLMetadata -> m (EncJSON, RebuildableSchemaCache)
queryModifiesMetadata :: RQLMetadataRequest -> Bool
runMetadataQueryM :: (MonadIO m, MonadBaseControl IO m, CacheRWM m, MonadTrace m, UserInfoM m, HasHttpManagerM m, MetadataM m, MonadMetadataStorageQueryAPI m, HasServerConfigCtx m, MonadReader r m, Has (Logger Hasura) r) => Environment -> MetadataResourceVersion -> RQLMetadataRequest -> m EncJSON
runMetadataQueryV1M :: forall m r. (MonadIO m, MonadBaseControl IO m, CacheRWM m, MonadTrace m, UserInfoM m, HasHttpManagerM m, MetadataM m, MonadMetadataStorageQueryAPI m, HasServerConfigCtx m, MonadReader r m, Has (Logger Hasura) r) => Environment -> MetadataResourceVersion -> RQLMetadataV1 -> m EncJSON
runMetadataQueryV2M :: (MonadIO m, CacheRWM m, MetadataM m, MonadMetadataStorageQueryAPI m, MonadReader r m, Has (Logger Hasura) r) => MetadataResourceVersion -> RQLMetadataV2 -> m EncJSON
instance GHC.Generics.Generic Hasura.Server.API.Metadata.RQLMetadataV2
instance GHC.Generics.Generic Hasura.Server.API.Metadata.RQLMetadataV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.RQLMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.RQLMetadataV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.RQLMetadataRequest
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.RQLMetadataV2

module Hasura.GraphQL.Transport.WebSocket.Server
newtype WSId
WSId :: UUID -> WSId
[unWSId] :: WSId -> UUID
mkUnsafeWSId :: UUID -> WSId

-- | Websocket message and other details
data MessageDetails
MessageDetails :: !SerializableBlob -> !Int64 -> MessageDetails
[_mdMessage] :: MessageDetails -> !SerializableBlob
[_mdMessageSize] :: MessageDetails -> !Int64
data WSEvent
EConnectionRequest :: WSEvent
EAccepted :: WSEvent
ERejected :: WSEvent
EMessageReceived :: !MessageDetails -> WSEvent
EMessageSent :: !MessageDetails -> WSEvent
EJwtExpired :: WSEvent
ECloseReceived :: WSEvent
ECloseSent :: !SerializableBlob -> WSEvent
EClosed :: WSEvent
data WSEventInfo
WSEventInfo :: !Maybe ServerMsgType -> !Maybe OperationId -> !Maybe OperationName -> !Maybe Double -> !Maybe Int64 -> !Maybe ParameterizedQueryHash -> WSEventInfo
[_wseiEventType] :: WSEventInfo -> !Maybe ServerMsgType
[_wseiOperationId] :: WSEventInfo -> !Maybe OperationId
[_wseiOperationName] :: WSEventInfo -> !Maybe OperationName
[_wseiQueryExecutionTime] :: WSEventInfo -> !Maybe Double
[_wseiResponseSize] :: WSEventInfo -> !Maybe Int64
[_wseiParameterizedQueryHash] :: WSEventInfo -> !Maybe ParameterizedQueryHash
data WSLog
WSLog :: !WSId -> !WSEvent -> !Maybe WSEventInfo -> WSLog
[_wslWebsocketId] :: WSLog -> !WSId
[_wslEvent] :: WSLog -> !WSEvent
[_wslMetadata] :: WSLog -> !Maybe WSEventInfo
class Monad m => MonadWSLog m

-- | Takes WS server log data and logs it logWSServer
logWSLog :: MonadWSLog m => Logger Hasura -> WSLog -> m ()
data WSQueueResponse
WSQueueResponse :: !ByteString -> !Maybe WSEventInfo -> WSQueueResponse
[_wsqrMessage] :: WSQueueResponse -> !ByteString

-- | extra metadata that we use for other actions, such as print log we
--   don't want to inlcude them into websocket message payload
[_wsqrEventInfo] :: WSQueueResponse -> !Maybe WSEventInfo
data WSConn a
WSConn :: !WSId -> !Logger Hasura -> !Connection -> !TQueue WSQueueResponse -> !a -> WSConn a
[_wcConnId] :: WSConn a -> !WSId
[_wcLogger] :: WSConn a -> !Logger Hasura
[_wcConnRaw] :: WSConn a -> !Connection
[_wcSendQ] :: WSConn a -> !TQueue WSQueueResponse
[_wcExtraData] :: WSConn a -> !a
getRawWebSocketConnection :: WSConn a -> Connection
getData :: WSConn a -> a
getWSId :: WSConn a -> WSId
closeConn :: WSConn a -> ByteString -> IO ()

-- | Closes a connection with code 1012, which means "Server is restarting"
--   good clients will implement a retry logic with a backoff of a few
--   seconds
forceConnReconnect :: MonadIO m => WSConn a -> ByteString -> m ()
closeConnWithCode :: WSConn a -> Word16 -> ByteString -> IO ()
sendMsg :: WSConn a -> WSQueueResponse -> IO ()
type ConnMap a = Map WSId (WSConn a)
data ServerStatus a
AcceptingConns :: !ConnMap a -> ServerStatus a
ShuttingDown :: ServerStatus a
data WSServer a
WSServer :: !Logger Hasura -> !TVar (ServerStatus a) -> WSServer a
[_wssLogger] :: WSServer a -> !Logger Hasura

-- | See e.g. createServerApp.onAccept for how we use STM to preserve
--   consistency
[_wssStatus] :: WSServer a -> !TVar (ServerStatus a)
createWSServer :: Logger Hasura -> STM (WSServer a)
closeAllWith :: (ByteString -> WSConn a -> IO ()) -> ByteString -> [(WSId, WSConn a)] -> IO ()

-- | Resets the current connections map to an empty one if the server is
--   running and returns the list of connections that were in the map
--   before flushing it.
flushConnMap :: TVar (ServerStatus a) -> STM [(WSId, WSConn a)]
data AcceptWith a
AcceptWith :: !a -> !AcceptRequest -> !WSConn a -> IO () -> !WSConn a -> IO () -> AcceptWith a
[_awData] :: AcceptWith a -> !a
[_awReq] :: AcceptWith a -> !AcceptRequest
[_awKeepAlive] :: AcceptWith a -> !WSConn a -> IO ()
[_awOnJwtExpiry] :: AcceptWith a -> !WSConn a -> IO ()

-- | These set of functions or message handlers is used by the server while
--   communicating with the client. They are particularly useful for the
--   case when the messages being sent to the client are different for each
--   of the sub-protocol(s) supported by the server.
type WSKeepAliveMessageAction a = WSConn a -> IO ()
type WSPostExecErrMessageAction a = WSConn a -> OperationId -> GQExecError -> IO ()
type WSOnErrorMessageAction a = WSConn a -> ConnErrMsg -> Maybe String -> IO ()
type WSCloseConnAction a = WSConn a -> OperationId -> String -> IO ()

-- | Used for specific actions within the <tt>onConn</tt> and
--   <tt>onMessage</tt> handlers
data WSActions a
WSActions :: !WSPostExecErrMessageAction a -> !WSOnErrorMessageAction a -> !WSCloseConnAction a -> !WSKeepAliveMessageAction a -> !DataMsg -> ServerMsg -> !AcceptRequest -> ![Value] -> Value -> WSActions a
[_wsaPostExecErrMessageAction] :: WSActions a -> !WSPostExecErrMessageAction a
[_wsaOnErrorMessageAction] :: WSActions a -> !WSOnErrorMessageAction a
[_wsaConnectionCloseAction] :: WSActions a -> !WSCloseConnAction a

-- | NOTE: keep alive action was made redundant because we need to send
--   this message after the connection has been successfully established
--   after <tt>connection_init</tt>
[_wsaKeepAliveAction] :: WSActions a -> !WSKeepAliveMessageAction a
[_wsaGetDataMessageType] :: WSActions a -> !DataMsg -> ServerMsg
[_wsaAcceptRequest] :: WSActions a -> !AcceptRequest
[_wsaErrorMsgFormat] :: WSActions a -> ![Value] -> Value

-- | to be used with <a>WSOnErrorMessageAction</a>
onClientMessageParseErrorText :: Maybe String

-- | to be used with <a>WSOnErrorMessageAction</a>
onConnInitErrorText :: Maybe String
type OnConnH m a = WSId -> RequestHead -> IpAddress -> WSActions a -> m (Either RejectRequest (AcceptWith a))
type OnCloseH m a = WSConn a -> m ()

-- | aka generalized <a>ServerApp</a> over <tt>m</tt>, which takes an
--   IPAddress
type HasuraServerApp m = IpAddress -> PendingConnection -> m ()

-- | NOTE: The types of <a>_hOnConn</a> and <a>_hOnMessage</a> were updated
--   from <a>OnConnH</a> and <tt>OnMessageH</tt> because we needed to pass
--   the subprotcol here to these methods to eventually get to
--   <a>OnConnH</a> and <tt>OnMessageH</tt>. Please see
--   <a>createServerApp</a> to get a better understanding of how these
--   handlers are used.
data WSHandlers m a
WSHandlers :: (WSId -> RequestHead -> IpAddress -> WSSubProtocol -> m (Either RejectRequest (AcceptWith a))) -> (WSConn a -> ByteString -> WSSubProtocol -> m ()) -> OnCloseH m a -> WSHandlers m a
[_hOnConn] :: WSHandlers m a -> WSId -> RequestHead -> IpAddress -> WSSubProtocol -> m (Either RejectRequest (AcceptWith a))
[_hOnMessage] :: WSHandlers m a -> WSConn a -> ByteString -> WSSubProtocol -> m ()
[_hOnClose] :: WSHandlers m a -> OnCloseH m a
createServerApp :: (MonadIO m, MonadBaseControl IO m, Forall (Pure m), MonadWSLog m) => WSConnectionInitTimeout -> WSServer a -> WSHandlers m a -> HasuraServerApp m
shutdown :: WSServer a -> IO ()
instance Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog m => Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog m => Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSLog
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Transport.WebSocket.Server.WSLog Hasura.Logging.Hasura
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSEventInfo
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Server.WSEventInfo
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSEventInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSEvent
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.MessageDetails
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.WebSocket.Server.WSId
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Server.WSId
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSId
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.MessageDetails
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSId


-- | Multiplexed subscription poller threads; see
--   <a>Hasura.GraphQL.Execute.Subscription</a> for details.
module Hasura.GraphQL.Execute.Subscription.Poll.Common
newtype SubscriberId
SubscriberId :: UUID -> SubscriberId
[unSubscriberId] :: SubscriberId -> UUID
newSubscriberId :: IO SubscriberId

-- | Allows a user of the live query subsystem (currently websocket
--   transport) to attach arbitrary metadata about a subscriber. This
--   information is available as part of Subscriber in
--   CohortExecutionDetails and can be logged by customizing in pollerlog
newtype SubscriberMetadata
SubscriberMetadata :: Value -> SubscriberMetadata
[unSubscriberMetadata] :: SubscriberMetadata -> Value
mkSubscriberMetadata :: WSId -> OperationId -> Maybe OperationName -> RequestId -> SubscriberMetadata
data Subscriber
Subscriber :: !SubscriberId -> !SubscriberMetadata -> !RequestId -> !Maybe OperationName -> !OnChange -> Subscriber
[_sId] :: Subscriber -> !SubscriberId
[_sMetadata] :: Subscriber -> !SubscriberMetadata
[_sRequestId] :: Subscriber -> !RequestId
[_sOperationName] :: Subscriber -> !Maybe OperationName
[_sOnChangeCallback] :: Subscriber -> !OnChange

-- | Subscription onChange metadata, used for adding more extra analytics
--   data
data SubscriptionMetadata
SubscriptionMetadata :: !DiffTime -> SubscriptionMetadata
[_sqmExecutionTime] :: SubscriptionMetadata -> !DiffTime
data SubscriptionResponse
SubscriptionResponse :: !ByteString -> !DiffTime -> SubscriptionResponse
[_lqrPayload] :: SubscriptionResponse -> !ByteString
[_lqrExecutionTime] :: SubscriptionResponse -> !DiffTime
type SubscriptionGQResponse = GQResult SubscriptionResponse
type OnChange = SubscriptionGQResponse -> IO ()
type SubscriberMap = TMap SubscriberId Subscriber

-- | A batched group of <a>Subscriber</a>s who are not only listening to
--   the same query but also have identical session and query variables.
--   Each result pushed to a <a>Cohort</a> is forwarded along to each of
--   its <a>Subscriber</a>s.
--   
--   In SQL, each <a>Cohort</a> corresponds to a single row in the
--   laterally-joined <tt>_subs</tt> table (and therefore a single row in
--   the query result).
--   
--   See also <a>CohortMap</a>.
data Cohort streamCursorVars
Cohort :: !CohortId -> !TVar (Maybe ResponseHash) -> !SubscriberMap -> !SubscriberMap -> !streamCursorVars -> Cohort streamCursorVars

-- | a unique identifier used to identify the cohort in the generated query
[_cCohortId] :: Cohort streamCursorVars -> !CohortId

-- | a hash of the previous query result, if any, used to determine if we
--   need to push an updated result to the subscribers or not
[_cPreviousResponse] :: Cohort streamCursorVars -> !TVar (Maybe ResponseHash)

-- | the subscribers we’ve already pushed a result to; we push new results
--   to them iff the response changes
[_cExistingSubscribers] :: Cohort streamCursorVars -> !SubscriberMap

-- | subscribers we haven’t yet pushed any results to; we push results to
--   them regardless if the result changed, then merge them in the map of
--   existing subscribers
[_cNewSubscribers] :: Cohort streamCursorVars -> !SubscriberMap

-- | a mutable type which holds the latest value of the subscription stream
--   cursor. In case of live query subscription, this field is ignored by
--   setting <tt>streamCursorVars</tt> to <tt>()</tt>
[_cStreamCursorVariables] :: Cohort streamCursorVars -> !streamCursorVars

-- | The <tt>BatchId</tt> is a number based ID to uniquely identify a batch
--   in a single poll and it's used to identify the batch to which a cohort
--   belongs to.
newtype BatchId
BatchId :: Int -> BatchId
[_unBatchId] :: BatchId -> Int

-- | A hash used to determine if the result changed without having to keep
--   the entire result in memory. Using a cryptographic hash ensures that a
--   hash collision is almost impossible: with 256 bits, even if a
--   subscription changes once per second for an entire year, the
--   probability of a hash collision is ~4.294417×10-63. See Note [Blake2b
--   faster than SHA-256].
newtype ResponseHash
ResponseHash :: Digest Blake2b_256 -> ResponseHash
[unResponseHash] :: ResponseHash -> Digest Blake2b_256
mkRespHash :: ByteString -> ResponseHash

-- | A key we use to determine if two <a>Subscriber</a>s belong in the same
--   <a>Cohort</a> (assuming they already meet the criteria to be in the
--   same <a>Poller</a>). Note the distinction between this and
--   <a>CohortId</a>; the latter is a completely synthetic key used only to
--   identify the cohort in the generated SQL query.
type CohortKey = CohortVariables

-- | This has the invariant, maintained in <tt>removeLiveQuery</tt>, that
--   it contains no <a>Cohort</a> with zero total (existing + new)
--   subscribers.
type CohortMap streamCursor = TMap CohortKey (Cohort streamCursor)
dumpCohortMap :: CohortMap streamCursor -> IO Value
data CohortSnapshot
CohortSnapshot :: !CohortVariables -> !TVar (Maybe ResponseHash) -> ![Subscriber] -> ![Subscriber] -> CohortSnapshot
[_csVariables] :: CohortSnapshot -> !CohortVariables
[_csPreviousResponse] :: CohortSnapshot -> !TVar (Maybe ResponseHash)
[_csExistingSubscribers] :: CohortSnapshot -> ![Subscriber]
[_csNewSubscribers] :: CohortSnapshot -> ![Subscriber]

-- | A unique, multiplexed query. Each <a>Poller</a> has its own polling
--   thread that periodically polls Postgres and pushes results to each of
--   its listening <a>Cohort</a>s.
--   
--   In SQL, an <a>Poller</a> corresponds to a single, multiplexed query,
--   though in practice, <a>Poller</a>s with large numbers of
--   <a>Cohort</a>s are batched into multiple concurrent queries for
--   performance reasons.
data Poller streamCursor
Poller :: !CohortMap streamCursor -> !TMVar PollerIOState -> Poller streamCursor
[_pCohorts] :: Poller streamCursor -> !CohortMap streamCursor

-- | This is in a separate <a>TMVar</a> because it’s important that we are
--   able to construct <a>Poller</a> values in <a>STM</a> --- we need the
--   insertion into the <a>PollerMap</a> to be atomic to ensure that we
--   don’t accidentally create two for the same query due to a race.
--   However, we can’t spawn the worker thread or create the metrics store
--   in <a>STM</a>, so we insert it into the <a>Poller</a> only after we’re
--   certain we won’t create any duplicates.
--   
--   This var is "write once", moving monotonically from empty to full.
--   TODO this could probably be tightened up to something like 'STM
--   PollerIOState'
[_pIOState] :: Poller streamCursor -> !TMVar PollerIOState
data PollerIOState
PollerIOState :: !Thread -> !PollerId -> PollerIOState

-- | a handle on the poller’s worker thread that can be used to <a>stop</a>
--   it if all its cohorts stop listening
[_pThread] :: PollerIOState -> !Thread
[_pId] :: PollerIOState -> !PollerId
data PollerKey
PollerKey :: !SourceName -> !RoleName -> !Text -> PollerKey
[_lgSource] :: PollerKey -> !SourceName
[_lgRole] :: PollerKey -> !RoleName
[_lgQuery] :: PollerKey -> !Text
type PollerMap streamCursor = Map PollerKey (Poller streamCursor)
dumpPollerMap :: Bool -> PollerMap streamCursor -> IO Value

-- | An ID to track unique <a>Poller</a>s, so that we can gather metrics
--   about each poller
newtype PollerId
PollerId :: UUID -> PollerId
[unPollerId] :: PollerId -> UUID
data SubscriberExecutionDetails
SubscriberExecutionDetails :: !SubscriberId -> !SubscriberMetadata -> SubscriberExecutionDetails
[_sedSubscriberId] :: SubscriberExecutionDetails -> !SubscriberId
[_sedSubscriberMetadata] :: SubscriberExecutionDetails -> !SubscriberMetadata

-- | Execution information related to a cohort on a poll cycle
data CohortExecutionDetails
CohortExecutionDetails :: !CohortId -> !CohortVariables -> !Maybe Int -> ![SubscriberExecutionDetails] -> ![SubscriberExecutionDetails] -> !BatchId -> CohortExecutionDetails
[_cedCohortId] :: CohortExecutionDetails -> !CohortId
[_cedVariables] :: CohortExecutionDetails -> !CohortVariables

-- | Nothing in case of an error
[_cedResponseSize] :: CohortExecutionDetails -> !Maybe Int

-- | The response on this cycle has been pushed to these above subscribers
--   New subscribers (those which haven't been around during the previous
--   poll cycle) will always be part of this
[_cedPushedTo] :: CohortExecutionDetails -> ![SubscriberExecutionDetails]

-- | The response on this cycle has *not* been pushed to these above
--   subscribers. This would when the response hasn't changed from the
--   previous polled cycle
[_cedIgnored] :: CohortExecutionDetails -> ![SubscriberExecutionDetails]
[_cedBatchId] :: CohortExecutionDetails -> !BatchId

-- | Execution information related to a single batched execution
data BatchExecutionDetails
BatchExecutionDetails :: !DiffTime -> !DiffTime -> !BatchId -> ![CohortExecutionDetails] -> !Maybe Int -> BatchExecutionDetails

-- | postgres execution time of each batch
[_bedPgExecutionTime] :: BatchExecutionDetails -> !DiffTime

-- | time to taken to push to all cohorts belonging to this batch
[_bedPushTime] :: BatchExecutionDetails -> !DiffTime

-- | id of the batch
[_bedBatchId] :: BatchExecutionDetails -> !BatchId

-- | execution details of the cohorts belonging to this batch
[_bedCohorts] :: BatchExecutionDetails -> ![CohortExecutionDetails]
[_bedBatchResponseSizeBytes] :: BatchExecutionDetails -> !Maybe Int

-- | see Note [Minimal LiveQuery Poller Log]
batchExecutionDetailMinimal :: BatchExecutionDetails -> Value
data PollDetails
PollDetails :: !PollerId -> !Text -> !DiffTime -> ![BatchExecutionDetails] -> !DiffTime -> !SubscriptionsOptions -> !SourceName -> !RoleName -> !ParameterizedQueryHash -> PollDetails

-- | the unique ID (basically a thread that run as a <a>Poller</a>) for the
--   <a>Poller</a>
[_pdPollerId] :: PollDetails -> !PollerId

-- | the multiplexed SQL query to be run against the database with all the
--   variables together
[_pdGeneratedSql] :: PollDetails -> !Text

-- | the time taken to get a snapshot of cohorts from our
--   <tt>SubscriptionsState</tt> data structure
[_pdSnapshotTime] :: PollDetails -> !DiffTime

-- | list of execution batches and their details
[_pdBatches] :: PollDetails -> ![BatchExecutionDetails]

-- | total time spent on a poll cycle
[_pdTotalTime] :: PollDetails -> !DiffTime
[_pdLiveQueryOptions] :: PollDetails -> !SubscriptionsOptions
[_pdSource] :: PollDetails -> !SourceName
[_pdRole] :: PollDetails -> !RoleName
[_pdParameterizedQueryHash] :: PollDetails -> !ParameterizedQueryHash

-- | see Note [Minimal LiveQuery Poller Log]
pollDetailMinimal :: PollDetails -> Value
type SubscriptionPostPollHook = PollDetails -> IO ()
defaultSubscriptionPostPollHook :: Logger Hasura -> SubscriptionPostPollHook
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberMetadata
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberMetadata
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchId
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.ResponseHash
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.ResponseHash
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberExecutionDetails
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberExecutionDetails
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.CohortExecutionDetails
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.CohortExecutionDetails
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchExecutionDetails
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchExecutionDetails
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetails
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetails
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetails Hasura.Logging.Hasura
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.ResponseHash

module Hasura.GraphQL.Execute.Subscription.Types
class SubscriptionTypes (s :: SubscriptionType) where {
    type family Cohort s :: Type;
    type family CohortSnapshot s :: Type;
    type family CohortMap s :: Type;
    type family Poller s :: Type;
    type family PollerMap s :: Type;
}
instance Hasura.GraphQL.Execute.Subscription.Types.SubscriptionTypes 'Hasura.RQL.Types.Subscription.LiveQuery
instance Hasura.GraphQL.Execute.Subscription.Types.SubscriptionTypes 'Hasura.RQL.Types.Subscription.Streaming

module Hasura.GraphQL.Execute.Subscription.Poll.StreamingQuery
mergeOldAndNewCursorValues :: CursorVariableValues -> CursorVariableValues -> CursorVariableValues
pushResultToCohort :: GQResult ByteString -> Maybe ResponseHash -> SubscriptionMetadata -> CursorVariableValues -> Name -> (CohortSnapshot 'Streaming, Cohort 'Streaming) -> IO ([SubscriberExecutionDetails], [SubscriberExecutionDetails])

-- | A single iteration of the streaming query polling loop. Invocations on
--   the same mutable objects may race.
pollStreamingQuery :: forall b. BackendTransport b => PollerId -> SubscriptionsOptions -> (SourceName, SourceConfig b) -> RoleName -> ParameterizedQueryHash -> MultiplexedQuery b -> CohortMap 'Streaming -> Name -> SubscriptionPostPollHook -> Maybe (IO ()) -> IO ()


-- | Multiplexed subscription poller threads; see
--   <a>Hasura.GraphQL.Execute.Subscription</a> for details.
module Hasura.GraphQL.Execute.Subscription.Poll.LiveQuery
pushResultToCohort :: GQResult ByteString -> Maybe ResponseHash -> SubscriptionMetadata -> CohortSnapshot 'LiveQuery -> IO ([SubscriberExecutionDetails], [SubscriberExecutionDetails])

-- | Where the magic happens: the top-level action run periodically by each
--   active <a>Poller</a>. This needs to be async exception safe.
pollLiveQuery :: forall b. BackendTransport b => PollerId -> SubscriptionsOptions -> (SourceName, SourceConfig b) -> RoleName -> ParameterizedQueryHash -> MultiplexedQuery b -> CohortMap 'LiveQuery -> SubscriptionPostPollHook -> IO ()


-- | Multiplexed subscription poller threads; see
--   <a>Hasura.GraphQL.Execute.Subscription</a> for details.
module Hasura.GraphQL.Execute.Subscription.Poll


-- | Top-level management of subscription poller threads. The
--   implementation of the polling itself is in
--   <a>Hasura.GraphQL.Execute.Subscription.Poll</a>. See
--   <a>Hasura.GraphQL.Execute.Subscription</a> for high-level details.
module Hasura.GraphQL.Execute.Subscription.State

-- | The top-level datatype that holds the state for all active
--   subscriptions.
--   
--   NOTE!: This must be kept consistent with a websocket connection's
--   <tt>OperationMap</tt>, in <tt>onClose</tt> and <tt>onStart</tt>.
data SubscriptionsState
SubscriptionsState :: LiveQueriesOptions -> StreamQueriesOptions -> PollerMap () -> PollerMap (TVar CursorVariableValues) -> SubscriptionPostPollHook -> AsyncActionSubscriptionState -> SubscriptionsState
[_ssLiveQueryOptions] :: SubscriptionsState -> LiveQueriesOptions
[_ssStreamQueryOptions] :: SubscriptionsState -> StreamQueriesOptions
[_ssLiveQueryMap] :: SubscriptionsState -> PollerMap ()
[_ssStreamQueryMap] :: SubscriptionsState -> PollerMap (TVar CursorVariableValues)

-- | A hook function which is run after each fetch cycle
[_ssPostPollHook] :: SubscriptionsState -> SubscriptionPostPollHook
[_ssAsyncActions] :: SubscriptionsState -> AsyncActionSubscriptionState
initSubscriptionsState :: LiveQueriesOptions -> StreamQueriesOptions -> SubscriptionPostPollHook -> IO SubscriptionsState
dumpSubscriptionsState :: Bool -> SubscriptionsState -> IO Value

-- | SubscriberDetails contains the data required to locate a subscriber in
--   the correct cohort within the correct poller in the operation map.
data SubscriberDetails a
SubscriberDetails :: !PollerKey -> !a -> !SubscriberId -> SubscriberDetails a
[_sdPoller] :: SubscriberDetails a -> !PollerKey
[_sdCohort] :: SubscriberDetails a -> !a
[_sdSubscriber] :: SubscriberDetails a -> !SubscriberId
type LiveQuerySubscriberDetails = SubscriberDetails CohortKey

-- | The <a>CohortKey</a> contains the variables with which the
--   subscription was started and which will remain unchanged. The second
--   type contains the mutable reference through which we can get the
--   latest value of the cursor and using both the <a>CohortKey</a> and the
--   latest cursor value, we locate the subscriber in the operation map to
--   find its details and then stop it.
type StreamingSubscriberDetails = SubscriberDetails (CohortKey, TVar CursorVariableValues)

-- | <a>findPollerForSubscriber</a> places a subscriber in the correct
--   poller. If the poller doesn't exist then we create one otherwise we
--   return the existing one.
findPollerForSubscriber :: Subscriber -> CohortId -> PollerMap streamCursorVars -> PollerKey -> CohortKey -> (Subscriber -> Cohort streamCursorVars -> STM streamCursorVars) -> (Subscriber -> CohortId -> Poller streamCursorVars -> STM streamCursorVars) -> STM (Maybe (Poller streamCursorVars), streamCursorVars)

-- | Fork a thread handling a regular (live query) subscription
addLiveQuery :: forall b. BackendTransport b => Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriberMetadata -> SubscriptionsState -> SourceName -> ParameterizedQueryHash -> Maybe OperationName -> RequestId -> SubscriptionQueryPlan b (MultiplexedQuery b) -> OnChange -> IO LiveQuerySubscriberDetails

-- | Fork a thread handling a streaming subscription
addStreamSubscriptionQuery :: forall b. BackendTransport b => Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriberMetadata -> SubscriptionsState -> SourceName -> ParameterizedQueryHash -> Maybe OperationName -> RequestId -> Name -> SubscriptionQueryPlan b (MultiplexedQuery b) -> OnChange -> IO StreamingSubscriberDetails
removeLiveQuery :: Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriptionsState -> LiveQuerySubscriberDetails -> IO ()
removeStreamingQuery :: Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriptionsState -> StreamingSubscriberDetails -> IO ()

-- | An async action query whose relationships are refered to table in a
--   source. We need to generate an SQL statement with the action response
--   and execute it in the source database so as to fetch response joined
--   with relationship rows. For more details see Note [Resolving async
--   action query]
data LiveAsyncActionQueryOnSource
LiveAsyncActionQueryOnSource :: !LiveQuerySubscriberDetails -> !ActionLogResponseMap -> !LiveQuerySubscriberDetails -> ActionLogResponseMap -> IO (Maybe LiveQuerySubscriberDetails) -> LiveAsyncActionQueryOnSource
[_laaqpCurrentLqId] :: LiveAsyncActionQueryOnSource -> !LiveQuerySubscriberDetails
[_laaqpPrevActionLogMap] :: LiveAsyncActionQueryOnSource -> !ActionLogResponseMap

-- | An IO action to restart the live query poller with updated action log
--   responses fetched from metadata storage Restarting a live query
--   re-generates the SQL statement with new action log responses to send
--   latest action response to the client.
[_laaqpRestartLq] :: LiveAsyncActionQueryOnSource -> !LiveQuerySubscriberDetails -> ActionLogResponseMap -> IO (Maybe LiveQuerySubscriberDetails)
data LiveAsyncActionQueryWithNoRelationships
LiveAsyncActionQueryWithNoRelationships :: !ActionLogResponseMap -> IO () -> !IO () -> LiveAsyncActionQueryWithNoRelationships

-- | An IO action to send response to the websocket client
[_laaqwnrSendResponse] :: LiveAsyncActionQueryWithNoRelationships -> !ActionLogResponseMap -> IO ()

-- | An IO action to send "completed" message to the websocket client
[_laaqwnrSendCompleted] :: LiveAsyncActionQueryWithNoRelationships -> !IO ()
data LiveAsyncActionQuery
LAAQNoRelationships :: !LiveAsyncActionQueryWithNoRelationships -> LiveAsyncActionQuery
LAAQOnSourceDB :: !LiveAsyncActionQueryOnSource -> LiveAsyncActionQuery
data AsyncActionQueryLive
AsyncActionQueryLive :: !NonEmpty ActionId -> !QErr -> IO () -> !LiveAsyncActionQuery -> AsyncActionQueryLive
[_aaqlActionIds] :: AsyncActionQueryLive -> !NonEmpty ActionId

-- | An IO action to send error message (in case of any exception) to the
--   websocket client
[_aaqlOnException] :: AsyncActionQueryLive -> !QErr -> IO ()
[_aaqlLiveExecution] :: AsyncActionQueryLive -> !LiveAsyncActionQuery

-- | A share-able state map which stores an async action live query with
--   it's subscription operation id
type AsyncActionSubscriptionState = TMap OperationId AsyncActionQueryLive
addAsyncActionLiveQuery :: AsyncActionSubscriptionState -> OperationId -> NonEmpty ActionId -> (QErr -> IO ()) -> LiveAsyncActionQuery -> IO ()
removeAsyncActionLiveQuery :: AsyncActionSubscriptionState -> OperationId -> IO ()
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Execute.Subscription.State.SubscriberDetails a)


-- | Module related to async action query subscriptions
module Hasura.GraphQL.Execute.Action.Subscription

-- | A forever running thread which processes async action subscriptions.
--   See Note [Async action subscriptions]
asyncActionSubscriptionsProcessor :: (MonadIO m, MonadMetadataStorage (MetadataStorageT m)) => AsyncActionSubscriptionState -> m void

module Hasura.GraphQL.Execute.Common

-- | Typeclass representing safety checks (if any) that need to be
--   performed before a GraphQL query should be allowed to be executed. In
--   OSS, the safety check is to check in the query is in the allow list.
--   
--   the <a>executeIntrospection</a> function has different implementations
--   in OSS and Pro. In Pro, the GraphQL schema introspection can be
--   disabled for specified roles and in OSS there is no restrictions.
--   
--   | TODO (from master): Limitation: This parses the query, which is not
--   ideal if we already have the query cached. The parsing happens
--   unnecessary. But getting this to either return a plan or parse was
--   tricky and complicated.
class Monad m => MonadGQLExecutionCheck m
checkGQLExecution :: MonadGQLExecutionCheck m => UserInfo -> ([Header], IpAddress) -> Bool -> SchemaCache -> GQLReqUnparsed -> RequestId -> m (Either QErr GQLReqParsed)
executeIntrospection :: MonadGQLExecutionCheck m => UserInfo -> Value -> SetGraphqlIntrospectionOptions -> m (Either QErr ExecutionStep)
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Hasura.Tracing.TraceT m)
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Hasura.Metadata.Class.MetadataStorageT m)

module Hasura.GraphQL.Execute.Query
parseGraphQLQuery :: MonadError QErr m => GQLContext -> [VariableDefinition] -> Maybe (HashMap Name Value) -> [Directive Name] -> SelectionSet NoFragments Name -> m (RootFieldMap (QueryRootField UnpreparedValue), [Directive Variable], SelectionSet NoFragments Variable)

-- | Construct an <a>ExecutionPlan</a> from a <a>SelectionSet</a>.
convertQuerySelSet :: forall m. (MonadError QErr m, MonadGQLExecutionCheck m, MonadQueryTags m) => Environment -> Logger Hasura -> GQLContext -> UserInfo -> Manager -> RequestHeaders -> [Directive Name] -> SelectionSet NoFragments Name -> [VariableDefinition] -> GQLReqUnparsed -> SetGraphqlIntrospectionOptions -> RequestId -> Maybe Name -> m (ExecutionPlan, [QueryRootField UnpreparedValue], DirectiveMap, ParameterizedQueryHash)

module Hasura.GraphQL.Execute.Mutation
convertMutationAction :: (MonadIO m, MonadError QErr m, MonadMetadataStorage (MetadataStorageT m)) => Environment -> Logger Hasura -> UserInfo -> Manager -> RequestHeaders -> Maybe GQLQueryText -> ActionMutation Void -> m ActionExecutionPlan
convertMutationSelectionSet :: forall m. (MonadTrace m, MonadIO m, MonadError QErr m, MonadMetadataStorage (MetadataStorageT m), MonadGQLExecutionCheck m, MonadQueryTags m) => Environment -> Logger Hasura -> GQLContext -> SQLGenCtx -> UserInfo -> Manager -> RequestHeaders -> [Directive Name] -> SelectionSet NoFragments Name -> [VariableDefinition] -> GQLReqUnparsed -> SetGraphqlIntrospectionOptions -> RequestId -> Maybe Name -> m (ExecutionPlan, ParameterizedQueryHash)

module Hasura.GraphQL.Execute

-- | Execution context
data ExecutionCtx
ExecutionCtx :: Logger Hasura -> SQLGenCtx -> SchemaCache -> SchemaCacheVer -> Manager -> Bool -> ReadOnlyMode -> PrometheusMetrics -> ExecutionCtx
[_ecxLogger] :: ExecutionCtx -> Logger Hasura
[_ecxSqlGenCtx] :: ExecutionCtx -> SQLGenCtx
[_ecxSchemaCache] :: ExecutionCtx -> SchemaCache
[_ecxSchemaCacheVer] :: ExecutionCtx -> SchemaCacheVer
[_ecxHttpManager] :: ExecutionCtx -> Manager
[_ecxEnableAllowList] :: ExecutionCtx -> Bool
[_ecxReadOnlyMode] :: ExecutionCtx -> ReadOnlyMode
[_ecxPrometheusMetrics] :: ExecutionCtx -> PrometheusMetrics

-- | Construct a single step of an execution plan.
makeGQLContext :: UserInfo -> SchemaCache -> GraphQLQueryType -> GQLContext
data ResolvedExecutionPlan

-- | query execution; remote schemas and introspection possible
QueryExecutionPlan :: ExecutionPlan -> [QueryRootField UnpreparedValue] -> DirectiveMap -> ResolvedExecutionPlan

-- | mutation execution; only __typename introspection supported
MutationExecutionPlan :: ExecutionPlan -> ResolvedExecutionPlan

-- | either action query or live query execution; remote schemas and
--   introspection not supported
SubscriptionExecutionPlan :: SubscriptionExecution -> ResolvedExecutionPlan
newtype MultiplexedSubscriptionQueryPlan (b :: BackendType)
MultiplexedSubscriptionQueryPlan :: SubscriptionQueryPlan b (MultiplexedQuery b) -> MultiplexedSubscriptionQueryPlan (b :: BackendType)
newtype SubscriptionQueryPlan
SubscriptionQueryPlan :: AnyBackend MultiplexedSubscriptionQueryPlan -> SubscriptionQueryPlan
data SourceSubscription
SSLivequery :: !HashSet ActionId -> !ActionLogResponseMap -> ExceptT QErr IO (SourceName, SubscriptionQueryPlan) -> SourceSubscription
SSStreaming :: !RootFieldAlias -> !(SourceName, SubscriptionQueryPlan) -> SourceSubscription

-- | The comprehensive subscription plan. We only support either 1. Fields
--   with only async action queries with no associated relationships or 2.
--   Source database query fields from same source and also can be mixed
--   with async action query fields whose relationships are defined to
--   tables in the source
data SubscriptionExecution
SEAsyncActionsWithNoRelationships :: !RootFieldMap (ActionId, ActionLogResponse -> Either QErr EncJSON) -> SubscriptionExecution
SEOnSourceDB :: !SourceSubscription -> SubscriptionExecution
buildSubscriptionPlan :: forall m. (MonadError QErr m, MonadQueryTags m, MonadIO m, MonadBaseControl IO m) => UserInfo -> RootFieldMap (QueryRootField UnpreparedValue) -> ParameterizedQueryHash -> m SubscriptionExecution
checkQueryInAllowlist :: MonadError QErr m => Bool -> AllowlistMode -> UserInfo -> GQLReqParsed -> SchemaCache -> m ()

-- | Construct a <a>ResolvedExecutionPlan</a> from a <a>GQLReqParsed</a>
--   and a bunch of metadata.
getResolvedExecPlan :: forall m. (MonadError QErr m, MonadMetadataStorage (MetadataStorageT m), MonadIO m, MonadBaseControl IO m, MonadTrace m, MonadGQLExecutionCheck m, MonadQueryTags m) => Environment -> Logger Hasura -> UserInfo -> SQLGenCtx -> ReadOnlyMode -> SchemaCache -> SchemaCacheVer -> GraphQLQueryType -> Manager -> [Header] -> GQLReqUnparsed -> SingleOperation -> Maybe Name -> RequestId -> m (ParameterizedQueryHash, ResolvedExecutionPlan)

-- | Even when directive _multiple_top_level_fields is given, we can't
--   allow fields within differently-aliased namespaces. This is because
--   the namespace is added to the result by wrapping the bytestring
--   response we get back from the DB.
isSingleNamespace :: RootFieldMap a -> Bool

module Hasura.GraphQL.Transport.WebSocket.Types
newtype WsHeaders
WsHeaders :: [Header] -> WsHeaders
[unWsHeaders] :: WsHeaders -> [Header]
data ErrRespType
ERTLegacy :: ErrRespType
ERTGraphqlCompliant :: ErrRespType
data WSConnState

-- | headers and IP address from the client for websockets
CSNotInitialised :: !WsHeaders -> !IpAddress -> WSConnState
CSInitError :: !Text -> WSConnState
CSInitialised :: !WsClientState -> WSConnState
data WsClientState
WsClientState :: !UserInfo -> !Maybe UTCTime -> ![Header] -> !IpAddress -> WsClientState

-- | the <a>UserInfo</a> required to execute the GraphQL query
[wscsUserInfo] :: WsClientState -> !UserInfo

-- | the JWT/token expiry time, if any
[wscsTokenExpTime] :: WsClientState -> !Maybe UTCTime

-- | headers from the client (in conn params) to forward to the remote
--   schema
[wscsReqHeaders] :: WsClientState -> ![Header]

-- | IP address required for <tt>MonadGQLAuthorization</tt>
[wscsIpAddress] :: WsClientState -> !IpAddress
data WSConnData
WSConnData :: !TVar WSConnState -> !OperationMap -> !ErrRespType -> !GraphQLQueryType -> WSConnData
[_wscUser] :: WSConnData -> !TVar WSConnState
[_wscOpMap] :: WSConnData -> !OperationMap
[_wscErrRespTy] :: WSConnData -> !ErrRespType
[_wscAPIType] :: WSConnData -> !GraphQLQueryType
data WSServerEnv
WSServerEnv :: !Logger Hasura -> !SubscriptionsState -> !IO (SchemaCache, SchemaCacheVer) -> !Manager -> !CorsPolicy -> !SQLGenCtx -> ReadOnlyMode -> !WSServer -> !Bool -> !KeepAliveDelay -> !ServerMetrics -> !PrometheusMetrics -> WSServerEnv
[_wseLogger] :: WSServerEnv -> !Logger Hasura
[_wseSubscriptionState] :: WSServerEnv -> !SubscriptionsState

-- | an action that always returns the latest version of the schema cache.
--   See <tt>SchemaCacheRef</tt>.
[_wseGCtxMap] :: WSServerEnv -> !IO (SchemaCache, SchemaCacheVer)
[_wseHManager] :: WSServerEnv -> !Manager
[_wseCorsPolicy] :: WSServerEnv -> !CorsPolicy
[_wseSQLCtx] :: WSServerEnv -> !SQLGenCtx
[_wseReadOnlyMode] :: WSServerEnv -> ReadOnlyMode
[_wseServer] :: WSServerEnv -> !WSServer
[_wseEnableAllowlist] :: WSServerEnv -> !Bool
[_wseKeepAliveDelay] :: WSServerEnv -> !KeepAliveDelay
[_wseServerMetrics] :: WSServerEnv -> !ServerMetrics
[_wsePrometheusMetrics] :: WSServerEnv -> !PrometheusMetrics
data SubscriberType
LiveQuerySubscriber :: !LiveQuerySubscriberDetails -> SubscriberType
StreamingQuerySubscriber :: !StreamingSubscriberDetails -> SubscriberType
type OperationMap = Map OperationId (SubscriberType, Maybe OperationName)
type WSServer = WSServer WSConnData
type WSConn = WSConn WSConnData
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Types.WsHeaders
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.WsHeaders
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.ErrRespType
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.WsClientState
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.WSConnState


-- | Execution of GraphQL queries over HTTP transport
module Hasura.GraphQL.Transport.HTTP
data QueryCacheKey
QueryCacheKey :: !GQLReqParsed -> !RoleName -> !SessionVariables -> QueryCacheKey
[qckQueryString] :: QueryCacheKey -> !GQLReqParsed
[qckUserRole] :: QueryCacheKey -> !RoleName
[qckSession] :: QueryCacheKey -> !SessionVariables
type CacheStoreResponse = Either CacheStoreFailure CacheStoreSuccess
data CacheStoreSuccess
CacheStoreSkipped :: CacheStoreSuccess
CacheStoreHit :: CacheStoreSuccess
data CacheStoreFailure
CacheStoreLimitReached :: CacheStoreFailure
CacheStoreNotEnoughCapacity :: CacheStoreFailure
CacheStoreBackendError :: String -> CacheStoreFailure
class Monad m => MonadExecuteQuery m

-- | This method does two things: it looks up a query result in the
--   server-side cache, if a cache is used, and it additionally returns
--   HTTP headers that can instruct a client how long a response can be
--   cached locally (i.e. client-side).
cacheLookup :: MonadExecuteQuery m => [RemoteSchemaInfo] -> [ActionsInfo] -> QueryCacheKey -> Maybe CachedDirective -> TraceT (ExceptT QErr m) (ResponseHeaders, Maybe EncJSON)

-- | Store a json response for a query that we've executed in the cache.
--   Note that, as part of this, <a>cacheStore</a> has to decide whether
--   the response is cacheable. A very similar decision is also made in
--   <a>cacheLookup</a>, since it has to construct corresponding
--   cache-enabling headers that are sent to the client. But note that the
--   HTTP headers influence client-side caching, whereas <a>cacheStore</a>
--   changes the server-side cache.
cacheStore :: MonadExecuteQuery m => QueryCacheKey -> Maybe CachedDirective -> EncJSON -> TraceT (ExceptT QErr m) CacheStoreResponse

-- | This method does two things: it looks up a query result in the
--   server-side cache, if a cache is used, and it additionally returns
--   HTTP headers that can instruct a client how long a response can be
--   cached locally (i.e. client-side).
cacheLookup :: (MonadExecuteQuery m, m ~ t n, MonadTrans t, MonadExecuteQuery n) => [RemoteSchemaInfo] -> [ActionsInfo] -> QueryCacheKey -> Maybe CachedDirective -> TraceT (ExceptT QErr m) (ResponseHeaders, Maybe EncJSON)

-- | Store a json response for a query that we've executed in the cache.
--   Note that, as part of this, <a>cacheStore</a> has to decide whether
--   the response is cacheable. A very similar decision is also made in
--   <a>cacheLookup</a>, since it has to construct corresponding
--   cache-enabling headers that are sent to the client. But note that the
--   HTTP headers influence client-side caching, whereas <a>cacheStore</a>
--   changes the server-side cache.
cacheStore :: (MonadExecuteQuery m, m ~ t n, MonadTrans t, MonadExecuteQuery n) => QueryCacheKey -> Maybe CachedDirective -> EncJSON -> TraceT (ExceptT QErr m) CacheStoreResponse

-- | A partial response, e.g. from a remote schema call or postgres
--   postgres query, which we'll assemble into the final response for the
--   client. It is annotated with timing metadata.
data AnnotatedResponsePart
AnnotatedResponsePart :: DiffTime -> Locality -> EncJSON -> ResponseHeaders -> AnnotatedResponsePart
[arpTimeIO] :: AnnotatedResponsePart -> DiffTime
[arpLocality] :: AnnotatedResponsePart -> Locality
[arpResponse] :: AnnotatedResponsePart -> EncJSON
[arpHeaders] :: AnnotatedResponsePart -> ResponseHeaders

-- | A full response, annotated with timing metadata.
data AnnotatedResponse
AnnotatedResponse :: QueryType -> DiffTime -> Locality -> HttpResponse (Maybe GQResponse, EncJSON) -> AnnotatedResponse
[arQueryType] :: AnnotatedResponse -> QueryType
[arTimeIO] :: AnnotatedResponse -> DiffTime
[arLocality] :: AnnotatedResponse -> Locality
[arResponse] :: AnnotatedResponse -> HttpResponse (Maybe GQResponse, EncJSON)

-- | Merge response parts into a full response.
buildResponseFromParts :: MonadError QErr m => QueryType -> Either (Either GQExecError QErr) (RootFieldMap AnnotatedResponsePart) -> ResponseHeaders -> m AnnotatedResponse
buildResponse :: MonadError QErr m => QueryType -> Either (Either GQExecError QErr) a -> (a -> AnnotatedResponse) -> m AnnotatedResponse

-- | A predicate on session variables. The <a>Monoid</a> instance makes it
--   simple to combine several predicates disjunctively. | The definition
--   includes <a>Maybe</a> which allows us to short-circuit calls like
--   <tt>mempty &lt;&gt; m</tt> and <tt>m &lt;&gt; mempty</tt>, which
--   otherwise might build up long repeated chains of calls to <tt>_ _
--   -&gt; False</tt>.
newtype SessVarPred
SessVarPred :: Maybe (SessionVariable -> SessionVariableValue -> Bool) -> SessVarPred
[unSessVarPred] :: SessVarPred -> Maybe (SessionVariable -> SessionVariableValue -> Bool)
keepAllSessionVariables :: SessVarPred
runSessVarPred :: SessVarPred -> SessionVariables -> SessionVariables

-- | Filter out only those session variables used by the query AST provided
filterVariablesFromQuery :: [RootField (QueryDBRoot (RemoteRelationshipField UnpreparedValue) UnpreparedValue) (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable) (ActionQuery (RemoteRelationshipField UnpreparedValue)) d] -> SessVarPred

-- | Run (execute) a single GraphQL query
runGQ :: forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadReader ExecutionCtx m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadTrace m, MonadExecuteQuery m, MonadMetadataStorage (MetadataStorageT m), MonadQueryTags m, HasResourceLimits m) => Environment -> Logger Hasura -> RequestId -> UserInfo -> IpAddress -> [Header] -> GraphQLQueryType -> GQLReqUnparsed -> m (GQLQueryOperationSuccessLog, HttpResponse (Maybe GQResponse, EncJSON))
coalescePostgresMutations :: ExecutionPlan -> Maybe (SourceConfig ('Postgres 'Vanilla), InsOrdHashMap RootFieldAlias (DBStepInfo ('Postgres 'Vanilla)))
data GraphQLResponse
GraphQLResponseErrors :: [Value] -> GraphQLResponse
GraphQLResponseData :: Value -> GraphQLResponse
decodeGraphQLResponse :: ByteString -> Either Text GraphQLResponse
extractFieldFromResponse :: forall m. Monad m => RootFieldAlias -> ResultCustomizer -> ByteString -> ExceptT (Either GQExecError QErr) m Value
buildRaw :: Applicative m => Value -> m AnnotatedResponsePart
encodeAnnotatedResponseParts :: RootFieldMap AnnotatedResponsePart -> EncJSON
encodeEncJSONResults :: RootFieldMap EncJSON -> EncJSON

-- | Run (execute) a batched GraphQL query (see <a>GQLBatchedReqs</a>).
runGQBatched :: forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadReader ExecutionCtx m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadTrace m, MonadExecuteQuery m, HttpLog m, MonadMetadataStorage (MetadataStorageT m), MonadQueryTags m, HasResourceLimits m) => Environment -> Logger Hasura -> RequestId -> ResponseInternalErrorsConfig -> UserInfo -> IpAddress -> [Header] -> GraphQLQueryType -> GQLBatchedReqs (GQLReq GQLQueryText) -> m (HttpLogMetadata m, HttpResponse EncJSON)
instance GHC.Show.Show Hasura.GraphQL.Transport.HTTP.CacheStoreSuccess
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.CacheStoreSuccess
instance GHC.Show.Show Hasura.GraphQL.Transport.HTTP.CacheStoreFailure
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.CacheStoreFailure
instance GHC.Base.Monoid Hasura.GraphQL.Transport.HTTP.SessVarPred
instance GHC.Base.Semigroup Hasura.GraphQL.Transport.HTTP.SessVarPred
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery m => Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery m => Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery (Control.Monad.Trans.Except.ExceptT r m)
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery m => Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery (Hasura.Tracing.TraceT m)
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery m => Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery (Hasura.Metadata.Class.MetadataStorageT m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.HTTP.QueryCacheKey

module Hasura.Server.Rest
parseVariableNames :: EndpointMetadata GQLQueryWithText -> [Text]
alignVars :: [VariableDefinition] -> [(Text, Either Text Value)] -> HashMap Name (These VariableDefinition (Either Text Value))

-- | <a>resolveVar</a> is responsible for decoding variables sent via REST
--   request. These can either be via body (represented by Right) or via
--   query-param or URL param (represented by Left). A variable can be
--   expected, unexpected, or missing (represented by These, This, and
--   That).
resolveVar :: Name -> These VariableDefinition (Either Text Value) -> Either Text (Maybe Value)
mkPassthroughRequest :: EndpointMetadata GQLQueryWithText -> VariableValues -> GQLReq GQLQueryText
data RestRequest method
RestRequest :: Text -> method -> [(Text, Either Text Value)] -> RestRequest method

-- | Remainder of the url path after `api/rest`
[reqPath] :: RestRequest method -> Text
[reqMethod] :: RestRequest method -> method

-- | URL Query/Request Body Arguments
[reqArgs] :: RestRequest method -> [(Text, Either Text Value)]

-- | Implements all the custom endpoints by looking up the path/methods in
--   the endpoint trie and delegating to the graphql handler.
runCustomEndpoint :: forall m. (MonadIO m, MonadError QErr m, MonadTrace m, MonadBaseControl IO m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadExecuteQuery m, MonadMetadataStorage (MetadataStorageT m), HttpLog m, MonadQueryTags m, HasResourceLimits m) => Environment -> ExecutionCtx -> RequestId -> UserInfo -> [Header] -> IpAddress -> RestRequest EndpointMethod -> EndpointTrie GQLQueryWithText -> m (HttpLogMetadata m, HttpResponse EncJSON)
instance Data.Traversable.Traversable Hasura.Server.Rest.RestRequest
instance Data.Foldable.Foldable Hasura.Server.Rest.RestRequest
instance GHC.Base.Functor Hasura.Server.Rest.RestRequest


-- | This file contains the handlers that are used within websocket server.
--   
--   This module export three main handlers for the websocket server
--   (<a>onConn</a>, <a>onMessage</a>, <a>onClose</a>), and two helpers for
--   sending messages to the client (<a>sendMsg</a>,
--   <a>sendCloseWithMsg</a>).
--   
--   NOTE! The handler functions <a>onClose</a>, <a>onMessage</a>, etc.
--   depend for correctness on two properties: - they run with async
--   exceptions masked - they do not race on the same connection
module Hasura.GraphQL.Transport.WebSocket

-- | <a>SubscriberDetails</a> comes from <a>addLiveQuery</a>. We use this
--   to track a connection's operations so we can remove them from
--   <tt>LiveQueryState</tt>, and log.
--   
--   NOTE!: This must be kept consistent with the global
--   <tt>LiveQueryState</tt>, in <a>onClose</a> and <a>onStart</a>.
data OpDetail
ODStarted :: OpDetail
ODProtoErr :: !Text -> OpDetail
ODQueryErr :: !QErr -> OpDetail
ODCompleted :: OpDetail
ODStopped :: OpDetail
data OperationDetails
OperationDetails :: !OperationId -> !Maybe RequestId -> !Maybe OperationName -> !OpDetail -> !Maybe GQLReqUnparsed -> !Maybe ParameterizedQueryHash -> OperationDetails
[_odOperationId] :: OperationDetails -> !OperationId
[_odRequestId] :: OperationDetails -> !Maybe RequestId
[_odOperationName] :: OperationDetails -> !Maybe OperationName
[_odOperationType] :: OperationDetails -> !OpDetail
[_odQuery] :: OperationDetails -> !Maybe GQLReqUnparsed
[_odParameterizedQueryHash] :: OperationDetails -> !Maybe ParameterizedQueryHash
data WSEvent
EAccepted :: WSEvent
ERejected :: !QErr -> WSEvent
EConnErr :: !ConnErrMsg -> WSEvent
EOperation :: !OperationDetails -> WSEvent
EClosed :: WSEvent
data WsConnInfo
WsConnInfo :: !WSId -> !Maybe UTCTime -> !Maybe Text -> WsConnInfo
[_wsciWebsocketId] :: WsConnInfo -> !WSId
[_wsciTokenExpiry] :: WsConnInfo -> !Maybe UTCTime
[_wsciMsg] :: WsConnInfo -> !Maybe Text
data WSLogInfo
WSLogInfo :: !Maybe SessionVariables -> !WsConnInfo -> !WSEvent -> WSLogInfo
[_wsliUserVars] :: WSLogInfo -> !Maybe SessionVariables
[_wsliConnectionInfo] :: WSLogInfo -> !WsConnInfo
[_wsliEvent] :: WSLogInfo -> !WSEvent
data WSLog
WSLog :: !LogLevel -> !WSLogInfo -> WSLog
[_wslLogLevel] :: WSLog -> !LogLevel
[_wslInfo] :: WSLog -> !WSLogInfo
mkWsInfoLog :: Maybe SessionVariables -> WsConnInfo -> WSEvent -> WSLog
mkWsErrorLog :: Maybe SessionVariables -> WsConnInfo -> WSEvent -> WSLog
logWSEvent :: MonadIO m => Logger Hasura -> WSConn -> WSEvent -> m ()
sendMsg :: MonadIO m => WSConn -> ServerMsg -> m ()
sendCloseWithMsg :: MonadIO m => Logger Hasura -> WSConn -> ServerErrorCode -> Maybe ServerMsg -> Maybe Word16 -> m ()
sendMsgWithMetadata :: MonadIO m => WSConn -> ServerMsg -> Maybe OperationName -> Maybe ParameterizedQueryHash -> SubscriptionMetadata -> m ()
onConn :: (MonadIO m, MonadReader WSServerEnv m) => OnConnH m WSConnData
onStart :: forall m. (MonadIO m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadTrace m, MonadExecuteQuery m, MonadBaseControl IO m, MonadMetadataStorage (MetadataStorageT m), MonadQueryTags m, HasResourceLimits m) => Environment -> HashSet (EngineLogType Hasura) -> WSServerEnv -> WSConn -> StartMsg -> WSActions WSConnData -> m ()
onMessage :: (MonadIO m, UserAuthentication (TraceT m), MonadGQLExecutionCheck m, MonadQueryLog m, HasReporter m, MonadExecuteQuery m, MonadBaseControl IO m, MonadMetadataStorage (MetadataStorageT m), MonadQueryTags m, HasResourceLimits m) => Environment -> HashSet (EngineLogType Hasura) -> AuthMode -> WSServerEnv -> WSConn -> ByteString -> WSActions WSConnData -> m ()
onPing :: MonadIO m => WSConn -> Maybe PingPongPayload -> m ()
onPong :: MonadIO m => WSConn -> Maybe PingPongPayload -> m ()
onStop :: MonadIO m => WSServerEnv -> WSConn -> StopMsg -> m ()
stopOperation :: WSServerEnv -> WSConn -> OperationId -> IO () -> IO ()
onConnInit :: (MonadIO m, UserAuthentication (TraceT m)) => Logger Hasura -> Manager -> WSConn -> AuthMode -> Maybe ConnParams -> WSOnErrorMessageAction WSConnData -> WSKeepAliveMessageAction WSConnData -> TraceT m ()
onClose :: MonadIO m => Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriptionsState -> WSConn -> m ()
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Transport.WebSocket.WSLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.WSLogInfo
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.WSLogInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.WsConnInfo
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.WsConnInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.WSEvent
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.WSEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.OperationDetails
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.OperationDetails
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.OpDetail
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.OpDetail

module Hasura.GraphQL.Transport.WSServerApp
createWSServerApp :: (MonadIO m, MonadBaseControl IO m, Forall (Pure m), UserAuthentication (TraceT m), MonadGQLExecutionCheck m, MonadWSLog m, MonadQueryLog m, HasReporter m, MonadExecuteQuery m, MonadMetadataStorage (MetadataStorageT m), MonadQueryTags m, HasResourceLimits m) => Environment -> HashSet (EngineLogType Hasura) -> AuthMode -> WSServerEnv -> WSConnectionInitTimeout -> HasuraServerApp m
stopWSServerApp :: WSServerEnv -> IO ()
createWSServerEnv :: MonadIO m => Logger Hasura -> SubscriptionsState -> IO (SchemaCache, SchemaCacheVer) -> Manager -> CorsPolicy -> SQLGenCtx -> ReadOnlyMode -> Bool -> KeepAliveDelay -> ServerMetrics -> PrometheusMetrics -> m WSServerEnv
mkWSActions :: Logger Hasura -> WSSubProtocol -> WSActions WSConnData

module Hasura.GraphQL.Explain
data GQLExplain
GQLExplain :: !GQLReqParsed -> !Maybe (HashMap Text Text) -> !Maybe Bool -> GQLExplain
[_gqeQuery] :: GQLExplain -> !GQLReqParsed
[_gqeUser] :: GQLExplain -> !Maybe (HashMap Text Text)
[_gqeIsRelay] :: GQLExplain -> !Maybe Bool
explainQueryField :: (MonadError QErr m, MonadIO m) => UserInfo -> RootFieldAlias -> QueryRootField UnpreparedValue -> m EncJSON
explainGQLQuery :: forall m. (MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadMetadataStorage (MetadataStorageT m), MonadQueryTags m) => SchemaCache -> GQLExplain -> m EncJSON
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Explain.GQLExplain
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Explain.GQLExplain
instance GHC.Classes.Eq Hasura.GraphQL.Explain.GQLExplain
instance GHC.Show.Show Hasura.GraphQL.Explain.GQLExplain


-- | Taken from wai-websockets package and customized to get IP address on
--   websocket connection
--   <a>http://hackage.haskell.org/package/wai-websockets-3.0.1.2/docs/Network-Wai-Handler-WebSockets.html</a>
module Network.Wai.Handler.WebSockets.Custom

-- | Returns whether or not the given <a>Request</a> is a WebSocket
--   request.
isWebSocketsReq :: Request -> Bool

-- | Upgrade a <tt>websockets</tt> <a>ServerApp</a> to a <tt>wai</tt>
--   <a>Application</a>. Uses the given backup <a>Application</a> to handle
--   <a>Request</a>s that are not WebSocket requests.
--   
--   <pre>
--   websocketsOr opts ws_app backup_app = \req respond -&gt;
--       <b>case</b> <a>websocketsApp</a> opts ws_app req <b>of</b>
--           <a>Nothing</a>  -&gt; backup_app req send_response
--           <a>Just</a> res -&gt; respond res
--   </pre>
--   
--   For example, below is an <a>Application</a> that sends <tt>"Hello,
--   client!"</tt> to each connected client.
--   
--   <pre>
--   app :: <a>Application</a>
--   app = <a>websocketsOr</a> <a>defaultConnectionOptions</a> wsApp backupApp
--     <b>where</b>
--       wsApp :: <a>ServerApp</a>
--       wsApp pending_conn = do
--           conn &lt;- <a>acceptRequest</a> pending_conn
--           <a>sendTextData</a> conn ("Hello, client!" :: <a>Text</a>)
--   
--       backupApp :: <a>Application</a>
--       backupApp _ respond = respond $ <a>responseLBS</a> <a>status400</a> [] "Not a WebSocket request"
--   </pre>
websocketsOr :: ConnectionOptions -> (IpAddress -> PendingConnection -> IO ()) -> Application -> Application

-- | Handle a single <tt>wai</tt> <a>Request</a> with the given
--   <tt>websockets</tt> <a>ServerApp</a>. Returns <a>Nothing</a> if the
--   <a>Request</a> is not a WebSocket request, <a>Just</a> otherwise.
--   
--   Usually, <a>websocketsOr</a> is more convenient.
websocketsApp :: ConnectionOptions -> (IpAddress -> PendingConnection -> IO ()) -> Request -> Maybe Response
getRequestHead :: Request -> (RequestHead, IpAddress)

-- | Internal function to run the WebSocket io-streams using the conduit
--   library.
runWebSockets :: ConnectionOptions -> RequestHead -> IpAddress -> (IpAddress -> PendingConnection -> IO a) -> IO ByteString -> (ByteString -> IO ()) -> IO a

module Hasura.Server.App
data ServerCtx
ServerCtx :: !Logger Hasura -> !SchemaCacheRef -> !AuthMode -> !Manager -> !SQLGenCtx -> !HashSet API -> !InstanceId -> !SubscriptionsState -> !Bool -> !Store EmptyMetrics -> !ResponseInternalErrorsConfig -> !Environment -> !RemoteSchemaPermissions -> !InferFunctionPermissions -> !MaintenanceMode () -> !HashSet ExperimentalFeature -> !LoggingSettings -> !EventingMode -> !ReadOnlyMode -> !Maybe NamingCase -> !PrometheusMetrics -> ServerCtx
[scLogger] :: ServerCtx -> !Logger Hasura
[scCacheRef] :: ServerCtx -> !SchemaCacheRef
[scAuthMode] :: ServerCtx -> !AuthMode
[scManager] :: ServerCtx -> !Manager
[scSQLGenCtx] :: ServerCtx -> !SQLGenCtx
[scEnabledAPIs] :: ServerCtx -> !HashSet API
[scInstanceId] :: ServerCtx -> !InstanceId
[scSubscriptionState] :: ServerCtx -> !SubscriptionsState
[scEnableAllowlist] :: ServerCtx -> !Bool
[scEkgStore] :: ServerCtx -> !Store EmptyMetrics
[scResponseInternalErrorsConfig] :: ServerCtx -> !ResponseInternalErrorsConfig
[scEnvironment] :: ServerCtx -> !Environment
[scRemoteSchemaPermsCtx] :: ServerCtx -> !RemoteSchemaPermissions
[scFunctionPermsCtx] :: ServerCtx -> !InferFunctionPermissions
[scEnableMaintenanceMode] :: ServerCtx -> !MaintenanceMode ()
[scExperimentalFeatures] :: ServerCtx -> !HashSet ExperimentalFeature
[scLoggingSettings] :: ServerCtx -> !LoggingSettings
[scEventingMode] :: ServerCtx -> !EventingMode
[scEnableReadOnlyMode] :: ServerCtx -> !ReadOnlyMode
[scDefaultNamingConvention] :: ServerCtx -> !Maybe NamingCase
[scPrometheusMetrics] :: ServerCtx -> !PrometheusMetrics
data HandlerCtx
HandlerCtx :: !ServerCtx -> !UserInfo -> ![Header] -> !RequestId -> !IpAddress -> HandlerCtx
[hcServerCtx] :: HandlerCtx -> !ServerCtx
[hcUser] :: HandlerCtx -> !UserInfo
[hcReqHeaders] :: HandlerCtx -> ![Header]
[hcRequestId] :: HandlerCtx -> !RequestId
[hcSourceIpAddress] :: HandlerCtx -> !IpAddress
type Handler m = ReaderT HandlerCtx (MetadataStorageT m)
data APIResp
JSONResp :: !HttpResponse EncJSON -> APIResp
RawResp :: !HttpResponse ByteString -> APIResp

-- | API request handlers for different endpoints
data APIHandler m a

-- | A simple GET request
[AHGet] :: !Handler m (HttpLogMetadata m, APIResp) -> APIHandler m void

-- | A simple POST request that expects a request body from which an
--   <tt>a</tt> can be extracted
[AHPost] :: !a -> Handler m (HttpLogMetadata m, APIResp) -> APIHandler m a

-- | A general GraphQL request (query or mutation) for which the content of
--   the query is made available to the handler for authentication. This is
--   a more specific version of the <a>AHPost</a> constructor.
[AHGraphQLRequest] :: !ReqsText -> Handler m (HttpLogMetadata m, APIResp) -> APIHandler m ReqsText
boolToText :: Bool -> Text
isAdminSecretSet :: AuthMode -> Text
mkGetHandler :: Handler m (HttpLogMetadata m, APIResp) -> APIHandler m ()
mkPostHandler :: (a -> Handler m (HttpLogMetadata m, APIResp)) -> APIHandler m a
mkGQLRequestHandler :: (ReqsText -> Handler m (HttpLogMetadata m, APIResp)) -> APIHandler m ReqsText
mkAPIRespHandler :: Functor m => (a -> Handler m (HttpResponse EncJSON)) -> a -> Handler m APIResp
mkGQLAPIRespHandler :: Functor m => (a -> Handler m (b, HttpResponse EncJSON)) -> a -> Handler m (b, APIResp)
isMetadataEnabled :: ServerCtx -> Bool
isGraphQLEnabled :: ServerCtx -> Bool
isPGDumpEnabled :: ServerCtx -> Bool
isConfigEnabled :: ServerCtx -> Bool
isDeveloperAPIEnabled :: ServerCtx -> Bool
parseBody :: (FromJSON a, MonadError QErr m) => ByteString -> m (Value, a)
onlyAdmin :: (MonadError QErr m, MonadReader HandlerCtx m) => m ()
setHeader :: MonadIO m => Header -> ActionT m ()

-- | Typeclass representing the metadata API authorization effect
class (Monad m) => MonadMetadataApiAuthorization m
authorizeV1QueryApi :: MonadMetadataApiAuthorization m => RQLQuery -> HandlerCtx -> m (Either QErr ())
authorizeV1MetadataApi :: MonadMetadataApiAuthorization m => RQLMetadata -> HandlerCtx -> m (Either QErr ())
authorizeV2QueryApi :: MonadMetadataApiAuthorization m => RQLQuery -> HandlerCtx -> m (Either QErr ())

-- | The config API (<i>v1alpha1</i>config) handler
class Monad m => MonadConfigApiHandler m
runConfigApiHandler :: MonadConfigApiHandler m => ServerCtx -> Maybe Text -> SpockCtxT () m ()
mapActionT :: (Monad m, Monad n) => (m (StT (ActionCtxT ()) a) -> n (StT (ActionCtxT ()) a)) -> ActionT m a -> ActionT n a
mkSpockAction :: (MonadIO m, MonadBaseControl IO m, FromJSON a, UserAuthentication (TraceT m), HttpLog m, HasReporter m, HasResourceLimits m) => ServerCtx -> (Bool -> QErr -> Value) -> (QErr -> QErr) -> APIHandler (TraceT m) a -> ActionT m ()
v1QueryHandler :: (MonadIO m, MonadBaseControl IO m, MonadMetadataApiAuthorization m, MonadTrace m, MonadReader HandlerCtx m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m) => RQLQuery -> m (HttpResponse EncJSON)
v1MetadataHandler :: (MonadIO m, MonadBaseControl IO m, MonadReader HandlerCtx m, MonadTrace m, MonadMetadataStorage m, MonadResolveSource m, MonadMetadataApiAuthorization m) => RQLMetadata -> m (HttpResponse EncJSON)
v2QueryHandler :: (MonadIO m, MonadBaseControl IO m, MonadMetadataApiAuthorization m, MonadTrace m, MonadReader HandlerCtx m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m) => RQLQuery -> m (HttpResponse EncJSON)
v1Alpha1GQHandler :: (MonadIO m, MonadBaseControl IO m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadTrace m, MonadExecuteQuery m, MonadError QErr m, MonadReader HandlerCtx m, HttpLog m, MonadMetadataStorage (MetadataStorageT m), MonadQueryTags m, HasResourceLimits m) => GraphQLQueryType -> GQLBatchedReqs (GQLReq GQLQueryText) -> m (HttpLogMetadata m, HttpResponse EncJSON)
mkExecutionContext :: (MonadIO m, MonadReader HandlerCtx m) => m ExecutionCtx
v1GQHandler :: (MonadIO m, MonadBaseControl IO m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadTrace m, MonadExecuteQuery m, HttpLog m, MonadError QErr m, MonadReader HandlerCtx m, MonadMetadataStorage (MetadataStorageT m), MonadQueryTags m, HasResourceLimits m) => GQLBatchedReqs (GQLReq GQLQueryText) -> m (HttpLogMetadata m, HttpResponse EncJSON)
v1GQRelayHandler :: (MonadIO m, MonadBaseControl IO m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadTrace m, HttpLog m, MonadExecuteQuery m, MonadError QErr m, MonadReader HandlerCtx m, MonadMetadataStorage (MetadataStorageT m), MonadQueryTags m, HasResourceLimits m) => GQLBatchedReqs (GQLReq GQLQueryText) -> m (HttpLogMetadata m, HttpResponse EncJSON)
gqlExplainHandler :: forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadReader HandlerCtx m, MonadMetadataStorage (MetadataStorageT m), MonadQueryTags m) => GQLExplain -> m (HttpResponse EncJSON)
v1Alpha1PGDumpHandler :: (MonadIO m, MonadError QErr m, MonadReader HandlerCtx m) => PGDumpReqBody -> m APIResp
consoleAssetsHandler :: (MonadIO m, HttpLog m) => Logger Hasura -> LoggingSettings -> Text -> FilePath -> ActionT m ()
class (Monad m) => ConsoleRenderer m
renderConsole :: ConsoleRenderer m => Text -> AuthMode -> Bool -> Maybe Text -> m (Either String Text)
renderHtmlTemplate :: Template -> Value -> Either String Text

-- | Default implementation of the <a>MonadConfigApiHandler</a>
configApiGetHandler :: forall m. (MonadIO m, MonadBaseControl IO m, UserAuthentication (TraceT m), HttpLog m, HasReporter m, HasResourceLimits m) => ServerCtx -> Maybe Text -> SpockCtxT () m ()
data HasuraApp
HasuraApp :: !Application -> !SchemaCacheRef -> !AsyncActionSubscriptionState -> !IO () -> HasuraApp
[_hapApplication] :: HasuraApp -> !Application
[_hapSchemaRef] :: HasuraApp -> !SchemaCacheRef
[_hapAsyncActionSubscriptionState] :: HasuraApp -> !AsyncActionSubscriptionState
[_hapShutdownWsServer] :: HasuraApp -> !IO ()
mkWaiApp :: forall m. (MonadIO m, MonadFix m, MonadStateless IO m, Forall (Pure m), ConsoleRenderer m, HttpLog m, UserAuthentication (TraceT m), MonadMetadataApiAuthorization m, MonadGQLExecutionCheck m, MonadConfigApiHandler m, MonadQueryLog m, MonadWSLog m, HasReporter m, MonadExecuteQuery m, HasResourceLimits m, MonadMetadataStorage (MetadataStorageT m), MonadResolveSource m, MonadQueryTags m) => (ServerCtx -> SpockT m ()) -> Environment -> Logger Hasura -> SQLGenCtx -> Bool -> Manager -> AuthMode -> CorsConfig -> Bool -> Maybe Text -> Bool -> InstanceId -> HashSet API -> LiveQueriesOptions -> StreamQueriesOptions -> ResponseInternalErrorsConfig -> Maybe SubscriptionPostPollHook -> SchemaCacheRef -> Store EmptyMetrics -> ServerMetrics -> PrometheusMetrics -> RemoteSchemaPermissions -> InferFunctionPermissions -> ConnectionOptions -> KeepAliveDelay -> MaintenanceMode () -> EventingMode -> ReadOnlyMode -> HashSet ExperimentalFeature -> HashSet (EngineLogType Hasura) -> WSConnectionInitTimeout -> MetadataQueryLoggingMode -> Maybe NamingCase -> m HasuraApp
httpApp :: forall m. (MonadIO m, MonadFix m, MonadBaseControl IO m, ConsoleRenderer m, HttpLog m, UserAuthentication (TraceT m), MonadMetadataApiAuthorization m, MonadGQLExecutionCheck m, MonadConfigApiHandler m, MonadQueryLog m, HasReporter m, MonadExecuteQuery m, MonadMetadataStorage (MetadataStorageT m), HasResourceLimits m, MonadResolveSource m, MonadQueryTags m) => (ServerCtx -> SpockT m ()) -> CorsConfig -> ServerCtx -> Bool -> Maybe Text -> Bool -> SpockT m ()
raiseGenericApiError :: (MonadIO m, HttpLog m) => Logger Hasura -> LoggingSettings -> [Header] -> QErr -> ActionT m ()
instance Hasura.Server.App.ConsoleRenderer m => Hasura.Server.App.ConsoleRenderer (Hasura.Tracing.TraceT m)
instance Hasura.Server.App.MonadMetadataApiAuthorization m => Hasura.Server.App.MonadMetadataApiAuthorization (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.App.MonadMetadataApiAuthorization m => Hasura.Server.App.MonadMetadataApiAuthorization (Hasura.Metadata.Class.MetadataStorageT m)
instance Hasura.Server.App.MonadMetadataApiAuthorization m => Hasura.Server.App.MonadMetadataApiAuthorization (Hasura.Tracing.TraceT m)

module Hasura.App
data ExitCode
InvalidEnvironmentVariableOptionsError :: ExitCode
InvalidDatabaseConnectionParamsError :: ExitCode
AuthConfigurationError :: ExitCode
EventSubSystemError :: ExitCode
DatabaseMigrationError :: ExitCode

-- | used by MT because it initialises the schema cache only these are used
--   in app/Main.hs:
SchemaCacheInitError :: ExitCode
MetadataExportError :: ExitCode
MetadataCleanError :: ExitCode
ExecuteProcessError :: ExitCode
DowngradeProcessError :: ExitCode
data ExitException
ExitException :: !ExitCode -> !ByteString -> ExitException
[eeCode] :: ExitException -> !ExitCode
[eeMessage] :: ExitException -> !ByteString
throwErrExit :: MonadIO m => forall a. ExitCode -> String -> m a
throwErrJExit :: (ToJSON a, MonadIO m) => forall b. ExitCode -> a -> m b
parseArgs :: EnabledLogTypes impl => IO (HGEOptions (ServeOptions impl))
printJSON :: (ToJSON a, MonadIO m) => a -> m ()
printYaml :: (ToJSON a, MonadIO m) => a -> m ()
mkPGLogger :: Logger Hasura -> PGLogger

-- | Context required for all graphql-engine CLI commands
data GlobalCtx
GlobalCtx :: !ConnInfo -> !(Maybe (UrlConf, ConnInfo), Maybe Int) -> GlobalCtx
[_gcMetadataDbConnInfo] :: GlobalCtx -> !ConnInfo

-- | <ul>
--   <li>-database-url option, @<a>UrlConf</a> is required to construct
--   default source configuration and optional retries</li>
--   </ul>
[_gcDefaultPostgresConnInfo] :: GlobalCtx -> !(Maybe (UrlConf, ConnInfo), Maybe Int)
readTlsAllowlist :: SchemaCacheRef -> IO [TlsAllow]
initGlobalCtx :: MonadIO m => Environment -> Maybe String -> PostgresConnInfo (Maybe UrlConf) -> m GlobalCtx

-- | Context required for the <tt>serve</tt> CLI command.
data ServeCtx
ServeCtx :: !Manager -> !InstanceId -> !Loggers -> !HashSet (EngineLogType Hasura) -> !PGPool -> !ShutdownLatch -> !RebuildableSchemaCache -> !SchemaCacheRef -> !TMVar MetadataResourceVersion -> ServeCtx
[_scHttpManager] :: ServeCtx -> !Manager
[_scInstanceId] :: ServeCtx -> !InstanceId
[_scLoggers] :: ServeCtx -> !Loggers
[_scEnabledLogTypes] :: ServeCtx -> !HashSet (EngineLogType Hasura)
[_scMetadataDbPool] :: ServeCtx -> !PGPool
[_scShutdownLatch] :: ServeCtx -> !ShutdownLatch
[_scSchemaCache] :: ServeCtx -> !RebuildableSchemaCache
[_scSchemaCacheRef] :: ServeCtx -> !SchemaCacheRef
[_scMetaVersionRef] :: ServeCtx -> !TMVar MetadataResourceVersion

-- | Collection of the LoggerCtx, the regular Logger and the PGLogger TODO
--   (from master): better naming?
data Loggers
Loggers :: !LoggerCtx Hasura -> !Logger Hasura -> !PGLogger -> Loggers
[_lsLoggerCtx] :: Loggers -> !LoggerCtx Hasura
[_lsLogger] :: Loggers -> !Logger Hasura
[_lsPgLogger] :: Loggers -> !PGLogger

-- | An application with Postgres database as a metadata storage
newtype PGMetadataStorageAppT m a
PGMetadataStorageAppT :: ((PGPool, PGLogger) -> m a) -> PGMetadataStorageAppT m a
[runPGMetadataStorageAppT] :: PGMetadataStorageAppT m a -> (PGPool, PGLogger) -> m a
resolvePostgresConnInfo :: MonadIO m => Environment -> UrlConf -> Maybe Int -> m ConnInfo

-- | Initializes or migrates the catalog and returns the context required
--   to start the server.
initialiseServeCtx :: (ForkableMonadIO m, MonadCatch m) => Environment -> GlobalCtx -> ServeOptions Hasura -> ServerMetrics -> ManagedT m ServeCtx
mkLoggers :: (MonadIO m, MonadBaseControl IO m) => HashSet (EngineLogType Hasura) -> LogLevel -> ManagedT m Loggers

-- | helper function to initialize or migrate the <tt>hdb_catalog</tt>
--   schema (used by pro as well)
migrateCatalogSchema :: (MonadIO m, MonadBaseControl IO m) => Environment -> Logger Hasura -> PGPool -> Maybe (SourceConnConfiguration ('Postgres 'Vanilla)) -> Manager -> ServerConfigCtx -> SourceResolver ('Postgres 'Vanilla) -> SourceResolver 'MSSQL -> ExtensionsSchema -> m RebuildableSchemaCache

-- | A latch for the graceful shutdown of a server process.
newtype ShutdownLatch
ShutdownLatch :: MVar () -> ShutdownLatch
[unShutdownLatch] :: ShutdownLatch -> MVar ()

-- | Event triggers live in the user's DB and other events (cron, one-off
--   and async actions) live in the metadata DB, so we need a way to
--   differentiate the type of shutdown action
data ShutdownAction
EventTriggerShutdownAction :: IO () -> ShutdownAction
MetadataDBShutdownAction :: MetadataStorageT IO () -> ShutdownAction
newShutdownLatch :: IO ShutdownLatch

-- | Block the current thread, waiting on the latch.
waitForShutdown :: ShutdownLatch -> IO ()

-- | Initiate a graceful shutdown of the server associated with the
--   provided latch.
shutdownGracefully :: ShutdownLatch -> IO ()

-- | Returns True if the latch is set for shutdown and vice-versa
shuttingDown :: ShutdownLatch -> IO Bool

-- | If an exception is encountered , flush the log buffer and rethrow If
--   we do not flush the log buffer on exception, then log lines may be
--   missed See:
--   <a>https://github.com/hasura/graphql-engine/issues/4772</a>
flushLogger :: MonadIO m => LoggerCtx impl -> m ()

-- | This function acts as the entrypoint for the graphql-engine webserver.
--   
--   Note: at the exit of this function, or in case of a graceful server
--   shutdown (SIGTERM, or more generally, whenever the shutdown latch is
--   set), we need to make absolutely sure that we clean up any resources
--   which were allocated during server setup. In the case of a multitenant
--   process, failure to do so can lead to resource leaks.
--   
--   To track these resources, we use the ManagedT monad, and attach
--   finalizers at the same point in the code where we allocate resources.
--   If you fork a new long-lived thread, or create a connection pool, or
--   allocate any other long-lived resource, make sure to pair the
--   allocator with its finalizer. There are plenty of examples throughout
--   the code. For example, see <a>forkManagedT</a>.
--   
--   Note also: the order in which the finalizers run can be important.
--   Specifically, we want the finalizers for the logger threads to run
--   last, so that we retain as many "thread stopping" log messages as
--   possible. The order in which the finalizers is run is determined by
--   the order in which they are introduced in the code.
runHGEServer :: forall m impl. (MonadIO m, MonadFix m, MonadMask m, MonadStateless IO m, Forall (Pure m), UserAuthentication (TraceT m), HttpLog m, ConsoleRenderer m, MonadMetadataApiAuthorization m, MonadGQLExecutionCheck m, MonadConfigApiHandler m, MonadQueryLog m, MonadWSLog m, MonadExecuteQuery m, HasReporter m, HasResourceLimits m, MonadMetadataStorage (MetadataStorageT m), MonadResolveSource m, MonadQueryTags m) => (ServerCtx -> SpockT m ()) -> Environment -> ServeOptions impl -> ServeCtx -> UTCTime -> Maybe SubscriptionPostPollHook -> ServerMetrics -> Store EmptyMetrics -> Maybe (IO ()) -> PrometheusMetrics -> ManagedT m ()

-- | Part of a factorization of <a>runHGEServer</a> to expose the
--   constructed WAI application for testing purposes. See
--   <a>runHGEServer</a> for documentation.
mkHGEServer :: forall m impl. (MonadIO m, MonadFix m, MonadMask m, MonadStateless IO m, Forall (Pure m), UserAuthentication (TraceT m), HttpLog m, ConsoleRenderer m, MonadMetadataApiAuthorization m, MonadGQLExecutionCheck m, MonadConfigApiHandler m, MonadQueryLog m, MonadWSLog m, MonadExecuteQuery m, HasReporter m, HasResourceLimits m, MonadMetadataStorage (MetadataStorageT m), MonadResolveSource m, MonadQueryTags m) => (ServerCtx -> SpockT m ()) -> Environment -> ServeOptions impl -> ServeCtx -> UTCTime -> Maybe SubscriptionPostPollHook -> ServerMetrics -> Store EmptyMetrics -> PrometheusMetrics -> ManagedT m Application
accessDeniedErrMsg :: Text
runInSeparateTx :: MonadIO m => TxE QErr a -> MetadataStorageT (PGMetadataStorageAppT m) a
notifySchemaCacheSyncTx :: MetadataResourceVersion -> InstanceId -> CacheInvalidations -> TxE QErr ()
getCatalogStateTx :: TxE QErr CatalogState
setCatalogStateTx :: CatalogStateType -> Value -> TxE QErr ()
mkConsoleHTML :: Text -> AuthMode -> Bool -> Maybe Text -> Either String Text
telemetryNotice :: String
mkPgSourceResolver :: PGLogger -> SourceResolver ('Postgres 'Vanilla)
mkMSSQLSourceResolver :: SourceResolver 'MSSQL
instance GHC.Show.Show Hasura.App.ExitCode
instance GHC.Show.Show Hasura.App.ExitException
instance Control.Monad.Trans.Class.MonadTrans Hasura.App.PGMetadataStorageAppT
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.App.PGMetadataStorageAppT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.App.PGMetadataStorageAppT m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader (Database.PG.Query.Pool.PGPool, Database.PG.Query.Connection.PGLogger) (Hasura.App.PGMetadataStorageAppT m)
instance Hasura.Server.Types.HasServerConfigCtx m => Hasura.Server.Types.HasServerConfigCtx (Hasura.App.PGMetadataStorageAppT m)
instance Network.HTTP.Client.Manager.HasHttpManagerM m => Network.HTTP.Client.Manager.HasHttpManagerM (Hasura.App.PGMetadataStorageAppT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Hasura.App.PGMetadataStorageAppT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hasura.App.PGMetadataStorageAppT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hasura.App.PGMetadataStorageAppT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Hasura.App.PGMetadataStorageAppT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.App.PGMetadataStorageAppT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.App.PGMetadataStorageAppT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.App.PGMetadataStorageAppT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.App.PGMetadataStorageAppT m)
instance GHC.Base.Monad m => Hasura.Tracing.HasReporter (Hasura.App.PGMetadataStorageAppT m)
instance GHC.Base.Monad m => Hasura.Server.Limits.HasResourceLimits (Hasura.App.PGMetadataStorageAppT m)
instance Control.Monad.IO.Class.MonadIO m => Hasura.Server.Logging.HttpLog (Hasura.App.PGMetadataStorageAppT m)
instance GHC.Base.Monad m => Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery (Hasura.App.PGMetadataStorageAppT m)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m) => Hasura.Server.Auth.UserAuthentication (Hasura.Tracing.TraceT (Hasura.App.PGMetadataStorageAppT m))
instance GHC.Base.Monad m => Hasura.Server.App.MonadMetadataApiAuthorization (Hasura.App.PGMetadataStorageAppT m)
instance GHC.Base.Monad m => Hasura.Server.App.ConsoleRenderer (Hasura.App.PGMetadataStorageAppT m)
instance GHC.Base.Monad m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Hasura.App.PGMetadataStorageAppT m)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m) => Hasura.Server.App.MonadConfigApiHandler (Hasura.App.PGMetadataStorageAppT m)
instance Control.Monad.IO.Class.MonadIO m => Hasura.GraphQL.Logging.MonadQueryLog (Hasura.App.PGMetadataStorageAppT m)
instance Control.Monad.IO.Class.MonadIO m => Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog (Hasura.App.PGMetadataStorageAppT m)
instance GHC.Base.Monad m => Hasura.RQL.Types.Source.MonadResolveSource (Hasura.App.PGMetadataStorageAppT m)
instance GHC.Base.Monad m => Hasura.GraphQL.Execute.Backend.MonadQueryTags (Hasura.App.PGMetadataStorageAppT m)
instance Control.Monad.IO.Class.MonadIO m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.Metadata.Class.MetadataStorageT (Hasura.App.PGMetadataStorageAppT m))
instance Hasura.Metadata.Class.MonadMetadataStorageQueryAPI (Hasura.Metadata.Class.MetadataStorageT (Hasura.App.PGMetadataStorageAppT Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild))
instance GHC.Exception.Type.Exception Hasura.App.ExitException
