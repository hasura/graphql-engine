-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | GraphQL API over Postgres
--   
--   GraphQL API over Postgres
@package graphql-engine
@version 1.0.0


-- | Knot-tying monad transformer for recursive graph building.
--   
--   Some operations, such as building a graph, are inherently
--   self-recursive; consider the following graph:
--   
--   <pre>
--   a -&gt; b
--   b -&gt; a
--   </pre>
--   
--   To construct in Haskell, we might want to use the following type:
--   
--   <pre>
--   data Node = Node
--     { nodeName :: Text
--     , nodeNeighbours :: [Node]
--     }
--   </pre>
--   
--   To construct our trivial graph, we need <tt>a</tt> to know about
--   <tt>b</tt> and <tt>b</tt> to know about <tt>a</tt>: this is fine as
--   long as we can build them both at the same time:
--   
--   <pre>
--   graph = [nodeA, nodeB]
--     where
--       nodeA = Node "a" [nodeB]
--       nodeB = Node "b" [nodeA]
--   </pre>
--   
--   But this falls apart as soon as building the nodes becomes more
--   complicated; for instance, if it becomes monadic. This causes an
--   infinite recursion:
--   
--   <pre>
--   graph = do
--     a &lt;- buildA
--     b &lt;- buildB
--     pure [a,b]
--     where
--       buildA = do
--         b &lt;- buildB
--         pure $ Node "a" [b]
--       buildB = do
--         a &lt;- buildA
--         pure $ Node "b" [a]
--   </pre>
--   
--   The reason why the non-monadic version works is laziness; and there is
--   a way to retrieve this laziness in a monadic context: it's what
--   <a>MonadFix</a> is for. (https:/<i>wiki.haskell.org</i>MonadFix)
--   
--   However, <a>MonadFix</a> is both powerful and unintuitive; the goal of
--   this module is to use its power, but to give it a more restricted
--   interface, to make it easier to use. Using <a>CircularT</a>, the graph
--   above can be built monadically like so:
--   
--   <pre>
--   graph = runCircularT do
--     a &lt;- buildA
--     b &lt;- buildB
--     pure [a,b]
--     where
--       buildA = withCircular "a" do
--         b &lt;- buildB
--         pure $ Node "a" [b]
--       buildB = withCircular "b" do
--         a &lt;- buildA
--         pure $ Node "b" [a]
--   </pre>
--   
--   It allows each part of a recursive process to be given a name (the
--   type of which is of the user's choosing), and it automatically breaks
--   cycles. The only caveat is that we cannot violate temporal causality:
--   if we attempt to make a cache-building decision based on the value
--   obtained from the cache, then no amount of laziness can save us:
--   
--   <pre>
--   broken = runCircularT go
--     where
--       go = withCircular () do
--         x &lt;- go
--         pure $ if odd x then 1 else 0
--   </pre>
--   
--   <a>CircularT</a> is somewhat similar to <tt>TardisT</tt> from
--   <tt>Control.Monad.Tardis</tt> and <tt>SchemaT</tt> from
--   <tt>Hasura.GraphQL.Parser.Monad</tt>, but simpler than both.
module Control.Monad.Circular

-- | CircularT is implemented as a state monad containing a lazy HashMap.
--   
--   We use this state to both determine wether we have already encountered
--   a given key and to track the associated result. We use laziness and
--   MonadFix to tie the knot for us (see <a>withCircular</a>).
--   
--   <ul>
--   <li>type <tt>k</tt> is the type of cache key, to which a given action
--   is associated.</li>
--   <li>type <tt>v</tt> is the values we wish to cache in our
--   process.</li>
--   <li>type <tt>m</tt> is the underlying monad on which this transformer
--   operates.</li>
--   <li>type <tt>a</tt> is the result of the computation</li>
--   </ul>
data CircularT k v m a

-- | Runs a computation in <a>CircularT</a>.
runCircularT :: (Hashable k, MonadFix m) => CircularT k v m a -> m a

-- | Cache a computation under a given key.
--   
--   For a given key <tt>k</tt>, and a computation in <a>CircularT</a> that
--   yields a value of type <tt>v</tt>, return an action that builds said
--   value <tt>v</tt> but that prevents cycles by looking into and
--   populating a stateful cache.
withCircular :: (Hashable k, MonadFix m) => k -> CircularT k v m v -> CircularT k v m v
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Circular.CircularT k v m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Circular.CircularT k v m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Circular.CircularT k v m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Circular.CircularT k v m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Circular.CircularT k v m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Circular.CircularT k v m)
instance Control.Monad.Trans.Class.MonadTrans (Control.Monad.Circular.CircularT k v)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Circular.CircularT k v m)

module Control.Monad.Memoize
class (Monad m) => MonadMemoize m

-- | Memoizes a parser constructor function for the extent of a single
--   schema construction process. This is mostly useful for recursive
--   parsers; see Note [Tying the knot] for more details.
--   
--   The generality of the type here allows us to use this with multiple
--   concrete parser types:
--   
--   <pre>
--   <a>memoizeOn</a> :: (<a>MonadMemoize</a> m, MonadParse n) =&gt; <a>Name</a> -&gt; a -&gt; m (Parser n b) -&gt; m (Parser n b)
--   <a>memoizeOn</a> :: (<a>MonadMemoize</a> m, MonadParse n) =&gt; <a>Name</a> -&gt; a -&gt; m (FieldParser n b) -&gt; m (FieldParser n b)
--   </pre>
memoizeOn :: forall a p. (MonadMemoize m, Ord a, Typeable a, Typeable p) => Name -> a -> m p -> m p

-- | A wrapper around <a>memoizeOn</a> that memoizes a function by using
--   its argument as the key.
memoize :: (MonadMemoize m, Ord a, Typeable a, Typeable p) => Name -> (a -> m p) -> a -> m p
data MemoizeT m a
runMemoizeT :: forall m a. Monad m => MemoizeT m a -> m a
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Memoize.MemoizeT
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Memoize.MemoizeT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Memoize.MemoizeT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Memoize.MemoizeT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Control.Monad.Memoize.MemoizeT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Memoize.MemoizeT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Memoize.MemoizeT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.Memoize.MonadMemoize (Control.Monad.Memoize.MemoizeT m)
instance Data.GADT.Compare.GEq Control.Monad.Memoize.MemoizationKey
instance Data.GADT.Compare.GCompare Control.Monad.Memoize.MemoizationKey
instance Control.Monad.Memoize.MonadMemoize m => Control.Monad.Memoize.MonadMemoize (Control.Monad.Trans.Reader.ReaderT a m)

module Control.Monad.Stateless
class (MonadBaseControl b m, forall a. StatelessProof m a) => MonadStateless b m | m -> b
liftWithStateless :: MonadStateless b m => ((forall a. m a -> b a) -> b c) -> m c
instance (Control.Monad.Trans.Control.MonadBaseControl b m, forall a. Control.Monad.Stateless.StatelessProof m a) => Control.Monad.Stateless.MonadStateless b m
instance (Control.Monad.Trans.Control.StM m a GHC.Types.~ a) => Control.Monad.Stateless.StatelessProof m a

module Control.Monad.Trans.Extended

-- | Utility newtype that can be used to derive type class instances just
--   using <a>MonadTrans</a>.
--   
--   We often derive some <tt>MonadBlaBla</tt> instance for
--   <tt>ReaderT</tt> by using <a>lift</a> from <a>MonadTrans</a>. Which is
--   fine, but it gets laborious if you do the same for <tt>ExceptT</tt>,
--   <tt>StateT</tt> and <tt>WriterT</tt>, even though the method
--   implementations are exactly the same. <a>TransT</a> allows you to
--   write one <a>MonadTrans</a>-based instance, which can then be used
--   with <tt>DerivingVia</tt> to use that one implementation for all monad
--   transformers that use that same lifting implementation.
newtype TransT t (m :: Type -> Type) a
TransT :: t m a -> TransT t (m :: Type -> Type) a
instance Control.Monad.Morph.MMonad t => Control.Monad.Morph.MMonad (Control.Monad.Trans.Extended.TransT t)
instance Control.Monad.Morph.MFunctor t => Control.Monad.Morph.MFunctor (Control.Monad.Trans.Extended.TransT t)
instance Control.Monad.Trans.Class.MonadTrans t => Control.Monad.Trans.Class.MonadTrans (Control.Monad.Trans.Extended.TransT t)
instance GHC.Base.Monad (t m) => GHC.Base.Monad (Control.Monad.Trans.Extended.TransT t m)
instance GHC.Base.Applicative (t m) => GHC.Base.Applicative (Control.Monad.Trans.Extended.TransT t m)
instance GHC.Base.Functor (t m) => GHC.Base.Functor (Control.Monad.Trans.Extended.TransT t m)

module Control.Monad.Trans.Managed

-- | This type is like a transformer version of the <tt>Managed</tt> monad
--   from the <tt>managed</tt> library. It can be used to manage resources
--   by pairing together their allocation with their finalizers.
--   
--   The documentation for the <tt>managed</tt> library is an excellent
--   introduction to the idea here.
--   
--   We could use <a>Codensity</a> directly, but we'd have to define an
--   orphan instance for <a>MonadFix</a>. This also gives us the
--   opportunity to give it a slightly more friendly name.
--   
--   We could also have used <tt>ResourceT</tt>, but that would have
--   involved writing instances for <tt>MonadUnliftIO</tt>. That could
--   still be a good option to consider later, however.
newtype ManagedT m a
ManagedT :: (forall r. (a -> m r) -> m r) -> ManagedT m a
[runManagedT] :: ManagedT m a -> forall r. (a -> m r) -> m r

-- | Allocate a resource by providing setup and finalizer actions.
allocate :: MonadBaseControl IO m => m a -> (a -> m b) -> ManagedT m a

-- | Allocate a resource but do not return a reference to it.
allocate_ :: MonadBaseControl IO m => m a -> m b -> ManagedT m ()

-- | Run the provided computation by returning its result, and run any
--   finalizers. Watch out: this function might leak finalized resources.
lowerManagedT :: Monad m => ManagedT m a -> m a
hoistManagedTReaderT :: Monad m => r -> ManagedT (ReaderT r m) a -> ManagedT m a
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.Managed.ManagedT
instance Control.Monad.Reader.Class.MonadReader s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Managed.ManagedT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Managed.ManagedT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Managed.ManagedT m)
instance GHC.Base.Monad (Control.Monad.Trans.Managed.ManagedT m)
instance GHC.Base.Applicative (Control.Monad.Trans.Managed.ManagedT m)
instance GHC.Base.Functor (Control.Monad.Trans.Managed.ManagedT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.Fix.MonadFix (Control.Monad.Trans.Managed.ManagedT m)


-- | MSSQL Connection Pooling
module Database.MSSQL.Pool

-- | ODBC connection string for MSSQL server
newtype ConnectionString
ConnectionString :: Text -> ConnectionString
[unConnectionString] :: ConnectionString -> Text
data ConnectionOptions
ConnectionOptionsPool :: PoolOptions -> ConnectionOptions
ConnectionOptionsNoPool :: ConnectionOptions
data PoolOptions
PoolOptions :: Int -> Int -> Int -> PoolOptions
[poConnections] :: PoolOptions -> Int
[poStripes] :: PoolOptions -> Int
[poIdleTime] :: PoolOptions -> Int

-- | ODBC connection pool
data MSSQLPool
MSSQLPool :: Pool Connection -> MSSQLPool
MSSQLNoPool :: IO Connection -> MSSQLPool

-- | Initialize an MSSQL pool with given connection configuration
initMSSQLPool :: ConnectionString -> ConnectionOptions -> IO MSSQLPool

-- | Destroy all pool resources
drainMSSQLPool :: MSSQLPool -> IO ()
withMSSQLPool :: MonadBaseControl IO m => MSSQLPool -> (Connection -> m a) -> m (Either ODBCException a)

-- | Resize a pool
resizePool :: MSSQLPool -> Int -> IO ()
getInUseConnections :: MSSQLPool -> IO Int
instance GHC.Generics.Generic Database.MSSQL.Pool.ConnectionString
instance Data.Aeson.Types.FromJSON.FromJSON Database.MSSQL.Pool.ConnectionString
instance Data.Aeson.Types.ToJSON.ToJSON Database.MSSQL.Pool.ConnectionString
instance GHC.Classes.Eq Database.MSSQL.Pool.ConnectionString
instance GHC.Show.Show Database.MSSQL.Pool.ConnectionString
instance GHC.Classes.Eq Database.MSSQL.Pool.PoolOptions
instance GHC.Show.Show Database.MSSQL.Pool.PoolOptions
instance GHC.Classes.Eq Database.MSSQL.Pool.ConnectionOptions
instance GHC.Show.Show Database.MSSQL.Pool.ConnectionOptions
instance Autodocodec.Class.HasCodec Database.MSSQL.Pool.ConnectionString

module Database.MSSQL.Transaction

-- | The transaction command to run, parameterised over: e - the exception
--   type (usually <a>MSSQLTxError</a>) m - some Monad, (usually some
--   <a>MonadIO</a>) a - the successful result type
newtype TxET e m a
TxET :: ReaderT Connection (ExceptT e m) a -> TxET e m a
[txHandler] :: TxET e m a -> ReaderT Connection (ExceptT e m) a

-- | Error type generally used in <a>TxET</a>.
data MSSQLTxError
MSSQLQueryError :: !Query -> !ODBCException -> MSSQLTxError
MSSQLConnError :: !ODBCException -> MSSQLTxError
MSSQLInternal :: !Text -> MSSQLTxError
type TxE e a = TxET e IO a

-- | The transaction command to run, returning an MSSQLTxError or the
--   result.
type TxT m a = TxET MSSQLTxError m a

-- | Run a command on the given connection wrapped in a transaction.
--   
--   See <a>runTxE</a> if you need to map the error type as well.
runTx :: (MonadIO m, MonadBaseControl IO m) => TxIsolation -> TxT m a -> MSSQLPool -> ExceptT MSSQLTxError m a

-- | Run a command on the given connection wrapped in a transaction.
runTxE :: (MonadIO m, MonadBaseControl IO m) => (MSSQLTxError -> e) -> TxIsolation -> TxET e m a -> MSSQLPool -> ExceptT e m a

-- | Useful for building transactions which return no data.
--   
--   <pre>
--   insertId :: TxT m ()
--   insertId = unitQuery "INSERT INTO some_table VALUES (1, "hello")"
--   </pre>
--   
--   See <a>unitQueryE</a> if you need to map the error type as well.
unitQuery :: MonadIO m => Query -> TxT m ()

-- | Useful for building transactions which return no data.
unitQueryE :: MonadIO m => (MSSQLTxError -> e) -> Query -> TxET e m ()

-- | Useful for building query transactions which return a single one row.
--   
--   <pre>
--   returnOne :: TxT m Int
--   returnOne = singleRowQuery "SELECT 1"
--   </pre>
--   
--   See <a>singleRowQueryE</a> if you need to map the error type as well.
singleRowQuery :: forall a m. (MonadIO m, FromRow a) => Query -> TxT m a

-- | Useful for building query transactions which return a single one row.
singleRowQueryE :: forall m a e. (MonadIO m, FromRow a) => (MSSQLTxError -> e) -> Query -> TxET e m a

-- | MSSQL splits up results that have a <tt>SELECT .. FOR JSON</tt> at the
--   top-level into multiple rows with a single column, see
--   <a>https://docs.microsoft.com/en-us/sql/relational-databases/json/format-query-results-as-json-with-for-json-sql-server?view=sql-server-ver15#output-of-the-for-json-clause</a>
--   
--   This function simply concatenates each single-column row into one long
--   <a>Text</a> string.
forJsonQueryE :: forall m e. MonadIO m => (MSSQLTxError -> e) -> Query -> TxET e m Text

-- | Useful for building query transactions which return multiple rows.
--   
--   <pre>
--   selectIds :: TxT m [Int]
--   selectIds = multiRowQuery "SELECT id FROM author"
--   </pre>
--   
--   See <a>multiRowQueryE</a> if you need to map the error type as well.
multiRowQuery :: forall a m. (MonadIO m, FromRow a) => Query -> TxT m [a]

-- | Useful for building query transactions which return multiple rows.
multiRowQueryE :: forall m a e. (MonadIO m, FromRow a) => (MSSQLTxError -> e) -> Query -> TxET e m [a]

-- | Build a generic transaction out of an IO action.
buildGenericQueryTxE :: MonadIO m => (MSSQLTxError -> e) -> query -> (query -> Query) -> (Connection -> query -> IO a) -> TxET e m a

-- | Map the error type for a <a>TxET</a>.
withTxET :: Monad m => (e1 -> e2) -> TxET e1 m a -> TxET e2 m a

-- | 
--   <a>https://learn.microsoft.com/en-us/sql/t-sql/statements/set-transaction-isolation-level-transact-sql</a>
data TxIsolation
ReadUncommitted :: TxIsolation
ReadCommitted :: TxIsolation
RepeatableRead :: TxIsolation
Snapshot :: TxIsolation
Serializable :: TxIsolation
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Database.MSSQL.Transaction.TxET e m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Database.ODBC.Internal.Connection (Database.MSSQL.Transaction.TxET e m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Database.MSSQL.Transaction.TxET e m)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError e (Database.MSSQL.Transaction.TxET e m)
instance GHC.Base.Monad m => GHC.Base.Monad (Database.MSSQL.Transaction.TxET e m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Database.MSSQL.Transaction.TxET e m)
instance GHC.Base.Functor m => GHC.Base.Functor (Database.MSSQL.Transaction.TxET e m)
instance GHC.Show.Show Database.MSSQL.Transaction.MSSQLTxError
instance GHC.Classes.Eq Database.MSSQL.Transaction.MSSQLTxError
instance GHC.Show.Show Database.MSSQL.Transaction.MSSQLResult
instance GHC.Classes.Eq Database.MSSQL.Transaction.MSSQLResult
instance GHC.Generics.Generic Database.MSSQL.Transaction.TxIsolation
instance GHC.Classes.Eq Database.MSSQL.Transaction.TxIsolation
instance Control.Monad.Base.MonadBase GHC.Types.IO m => Control.Monad.Base.MonadBase GHC.Types.IO (Database.MSSQL.Transaction.TxET e m)
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m => Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO (Database.MSSQL.Transaction.TxET e m)
instance GHC.Show.Show Database.MSSQL.Transaction.TxIsolation
instance Data.Hashable.Class.Hashable Database.MSSQL.Transaction.TxIsolation
instance Control.DeepSeq.NFData Database.MSSQL.Transaction.TxIsolation
instance Autodocodec.Class.HasCodec Database.MSSQL.Transaction.TxIsolation
instance Data.Aeson.Types.ToJSON.ToJSON Database.MSSQL.Transaction.TxIsolation
instance Data.Aeson.Types.FromJSON.FromJSON Database.MSSQL.Transaction.TxIsolation
instance Control.Monad.Morph.MFunctor (Database.MSSQL.Transaction.TxET e)
instance Control.Monad.Trans.Class.MonadTrans (Database.MSSQL.Transaction.TxET e)

module Hasura.Backends.BigQuery.Name
_Bytes :: Name
_Date :: Name
_Datetime :: Name
_Geography :: Name
_Time :: Name
_Timestamp :: Name

module Hasura.Backends.BigQuery.Source
newtype BigQueryProjectId
BigQueryProjectId :: Text -> BigQueryProjectId
[getBigQueryProjectId] :: BigQueryProjectId -> Text
newtype BigQueryDataset
BigQueryDataset :: Text -> BigQueryDataset
[getBigQueryDataset] :: BigQueryDataset -> Text
data PKey
newtype GoogleAccessToken
GoogleAccessToken :: Text -> GoogleAccessToken
data TokenResp
TokenResp :: GoogleAccessToken -> Integer -> TokenResp
[_trAccessToken] :: TokenResp -> GoogleAccessToken
[_trExpiresAt] :: TokenResp -> Integer
data ServiceAccount
ServiceAccount :: Text -> PKey -> BigQueryProjectId -> ServiceAccount
[_saClientEmail] :: ServiceAccount -> Text
[_saPrivateKey] :: ServiceAccount -> PKey
[_saProjectId] :: ServiceAccount -> BigQueryProjectId
data ConfigurationJSON a
FromEnvJSON :: Text -> ConfigurationJSON a
FromYamlJSON :: a -> ConfigurationJSON a

-- | Configuration inputs when they are a YAML array or an Env var whose
--   value is a comma-separated string
data ConfigurationInputs
FromYamls :: [Text] -> ConfigurationInputs
FromEnvs :: Text -> ConfigurationInputs

-- | Configuration input when the YAML value as well as the Env var have
--   singular values
data ConfigurationInput
FromYaml :: Text -> ConfigurationInput
FromEnv :: Text -> ConfigurationInput
data BigQueryConnSourceConfig
BigQueryConnSourceConfig :: ConfigurationJSON ServiceAccount -> ConfigurationInputs -> ConfigurationInput -> Maybe ConfigurationInput -> Maybe ConfigurationInput -> Maybe ConfigurationInput -> BigQueryConnSourceConfig
[_cscServiceAccount] :: BigQueryConnSourceConfig -> ConfigurationJSON ServiceAccount
[_cscDatasets] :: BigQueryConnSourceConfig -> ConfigurationInputs
[_cscProjectId] :: BigQueryConnSourceConfig -> ConfigurationInput
[_cscGlobalSelectLimit] :: BigQueryConnSourceConfig -> Maybe ConfigurationInput
[_cscRetryBaseDelay] :: BigQueryConnSourceConfig -> Maybe ConfigurationInput
[_cscRetryLimit] :: BigQueryConnSourceConfig -> Maybe ConfigurationInput
data RetryOptions
RetryOptions :: Microseconds -> Int -> RetryOptions
[_retryBaseDelay] :: RetryOptions -> Microseconds
[_retryNumRetries] :: RetryOptions -> Int
data BigQueryConnection
BigQueryConnection :: ServiceAccount -> BigQueryProjectId -> Maybe RetryOptions -> MVar (Maybe TokenResp) -> BigQueryConnection
[_bqServiceAccount] :: BigQueryConnection -> ServiceAccount
[_bqProjectId] :: BigQueryConnection -> BigQueryProjectId
[_bqRetryOptions] :: BigQueryConnection -> Maybe RetryOptions
[_bqAccessTokenMVar] :: BigQueryConnection -> MVar (Maybe TokenResp)
data BigQuerySourceConfig
BigQuerySourceConfig :: BigQueryConnection -> [BigQueryDataset] -> Int64 -> BigQuerySourceConfig
[_scConnection] :: BigQuerySourceConfig -> BigQueryConnection
[_scDatasets] :: BigQuerySourceConfig -> [BigQueryDataset]
[_scGlobalSelectLimit] :: BigQuerySourceConfig -> Int64
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance Data.Data.Data Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQueryProjectId
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Data.Data.Data Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.BigQueryDataset
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.BigQueryDataset
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.PKey
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.PKey
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.PKey
instance Data.Data.Data Hasura.Backends.BigQuery.Source.PKey
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.PKey
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.PKey
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Data.Data Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.GoogleAccessToken
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.TokenResp
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.TokenResp
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.TokenResp
instance Data.Data.Data Hasura.Backends.BigQuery.Source.TokenResp
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.TokenResp
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.TokenResp
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.ServiceAccount
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.ServiceAccount
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.ServiceAccount
instance Data.Data.Data Hasura.Backends.BigQuery.Source.ServiceAccount
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.ServiceAccount
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.ServiceAccount
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance GHC.Generics.Generic (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.ConfigurationInput
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.ConfigurationInput
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.ConfigurationInput
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.RetryOptions
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQueryConnection
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Source.BigQuerySourceConfig
instance GHC.Generics.Generic Crypto.PubKey.RSA.Types.PrivateKey
instance GHC.Generics.Generic Crypto.PubKey.RSA.Types.PublicKey
instance Data.Aeson.Types.ToJSON.ToJSON Crypto.PubKey.RSA.Types.PrivateKey
instance Data.Aeson.Types.ToJSON.ToJSON Crypto.PubKey.RSA.Types.PublicKey
instance Data.Hashable.Class.Hashable Crypto.PubKey.RSA.Types.PrivateKey
instance Data.Hashable.Class.Hashable Crypto.PubKey.RSA.Types.PublicKey
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance GHC.Show.Show Hasura.Backends.BigQuery.Source.BigQuerySourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.BigQuerySourceConfig
instance Data.Has.Has () Hasura.Backends.BigQuery.Source.BigQuerySourceConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.BigQueryConnSourceConfig
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.ConfigurationInput
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.ConfigurationInputs
instance Autodocodec.Class.HasCodec a => Autodocodec.Class.HasCodec (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.BigQuery.Source.ConfigurationJSON a)
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.ServiceAccount
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.ServiceAccount
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.ServiceAccount
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.TokenResp
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.PKey
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Source.PKey
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Source.PKey
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.BigQueryDataset
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Source.BigQueryProjectId


-- | Functions and datatypes for interpreting MSSQL database errors.
module Hasura.Backends.MSSQL.SQL.Error

-- | The top-level error class. Errors in MSSQL are divided into different
--   <i>classes</i>, which are further subdivided into individual error
--   subclasses. It is useful to determine the class of database exception
--   and handle it appropriately.
data ErrorClass
DataException :: ErrorSubclass DataExceptionSubclass -> ErrorClass
IntegrityConstraintViolation :: ErrorClass
SyntaxErrorOrAccessViolation :: ErrorSubclass SyntaxErrorOrAccessViolationSubclass -> ErrorClass
data ErrorSubclass a

-- | represents non-specific <tt>000</tt> subclass code
NoSubclass :: ErrorSubclass a

-- | represents known, more specific sub class
Subclass :: a -> ErrorSubclass a
data DataExceptionSubclass
StringDataRightTruncated :: DataExceptionSubclass
NumericValueOutOfRange :: DataExceptionSubclass
InvalidDatetimeFormat :: DataExceptionSubclass
DatetimeFieldOverflow :: DataExceptionSubclass
IntervalFieldOverflow :: DataExceptionSubclass
InvalidEscapeCharacter :: DataExceptionSubclass
InvalidEscapeSequence :: DataExceptionSubclass
data SyntaxErrorOrAccessViolationSubclass
TableOrViewAlreadyExists :: SyntaxErrorOrAccessViolationSubclass
TableOrViewNotFound :: SyntaxErrorOrAccessViolationSubclass
IndexAlreadyExists :: SyntaxErrorOrAccessViolationSubclass
IndexNotFound :: SyntaxErrorOrAccessViolationSubclass
ColumnAlreadyExists :: SyntaxErrorOrAccessViolationSubclass
ColumnNotFound :: SyntaxErrorOrAccessViolationSubclass

-- | Parsing error class and subclass information from a SQLSTATE code.
--   SQLSTATE provides detailed information about the cause of a warning or
--   error. A SQLSTATE consists of 5 chars. They are divided into two
--   parts: the first and second chars contain a class and the following
--   three a subclass.
parseErrorClass :: String -> Maybe ErrorClass

-- | A default transaction error handler where all errors are unexpected.
defaultMSSQLTxErrorHandler :: MSSQLTxError -> QErr

-- | A transaction error handler to be used in constructing mutation
--   transactions, i.e INSERT, UPDATE and DELETE. We expect data exception
--   and integrity constraint violation.
mutationMSSQLTxErrorHandler :: MSSQLTxError -> QErr

-- | Constructs a transaction error handler given a predicate that
--   determines which error classes (and subclasses) are expected and
--   should be reported to the user. All other errors are considered
--   internal errors. Example:- Consider a insert mutation where we insert
--   some data into columns of a table. Except for the basic data type,
--   such as Boolean, String, Float, Int etc. we cannot invalidate data any
--   further, such as validating timestamp string format. In this case, a
--   @<a>DataException</a> is expected from the database and it is handled
--   and thrown with proper error message.
mkMSSQLTxErrorHandler :: (ErrorClass -> Bool) -> MSSQLTxError -> QErr
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.MSSQL.SQL.Error.ErrorSubclass a)
instance GHC.Classes.Eq Hasura.Backends.MSSQL.SQL.Error.DataExceptionSubclass
instance GHC.Classes.Eq Hasura.Backends.MSSQL.SQL.Error.SyntaxErrorOrAccessViolationSubclass
instance GHC.Classes.Eq Hasura.Backends.MSSQL.SQL.Error.ErrorClass
instance GHC.Show.Show Hasura.Backends.MSSQL.SQL.Error.ErrorClass
instance GHC.Show.Show Hasura.Backends.MSSQL.SQL.Error.SyntaxErrorOrAccessViolationSubclass
instance GHC.Show.Show Hasura.Backends.MSSQL.SQL.Error.DataExceptionSubclass


-- | Postgres SQL Error
--   
--   Functions and datatypes for interpreting Postgres errors.
module Hasura.Backends.Postgres.SQL.Error

-- | The top-level error code type. Errors in Postgres are divided into
--   different <i>classes</i>, which are further subdivided into individual
--   error codes. Even if a particular status code is not known to the
--   application, itâ€™s possible to determine its class and handle it
--   appropriately.
data PGErrorType
PGDataException :: Maybe (PGErrorCode PGDataException) -> PGErrorType
PGIntegrityConstraintViolation :: Maybe (PGErrorCode PGIntegrityConstraintViolation) -> PGErrorType
PGSyntaxErrorOrAccessRuleViolation :: Maybe (PGErrorCode PGSyntaxErrorOrAccessRuleViolation) -> PGErrorType
PGTransactionRollback :: Maybe (PGErrorCode PGTransactionRollback) -> PGErrorType
data PGErrorCode a

-- | represents errors that have the non-specific <tt>000</tt> status code
PGErrorGeneric :: PGErrorCode a

-- | represents errors with a known, more specific status code
PGErrorSpecific :: a -> PGErrorCode a
data PGDataException
PGInvalidDatetimeFormat :: PGDataException
PGInvalidParameterValue :: PGDataException
PGInvalidEscapeSequence :: PGDataException
PGInvalidTextRepresentation :: PGDataException
data PGIntegrityConstraintViolation
PGRestrictViolation :: PGIntegrityConstraintViolation
PGNotNullViolation :: PGIntegrityConstraintViolation
PGForeignKeyViolation :: PGIntegrityConstraintViolation
PGUniqueViolation :: PGIntegrityConstraintViolation
PGCheckViolation :: PGIntegrityConstraintViolation
PGExclusionViolation :: PGIntegrityConstraintViolation
data PGSyntaxErrorOrAccessRuleViolation
PGUndefinedObject :: PGSyntaxErrorOrAccessRuleViolation
PGInvalidColumnReference :: PGSyntaxErrorOrAccessRuleViolation
data PGTransactionRollback
PGSerializationFailure :: PGTransactionRollback
_PGTransactionRollback :: Prism' PGErrorType (Maybe (PGErrorCode PGTransactionRollback))
_PGSyntaxErrorOrAccessRuleViolation :: Prism' PGErrorType (Maybe (PGErrorCode PGSyntaxErrorOrAccessRuleViolation))
_PGIntegrityConstraintViolation :: Prism' PGErrorType (Maybe (PGErrorCode PGIntegrityConstraintViolation))
_PGDataException :: Prism' PGErrorType (Maybe (PGErrorCode PGDataException))
_PGErrorSpecific :: forall a_a18EF a_a18ih. Prism (PGErrorCode a_a18EF) (PGErrorCode a_a18ih) a_a18EF a_a18ih
_PGErrorGeneric :: forall a_a18ih. Prism' (PGErrorCode a_a18ih) ()
pgErrorType :: PGStmtErrDetail -> Maybe PGErrorType
instance GHC.Base.Functor Hasura.Backends.Postgres.SQL.Error.PGErrorCode
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.SQL.Error.PGErrorCode a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.Postgres.SQL.Error.PGErrorCode a)
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGDataException
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Error.PGDataException
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGIntegrityConstraintViolation
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Error.PGIntegrityConstraintViolation
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGSyntaxErrorOrAccessRuleViolation
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Error.PGSyntaxErrorOrAccessRuleViolation
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGTransactionRollback
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Error.PGTransactionRollback
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Error.PGErrorType
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Error.PGErrorType


-- | graphql-engine used to have a query plan cache, which cached the
--   execution plan for a given graphql query (sans JSON variable values).
--   After the PDV refactor (see <a>hasura/graphql-engine#4111</a>), this
--   query plan cache was not needed anymore. For backwards compatibility
--   reasons, we still need to parse the configuration options from the
--   CLI, although the CLI option gets ignored.
--   
--   Eventually, we can decide to stop parsing the CLI option
--   --query-plan-cache-size, at which point this module can be removed.
module Hasura.Cache.Bounded
newtype CacheSize
CacheSize :: Word16 -> CacheSize
[unCacheSize] :: CacheSize -> Word16
parseCacheSize :: String -> Either String CacheSize
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Cache.Bounded.CacheSize
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Cache.Bounded.CacheSize
instance GHC.Enum.Enum Hasura.Cache.Bounded.CacheSize
instance GHC.Real.Integral Hasura.Cache.Bounded.CacheSize
instance GHC.Real.Real Hasura.Cache.Bounded.CacheSize
instance GHC.Num.Num Hasura.Cache.Bounded.CacheSize
instance GHC.Enum.Bounded Hasura.Cache.Bounded.CacheSize
instance GHC.Classes.Ord Hasura.Cache.Bounded.CacheSize
instance GHC.Classes.Eq Hasura.Cache.Bounded.CacheSize
instance GHC.Read.Read Hasura.Cache.Bounded.CacheSize
instance GHC.Show.Show Hasura.Cache.Bounded.CacheSize


-- | Interface for a service for maintaining short-lived credentials, such
--   as access tokens or JWTs.
module Hasura.CredentialCache
newtype CredentialCache cred
CredentialCache :: STM (cred, STM (STM ())) -> CredentialCache cred

-- | Get the stored credential. Also returns an STM action for requesting a
--   refresh of the credential, which, in turn, returns an STM action for
--   waiting on the arrival of the fresh credential.
[getCredential] :: CredentialCache cred -> STM (cred, STM (STM ()))
instance GHC.Base.Functor Hasura.CredentialCache.CredentialCache

module Hasura.GraphQL.Execute.Subscription.Options
data SubscriptionsOptions
SubscriptionsOptions :: !BatchSize -> !RefetchInterval -> SubscriptionsOptions
[_lqoBatchSize] :: SubscriptionsOptions -> !BatchSize
[_lqoRefetchInterval] :: SubscriptionsOptions -> !RefetchInterval
type LiveQueriesOptions = SubscriptionsOptions
type StreamQueriesOptions = SubscriptionsOptions
mkSubscriptionsOptions :: Maybe BatchSize -> Maybe RefetchInterval -> SubscriptionsOptions
newtype BatchSize
BatchSize :: Refined NonNegative Int -> BatchSize
[unBatchSize] :: BatchSize -> Refined NonNegative Int
mkBatchSize :: Int -> Maybe BatchSize
newtype RefetchInterval
RefetchInterval :: Refined NonNegative DiffTime -> RefetchInterval
[unRefetchInterval] :: RefetchInterval -> Refined NonNegative DiffTime
mkRefetchInterval :: DiffTime -> Maybe RefetchInterval
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Options.SubscriptionsOptions

module Hasura.GraphQL.Execute.Subscription.TMap

-- | A coarse-grained transactional map implemented by simply wrapping a
--   <a>HashMap</a> in a <a>TVar</a>. Compared to <a>StmContainers.Map</a>,
--   this provides much faster iteration over the elements at the cost of
--   significantly increased contention on writes.
data TMap k v
new :: STM (TMap k v)
reset :: TMap k v -> STM ()
null :: TMap k v -> STM Bool
lookup :: Hashable k => k -> TMap k v -> STM (Maybe v)
insert :: Hashable k => v -> k -> TMap k v -> STM ()
delete :: Hashable k => k -> TMap k v -> STM ()
toList :: TMap k v -> STM [(k, v)]
filterWithKey :: (k -> v -> Bool) -> TMap k v -> STM ()
replace :: TMap k v -> HashMap k v -> STM ()
union :: Hashable k => TMap k v -> TMap k v -> STM (TMap k v)
getMap :: TMap k v -> STM (HashMap k v)
adjust :: Hashable k => (v -> v) -> k -> TMap k v -> STM ()

module Hasura.GraphQL.Execute.Types
data GraphQLQueryType
QueryHasura :: GraphQLQueryType
QueryRelay :: GraphQLQueryType
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance GHC.Classes.Ord Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance GHC.Show.Show Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Types.GraphQLQueryType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Types.GraphQLQueryType

module Hasura.GraphQL.Schema.Typename

-- | Type name customization
newtype MkTypename
MkTypename :: (Name -> Name) -> MkTypename
[runMkTypename] :: MkTypename -> Name -> Name

-- | Inject a new <tt>MkTypename</tt> customization function into the
--   environment. This can be used by schema-building code (with
--   <tt>MonadBuildSchema</tt> constraint) to ensure the correct type name
--   customizations are applied.
withTypenameCustomization :: forall m r a. (MonadReader r m, Has MkTypename r) => MkTypename -> m a -> m a
instance GHC.Base.Monoid Hasura.GraphQL.Schema.Typename.MkTypename
instance GHC.Base.Semigroup Hasura.GraphQL.Schema.Typename.MkTypename


-- | We are in the process of building DTO types incrementally. We use
--   placeholder types in positions in data structures that are not
--   fully-defined yet. For example <a>PlaceholderObject</a> represents
--   some unspecified JSON object, and <a>PlaceholderArray</a> represents
--   an array whose contents are not yet specified.
--   
--   We are transitioning from converting <a>Metadata</a> directly to JSON
--   to converting it to <a>MetadataDTO</a> instead. Serialization and
--   deserialization for placeholder values is delegated to the old JSON
--   serialization code.
module Hasura.Metadata.DTO.Placeholder

-- | Stands in for an array that we have not had time to fully specify yet.
--   Generated OpenAPI documentation for <a>PlaceholderArray</a> will
--   permit an array of values of any type, and a note will be appended to
--   the documentation string for the value explaining that this is a
--   temporary placeholder.
newtype PlaceholderArray
PlaceholderArray :: Array -> PlaceholderArray

-- | Stands in for an object that we have not had time to fully specify
--   yet. Generated OpenAPI documentation for <a>PlaceholderObject</a> will
--   permit an object with any keys with any types of values. A note will
--   be appended to the documentation string for the value explaining that
--   this is a temporary placeholder.
newtype PlaceholderObject
PlaceholderObject :: Object -> PlaceholderObject
class IsPlaceholder p a | a -> p

-- | Use this function to mark an Aeson type (Array or Object) as a
--   temporary placeholder in a larger data structure.
placeholder :: IsPlaceholder p a => a -> p

-- | This placeholder can be used in a codec to represent any type of data
--   that has <a>FromJSON</a> and <a>ToJSON</a> instances. Generated
--   OpenAPI specifications based on this codec will not show any
--   information about the internal structure of the type so ideally uses
--   of this placeholder should eventually be replaced with more
--   descriptive codecs.
placeholderCodecViaJSON :: (FromJSON a, ToJSON a) => JSONCodec a
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance GHC.Generics.Generic Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance GHC.Classes.Eq Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance GHC.Show.Show Hasura.Metadata.DTO.Placeholder.PlaceholderArray
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance GHC.Generics.Generic Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance GHC.Classes.Eq Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance GHC.Show.Show Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderArray Data.Aeson.Types.Internal.Array
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderObject Data.Aeson.Types.Internal.Object
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderArray Data.Aeson.Ordered.Array
instance Hasura.Metadata.DTO.Placeholder.IsPlaceholder Hasura.Metadata.DTO.Placeholder.PlaceholderObject Data.Aeson.Ordered.Object
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.Placeholder.PlaceholderObject
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.Placeholder.PlaceholderArray

module Hasura.Metadata.DTO.MetadataV2

-- | Revision 2 of the Metadata export format. Note that values of the
--   types, <a>PlaceholderArray</a> and <a>PlaceholderObject</a> are
--   placeholders that will eventually be expanded to represent more
--   detail.
data MetadataV2
MetadataV2 :: Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderObject -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> Maybe PlaceholderArray -> PlaceholderArray -> MetadataV2
[metaV2Actions] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2Allowlist] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2CronTriggers] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2CustomTypes] :: MetadataV2 -> Maybe PlaceholderObject
[metaV2Functions] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2QueryCollections] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2RemoteSchemas] :: MetadataV2 -> Maybe PlaceholderArray
[metaV2Tables] :: MetadataV2 -> PlaceholderArray
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance GHC.Generics.Generic Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance GHC.Classes.Eq Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance GHC.Show.Show Hasura.Metadata.DTO.MetadataV2.MetadataV2
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.MetadataV2.MetadataV2

module Hasura.Metadata.DTO.MetadataV1

-- | Revision 1 of the Metadata export format. Note that values of the
--   types, <a>PlaceholderArray</a> and <tt>PlaceholderObject</tt> are
--   placeholders that will eventually be expanded to represent more
--   detail.
data MetadataV1
MetadataV1 :: Maybe PlaceholderArray -> Maybe PlaceholderArray -> PlaceholderArray -> MetadataV1
[metaV1Functions] :: MetadataV1 -> Maybe PlaceholderArray
[metaV1RemoteSchemas] :: MetadataV1 -> Maybe PlaceholderArray
[metaV1Tables] :: MetadataV1 -> PlaceholderArray
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance GHC.Generics.Generic Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance GHC.Classes.Eq Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance GHC.Show.Show Hasura.Metadata.DTO.MetadataV1.MetadataV1
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.MetadataV1.MetadataV1


-- | QuasiQuoted GraphQL constants used througout the codebase. By moving
--   all the Quasiquotes here we can eliminate extraneous rebuilds of
--   larger modules.
--   
--   See:
--   <a>https://www.parsonsmatt.org/2021/07/12/template_haskell_performance_tips.html#recompilation-avoidance</a>
module Hasura.Name
__ :: Name
_no_queries_available :: Name
__mutation_backend :: Name
__mutation_frontend :: Name
__query :: Name
__subscription :: Name
_preset :: Name
_static :: Name
_value :: Name
_Bool :: Name
_Double :: Name
_float8 :: Name
_Number :: Name
_numeric :: Name
_mutation_root :: Name
_query_root :: Name
_subscription_root :: Name
__enum :: Name
__scalar :: Name
_id :: Name
_session_variables :: Name
__remote_rel_ :: Name
__bool_exp :: Name
__comparison_exp :: Name
__BigQuery_comparison_exp :: Name
__MSSQL_comparison_exp :: Name
__cast :: Name
__cast_exp :: Name
__is_null :: Name
__eq :: Name
__neq :: Name
__in :: Name
__nin :: Name
__gt :: Name
__gte :: Name
__lt :: Name
__lte :: Name
__contains :: Name
__matches :: Name
__ancestor :: Name
__descendant :: Name
__like :: Name
__ilike :: Name
__nlike :: Name
__nilike :: Name
__similar :: Name
__nsimilar :: Name
__regex :: Name
__nregex :: Name
__niregex :: Name
__iregex :: Name
__and :: Name
__not :: Name
__or :: Name
_aggregate :: Name
_aggregate_bool_exp :: Name
_column :: Name
_columns :: Name
_nodes :: Name
_avg :: Name
_count :: Name
_stddev :: Name
_stddev_pop :: Name
_stddev_samp :: Name
_sum :: Name
_var_pop :: Name
_var_samp :: Name
_variance :: Name
__aggregate :: Name
__aggregate_fields :: Name
__fields :: Name
_group_by :: Name
_keys :: Name
_group_key :: Name
_path :: Name
_args :: Name
__args :: Name
_distinct :: Name
_distinct_on :: Name
__select_column :: Name
_where :: Name
_order_by :: Name
_ASC :: Name
_asc :: Name
_asc_nulls_first :: Name
_asc_nulls_last :: Name
_DESC :: Name
_desc :: Name
_desc_nulls_first :: Name
_desc_nulls_last :: Name
_first :: Name
_last :: Name
_before :: Name
_after :: Name
__aggregate_order_by :: Name
__order_by :: Name
_limit :: Name
_offset :: Name
_distance :: Name
_from :: Name
_geommin :: Name
_nband :: Name
_st_d_within_geography_input :: Name
_st_d_within_input :: Name
_st_intersects_geom_nband_input :: Name
_st_intersects_nband_geom_input :: Name
_st_dwithin_input :: Name
_use_spheroid :: Name
__st_3d_d_within :: Name
__st_3d_intersects :: Name
__st_contains :: Name
__st_crosses :: Name
__st_d_within :: Name
__st_equals :: Name
__st_intersects_geom_nband :: Name
__st_intersects_nband_geom :: Name
__st_intersects_rast :: Name
__st_intersects :: Name
__st_overlaps :: Name
__st_touches :: Name
__st_within :: Name
_constraint :: Name
_if_matched :: Name
_match_columns :: Name
_on_conflict :: Name
_update_columns :: Name
__constraint :: Name
__if_matched :: Name
__on_conflict :: Name
__update_column :: Name
__PLACEHOLDER :: Name
_insert :: Name
_update :: Name
_updates :: Name
_delete :: Name
_affected_rows :: Name
_data :: Name
_object :: Name
_objects :: Name
_one :: Name
_many :: Name
_returning :: Name
_transaction :: Name
__append :: Name
__arr_rel_insert_input :: Name
__delete_at_path :: Name
__delete_elem :: Name
__delete_key :: Name
__insert_input :: Name
__insert_match_column :: Name
__mutation_response :: Name
__prepend :: Name
__obj_rel_insert_input :: Name
_created_at :: Name
_errors :: Name
_output :: Name
_Connection :: Name
_Edge :: Name
_PageInfo :: Name
_batch_size :: Name
_connection :: Name
_cursor :: Name
_cursor_ordering :: Name
_edges :: Name
_initial_value :: Name
_node :: Name
_ordering :: Name
_pageInfo :: Name
_stream :: Name
_startCursor :: Name
_endCursor :: Name
_hasNextPage :: Name
_hasPreviousPage :: Name
__connection :: Name
__stream_cursor_input :: Name
__stream_cursor_value_input :: Name
_Node :: Name
___hasura_internal_typename :: Name
__service :: Name
_key :: Name
_fields :: Name
_representations :: Name
__Any :: Name
_sdl :: Name
__Service :: Name
__Entity :: Name
__entities :: Name
_arguments :: Name
_predicate :: Name
_filter :: Name
__array :: Name


-- | Tools to analyze the structure of a GraphQL request.
module Hasura.GraphQL.Analyse

-- | Overall structure of a given query. We extract the tree of fields in
--   the output, and the graph of input variables.
data Structure
Structure :: HashMap Name FieldInfo -> HashMap Name VariableInfo -> Structure
[_stSelection] :: Structure -> HashMap Name FieldInfo
[_stVariables] :: Structure -> HashMap Name VariableInfo

-- | Information about the type of an output field; whether the base type
--   is an object or a scalar, we store the correspoding <tt>GType</tt> to
--   keep track of the modifiers applied to it (list or non-nullability).
data FieldInfo
FieldObjectInfo :: GType -> ObjectInfo -> FieldInfo
FieldScalarInfo :: GType -> ScalarInfo -> FieldInfo
FieldEnumInfo :: GType -> EnumInfo -> FieldInfo
data ScalarInfo
ScalarInfo :: ScalarTypeDefinition -> ScalarInfo
[_siTypeDefinition] :: ScalarInfo -> ScalarTypeDefinition
data EnumInfo
EnumInfo :: EnumTypeDefinition -> EnumInfo
[_eiTypeDefinition] :: EnumInfo -> EnumTypeDefinition
data ObjectInfo
ObjectInfo :: ObjectTypeDefinition InputValueDefinition -> HashMap Name FieldInfo -> ObjectInfo
[_oiTypeDefinition] :: ObjectInfo -> ObjectTypeDefinition InputValueDefinition
[_oiSelection] :: ObjectInfo -> HashMap Name FieldInfo

-- | Information about a single variable of the query.
data VariableInfo
VariableInfo :: GType -> InputFieldInfo -> Maybe (Value Void) -> VariableInfo
[_viType] :: VariableInfo -> GType
[_viTypeInfo] :: VariableInfo -> InputFieldInfo
[_viDefaultValue] :: VariableInfo -> Maybe (Value Void)

-- | Information about the type of an input field; whether the base type is
--   an object or a scalar, we store the correspoding <tt>GType</tt> to
--   keep track of the modifiers applied to it (list or non-nullability).
data InputFieldInfo
InputFieldScalarInfo :: ScalarInfo -> InputFieldInfo
InputFieldEnumInfo :: EnumInfo -> InputFieldInfo
InputFieldObjectInfo :: InputObjectInfo -> InputFieldInfo
data InputObjectInfo
InputObjectInfo :: InputObjectTypeDefinition InputValueDefinition -> ~HashMap Name (GType, InputFieldInfo) -> InputObjectInfo
[_ioiTypeDefinition] :: InputObjectInfo -> InputObjectTypeDefinition InputValueDefinition

-- | lazy for knot-tying, as we build a graph
[_ioiFields] :: InputObjectInfo -> ~HashMap Name (GType, InputFieldInfo)

-- | Given the schema's definition, and a query, validate that the query is
--   consistent. We do this by running the analysis, but discarding the
--   result: we do not care about the structure, only about the validity of
--   the query.
--   
--   Returns <a>Nothing</a> if the query is valid, or a list of messages
--   otherwise.
diagnoseGraphQLQuery :: SchemaIntrospection -> TypedOperationDefinition NoFragments Name -> Maybe [Text]

-- | Given the schema's definition, and a query, run the analysis.
--   
--   We process all possible fields, and return a partially filled
--   structure if necessary. Given the following query:
--   
--   <pre>
--   query {
--     foo {
--       bar
--     }
--     does_not_exist {
--       ghsdflgh
--     }
--   }
--   </pre>
--   
--   We would return a structure containing:
--   
--   <pre>
--   foo: {
--     bar: {
--     }
--   }
--   </pre>
--   
--   AND an error about "does_not_exist" not existing.
--   
--   In some cases, however, we might not be able to produce a structure at
--   all, in which case we return <a>Nothing</a>. This either indicates
--   that something was fundamentally wrong with the structure of the query
--   (such as not finding an object at the top level), or that a
--   recoverable error was not caught properly (see
--   <a>withCatchAndRecord</a>).
analyzeGraphQLQuery :: SchemaIntrospection -> TypedOperationDefinition NoFragments Name -> (Maybe Structure, [Text])
instance Control.Monad.Fix.MonadFix Hasura.GraphQL.Analyse.Analysis
instance Control.Monad.Error.Class.MonadError Hasura.GraphQL.Analyse.AnalysisError Hasura.GraphQL.Analyse.Analysis
instance Control.Monad.Writer.Class.MonadWriter [Hasura.GraphQL.Analyse.AnalysisError] Hasura.GraphQL.Analyse.Analysis
instance Control.Monad.Reader.Class.MonadReader (Hasura.GraphQL.Analyse.Path, Language.GraphQL.Draft.Syntax.SchemaIntrospection) Hasura.GraphQL.Analyse.Analysis
instance GHC.Base.Monad Hasura.GraphQL.Analyse.Analysis
instance GHC.Base.Applicative Hasura.GraphQL.Analyse.Analysis
instance GHC.Base.Functor Hasura.GraphQL.Analyse.Analysis

module Hasura.QueryTags.Types
data QueryTagsFormat
Standard :: QueryTagsFormat
SQLCommenter :: QueryTagsFormat

-- | QueryTagsConfig is the configuration created by the users to control
--   query tags
--   
--   This config let's hasura know about the following: 1. In what format
--   should the query tags be created 2. Should they be appended to the SQL
--   3. Should the request id be part of the query tags (which varies on
--   each request and will cause prepared statements to be re-prepared
--   every time)
--   
--   FWIW, <a>QueryTagsConfig</a> are coupled along with the Source
--   metadata. So you can also think <a>QueryTagsConfig</a> as the query
--   tags configuration for each source.
--   
--   The workflow is something like this:
--   
--   <ol>
--   <li>The <a>QueryTagsConfig</a> for a source is created from the
--   metadata we get from the user.</li>
--   <li>This configuration is packaged (for the lack of better word) along
--   with SourceConfigWith</li>
--   <li>These query tags configuration are extracted from the
--   <tt>SourceConfigWith</tt> in the <tt>mkDBQueryPlan</tt>,
--   <tt>mkDBMutationPlan</tt>, <tt>mkDBSubscriptionPlan</tt> functions and
--   are passed along to the point where the actual SQL generation takes
--   place</li>
--   </ol>
--   
--   Note that, it is important for <a>QueryTagsConfig</a> to be a part of
--   <tt>SourceConfigWith</tt> because that's the only sane way (that we
--   can think of) the `mkDB..Plan` functions can get the QueryTagsConfig.
data QueryTagsConfig
QueryTagsConfig :: !Bool -> !QueryTagsFormat -> !Bool -> QueryTagsConfig
[_qtcDisabled] :: QueryTagsConfig -> !Bool
[_qtcFormat] :: QueryTagsConfig -> !QueryTagsFormat
[_qtcOmitRequestId] :: QueryTagsConfig -> !Bool
defaultQueryTagsConfig :: QueryTagsConfig
instance GHC.Generics.Generic Hasura.QueryTags.Types.QueryTagsFormat
instance GHC.Classes.Eq Hasura.QueryTags.Types.QueryTagsFormat
instance GHC.Show.Show Hasura.QueryTags.Types.QueryTagsFormat
instance GHC.Generics.Generic Hasura.QueryTags.Types.QueryTagsConfig
instance GHC.Classes.Eq Hasura.QueryTags.Types.QueryTagsConfig
instance GHC.Show.Show Hasura.QueryTags.Types.QueryTagsConfig
instance Data.Hashable.Class.Hashable Hasura.QueryTags.Types.QueryTagsConfig
instance Control.DeepSeq.NFData Hasura.QueryTags.Types.QueryTagsConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.QueryTags.Types.QueryTagsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.QueryTags.Types.QueryTagsConfig
instance Autodocodec.Class.HasCodec Hasura.QueryTags.Types.QueryTagsConfig
instance Data.Hashable.Class.Hashable Hasura.QueryTags.Types.QueryTagsFormat
instance Control.DeepSeq.NFData Hasura.QueryTags.Types.QueryTagsFormat
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.QueryTags.Types.QueryTagsFormat
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.QueryTags.Types.QueryTagsFormat
instance Autodocodec.Class.HasCodec Hasura.QueryTags.Types.QueryTagsFormat

module Hasura.RQL.Types.DataConnector

-- | Note: Currently you should not use underscores in this name. This
--   should be enforced in instances, and the <a>mkDataConnectorName</a>
--   smart constructor is available to assist.
data DataConnectorName
mkDataConnectorName :: Name -> Either String DataConnectorName
instance Control.DeepSeq.NFData Hasura.RQL.Types.DataConnector.DataConnectorName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.DataConnector.DataConnectorName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.DataConnector.DataConnectorName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.DataConnector.DataConnectorName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.DataConnector.DataConnectorName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.DataConnector.DataConnectorName
instance GHC.Generics.Generic Hasura.RQL.Types.DataConnector.DataConnectorName
instance GHC.Show.Show Hasura.RQL.Types.DataConnector.DataConnectorName
instance GHC.Classes.Ord Hasura.RQL.Types.DataConnector.DataConnectorName
instance GHC.Classes.Eq Hasura.RQL.Types.DataConnector.DataConnectorName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.DataConnector.DataConnectorName
instance Witch.From.From Hasura.RQL.Types.DataConnector.DataConnectorName Data.Text.NonEmpty.NonEmptyText
instance Witch.From.From Hasura.RQL.Types.DataConnector.DataConnectorName Data.Text.Internal.Text

module Hasura.RQL.Types.BackendType

-- | Argument to Postgres; we represent backends which are variations on
--   Postgres as sub-types of Postgres. This value indicates which
--   "flavour" of Postgres a backend is.
data PostgresKind
Vanilla :: PostgresKind
Citus :: PostgresKind
Cockroach :: PostgresKind

-- | An enum that represents each backend we support.
data BackendType
Postgres :: PostgresKind -> BackendType
MSSQL :: BackendType
BigQuery :: BackendType
DataConnector :: BackendType

-- | Similar to <a>BackendType</a>, however, in the case of
--   <a>DataConnectorKind</a> we need to be able capture the name of the
--   data connector that should be used by the DataConnector backend. This
--   type correlates to the kind property of <tt>SourceMetadata</tt>, which
--   is usually just postgres, mssql, etc for static backends, but can be a
--   configurable value for DataConnector hence requiring
--   <a>DataConnectorName</a> for <a>DataConnectorKind</a>
--   
--   This type cannot entirely replace <a>BackendType</a> because
--   <a>BackendType</a> has a fixed number of possible values which can be
--   enumerated over at compile time, but <a>BackendSourceKind</a> does not
--   because DataConnector fundamentally is configured at runtime with
--   <a>DataConnectorName</a>.
data BackendSourceKind (b :: BackendType)
[PostgresVanillaKind] :: BackendSourceKind ('Postgres 'Vanilla)
[PostgresCitusKind] :: BackendSourceKind ('Postgres 'Citus)
[PostgresCockroachKind] :: BackendSourceKind ('Postgres 'Cockroach)
[MSSQLKind] :: BackendSourceKind 'MSSQL
[BigQueryKind] :: BackendSourceKind 'BigQuery
[DataConnectorKind] :: DataConnectorName -> BackendSourceKind 'DataConnector

-- | Some generated APIs use a shortened version of the backend's name
--   rather than its full name. This function returns the "short form" of a
--   backend, if any.
backendShortName :: BackendType -> Maybe Text
supportedBackends :: [BackendType]
backendTextNames :: BackendType -> [Text]

-- | This uses this lookup mechanism to avoid having to duplicate and
--   hardcode the backend string. We accept both the short form and the
--   long form of the backend's name.
backendTypeFromText :: Text -> Maybe BackendType
parseBackendTypeFromText :: Text -> Parser BackendType
backendTypeFromBackendSourceKind :: BackendSourceKind b -> BackendType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.BackendType.PostgresKind
instance GHC.Generics.Generic Hasura.RQL.Types.BackendType.PostgresKind
instance GHC.Classes.Ord Hasura.RQL.Types.BackendType.PostgresKind
instance GHC.Classes.Eq Hasura.RQL.Types.BackendType.PostgresKind
instance GHC.Show.Show Hasura.RQL.Types.BackendType.PostgresKind
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.BackendType.BackendType
instance GHC.Generics.Generic Hasura.RQL.Types.BackendType.BackendType
instance GHC.Classes.Ord Hasura.RQL.Types.BackendType.BackendType
instance GHC.Classes.Eq Hasura.RQL.Types.BackendType.BackendType
instance GHC.Show.Show Hasura.RQL.Types.BackendType.BackendType
instance GHC.Show.Show (Hasura.RQL.Types.BackendType.BackendSourceKind b)
instance GHC.Classes.Eq (Hasura.RQL.Types.BackendType.BackendSourceKind b)
instance GHC.Classes.Ord (Hasura.RQL.Types.BackendType.BackendSourceKind b)
instance Witch.From.From (Hasura.RQL.Types.BackendType.BackendSourceKind b) Data.Text.NonEmpty.NonEmptyText
instance Data.Text.Extended.ToTxt (Hasura.RQL.Types.BackendType.BackendSourceKind b)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.BackendType.BackendSourceKind b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Vanilla))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Citus))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Cockroach))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.MSSQL)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.BigQuery)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.DataConnector)
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Vanilla))
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Citus))
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Cockroach))
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.MSSQL)
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.BigQuery)
instance Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind 'Hasura.RQL.Types.BackendType.DataConnector)
instance Witch.From.From Hasura.RQL.Types.BackendType.BackendType Data.Text.NonEmpty.NonEmptyText
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.BackendType.BackendType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.BackendType.BackendType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.BackendType.BackendType

module Hasura.RQL.Types.BackendTag

-- | A singleton-like GADT that associates a tag to each backend.
data BackendTag (b :: BackendType)
[PostgresVanillaTag] :: BackendTag ('Postgres 'Vanilla)
[PostgresCitusTag] :: BackendTag ('Postgres 'Citus)
[PostgresCockroachTag] :: BackendTag ('Postgres 'Cockroach)
[MSSQLTag] :: BackendTag 'MSSQL
[BigQueryTag] :: BackendTag 'BigQuery
[DataConnectorTag] :: BackendTag 'DataConnector

-- | This class describes how to get a tag for a given type. We use it in
--   AnyBackend: `case backendTag @b of`...
class HasTag (b :: BackendType)
backendTag :: HasTag b => BackendTag b

-- | How to convert back from a tag to a runtime value.
reify :: BackendTag b -> BackendType

-- | Provides a title-cased name for a database kind, inferring the
--   appropriate database kind from type context.
backendPrefix :: forall b. HasTag b => Text
instance Hasura.RQL.Types.BackendTag.HasTag ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Vanilla)
instance Hasura.RQL.Types.BackendTag.HasTag ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Citus)
instance Hasura.RQL.Types.BackendTag.HasTag ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Cockroach)
instance Hasura.RQL.Types.BackendTag.HasTag 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.RQL.Types.BackendTag.HasTag 'Hasura.RQL.Types.BackendType.BigQuery
instance Hasura.RQL.Types.BackendTag.HasTag 'Hasura.RQL.Types.BackendType.DataConnector
instance Data.GADT.Compare.GCompare Hasura.RQL.Types.BackendTag.BackendTag
instance Data.GADT.Compare.GEq Hasura.RQL.Types.BackendTag.BackendTag

module Hasura.RQL.Types.EECredentials
data EEClientCredentials
EEClientCredentials :: EEClientId -> Text -> EEClientCredentials
[eccClientId] :: EEClientCredentials -> EEClientId
[eccClientSecret] :: EEClientCredentials -> Text
newtype EEClientId
EEClientId :: Text -> EEClientId
[_getEEClientId] :: EEClientId -> Text
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EECredentials.EEClientId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EECredentials.EEClientCredentials

module Hasura.RQL.Types.Endpoint.Trie

-- | Trie from <a>PathComponent</a>s to <tt>MultiMap</tt>s
type MultiMapPathTrie a k v = Trie (PathComponent a) (MultiMap k v)

-- | A component in a URL path: either a literal or a wildcard parameter
data PathComponent a
PathLiteral :: a -> PathComponent a
PathParam :: PathComponent a

-- | Result of matching a path <tt>[<a>PathComponent</a>] a</tt> and key
--   <tt>k</tt> in a <a>MultiMapPathTrie</a>.
--   
--   <a>MatchResult</a> is a lattice where <a>MatchNotFound</a> is the
--   bottom element and <a>MatchAmbiguous</a> is the top element:
--   
--   MatchAmbiguous / MatchFound v0 as0 MatchFound v1 as1 / MatchMissingKey
--   (ks0 &lt;&gt; ks1) / MatchMissingKey ks0 MatchMissingKey ks1 /
--   MatchNotFound
data MatchResult a k v

-- | Multiple results.
MatchAmbiguous :: MatchResult a k v

-- | A single unambiguous result. Returns the value found and a list of
--   parameter bindings.
MatchFound :: v -> [a] -> MatchResult a k v

-- | A path was found, but not a key. Returns a list of keys found.
MatchMissingKey :: NonEmpty k -> MatchResult a k v

-- | Path was not found in the <a>MultiMapPathTrie</a>.
MatchNotFound :: MatchResult a k v

-- | Match a key <tt>k</tt> and path <tt>[a]</tt> against a
--   <tt>MultiMapPathTrie a k v</tt>
matchPath :: (Hashable k, Hashable a) => k -> [a] -> MultiMapPathTrie a k v -> MatchResult a k v

-- | A version of ambiguousPaths that attempts to group all ambiguous paths
--   that have overlapping endpoints
ambiguousPathsGrouped :: (Hashable a, Hashable k, Ord v, Ord a) => MultiMapPathTrie a k v -> [(Set [PathComponent a], Set v)]

-- | Detect and return all ambiguous paths in the <tt>MultiMapPathTrie</tt>
--   A path <tt>p</tt> is ambiguous if <tt>matchPath k p</tt> can return
--   <tt>MatchAmbiguous</tt> for some <tt>k</tt>.
ambiguousPaths :: (Hashable a, Hashable k, Ord v) => MultiMapPathTrie a k v -> [([PathComponent a], Set v)]
instance GHC.Generics.Generic (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance (GHC.Show.Show v, GHC.Show.Show a, GHC.Show.Show k) => GHC.Show.Show (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance (GHC.Classes.Eq v, GHC.Classes.Eq a, GHC.Classes.Eq k) => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance GHC.Base.Semigroup (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance GHC.Base.Monoid (Hasura.RQL.Types.Endpoint.Trie.MatchResult a k v)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSONKey (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Endpoint.Trie.PathComponent a)

module Hasura.RQL.Types.Headers
data HeaderConf
HeaderConf :: HeaderName -> HeaderValue -> HeaderConf
data HeaderValue
HVValue :: Template -> HeaderValue
HVEnv :: Text -> HeaderValue
instance GHC.Generics.Generic Hasura.RQL.Types.Headers.HeaderValue
instance GHC.Classes.Eq Hasura.RQL.Types.Headers.HeaderValue
instance GHC.Show.Show Hasura.RQL.Types.Headers.HeaderValue
instance GHC.Generics.Generic Hasura.RQL.Types.Headers.HeaderConf
instance GHC.Classes.Eq Hasura.RQL.Types.Headers.HeaderConf
instance GHC.Show.Show Hasura.RQL.Types.Headers.HeaderConf
instance Control.DeepSeq.NFData Hasura.RQL.Types.Headers.HeaderConf
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Headers.HeaderConf
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Headers.HeaderConf
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Headers.HeaderConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Headers.HeaderConf
instance Control.DeepSeq.NFData Hasura.RQL.Types.Headers.HeaderValue
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Headers.HeaderValue


-- | This module contains types which are common to event triggers and
--   scheduled triggers.
module Hasura.RQL.Types.Eventing
newtype EventId
EventId :: Text -> EventId
[unEventId] :: EventId -> Text

-- | There are two types of events: EventType (for event triggers) and
--   ScheduledType (for scheduled triggers)
data TriggerTypes
EventType :: TriggerTypes
ScheduledType :: TriggerTypes
data WebhookRequest
WebhookRequest :: Value -> [HeaderConf] -> Text -> WebhookRequest
[_rqPayload] :: WebhookRequest -> Value
[_rqHeaders] :: WebhookRequest -> [HeaderConf]
[_rqVersion] :: WebhookRequest -> Text
data WebhookResponse
WebhookResponse :: SerializableBlob -> [HeaderConf] -> Int -> WebhookResponse
[_wrsBody] :: WebhookResponse -> SerializableBlob
[_wrsHeaders] :: WebhookResponse -> [HeaderConf]
[_wrsStatus] :: WebhookResponse -> Int
newtype ClientError
ClientError :: SerializableBlob -> ClientError
[_ceMessage] :: ClientError -> SerializableBlob
data Response (a :: TriggerTypes)
ResponseHTTP :: WebhookResponse -> Response (a :: TriggerTypes)
ResponseError :: ClientError -> Response (a :: TriggerTypes)
type InvocationVersion = Text
invocationVersionET :: InvocationVersion
invocationVersionST :: InvocationVersion
data Invocation (a :: TriggerTypes)
Invocation :: EventId -> Maybe Int -> WebhookRequest -> Response a -> Invocation (a :: TriggerTypes)
[iEventId] :: Invocation (a :: TriggerTypes) -> EventId
[iStatus] :: Invocation (a :: TriggerTypes) -> Maybe Int
[iRequest] :: Invocation (a :: TriggerTypes) -> WebhookRequest
[iResponse] :: Invocation (a :: TriggerTypes) -> Response a

-- | PGTextArray is only used for PG array encoding
newtype PGTextArray
PGTextArray :: [Text] -> PGTextArray
[unPGTextArray] :: PGTextArray -> [Text]

-- | Used to construct the payload of Event Trigger
--   
--   OLD: Depicts the old database row value for UPDATE/DELETE trigger
--   operations. This is used to construct the 'data.old' field of the
--   event trigger payload. The value of 'data.old' is null in INSERT
--   trigger operation.
--   
--   NEW: Depicts the new database row value for INSERT/UPDATE trigger
--   operations. This is used to construct the 'data.new' field of the
--   event trigger payload. The value of 'data.new' is null in DELETE
--   trigger operation.
data OpVar
OLD :: OpVar
NEW :: OpVar
instance Control.DeepSeq.NFData Hasura.RQL.Types.Eventing.EventId
instance GHC.Generics.Generic Hasura.RQL.Types.Eventing.EventId
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Eventing.EventId
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Eventing.EventId
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Eventing.EventId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.EventId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Eventing.EventId
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Eventing.EventId
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Eventing.EventId
instance GHC.Classes.Ord Hasura.RQL.Types.Eventing.EventId
instance GHC.Classes.Eq Hasura.RQL.Types.Eventing.EventId
instance GHC.Show.Show Hasura.RQL.Types.Eventing.EventId
instance GHC.Generics.Generic Hasura.RQL.Types.Eventing.WebhookRequest
instance GHC.Generics.Generic Hasura.RQL.Types.Eventing.WebhookResponse
instance GHC.Generics.Generic Hasura.RQL.Types.Eventing.ClientError
instance GHC.Classes.Eq Hasura.RQL.Types.Eventing.PGTextArray
instance GHC.Show.Show Hasura.RQL.Types.Eventing.PGTextArray
instance GHC.Show.Show Hasura.RQL.Types.Eventing.OpVar
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Eventing.PGTextArray
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Eventing.Response 'Hasura.RQL.Types.Eventing.EventType)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Eventing.Response 'Hasura.RQL.Types.Eventing.ScheduledType)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.ClientError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.WebhookResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Eventing.WebhookRequest

module Hasura.RQL.DDL.Headers

-- | Resolve configuration headers
makeHeadersFromConf :: MonadError QErr m => Environment -> [HeaderConf] -> m [Header]

-- | Encode headers to HeaderConf
toHeadersConf :: [Header] -> [HeaderConf]


-- | Provides a data type that holds all of the required implementation
--   details for a backend that supports health checks.
module Hasura.RQL.Types.HealthCheckImplementation
data HealthCheckImplementation healthCheckTest
HealthCheckImplementation :: healthCheckTest -> JSONCodec healthCheckTest -> HealthCheckImplementation healthCheckTest
[_hciDefaultTest] :: HealthCheckImplementation healthCheckTest -> healthCheckTest
[_hciTestCodec] :: HealthCheckImplementation healthCheckTest -> JSONCodec healthCheckTest

module Hasura.RQL.Types.NamingCase

-- | Represents the different possible type cases for fields and types,
--   i.e. <tt>HasuraCase</tt> and <tt>GraphqlCase</tt> (<tt>CamelCase</tt>
--   fields and <tt>PascalCase</tt> types).
data NamingCase
HasuraCase :: NamingCase
GraphqlCase :: NamingCase
parseNamingConventionFromText :: Text -> Either String NamingCase
instance GHC.Generics.Generic Hasura.RQL.Types.NamingCase.NamingCase
instance GHC.Show.Show Hasura.RQL.Types.NamingCase.NamingCase
instance GHC.Classes.Eq Hasura.RQL.Types.NamingCase.NamingCase
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.NamingCase.NamingCase
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.NamingCase.NamingCase
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.NamingCase.NamingCase

module Hasura.RQL.Types.OpenTelemetry

-- | Metadata configuration for all OpenTelemetry-related features
data OpenTelemetryConfig
OpenTelemetryConfig :: OtelStatus -> Set OtelDataType -> OtelExporterConfig -> OtelBatchSpanProcessorConfig -> OpenTelemetryConfig
[_ocStatus] :: OpenTelemetryConfig -> OtelStatus
[_ocEnabledDataTypes] :: OpenTelemetryConfig -> Set OtelDataType
[_ocExporterOtlp] :: OpenTelemetryConfig -> OtelExporterConfig
[_ocBatchSpanProcessor] :: OpenTelemetryConfig -> OtelBatchSpanProcessorConfig
emptyOpenTelemetryConfig :: OpenTelemetryConfig

-- | Subsets of the fields of <a>OpenTelemetryConfig</a>, serving as
--   metadata object names for <tt>MetadataObjId</tt>.
data OpenTelemetryConfigSubobject

-- | The entire OpenTelemetry configuration
OtelSubobjectAll :: OpenTelemetryConfigSubobject
OtelSubobjectExporterOtlp :: OpenTelemetryConfigSubobject
OtelSubobjectBatchSpanProcessor :: OpenTelemetryConfigSubobject

-- | Should the OpenTelemetry exporter be enabled?
data OtelStatus
OtelEnabled :: OtelStatus
OtelDisabled :: OtelStatus
data OtelDataType
OtelTraces :: OtelDataType
OtelMetrics :: OtelDataType

-- | 
--   <a>https://opentelemetry.io/docs/reference/specification/protocol/exporter/</a>
data OtelExporterConfig
OtelExporterConfig :: Maybe Text -> Maybe Text -> OtlpProtocol -> [HeaderConf] -> [NameValue] -> OtelExporterConfig

-- | Target URL to which the exporter is going to send traces. No default.
--   Used as-is without modification (e.g. appending <i>v1</i>traces).
[_oecTracesEndpoint] :: OtelExporterConfig -> Maybe Text

-- | Target URL to which the exporter is going to send metrics. No default.
--   Used as-is without modification (e.g. appending <i>v1</i>metrics).
[_oecMetricsEndpoint] :: OtelExporterConfig -> Maybe Text

-- | The transport protocol, for all telemetry types.
[_oecProtocol] :: OtelExporterConfig -> OtlpProtocol

-- | Key-value pairs to be used as headers to send with an export request,
--   for all telemetry types. We currently only support string-valued
--   attributes. Like OTEL_EXPORTER_OTLP_HEADERS.
[_oecHeaders] :: OtelExporterConfig -> [HeaderConf]

-- | Attributes to send as the resource attributes of an export request,
--   for all telemetry types.
[_oecResourceAttributes] :: OtelExporterConfig -> [NameValue]
defaultOtelExporterConfig :: OtelExporterConfig

-- | Possible protocol to use with OTLP. Currently, only http/protobuf is
--   supported.
data OtlpProtocol
OtlpProtocolHttpProtobuf :: OtlpProtocol
data NameValue
NameValue :: Text -> Text -> NameValue
[nv_name] :: NameValue -> Text
[nv_value] :: NameValue -> Text
newtype OtelBatchSpanProcessorConfig
OtelBatchSpanProcessorConfig :: Int -> OtelBatchSpanProcessorConfig

-- | The maximum batch size of every export. It must be smaller or equal to
--   maxQueueSize (not yet configurable). Default 512.
[_obspcMaxExportBatchSize] :: OtelBatchSpanProcessorConfig -> Int
defaultOtelBatchSpanProcessorConfig :: OtelBatchSpanProcessorConfig
ocStatus :: Lens' OpenTelemetryConfig OtelStatus
ocExporterOtlp :: Lens' OpenTelemetryConfig OtelExporterConfig
ocEnabledDataTypes :: Lens' OpenTelemetryConfig (Set OtelDataType)
ocBatchSpanProcessor :: Lens' OpenTelemetryConfig OtelBatchSpanProcessorConfig

-- | Schema cache configuration for all OpenTelemetry-related features
data OpenTelemetryInfo
OpenTelemetryInfo :: OtelExporterInfo -> OtelBatchSpanProcessorInfo -> OpenTelemetryInfo
[_otiExporterOtlp] :: OpenTelemetryInfo -> OtelExporterInfo

-- | This configuration will be used for traces and logs (when implemented)
[_otiBatchSpanProcessorInfo] :: OpenTelemetryInfo -> OtelBatchSpanProcessorInfo
data OtelExporterInfo
OtelExporterInfo :: Maybe Request -> Maybe Request -> Map Text Text -> OtelExporterInfo

-- | HTTP <a>Request</a> containing (1) the target URL to which the
--   exporter is going to send spans, and (2) the user-specified request
--   headers. A value of <a>Nothing</a> indicates that the export of trace
--   data is disabled.
[_oteleiTracesBaseRequest] :: OtelExporterInfo -> Maybe Request

-- | HTTP <a>Request</a> containing (1) the target URL to which the
--   exporter is going to send metrics, and (2) the user-specified request
--   headers. A value of <a>Nothing</a> indicates that the export of trace
--   data is disabled.
[_oteleiMetricsBaseRequest] :: OtelExporterInfo -> Maybe Request

-- | Attributes to send as the resource attributes of an export request. We
--   currently only support string-valued attributes.
--   
--   Using Data.Map.Strict over Data.Hashmap.Strict because currently the
--   only operations on data are (1) folding and (2) union with a small map
--   of default attributes, and Map should be is faster than HashMap for
--   the latter.
[_oteleiResourceAttributes] :: OtelExporterInfo -> Map Text Text
emptyOtelExporterInfo :: OtelExporterInfo

-- | <tt>Nothing</tt> means this exporter is disabled
getOtelExporterTracesBaseRequest :: OtelExporterInfo -> Maybe Request

-- | <tt>Nothing</tt> means this exporter is disabled
getOtelExporterMetricsBaseRequest :: OtelExporterInfo -> Maybe Request
getOtelExporterResourceAttributes :: OtelExporterInfo -> Map Text Text

-- | Batch processor configuration for trace export.
--   
--   
--   <a>https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md</a>
--   
--   NOTE: we could share this configuration with logs when implemented,
--   but that change is invasive; I recommend just adding a new separate
--   configuration. See:
--   <a>https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/logs/sdk.md#batching-processor</a>
data OtelBatchSpanProcessorInfo
OtelBatchSpanProcessorInfo :: Int -> Int -> OtelBatchSpanProcessorInfo

-- | The maximum batch size of every export. It must be smaller or equal to
--   maxQueueSize. Default 512.
[_obspiMaxExportBatchSize] :: OtelBatchSpanProcessorInfo -> Int

-- | The maximum span queue size. After the size is reached spans are
--   dropped. Default 2048.
[_obspiMaxQueueSize] :: OtelBatchSpanProcessorInfo -> Int
getMaxExportBatchSize :: OtelBatchSpanProcessorInfo -> Int
getMaxQueueSize :: OtelBatchSpanProcessorInfo -> Int

-- | Defaults taken from
--   <a>https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/trace/sdk.md#batching-processor</a>
defaultOtelBatchSpanProcessorInfo :: OtelBatchSpanProcessorInfo
otiExporterOtlp :: Lens' OpenTelemetryInfo OtelExporterInfo
otiBatchSpanProcessorInfo :: Lens' OpenTelemetryInfo OtelBatchSpanProcessorInfo
instance Language.Haskell.TH.Syntax.Lift Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorInfo
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfigSubobject
instance GHC.Show.Show Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfigSubobject
instance GHC.Classes.Ord Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfigSubobject
instance GHC.Generics.Generic Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfigSubobject
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfigSubobject
instance GHC.Enum.Enum Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance GHC.Enum.Bounded Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance GHC.Show.Show Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance GHC.Enum.Enum Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance GHC.Enum.Bounded Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance GHC.Show.Show Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance GHC.Classes.Ord Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance GHC.Enum.Enum Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance GHC.Enum.Bounded Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance GHC.Show.Show Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance GHC.Show.Show Hasura.RQL.Types.OpenTelemetry.NameValue
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.NameValue
instance GHC.Show.Show Hasura.RQL.Types.OpenTelemetry.OtelExporterConfig
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OtelExporterConfig
instance GHC.Show.Show Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorConfig
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorConfig
instance GHC.Show.Show Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfig
instance GHC.Classes.Eq Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OpenTelemetryConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.OtelBatchSpanProcessorConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OtelExporterConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OtelExporterConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.OtelExporterConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.NameValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.NameValue
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.NameValue
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.OtlpProtocol
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.OtelDataType
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.OpenTelemetry.OtelStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.OpenTelemetry.OtelStatus

module Hasura.RQL.Types.QueryCollection
newtype CollectionName
CollectionName :: NonEmptyText -> CollectionName
[unCollectionName] :: CollectionName -> NonEmptyText
newtype QueryName
QueryName :: NonEmptyText -> QueryName
[unQueryName] :: QueryName -> NonEmptyText
newtype GQLQuery
GQLQuery :: ExecutableDocument Name -> GQLQuery
[unGQLQuery] :: GQLQuery -> ExecutableDocument Name
newtype GQLQueryWithText
GQLQueryWithText :: (Text, GQLQuery) -> GQLQueryWithText
getGQLQuery :: GQLQueryWithText -> GQLQuery
getGQLQueryText :: GQLQueryWithText -> Text
data ListedQuery
ListedQuery :: QueryName -> GQLQueryWithText -> ListedQuery
[_lqName] :: ListedQuery -> QueryName
[_lqQuery] :: ListedQuery -> GQLQueryWithText
newtype CollectionDef
CollectionDef :: [ListedQuery] -> CollectionDef
[_cdQueries] :: CollectionDef -> [ListedQuery]
cdQueries :: Iso' CollectionDef [ListedQuery]
data CreateCollection
CreateCollection :: CollectionName -> CollectionDef -> Maybe Text -> CreateCollection
[_ccName] :: CreateCollection -> CollectionName
[_ccDefinition] :: CreateCollection -> CollectionDef
[_ccComment] :: CreateCollection -> Maybe Text
ccName :: Lens' CreateCollection CollectionName
ccDefinition :: Lens' CreateCollection CollectionDef
ccComment :: Lens' CreateCollection (Maybe Text)
collectionQueries :: CreateCollection -> [ExecutableDocument Name]
data RenameCollection
RenameCollection :: CollectionName -> CollectionName -> RenameCollection
[_rcName] :: RenameCollection -> CollectionName
[_rcNewName] :: RenameCollection -> CollectionName
rcNewName :: Lens' RenameCollection CollectionName
rcName :: Lens' RenameCollection CollectionName
data DropCollection
DropCollection :: CollectionName -> Bool -> DropCollection
[_dcCollection] :: DropCollection -> CollectionName
[_dcCascade] :: DropCollection -> Bool
data AddQueryToCollection
AddQueryToCollection :: CollectionName -> QueryName -> GQLQueryWithText -> AddQueryToCollection
[_aqtcCollectionName] :: AddQueryToCollection -> CollectionName
[_aqtcQueryName] :: AddQueryToCollection -> QueryName
[_aqtcQuery] :: AddQueryToCollection -> GQLQueryWithText
data DropQueryFromCollection
DropQueryFromCollection :: CollectionName -> QueryName -> DropQueryFromCollection
[_dqfcCollectionName] :: DropQueryFromCollection -> CollectionName
[_dqfcQueryName] :: DropQueryFromCollection -> QueryName
type QueryCollections = InsOrdHashMap CollectionName CreateCollection
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.DropCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.DropCollection
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.DropCollection
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.DropQueryFromCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.AddQueryToCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.DropCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.DropCollection
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.RenameCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.RenameCollection
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.RenameCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.RenameCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.RenameCollection
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.CreateCollection
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.CreateCollection
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.CreateCollection
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.CreateCollection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.CreateCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.CreateCollection
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.QueryCollection.CollectionName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.QueryCollection.CollectionName
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.CollectionName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.CollectionName
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.CollectionName
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.CollectionName
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.CollectionName
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.QueryName
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.QueryName
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.QueryName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.GQLQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.GQLQuery
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.GQLQuery
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.GQLQuery
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.GQLQuery
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.GQLQuery
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.GQLQuery
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.ListedQuery
instance GHC.Classes.Ord Hasura.RQL.Types.QueryCollection.ListedQuery
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.ListedQuery
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.ListedQuery
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.CollectionDef
instance GHC.Generics.Generic Hasura.RQL.Types.QueryCollection.CollectionDef
instance GHC.Classes.Eq Hasura.RQL.Types.QueryCollection.CollectionDef
instance GHC.Show.Show Hasura.RQL.Types.QueryCollection.CollectionDef
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.CollectionDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.CollectionDef
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.CollectionDef
instance Control.DeepSeq.NFData Hasura.RQL.Types.QueryCollection.ListedQuery
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.QueryCollection.ListedQuery
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.ListedQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.ListedQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.ListedQuery
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.QueryCollection.GQLQueryWithText
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.GQLQuery
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.QueryName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.QueryCollection.CollectionName

module Hasura.RQL.Types.Endpoint
data EndpointMethod
GET :: EndpointMethod
POST :: EndpointMethod
PUT :: EndpointMethod
DELETE :: EndpointMethod
PATCH :: EndpointMethod
newtype EndpointName
EndpointName :: NonEmptyText -> EndpointName
[unEndpointName] :: EndpointName -> NonEmptyText
data EndpointUrl
mkEndpointUrl :: ToTxt a => a -> Maybe EndpointUrl
data QueryReference
QueryReference :: CollectionName -> QueryName -> QueryReference
[_qrCollectionName] :: QueryReference -> CollectionName
[_qrQueryName] :: QueryReference -> QueryName
qrQueryName :: Lens' QueryReference QueryName
qrCollectionName :: Lens' QueryReference CollectionName
data EndpointDef query
EndpointDef :: query -> EndpointDef query
[_edQuery] :: EndpointDef query -> query
edQuery :: forall query_a1Vxm query_a1VNH. Iso (EndpointDef query_a1Vxm) (EndpointDef query_a1VNH) query_a1Vxm query_a1VNH
type EndpointTrie query = MultiMapPathTrie Text EndpointMethod (EndpointMetadata query)
buildEndpointsTrie :: Ord query => [EndpointMetadata query] -> EndpointTrie query

-- | Split a path and construct PathSegments based on callbacks for
--   variables and literals Var callback is passed the ":" prefix as part
--   of the text.
splitPath :: (Text -> a) -> (Text -> a) -> EndpointUrl -> [a]
type CreateEndpoint = EndpointMetadata QueryReference
data EndpointMetadata query
EndpointMetadata :: EndpointName -> EndpointUrl -> NonEmpty EndpointMethod -> EndpointDef query -> Maybe Text -> EndpointMetadata query
[_ceName] :: EndpointMetadata query -> EndpointName
[_ceUrl] :: EndpointMetadata query -> EndpointUrl
[_ceMethods] :: EndpointMetadata query -> NonEmpty EndpointMethod
[_ceDefinition] :: EndpointMetadata query -> EndpointDef query
[_ceComment] :: EndpointMetadata query -> Maybe Text
ceUrl :: forall query_a1VNV. Lens' (EndpointMetadata query_a1VNV) EndpointUrl
ceName :: forall query_a1VNV. Lens' (EndpointMetadata query_a1VNV) EndpointName
ceMethods :: forall query_a1VNV. Lens' (EndpointMetadata query_a1VNV) (NonEmpty EndpointMethod)
ceDefinition :: forall query_a1VNV query_a1Whz. Lens (EndpointMetadata query_a1VNV) (EndpointMetadata query_a1Whz) (EndpointDef query_a1VNV) (EndpointDef query_a1Whz)
ceComment :: forall query_a1VNV. Lens' (EndpointMetadata query_a1VNV) (Maybe Text)
data DropEndpoint
DropEndpoint :: EndpointName -> DropEndpoint
[_deName] :: DropEndpoint -> EndpointName
deName :: Iso' DropEndpoint EndpointName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.DropEndpoint
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.DropEndpoint
instance GHC.Generics.Generic Hasura.RQL.Types.Endpoint.DropEndpoint
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.DropEndpoint
instance GHC.Show.Show Hasura.RQL.Types.Endpoint.DropEndpoint
instance Data.Aeson.Types.ToJSON.ToJSON query => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance Data.Aeson.Types.FromJSON.FromJSON query => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance Data.Traversable.Traversable Hasura.RQL.Types.Endpoint.EndpointMetadata
instance Data.Foldable.Foldable Hasura.RQL.Types.Endpoint.EndpointMetadata
instance GHC.Base.Functor Hasura.RQL.Types.Endpoint.EndpointMetadata
instance GHC.Generics.Generic (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance GHC.Classes.Ord query => GHC.Classes.Ord (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance GHC.Classes.Eq query => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance GHC.Show.Show query => GHC.Show.Show (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance (Autodocodec.Class.HasCodec query, Data.Typeable.Internal.Typeable query) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Endpoint.EndpointMetadata query)
instance Data.Aeson.Types.ToJSON.ToJSON query => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance Data.Aeson.Types.FromJSON.FromJSON query => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance Data.Traversable.Traversable Hasura.RQL.Types.Endpoint.EndpointDef
instance Data.Foldable.Foldable Hasura.RQL.Types.Endpoint.EndpointDef
instance GHC.Base.Functor Hasura.RQL.Types.Endpoint.EndpointDef
instance GHC.Generics.Generic (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance GHC.Classes.Ord query => GHC.Classes.Ord (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance GHC.Classes.Eq query => GHC.Classes.Eq (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance GHC.Show.Show query => GHC.Show.Show (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance (Autodocodec.Class.HasCodec query, Data.Typeable.Internal.Typeable query) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Endpoint.EndpointDef query)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.QueryReference
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.QueryReference
instance GHC.Generics.Generic Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Classes.Ord Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Enum.Enum Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Enum.Bounded Hasura.RQL.Types.Endpoint.EndpointMethod
instance GHC.Show.Show Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Endpoint.EndpointName
instance GHC.Classes.Ord Hasura.RQL.Types.Endpoint.EndpointName
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.EndpointName
instance GHC.Show.Show Hasura.RQL.Types.Endpoint.EndpointName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Endpoint.EndpointUrl
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Endpoint.EndpointUrl
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Endpoint.EndpointUrl
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Classes.Ord Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Show.Show Hasura.RQL.Types.Endpoint.EndpointUrl
instance GHC.Generics.Generic Hasura.RQL.Types.Endpoint.QueryReference
instance GHC.Classes.Eq Hasura.RQL.Types.Endpoint.QueryReference
instance GHC.Show.Show Hasura.RQL.Types.Endpoint.QueryReference
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Endpoint.QueryReference
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Endpoint.EndpointUrl
instance Web.Internal.HttpApiData.FromHttpApiData Hasura.RQL.Types.Endpoint.EndpointUrl
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Endpoint.EndpointName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Endpoint.EndpointMethod
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Endpoint.EndpointMethod


-- | Types related to resizing a connection pool
--   
--   Resize connection pools, on-demand, based on underlying server
--   replicas
--   
--   See @<tt>resizeSourcePools</tt> in Hasura.RQL.Types.Backend
module Hasura.RQL.Types.ResizePool

-- | Number of server instances. A wrapper over <tt><a>Word</a> type, a
--   non-negative integer with the same size as </tt><a>Int</a>. Useful for
--   resize a connection pool.
data ServerReplicas
unsafeServerReplicas :: Word -> ServerReplicas
oneServerReplica :: ServerReplicas

-- | Safely build <tt><a>ServerReplicas</a> from non-negative and non-zero
--   </tt><a>Int</a> value.
safeServerReplicas :: Int -> Either Text ServerReplicas

-- | Get server replic count in @<a>Int</a>
getServerReplicasInt :: ServerReplicas -> Int

-- | A strategy for resizing a pool
data ResizePoolStrategy

-- | Never resize the pool
NeverResizePool :: ResizePoolStrategy

-- | Resize the pool by using provided total maximum connections
ResizePool :: Int -> ResizePoolStrategy

-- | Summary of a source's pools resize. Predominantly used to log.
data SourceResizePoolSummary
SourceResizePoolSummary :: Bool -> Bool -> [Text] -> SourceResizePoolSummary
[_srpsPrimaryResized] :: SourceResizePoolSummary -> Bool
[_srpsReadReplicasResized] :: SourceResizePoolSummary -> Bool
[_srpsConnectionSet] :: SourceResizePoolSummary -> [Text]
noPoolsResizedSummary :: SourceResizePoolSummary
instance GHC.Classes.Eq Hasura.RQL.Types.ResizePool.ServerReplicas
instance GHC.Show.Show Hasura.RQL.Types.ResizePool.ServerReplicas
instance GHC.Show.Show Hasura.RQL.Types.ResizePool.SourceResizePoolSummary
instance GHC.Classes.Eq Hasura.RQL.Types.ResizePool.SourceResizePoolSummary


-- | MSSQL Connection
--   
--   This module handles the connection against an MS SQL Server. It
--   defines the connection string, connection pool, default settings, and
--   conversion functions between MSSQL and graphql-engine.
module Hasura.Backends.MSSQL.Connection
class (MonadError QErr m) => MonadMSSQLTx m
liftMSSQLTx :: MonadMSSQLTx m => TxE QErr a -> m a
data MSSQLPoolConnectionSettings
MSSQLPoolConnectionSettings :: Maybe Int -> Maybe Int -> Int -> MSSQLPoolConnectionSettings
[mpsMaxConnections] :: MSSQLPoolConnectionSettings -> Maybe Int
[mpsTotalMaxConnections] :: MSSQLPoolConnectionSettings -> Maybe Int
[mpsIdleTimeout] :: MSSQLPoolConnectionSettings -> Int
data MSSQLPoolSettings
MSSQLPoolSettingsPool :: MSSQLPoolConnectionSettings -> MSSQLPoolSettings
MSSQLPoolSettingsNoPool :: MSSQLPoolSettings
defaultMSSQLMaxConnections :: Int
data MSSQLConnectionInfo
MSSQLConnectionInfo :: InputConnectionString -> MSSQLPoolSettings -> TxIsolation -> MSSQLConnectionInfo
[mciConnectionString] :: MSSQLConnectionInfo -> InputConnectionString
[mciPoolSettings] :: MSSQLConnectionInfo -> MSSQLPoolSettings
[mciIsolationLevel] :: MSSQLConnectionInfo -> TxIsolation
data MSSQLConnConfiguration
MSSQLConnConfiguration :: MSSQLConnectionInfo -> Maybe (NonEmpty MSSQLConnectionInfo) -> MSSQLConnConfiguration
createMSSQLPool :: MonadIO m => QErrM m => InputConnectionString -> ConnectionOptions -> Environment -> m (ConnectionString, MSSQLPool)
getEnv :: QErrM m => Environment -> Text -> m Text

-- | Execution Context required to execute MSSQL transactions
data MSSQLExecCtx
MSSQLExecCtx :: MSSQLRunTx -> MSSQLRunTx -> MSSQLRunTx -> IO () -> (ServerReplicas -> IO SourceResizePoolSummary) -> MSSQLExecCtx

-- | A function that runs read-only queries
[mssqlRunReadOnly] :: MSSQLExecCtx -> MSSQLRunTx

-- | A function that runs read-write queries; run in a transaction
[mssqlRunReadWrite] :: MSSQLExecCtx -> MSSQLRunTx

-- | A function that runs a transaction in the SERIALIZABLE transaction
--   isolation level. This is mainly intended to run source catalog
--   migrations.
[mssqlRunSerializableTx] :: MSSQLExecCtx -> MSSQLRunTx

-- | Destroys connection pools
[mssqlDestroyConn] :: MSSQLExecCtx -> IO ()

-- | Resize pools based on number of server instances
[mssqlResizePools] :: MSSQLExecCtx -> ServerReplicas -> IO SourceResizePoolSummary

-- | Creates a MSSQL execution context for a single primary pool
mkMSSQLExecCtx :: TxIsolation -> MSSQLPool -> ResizePoolStrategy -> MSSQLExecCtx

-- | Resize MSSQL pool by setting the number of connections equal to
--   allowed maximum connections across all server instances divided by
--   number of instances
resizeMSSQLPool :: MSSQLPool -> Int -> ServerReplicas -> IO ()

-- | Run any query discarding its results
mkMSSQLAnyQueryTx :: Query -> TxET QErr IO ()
data MSSQLSourceConfig
MSSQLSourceConfig :: ConnectionString -> MSSQLExecCtx -> Int -> MSSQLSourceConfig
odbcValueToJValue :: Value -> Value
runMSSQLSourceReadTx :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> TxET QErr m a -> m (Either QErr a)
runMSSQLSourceWriteTx :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> TxET QErr m a -> m (Either QErr a)
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLConnectionString
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Connection.InputConnectionString
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.InputConnectionString
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.InputConnectionString
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLPoolConnectionSettings
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLPoolConnectionSettings
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLPoolConnectionSettings
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance GHC.Show.Show Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance Data.Has.Has () Hasura.Backends.MSSQL.Connection.MSSQLSourceConfig
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLConnConfiguration
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.MSSQLConnectionInfo
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Connection.MSSQLPoolSettings
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.MSSQLPoolConnectionSettings
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.MSSQLPoolConnectionSettings
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Connection.InputConnectionString
instance Hasura.Backends.MSSQL.Connection.MonadMSSQLTx m => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Control.Monad.Trans.Reader.ReaderT s m)
instance Hasura.Backends.MSSQL.Connection.MonadMSSQLTx m => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Hasura.Backends.MSSQL.Connection.MonadMSSQLTx m) => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Control.Monad.IO.Class.MonadIO m => Hasura.Backends.MSSQL.Connection.MonadMSSQLTx (Database.MSSQL.Transaction.TxET Hasura.Base.Error.QErr m)
instance Data.Hashable.Class.Hashable Database.MSSQL.Pool.ConnectionString
instance Control.DeepSeq.NFData Database.MSSQL.Pool.ConnectionString

module Hasura.Backends.BigQuery.Connection
resolveConfigurationJson :: (QErrM m, FromJSON a) => Environment -> ConfigurationJSON a -> m (Either String a)
resolveConfigurationInput :: QErrM m => Environment -> ConfigurationInput -> m Text
resolveConfigurationInputs :: QErrM m => Environment -> ConfigurationInputs -> m [Text]
initConnection :: MonadIO m => ServiceAccount -> BigQueryProjectId -> Maybe RetryOptions -> m BigQueryConnection
data BigQueryProblem
runBigQuery :: MonadIO m => BigQueryConnection -> Request -> m (Either BigQueryProblem (Response ByteString))
instance Data.String.IsString Hasura.Backends.BigQuery.Connection.Scope
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Connection.Scope
instance GHC.Show.Show Hasura.Backends.BigQuery.Connection.Scope
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest
instance GHC.Show.Show Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Connection.TokenProblem
instance GHC.Show.Show Hasura.Backends.BigQuery.Connection.TokenProblem
instance GHC.Show.Show Hasura.Backends.BigQuery.Connection.ServiceAccountProblem
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Connection.BigQueryProblem
instance GHC.Show.Show Hasura.Backends.BigQuery.Connection.BigQueryProblem
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Connection.BigQueryProblem
instance GHC.Exception.Type.Exception Hasura.Backends.BigQuery.Connection.ServiceAccountProblem
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Connection.GoogleAccessTokenRequest

module Hasura.RQL.Types.ResultCustomization

-- | Mapping that can be provided to a ResultCustomizer to map top-level
--   field aliases that were not available at field parse time. E.g. for
--   aliases created in the remote server query for remote joins.
data AliasMapping

-- | AliasMapping that maps a single field name to an alias
singletonAliasMapping :: Name -> Name -> AliasMapping

-- | Function to modify JSON values returned from the remote server e.g. to
--   map values of __typename fields to customized type names. The
--   customizer uses Maybe to allow short-circuiting subtrees where no
--   customizations are needed.
data ResultCustomizer

-- | Apply a ResultCustomizer to a JSON value
applyResultCustomizer :: ResultCustomizer -> Value -> Value

-- | Apply an AliasMapping to a ResultCustomizer.
applyAliasMapping :: AliasMapping -> ResultCustomizer -> ResultCustomizer

-- | Take a ResultCustomizer for a JSON subtree, and a fieldName, and
--   produce a ResultCustomizer for a parent object or array of objects
--   that applies the subtree customizer to the subtree at the given
--   fieldName.
modifyFieldByName :: Name -> ResultCustomizer -> ResultCustomizer

-- | Create a RemoteResultCustomizer that applies the typeNameMap to a JSON
--   string value, e.g. for use in customizing a __typename field value.
customizeTypeNameString :: HashMap Name Name -> ResultCustomizer
instance GHC.Base.Monoid Hasura.RQL.Types.ResultCustomization.AliasMapping
instance GHC.Base.Semigroup Hasura.RQL.Types.ResultCustomization.AliasMapping
instance GHC.Base.Monoid Hasura.RQL.Types.ResultCustomization.ResultCustomizer
instance GHC.Base.Semigroup Hasura.RQL.Types.ResultCustomization.ResultCustomizer
instance GHC.Show.Show Hasura.RQL.Types.ResultCustomization.ResultCustomizer

module Hasura.RQL.Types.Roles
data RoleName
roleNameToTxt :: RoleName -> Text
mkRoleName :: Text -> Maybe RoleName
mkRoleNameSafe :: NonEmptyText -> RoleName
adminRoleName :: RoleName
newtype ParentRoles
ParentRoles :: HashSet RoleName -> ParentRoles
[_unParentRoles] :: ParentRoles -> HashSet RoleName

-- | The <a>Role</a> type represents a role by containing its name and the
--   names of its parent roles. This type is used externally in the
--   <tt>add_inherited_role</tt> metadata API and is also used internally
--   in the permission building part of the schema cache building process
data Role
Role :: RoleName -> ParentRoles -> Role
[_rRoleName] :: Role -> RoleName

-- | set of the parent role names, in case of non-inherited roles it will
--   be an empty set
[_rParentRoles] :: Role -> ParentRoles
type InheritedRole = Role
newtype DropInheritedRole
DropInheritedRole :: RoleName -> DropInheritedRole
[_ddrRoleName] :: DropInheritedRole -> RoleName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Roles.RoleName
instance GHC.Generics.Generic Hasura.RQL.Types.Roles.RoleName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Roles.RoleName
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Roles.RoleName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Roles.RoleName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Roles.RoleName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Roles.RoleName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Roles.RoleName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Roles.RoleName
instance GHC.Classes.Ord Hasura.RQL.Types.Roles.RoleName
instance GHC.Classes.Eq Hasura.RQL.Types.Roles.RoleName
instance GHC.Show.Show Hasura.RQL.Types.Roles.RoleName
instance GHC.Generics.Generic Hasura.RQL.Types.Roles.ParentRoles
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Roles.ParentRoles
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Roles.ParentRoles
instance GHC.Classes.Eq Hasura.RQL.Types.Roles.ParentRoles
instance GHC.Show.Show Hasura.RQL.Types.Roles.ParentRoles
instance GHC.Generics.Generic Hasura.RQL.Types.Roles.Role
instance GHC.Classes.Eq Hasura.RQL.Types.Roles.Role
instance GHC.Show.Show Hasura.RQL.Types.Roles.Role
instance GHC.Generics.Generic Hasura.RQL.Types.Roles.DropInheritedRole
instance GHC.Classes.Eq Hasura.RQL.Types.Roles.DropInheritedRole
instance GHC.Show.Show Hasura.RQL.Types.Roles.DropInheritedRole
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Roles.DropInheritedRole
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Roles.DropInheritedRole
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Roles.Role
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Roles.Role
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Roles.Role
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Roles.Role
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Roles.ParentRoles
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Roles.ParentRoles
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Roles.RoleName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Roles.RoleName

module Hasura.RQL.Types.GraphqlSchemaIntrospection
newtype SetGraphqlIntrospectionOptions
SetGraphqlIntrospectionOptions :: HashSet RoleName -> SetGraphqlIntrospectionOptions
[_idrDisabledForRoles] :: SetGraphqlIntrospectionOptions -> HashSet RoleName
instance GHC.Base.Monoid Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Base.Semigroup Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Generics.Generic Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Classes.Eq Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance GHC.Show.Show Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Control.DeepSeq.NFData Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.GraphqlSchemaIntrospection.SetGraphqlIntrospectionOptions

module Hasura.RQL.Types.Allowlist
newtype DropCollectionFromAllowlist
DropCollectionFromAllowlist :: CollectionName -> DropCollectionFromAllowlist
[_dcfaCollection] :: DropCollectionFromAllowlist -> CollectionName
data AllowlistScope
AllowlistScopeGlobal :: AllowlistScope
AllowlistScopeRoles :: NonEmpty RoleName -> AllowlistScope
data AllowlistEntry
AllowlistEntry :: CollectionName -> AllowlistScope -> AllowlistEntry
[aeCollection] :: AllowlistEntry -> CollectionName
[aeScope] :: AllowlistEntry -> AllowlistScope

-- | Wrap <a>AllowlistEntry</a> with a FromJSON instance that requires
--   <tt>scope</tt> to be set.
newtype UpdateScopeOfCollectionInAllowlist
UpdateScopeOfCollectionInAllowlist :: AllowlistEntry -> UpdateScopeOfCollectionInAllowlist
type MetadataAllowlist = InsOrdHashMap CollectionName AllowlistEntry
metadataAllowlistInsert :: AllowlistEntry -> MetadataAllowlist -> Either Text MetadataAllowlist
metadataAllowlistUpdateScope :: AllowlistEntry -> MetadataAllowlist -> Either Text MetadataAllowlist

-- | Produce a list of all collections in the allowlist. This is used in
--   <tt>runDropCollection</tt> to function to ensure that we don't delete
--   any collections which are referred to in the allowlist.
metadataAllowlistAllCollections :: MetadataAllowlist -> [CollectionName]

-- | A query stripped of typenames. A query is allowed if it occurs in an
--   allowed query collection after normalization.
--   
--   Compare docs<i>graphql</i>core<i>deployment</i>allow-list.rst.
newtype NormalizedQuery
NormalizedQuery :: ExecutableDocument Name -> NormalizedQuery
[unNormalizedQuery] :: NormalizedQuery -> ExecutableDocument Name

-- | InlinedAllowlist is the data type with which the allowlist is
--   represented in the schema cache, it contains a global and a per role
--   allowlist and when allowlist is enabled in the graphql-engine, the
--   incoming query for a non-admin role should either be in the global
--   allowlist or in the given role's role based allowlist.
--   
--   Essentially, it's a memoization of <a>allowlistAllowsQuery</a>
--   implemented in terms of <a>MetadataAllowlist</a>.
data InlinedAllowlist
InlinedAllowlist :: HashSet NormalizedQuery -> HashMap RoleName (HashSet NormalizedQuery) -> InlinedAllowlist
[iaGlobal] :: InlinedAllowlist -> HashSet NormalizedQuery
[iaPerRole] :: InlinedAllowlist -> HashMap RoleName (HashSet NormalizedQuery)
inlineAllowlist :: QueryCollections -> MetadataAllowlist -> InlinedAllowlist

-- | The mode in which the allowlist functions. In global mode, collections
--   with non-global scope are ignored.
data AllowlistMode
AllowlistModeGlobalOnly :: AllowlistMode
AllowlistModeFull :: AllowlistMode
allowlistAllowsQuery :: InlinedAllowlist -> AllowlistMode -> RoleName -> ExecutableDocument Name -> Bool
instance GHC.Generics.Generic Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance GHC.Show.Show Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance GHC.Generics.Generic Hasura.RQL.Types.Allowlist.AllowlistScope
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.AllowlistScope
instance GHC.Show.Show Hasura.RQL.Types.Allowlist.AllowlistScope
instance GHC.Generics.Generic Hasura.RQL.Types.Allowlist.AllowlistEntry
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.AllowlistEntry
instance GHC.Show.Show Hasura.RQL.Types.Allowlist.AllowlistEntry
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.NormalizedQuery
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Allowlist.NormalizedQuery
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.NormalizedQuery
instance GHC.Show.Show Hasura.RQL.Types.Allowlist.NormalizedQuery
instance GHC.Generics.Generic Hasura.RQL.Types.Allowlist.InlinedAllowlist
instance GHC.Classes.Eq Hasura.RQL.Types.Allowlist.InlinedAllowlist
instance GHC.Show.Show Hasura.RQL.Types.Allowlist.InlinedAllowlist
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.InlinedAllowlist
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.UpdateScopeOfCollectionInAllowlist
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Allowlist.AllowlistEntry
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.AllowlistEntry
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.AllowlistEntry
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Allowlist.AllowlistScope
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.AllowlistScope
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.AllowlistScope
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Allowlist.DropCollectionFromAllowlist


-- | Definitions for schema building configuration.
module Hasura.RQL.Types.Schema.Options

-- | The record of options required to build the schema. This includes
--   options that can be enabled with <a>ExperimentalFeature</a> flags.
data SchemaOptions
SchemaOptions :: StringifyNumbers -> DangerouslyCollapseBooleans -> RemoteNullForwardingPolicy -> InferFunctionPermissions -> OptimizePermissionFilters -> IncludeUpdateManyFields -> IncludeAggregationPredicates -> IncludeStreamFields -> BigQueryStringNumericInput -> IncludeGroupByAggregateFields -> UsePostgresArrays -> SchemaOptions
[soStringifyNumbers] :: SchemaOptions -> StringifyNumbers
[soDangerousBooleanCollapse] :: SchemaOptions -> DangerouslyCollapseBooleans
[soRemoteNullForwardingPolicy] :: SchemaOptions -> RemoteNullForwardingPolicy
[soInferFunctionPermissions] :: SchemaOptions -> InferFunctionPermissions
[soOptimizePermissionFilters] :: SchemaOptions -> OptimizePermissionFilters
[soIncludeUpdateManyFields] :: SchemaOptions -> IncludeUpdateManyFields
[soIncludeAggregationPredicates] :: SchemaOptions -> IncludeAggregationPredicates
[soIncludeStreamFields] :: SchemaOptions -> IncludeStreamFields
[soBigQueryStringNumericInput] :: SchemaOptions -> BigQueryStringNumericInput
[soIncludeGroupByAggregateFields] :: SchemaOptions -> IncludeGroupByAggregateFields
[soPostgresArrays] :: SchemaOptions -> UsePostgresArrays

-- | Should we represent numbers in our responses as numbers, or strings?
--   Some backends can return numbers that exceed the bounds of JSON's own
--   number type. In these cases, we can use stringified versions of these
--   numbers to avoid this problem.
data StringifyNumbers
StringifyNumbers :: StringifyNumbers
Don'tStringifyNumbers :: StringifyNumbers

-- | Should we include <tt>TABLE_updates</tt> fields in schemas This is a
--   toggle so that users can opt-in, and so that we can rename any tables
--   that this may conflict with if needed
data IncludeUpdateManyFields
IncludeUpdateManyFields :: IncludeUpdateManyFields
Don'tIncludeUpdateManyFields :: IncludeUpdateManyFields

-- | Should we include <tt>TABLE_stream</tt> fields in schemas This is a
--   toggle so that users can opt-in, and so that we can rename any tables
--   that this may conflict with if needed
data IncludeStreamFields
IncludeStreamFields :: IncludeStreamFields
Don'tIncludeStreamFields :: IncludeStreamFields

-- | Should we include aggregation functions in where clauses? Because this
--   has the potential to cause naming conflicts in graphql schema types,
--   this flag allows users to toggle the feature off if it an upgrade
--   breaks their setup.
data IncludeAggregationPredicates
IncludeAggregationPredicates :: IncludeAggregationPredicates
Don'tIncludeAggregationPredicates :: IncludeAggregationPredicates

-- | Should Boolean fields be collapsed to <a>True</a> when a null value is
--   given? This was the behaviour of Hasura V1, and is now discouraged.
data DangerouslyCollapseBooleans
DangerouslyCollapseBooleans :: DangerouslyCollapseBooleans
Don'tDangerouslyCollapseBooleans :: DangerouslyCollapseBooleans
data RemoteNullForwardingPolicy
RemoteForwardAccurately :: RemoteNullForwardingPolicy
RemoteOnlyForwardNonNull :: RemoteNullForwardingPolicy

-- | Should we infer function permissions? If this flag is set to
--   <a>InferFunctionPermissions</a>, we may fail to build expression
--   parsers in <tt>buildQueryAndSubscriptionFields</tt> for users with
--   unrecognised roles.
data InferFunctionPermissions
InferFunctionPermissions :: InferFunctionPermissions
Don'tInferFunctionPermissions :: InferFunctionPermissions

-- | Should we enable remote schema permissions? If so, these permissions
--   will influence <a>buildGQLContext</a>.
data RemoteSchemaPermissions
EnableRemoteSchemaPermissions :: RemoteSchemaPermissions
DisableRemoteSchemaPermissions :: RemoteSchemaPermissions

-- | Should we attempt to deduplicate permission filters? This flag is used
--   in <a>relationshipField</a> to determine whether certain row-level
--   permission filters can be dropped in certain cases.
data OptimizePermissionFilters
OptimizePermissionFilters :: OptimizePermissionFilters
Don'tOptimizePermissionFilters :: OptimizePermissionFilters

-- | Should we enable string-accepting scalar parsers for BigQuery sources
data BigQueryStringNumericInput
EnableBigQueryStringNumericInput :: BigQueryStringNumericInput
DisableBigQueryStringNumericInput :: BigQueryStringNumericInput
data IncludeGroupByAggregateFields
IncludeGroupByAggregateFields :: IncludeGroupByAggregateFields
ExcludeGroupByAggregateFields :: IncludeGroupByAggregateFields

-- | if we use Postgres arrays then an array of <tt>text</tt> becomes
--   `[String!]`, however we want users to have the option to make it
--   output <tt>_text</tt> like it did before for compatibility.
data UsePostgresArrays
UsePostgresArrays :: UsePostgresArrays
DontUsePostgresArrays :: UsePostgresArrays
instance GHC.Show.Show Hasura.RQL.Types.Schema.Options.StringifyNumbers
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.StringifyNumbers
instance GHC.Show.Show Hasura.RQL.Types.Schema.Options.IncludeUpdateManyFields
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.IncludeUpdateManyFields
instance GHC.Show.Show Hasura.RQL.Types.Schema.Options.IncludeStreamFields
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.IncludeStreamFields
instance GHC.Show.Show Hasura.RQL.Types.Schema.Options.DangerouslyCollapseBooleans
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.DangerouslyCollapseBooleans
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.RemoteNullForwardingPolicy
instance GHC.Show.Show Hasura.RQL.Types.Schema.Options.RemoteNullForwardingPolicy
instance GHC.Show.Show Hasura.RQL.Types.Schema.Options.InferFunctionPermissions
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.InferFunctionPermissions
instance GHC.Show.Show Hasura.RQL.Types.Schema.Options.RemoteSchemaPermissions
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.RemoteSchemaPermissions
instance GHC.Show.Show Hasura.RQL.Types.Schema.Options.OptimizePermissionFilters
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.OptimizePermissionFilters
instance GHC.Show.Show Hasura.RQL.Types.Schema.Options.BigQueryStringNumericInput
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.BigQueryStringNumericInput
instance GHC.Show.Show Hasura.RQL.Types.Schema.Options.IncludeGroupByAggregateFields
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.IncludeGroupByAggregateFields
instance GHC.Show.Show Hasura.RQL.Types.Schema.Options.UsePostgresArrays
instance GHC.Classes.Eq Hasura.RQL.Types.Schema.Options.UsePostgresArrays
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Schema.Options.RemoteSchemaPermissions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Schema.Options.RemoteSchemaPermissions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Schema.Options.InferFunctionPermissions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Schema.Options.InferFunctionPermissions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Schema.Options.RemoteNullForwardingPolicy
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Schema.Options.RemoteNullForwardingPolicy
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Schema.Options.DangerouslyCollapseBooleans
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Schema.Options.DangerouslyCollapseBooleans

module Hasura.RQL.Types.Common
newtype RelName
RelName :: NonEmptyText -> RelName
[getRelTxt] :: RelName -> NonEmptyText
relNameToTxt :: RelName -> Text
fromRemoteRelationship :: RelName -> FieldName
data RelType
ObjRel :: RelType
ArrRel :: RelType
relTypeToTxt :: RelType -> Text
data JsonAggSelect
JASMultipleRows :: JsonAggSelect
JASSingleObject :: JsonAggSelect
data InsertOrder
BeforeParent :: InsertOrder
AfterParent :: InsertOrder

-- | Postgres OIDs.
--   <a>https://www.postgresql.org/docs/12/datatype-oid.html</a>
newtype OID
OID :: Int -> OID
[unOID] :: OID -> Int
newtype FieldName
FieldName :: Text -> FieldName
[getFieldNameTxt] :: FieldName -> Text
type Fields a = [(FieldName, a)]
class ToAesonPairs a
toAesonPairs :: (ToAesonPairs a, KeyValue v) => a -> [v]
data SourceName
SNDefault :: SourceName
SNName :: NonEmptyText -> SourceName
sourceNameToText :: SourceName -> Text
defaultSource :: SourceName
data InpValInfo
InpValInfo :: Maybe Description -> Name -> Maybe (Value Void) -> GType -> InpValInfo
[_iviDesc] :: InpValInfo -> Maybe Description
[_iviName] :: InpValInfo -> Name
[_iviDefVal] :: InpValInfo -> Maybe (Value Void)
[_iviType] :: InpValInfo -> GType
newtype SystemDefined
SystemDefined :: Bool -> SystemDefined
[unSystemDefined] :: SystemDefined -> Bool
isSystemDefined :: SystemDefined -> Bool
data SQLGenCtx
SQLGenCtx :: StringifyNumbers -> DangerouslyCollapseBooleans -> RemoteNullForwardingPolicy -> OptimizePermissionFilters -> BigQueryStringNumericInput -> SQLGenCtx
[stringifyNum] :: SQLGenCtx -> StringifyNumbers
[dangerousBooleanCollapse] :: SQLGenCtx -> DangerouslyCollapseBooleans
[remoteNullForwardingPolicy] :: SQLGenCtx -> RemoteNullForwardingPolicy
[optimizePermissionFilters] :: SQLGenCtx -> OptimizePermissionFilters
[bigqueryStringNumericInput] :: SQLGenCtx -> BigQueryStringNumericInput
successMsg :: EncJSON
failureMsg :: EncJSON
newtype ResolvedWebhook
ResolvedWebhook :: Text -> ResolvedWebhook
[unResolvedWebhook] :: ResolvedWebhook -> Text
newtype InputWebhook
InputWebhook :: Template -> InputWebhook
[unInputWebhook] :: InputWebhook -> Template
newtype ResolveWebhookError
ResolveWebhookError :: Text -> ResolveWebhookError
[unResolveWebhookError] :: ResolveWebhookError -> Text
resolveWebhook :: QErrM m => Environment -> InputWebhook -> m ResolvedWebhook
resolveWebhookEither :: Environment -> InputWebhook -> Either ResolveWebhookError ResolvedWebhook
newtype Timeout
Timeout :: Int -> Timeout
[unTimeout] :: Timeout -> Int
defaultActionTimeoutSecs :: Timeout

-- | See API reference here:
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/syntax-defs.html#pgconnectionparameters</a>
data PGConnectionParams
PGConnectionParams :: Text -> Text -> Maybe Text -> Int -> Text -> PGConnectionParams
[_pgcpHost] :: PGConnectionParams -> Text
[_pgcpUsername] :: PGConnectionParams -> Text
[_pgcpPassword] :: PGConnectionParams -> Maybe Text
[_pgcpPort] :: PGConnectionParams -> Int
[_pgcpDatabase] :: PGConnectionParams -> Text
data UrlConf

-- | the database connection string
UrlValue :: InputWebhook -> UrlConf

-- | the name of environment variable containing the connection string
UrlFromEnv :: Text -> UrlConf

-- | the minimum required `connection parameters` to construct a valid
--   connection string
UrlFromParams :: PGConnectionParams -> UrlConf
getConnOptionsFromConnParams :: PGConnectionParams -> ConnOptions

-- | Construct a Postgres connection URI as a String from
--   <a>PGConnectionParams</a>.
--   
--   NOTE: This function takes care to properly escape all URI components,
--   as Postgres requires that a connection URI is percent-encoded if it
--   includes symbols with "special meaning".
--   
--   See the <tt>libpq</tt> documentation for details:
--   <a>https://www.postgresql.org/docs/13/libpq-connect.html#id-1.7.3.8.3.6</a>
getPGConnectionStringFromParams :: PGConnectionParams -> String
resolveUrlConf :: MonadError QErr m => Environment -> UrlConf -> m Text
getEnv :: QErrM m => Environment -> Text -> m Text
getEnvEither :: Environment -> Text -> Either Text Text

-- | Various user-controlled configuration for metrics used by Pro
data MetricsConfig
MetricsConfig :: Bool -> Bool -> MetricsConfig

-- | should the query-variables be logged and analyzed for metrics
[_mcAnalyzeQueryVariables] :: MetricsConfig -> Bool

-- | should the response-body be analyzed for empty and null responses
[_mcAnalyzeResponseBody] :: MetricsConfig -> Bool
emptyMetricsConfig :: MetricsConfig
data Comment

-- | Automatically generate a comment (derive it from DB comments, or a
--   sensible default describing the source of the data)
Automatic :: Comment

-- | The user's explicitly provided comment, or explicitly no comment (ie.
--   leave it blank, do not autogenerate one)
Explicit :: Maybe NonEmptyText -> Comment
commentToMaybeText :: Comment -> Maybe Text
commentFromMaybeText :: Maybe Text -> Comment

-- | We use the following type, after we resolve the env var. | This will
--   store both the env var name and the resolved value.
data EnvRecord a
EnvRecord :: Text -> a -> EnvRecord a
[_envVarName] :: EnvRecord a -> Text
[_envVarValue] :: EnvRecord a -> a
data ApolloFederationVersion
V1 :: ApolloFederationVersion
data ApolloFederationConfig
ApolloFederationConfig :: ApolloFederationVersion -> ApolloFederationConfig
[enable] :: ApolloFederationConfig -> ApolloFederationVersion
isApolloFedV1enabled :: Maybe ApolloFederationConfig -> Bool

-- | Type to indicate if the SQL trigger should be enabled when data is
--   inserted into a table through replication.
data TriggerOnReplication
TOREnableTrigger :: TriggerOnReplication
TORDisableTrigger :: TriggerOnReplication

-- | Metadata representation of a generic remote relationship, regardless
--   of the source: all sources use this same agnostic definition. The
--   internal definition field is where we differentiate between different
--   targets.
--   
--   TODO: This needs to be moved to an appropriate module, maybe something
--   like Hasura.RemoteRelationships.Metadata.
data RemoteRelationshipG definition
RemoteRelationship :: RelName -> definition -> RemoteRelationshipG definition
[_rrName] :: RemoteRelationshipG definition -> RelName
[_rrDefinition] :: RemoteRelationshipG definition -> definition
rrName :: Lens (RemoteRelationshipG def) (RemoteRelationshipG def) RelName RelName
rrDefinition :: Lens (RemoteRelationshipG def) (RemoteRelationshipG def') def def'
remoteRelationshipCodec :: forall definition. Typeable definition => JSONCodec definition -> JSONCodec (RemoteRelationshipG definition)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.RelName
instance GHC.Generics.Generic Hasura.RQL.Types.Common.RelName
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.RelName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Common.RelName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.RelName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.RelName
instance GHC.Classes.Ord Hasura.RQL.Types.Common.RelName
instance GHC.Classes.Eq Hasura.RQL.Types.Common.RelName
instance GHC.Show.Show Hasura.RQL.Types.Common.RelName
instance Data.Data.Data Hasura.RQL.Types.Common.RelType
instance GHC.Generics.Generic Hasura.RQL.Types.Common.RelType
instance GHC.Classes.Ord Hasura.RQL.Types.Common.RelType
instance GHC.Classes.Eq Hasura.RQL.Types.Common.RelType
instance GHC.Show.Show Hasura.RQL.Types.Common.RelType
instance GHC.Generics.Generic Hasura.RQL.Types.Common.JsonAggSelect
instance GHC.Classes.Eq Hasura.RQL.Types.Common.JsonAggSelect
instance GHC.Show.Show Hasura.RQL.Types.Common.JsonAggSelect
instance GHC.Generics.Generic Hasura.RQL.Types.Common.InsertOrder
instance GHC.Classes.Ord Hasura.RQL.Types.Common.InsertOrder
instance GHC.Classes.Eq Hasura.RQL.Types.Common.InsertOrder
instance GHC.Show.Show Hasura.RQL.Types.Common.InsertOrder
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.OID
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.OID
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.OID
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.OID
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.OID
instance GHC.Classes.Eq Hasura.RQL.Types.Common.OID
instance GHC.Show.Show Hasura.RQL.Types.Common.OID
instance GHC.Base.Semigroup Hasura.RQL.Types.Common.FieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.FieldName
instance Data.String.IsString Hasura.RQL.Types.Common.FieldName
instance GHC.Generics.Generic Hasura.RQL.Types.Common.FieldName
instance Data.Data.Data Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.FieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.FieldName
instance GHC.Classes.Ord Hasura.RQL.Types.Common.FieldName
instance GHC.Classes.Eq Hasura.RQL.Types.Common.FieldName
instance GHC.Show.Show Hasura.RQL.Types.Common.FieldName
instance GHC.Generics.Generic Hasura.RQL.Types.Common.SourceName
instance GHC.Classes.Ord Hasura.RQL.Types.Common.SourceName
instance GHC.Classes.Eq Hasura.RQL.Types.Common.SourceName
instance GHC.Show.Show Hasura.RQL.Types.Common.SourceName
instance GHC.Generics.Generic Hasura.RQL.Types.Common.InpValInfo
instance Language.Haskell.TH.Syntax.Lift Hasura.RQL.Types.Common.InpValInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Common.InpValInfo
instance GHC.Show.Show Hasura.RQL.Types.Common.InpValInfo
instance GHC.Generics.Generic Hasura.RQL.Types.Common.SystemDefined
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.SystemDefined
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Common.SystemDefined
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.SystemDefined
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.SystemDefined
instance GHC.Classes.Eq Hasura.RQL.Types.Common.SystemDefined
instance GHC.Show.Show Hasura.RQL.Types.Common.SystemDefined
instance GHC.Classes.Eq Hasura.RQL.Types.Common.SQLGenCtx
instance GHC.Show.Show Hasura.RQL.Types.Common.SQLGenCtx
instance GHC.Generics.Generic Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.ResolvedWebhook
instance GHC.Classes.Eq Hasura.RQL.Types.Common.ResolvedWebhook
instance GHC.Show.Show Hasura.RQL.Types.Common.ResolvedWebhook
instance GHC.Generics.Generic Hasura.RQL.Types.Common.InputWebhook
instance GHC.Classes.Eq Hasura.RQL.Types.Common.InputWebhook
instance GHC.Show.Show Hasura.RQL.Types.Common.InputWebhook
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.ResolveWebhookError
instance GHC.Show.Show Hasura.RQL.Types.Common.ResolveWebhookError
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.Timeout
instance GHC.Generics.Generic Hasura.RQL.Types.Common.Timeout
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.Timeout
instance GHC.Classes.Eq Hasura.RQL.Types.Common.Timeout
instance GHC.Show.Show Hasura.RQL.Types.Common.Timeout
instance GHC.Generics.Generic Hasura.RQL.Types.Common.PGConnectionParams
instance GHC.Classes.Eq Hasura.RQL.Types.Common.PGConnectionParams
instance GHC.Show.Show Hasura.RQL.Types.Common.PGConnectionParams
instance GHC.Generics.Generic Hasura.RQL.Types.Common.UrlConf
instance GHC.Classes.Eq Hasura.RQL.Types.Common.UrlConf
instance GHC.Show.Show Hasura.RQL.Types.Common.UrlConf
instance GHC.Generics.Generic Hasura.RQL.Types.Common.MetricsConfig
instance GHC.Classes.Eq Hasura.RQL.Types.Common.MetricsConfig
instance GHC.Show.Show Hasura.RQL.Types.Common.MetricsConfig
instance GHC.Generics.Generic Hasura.RQL.Types.Common.Comment
instance GHC.Show.Show Hasura.RQL.Types.Common.Comment
instance GHC.Classes.Eq Hasura.RQL.Types.Common.Comment
instance GHC.Generics.Generic (Hasura.RQL.Types.Common.EnvRecord a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Common.EnvRecord a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.Common.EnvRecord a)
instance GHC.Generics.Generic Hasura.RQL.Types.Common.ApolloFederationVersion
instance GHC.Classes.Eq Hasura.RQL.Types.Common.ApolloFederationVersion
instance GHC.Show.Show Hasura.RQL.Types.Common.ApolloFederationVersion
instance GHC.Generics.Generic Hasura.RQL.Types.Common.ApolloFederationConfig
instance GHC.Classes.Eq Hasura.RQL.Types.Common.ApolloFederationConfig
instance GHC.Show.Show Hasura.RQL.Types.Common.ApolloFederationConfig
instance GHC.Generics.Generic Hasura.RQL.Types.Common.TriggerOnReplication
instance GHC.Classes.Eq Hasura.RQL.Types.Common.TriggerOnReplication
instance GHC.Show.Show Hasura.RQL.Types.Common.TriggerOnReplication
instance GHC.Generics.Generic (Hasura.RQL.Types.Common.RemoteRelationshipG definition)
instance GHC.Classes.Eq definition => GHC.Classes.Eq (Hasura.RQL.Types.Common.RemoteRelationshipG definition)
instance GHC.Show.Show definition => GHC.Show.Show (Hasura.RQL.Types.Common.RemoteRelationshipG definition)
instance Data.Aeson.Types.ToJSON.ToJSON definition => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Common.RemoteRelationshipG definition)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.TriggerOnReplication
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.TriggerOnReplication
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.TriggerOnReplication
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.TriggerOnReplication
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.ApolloFederationConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.ApolloFederationConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.ApolloFederationConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.ApolloFederationConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.ApolloFederationVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.ApolloFederationVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.ApolloFederationVersion
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.ApolloFederationVersion
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.Types.Common.EnvRecord a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Common.EnvRecord a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Common.EnvRecord a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Common.EnvRecord a)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.Comment
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.Comment
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.Comment
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.Comment
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.Comment
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.MetricsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.MetricsConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.MetricsConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.UrlConf
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.UrlConf
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.UrlConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.UrlConf
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.UrlConf
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.PGConnectionParams
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.PGConnectionParams
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.PGConnectionParams
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.PGConnectionParams
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.PGConnectionParams
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.Timeout
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.Timeout
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.InputWebhook
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.InputWebhook
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.InputWebhook
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.InputWebhook
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.InputWebhook
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.InputWebhook
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.ResolvedWebhook
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.SourceName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Common.SourceName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.SourceName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.SourceName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.SourceName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.RQL.Types.Common.SourceName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Common.SourceName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.SourceName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.SourceName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.FieldName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.FieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.InsertOrder
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.InsertOrder
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.InsertOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.InsertOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.InsertOrder
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.JsonAggSelect
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.JsonAggSelect
instance Control.DeepSeq.NFData Hasura.RQL.Types.Common.RelType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Common.RelType
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.RelType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Common.RelType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Common.RelType
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Common.RelType
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Common.RelName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Common.RelName

module Hasura.RQL.Types.ComputedField.Name
newtype ComputedFieldName
ComputedFieldName :: NonEmptyText -> ComputedFieldName
[unComputedFieldName] :: ComputedFieldName -> NonEmptyText
computedFieldNameToText :: ComputedFieldName -> Text
fromComputedField :: ComputedFieldName -> FieldName
instance GHC.Generics.Generic Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Control.DeepSeq.NFData Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance GHC.Classes.Ord Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance GHC.Classes.Eq Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance GHC.Show.Show Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ComputedField.Name.ComputedFieldName

module Hasura.RQL.Types.Session
newtype SessionVariable
SessionVariable :: CI Text -> SessionVariable
[unSessionVariable] :: SessionVariable -> CI Text
type SessionVariableValue = Text
sessionVariablePrefix :: Text
isSessionVariable :: Text -> Bool
parseSessionVariable :: Text -> Parser SessionVariable
sessionVariableToText :: SessionVariable -> Text
mkSessionVariable :: Text -> SessionVariable
newtype SessionVariables
SessionVariables :: HashMap SessionVariable SessionVariableValue -> SessionVariables
[unSessionVariables] :: SessionVariables -> HashMap SessionVariable SessionVariableValue
mkSessionVariablesText :: HashMap Text Text -> SessionVariables

-- | Represent the admin secret state; whether the secret is sent in the
--   request or if actually authorization is not configured.
data UserAdminSecret
UAdminSecretSent :: UserAdminSecret
UAdminSecretNotSent :: UserAdminSecret
UAuthNotSet :: UserAdminSecret

-- | Represents the 'X-Hasura-Use-Backend-Only-Permissions' session
--   variable and request made with 'X-Hasura-Admin-Secret' if any auth
--   configured. For more details see Note [Backend only permissions]
data BackendOnlyFieldAccess
BOFAAllowed :: BackendOnlyFieldAccess
BOFADisallowed :: BackendOnlyFieldAccess
data UserInfo
UserInfo :: !RoleName -> !SessionVariables -> !BackendOnlyFieldAccess -> UserInfo
[_uiRole] :: UserInfo -> !RoleName
[_uiSession] :: UserInfo -> !SessionVariables
[_uiBackendOnlyFieldAccess] :: UserInfo -> !BackendOnlyFieldAccess
class (Monad m) => UserInfoM m
askUserInfo :: UserInfoM m => m UserInfo

-- | extra information used to identify a Hasura User
data ExtraUserInfo
ExtraUserInfo :: Maybe Text -> ExtraUserInfo
[_euiUserId] :: ExtraUserInfo -> Maybe Text

-- | Represents how to build a role from the session variables
data UserRoleBuild

-- | Look for `x-hasura-role` session variable value and absence will raise
--   an exception
URBFromSessionVariables :: UserRoleBuild

-- | Look for `x-hasura-role` session variable value, if absent fall back
--   to given role
URBFromSessionVariablesFallback :: !RoleName -> UserRoleBuild

-- | Use only the pre-determined role
URBPreDetermined :: !RoleName -> UserRoleBuild
instance GHC.Classes.Ord Hasura.RQL.Types.Session.SessionVariable
instance Control.DeepSeq.NFData Hasura.RQL.Types.Session.SessionVariable
instance Data.Data.Data Hasura.RQL.Types.Session.SessionVariable
instance Data.String.IsString Hasura.RQL.Types.Session.SessionVariable
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Session.SessionVariable
instance GHC.Classes.Eq Hasura.RQL.Types.Session.SessionVariable
instance GHC.Show.Show Hasura.RQL.Types.Session.SessionVariable
instance GHC.Base.Monoid Hasura.RQL.Types.Session.SessionVariables
instance GHC.Base.Semigroup Hasura.RQL.Types.Session.SessionVariables
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Session.SessionVariables
instance GHC.Classes.Eq Hasura.RQL.Types.Session.SessionVariables
instance GHC.Show.Show Hasura.RQL.Types.Session.SessionVariables
instance GHC.Classes.Eq Hasura.RQL.Types.Session.UserAdminSecret
instance GHC.Show.Show Hasura.RQL.Types.Session.UserAdminSecret
instance GHC.Generics.Generic Hasura.RQL.Types.Session.BackendOnlyFieldAccess
instance GHC.Classes.Eq Hasura.RQL.Types.Session.BackendOnlyFieldAccess
instance GHC.Show.Show Hasura.RQL.Types.Session.BackendOnlyFieldAccess
instance GHC.Generics.Generic Hasura.RQL.Types.Session.UserInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Session.UserInfo
instance GHC.Show.Show Hasura.RQL.Types.Session.UserInfo
instance GHC.Generics.Generic Hasura.RQL.Types.Session.ExtraUserInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Session.ExtraUserInfo
instance GHC.Show.Show Hasura.RQL.Types.Session.ExtraUserInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Session.UserRoleBuild
instance GHC.Show.Show Hasura.RQL.Types.Session.UserRoleBuild
instance Hasura.RQL.Types.Session.UserInfoM m => Hasura.RQL.Types.Session.UserInfoM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.Session.UserInfoM m => Hasura.RQL.Types.Session.UserInfoM (Control.Monad.Trans.Except.ExceptT r m)
instance Hasura.RQL.Types.Session.UserInfoM m => Hasura.RQL.Types.Session.UserInfoM (Control.Monad.Trans.State.Strict.StateT s m)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Session.UserInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Session.UserInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Session.UserInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Session.BackendOnlyFieldAccess
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Session.BackendOnlyFieldAccess
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Session.BackendOnlyFieldAccess
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Session.SessionVariables
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Session.SessionVariables
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Session.SessionVariable
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Session.SessionVariable
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Session.SessionVariable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Session.SessionVariable
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Session.SessionVariable

module Hasura.RQL.Types.ApiLimit
data ApiLimit
ApiLimit :: Maybe RateLimit -> Maybe DepthLimit -> Maybe NodeLimit -> Maybe TimeLimit -> Maybe BatchLimit -> Bool -> ApiLimit
[_alRateLimit] :: ApiLimit -> Maybe RateLimit
[_alDepthLimit] :: ApiLimit -> Maybe DepthLimit
[_alNodeLimit] :: ApiLimit -> Maybe NodeLimit
[_alTimeLimit] :: ApiLimit -> Maybe TimeLimit
[_alBatchLimit] :: ApiLimit -> Maybe BatchLimit
[_alDisabled] :: ApiLimit -> Bool
emptyApiLimit :: ApiLimit
data Limit a
Limit :: a -> Map RoleName a -> Limit a
[_lGlobal] :: Limit a -> a
[_lPerRole] :: Limit a -> Map RoleName a
type RateLimit = Limit RateLimitConfig
type DepthLimit = Limit MaxDepth
type NodeLimit = Limit MaxNodes
type TimeLimit = Limit MaxTime
type BatchLimit = Limit MaxBatchSize
data RateLimitConfig
RateLimitConfig :: Int -> Maybe UniqueParamConfig -> RateLimitConfig
[_rlcMaxReqsPerMin] :: RateLimitConfig -> Int
[_rlcUniqueParams] :: RateLimitConfig -> Maybe UniqueParamConfig

-- | The unique key using which an authenticated client can be identified
data UniqueParamConfig

-- | it can be a list of session variable (like session var in
--   <tt>UserInfo</tt>)
UPCSessionVar :: [Text] -> UniqueParamConfig

-- | or it can be an IP address
UPCIpAddress :: UniqueParamConfig
newtype MaxDepth
MaxDepth :: Int -> MaxDepth
[unMaxDepth] :: MaxDepth -> Int
newtype MaxNodes
MaxNodes :: Int -> MaxNodes
[unMaxNodes] :: MaxNodes -> Int
newtype MaxTime
MaxTime :: Seconds -> MaxTime
[unMaxTime] :: MaxTime -> Seconds
newtype MaxBatchSize
MaxBatchSize :: Int -> MaxBatchSize
[unMaxBatchSize] :: MaxBatchSize -> Int
instance GHC.Generics.Generic (Hasura.RQL.Types.ApiLimit.Limit a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.ApiLimit.Limit a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.ApiLimit.Limit a)
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.MaxDepth
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Classes.Ord Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.MaxDepth
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.MaxDepth
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.MaxNodes
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Classes.Ord Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.MaxNodes
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.MaxNodes
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.MaxTime
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Classes.Ord Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.MaxTime
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.MaxTime
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance GHC.Classes.Ord Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance GHC.Generics.Generic Hasura.RQL.Types.ApiLimit.ApiLimit
instance GHC.Classes.Eq Hasura.RQL.Types.ApiLimit.ApiLimit
instance GHC.Show.Show Hasura.RQL.Types.ApiLimit.ApiLimit
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.ApiLimit
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.ApiLimit
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.ApiLimit
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.MaxBatchSize
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.MaxTime
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.ApiLimit.MaxTime
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.MaxNodes
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.MaxDepth
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.RateLimitConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ApiLimit.UniqueParamConfig
instance (Autodocodec.Class.HasCodec a, Data.Typeable.Internal.Typeable a) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.ApiLimit.Limit a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.ApiLimit.Limit a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.ApiLimit.Limit a)

module Hasura.RQL.Types.Source.TableType
data SourceTableType
Table :: SourceTableType
View :: SourceTableType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Source.TableType.SourceTableType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Source.TableType.SourceTableType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Source.TableType.SourceTableType
instance Control.DeepSeq.NFData Hasura.RQL.Types.Source.TableType.SourceTableType
instance GHC.Enum.Bounded Hasura.RQL.Types.Source.TableType.SourceTableType
instance GHC.Enum.Enum Hasura.RQL.Types.Source.TableType.SourceTableType
instance GHC.Generics.Generic Hasura.RQL.Types.Source.TableType.SourceTableType
instance GHC.Show.Show Hasura.RQL.Types.Source.TableType.SourceTableType
instance GHC.Classes.Ord Hasura.RQL.Types.Source.TableType.SourceTableType
instance GHC.Classes.Eq Hasura.RQL.Types.Source.TableType.SourceTableType
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Source.TableType.SourceTableType

module Hasura.RQL.Types.SourceConfiguration
type Representable a = (Show a, Eq a, Hashable a, NFData a)
class (Representable (SourceConnConfiguration b), HasCodec (SourceConnConfiguration b), FromJSON (SourceConnConfiguration b), ToJSON (SourceConfig b), ToJSON (SourceConnConfiguration b), Eq (SourceConfig b), Has (ScalarTypeParsingContext b) (SourceConfig b), Eq (ScalarTypeParsingContext b), Ord (ScalarTypeParsingContext b), HasTag b) => HasSourceConfiguration (b :: BackendType) where {
    type ScalarTypeParsingContext b;
    
    -- | User facing connection configuration for a database.
    type SourceConnConfiguration b :: Type;
    
    -- | Internal connection configuration for a database - connection string,
    --   connection pool etc
    type SourceConfig b :: Type;
    type ScalarTypeParsingContext b = ();
}

-- | The number of read replicas specified in the source configuration
sourceConfigNumReadReplicas :: HasSourceConfiguration b => SourceConfig b -> Int

-- | Whether the source configuration specifies the use of a connection
--   template
sourceConfigConnectonTemplateEnabled :: HasSourceConfiguration b => SourceConfig b -> Bool

-- | Whether or not the source supports performing column redaction. See
--   note [SQL generation for inherited roles] for more information
sourceSupportsColumnRedaction :: HasSourceConfiguration b => SourceConfig b -> Bool
sourceConfigBackendSourceKind :: HasSourceConfiguration b => SourceConfig b -> BackendSourceKind b

module Hasura.RQL.Types.Subscription

-- | CursorOrdering is used in the streaming subscriptions to specify how
--   to order the cursor.
data CursorOrdering
COAscending :: CursorOrdering
CODescending :: CursorOrdering
data SubscriptionType
Streaming :: SubscriptionType
LiveQuery :: SubscriptionType
instance GHC.Generics.Generic Hasura.RQL.Types.Subscription.CursorOrdering
instance GHC.Classes.Eq Hasura.RQL.Types.Subscription.CursorOrdering
instance GHC.Show.Show Hasura.RQL.Types.Subscription.CursorOrdering
instance GHC.Generics.Generic Hasura.RQL.Types.Subscription.SubscriptionType
instance GHC.Classes.Eq Hasura.RQL.Types.Subscription.SubscriptionType
instance GHC.Show.Show Hasura.RQL.Types.Subscription.SubscriptionType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Subscription.SubscriptionType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Subscription.CursorOrdering

module Hasura.RQL.Types.Webhook.Transform.Class

-- | Textual transformation template.
newtype Template
Template :: Text -> Template
[unTemplate] :: Template -> Text

-- | Validated textual transformation template /for string interpolation
--   only/.
--   
--   This is necessary due to Kriti not distinguishing between string
--   literals and string templates.
newtype UnescapedTemplate
UnescapedTemplate :: Text -> UnescapedTemplate
[getUnescapedTemplate] :: UnescapedTemplate -> Text

-- | Available templating engines.
data TemplatingEngine
Kriti :: TemplatingEngine

-- | The associated type 'TransformFn a' is the defunctionalized version of
--   some transformation that should be applied to a given request field.
--   
--   In most cases it is some variation on a piece of template text
--   describing the transformation.
data family TransformFn a :: Type
data family TransformCtx a :: Type

-- | We use collect all transformation failures as a '[J.Value]'.
newtype TransformErrorBundle
TransformErrorBundle :: [Value] -> TransformErrorBundle
[tebMessages] :: TransformErrorBundle -> [Value]
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Webhook.Transform.Class.Template
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Class.Template
instance GHC.Classes.Ord Hasura.RQL.Types.Webhook.Transform.Class.Template
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Class.Template
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Classes.Ord Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance GHC.Enum.Enum Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance GHC.Enum.Bounded Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Base.Semigroup Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Base.Monoid Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Class.TransformErrorBundle
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Class.TemplatingEngine
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Class.UnescapedTemplate
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Class.Template
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Class.Template


-- | The <a>Transform</a> typeclass with various types and helper functions
--   for evaluating transformations.
module Hasura.RQL.DDL.Webhook.Transform.Class

-- | <a>Transform</a> describes how to reify a defunctionalized
--   transformation for a particular request field.
class Transform a

-- | <a>transform</a> is a function which takes <a>TransformFn</a> of
--   <tt>a</tt> and reifies it into a function of the form:
--   
--   <pre>
--   ReqTransformCtx -&gt; a -&gt; m a
--   </pre>
transform :: (Transform a, MonadError TransformErrorBundle m) => TransformFn a -> TransformCtx a -> a -> m a

-- | Validate a <a>TransformFn</a> of <tt>a</tt>.
validate :: Transform a => TemplatingEngine -> TransformFn a -> Validation TransformErrorBundle ()

-- | A helper function for serializing transformation errors to JSON.
throwErrorBundle :: MonadError TransformErrorBundle m => Text -> Maybe Value -> m a

-- | Wrap an <a>UnescapedTemplate</a> with escaped double quotes.
wrapUnescapedTemplate :: UnescapedTemplate -> Template

-- | Encode a JSON Scalar Value as a <a>ByteString</a>. If a non-Scalar
--   value is provided, will return a <tt>TrnasformErrorBundle</tt>
encodeScalar :: MonadError TransformErrorBundle m => Value -> m ByteString

module Hasura.RQL.Types.Webhook.Transform.WithOptional

-- | Enrich a <a>Functor</a> <tt>f</tt> with optionality; this is primarily
--   useful when one wants to annotate fields as optional when using the
--   Higher-Kinded Data pattern.
--   
--   <a>WithOptional</a><tt> f</tt> is equivalent to <tt>Compose Maybe
--   f</tt>.
newtype WithOptional f result
WithOptional :: Maybe (f result) -> WithOptional f result
[getOptional] :: WithOptional f result -> Maybe (f result)

-- | <a>WithOptional</a> smart constructor for the special case of optional
--   values that are representationally equivalent to some "wrapper" type.
--   
--   For example: <tt> withOptional @HeaderTransformsAction headers ==
--   WithOptional $ fmap HeadersTransform headers </tt>
--   
--   In other words: this function observes the isomorphism between
--   <tt><a>Maybe</a> a</tt> and <tt><a>WithOptional</a> f b</tt> if an
--   isomorphism exists between <tt>a</tt> and <tt>f b</tt>.
withOptional :: forall a b f. Coercible a (f b) => Maybe a -> WithOptional f b

-- | Define a field in an object codec that applies <a>withOptional</a>
--   when decoding, and applies <a>getOptional</a> when encoding.
withOptionalField' :: forall a b f. (Coercible a (f b), HasCodec a) => Text -> ObjectCodec (WithOptional f b) (WithOptional f b)

-- | Define a field in an object codec that applies <a>withOptional</a>
--   when decoding, and applies <a>getOptional</a> when encoding.
--   
--   This version takes a codec for the underlying value type as an
--   argument.
withOptionalFieldWith' :: forall a b f. Coercible a (f b) => Text -> ValueCodec a a -> ObjectCodec (WithOptional f b) (WithOptional f b)
instance Data.Aeson.Types.ToJSON.ToJSON (f result) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)
instance Data.Aeson.Types.FromJSON.FromJSON (f result) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)
instance GHC.Show.Show (f result) => GHC.Show.Show (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)
instance GHC.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f)
instance GHC.Base.Functor f => GHC.Base.Functor (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f)
instance GHC.Classes.Eq (f result) => GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)
instance Control.DeepSeq.NFData (f result) => Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.WithOptional.WithOptional f result)

module Hasura.RemoteSchema.Metadata.Base

-- | Remote schema identifier.
--   
--   NOTE: no validation on the character set is done here; it's likely
--   there is a bug (FIXME) where this interacts with remote relationships
--   and some name mangling needs to happen.
newtype RemoteSchemaName
RemoteSchemaName :: NonEmptyText -> RemoteSchemaName
[unRemoteSchemaName] :: RemoteSchemaName -> NonEmptyText
instance GHC.Generics.Generic Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Text.Extended.ToTxt Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Database.PG.Query.Class.FromCol Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Database.PG.Query.Class.ToPrepArg Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance GHC.Classes.Ord Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance GHC.Show.Show Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Base.RemoteSchemaName

module Hasura.RemoteSchema.Metadata.Customization
data RemoteTypeCustomization
RemoteTypeCustomization :: Maybe Name -> Maybe Name -> HashMap Name Name -> RemoteTypeCustomization
[_rtcPrefix] :: RemoteTypeCustomization -> Maybe Name
[_rtcSuffix] :: RemoteTypeCustomization -> Maybe Name
[_rtcMapping] :: RemoteTypeCustomization -> HashMap Name Name
data RemoteFieldCustomization
RemoteFieldCustomization :: Name -> Maybe Name -> Maybe Name -> HashMap Name Name -> RemoteFieldCustomization
[_rfcParentType] :: RemoteFieldCustomization -> Name
[_rfcPrefix] :: RemoteFieldCustomization -> Maybe Name
[_rfcSuffix] :: RemoteFieldCustomization -> Maybe Name
[_rfcMapping] :: RemoteFieldCustomization -> HashMap Name Name
data RemoteSchemaCustomization
RemoteSchemaCustomization :: Maybe Name -> Maybe RemoteTypeCustomization -> Maybe [RemoteFieldCustomization] -> RemoteSchemaCustomization
[_rscRootFieldsNamespace] :: RemoteSchemaCustomization -> Maybe Name
[_rscTypeNames] :: RemoteSchemaCustomization -> Maybe RemoteTypeCustomization
[_rscFieldNames] :: RemoteSchemaCustomization -> Maybe [RemoteFieldCustomization]
instance GHC.Generics.Generic Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance GHC.Show.Show Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance GHC.Generics.Generic Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance GHC.Show.Show Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance GHC.Generics.Generic Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance GHC.Show.Show Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Customization.RemoteSchemaCustomization
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Customization.RemoteFieldCustomization
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Customization.RemoteTypeCustomization

module Hasura.RemoteSchema.Metadata.Permission
newtype RemoteSchemaPermissionDefinition
RemoteSchemaPermissionDefinition :: SchemaDocument -> RemoteSchemaPermissionDefinition
[_rspdSchema] :: RemoteSchemaPermissionDefinition -> SchemaDocument
data RemoteSchemaPermissionMetadata
RemoteSchemaPermissionMetadata :: RoleName -> RemoteSchemaPermissionDefinition -> Maybe Text -> RemoteSchemaPermissionMetadata
[_rspmRole] :: RemoteSchemaPermissionMetadata -> RoleName
[_rspmDefinition] :: RemoteSchemaPermissionMetadata -> RemoteSchemaPermissionDefinition
[_rspmComment] :: RemoteSchemaPermissionMetadata -> Maybe Text
instance GHC.Generics.Generic Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance GHC.Show.Show Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance GHC.Generics.Generic Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata
instance GHC.Show.Show Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionMetadata
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Permission.RemoteSchemaPermissionDefinition

module Hasura.RemoteSchema.Metadata.RemoteRelationship

-- | Metadata representation of a relationship to a remote schema.
data ToSchemaRelationshipDef
ToSchemaRelationshipDef :: RemoteSchemaName -> HashSet FieldName -> RemoteFields -> ToSchemaRelationshipDef

-- | Identifier for this mapping.
[_trrdRemoteSchema] :: ToSchemaRelationshipDef -> RemoteSchemaName

-- | The lhs fields that must be forwarded to the remote schema.
[_trrdLhsFields] :: ToSchemaRelationshipDef -> HashSet FieldName
[_trrdRemoteField] :: ToSchemaRelationshipDef -> RemoteFields

-- | Targeted field in a remote schema relationship. TODO: explain about
--   subfields and why this is a container
newtype RemoteFields
RemoteFields :: NonEmpty FieldCall -> RemoteFields
[unRemoteFields] :: RemoteFields -> NonEmpty FieldCall

-- | Associates a field name with the arguments it will be passed in the
--   query.
--   
--   
--   <a>https://graphql.github.io/graphql-spec/June2018/#sec-Language.Arguments</a>
data FieldCall
FieldCall :: Name -> RemoteArguments -> FieldCall
[fcName] :: FieldCall -> Name
[fcArguments] :: FieldCall -> RemoteArguments

-- | Arguments to a remote GraphQL fields, represented as a mapping from
--   name to GraphQL Value. Said values can be variable names, in which
--   case they'll be referring to values we're closed over. TODO: expand on
--   this
newtype RemoteArguments
RemoteArguments :: HashMap Name (Value Name) -> RemoteArguments
[getRemoteArguments] :: RemoteArguments -> HashMap Name (Value Name)
data RemoteSchemaTypeRelationships r
RemoteSchemaTypeRelationships :: Name -> RemoteRelationships r -> RemoteSchemaTypeRelationships r
[_rstrsName] :: RemoteSchemaTypeRelationships r -> Name
[_rstrsRelationships] :: RemoteSchemaTypeRelationships r -> RemoteRelationships r
type SchemaRemoteRelationships r = InsOrdHashMap Name (RemoteSchemaTypeRelationships r)
rstrsRelationships :: forall r_a2ZME r_a30BV. Lens (RemoteSchemaTypeRelationships r_a2ZME) (RemoteSchemaTypeRelationships r_a30BV) (RemoteRelationships r_a2ZME) (RemoteRelationships r_a30BV)
rstrsName :: forall r_a2ZME. Lens' (RemoteSchemaTypeRelationships r_a2ZME) Name
trrdRemoteSchema :: Lens' ToSchemaRelationshipDef RemoteSchemaName
trrdRemoteField :: Lens' ToSchemaRelationshipDef RemoteFields
trrdLhsFields :: Lens' ToSchemaRelationshipDef (HashSet FieldName)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance GHC.Generics.Generic Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance GHC.Show.Show Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance GHC.Generics.Generic Hasura.RemoteSchema.Metadata.RemoteRelationship.FieldCall
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.RemoteRelationship.FieldCall
instance GHC.Show.Show Hasura.RemoteSchema.Metadata.RemoteRelationship.FieldCall
instance GHC.Generics.Generic Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance GHC.Show.Show Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance GHC.Generics.Generic Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance GHC.Show.Show Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance GHC.Generics.Generic (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance GHC.Show.Show r => GHC.Show.Show (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance (Autodocodec.Class.HasCodec (Hasura.RQL.Types.Common.RemoteRelationshipG r), Data.Typeable.Internal.Typeable r) => Autodocodec.Class.HasCodec (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Common.RemoteRelationshipG r) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Common.RemoteRelationshipG r) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteSchemaTypeRelationships r)
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.RemoteRelationship.ToSchemaRelationshipDef
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteFields
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.RemoteRelationship.FieldCall
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.RemoteRelationship.FieldCall
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.RemoteRelationship.RemoteArguments

module Hasura.RemoteSchema.Metadata.Core
type UrlFromEnv = Text

-- | Unvalidated remote schema config, from the user's API request
data RemoteSchemaDef
RemoteSchemaDef :: Maybe InputWebhook -> Maybe UrlFromEnv -> Maybe [HeaderConf] -> Bool -> Maybe Int -> Maybe RemoteSchemaCustomization -> RemoteSchemaDef
[_rsdUrl] :: RemoteSchemaDef -> Maybe InputWebhook
[_rsdUrlFromEnv] :: RemoteSchemaDef -> Maybe UrlFromEnv
[_rsdHeaders] :: RemoteSchemaDef -> Maybe [HeaderConf]
[_rsdForwardClientHeaders] :: RemoteSchemaDef -> Bool
[_rsdTimeoutSeconds] :: RemoteSchemaDef -> Maybe Int
[_rsdCustomization] :: RemoteSchemaDef -> Maybe RemoteSchemaCustomization
getUrlFromEnv :: MonadError QErr m => Environment -> Text -> m (EnvRecord URI)
data RemoteSchemaMetadataG r
RemoteSchemaMetadata :: RemoteSchemaName -> RemoteSchemaDef -> Maybe Text -> [RemoteSchemaPermissionMetadata] -> SchemaRemoteRelationships r -> RemoteSchemaMetadataG r
[_rsmName] :: RemoteSchemaMetadataG r -> RemoteSchemaName
[_rsmDefinition] :: RemoteSchemaMetadataG r -> RemoteSchemaDef
[_rsmComment] :: RemoteSchemaMetadataG r -> Maybe Text
[_rsmPermissions] :: RemoteSchemaMetadataG r -> [RemoteSchemaPermissionMetadata]
[_rsmRemoteRelationships] :: RemoteSchemaMetadataG r -> SchemaRemoteRelationships r
rsmRemoteRelationships :: forall r_a34at r_a34KF. Lens (RemoteSchemaMetadataG r_a34at) (RemoteSchemaMetadataG r_a34KF) (SchemaRemoteRelationships r_a34at) (SchemaRemoteRelationships r_a34KF)
rsmPermissions :: forall r_a34at. Lens' (RemoteSchemaMetadataG r_a34at) [RemoteSchemaPermissionMetadata]
rsmName :: forall r_a34at. Lens' (RemoteSchemaMetadataG r_a34at) RemoteSchemaName
rsmDefinition :: forall r_a34at. Lens' (RemoteSchemaMetadataG r_a34at) RemoteSchemaDef
rsmComment :: forall r_a34at. Lens' (RemoteSchemaMetadataG r_a34at) (Maybe Text)
instance GHC.Generics.Generic Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance GHC.Classes.Eq Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance GHC.Show.Show Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance GHC.Generics.Generic (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)
instance GHC.Show.Show r => GHC.Show.Show (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)
instance (Autodocodec.Class.HasCodec (Hasura.RQL.Types.Common.RemoteRelationshipG r), Data.Typeable.Internal.Typeable r) => Autodocodec.Class.HasCodec (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Common.RemoteRelationshipG r) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Common.RemoteRelationshipG r) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RemoteSchema.Metadata.Core.RemoteSchemaMetadataG r)
instance Control.DeepSeq.NFData Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance Autodocodec.Class.HasCodec Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.Metadata.Core.RemoteSchemaDef

module Hasura.RemoteSchema.Metadata


-- | Dispatch over backends.
--   
--   <h1>Creating and consuming <a>AnyBackend</a></h1>
--   
--   Creating a new value of type <a>AnyBackend</a> is done via
--   <a>mkAnyBackend</a>.
--   
--   Consuming a value of type <a>AnyBackend</a> is done via either
--   <tt>runAnyBackend</tt> or any of the dispatch functions
--   (<a>dispatchAnyBackend</a>, <a>dispatchAnyBackend'</a>,
--   <a>dispatchAnyBackend''</a>).
--   
--   For implementation details, or when trying to understand this module,
--   start from <a>AnyBackend</a>.
--   
--   <h1>Backend Architecture</h1>
--   
--   Our multiple backend architecture uses type classes and associated
--   types in order to share code, such as parsing graphql queries,
--   building schemas and metadata, while still accounting for the
--   differences between backends.
--   
--   Each backend implements the <tt>Backend</tt> type class from
--   <a>Hasura.RQL.Types.Backend</a> as well as instances for other classes
--   such as <tt>BackendSchema</tt> from
--   <a>Hasura.GraphQL.Schema.Backend</a>, and define the associated types
--   and functions, such as <tt>ScalarType</tt> and
--   <tt>parseScalarValue</tt>, which fit the backend.
--   
--   Whenever one of these associated types (<tt>ScalarType</tt>,
--   <tt>Column</tt>, etc.) are used, we need to either push the
--   <a>BackendType</a> to our caller (and making our type <tt>BackendType
--   -&gt; Type</tt>), or use <a>AnyBackend</a> (and allow our type to be
--   <a>Type</a>). This is particularly useful when we need to store a
--   container of any backend.
--   
--   In order to actually program abstractly using type classes, we need
--   the type class instances to be available for us to use. This module is
--   a trick to enumerate all supported backends and their respective
--   instances to convince GHC that they can be used.
--   
--   <h1>Example usage</h1>
--   
--   As an example of using this module, consider wanting to write a
--   function that calculates metrics for each source. For example, we want
--   to count the number of tables each source has.
--   
--   The <tt>SchemaCache</tt> (defined in
--   <a>Hasura.RQL.Types.SchemaCache</a>) holds a hash map from each source
--   to their information. The source information is parameterized by the
--   <a>BackendType</a> and is hidden using an existential type inside
--   <a>AnyBackend</a>. It essentially looks like this:
--   
--   <pre>
--   data SourceInfo b = ...
--   
--   type SourceCache = HashMap SourceName (AnyBackend SourceInfo)
--   </pre>
--   
--   Our metrics calculation function cares which backend it receives, but
--   only for its type class instances so it can call the relevant
--   functions:
--   
--   <pre>
--   telemetryForSource :: forall (b :: BackendType). SourceInfo b -&gt; TelemetryPayload
--   </pre>
--   
--   In order to apply this function to all backends and return the
--   telemetry payload for each, we need to map over the hash map and
--   dispatch the function over the relevant backend. we can do this with
--   <a>runBackend</a>:
--   
--   <pre>
--   telemetries =
--     map
--       (`runBackend` telemetryForSource)
--       (scSources schemaCache)
--   </pre>
--   
--   If we want to be able to extract some information about the backend
--   type inside <tt>telemetryForSource</tt>, we can do this using
--   <a>backendTag</a>:
--   
--   <pre>
--   let telemetryForSource :: forall (b :: BackendType). HasTag b =&gt; SourceInfo b -&gt; TelemetryPayload
--       telemetryForSource =
--         let dbKind = reify (backendTag @b)
--   </pre>
--   
--   Note that we needed to add the <a>HasTag</a> constraint, which now
--   means we can't use <a>runBackend</a> because our function has the
--   wrong type (it has an extra constraint). Instead, we can use
--   <a>dispatchAnyBackend</a> which allows us to have one constraint:
--   
--   <pre>
--   telemetries =
--     fmap
--       (\sourceinfo -&gt; (Any.dispatchAnyBackend @HasTag) sourceinfo telemetryForSource)
--       (scSources schemaCache)
--   </pre>
--   
--   Note that we had to add the constraint name as a type application, and
--   we had to explicitly add a lambda instead of using <a>flip</a>.
module Hasura.SQL.AnyBackend

-- | Allows storing types of kind <tt>BackendType -&gt; Type</tt>
--   heterogenously.
--   
--   Adding a new constructor to <a>BackendType</a> will automatically
--   create a new constructor here.
--   
--   Given some type defined as <tt>data T (b :: BackendType) = ...</tt>,
--   we can define <tt>AnyBackend T</tt> without mentioning any
--   <a>BackendType</a>.
--   
--   This is useful for having generic containers of potentially different
--   types of T. For instance, <tt>SourceCache</tt> is defined as a
--   <tt>HashMap SourceName (AnyBackend SourceInfo)</tt>.
data AnyBackend (i :: BackendType -> Type)

-- | Generates a constraint for a generic type over all backends.
type SatisfiesForAllBackends (i :: BackendType -> Type) (c :: Type -> Constraint) = (c (i ('Postgres 'Vanilla)), c (i ('Postgres 'Citus)), c (i ('Postgres 'Cockroach)), c (i 'MSSQL), c (i 'BigQuery), c (i 'DataConnector))

-- | How to obtain a tag from a runtime value.
liftTag :: BackendType -> AnyBackend BackendTag

-- | Obtain a <tt>BackendType</tt> from a runtime value.
lowerTag :: AnyBackend i -> BackendType

-- | Transforms an <tt>AnyBackend i</tt> into an <tt>AnyBackend j</tt>.
mapBackend :: forall (i :: BackendType -> Type) (j :: BackendType -> Type). AnyBackend i -> (forall b. i b -> j b) -> AnyBackend j

-- | Traverse an <tt>AnyBackend i</tt> into an <tt>f (AnyBackend j)</tt>.
traverseBackend :: forall (c :: BackendType -> Constraint) (i :: BackendType -> Type) (j :: BackendType -> Type) f. (AllBackendsSatisfy c, Functor f) => AnyBackend i -> (forall b. c b => i b -> f (j b)) -> f (AnyBackend j)

-- | Creates a new <tt>AnyBackend i</tt> for a given backend <tt>b</tt> by
--   wrapping the given <tt>i b</tt>.
mkAnyBackend :: forall (b :: BackendType) (i :: BackendType -> Type). HasTag b => i b -> AnyBackend i

-- | Dispatch a function to the value inside the <tt>AnyBackend</tt>, that
--   does not require bringing into scope a new class constraint.
runBackend :: forall (i :: BackendType -> Type) (r :: Type). AnyBackend i -> (forall (b :: BackendType). i b -> r) -> r

-- | Dispatch an existential using an universally quantified function while
--   also resolving a different constraint. Use this to dispatch Backend*
--   instances. This is essentially a wrapper around <tt>runAnyBackend f .
--   repackAnyBackend @c</tt>.
dispatchAnyBackend :: forall (c :: BackendType -> Constraint) (i :: BackendType -> Type) (r :: Type). AllBackendsSatisfy c => AnyBackend i -> (forall (b :: BackendType). c b => i b -> r) -> r
dispatchAnyBackendWithTwoConstraints :: forall (c1 :: BackendType -> Constraint) (c2 :: BackendType -> Constraint) (i :: BackendType -> Type) (r :: Type). AllBackendsSatisfy c1 => AllBackendsSatisfy c2 => AnyBackend i -> (forall (b :: BackendType). c1 b => c2 b => i b -> r) -> r

-- | Unlike <a>dispatchAnyBackend</a>, the expected constraint has a
--   different kind. Use for classes like <a>Show</a>, <a>ToJSON</a>, etc.
dispatchAnyBackend' :: forall (c :: Type -> Constraint) (i :: BackendType -> Type) (r :: Type). i `SatisfiesForAllBackends` c => AnyBackend i -> (forall (b :: BackendType). c (i b) => i b -> r) -> r

-- | This allows you to apply a constraint to the Backend instances (c2) as
--   well as a constraint on the higher-kinded <tt>i b</tt> type (c1)
dispatchAnyBackend'' :: forall (c1 :: Type -> Constraint) (c2 :: BackendType -> Constraint) (i :: BackendType -> Type) (r :: Type). i `SatisfiesForAllBackends` c1 => AllBackendsSatisfy c2 => AnyBackend i -> (forall (b :: BackendType). c2 b => c1 (i b) => i b -> r) -> r

-- | Sometimes we need to run operations on two backends of the same type.
--   If the backends don't contain the same type, the given <tt>r</tt>
--   value is returned. Otherwise, the function is called with the two
--   wrapped values.
composeAnyBackend :: forall (c :: BackendType -> Constraint) (i :: BackendType -> Type) (r :: Type). AllBackendsSatisfy c => (forall (b :: BackendType). c b => i b -> i b -> r) -> AnyBackend i -> AnyBackend i -> r -> r

-- | Merge two matching backends, falling back on a default.
mergeAnyBackend :: forall (c :: Type -> Constraint) (i :: BackendType -> Type). i `SatisfiesForAllBackends` c => (forall (b :: BackendType). c (i b) => i b -> i b -> i b) -> AnyBackend i -> AnyBackend i -> AnyBackend i -> AnyBackend i

-- | Try to unpack the type of an existential. Returns <tt>Just x</tt> upon
--   a succesful match, <tt>Nothing</tt> otherwise.
unpackAnyBackend :: forall (b :: BackendType) (i :: BackendType -> Type). HasTag b => AnyBackend i -> Maybe (i b)

-- | Dispatch variant for use with arrow syntax.
--   
--   NOTE: The below function accepts two constraints, if the arrow you
--   want to dispatch only has one constraint then repeat the constraint
--   twice. For example:
--   
--   <pre>
--   AB.dispatchAnyBackendArrow @BackendMetadata @BackendMetadata (proc (sourceMetadata, invalidationKeys)
--   </pre>
dispatchAnyBackendArrow :: forall (c1 :: BackendType -> Constraint) (c2 :: BackendType -> Constraint) (i :: BackendType -> Type) (r :: Type) (arr :: Type -> Type -> Type) x. (ArrowChoice arr, AllBackendsSatisfy c1, AllBackendsSatisfy c2) => (forall b. c1 b => c2 b => arr (i b, x) r) -> arr (AnyBackend i, x) r

-- | Attempts to parse an <a>AnyBackend</a> from a JSON value, using the
--   provided backend information.
parseAnyBackendFromJSON :: i `SatisfiesForAllBackends` FromJSON => BackendType -> Value -> Parser (AnyBackend i)

-- | Codec that can be used to decode and encode <tt>AnyBackend i</tt>
--   values. Throws an error when attempting to encode a value with a
--   mismatched <tt>backendKind</tt> argument.
anyBackendCodec :: forall i. i `SatisfiesForAllBackends` HasCodec => BackendType -> JSONCodec (AnyBackend i)

-- | Outputs a debug JSON value from an <a>AnyBackend</a>. This function
--   must only be used for debug purposes, as it has no way of inserting
--   the backend kind in the output, since there's no guarantee that the
--   output will be an object.
debugAnyBackendToJSON :: i `SatisfiesForAllBackends` ToJSON => AnyBackend i -> Value
backendSourceKindFromText :: Text -> Maybe (AnyBackend BackendSourceKind)
parseBackendSourceKindFromJSON :: Value -> Parser (AnyBackend BackendSourceKind)
instance GHC.Generics.Generic (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Show.Show => GHC.Show.Show (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Classes.Eq => GHC.Classes.Eq (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Classes.Ord => GHC.Classes.Ord (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Hashable.Class.Hashable => Data.Hashable.Class.Hashable (Hasura.SQL.AnyBackend.AnyBackend i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Aeson.Types.FromJSON.FromJSON => Data.Aeson.Extended.FromJSONKeyValue (Hasura.SQL.AnyBackend.AnyBackend i)

module Hasura.SQL.BackendMap

-- | A BackendMap is a data structure that can contain at most one value of
--   an <tt>i</tt> per <a>BackendType</a> The <tt>i</tt> type must be one
--   that is parameterized by a BackendType-kinded type parameter
data BackendMap (i :: BackendType -> Type)
lookupD :: forall (b :: BackendType) (i :: BackendType -> Type). HasTag b => Dependency (BackendMap i) -> Dependency (Maybe (i b))
singleton :: forall b i. HasTag b => i b -> BackendMap i

-- | Get a value from the map for the particular <a>BackendType</a>
--   <tt>b</tt>. This function is usually used with a type application.
--   <tt> lookup </tt>('Postgres 'Vanilla) backendMap @
lookup :: forall (b :: BackendType) i. HasTag b => BackendMap i -> Maybe (i b)

-- | Get all values in the map
elems :: forall i. BackendMap i -> [AnyBackend i]

-- | The expression <tt>modify f bmap</tt> alters the value <tt>x</tt> at
--   <tt>b</tt>. <tt>modify</tt> is a restricted version of <a>alter</a>
--   which cannot delete entries and if there is no <tt>b</tt> key present
--   in the map, it will apply the modification function to the <tt>i
--   b</tt> unit value and insert the result at <tt>b</tt>.
modify :: forall b i. (HasTag b, Monoid (i b)) => (i b -> i b) -> BackendMap i -> BackendMap i

-- | The expression <tt>alter f bmap</tt> alters the value <tt>x</tt> at
--   <tt>b</tt>, or absence thereof. alter can be used to insert, delete,
--   or update a value in a Map.
--   
--   In short : <tt>lookup k (alter f k m) = f (lookup k m)</tt>.
alter :: forall b i. HasTag b => (Maybe (i b) -> Maybe (i b)) -> BackendMap i -> BackendMap i

-- | The expression <tt>a `overridesDeeply b</tt> applies the values from
--   <tt>a</tt> on top of the defaults <tt>b</tt>. In practice this should
--   union the maps for each backend type.
overridesDeeply :: i `SatisfiesForAllBackends` Semigroup => BackendMap i -> BackendMap i -> BackendMap i
instance GHC.Base.Monoid (Hasura.SQL.BackendMap.BackendMap i)
instance GHC.Base.Semigroup (Hasura.SQL.BackendMap.BackendMap i)
instance GHC.Generics.Generic (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Show.Show => GHC.Show.Show (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i GHC.Classes.Eq => GHC.Classes.Eq (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.Incremental.Select.Select (Hasura.SQL.BackendMap.BackendMap i)
instance Data.GADT.Compare.GEq (Hasura.SQL.BackendMap.BackendMapS i)
instance Data.GADT.Compare.GCompare (Hasura.SQL.BackendMap.BackendMapS i)
instance (Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Autodocodec.Class.HasCodec, Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Typeable.Internal.Typeable) => Autodocodec.Class.HasCodec (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Aeson.Types.FromJSON.FromJSON => Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.BackendMap.BackendMap i)
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends i Data.Aeson.Types.ToJSON.ToJSON => Data.Aeson.Types.ToJSON.ToJSON (Hasura.SQL.BackendMap.BackendMap i)

module Hasura.SQL.GeoJSON
data Position
Position :: !Double -> !Double -> !Maybe Double -> Position
newtype Point
Point :: Position -> Point
[unPoint] :: Point -> Position
newtype MultiPoint
MultiPoint :: [Position] -> MultiPoint
[unMultiPoint] :: MultiPoint -> [Position]
data LineString
LineString :: !Position -> !Position -> ![Position] -> LineString
[_lsFirst] :: LineString -> !Position
[_lsSecond] :: LineString -> !Position
[_lsRest] :: LineString -> ![Position]
newtype MultiLineString
MultiLineString :: [LineString] -> MultiLineString
[unMultiLineString] :: MultiLineString -> [LineString]
data LinearRing
LinearRing :: !Position -> !Position -> !Position -> ![Position] -> LinearRing
[_pFirst] :: LinearRing -> !Position
[_pSecond] :: LinearRing -> !Position
[_pThird] :: LinearRing -> !Position
[_pRest] :: LinearRing -> ![Position]
newtype Polygon
Polygon :: [LinearRing] -> Polygon
[unPolygon] :: Polygon -> [LinearRing]
newtype MultiPolygon
MultiPolygon :: [Polygon] -> MultiPolygon
[unMultiPolygon] :: MultiPolygon -> [Polygon]
data GeometryWithCRS
GeometryWithCRS :: !Geometry -> !Maybe CRS -> GeometryWithCRS
[_gwcGeom] :: GeometryWithCRS -> !Geometry
[_gwcCrs] :: GeometryWithCRS -> !Maybe CRS
newtype GeometryCollection
GeometryCollection :: [GeometryWithCRS] -> GeometryCollection
[unGeometryCollection] :: GeometryCollection -> [GeometryWithCRS]
data Geometry
GPoint :: !Point -> Geometry
GMultiPoint :: !MultiPoint -> Geometry
GLineString :: !LineString -> Geometry
GMultiLineString :: !MultiLineString -> Geometry
GPolygon :: !Polygon -> Geometry
GMultiPolygon :: !MultiPolygon -> Geometry
GGeometryCollection :: !GeometryCollection -> Geometry
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Position
instance GHC.Show.Show Hasura.SQL.GeoJSON.Position
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.Point
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.Point
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Point
instance GHC.Show.Show Hasura.SQL.GeoJSON.Point
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.MultiPoint
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.MultiPoint
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.MultiPoint
instance GHC.Show.Show Hasura.SQL.GeoJSON.MultiPoint
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.LineString
instance GHC.Show.Show Hasura.SQL.GeoJSON.LineString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.MultiLineString
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.MultiLineString
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.MultiLineString
instance GHC.Show.Show Hasura.SQL.GeoJSON.MultiLineString
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.LinearRing
instance GHC.Show.Show Hasura.SQL.GeoJSON.LinearRing
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.Polygon
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.Polygon
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Polygon
instance GHC.Show.Show Hasura.SQL.GeoJSON.Polygon
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.MultiPolygon
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.MultiPolygon
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.MultiPolygon
instance GHC.Show.Show Hasura.SQL.GeoJSON.MultiPolygon
instance GHC.Generics.Generic Hasura.SQL.GeoJSON.CRSNameProps
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.CRSNameProps
instance GHC.Show.Show Hasura.SQL.GeoJSON.CRSNameProps
instance GHC.Generics.Generic Hasura.SQL.GeoJSON.CRSLinkProps
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.CRSLinkProps
instance GHC.Show.Show Hasura.SQL.GeoJSON.CRSLinkProps
instance GHC.Generics.Generic Hasura.SQL.GeoJSON.CRS
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.CRS
instance GHC.Show.Show Hasura.SQL.GeoJSON.CRS
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.GeometryWithCRS
instance GHC.Show.Show Hasura.SQL.GeoJSON.GeometryWithCRS
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.GeometryCollection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.GeometryCollection
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.GeometryCollection
instance GHC.Show.Show Hasura.SQL.GeoJSON.GeometryCollection
instance GHC.Classes.Eq Hasura.SQL.GeoJSON.Geometry
instance GHC.Show.Show Hasura.SQL.GeoJSON.Geometry
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.GeometryWithCRS
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.GeometryWithCRS
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.CRS
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.CRS
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.CRSLinkProps
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.CRSLinkProps
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.CRSNameProps
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.CRSNameProps
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.LinearRing
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.LinearRing
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.LineString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.LineString
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.GeoJSON.Position
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.GeoJSON.Position

module Hasura.SQL.Time
data ZonedTimeOfDay
ZonedTimeOfDay :: TimeOfDay -> TimeZone -> ZonedTimeOfDay
[ztodTime] :: ZonedTimeOfDay -> TimeOfDay
[ztodZone] :: ZonedTimeOfDay -> TimeZone
instance GHC.Classes.Eq Hasura.SQL.Time.ZonedTimeOfDay
instance GHC.Show.Show Hasura.SQL.Time.ZonedTimeOfDay
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.Time.ZonedTimeOfDay

module Hasura.SQL.Types
class ToSQL a
toSQL :: ToSQL a => a -> Builder
toSQLTxt :: ToSQL a => a -> Text

-- | The type of all Postgres types (i.e. scalars and arrays). This type is
--   parameterized so that we can have both <tt><a>CollectableType</a>
--   <tt>PGScalarType</tt></tt> and <tt><a>CollectableType</a>
--   <a>PGColumnType</a></tt>, for when we care about the distinction made
--   by <a>PGColumnType</a>. If we ever change <a>PGColumnType</a> to
--   handle arrays, not just scalars, then the parameterization can go
--   away.
--   
--   TODO (from master): This is incorrect modeling, as
--   <tt>PGScalarType</tt> will capture anything (under
--   <tt>PGUnknown</tt>). This should be fixed when support for all types
--   is merged.
data CollectableType a
CollectableTypeScalar :: !a -> CollectableType a
CollectableTypeArray :: !a -> CollectableType a

-- | The name of the schema in which the graphql-engine will install
--   database extensions.
newtype ExtensionsSchema
ExtensionsSchema :: Text -> ExtensionsSchema
[_unExtensionsSchema] :: ExtensionsSchema -> Text
instance GHC.Base.Functor Hasura.SQL.Types.CollectableType
instance Data.Data.Data a => Data.Data.Data (Hasura.SQL.Types.CollectableType a)
instance GHC.Generics.Generic (Hasura.SQL.Types.CollectableType a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.SQL.Types.CollectableType a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.SQL.Types.CollectableType a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.Types.ExtensionsSchema
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.Types.ExtensionsSchema
instance Control.DeepSeq.NFData Hasura.SQL.Types.ExtensionsSchema
instance Data.Hashable.Class.Hashable Hasura.SQL.Types.ExtensionsSchema
instance GHC.Classes.Eq Hasura.SQL.Types.ExtensionsSchema
instance GHC.Show.Show Hasura.SQL.Types.ExtensionsSchema
instance Autodocodec.Class.HasCodec Hasura.SQL.Types.ExtensionsSchema
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.SQL.Types.CollectableType a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.SQL.Types.CollectableType a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.SQL.Types.CollectableType a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.SQL.Types.CollectableType a)
instance Hasura.SQL.Types.ToSQL a => Hasura.SQL.Types.ToSQL (Hasura.SQL.Types.CollectableType a)
instance Hasura.SQL.Types.ToSQL Text.Builder.Builder
instance Hasura.SQL.Types.ToSQL a => Hasura.SQL.Types.ToSQL (GHC.Maybe.Maybe a)

module Hasura.SQL.Value
data TxtEncodedVal
TENull :: TxtEncodedVal
TELit :: !Text -> TxtEncodedVal
instance GHC.Generics.Generic Hasura.SQL.Value.TxtEncodedVal
instance GHC.Classes.Eq Hasura.SQL.Value.TxtEncodedVal
instance GHC.Show.Show Hasura.SQL.Value.TxtEncodedVal
instance Data.Hashable.Class.Hashable Hasura.SQL.Value.TxtEncodedVal
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.SQL.Value.TxtEncodedVal
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.SQL.Value.TxtEncodedVal

module Hasura.SQL.WKT
newtype WKT
WKT :: Text -> WKT
[getWKT] :: WKT -> Text
class ToWKT a
toWKT :: ToWKT a => a -> Either QErr WKT
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.Point
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.MultiPoint
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.LineString
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.MultiLineString
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.Polygon
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.MultiPolygon
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.GeometryCollection
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.Geometry
instance Hasura.SQL.WKT.ToWKT Hasura.SQL.GeoJSON.GeometryWithCRS


-- | API related to Postgres' pg dump
module Hasura.Server.API.PGDump
data PGDumpReqBody
PGDumpReqBody :: !SourceName -> ![String] -> !Bool -> PGDumpReqBody
[prbSource] :: PGDumpReqBody -> !SourceName
[prbOpts] :: PGDumpReqBody -> ![String]
[prbCleanOutput] :: PGDumpReqBody -> !Bool
execPGDump :: (MonadError QErr m, MonadIO m) => PGDumpReqBody -> ConnInfo -> m ByteString
instance GHC.Classes.Eq Hasura.Server.API.PGDump.PGDumpReqBody
instance GHC.Show.Show Hasura.Server.API.PGDump.PGDumpReqBody
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.PGDump.PGDumpReqBody

module Hasura.Server.Init.Arg.PrettyPrinter
mkEnvVarDoc :: [(String, String)] -> Doc
mkExamplesDoc :: [[String]] -> Doc


-- | Feature Flags are <i>temporary</i> toggles.
module Hasura.Server.Init.FeatureFlag
newtype FeatureFlag
FeatureFlag :: Text -> FeatureFlag
[ffIdentifier] :: FeatureFlag -> Text

-- | In OSS we _may_ look for a environment variable or fall back to the
--   default value.
ceCheckFeatureFlag :: Environment -> CheckFeatureFlag
data CheckFeatureFlag
CheckFeatureFlag :: (FeatureFlag -> IO Bool) -> [(FeatureFlag, Text)] -> CheckFeatureFlag

-- | Action that samples the value of a feature flag. Different products
--   will want to do different things. For example, the Cloud product will
--   want to use LaunchDarkly whereas the OSS and non-cloud EE products
--   will want to sample environment variables.
[runCheckFeatureFlag] :: CheckFeatureFlag -> FeatureFlag -> IO Bool

-- | A registry of flags that are <tt>known</tt> by the system. This is
--   only used to inform of feature flag values via the
--   '<i>v1alpha</i>config' endpoint. Ideally, the console should have a
--   dedicated endpoint to sample feature flags so we don't _have_ to
--   centralise that knowledge here.
[listKnownFeatureFlags] :: CheckFeatureFlag -> [(FeatureFlag, Text)]
class (Monad m) => HasFeatureFlagChecker m
checkFlag :: HasFeatureFlagChecker m => FeatureFlag -> m Bool
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.FeatureFlag.FeatureFlag
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.FeatureFlag.FeatureFlag
instance Data.Hashable.Class.Hashable Hasura.Server.Init.FeatureFlag.FeatureFlag
instance GHC.Generics.Generic Hasura.Server.Init.FeatureFlag.FeatureFlag
instance GHC.Classes.Eq Hasura.Server.Init.FeatureFlag.FeatureFlag
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Control.Monad.Trans.State.Strict.StateT s m)

module Hasura.Server.Metrics

-- | A specification of the metrics tracked by the server.
--   
--   The use of the "unit" type () for the "tag structure" type parameter
--   of a metric indicates that we prohibit that metric from being
--   annotated with tags.
data ServerMetricsSpec :: Symbol -> MetricType -> Type -> Type

-- | Current Number of active Warp threads
[WarpThreads] :: ServerMetricsSpec "warp_threads" 'GaugeType ()

-- | Current number of active websocket connections
[WebsocketConnections] :: ServerMetricsSpec "websocket_connections" 'GaugeType ()

-- | Current number of active subscriptions
[ActiveSubscriptions] :: ServerMetricsSpec "active_subscriptions" 'GaugeType ()

-- | Total Number of events fetched from last 'Event Trigger Fetch'
[NumEventsFetchedPerBatch] :: ServerMetricsSpec "events_fetched_per_batch" 'DistributionType ()

-- | Current number of Event trigger's HTTP workers in process
[NumEventHTTPWorkers] :: ServerMetricsSpec "num_event_trigger_http_workers" 'GaugeType ()

-- | Time (in seconds) between the 'Event Trigger Fetch' from DB and the
--   processing of the event
[EventQueueTime] :: ServerMetricsSpec "event_queue_time" 'DistributionType ()

-- | The current schema cache metadata resource version
[SchemaCacheMetadataResourceVersion] :: ServerMetricsSpec "schema_cache_metadata_resource_version" 'GaugeType ()

-- | Current number of subscribers connected to live queries
[ActiveLiveQueries] :: ServerMetricsSpec "active_livequeries" 'GaugeType ()

-- | Current number of subscribers connected to streaming subscriptions
[ActiveStreaming] :: ServerMetricsSpec "active_streaming_subscriptions" 'GaugeType ()

-- | Latency of fetching a batch of events
[EventFetchTimePerBatch] :: ServerMetricsSpec "events_fetch_time_per_batch" 'DistributionType ()

-- | The time (in seconds) between when a event is picked for delivery to
--   the time its status is updated in the DB
[EventWebhookProcessingTime] :: ServerMetricsSpec "event_webhook_processing_time" 'DistributionType ()

-- | The time taken for an event to be delivered since it's been created
--   (if first attempt) or retried (after first attempt)
[EventProcessingTime] :: ServerMetricsSpec "event_processing_time" 'DistributionType ()

-- | Mutable references for the server metrics. See
--   <a>ServerMetricsSpec</a> for a description of each metric.
data ServerMetrics
ServerMetrics :: Gauge -> Gauge -> Gauge -> Distribution -> Gauge -> Distribution -> Gauge -> Gauge -> Gauge -> Distribution -> Distribution -> Distribution -> ServerMetrics
[smWarpThreads] :: ServerMetrics -> Gauge
[smWebsocketConnections] :: ServerMetrics -> Gauge
[smActiveSubscriptions] :: ServerMetrics -> Gauge
[smNumEventsFetchedPerBatch] :: ServerMetrics -> Distribution
[smNumEventHTTPWorkers] :: ServerMetrics -> Gauge
[smEventQueueTime] :: ServerMetrics -> Distribution
[smSchemaCacheMetadataResourceVersion] :: ServerMetrics -> Gauge
[smActiveLiveQueries] :: ServerMetrics -> Gauge
[smActiveStreamingSubscriptions] :: ServerMetrics -> Gauge
[smEventFetchTimePerBatch] :: ServerMetrics -> Distribution
[smEventWebhookProcessingTime] :: ServerMetrics -> Distribution
[smEventProcessingTime] :: ServerMetrics -> Distribution
createServerMetrics :: Store ServerMetricsSpec -> IO ServerMetrics

module Hasura.Server.Name
_Bool :: Name
_Double :: Name
_float8 :: Name
_Number :: Name
_numeric :: Name

module Hasura.Server.ResourceChecker

-- | The response data of cpu and memory resources
data ComputeResourcesResponse
ComputeResourcesResponse :: Maybe Int -> Maybe Int64 -> Maybe ResourceCheckerError -> ComputeResourcesResponse
[_rcrCpu] :: ComputeResourcesResponse -> Maybe Int
[_rcrMemory] :: ComputeResourcesResponse -> Maybe Int64
[_rcrErrorCode] :: ComputeResourcesResponse -> Maybe ResourceCheckerError
data ResourceCheckerError
CGroupUnavailable :: ResourceCheckerError
CpuInconclusive :: ResourceCheckerError
MemoryInconclusive :: ResourceCheckerError
CpuMemoryInconclusive :: ResourceCheckerError
RCInternalError :: String -> ResourceCheckerError

-- | Determine allocated cpu and memory resources of the host server or
--   Container Runtime. because HGE mainly runs in the container runtime we
--   need to determine the max cpu and memory limit constraints that are
--   managed by cgroups or fallback to physical cpu and memory information
--   of the server <a>https://hasurahq.atlassian.net/browse/INFRA-772</a>
--   
--   Those information are stored in many files of cgroup folders, the
--   logic is simply to read them and parse number values
--   
--   In cgroup v1 systems there are several ways in which the amount of
--   allocated cpu resources could be presented. We first try reading
--   requests (quota &amp; period); if that fails, we fallback to reading
--   limits (shares); if that fails, we fallback to reading the physical
--   cpu count, which should always succeed.
getServerResources :: MonadIO m => m ComputeResourcesResponse
getServerResources_ :: MonadIO m => FilePath -> m ComputeResourcesResponse

-- | Compute the cpu share allocations from the number of physical CPU
--   cores
getPhysicalCpuResource :: MonadIO m => m Int

-- | Compute the max physical memory size of the server
getMaxPhysicalMemory :: MonadIO m => m (Maybe Int64)
getPhysicalResources :: MonadIO m => Maybe ResourceCheckerError -> m ComputeResourcesResponse

-- | Determine cpu and memory resource allocations if the OCI Container
--   Runtime supports cgroup v1
getCGroupV1Resources :: MonadIO m => FilePath -> m ComputeResourcesResponse

-- | Determine cpu and memory resource allocations if the OCI Container
--   Runtime supports cgroup v2
getCGroupV2Resources :: MonadIO m => FilePath -> m ComputeResourcesResponse
instance GHC.Show.Show Hasura.Server.ResourceChecker.CGroupMode
instance GHC.Classes.Eq Hasura.Server.ResourceChecker.CGroupMode
instance GHC.Classes.Eq Hasura.Server.ResourceChecker.ResourceCheckerError
instance GHC.Show.Show Hasura.Server.ResourceChecker.ComputeResourcesResponse
instance GHC.Classes.Eq Hasura.Server.ResourceChecker.ComputeResourcesResponse
instance GHC.Generics.Generic Hasura.Server.ResourceChecker.ComputeResourcesResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.ResourceChecker.ComputeResourcesResponse
instance GHC.Show.Show Hasura.Server.ResourceChecker.ResourceCheckerError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.ResourceChecker.ResourceCheckerError


-- | Counters used in telemetry collection. Additional counters can be
--   added here.and serviced in <a>Hasura.Server.Telemetry</a>.
module Hasura.Server.Telemetry.Counters

-- | The properties that characterize this request. The dimensions over
--   which we collect metrics for each serviced request.
data RequestDimensions
RequestDimensions :: !QueryType -> !Locality -> !Transport -> RequestDimensions
[$sel:telemQueryType:RequestDimensions] :: RequestDimensions -> !QueryType
[$sel:telemLocality:RequestDimensions] :: RequestDimensions -> !Locality
[$sel:telemTransport:RequestDimensions] :: RequestDimensions -> !Transport

-- | Accumulated time metrics.
data RequestTimings
RequestTimings :: !Seconds -> !Seconds -> RequestTimings

-- | Time spent waiting on PG/remote http calls
[$sel:telemTimeIO:RequestTimings] :: RequestTimings -> !Seconds

-- | Total service time for request (including <a>RequestTimings</a>)
[$sel:telemTimeTot:RequestTimings] :: RequestTimings -> !Seconds

-- | <a>RequestTimings</a> along with the count
data RequestTimingsCount
RequestTimingsCount :: !Seconds -> !Seconds -> !Word -> RequestTimingsCount
[$sel:telemTimeIO:RequestTimingsCount] :: RequestTimingsCount -> !Seconds
[$sel:telemTimeTot:RequestTimingsCount] :: RequestTimingsCount -> !Seconds

-- | The number of requests that have contributed to the accumulated
--   timings above. So e.g. <tt>telemTimeTot / count</tt> would give the
--   mean service time.
[$sel:telemCount:RequestTimingsCount] :: RequestTimingsCount -> !Word

-- | Was this request a mutation (involved DB writes)?
data QueryType
Mutation :: QueryType
Query :: QueryType

-- | Was this a PG local query, or did it involve remote execution?
data Locality

-- | No data was fetched
Empty :: Locality

-- | local DB data
Local :: Locality

-- | remote schema
Remote :: Locality

-- | mixed
Heterogeneous :: Locality

-- | Was this a query over http or websockets?
data Transport
HTTP :: Transport
WebSocket :: Transport

-- | The timings and counts here were from requests with total time longer
--   than <a>$sel:bucketGreaterThan:RunningTimeBucket</a> (but less than
--   any larger bucket cutoff times).
newtype RunningTimeBucket
RunningTimeBucket :: Seconds -> RunningTimeBucket
[$sel:bucketGreaterThan:RunningTimeBucket] :: RunningTimeBucket -> Seconds

-- | Save a timing metric sample in our in-memory store. These will be
--   accumulated and uploaded periodically in
--   <a>Hasura.Server.Telemetry</a>.
recordTimingMetric :: MonadIO m => RequestDimensions -> RequestTimings -> m ()

-- | The final shape of this part of our metrics data JSON. This should
--   allow reasonably efficient querying using GIN indexes and JSONB
--   containment operations (which treat arrays as sets).
data ServiceTimingMetrics
ServiceTimingMetrics :: Int -> [ServiceTimingMetric] -> ServiceTimingMetrics

-- | This is set to a new unique value when the counters reset (e.g.
--   because of a restart)
[$sel:collectionTag:ServiceTimingMetrics] :: ServiceTimingMetrics -> Int
[$sel:serviceTimingMetrics:ServiceTimingMetrics] :: ServiceTimingMetrics -> [ServiceTimingMetric]
data ServiceTimingMetric
ServiceTimingMetric :: RequestDimensions -> RunningTimeBucket -> RequestTimingsCount -> ServiceTimingMetric
[$sel:dimensions:ServiceTimingMetric] :: ServiceTimingMetric -> RequestDimensions
[$sel:bucket:ServiceTimingMetric] :: ServiceTimingMetric -> RunningTimeBucket
[$sel:metrics:ServiceTimingMetric] :: ServiceTimingMetric -> RequestTimingsCount
dumpServiceTimingMetrics :: MonadIO m => m ServiceTimingMetrics
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Enum.Enum Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.Locality
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.Locality
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.Locality
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.Locality
instance GHC.Enum.Enum Hasura.Server.Telemetry.Counters.Locality
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.Transport
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.Transport
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.Transport
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.Transport
instance GHC.Enum.Enum Hasura.Server.Telemetry.Counters.Transport
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.RequestDimensions
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.RequestDimensions
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.RequestDimensions
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.RequestDimensions
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.RunningTimeBucket
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance GHC.Classes.Ord Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance GHC.Generics.Generic Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance GHC.Show.Show Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.ServiceTimingMetric
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.RequestDimensions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.RequestDimensions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.RequestDimensions
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.Transport
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.Transport
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.Transport
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.Locality
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.Locality
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.Locality
instance GHC.Base.Semigroup Hasura.Server.Telemetry.Counters.Locality
instance GHC.Base.Monoid Hasura.Server.Telemetry.Counters.Locality
instance Data.Hashable.Class.Hashable Hasura.Server.Telemetry.Counters.QueryType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.QueryType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.QueryType
instance GHC.Base.Semigroup Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Counters.RequestTimingsCount
instance GHC.Base.Semigroup Hasura.Server.Telemetry.Counters.RequestTimings

module Hasura.Server.Utils
jsonHeader :: Header
sqlHeader :: Header
gzipHeader :: Header
userRoleHeader :: IsString a => a
deprecatedAccessKeyHeader :: IsString a => a
adminSecretHeader :: IsString a => a
userIdHeader :: IsString a => a
requestIdHeader :: IsString a => a
contentLengthHeader :: IsString a => a
useBackendOnlyPermissionsHeader :: IsString a => a
getRequestHeader :: HeaderName -> [Header] -> Maybe ByteString
parseStringAsBool :: String -> Either String Bool

-- | Quotes a regex using Template Haskell so syntax errors can be reported
--   at compile-time.
quoteRegex :: CompOption -> ExecOption -> String -> Code Q Regex
fmapL :: (a -> a') -> Either a b -> Either a' b
generateFingerprint :: IO Text
httpExceptToJSON :: HttpException -> Value
commonClientHeadersIgnored :: IsString a => [a]
sessionVariablePrefix :: Text
isReqUserId :: Text -> Bool
mkClientHeadersForward :: [Header] -> [Header]
mkSetCookieHeaders :: Response a -> ResponseHeaders
filterHeaders :: HashSet HeaderName -> [Header] -> [Header]

-- | The version integer
data APIVersion
VIVersion1 :: APIVersion
VIVersion2 :: APIVersion
englishList :: Text -> NonEmpty Text -> Text
makeReasonMessage :: [a] -> (a -> Text) -> Text
executeJSONPath :: JSONPath -> Value -> IResult Value
cryptoHash :: ToJSON a => a -> ByteString
readIsoLevel :: String -> Either String TxIsolation
parseConnLifeTime :: Maybe NominalDiffTime -> Maybe NominalDiffTime

-- | The environment variables that were moved to metadata. These
--   environment variables are available if a v1 hasura project is run an
--   v2 hasura server. These environment variables are marked as deprecated
--   only when the v1 hasura project is migrated to v2 project.
newtype EnvVarsMovedToMetadata
EnvVarsMovedToMetadata :: [String] -> EnvVarsMovedToMetadata
[unEnvVarsMovedToMetadata] :: EnvVarsMovedToMetadata -> [String]

-- | These env vars are completely deprecated
newtype DeprecatedEnvVars
DeprecatedEnvVars :: [String] -> DeprecatedEnvVars
[unDeprecatedEnvVars] :: DeprecatedEnvVars -> [String]
envVarsMovedToMetadata :: EnvVarsMovedToMetadata
deprecatedEnvVars :: DeprecatedEnvVars
redactSensitiveHeader :: Header -> Header
instance GHC.Classes.Eq Hasura.Server.Utils.APIVersion
instance GHC.Show.Show Hasura.Server.Utils.APIVersion
instance GHC.Show.Show Hasura.Server.Utils.EnvVarsMovedToMetadata
instance GHC.Show.Show Hasura.Server.Utils.DeprecatedEnvVars
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Utils.APIVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Utils.APIVersion

module Hasura.Server.Types
newtype RequestId
RequestId :: Text -> RequestId
[unRequestId] :: RequestId -> Text
getRequestId :: MonadIO m => [Header] -> m (RequestId, [Header])

-- | A uuid of a source database.
newtype DbUid
DbUid :: Text -> DbUid
[getDbUid] :: DbUid -> Text
newtype DbVersion
DbVersion :: Text -> DbVersion
newtype PGVersion
PGVersion :: Int -> PGVersion
pgToDbVersion :: PGVersion -> DbVersion

-- | A uuid of the postgres metadata db.
newtype MetadataDbId
MetadataDbId :: Text -> MetadataDbId
[getMetadataDbId] :: MetadataDbId -> Text
mdDbIdToDbUid :: MetadataDbId -> DbUid

-- | A UUID for each running instance of graphql-engine, generated fresh
--   each time graphql-engine starts up
newtype InstanceId
InstanceId :: Text -> InstanceId
[getInstanceId] :: InstanceId -> Text

-- | Generate an <a>InstanceId</a> from a <tt>UUID</tt>
generateInstanceId :: IO InstanceId
data ExperimentalFeature
EFInheritedRoles :: ExperimentalFeature
EFOptimizePermissionFilters :: ExperimentalFeature
EFNamingConventions :: ExperimentalFeature
EFStreamingSubscriptions :: ExperimentalFeature
EFApolloFederation :: ExperimentalFeature
EFHideUpdateManyFields :: ExperimentalFeature
EFBigQueryStringNumericInput :: ExperimentalFeature
EFHideAggregationPredicates :: ExperimentalFeature
EFHideStreamFields :: ExperimentalFeature
EFGroupByAggregations :: ExperimentalFeature
EFDisablePostgresArrays :: ExperimentalFeature
experimentalFeatureKey :: ExperimentalFeature -> Text
data MaintenanceMode a
MaintenanceModeEnabled :: a -> MaintenanceMode a
MaintenanceModeDisabled :: MaintenanceMode a

-- | See Note [ReadOnly Mode]
data ReadOnlyMode
ReadOnlyModeEnabled :: ReadOnlyMode
ReadOnlyModeDisabled :: ReadOnlyMode

-- | EventingMode decides whether the eventing subsystem should be enabled
--   or disabled. <tt>EventDisabled</tt> mode disables Event Triggers,
--   Async Actions, Scheduled Events and source catalaog migrations. This
--   is an internal feature and will not be exposed to users.
data EventingMode
EventingEnabled :: EventingMode
EventingDisabled :: EventingMode

-- | Whether or not to enable apollo federation fields.
data ApolloFederationStatus
ApolloFederationEnabled :: ApolloFederationStatus
ApolloFederationDisabled :: ApolloFederationStatus
isApolloFederationEnabled :: ApolloFederationStatus -> Bool
data TriggersErrorLogLevelStatus
TriggersErrorLogLevelEnabled :: TriggersErrorLogLevelStatus
TriggersErrorLogLevelDisabled :: TriggersErrorLogLevelStatus
isTriggersErrorLogLevelEnabled :: TriggersErrorLogLevelStatus -> Bool

-- | Whether or not to enable granular metrics for Prometheus.
--   
--   <a>GranularMetricsOn</a> will enable the dynamic labels for the
--   metrics. <a>GranularMetricsOff</a> will disable the dynamic labels for
--   the metrics.
--   
--   <ul>
--   <li>*Warning**: Enabling dynamic labels for Prometheus metrics can
--   cause cardinality issues and can cause memory usage to increase.</li>
--   </ul>
data GranularPrometheusMetricsState
GranularMetricsOff :: GranularPrometheusMetricsState
GranularMetricsOn :: GranularPrometheusMetricsState

-- | Whether or not to enable OpenTelemetry Exporter.
--   
--   <a>OpenTelemetryExporterOn</a> will enable exporting of traces &amp;
--   metrics via the OTel Exporter. <a>OpenTelemetryExporterOff</a> will
--   disable exporting of traces &amp; metrics via the OTel Exporter.
data OpenTelemetryExporterState
OpenTelemetryExporterOff :: OpenTelemetryExporterState
OpenTelemetryExporterOn :: OpenTelemetryExporterState

-- | Whether or not to close websocket connections on metadata change.
data CloseWebsocketsOnMetadataChangeStatus
CWMCEnabled :: CloseWebsocketsOnMetadataChangeStatus
CWMCDisabled :: CloseWebsocketsOnMetadataChangeStatus
isCloseWebsocketsOnMetadataChangeStatusEnabled :: CloseWebsocketsOnMetadataChangeStatus -> Bool
class (Monad m) => MonadGetPolicies m
runGetApiTimeLimit :: MonadGetPolicies m => m (Maybe MaxTime)
runGetPrometheusMetricsGranularity :: MonadGetPolicies m => m (IO GranularPrometheusMetricsState)
instance Data.Hashable.Class.Hashable Hasura.Server.Types.RequestId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.RequestId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.RequestId
instance GHC.Classes.Eq Hasura.Server.Types.RequestId
instance GHC.Show.Show Hasura.Server.Types.RequestId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.DbUid
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.DbUid
instance GHC.Classes.Eq Hasura.Server.Types.DbUid
instance GHC.Show.Show Hasura.Server.Types.DbUid
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.DbVersion
instance GHC.Classes.Eq Hasura.Server.Types.DbVersion
instance GHC.Show.Show Hasura.Server.Types.DbVersion
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.PGVersion
instance GHC.Classes.Eq Hasura.Server.Types.PGVersion
instance GHC.Show.Show Hasura.Server.Types.PGVersion
instance Database.PG.Query.Class.ToPrepArg Hasura.Server.Types.MetadataDbId
instance Database.PG.Query.Class.FromCol Hasura.Server.Types.MetadataDbId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.MetadataDbId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.MetadataDbId
instance GHC.Classes.Eq Hasura.Server.Types.MetadataDbId
instance GHC.Show.Show Hasura.Server.Types.MetadataDbId
instance Database.PG.Query.Class.ToPrepArg Hasura.Server.Types.InstanceId
instance Database.PG.Query.Class.FromCol Hasura.Server.Types.InstanceId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.InstanceId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.InstanceId
instance GHC.Classes.Eq Hasura.Server.Types.InstanceId
instance GHC.Show.Show Hasura.Server.Types.InstanceId
instance GHC.Show.Show Hasura.Server.Types.ExperimentalFeature
instance GHC.Generics.Generic Hasura.Server.Types.ExperimentalFeature
instance GHC.Classes.Eq Hasura.Server.Types.ExperimentalFeature
instance GHC.Enum.Enum Hasura.Server.Types.ExperimentalFeature
instance GHC.Enum.Bounded Hasura.Server.Types.ExperimentalFeature
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Server.Types.MaintenanceMode a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Server.Types.MaintenanceMode a)
instance GHC.Classes.Eq Hasura.Server.Types.ReadOnlyMode
instance GHC.Show.Show Hasura.Server.Types.ReadOnlyMode
instance GHC.Classes.Eq Hasura.Server.Types.EventingMode
instance GHC.Show.Show Hasura.Server.Types.EventingMode
instance GHC.Generics.Generic Hasura.Server.Types.ApolloFederationStatus
instance GHC.Classes.Ord Hasura.Server.Types.ApolloFederationStatus
instance GHC.Classes.Eq Hasura.Server.Types.ApolloFederationStatus
instance GHC.Show.Show Hasura.Server.Types.ApolloFederationStatus
instance GHC.Generics.Generic Hasura.Server.Types.TriggersErrorLogLevelStatus
instance GHC.Classes.Ord Hasura.Server.Types.TriggersErrorLogLevelStatus
instance GHC.Classes.Eq Hasura.Server.Types.TriggersErrorLogLevelStatus
instance GHC.Show.Show Hasura.Server.Types.TriggersErrorLogLevelStatus
instance GHC.Show.Show Hasura.Server.Types.GranularPrometheusMetricsState
instance GHC.Classes.Eq Hasura.Server.Types.GranularPrometheusMetricsState
instance GHC.Show.Show Hasura.Server.Types.OpenTelemetryExporterState
instance GHC.Classes.Eq Hasura.Server.Types.OpenTelemetryExporterState
instance GHC.Generics.Generic Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance GHC.Classes.Ord Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance GHC.Classes.Eq Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance GHC.Show.Show Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Control.Monad.Trans.State.Strict.StateT w m)
instance Control.DeepSeq.NFData Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.OpenTelemetryExporterState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.OpenTelemetryExporterState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.GranularPrometheusMetricsState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.GranularPrometheusMetricsState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.TriggersErrorLogLevelStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.TriggersErrorLogLevelStatus
instance Control.DeepSeq.NFData Hasura.Server.Types.ApolloFederationStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Types.ApolloFederationStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.ApolloFederationStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.ApolloFederationStatus
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.Server.Types.MaintenanceMode ())
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Server.Types.MaintenanceMode ())
instance Data.Hashable.Class.Hashable Hasura.Server.Types.ExperimentalFeature
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Types.ExperimentalFeature
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Types.ExperimentalFeature

module Hasura.GraphQL.Schema.NamingCase
isGraphqlCase :: NamingCase -> Bool

-- | Check if naming convention has changed The value of naming convention
--   depends on whether the naming convention is enabled in experimental
--   features and what the default naming convention
--   (<tt>HASURA_GRAPHQL_DEFAULT_NAMING_CONVENTION</tt>) is hence use both
--   these values to decide if naming convention has changed
hasNamingConventionChanged :: (HashSet ExperimentalFeature, NamingCase) -> (HashSet ExperimentalFeature, NamingCase) -> Bool


-- | CORS (Cross Origin Resource Sharing) related configuration
module Hasura.Server.Cors
data Domains
Domains :: !HashSet Text -> !HashSet DomainParts -> Domains
[dmFqdns] :: Domains -> !HashSet Text
[dmWildcards] :: Domains -> !HashSet DomainParts
data CorsConfig
CCAllowAll :: CorsConfig
CCAllowedOrigins :: Domains -> CorsConfig
CCDisabled :: Bool -> CorsConfig
isCorsDisabled :: CorsConfig -> Bool
readCorsDomains :: String -> Either String CorsConfig
data CorsPolicy
CorsPolicy :: !CorsConfig -> ![Text] -> !Int -> CorsPolicy
[cpConfig] :: CorsPolicy -> !CorsConfig
[cpMethods] :: CorsPolicy -> ![Text]
[cpMaxAge] :: CorsPolicy -> !Int
mkDefaultCorsPolicy :: CorsConfig -> CorsPolicy
inWildcardList :: Domains -> Text -> Bool
parseOrigin :: Text -> Either String DomainParts
instance Data.Hashable.Class.Hashable Hasura.Server.Cors.DomainParts
instance GHC.Generics.Generic Hasura.Server.Cors.DomainParts
instance GHC.Classes.Eq Hasura.Server.Cors.DomainParts
instance GHC.Show.Show Hasura.Server.Cors.DomainParts
instance GHC.Generics.Generic Hasura.Server.Cors.Domains
instance GHC.Classes.Eq Hasura.Server.Cors.Domains
instance GHC.Show.Show Hasura.Server.Cors.Domains
instance GHC.Classes.Eq Hasura.Server.Cors.CorsConfig
instance GHC.Show.Show Hasura.Server.Cors.CorsConfig
instance GHC.Classes.Eq Hasura.Server.Cors.CorsPolicy
instance GHC.Show.Show Hasura.Server.Cors.CorsPolicy
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Cors.CorsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Cors.CorsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Cors.Domains
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Cors.Domains
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Cors.DomainParts
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Cors.DomainParts

module Hasura.Server.Middleware
corsMiddleware :: IO CorsPolicy -> Middleware

module Hasura.Server.Compression

-- | Compressed encodings which hasura supports
data CompressionType
CTGZip :: CompressionType

-- | Accept-Encoding directives (from client) which hasura supports.
--   <tt>Nothing</tt> indicates identity (no compression)
type EncodingType = Maybe CompressionType
identityEncoding :: EncodingType
compressionTypeToTxt :: CompressionType -> Text

-- | A map from Accept-Encoding directives to corresponding
--   Content-Encoding headers (from server). NOTE: <tt>identity</tt> is not
--   a valid directive for this header.
contentEncodingHeader :: CompressionType -> Header

-- | Maybe compress the response body, based on the client's
--   Accept-Encoding and our own judgement.
compressResponse :: RequestHeaders -> ByteString -> (ByteString, EncodingType)

-- | Compress the bytestring preferring speed over compression ratio
compressFast :: CompressionType -> ByteString -> ByteString

-- | Which encodings can the client accept? The empty set returned here is
--   an error condition and the server tecnically ought to return a 406.
--   
--   
--   <a>https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Encoding</a>
getAcceptedEncodings :: RequestHeaders -> Set EncodingType
instance GHC.Classes.Ord Hasura.Server.Compression.CompressionType
instance GHC.Classes.Eq Hasura.Server.Compression.CompressionType
instance GHC.Show.Show Hasura.Server.Compression.CompressionType

module Hasura.Server.Auth.JWT.Internal

-- | Helper functions to decode Text to JWK
parseHmacKey :: Text -> Int64 -> Either Text JWK
parseRsaKey :: Text -> Either Text JWK
parseEdDSAKey :: Text -> Either Text JWK
parseEsKey :: Text -> Either Text JWK


-- | This module calculates parameterized query hash, which is a way to
--   hash an incoming query (after resolving variables) with all leaf nodes
--   (i.e. scalar values) discarded. In other words, two queries having the
--   same parameterized query hash are essentially the same query but may
--   differ in leaf values.
--   
--   For example:
--   
--   <ol>
--   <li>query { authors (where: {id: {_eq: 2}}) { id name } }</li>
--   <li>query { authors (where: {id: {_eq: 203943}}) { id name } }</li>
--   <li>query { authors (where: {id: {_eq: $id}}) { id name } }</li>
--   </ol>
--   
--   For any value of <a>id</a>
--   
--   <ol>
--   <li>query { authors (where: $whereBoolExp) { id name } }</li>
--   </ol>
--   
--   only when <tt>whereBoolExp</tt> is of the form of
--   
--   { "id": { "_eq": <a>id</a> } }
--   
--   All the above queries should result in the same parameterized query
--   hash.
--   
--   The following steps are done to calculate the parameterized query
--   hash:
--   
--   <ol>
--   <li>Normalize the GraphQL query by substituting the variables (if any)
--   in appropriate places.</li>
--   <li>Substitute any scalar GraphQL values (Int, Float, Enum, String and
--   Boolean) to null</li>
--   <li>For input objects and list, traverse through them and do step no
--   2.</li>
--   <li>Calculate the hash of the query obtained from step 3.</li>
--   </ol>
--   
--   Note: Parameterized query hash is a PRO only feature
module Hasura.GraphQL.ParameterizedQueryHash

-- | a set of parameterized query hashes attached to a request this type
--   exists because a simple list of <tt>ParameterisedQueryHash</tt>es
--   won't let us log a single-request batch and a single non-batched
--   request differently. the log format uses json lists for requests
--   executed in batched mode, for fields like <tt>query</tt>, but not for
--   requests in single mode (e.g. <tt>query: "..."</tt> vs <tt>query:
--   ["..."]</tt>) and so to conform to that, we capture the whole _set_ of
--   parameterised query hashes when it's created, tagging it with
--   information about how it was created (i.e. from a batched request, a
--   single request, etc.)
data ParameterizedQueryHashList

-- | an empty query hash set, either for an operation that does not produce
--   query hashes, or due to failure in operation execution
PQHSetEmpty :: ParameterizedQueryHashList

-- | a query hash set consisting of a single element, corresponding to e.g.
--   a single (non-batched) graphql request
PQHSetSingleton :: !ParameterizedQueryHash -> ParameterizedQueryHashList

-- | a query hash set associated to a batched request note that this does
--   not need to contain multiple query hashes: it is possible for a batch
--   to contain only one request
PQHSetBatched :: ![ParameterizedQueryHash] -> ParameterizedQueryHashList

-- | we use something that explicitly produces an <a>Object</a> instead of
--   writing a <a>ToJSON</a> instance. in the latter case, functions
--   consuming the output of <a>toJSON</a> would have to perform a partial
--   pattern-match on the <a>Value</a> output to extract a JSON object from
--   it. for the other patterns, it would have to either throw a runtime
--   error on or silently ignore the other patterns, and the latter choice
--   would cause a silent failure if the <a>ToJSON</a> instance were
--   modified to no longer always return objects
parameterizedQueryHashListToObject :: ParameterizedQueryHashList -> Object
data ParameterizedQueryHash
calculateParameterizedQueryHash :: SelectionSet NoFragments Variable -> ParameterizedQueryHash
mkUnsafeParameterizedQueryHash :: Text -> ParameterizedQueryHash
instance GHC.Classes.Ord Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash
instance GHC.Classes.Eq Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash
instance GHC.Show.Show Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash
instance GHC.Classes.Eq Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHashList
instance GHC.Show.Show Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHashList
instance Data.Hashable.Class.Hashable Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.ParameterizedQueryHash.ParameterizedQueryHash


-- | This module implements <i>fragment inlining</i>, which converts all
--   fragment spreads in a GraphQL query to inline fragments. For example,
--   given a query like
--   
--   <pre>
--   query {
--     users {
--       id
--       ...userFields
--     }
--   }
--   
--   fragment userFields on User {
--     name
--     favoriteColor
--   }
--   </pre>
--   
--   the fragment inliner will convert it to this:
--   
--   <pre>
--   query {
--     users {
--       id
--       ... on User {
--         name
--         favoriteColor
--       }
--     }
--   }
--   </pre>
--   
--   This is a straightforward and mechanical transformation, but it
--   simplifies further processing, since we catch unbound fragments and
--   recursive fragment definitions early in the pipeline, so parsing does
--   not have to worry about it. In that sense, fragment inlining is
--   similar to the variable resolution pass performed by
--   <a>Hasura.GraphQL.Execute.Resolve</a>, but for fragment definitions
--   rather than variables.
module Hasura.GraphQL.Execute.Inline
type InlineMT m a = (MonadError QErr m) => (StateT InlineState (ReaderT InlineEnv m)) a
type InlineM a = InlineMT (Except QErr) a
runInlineMT :: forall m a. MonadError QErr m => HashMap Name FragmentDefinition -> InlineMT m a -> m a
runInlineM :: forall a. HashMap Name FragmentDefinition -> InlineM a -> Either QErr a

-- | Inlines all fragment spreads in a <a>SelectionSet</a>; see the module
--   documentation for <a>Hasura.GraphQL.Execute.Inline</a> for details.
inlineSelectionSet :: (MonadError QErr m, Foldable t) => t FragmentDefinition -> SelectionSet FragmentSpread Name -> m (SelectionSet NoFragments Name)
inlineField :: MonadInline m => Field FragmentSpread Name -> m (Field NoFragments Name)

module Hasura.GraphQL.Transport.HTTP.Protocol
newtype GQLExecDoc
GQLExecDoc :: [ExecutableDefinition Name] -> GQLExecDoc
[unGQLExecDoc] :: GQLExecDoc -> [ExecutableDefinition Name]
newtype OperationName
OperationName :: Name -> OperationName
[_unOperationName] :: OperationName -> Name
type VariableValues = HashMap Name Value

-- | <a>https://graphql.org/learn/serving-over-http/#post-request</a>
--   
--   See <a>GQLReqParsed</a> for invariants.
data GQLReq a
GQLReq :: !Maybe OperationName -> !a -> !Maybe VariableValues -> GQLReq a
[_grOperationName] :: GQLReq a -> !Maybe OperationName
[_grQuery] :: GQLReq a -> !a
[_grVariables] :: GQLReq a -> !Maybe VariableValues

-- | Batched queries are sent as a JSON array of <a>GQLReq</a> records.
--   This newtype exists to support the unusual JSON encoding.
--   
--   See <a>https://github.com/hasura/graphql-engine/issues/1812</a>.
data GQLBatchedReqs a
GQLSingleRequest :: a -> GQLBatchedReqs a
GQLBatchedReqs :: [a] -> GQLBatchedReqs a
newtype GQLQueryText
GQLQueryText :: Text -> GQLQueryText
[_unGQLQueryText] :: GQLQueryText -> Text

-- | We've not yet parsed the graphql query string parameter of the POST.
type GQLReqUnparsed = GQLReq GQLQueryText

-- | Invariants:
--   
--   <ul>
--   <li>when <a>_grOperationName</a> is <tt>Nothing</tt>, <a>_grQuery</a>
--   contains exactly one <tt>ExecutableDefinitionOperation</tt> (and zero
--   or more <tt>ExecutableDefinitionFragment</tt>)</li>
--   <li>when <a>_grOperationName</a> is present, there is a corresponding
--   <tt>ExecutableDefinitionOperation</tt> in <a>_grQuery</a></li>
--   </ul>
type GQLReqParsed = GQLReq GQLExecDoc
type ReqsText = GQLBatchedReqs (GQLReq GQLQueryText)

-- | A simplified form of <a>GQLReqParsed</a> which is more ergonomic in
--   particular for APIs that act as graphql <i>clients</i> (e.g. in remote
--   relationship execution). This is a "desugared" request in which
--   fragments have been inlined (see <tt>inlineSelectionSet</tt>), and the
--   operation (<a>_grOperationName</a>) to be executed is the only payload
--   (in contrast to a <a>ExecutableDocument</a> with possibly many named
--   operations).
--   
--   <a>_grOperationName</a> is essentially ignored here, but should
--   correspond with <tt>_todName</tt> if present.
--   
--   These could maybe benefit from an HKD refactoring.
type GQLReqOutgoing = GQLReq SingleOperation

-- | A single graphql operation to be executed, with fragment definitions
--   inlined. This is the simplified form of <a>GQLExecDoc</a> or
--   <a>ExecutableDocument</a>:
type SingleOperation = TypedOperationDefinition NoFragments Name
renderGQLReqOutgoing :: GQLReqOutgoing -> GQLReqUnparsed

-- | Obtain the actual single operation to be executed, from the possibly-
--   multi-operation document, validating per the spec and inlining any
--   fragment definitions (pre-defined parts of a graphql query) at
--   fragment spreads (locations where fragments are "spliced"). See:
--   
--   <a>https://spec.graphql.org/June2018/#sec-Executable-Definitions</a>
--   and... <a>https://graphql.org/learn/serving-over-http/</a>
getSingleOperation :: MonadError QErr m => GQLReqParsed -> m SingleOperation
toParsed :: MonadError QErr m => GQLReqUnparsed -> m GQLReqParsed

-- | Get operation name from parsed executable document if the field
--   <tt>operationName</tt> is not explicitly sent by the client in the
--   body of the request
getOpNameFromParsedReq :: GQLReqParsed -> Maybe OperationName
encodeGQErr :: Bool -> QErr -> Encoding
type GQResult a = Either GQExecError a
newtype GQExecError
GQExecError :: [Encoding] -> GQExecError
type GQResponse = GQResult ByteString
isExecError :: GQResult a -> Bool
encodeGQExecError :: GQExecError -> Encoding
encodeGQResp :: GQResponse -> EncJSON
decodeGQResp :: EncJSON -> (Maybe GQResponse, EncJSON)
encodeHTTPResp :: GQResponse -> EncJSON
instance Language.Haskell.TH.Syntax.Lift Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance GHC.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance GHC.Classes.Ord Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance Language.Haskell.TH.Syntax.Lift Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance GHC.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance GHC.Classes.Ord Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance GHC.Base.Functor Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq
instance GHC.Generics.Generic (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance GHC.Base.Functor Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs
instance GHC.Generics.Generic (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance Data.String.IsString Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance GHC.Classes.Ord Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance GHC.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.GQLQueryText
instance GHC.Classes.Eq Hasura.GraphQL.Transport.HTTP.Protocol.GQExecError
instance GHC.Show.Show Hasura.GraphQL.Transport.HTTP.Protocol.GQExecError
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLBatchedReqs a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.GraphQL.Transport.HTTP.Protocol.GQLReq a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.HTTP.Protocol.OperationName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.HTTP.Protocol.GQLExecDoc


-- | Implements <i>variable resolution</i> for GraphQL queries, which
--   annotates the use site of each GraphQL variable with its value.
module Hasura.GraphQL.Execute.Resolve
resolveVariables :: forall m fragments. (MonadError QErr m, Traversable fragments) => [VariableDefinition] -> VariableValues -> [Directive Name] -> SelectionSet fragments Name -> m ([Directive Variable], SelectionSet fragments Variable)


-- | Postgres Connection Settings
--   
--   This module contains types and combinators related to postgres
--   connection, pool, and replica related settings.
module Hasura.Backends.Postgres.Connection.Settings
data PostgresPoolSettings
PostgresPoolSettings :: Maybe Int -> Maybe Int -> Maybe Int -> Maybe Int -> Maybe NominalDiffTime -> Maybe NominalDiffTime -> PostgresPoolSettings
[ppsMaxConnections] :: PostgresPoolSettings -> Maybe Int
[ppsTotalMaxConnections] :: PostgresPoolSettings -> Maybe Int
[ppsIdleTimeout] :: PostgresPoolSettings -> Maybe Int
[ppsRetries] :: PostgresPoolSettings -> Maybe Int
[ppsPoolTimeout] :: PostgresPoolSettings -> Maybe NominalDiffTime
[ppsConnectionLifetime] :: PostgresPoolSettings -> Maybe NominalDiffTime
data DefaultPostgresPoolSettings
DefaultPostgresPoolSettings :: Int -> Int -> Int -> Maybe NominalDiffTime -> DefaultPostgresPoolSettings
[dppsMaxConnections] :: DefaultPostgresPoolSettings -> Int
[dppsIdleTimeout] :: DefaultPostgresPoolSettings -> Int
[dppsRetries] :: DefaultPostgresPoolSettings -> Int
[dppsConnectionLifetime] :: DefaultPostgresPoolSettings -> Maybe NominalDiffTime
defaultPostgresPoolSettings :: DefaultPostgresPoolSettings
setPostgresPoolSettings :: PostgresPoolSettings
getDefaultPGPoolSettingIfNotExists :: Maybe PostgresPoolSettings -> DefaultPostgresPoolSettings -> (Int, Int, Int)
data SSLMode
Disable :: SSLMode
Allow :: SSLMode
Prefer :: SSLMode
Require :: SSLMode
VerifyCA :: SSLMode
VerifyFull :: SSLMode
newtype CertVar
CertVar :: String -> CertVar
newtype CertData
CertData :: Text -> CertData
[unCert] :: CertData -> Text
data PGClientCerts p a
PGClientCerts :: Maybe a -> Maybe a -> Maybe a -> SSLMode -> Maybe p -> PGClientCerts p a
[pgcSslCert] :: PGClientCerts p a -> Maybe a
[pgcSslKey] :: PGClientCerts p a -> Maybe a
[pgcSslRootCert] :: PGClientCerts p a -> Maybe a
[pgcSslMode] :: PGClientCerts p a -> SSLMode
[pgcSslPassword] :: PGClientCerts p a -> Maybe p
data PostgresSourceConnInfo
PostgresSourceConnInfo :: UrlConf -> Maybe PostgresPoolSettings -> Bool -> TxIsolation -> Maybe (PGClientCerts CertVar CertVar) -> PostgresSourceConnInfo
[psciDatabaseUrl] :: PostgresSourceConnInfo -> UrlConf
[psciPoolSettings] :: PostgresSourceConnInfo -> Maybe PostgresPoolSettings
[psciUsePreparedStatements] :: PostgresSourceConnInfo -> Bool
[psciIsolationLevel] :: PostgresSourceConnInfo -> TxIsolation
[psciSslConfiguration] :: PostgresSourceConnInfo -> Maybe (PGClientCerts CertVar CertVar)
defaultPostgresExtensionsSchema :: ExtensionsSchema

-- | `kriti-lang` template.
data KritiTemplate
KritiTemplate :: Text -> ValueExt -> KritiTemplate

-- | Raw kriti template
[ktSource] :: KritiTemplate -> Text

-- | Parsed kriti template
[ktParsedAST] :: KritiTemplate -> ValueExt

-- | Connection template for the dynamic DB connection.
data ConnectionTemplate
ConnectionTemplate :: Int -> KritiTemplate -> ConnectionTemplate

-- | Version for the connection template. Please read more about this in
--   the dynamic DB connection RFC (Metadata API &gt; Versioning).
[ctVersion] :: ConnectionTemplate -> Int

-- | `kriti-lang` template for the dynamic DB connection.
[ctTemplate] :: ConnectionTemplate -> KritiTemplate

-- | Name of the member of a connection set.
newtype PostgresConnectionSetMemberName
PostgresConnectionSetMemberName :: NonEmptyText -> PostgresConnectionSetMemberName
[getPostgresConnectionSetMemberName] :: PostgresConnectionSetMemberName -> NonEmptyText
data PostgresConnectionSetMember
PostgresConnectionSetMember :: PostgresConnectionSetMemberName -> PostgresSourceConnInfo -> PostgresConnectionSetMember
[pscmName] :: PostgresConnectionSetMember -> PostgresConnectionSetMemberName
[pscmConnectionInfo] :: PostgresConnectionSetMember -> PostgresSourceConnInfo

-- | HashMap of the connection set. This is used for the dynamic DB
--   connection feature.
newtype PostgresConnectionSet
PostgresConnectionSet :: NEHashMap PostgresConnectionSetMemberName PostgresConnectionSetMember -> PostgresConnectionSet
[getPostgresConnectionSet] :: PostgresConnectionSet -> NEHashMap PostgresConnectionSetMemberName PostgresConnectionSetMember
data PostgresConnConfiguration
PostgresConnConfiguration :: PostgresSourceConnInfo -> Maybe (NonEmpty PostgresSourceConnInfo) -> ExtensionsSchema -> Maybe ConnectionTemplate -> Maybe PostgresConnectionSet -> PostgresConnConfiguration
[pccConnectionInfo] :: PostgresConnConfiguration -> PostgresSourceConnInfo
[pccReadReplicas] :: PostgresConnConfiguration -> Maybe (NonEmpty PostgresSourceConnInfo)
[pccExtensionsSchema] :: PostgresConnConfiguration -> ExtensionsSchema
[pccConnectionTemplate] :: PostgresConnConfiguration -> Maybe ConnectionTemplate
[pccConnectionSet] :: PostgresConnConfiguration -> Maybe PostgresConnectionSet
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.DefaultPostgresPoolSettings
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.DefaultPostgresPoolSettings
instance GHC.Enum.Bounded Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Enum.Enum Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Classes.Ord Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.CertVar
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.CertVar
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.CertVar
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.CertData
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.CertData
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.CertData
instance Data.Traversable.Traversable (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p)
instance Data.Foldable.Foldable (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p)
instance GHC.Base.Functor (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq p) => GHC.Classes.Eq (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance (GHC.Show.Show a, GHC.Show.Show p) => GHC.Show.Show (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance GHC.Classes.Ord Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance GHC.Generics.Generic Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Generics.Generic Database.PG.Query.Transaction.TxIsolation
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.PostgresConnConfiguration
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSet
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMember
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresConnectionSetMemberName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.ConnectionTemplate
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.KritiTemplate
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresSourceConnInfo
instance (Autodocodec.Class.HasCodec p, Autodocodec.Class.HasCodec a) => Autodocodec.Class.HasCodec (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance (Data.Aeson.Types.FromJSON.FromJSON p, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance (Data.Aeson.Types.ToJSON.ToJSON p, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance Data.Bifunctor.Bifunctor Hasura.Backends.Postgres.Connection.Settings.PGClientCerts
instance Data.Bifoldable.Bifoldable Hasura.Backends.Postgres.Connection.Settings.PGClientCerts
instance Data.Bitraversable.Bitraversable Hasura.Backends.Postgres.Connection.Settings.PGClientCerts
instance (Data.Hashable.Class.Hashable p, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance (Control.DeepSeq.NFData p, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.Backends.Postgres.Connection.Settings.PGClientCerts p a)
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.CertData
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.CertData
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.CertVar
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.SSLMode
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Connection.Settings.PostgresPoolSettings
instance Control.DeepSeq.NFData Database.PG.Query.Transaction.TxIsolation
instance Data.Hashable.Class.Hashable Database.PG.Query.Transaction.TxIsolation
instance Autodocodec.Class.HasCodec Database.PG.Query.Transaction.TxIsolation
instance Data.Aeson.Types.FromJSON.FromJSON Database.PG.Query.Transaction.TxIsolation
instance Data.Aeson.Types.ToJSON.ToJSON Database.PG.Query.Transaction.TxIsolation

module Hasura.RQL.Types.Backend
type SessionVarType b = CollectableType (ScalarType b)
data ComputedFieldReturnType (b :: BackendType)
ReturnsScalar :: ScalarType b -> ComputedFieldReturnType (b :: BackendType)
ReturnsTable :: TableName b -> ComputedFieldReturnType (b :: BackendType)
ReturnsOthers :: ComputedFieldReturnType (b :: BackendType)
type XEnable = ()
type XDisable = Void

-- | Used for keeping track of the extent of support of naming convention
--   across different backends.
--   
--   <tt>AllConventions</tt> implies a full support whereas
--   <tt>OnlyHasuraCase</tt> implies a partial support of only
--   <tt>HasuraCase</tt>
data SupportedNamingCase
OnlyHasuraCase :: SupportedNamingCase
AllConventions :: SupportedNamingCase

-- | Mapping from abstract types to concrete backend representation
--   
--   The RQL IR, used as the output of GraphQL parsers and of the RQL
--   parsers, is backend-agnostic: it uses an abstract representation of
--   the structure of a query, and delegates to the backends the task of
--   choosing an appropriate concrete representation.
--   
--   Additionally, grouping all those types under one typeclass rather than
--   having dedicated type families allows to explicitly list all typeclass
--   requirements, which simplifies the instance declarations of all IR
--   types.
--   
--   There are no injectivity requirements on those type families: it's
--   okay for two different backends to use the same types. That means,
--   however, that functions cannot identify to what backend b a given
--   <tt>TableName b</tt> refers to; most generic functions will need
--   either a type application or a <tt>Proxy</tt> parameter to
--   disambiguate between different backends at the call site.
class (HasSourceConfiguration b, Representable (BasicOrderType b), Representable (Column b), Representable (ComputedFieldDefinition b), Representable (ComputedFieldImplicitArguments b), Representable (ComputedFieldReturn b), Representable (ConstraintName b), Representable (ExtraTableMetadata b), Representable (FunctionArgument b), Representable (FunctionName b), Representable (FunctionReturnType b), Representable (HealthCheckTest b), Representable (NullsOrderType b), Representable (SQLExpression b), Representable (ScalarSelectionArguments b), Representable (ScalarType b), Representable (XComputedField b), Representable (XGroupBy b), Representable (TableName b), Eq (RawFunctionInfo b), Show (RawFunctionInfo b), Representable (ResolvedConnectionTemplate b), Ord (TableName b), Ord (FunctionName b), Ord (ScalarType b), Ord (Column b), Ord (ComputedFieldReturn b), Ord (ComputedFieldImplicitArguments b), Ord (ConstraintName b), Ord (FunctionArgument b), Ord (XComputedField b), Data (TableName b), FromJSON (BackendConfig b), FromJSON (Column b), FromJSON (ComputedFieldDefinition b), FromJSON (ConnectionTemplateRequestContext b), FromJSON (ConstraintName b), FromJSON (ExtraTableMetadata b), FromJSON (FunctionName b), FromJSON (FunctionReturnType b), FromJSON (HealthCheckTest b), FromJSON (RawFunctionInfo b), FromJSON (ScalarType b), FromJSON (TableName b), FromJSONKey (Column b), FromJSONKey (ConstraintName b), HasCodec (BackendConfig b), HasCodec (BackendSourceKind b), HasCodec (Column b), HasCodec (ComputedFieldDefinition b), HasCodec (FunctionName b), HasCodec (FunctionReturnType b), HasCodec (ScalarType b), HasCodec (TableName b), ToJSON (BackendConfig b), ToJSON (Column b), ToJSON (ConstraintName b), ToJSON (ExecutionStatistics b), ToJSON (FunctionArgument b), ToJSON (FunctionName b), ToJSON (FunctionReturnType b), ToJSON (RawFunctionInfo b), ToJSON (ScalarType b), ToJSON (TableName b), ToJSON (ExtraTableMetadata b), ToJSON (SQLExpression b), ToJSON (ComputedFieldDefinition b), ToJSON (ComputedFieldImplicitArguments b), ToJSON (ComputedFieldReturn b), ToJSON (HealthCheckTest b), ToJSON (ResolvedConnectionTemplate b), ToJSONKey (Column b), ToJSONKey (ConstraintName b), ToJSONKey (ScalarType b), ToTxt (Column b), ToTxt (FunctionName b), ToTxt (ScalarType b), ToTxt (TableName b), ToTxt (ConstraintName b), ToErrorValue (Column b), ToErrorValue (TableName b), Typeable (Column b), Typeable b, HasTag b, Traversable (CountType b), Traversable (FunctionArgumentExp b), Eq (BackendConfig b), Show (BackendConfig b), Eq (BackendInfo b), Show (BackendInfo b), Monoid (BackendInfo b), Eq (ScalarValue b), Show (ScalarValue b), Eq (XNodesAgg b), Show (XNodesAgg b), Eq (XRelay b), Show (XRelay b), Eq (XStreamingSubscription b), Show (XStreamingSubscription b), Eq (XNestedObjects b), Ord (XNestedObjects b), Show (XNestedObjects b), NFData (XNestedObjects b), Hashable (XNestedObjects b), ToJSON (XNestedObjects b), FromJSON (XNestedObjects b), ToTxt (XNestedObjects b), Traversable (BooleanOperators b), Traversable (UpdateVariant b), Traversable (BackendInsert b), Traversable (AggregationPredicates b)) => Backend (b :: BackendType) where {
    
    -- | Backend configuration stored in metadata
    type BackendConfig b :: Type;
    
    -- | Runtime backend info derived from (possibly enriched) BackendConfig
    --   and stored in SchemaCache
    type BackendInfo b :: Type;
    type TableName b :: Type;
    type FunctionName b :: Type;
    type FunctionReturnType b :: Type;
    type RawFunctionInfo b :: Type;
    type ConstraintName b :: Type;
    type BasicOrderType b :: Type;
    type NullsOrderType b :: Type;
    
    -- | The type that captures how count aggregations are modelled
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type CountType b :: Type -> Type;
    type Column b :: Type;
    type ScalarValue b :: Type;
    type ScalarType b :: Type;
    type SQLExpression b :: Type;
    type ComputedFieldDefinition b :: Type;
    
    -- | Arguments of a scalar field's selection { query { some_table { # a
    --   scalar field column(ScalarSelectionArguments) } } }
    type ScalarSelectionArguments b :: Type;
    type ExtraTableMetadata b :: Type;
    
    -- | FunctionArgument
    type FunctionArgument b :: Type;
    
    -- | Function input argument expression
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type FunctionArgumentExp b :: Type -> Type;
    
    -- | Computed field function argument values which are being implicitly
    --   inferred from table and/or session information
    type ComputedFieldImplicitArguments b :: Type;
    
    -- | Computed field return information
    type ComputedFieldReturn b :: Type;
    
    -- | A config type for health check tests
    type HealthCheckTest b :: Type;
    
    -- | Intermediate Representation of extensions to the shared set of boolean
    --   operators on table fields.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type BooleanOperators b :: Type -> Type;
    
    -- | Intermediate Representation of aggregation predicates. The default
    --   implementation makes aggregation predicates uninstantiable.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type AggregationPredicates b :: Type -> Type;
    
    -- | The different variants of update supported by a backend for their
    --   intermediate representation. For example, a backend could use a sum
    --   type encapsulating either a single batch update or multiple batch
    --   updates.
    --   
    --   The default implementation makes update expressions uninstantiable.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type UpdateVariant b :: Type -> Type;
    
    -- | Intermediate Representation of Insert Mutations. The default
    --   implementation makes insert expressions uninstantiable.
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type BackendInsert b :: Type -> Type;
    type XComputedField b :: Type;
    type XRelay b :: Type;
    type XNodesAgg b :: Type;
    
    -- | Flag the availability of event triggers.
    type XEventTriggers b :: Type;
    
    -- | Extension to flag the availability of object and array relationships
    --   in inserts (aka nested inserts).
    type XNestedInserts b :: Type;
    type XStreamingSubscription b :: Type;
    type XNestedObjects b :: Type;
    type XGroupBy b :: Type;
    type ResolvedConnectionTemplate b :: Type;
    type ConnectionTemplateRequestContext b :: Type;
    
    -- | Information about the query execution that may be useful for debugging
    --   or reporting.
    type ExecutionStatistics b :: Type;
    type FunctionReturnType b = XDisable;
    type AggregationPredicates b = Const Void;
    type UpdateVariant b = Const Void;
    type BackendInsert b = Const Void;
    type XNestedObjects b = XDisable;
    type XGroupBy b = XDisable;
    type ResolvedConnectionTemplate b = ();
    type ConnectionTemplateRequestContext b = ();
    type ExecutionStatistics b = ();
}

-- | A backend type can opt into supporting health checks by providing an
--   implementation that includes a default health check test, and a health
--   check test codec.
healthCheckImplementation :: Backend b => Maybe (HealthCheckImplementation (HealthCheckTest b))

-- | An Implementation for version checking when adding a source.
versionCheckImplementation :: Backend b => Environment -> SourceName -> SourceConnConfiguration b -> IO (Either QErr ())

-- | A backend type can opt into providing an implementation for
--   fingerprinted pings to the source, useful for attribution that the
--   user is using Hasura
runPingSource :: Backend b => Environment -> (String -> IO ()) -> SourceName -> SourceConnConfiguration b -> IO ()
resolveConnectionTemplate :: Backend b => SourceConfig b -> ConnectionTemplateRequestContext b -> Maybe ConnectionTemplate -> Either QErr EncJSON
isComparableType :: Backend b => ScalarType b -> Bool
isNumType :: Backend b => ScalarType b -> Bool

-- | Custom aggregate operators supported by the backend. Backends that
--   support custom aggregate operators should return a HashMap from
--   operator name to a scalar type mapping. In the scalar type mapping the
--   key represents the input type for the operator and the value
--   represents the result type. Backends that do not support custom
--   aggregate operators can use the default implementation which returns
--   an empty map.
getCustomAggregateOperators :: Backend b => SourceConfig b -> HashMap Name (HashMap (ScalarType b) (ScalarType b))
textToScalarValue :: Backend b => Maybe Text -> ScalarValue b
parseScalarValue :: Backend b => ScalarTypeParsingContext b -> ScalarType b -> Value -> Either QErr (ScalarValue b)
scalarValueToJSON :: Backend b => ScalarValue b -> Value
functionToTable :: Backend b => FunctionName b -> TableName b
tableToFunction :: Backend b => TableName b -> FunctionName b
computedFieldFunction :: Backend b => ComputedFieldDefinition b -> FunctionName b
computedFieldReturnType :: Backend b => ComputedFieldReturn b -> ComputedFieldReturnType b

-- | Backends that don't support aggregate computed fields will never
--   encounter an <a>SelectionField</a>. However, backends are expected to
--   provide a total transformation from <tt>SelectionField</tt> to the
--   backend's query language.
--   
--   Rather than implement error handling for every backend that doesn't
--   support aggregate computed fields, and then remove that error handling
--   for each backend when we <i>add</i> support - honestly, adding error
--   handling would probably take longer than adding aggregate computed
--   field support - we instead have a flag.
--   
--   If a backend declares this flag as <a>False</a>, computed fields will
--   not be added to the GraphQL schema. This means that backends can
--   safely handle <tt>SFComputedField</tt> with a runtime exception <i>as
--   long as</i> this flag is <a>False</a>.
--   
--   Once all backends support all aggregate computed field operations,
--   this flag can be deleted.
supportsAggregateComputedFields :: Backend b => Bool

-- | Build function arguments expression from computed field implicit
--   arguments
fromComputedFieldImplicitArguments :: Backend b => v -> ComputedFieldImplicitArguments b -> [FunctionArgumentExp b v]
tableGraphQLName :: Backend b => TableName b -> Either QErr Name
functionGraphQLName :: Backend b => FunctionName b -> Either QErr Name
getTableIdentifier :: Backend b => TableName b -> Either QErr GQLNameIdentifier
snakeCaseTableName :: Backend b => TableName b -> Text
namingConventionSupport :: Backend b => SupportedNamingCase
resizeSourcePools :: Backend b => SourceConfig b -> ServerReplicas -> IO SourceResizePoolSummary

-- | Default behaviour of SQL triggers on logically replicated database.
--   Setting this to <tt>Nothing</tt> will disable event trigger
--   configuration in the metadata.
defaultTriggerOnReplication :: Backend b => Maybe (XEventTriggers b, TriggerOnReplication)
backendSupportsNestedObjects :: Backend b => Either QErr (XNestedObjects b)
backendSupportsNestedObjects :: (Backend b, XNestedObjects b ~ XDisable) => Either QErr (XNestedObjects b)
sourceSupportsSchemalessTables :: Backend b => SourceConfig b -> Bool
_ReturnsTable :: forall b_a4itd. Prism' (ComputedFieldReturnType b_a4itd) (TableName b_a4itd)

module Hasura.RQL.Types.SourceCustomization
data RootFieldsCustomization
RootFieldsCustomization :: Maybe Name -> Maybe Name -> Maybe Name -> RootFieldsCustomization
[_rootfcNamespace] :: RootFieldsCustomization -> Maybe Name
[_rootfcPrefix] :: RootFieldsCustomization -> Maybe Name
[_rootfcSuffix] :: RootFieldsCustomization -> Maybe Name
data SourceTypeCustomization
emptySourceTypeCustomization :: SourceTypeCustomization
mkCustomizedTypename :: Maybe SourceTypeCustomization -> NamingCase -> MkTypename

-- | apply naming convention to type name
applyTypeNameCaseCust :: NamingCase -> Name -> Name

-- | apply naming convention to field name
applyFieldNameCaseCust :: NamingCase -> Name -> Name

-- | returns field name according to the naming conventions as
--   <tt>Text</tt>
getTextFieldName :: NamingCase -> GQLNameIdentifier -> Text

-- | applies naming convention and returns field name
--   
--   Note: This can't possibly fail as <tt>GQLNameIdentifier</tt> contains
--   already validated identifiers
applyTypeNameCaseIdentifier :: NamingCase -> GQLNameIdentifier -> Name

-- | returns type name according to the naming conventions as <tt>Text</tt>
getTextTypeName :: NamingCase -> GQLNameIdentifier -> Text

-- | applies naming convention and returns type name
--   
--   Note: This can't possibly fail as <tt>GQLNameIdentifier</tt> contains
--   already validated identifiers
applyFieldNameCaseIdentifier :: NamingCase -> GQLNameIdentifier -> Name
applyEnumValueCase :: NamingCase -> Name -> Name

-- | Source customization information as it appears in the metadata.
data SourceCustomization
SourceCustomization :: Maybe RootFieldsCustomization -> Maybe SourceTypeCustomization -> Maybe NamingCase -> SourceCustomization
[_scRootFields] :: SourceCustomization -> Maybe RootFieldsCustomization
[_scTypeNames] :: SourceCustomization -> Maybe SourceTypeCustomization
[_scNamingConvention] :: SourceCustomization -> Maybe NamingCase
emptySourceCustomization :: SourceCustomization
getSourceTypeCustomization :: SourceCustomization -> SourceTypeCustomization

-- | Source customization as it appears in the SchemaCache.
data ResolvedSourceCustomization
ResolvedSourceCustomization :: MkRootFieldName -> MkTypename -> NamingCase -> Maybe Name -> ResolvedSourceCustomization
[_rscRootFields] :: ResolvedSourceCustomization -> MkRootFieldName
[_rscTypeNames] :: ResolvedSourceCustomization -> MkTypename
[_rscNamingConvention] :: ResolvedSourceCustomization -> NamingCase
[_rscRootNamespace] :: ResolvedSourceCustomization -> Maybe Name
mkResolvedSourceCustomization :: SourceCustomization -> NamingCase -> ResolvedSourceCustomization

-- | Function to apply root field name customizations.
newtype MkRootFieldName
MkRootFieldName :: (Name -> Name) -> MkRootFieldName
[runMkRootFieldName] :: MkRootFieldName -> Name -> Name
getNamingCase :: forall m. MonadError QErr m => SourceCustomization -> SupportedNamingCase -> NamingCase -> m NamingCase
mkSelectField :: GQLNameIdentifier -> GQLNameIdentifier
mkSelectAggregateField :: GQLNameIdentifier -> GQLNameIdentifier
mkSelectByPkField :: GQLNameIdentifier -> GQLNameIdentifier
mkInsertField :: GQLNameIdentifier -> GQLNameIdentifier
mkInsertOneField :: GQLNameIdentifier -> GQLNameIdentifier
mkUpdateField :: GQLNameIdentifier -> GQLNameIdentifier
mkUpdateByPkField :: GQLNameIdentifier -> GQLNameIdentifier
mkUpdateManyField :: GQLNameIdentifier -> GQLNameIdentifier
mkDeleteField :: GQLNameIdentifier -> GQLNameIdentifier
mkDeleteByPkField :: GQLNameIdentifier -> GQLNameIdentifier
mkRelayConnectionField :: GQLNameIdentifier -> GQLNameIdentifier
mkSelectStreamField :: GQLNameIdentifier -> GQLNameIdentifier
mkMultiRowUpdateTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkOnConflictTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableConstraintTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateFieldTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkFunctionArgsTypeName :: Name -> GQLNameIdentifier -> GQLNameIdentifier
mkTableBoolExpTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableInsertInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableObjRelInsertInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableArrRelInsertInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableMutationResponseTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableOrderByTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateOrderByTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateOrderByOpTypeName :: GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier
mkTableAggOperatorTypeName :: GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier
mkTableSelectColumnTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableUpdateColumnTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkTableOperatorInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier
mkTablePkColumnsInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkEnumTableTypeName :: GQLNameIdentifier -> Maybe Name -> GQLNameIdentifier
mkStreamCursorInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkStreamCursorValueInputTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkSelectColumnPredTypeName :: GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier
mkTableAggregateBoolExpTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkGroupByTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkGroupByKeyTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkGroupByKeyFieldsTypeName :: GQLNameIdentifier -> GQLNameIdentifier
mkRelationFunctionIdentifier :: GQLNameIdentifier -> Name -> GQLNameIdentifier
mkRelationFunctionArgumentsFieldName :: GQLNameIdentifier -> Name -> GQLNameIdentifier
updateColumnsFieldName :: GQLNameIdentifier
affectedRowsFieldName :: GQLNameIdentifier
pkColumnsFieldName :: GQLNameIdentifier
instance GHC.Generics.Generic Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance GHC.Show.Show Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance GHC.Classes.Eq Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance GHC.Generics.Generic Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance GHC.Show.Show Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance GHC.Classes.Eq Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance GHC.Generics.Generic Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance GHC.Show.Show Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance GHC.Classes.Eq Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance GHC.Base.Monoid Hasura.RQL.Types.SourceCustomization.MkRootFieldName
instance GHC.Base.Semigroup Hasura.RQL.Types.SourceCustomization.MkRootFieldName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SourceCustomization.SourceCustomization
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SourceCustomization.SourceTypeCustomization
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SourceCustomization.RootFieldsCustomization

module Hasura.RQL.Types.Relationships.ToSource

-- | Metadata representation of a "remote" relationship targetting a
--   source.
--   
--   This representation has to be backend-agnostic, as it will be parsed
--   before the source cache is built, meaning we can't decide how
--   something backend specific should be resolved based solely on the
--   source name. But the table name is specific to the targeted backend...
--   There are two solutions to this problem: - we can either include an
--   additional field in the serialization that tells us the "kind" of the
--   backend; but that requies an additional field that is technically not
--   required, and that could potentially be inconsistent - or we can do
--   the same thing that we do for source to source relationships: we store
--   an unparsed JSON value as far as the metadata goes, and we parse it
--   when building the schema cache, when we know the kind of the source
--   from its name We chose the latter.
--   
--   Furthermore, the mapping is represented using a backend-agnostic
--   <a>FieldName</a>, whose interpretation is likewise delayed until the
--   schema cache is built.
--   
--   FIXME: move this to Hasura/Metadata
data ToSourceRelationshipDef
ToSourceRelationshipDef :: RelType -> HashMap FieldName FieldName -> SourceName -> Value -> ToSourceRelationshipDef
[_tsrdRelationshipType] :: ToSourceRelationshipDef -> RelType
[_tsrdFieldMapping] :: ToSourceRelationshipDef -> HashMap FieldName FieldName
[_tsrdSource] :: ToSourceRelationshipDef -> SourceName
[_tsrdTable] :: ToSourceRelationshipDef -> Value

-- | Schema cache information for a table field targeting a remote source.
data RemoteSourceFieldInfo tgt
RemoteSourceFieldInfo :: RelName -> RelType -> SourceName -> SourceConfig tgt -> TableName tgt -> HashMap FieldName (ScalarType tgt, Column tgt) -> RemoteSourceFieldInfo tgt
[_rsfiName] :: RemoteSourceFieldInfo tgt -> RelName
[_rsfiType] :: RemoteSourceFieldInfo tgt -> RelType
[_rsfiSource] :: RemoteSourceFieldInfo tgt -> SourceName
[_rsfiSourceConfig] :: RemoteSourceFieldInfo tgt -> SourceConfig tgt

-- | this is parsed from <a>Value</a>
[_rsfiTable] :: RemoteSourceFieldInfo tgt -> TableName tgt

-- | LHS field name -&gt; RHS Column, RHS Column type
[_rsfiMapping] :: RemoteSourceFieldInfo tgt -> HashMap FieldName (ScalarType tgt, Column tgt)
tsrdTable :: Lens' ToSourceRelationshipDef Value
tsrdSource :: Lens' ToSourceRelationshipDef SourceName
tsrdRelationshipType :: Lens' ToSourceRelationshipDef RelType
tsrdFieldMapping :: Lens' ToSourceRelationshipDef (HashMap FieldName FieldName)
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance GHC.Show.Show Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.ToSource.RemoteSourceFieldInfo tgt)
instance Hasura.RQL.Types.Backend.Backend tgt => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.ToSource.RemoteSourceFieldInfo tgt)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.ToSource.ToSourceRelationshipDef

module Hasura.RQL.Types.HealthCheck
newtype HealthCheckTestSql
HealthCheckTestSql :: Text -> HealthCheckTestSql
[_hctSql] :: HealthCheckTestSql -> Text
defaultHealthCheckTestSql :: HealthCheckTestSql
newtype HealthCheckInterval
HealthCheckInterval :: Seconds -> HealthCheckInterval
[unHealthCheckInterval] :: HealthCheckInterval -> Seconds
newtype HealthCheckRetries
HealthCheckRetries :: Int -> HealthCheckRetries
[unHealthCheckRetries] :: HealthCheckRetries -> Int
newtype HealthCheckRetryInterval
HealthCheckRetryInterval :: Seconds -> HealthCheckRetryInterval
[unHealthCheckRetryInterval] :: HealthCheckRetryInterval -> Seconds
newtype HealthCheckTimeout
HealthCheckTimeout :: Seconds -> HealthCheckTimeout
[unHealthCheckTimeout] :: HealthCheckTimeout -> Seconds
data HealthCheckConfig b
HealthCheckConfig :: HealthCheckTest b -> HealthCheckInterval -> HealthCheckRetries -> HealthCheckRetryInterval -> HealthCheckTimeout -> HealthCheckConfig b
[_hccTest] :: HealthCheckConfig b -> HealthCheckTest b
[_hccInterval] :: HealthCheckConfig b -> HealthCheckInterval
[_hccRetries] :: HealthCheckConfig b -> HealthCheckRetries
[_hccRetryInterval] :: HealthCheckConfig b -> HealthCheckRetryInterval
[_hccTimeout] :: HealthCheckConfig b -> HealthCheckTimeout
healthCheckConfigCodec :: forall b. Backend b => HealthCheckImplementation (HealthCheckTest b) -> JSONCodec (HealthCheckConfig b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance GHC.Show.Show Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance GHC.Generics.Generic Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance GHC.Classes.Eq Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance GHC.Show.Show Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance GHC.Generics.Generic Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance GHC.Classes.Eq Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance GHC.Show.Show Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance GHC.Generics.Generic Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance GHC.Classes.Eq Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance GHC.Show.Show Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance GHC.Generics.Generic Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance GHC.Classes.Eq Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.HealthCheck.HealthCheckTimeout
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.HealthCheck.HealthCheckTimeout
instance GHC.Show.Show Hasura.RQL.Types.HealthCheck.HealthCheckTimeout
instance GHC.Generics.Generic Hasura.RQL.Types.HealthCheck.HealthCheckTimeout
instance GHC.Classes.Eq Hasura.RQL.Types.HealthCheck.HealthCheckTimeout
instance GHC.Generics.Generic (Hasura.RQL.Types.HealthCheck.HealthCheckConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.HealthCheck.HealthCheckConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.HealthCheck.HealthCheckConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.HealthCheck.HealthCheckConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.HealthCheck.HealthCheckConfig b)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.HealthCheck.HealthCheckTimeout
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.HealthCheck.HealthCheckRetryInterval
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.HealthCheck.HealthCheckRetries
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.HealthCheck.HealthCheckInterval
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.HealthCheck.HealthCheckTestSql
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.HealthCheck.HealthCheckTestSql

module Hasura.RQL.IR.OrderBy
data OrderByCol
OCPG :: FieldName -> OrderByCol
OCRel :: FieldName -> OrderByCol -> OrderByCol
orderByColFromTxt :: MonadFail m => Text -> m OrderByCol
data OrderByItemG (b :: BackendType) a
OrderByItemG :: Maybe (BasicOrderType b) -> a -> Maybe (NullsOrderType b) -> OrderByItemG (b :: BackendType) a
[obiType] :: OrderByItemG (b :: BackendType) a -> Maybe (BasicOrderType b)
[obiColumn] :: OrderByItemG (b :: BackendType) a -> a
[obiNulls] :: OrderByItemG (b :: BackendType) a -> Maybe (NullsOrderType b)
type OrderByItem b = OrderByItemG b OrderByCol
instance GHC.Classes.Eq Hasura.RQL.IR.OrderBy.OrderByCol
instance GHC.Show.Show Hasura.RQL.IR.OrderBy.OrderByCol
instance GHC.Generics.Generic (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance Data.Traversable.Traversable (Hasura.RQL.IR.OrderBy.OrderByItemG b)
instance Data.Foldable.Foldable (Hasura.RQL.IR.OrderBy.OrderByItemG b)
instance GHC.Base.Functor (Hasura.RQL.IR.OrderBy.OrderByItemG b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.OrderBy.OrderByItemG b a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.IR.OrderBy.OrderByCol


-- | A scalar type to be used for logical models and resolvers.
module Hasura.LogicalModel.NullableScalarType

-- | A ScalarType that can be nullable with an optional description
data NullableScalarType b
NullableScalarType :: ScalarType b -> Bool -> Maybe Text -> NullableScalarType b
[nstType] :: NullableScalarType b -> ScalarType b
[nstNullable] :: NullableScalarType b -> Bool
[nstDescription] :: NullableScalarType b -> Maybe Text
nullableScalarTypeMapCodec :: forall b. Backend b => Codec Value (InsOrdHashMap (Column b) (NullableScalarType b)) (InsOrdHashMap (Column b) (NullableScalarType b))
instance GHC.Generics.Generic (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Autodocodec.Class.HasCodec a => Autodocodec.Class.HasObjectCodec (Hasura.LogicalModel.NullableScalarType.NameField a)
instance (Autodocodec.Class.HasObjectCodec a, Autodocodec.Class.HasObjectCodec b) => Autodocodec.Class.HasObjectCodec (Hasura.LogicalModel.NullableScalarType.MergedObject a b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasObjectCodec (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.LogicalModel.NullableScalarType.NullableScalarType b)


-- | A name for a native query as it is recognized by the graphql schema.
module Hasura.NativeQuery.Types
newtype NativeQueryName
NativeQueryName :: Name -> NativeQueryName
[getNativeQueryName] :: NativeQueryName -> Name
instance Language.Haskell.TH.Syntax.Lift Hasura.NativeQuery.Types.NativeQueryName
instance GHC.Generics.Generic Hasura.NativeQuery.Types.NativeQueryName
instance Data.Data.Data Hasura.NativeQuery.Types.NativeQueryName
instance Data.Text.Extended.ToTxt Hasura.NativeQuery.Types.NativeQueryName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.NativeQuery.Types.NativeQueryName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.NativeQuery.Types.NativeQueryName
instance Control.DeepSeq.NFData Hasura.NativeQuery.Types.NativeQueryName
instance Data.Hashable.Class.Hashable Hasura.NativeQuery.Types.NativeQueryName
instance GHC.Show.Show Hasura.NativeQuery.Types.NativeQueryName
instance GHC.Classes.Ord Hasura.NativeQuery.Types.NativeQueryName
instance GHC.Classes.Eq Hasura.NativeQuery.Types.NativeQueryName
instance Autodocodec.Class.HasCodec Hasura.NativeQuery.Types.NativeQueryName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.NativeQuery.Types.NativeQueryName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.NativeQuery.Types.NativeQueryName

module Hasura.RQL.Types.Relationships.Local
data RelDef a
RelDef :: RelName -> a -> Maybe Text -> RelDef a
[_rdName] :: RelDef a -> RelName
[_rdUsing] :: RelDef a -> a
[_rdComment] :: RelDef a -> Maybe Text
rdUsing :: forall a_a4HMy a_a4HWp. Lens (RelDef a_a4HMy) (RelDef a_a4HWp) a_a4HMy a_a4HWp
rdName :: forall a_a4HMy. Lens' (RelDef a_a4HMy) RelName
rdComment :: forall a_a4HMy. Lens' (RelDef a_a4HMy) (Maybe Text)
data RelManualConfig (b :: BackendType)
RelManualTableConfig :: RelManualTableConfig b -> RelManualConfig (b :: BackendType)
RelManualNativeQueryConfig :: RelManualNativeQueryConfig b -> RelManualConfig (b :: BackendType)
data RelManualTableConfig (b :: BackendType)
RelManualTableConfigC :: TableName b -> RelManualCommon b -> RelManualTableConfig (b :: BackendType)
[rmtTable] :: RelManualTableConfig (b :: BackendType) -> TableName b
[rmtCommon] :: RelManualTableConfig (b :: BackendType) -> RelManualCommon b
data RelManualNativeQueryConfig (b :: BackendType)
RelManualNativeQueryConfigC :: NativeQueryName -> RelManualCommon b -> RelManualNativeQueryConfig (b :: BackendType)
[rmnNativeQueryName] :: RelManualNativeQueryConfig (b :: BackendType) -> NativeQueryName
[rmnCommon] :: RelManualNativeQueryConfig (b :: BackendType) -> RelManualCommon b
data RelManualCommon (b :: BackendType)
RelManualCommon :: HashMap (Column b) (Column b) -> Maybe InsertOrder -> RelManualCommon (b :: BackendType)
[rmColumns] :: RelManualCommon (b :: BackendType) -> HashMap (Column b) (Column b)
[rmInsertOrder] :: RelManualCommon (b :: BackendType) -> Maybe InsertOrder
data RelUsing (b :: BackendType) a
RUFKeyOn :: a -> RelUsing (b :: BackendType) a
RUManual :: RelManualConfig b -> RelUsing (b :: BackendType) a
data ArrRelUsingFKeyOn (b :: BackendType)
ArrRelUsingFKeyOn :: TableName b -> NonEmpty (Column b) -> ArrRelUsingFKeyOn (b :: BackendType)
[arufTable] :: ArrRelUsingFKeyOn (b :: BackendType) -> TableName b
[arufColumns] :: ArrRelUsingFKeyOn (b :: BackendType) -> NonEmpty (Column b)
data WithTable b a
WithTable :: SourceName -> TableName b -> a -> WithTable b a
[wtSource] :: WithTable b a -> SourceName
[wtName] :: WithTable b a -> TableName b
[wtInfo] :: WithTable b a -> a
data ObjRelUsingChoice b
SameTable :: NonEmpty (Column b) -> ObjRelUsingChoice b
RemoteTable :: TableName b -> NonEmpty (Column b) -> ObjRelUsingChoice b
type ArrRelUsing b = RelUsing b (ArrRelUsingFKeyOn b)
type ArrRelDef b = RelDef (ArrRelUsing b)
type ObjRelUsing b = RelUsing b (ObjRelUsingChoice b)
type ObjRelDef b = RelDef (ObjRelUsing b)
data RelTarget b
RelTargetTable :: TableName b -> RelTarget b
RelTargetNativeQuery :: NativeQueryName -> RelTarget b
data RelInfo (b :: BackendType)
RelInfo :: RelName -> RelType -> HashMap (Column b) (Column b) -> RelTarget b -> Bool -> InsertOrder -> RelInfo (b :: BackendType)
[riName] :: RelInfo (b :: BackendType) -> RelName
[riType] :: RelInfo (b :: BackendType) -> RelType
[riMapping] :: RelInfo (b :: BackendType) -> HashMap (Column b) (Column b)
[riTarget] :: RelInfo (b :: BackendType) -> RelTarget b
[riIsManual] :: RelInfo (b :: BackendType) -> Bool
[riInsertOrder] :: RelInfo (b :: BackendType) -> InsertOrder
data Nullable
Nullable :: Nullable
NotNullable :: Nullable
boolToNullable :: Bool -> Nullable
fromRel :: RelName -> FieldName
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelManualCommon b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelManualNativeQueryConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.Local.Nullable
instance GHC.Show.Show Hasura.RQL.Types.Relationships.Local.Nullable
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Local.Nullable
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelManualNativeQueryConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelManualNativeQueryConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelManualCommon b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelManualCommon b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.WithTable b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.WithTable b a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Relationships.Local.Nullable
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Relationships.Local.Nullable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.Local.Nullable
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.Local.Nullable
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelTarget b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.ObjRelUsingChoice b)
instance (Data.Aeson.Types.FromJSON.FromJSON a, Hasura.RQL.Types.Backend.Backend b) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.WithTable b a)
instance (Hasura.RQL.Types.Common.ToAesonPairs a, Hasura.RQL.Types.Backend.Backend b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.WithTable b a)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.ArrRelUsingFKeyOn b)
instance (Hasura.RQL.Types.Backend.Backend b, Autodocodec.Class.HasCodec a, Data.Typeable.Internal.Typeable a) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance (Data.Aeson.Types.FromJSON.FromJSON a, Hasura.RQL.Types.Backend.Backend b) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelUsing b a)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.RelManualConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.RelManualTableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.RelManualNativeQueryConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasObjectCodec (Hasura.RQL.Types.Relationships.Local.RelManualCommon b)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Hasura.RQL.Types.Common.ToAesonPairs (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance (Autodocodec.Class.HasCodec a, Data.Typeable.Internal.Typeable a) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Autodocodec.Class.HasCodec a => Autodocodec.Class.HasObjectCodec (Hasura.RQL.Types.Relationships.Local.RelDef a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Relationships.Local.RelDef a)


-- | More leaves cut from RQL.IR.Select for sake of breaking up the big
--   pile of things
module Hasura.RQL.IR.Select.RelationSelect
data AnnRelationSelectG (b :: BackendType) a
AnnRelationSelectG :: RelName -> HashMap (Column b) (Column b) -> Nullable -> a -> AnnRelationSelectG (b :: BackendType) a
[$sel:_aarRelationshipName:AnnRelationSelectG] :: AnnRelationSelectG (b :: BackendType) a -> RelName
[$sel:_aarColumnMapping:AnnRelationSelectG] :: AnnRelationSelectG (b :: BackendType) a -> HashMap (Column b) (Column b)
[$sel:_aarNullable:AnnRelationSelectG] :: AnnRelationSelectG (b :: BackendType) a -> Nullable
[$sel:_aarAnnSelect:AnnRelationSelectG] :: AnnRelationSelectG (b :: BackendType) a -> a
instance Data.Traversable.Traversable (Hasura.RQL.IR.Select.RelationSelect.AnnRelationSelectG b)
instance Data.Foldable.Foldable (Hasura.RQL.IR.Select.RelationSelect.AnnRelationSelectG b)
instance GHC.Base.Functor (Hasura.RQL.IR.Select.RelationSelect.AnnRelationSelectG b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.RelationSelect.AnnRelationSelectG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v) => GHC.Show.Show (Hasura.RQL.IR.Select.RelationSelect.AnnRelationSelectG b v)


-- | Common codecs shared between similar logical model resolvers.
module Hasura.LogicalModelResolver.Codec

-- | Codec for native-query-or-table relationships
nativeQueryRelationshipsCodec :: forall b. Backend b => Codec Value (InsOrdHashMap RelName (RelDef (RelManualConfig b))) (InsOrdHashMap RelName (RelDef (RelManualConfig b)))
instance Autodocodec.Class.HasCodec a => Autodocodec.Class.HasObjectCodec (Hasura.LogicalModelResolver.Codec.NameField a)
instance (Autodocodec.Class.HasObjectCodec a, Autodocodec.Class.HasObjectCodec b) => Autodocodec.Class.HasObjectCodec (Hasura.LogicalModelResolver.Codec.MergedObject a b)


-- | A name for a logical model as it is recognized by the graphql schema.
module Hasura.LogicalModel.Types
newtype LogicalModelName
LogicalModelName :: Name -> LogicalModelName
[getLogicalModelName] :: LogicalModelName -> Name
data LogicalModelTypeScalar b
LogicalModelTypeScalarC :: ScalarType b -> Bool -> LogicalModelTypeScalar b
[lmtsScalar] :: LogicalModelTypeScalar b -> ScalarType b
[lmtsNullable] :: LogicalModelTypeScalar b -> Bool
data LogicalModelTypeArray b
LogicalModelTypeArrayC :: LogicalModelType b -> Bool -> LogicalModelTypeArray b
[lmtaArray] :: LogicalModelTypeArray b -> LogicalModelType b
[lmtaNullable] :: LogicalModelTypeArray b -> Bool
data LogicalModelTypeReference
LogicalModelTypeReferenceC :: LogicalModelName -> Bool -> LogicalModelTypeReference
[lmtrReference] :: LogicalModelTypeReference -> LogicalModelName
[lmtrNullable] :: LogicalModelTypeReference -> Bool
data LogicalModelType b
LogicalModelTypeScalar :: LogicalModelTypeScalar b -> LogicalModelType b
LogicalModelTypeArray :: LogicalModelTypeArray b -> LogicalModelType b
LogicalModelTypeReference :: LogicalModelTypeReference -> LogicalModelType b

-- | a single field in a Logical Model
data LogicalModelField b
LogicalModelField :: Column b -> LogicalModelType b -> Maybe Text -> LogicalModelField b
[lmfName] :: LogicalModelField b -> Column b
[lmfType] :: LogicalModelField b -> LogicalModelType b
[lmfDescription] :: LogicalModelField b -> Maybe Text
type LogicalModelFields b = InsOrdHashMap (Column b) (LogicalModelField b)
logicalModelFieldMapCodec :: forall b. Backend b => Codec Value (LogicalModelFields b) (LogicalModelFields b)
data LogicalModelLocation
LMLLogicalModel :: LogicalModelName -> LogicalModelLocation
LMLNativeQuery :: NativeQueryName -> LogicalModelLocation
instance Language.Haskell.TH.Syntax.Lift Hasura.LogicalModel.Types.LogicalModelName
instance GHC.Generics.Generic Hasura.LogicalModel.Types.LogicalModelName
instance Data.Data.Data Hasura.LogicalModel.Types.LogicalModelName
instance Data.Text.Extended.ToTxt Hasura.LogicalModel.Types.LogicalModelName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.LogicalModel.Types.LogicalModelName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.LogicalModel.Types.LogicalModelName
instance Control.DeepSeq.NFData Hasura.LogicalModel.Types.LogicalModelName
instance Data.Hashable.Class.Hashable Hasura.LogicalModel.Types.LogicalModelName
instance GHC.Show.Show Hasura.LogicalModel.Types.LogicalModelName
instance GHC.Classes.Ord Hasura.LogicalModel.Types.LogicalModelName
instance GHC.Classes.Eq Hasura.LogicalModel.Types.LogicalModelName
instance GHC.Generics.Generic (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Control.DeepSeq.NFData Hasura.LogicalModel.Types.LogicalModelTypeReference
instance Data.Hashable.Class.Hashable Hasura.LogicalModel.Types.LogicalModelTypeReference
instance GHC.Generics.Generic Hasura.LogicalModel.Types.LogicalModelTypeReference
instance GHC.Show.Show Hasura.LogicalModel.Types.LogicalModelTypeReference
instance GHC.Classes.Eq Hasura.LogicalModel.Types.LogicalModelTypeReference
instance GHC.Generics.Generic (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance GHC.Generics.Generic (Hasura.LogicalModel.Types.LogicalModelType b)
instance GHC.Generics.Generic (Hasura.LogicalModel.Types.LogicalModelField b)
instance Data.Hashable.Class.Hashable Hasura.LogicalModel.Types.LogicalModelLocation
instance GHC.Generics.Generic Hasura.LogicalModel.Types.LogicalModelLocation
instance GHC.Show.Show Hasura.LogicalModel.Types.LogicalModelLocation
instance GHC.Classes.Ord Hasura.LogicalModel.Types.LogicalModelLocation
instance GHC.Classes.Eq Hasura.LogicalModel.Types.LogicalModelLocation
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.LogicalModel.Types.LogicalModelTypeReference
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.LogicalModel.Types.LogicalModelTypeReference
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Types.LogicalModelField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Types.LogicalModelField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.Types.LogicalModelField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.LogicalModel.Types.LogicalModelField b)
instance Data.Text.Extended.ToTxt Hasura.LogicalModel.Types.LogicalModelLocation
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.Types.LogicalModelField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.LogicalModel.Types.LogicalModelField b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.LogicalModel.Types.LogicalModelField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.Types.LogicalModelTypeArray b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Types.LogicalModelType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Types.LogicalModelType b)
instance Autodocodec.Class.HasCodec Hasura.LogicalModel.Types.LogicalModelTypeReference
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.Types.LogicalModelTypeScalar b)
instance Autodocodec.Class.HasCodec Hasura.LogicalModel.Types.LogicalModelName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.LogicalModel.Types.LogicalModelName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.LogicalModel.Types.LogicalModelName

module Hasura.RQL.Types.Column
newtype EnumValue
EnumValue :: Name -> EnumValue
[getEnumValue] :: EnumValue -> Name
newtype EnumValueInfo
EnumValueInfo :: Maybe Text -> EnumValueInfo
[evComment] :: EnumValueInfo -> Maybe Text
type EnumValues = HashMap EnumValue EnumValueInfo

-- | Represents a reference to an â€œenum table,â€ a single-column Postgres
--   table that is referenced via foreign key.
data EnumReference (b :: BackendType)
EnumReference :: TableName b -> EnumValues -> Maybe Name -> EnumReference (b :: BackendType)
[erTable] :: EnumReference (b :: BackendType) -> TableName b
[erValues] :: EnumReference (b :: BackendType) -> EnumValues
[erTableCustomName] :: EnumReference (b :: BackendType) -> Maybe Name

-- | The type we use for columns, which are currently always â€œscalarsâ€
--   (though see the note about <a>CollectableType</a>). Unlike
--   <a>ScalarType</a>, which represents a type that a backend knows about,
--   this type characterizes distinctions we make but the backend doesnâ€™t.
data ColumnType (b :: BackendType)

-- | Ordinary Postgres columns.
ColumnScalar :: ScalarType b -> ColumnType (b :: BackendType)

-- | Columns that reference enum tables (see
--   <a>Hasura.RQL.Schema.Enum</a>). This is not actually a distinct type
--   from the perspective of Postgres (at the time of this writing, we
--   ensure they always have type <tt>text</tt>), but we really want to
--   distinguish this case, since we treat it <i>completely</i> differently
--   in the GraphQL schema.
ColumnEnumReference :: EnumReference b -> ColumnType (b :: BackendType)
_ColumnEnumReference :: forall b_a58tK. Prism' (ColumnType b_a58tK) (EnumReference b_a58tK)
_ColumnScalar :: forall b_a58tK. Prism' (ColumnType b_a58tK) (ScalarType b_a58tK)

-- | A parser to parse a json value with enforcing column type
type ValueParser b m v = CollectableType (ColumnType b) -> Value -> m v
data ColumnValue (b :: BackendType)
ColumnValue :: ColumnType b -> ScalarValue b -> ColumnValue (b :: BackendType)
[cvType] :: ColumnValue (b :: BackendType) -> ColumnType b
[cvValue] :: ColumnValue (b :: BackendType) -> ScalarValue b
isScalarColumnWhere :: (ScalarType b -> Bool) -> ColumnType b -> Bool
isEnumColumn :: ColumnType b -> Bool

-- | Note: Unconditionally accepts null values and returns <tt>PGNull</tt>.
parseScalarValueColumnTypeWithContext :: forall m b. (MonadError QErr m, Backend b) => ScalarTypeParsingContext b -> ColumnType b -> Value -> m (ScalarValue b)

-- | Note: Unconditionally accepts null values and returns <tt>PGNull</tt>.
parseScalarValueColumnType :: forall m b r. (MonadError QErr m, Backend b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => ColumnType b -> Value -> m (ScalarValue b)
parseScalarValuesColumnTypeWithContext :: forall m b. (MonadError QErr m, Backend b) => ScalarTypeParsingContext b -> ColumnType b -> [Value] -> m [ScalarValue b]
parseScalarValuesColumnType :: forall m b r. (MonadError QErr m, Backend b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => ColumnType b -> [Value] -> m [ScalarValue b]
data RawColumnType (b :: BackendType)
RawColumnTypeScalar :: ScalarType b -> RawColumnType (b :: BackendType)
RawColumnTypeObject :: XNestedObjects b -> Name -> RawColumnType (b :: BackendType)
RawColumnTypeArray :: XNestedObjects b -> RawColumnType b -> Bool -> RawColumnType (b :: BackendType)

-- | â€œRawâ€ column info, as stored in the catalog (but not in the schema
--   cache). Instead of containing a <tt>PGColumnType</tt>, it only
--   contains a <tt>PGScalarType</tt>, which is combined with the
--   <tt>pcirReferences</tt> field and other table data to eventually
--   resolve the type to a <tt>PGColumnType</tt>.
data RawColumnInfo (b :: BackendType)
RawColumnInfo :: Column b -> Int -> RawColumnType b -> Bool -> Maybe Description -> ColumnMutability -> RawColumnInfo (b :: BackendType)
[rciName] :: RawColumnInfo (b :: BackendType) -> Column b

-- | The â€œordinal positionâ€ of the column according to Postgres. Numbering
--   starts at 1 and increases. Dropping a column does <i>not</i> cause the
--   columns to be renumbered, so a column can be consistently identified
--   by its position.
[rciPosition] :: RawColumnInfo (b :: BackendType) -> Int
[rciType] :: RawColumnInfo (b :: BackendType) -> RawColumnType b
[rciIsNullable] :: RawColumnInfo (b :: BackendType) -> Bool
[rciDescription] :: RawColumnInfo (b :: BackendType) -> Maybe Description
[rciMutability] :: RawColumnInfo (b :: BackendType) -> ColumnMutability

-- | Indicates whether a column may participate in certain mutations.
--   
--   For example, identity columns may sometimes be insertable but rarely
--   updatable, depending on the backend and how they're declared.
--   
--   This guides the schema parsers such that they only generate fields for
--   columns where they're valid without having to model the exact
--   circumstances which cause a column to appear or not.
--   
--   See
--   <a>https://github.com/hasura/graphql-engine/blob/master/rfcs/column-mutability.md</a>.
data ColumnMutability
ColumnMutability :: Bool -> Bool -> ColumnMutability
[_cmIsInsertable] :: ColumnMutability -> Bool
[_cmIsUpdatable] :: ColumnMutability -> Bool

-- | â€œResolvedâ€ column info, produced from a <a>RawColumnInfo</a> value
--   that has been combined with other schema information to produce a
--   <tt>PGColumnType</tt>.
data ColumnInfo (b :: BackendType)
ColumnInfo :: Column b -> Name -> Int -> ColumnType b -> Bool -> Maybe Description -> ColumnMutability -> ColumnInfo (b :: BackendType)
[ciColumn] :: ColumnInfo (b :: BackendType) -> Column b

-- | field name exposed in GraphQL interface
[ciName] :: ColumnInfo (b :: BackendType) -> Name
[ciPosition] :: ColumnInfo (b :: BackendType) -> Int
[ciType] :: ColumnInfo (b :: BackendType) -> ColumnType b
[ciIsNullable] :: ColumnInfo (b :: BackendType) -> Bool
[ciDescription] :: ColumnInfo (b :: BackendType) -> Maybe Description
[ciMutability] :: ColumnInfo (b :: BackendType) -> ColumnMutability
data NestedObjectInfo b
NestedObjectInfo :: XNestedObjects b -> Column b -> Name -> LogicalModelName -> Bool -> Maybe Description -> ColumnMutability -> NestedObjectInfo b
[_noiSupportsNestedObjects] :: NestedObjectInfo b -> XNestedObjects b
[_noiColumn] :: NestedObjectInfo b -> Column b
[_noiName] :: NestedObjectInfo b -> Name
[_noiType] :: NestedObjectInfo b -> LogicalModelName
[_noiIsNullable] :: NestedObjectInfo b -> Bool
[_noiDescription] :: NestedObjectInfo b -> Maybe Description
[_noiMutability] :: NestedObjectInfo b -> ColumnMutability
data NestedArrayInfo b
NestedArrayInfo :: XNestedObjects b -> Bool -> StructuredColumnInfo b -> NestedArrayInfo b
[_naiSupportsNestedArrays] :: NestedArrayInfo b -> XNestedObjects b
[_naiIsNullable] :: NestedArrayInfo b -> Bool
[_naiColumnInfo] :: NestedArrayInfo b -> StructuredColumnInfo b
data StructuredColumnInfo b
SCIScalarColumn :: ColumnInfo b -> StructuredColumnInfo b
SCIObjectColumn :: NestedObjectInfo b -> StructuredColumnInfo b
SCIArrayColumn :: NestedArrayInfo b -> StructuredColumnInfo b
structuredColumnInfoName :: StructuredColumnInfo b -> Name
structuredColumnInfoColumn :: StructuredColumnInfo b -> Column b
structuredColumnInfoMutability :: StructuredColumnInfo b -> ColumnMutability
toScalarColumnInfo :: StructuredColumnInfo b -> Maybe (ColumnInfo b)
_SCIArrayColumn :: forall b_a5bkj. Prism' (StructuredColumnInfo b_a5bkj) (NestedArrayInfo b_a5bkj)
_SCIObjectColumn :: forall b_a5bkj. Prism' (StructuredColumnInfo b_a5bkj) (NestedObjectInfo b_a5bkj)
_SCIScalarColumn :: forall b_a5bkj. Prism' (StructuredColumnInfo b_a5bkj) (ColumnInfo b_a5bkj)
type PrimaryKeyColumns b = NESeq (ColumnInfo b)
onlyNumCols :: forall b. Backend b => [ColumnInfo b] -> [ColumnInfo b]
isNumCol :: forall b. Backend b => ColumnInfo b -> Bool
onlyComparableCols :: forall b. Backend b => [ColumnInfo b] -> [ColumnInfo b]
isComparableCol :: forall b. Backend b => ColumnInfo b -> Bool
getColInfos :: Backend b => [Column b] -> [ColumnInfo b] -> [ColumnInfo b]
fromCol :: Backend b => Column b -> FieldName
type ColumnValues b a = HashMap (Column b) a

-- | Represents a reference to a source column, possibly casted an
--   arbitrary number of times. Used within <tt>parseBoolExpOperations</tt>
--   for bookkeeping.
data ColumnReference (b :: BackendType)
ColumnReferenceColumn :: ColumnInfo b -> ColumnReference (b :: BackendType)
ColumnReferenceComputedField :: ComputedFieldName -> ScalarType b -> ColumnReference (b :: BackendType)
ColumnReferenceCast :: ColumnReference b -> ColumnType b -> ColumnReference (b :: BackendType)

-- | Whether the column referred to might be null. Currently we can only
--   tell for references that refer to proper relation columns.
columnReferenceNullable :: ColumnReference (b :: BackendType) -> Maybe Bool
columnReferenceType :: ColumnReference backend -> ColumnType backend
instance Hasura.RQL.Types.Backend.Backend b => Data.Text.Extended.ToTxt (Hasura.RQL.Types.Column.ColumnReference b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.RawColumnType b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.RawColumnType b)
instance GHC.Show.Show Hasura.RQL.Types.Column.ColumnMutability
instance GHC.Generics.Generic Hasura.RQL.Types.Column.ColumnMutability
instance GHC.Classes.Ord Hasura.RQL.Types.Column.ColumnMutability
instance GHC.Classes.Eq Hasura.RQL.Types.Column.ColumnMutability
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.RawColumnInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.ColumnInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.ColumnValue b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.ColumnValue b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.NestedArrayInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.StructuredColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.NestedObjectInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.ColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Column.RawColumnInfo b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Column.ColumnMutability
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Column.ColumnMutability
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Column.ColumnMutability
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Column.ColumnMutability
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Column.RawColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Text.Extended.ToTxt (Hasura.RQL.Types.Column.ColumnType b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.EnumReference b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.ColumnType b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Column.EnumReference b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Column.EnumReference b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Column.EnumValueInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Column.EnumValueInfo
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Column.EnumValue
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Column.EnumValue
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Column.EnumValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Column.EnumValue
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Column.EnumValue
instance Control.DeepSeq.NFData Hasura.RQL.Types.Column.EnumValue
instance GHC.Generics.Generic Hasura.RQL.Types.Column.EnumValue
instance GHC.Classes.Ord Hasura.RQL.Types.Column.EnumValue
instance GHC.Classes.Eq Hasura.RQL.Types.Column.EnumValue
instance GHC.Show.Show Hasura.RQL.Types.Column.EnumValue
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Column.EnumValueInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.Column.EnumValueInfo
instance GHC.Generics.Generic Hasura.RQL.Types.Column.EnumValueInfo
instance GHC.Classes.Ord Hasura.RQL.Types.Column.EnumValueInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Column.EnumValueInfo
instance GHC.Show.Show Hasura.RQL.Types.Column.EnumValueInfo

module Hasura.RQL.Types.Source.Column
data SourceColumnInfo b
SourceColumnInfo :: Column b -> RawColumnType b -> Bool -> Maybe Text -> Bool -> Bool -> Maybe ColumnValueGenerationStrategy -> SourceColumnInfo b
[_sciName] :: SourceColumnInfo b -> Column b
[_sciType] :: SourceColumnInfo b -> RawColumnType b
[_sciNullable] :: SourceColumnInfo b -> Bool
[_sciDescription] :: SourceColumnInfo b -> Maybe Text
[_sciInsertable] :: SourceColumnInfo b -> Bool
[_sciUpdatable] :: SourceColumnInfo b -> Bool
[_sciValueGenerated] :: SourceColumnInfo b -> Maybe ColumnValueGenerationStrategy
data ColumnValueGenerationStrategy
AutoIncrement :: ColumnValueGenerationStrategy
UniqueIdentifier :: ColumnValueGenerationStrategy
DefaultValue :: ColumnValueGenerationStrategy
sciValueGenerated :: forall b_a5xwY. Lens' (SourceColumnInfo b_a5xwY) (Maybe ColumnValueGenerationStrategy)
sciUpdatable :: forall b_a5xwY. Lens' (SourceColumnInfo b_a5xwY) Bool
sciType :: forall b_a5xwY. Lens' (SourceColumnInfo b_a5xwY) (RawColumnType b_a5xwY)
sciNullable :: forall b_a5xwY. Lens' (SourceColumnInfo b_a5xwY) Bool
sciName :: forall b_a5xwY. Lens' (SourceColumnInfo b_a5xwY) (Column b_a5xwY)
sciInsertable :: forall b_a5xwY. Lens' (SourceColumnInfo b_a5xwY) Bool
sciDescription :: forall b_a5xwY. Lens' (SourceColumnInfo b_a5xwY) (Maybe Text)
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Control.DeepSeq.NFData Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance GHC.Generics.Generic Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance GHC.Show.Show Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance GHC.Classes.Ord Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance GHC.Classes.Eq Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Source.Column.SourceColumnInfo b)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Source.Column.ColumnValueGenerationStrategy


-- | Common types shared between similar logical model resolvers.
module Hasura.LogicalModelResolver.Types

-- | A name of an argument to a native query or stored procedure.
newtype ArgumentName
ArgumentName :: Text -> ArgumentName
[getArgumentName] :: ArgumentName -> Text
instance GHC.Generics.Generic Hasura.LogicalModelResolver.Types.ArgumentName
instance Data.Hashable.Class.Hashable Hasura.LogicalModelResolver.Types.ArgumentName
instance GHC.Show.Show Hasura.LogicalModelResolver.Types.ArgumentName
instance GHC.Classes.Ord Hasura.LogicalModelResolver.Types.ArgumentName
instance GHC.Classes.Eq Hasura.LogicalModelResolver.Types.ArgumentName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.LogicalModelResolver.Types.ArgumentName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.LogicalModelResolver.Types.ArgumentName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.LogicalModelResolver.Types.ArgumentName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.LogicalModelResolver.Types.ArgumentName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.LogicalModelResolver.Types.ArgumentName
instance Autodocodec.Class.HasCodec Hasura.LogicalModelResolver.Types.ArgumentName
instance Control.DeepSeq.NFData Hasura.LogicalModelResolver.Types.ArgumentName


-- | Parser and prettyprinter for native query code.
module Hasura.NativeQuery.InterpolatedQuery

-- | A component of an interpolated query
data InterpolatedItem variable

-- | normal text
IIText :: Text -> InterpolatedItem variable

-- | a captured variable
IIVariable :: variable -> InterpolatedItem variable

-- | A list of stored procedure components representing a single stored
--   procedure, separating the variables from the text.
newtype InterpolatedQuery variable
InterpolatedQuery :: [InterpolatedItem variable] -> InterpolatedQuery variable
[getInterpolatedQuery] :: InterpolatedQuery variable -> [InterpolatedItem variable]
ppInterpolatedQuery :: InterpolatedQuery ArgumentName -> Text

-- | extract all of the `{{ variable }}` inside our query string
parseInterpolatedQuery :: Text -> Either Text (InterpolatedQuery ArgumentName)

-- | Get a set of all arguments used in an interpolated query.
getUniqueVariables :: Ord var => InterpolatedQuery var -> Set var

-- | Remove spaces and semicolon from the end of a query and add a newline,
--   for sql backends.
trimQueryEnd :: InterpolatedQuery var -> InterpolatedQuery var
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.NativeQuery.InterpolatedQuery.RawQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.NativeQuery.InterpolatedQuery.RawQuery
instance GHC.Show.Show Hasura.NativeQuery.InterpolatedQuery.RawQuery
instance GHC.Classes.Ord Hasura.NativeQuery.InterpolatedQuery.RawQuery
instance GHC.Classes.Eq Hasura.NativeQuery.InterpolatedQuery.RawQuery
instance Data.Traversable.Traversable Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem
instance Language.Haskell.TH.Syntax.Lift variable => Language.Haskell.TH.Syntax.Lift (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance GHC.Generics.Generic (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance Data.Data.Data variable => Data.Data.Data (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance Data.Foldable.Foldable Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem
instance GHC.Base.Functor Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem
instance GHC.Show.Show variable => GHC.Show.Show (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance GHC.Classes.Ord variable => GHC.Classes.Ord (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance GHC.Classes.Eq variable => GHC.Classes.Eq (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance Data.Traversable.Traversable Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery
instance Language.Haskell.TH.Syntax.Lift variable => Language.Haskell.TH.Syntax.Lift (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance Data.Foldable.Foldable Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery
instance GHC.Base.Functor Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery
instance Data.Data.Data variable => Data.Data.Data (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance GHC.Generics.Generic (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance GHC.Show.Show variable => GHC.Show.Show (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance GHC.Classes.Ord variable => GHC.Classes.Ord (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance GHC.Classes.Eq variable => GHC.Classes.Eq (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance Data.Hashable.Class.Hashable variable => Data.Hashable.Class.Hashable (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance Control.DeepSeq.NFData variable => Control.DeepSeq.NFData (Hasura.NativeQuery.InterpolatedQuery.InterpolatedItem variable)
instance Data.Hashable.Class.Hashable variable => Data.Hashable.Class.Hashable (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance Control.DeepSeq.NFData variable => Control.DeepSeq.NFData (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery variable)
instance (v GHC.Types.~ Hasura.LogicalModelResolver.Types.ArgumentName) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery v)
instance (v GHC.Types.~ Hasura.LogicalModelResolver.Types.ArgumentName) => Autodocodec.Class.HasCodec (Hasura.NativeQuery.InterpolatedQuery.InterpolatedQuery v)
instance Autodocodec.Class.HasCodec Hasura.NativeQuery.InterpolatedQuery.RawQuery

module Hasura.LogicalModel.IR

-- | Description of a logical model for use in IR
data LogicalModel (b :: BackendType)
LogicalModel :: LogicalModelName -> InsOrdHashMap (Column b) (LogicalModelField b) -> LogicalModel (b :: BackendType)
[lmName] :: LogicalModel (b :: BackendType) -> LogicalModelName
[lmFields] :: LogicalModel (b :: BackendType) -> InsOrdHashMap (Column b) (LogicalModelField b)
instance GHC.Generics.Generic (Hasura.LogicalModel.IR.LogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.IR.LogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.LogicalModel.IR.LogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.IR.LogicalModel b)


-- | types and helpers for user-defined-functions after they have been
--   resolved in the schema cache
module Hasura.Function.Cache

-- | <a>https://www.postgresql.org/docs/current/xfunc-volatility.html</a>
data FunctionVolatility
FTVOLATILE :: FunctionVolatility
FTIMMUTABLE :: FunctionVolatility
FTSTABLE :: FunctionVolatility
funcTypToTxt :: FunctionVolatility -> Text
newtype FunctionArgName
FunctionArgName :: Text -> FunctionArgName
[getFuncArgNameTxt] :: FunctionArgName -> Text
data InputArgument a
IAUserProvided :: a -> InputArgument a
IASessionVariables :: FunctionArgName -> InputArgument a
type FunctionInputArgument b = InputArgument (FunctionArgument b)

-- | Indicates whether the user requested the corresponding function to be
--   tracked as a mutation or a query/subscription, in
--   <tt>track_function</tt>.
data FunctionExposedAs
FEAQuery :: FunctionExposedAs
FEAMutation :: FunctionExposedAs
newtype FunctionPermissionInfo
FunctionPermissionInfo :: RoleName -> FunctionPermissionInfo
[_fpmRole] :: FunctionPermissionInfo -> RoleName
type FunctionPermissionsMap = HashMap RoleName FunctionPermissionInfo

-- | Custom root fields for functions. When set, will be the names exposed
--   to the user in the schema.
--   
--   See rfcs/function-root-field-customisation.md for more information.
data FunctionCustomRootFields
FunctionCustomRootFields :: Maybe Name -> Maybe Name -> FunctionCustomRootFields
[_fcrfFunction] :: FunctionCustomRootFields -> Maybe Name
[_fcrfFunctionAggregate] :: FunctionCustomRootFields -> Maybe Name

-- | A function custom root fields without custom names set. This is the
--   default.
emptyFunctionCustomRootFields :: FunctionCustomRootFields

-- | Tracked SQL function metadata. See <tt>buildFunctionInfo</tt>.
data FunctionInfo (b :: BackendType)
FunctionInfo :: FunctionName b -> Name -> Name -> Name -> SystemDefined -> FunctionVolatility -> FunctionExposedAs -> Seq (FunctionInputArgument b) -> TableName b -> Maybe Text -> FunctionPermissionsMap -> JsonAggSelect -> Maybe Text -> FunctionInfo (b :: BackendType)
[_fiSQLName] :: FunctionInfo (b :: BackendType) -> FunctionName b
[_fiGQLName] :: FunctionInfo (b :: BackendType) -> Name
[_fiGQLArgsName] :: FunctionInfo (b :: BackendType) -> Name
[_fiGQLAggregateName] :: FunctionInfo (b :: BackendType) -> Name
[_fiSystemDefined] :: FunctionInfo (b :: BackendType) -> SystemDefined
[_fiVolatility] :: FunctionInfo (b :: BackendType) -> FunctionVolatility

-- | In which part of the schema should this function be exposed?
--   
--   See <tt>mkFunctionInfo</tt> and <a>_fcExposedAs</a>.
[_fiExposedAs] :: FunctionInfo (b :: BackendType) -> FunctionExposedAs
[_fiInputArgs] :: FunctionInfo (b :: BackendType) -> Seq (FunctionInputArgument b)

-- | NOTE: when a table is created, a new composite type of the same name
--   is automatically created; so strictly speaking this field means "the
--   function returns the composite type corresponding to this table".
[_fiReturnType] :: FunctionInfo (b :: BackendType) -> TableName b

-- | this field represents the description of the function as present on
--   the database
[_fiDescription] :: FunctionInfo (b :: BackendType) -> Maybe Text

-- | Roles to which the function is accessible
[_fiPermissions] :: FunctionInfo (b :: BackendType) -> FunctionPermissionsMap
[_fiJsonAggSelect] :: FunctionInfo (b :: BackendType) -> JsonAggSelect
[_fiComment] :: FunctionInfo (b :: BackendType) -> Maybe Text
type FunctionCache b = HashMap (FunctionName b) (FunctionInfo b)
data TrackableFunctionInfo b
TrackableFunctionInfo :: FunctionName b -> FunctionVolatility -> TrackableFunctionInfo b
[tfiFunctionName] :: TrackableFunctionInfo b -> FunctionName b
[tfiFunctionVolitility] :: TrackableFunctionInfo b -> FunctionVolatility
newtype TrackableTableInfo b
TrackableTableInfo :: TableName b -> TrackableTableInfo b
[tfTableiName] :: TrackableTableInfo b -> TableName b
data TrackableInfo b
TrackableInfo :: [TrackableFunctionInfo b] -> [TrackableTableInfo b] -> TrackableInfo b
[trackableFunctions] :: TrackableInfo b -> [TrackableFunctionInfo b]
[trackableTables] :: TrackableInfo b -> [TrackableTableInfo b]

-- | Tracked function configuration, and payload of the
--   <tt>pg_track_function</tt> and <tt>pg_set_function_customization</tt>
--   API calls.
data FunctionConfig b
FunctionConfig :: Maybe FunctionArgName -> Maybe FunctionExposedAs -> FunctionCustomRootFields -> Maybe Name -> Maybe (FunctionReturnType b) -> FunctionConfig b
[_fcSessionArgument] :: FunctionConfig b -> Maybe FunctionArgName

-- | In which top-level field should we expose this function?
--   
--   The user might omit this, in which case we'll infer the location from
--   the SQL functions volatility. See <tt>mkFunctionInfo</tt> or the
--   <tt>track_function</tt> API docs for details of validation, etc.
[_fcExposedAs] :: FunctionConfig b -> Maybe FunctionExposedAs
[_fcCustomRootFields] :: FunctionConfig b -> FunctionCustomRootFields
[_fcCustomName] :: FunctionConfig b -> Maybe Name
[_fcResponse] :: FunctionConfig b -> Maybe (FunctionReturnType b)

-- | The default function config; v1 of the API implies this.
emptyFunctionConfig :: FunctionConfig b
type DBFunctionsMetadata b = HashMap (FunctionName b) (FunctionOverloads b)
newtype FunctionOverloads b
FunctionOverloads :: NonEmpty (RawFunctionInfo b) -> FunctionOverloads b
[getFunctionOverloads] :: FunctionOverloads b -> NonEmpty (RawFunctionInfo b)
data FunctionArgsExpG a
FunctionArgsExp :: [a] -> HashMap Text a -> FunctionArgsExpG a
[_faePositional] :: FunctionArgsExpG a -> [a]
[_faeNamed] :: FunctionArgsExpG a -> HashMap Text a
type FunctionArgsExp b v = FunctionArgsExpG (FunctionArgumentExp b v)
emptyFunctionArgsExp :: FunctionArgsExpG a
instance GHC.Generics.Generic Hasura.Function.Cache.FunctionVolatility
instance GHC.Classes.Eq Hasura.Function.Cache.FunctionVolatility
instance Data.Data.Data Hasura.Function.Cache.FunctionArgName
instance Language.Haskell.TH.Syntax.Lift Hasura.Function.Cache.FunctionArgName
instance Data.Hashable.Class.Hashable Hasura.Function.Cache.FunctionArgName
instance GHC.Generics.Generic Hasura.Function.Cache.FunctionArgName
instance Data.String.IsString Hasura.Function.Cache.FunctionArgName
instance Data.Text.Extended.ToTxt Hasura.Function.Cache.FunctionArgName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Function.Cache.FunctionArgName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Function.Cache.FunctionArgName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Function.Cache.FunctionArgName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Function.Cache.FunctionArgName
instance Control.DeepSeq.NFData Hasura.Function.Cache.FunctionArgName
instance GHC.Classes.Ord Hasura.Function.Cache.FunctionArgName
instance GHC.Classes.Eq Hasura.Function.Cache.FunctionArgName
instance GHC.Show.Show Hasura.Function.Cache.FunctionArgName
instance GHC.Generics.Generic (Hasura.Function.Cache.InputArgument a)
instance GHC.Base.Functor Hasura.Function.Cache.InputArgument
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Function.Cache.InputArgument a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Function.Cache.InputArgument a)
instance GHC.Generics.Generic Hasura.Function.Cache.FunctionExposedAs
instance GHC.Classes.Eq Hasura.Function.Cache.FunctionExposedAs
instance GHC.Show.Show Hasura.Function.Cache.FunctionExposedAs
instance GHC.Generics.Generic Hasura.Function.Cache.FunctionPermissionInfo
instance GHC.Classes.Eq Hasura.Function.Cache.FunctionPermissionInfo
instance GHC.Show.Show Hasura.Function.Cache.FunctionPermissionInfo
instance GHC.Generics.Generic Hasura.Function.Cache.FunctionCustomRootFields
instance GHC.Classes.Eq Hasura.Function.Cache.FunctionCustomRootFields
instance GHC.Show.Show Hasura.Function.Cache.FunctionCustomRootFields
instance GHC.Generics.Generic (Hasura.Function.Cache.FunctionInfo b)
instance GHC.Generics.Generic (Hasura.Function.Cache.TrackableFunctionInfo b)
instance GHC.Generics.Generic (Hasura.Function.Cache.TrackableTableInfo b)
instance GHC.Generics.Generic (Hasura.Function.Cache.TrackableInfo b)
instance GHC.Generics.Generic (Hasura.Function.Cache.FunctionConfig b)
instance GHC.Generics.Generic (Hasura.Function.Cache.FunctionArgsExpG a)
instance Data.Traversable.Traversable Hasura.Function.Cache.FunctionArgsExpG
instance Data.Foldable.Foldable Hasura.Function.Cache.FunctionArgsExpG
instance GHC.Base.Functor Hasura.Function.Cache.FunctionArgsExpG
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Function.Cache.FunctionArgsExpG a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Function.Cache.FunctionArgsExpG a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Function.Cache.FunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.FunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Function.Cache.TrackableFunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.TrackableFunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Function.Cache.TrackableTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.TrackableTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Function.Cache.TrackableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.TrackableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Function.Cache.FunctionConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.FunctionConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Cache.FunctionOverloads b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Function.Cache.FunctionOverloads b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Backend.RawFunctionInfo b) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.Cache.FunctionOverloads b)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Backend.RawFunctionInfo b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.FunctionOverloads b)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Function.Cache.FunctionArgsExpG a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Function.Cache.FunctionArgsExpG a)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Function.Cache.FunctionConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.Function.Cache.FunctionConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.Cache.FunctionConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.FunctionConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.TrackableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.TrackableTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.TrackableFunctionInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.FunctionInfo b)
instance Control.DeepSeq.NFData Hasura.Function.Cache.FunctionCustomRootFields
instance Autodocodec.Class.HasCodec Hasura.Function.Cache.FunctionCustomRootFields
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Function.Cache.FunctionCustomRootFields
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Function.Cache.FunctionCustomRootFields
instance Autodocodec.Class.HasCodec Hasura.Function.Cache.FunctionPermissionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Function.Cache.FunctionPermissionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Function.Cache.FunctionPermissionInfo
instance Control.DeepSeq.NFData Hasura.Function.Cache.FunctionExposedAs
instance Autodocodec.Class.HasCodec Hasura.Function.Cache.FunctionExposedAs
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Function.Cache.FunctionExposedAs
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Function.Cache.FunctionExposedAs
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.InputArgument a)
instance Autodocodec.Class.HasCodec Hasura.Function.Cache.FunctionArgName
instance Control.DeepSeq.NFData Hasura.Function.Cache.FunctionVolatility
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Function.Cache.FunctionVolatility
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Function.Cache.FunctionVolatility
instance GHC.Show.Show Hasura.Function.Cache.FunctionVolatility


-- | Types for storing user-defined-functions in metadata
module Hasura.Function.Metadata
data FunctionMetadata b
FunctionMetadata :: FunctionName b -> FunctionConfig b -> [FunctionPermissionInfo] -> Maybe Text -> FunctionMetadata b
[_fmFunction] :: FunctionMetadata b -> FunctionName b
[_fmConfiguration] :: FunctionMetadata b -> FunctionConfig b
[_fmPermissions] :: FunctionMetadata b -> [FunctionPermissionInfo]
[_fmComment] :: FunctionMetadata b -> Maybe Text
fmPermissions :: forall b_a5XbX. Lens' (FunctionMetadata b_a5XbX) [FunctionPermissionInfo]
fmFunction :: forall b_a5XbX. Lens' (FunctionMetadata b_a5XbX) (FunctionName b_a5XbX)
fmConfiguration :: forall b_a5XbX. Lens' (FunctionMetadata b_a5XbX) (FunctionConfig b_a5XbX)
fmComment :: forall b_a5XbX. Lens' (FunctionMetadata b_a5XbX) (Maybe Text)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.Metadata.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.Function.Metadata.FunctionMetadata b)
instance GHC.Generics.Generic (Hasura.Function.Metadata.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Function.Metadata.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.Metadata.FunctionMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Metadata.FunctionMetadata b)

module Hasura.Function.Lenses
_IASessionVariables :: forall a_i5ZiD. Prism' (InputArgument a_i5ZiD) FunctionArgName
_IAUserProvided :: forall a_a5ZiG a_i5ZiD. Prism (InputArgument a_a5ZiG) (InputArgument a_i5ZiD) a_a5ZiG a_i5ZiD
fpmRole :: Iso' FunctionPermissionInfo RoleName
fiVolatility :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) FunctionVolatility
fiSystemDefined :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) SystemDefined
fiSQLName :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) (FunctionName b_i5ZlC)
fiReturnType :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) (TableName b_i5ZlC)
fiPermissions :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) FunctionPermissionsMap
fiJsonAggSelect :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) JsonAggSelect
fiInputArgs :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) (Seq (FunctionInputArgument b_i5ZlC))
fiGQLName :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) Name
fiGQLArgsName :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) Name
fiGQLAggregateName :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) Name
fiExposedAs :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) FunctionExposedAs
fiDescription :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) (Maybe Text)
fiComment :: forall b_i5ZlC. Lens' (FunctionInfo b_i5ZlC) (Maybe Text)

module Hasura.Function.Common

-- | Apply function name customization to function arguments, as detailed
--   in 'rfcs/function-root-field-customisation.md'. We want the different
--   variations of a function (i.e. basic, aggregate) to share the same
--   type name for their arguments.
getFunctionArgsGQLName :: Name -> FunctionConfig b -> (Name -> Name) -> Name

-- | Apply function name customization to the basic function variation, as
--   detailed in 'rfcs/function-root-field-customisation.md'.
getFunctionGQLName :: Name -> FunctionConfig b -> (Name -> Name) -> Name

-- | Apply function name customization to the aggregate function variation,
--   as detailed in 'rfcs/function-root-field-customisation.md'.
getFunctionAggregateGQLName :: Name -> FunctionConfig b -> (Name -> Name) -> Name
getInputArgs :: FunctionInfo b -> Seq (FunctionArgument b)


-- | Postgres SQL Types
--   
--   Combinators and helpers for dealing with Postgres types such as
--   strings, numerals, geography and geometry, etc.
module Hasura.Backends.Postgres.SQL.Types
newtype Identifier
Identifier :: Text -> Identifier
[getIdenTxt] :: Identifier -> Text
class IsIdentifier a
toIdentifier :: IsIdentifier a => a -> Identifier

-- | The type of identifiers representing tabular values. While we are
--   transitioning away from <a>Identifier</a> we provisionally export the
--   value constructor.
newtype TableIdentifier
TableIdentifier :: Text -> TableIdentifier
[unTableIdentifier] :: TableIdentifier -> Text

-- | Temporary conversion function, to be removed once <a>Identifier</a>
--   has been entirely split into <a>TableIdentifier</a> and
--   <a>ColumnIdentifier</a>.
tableIdentifierToIdentifier :: TableIdentifier -> Identifier

-- | Temporary conversion function, to be removed once <a>Identifier</a>
--   has been entirely split into <a>TableIdentifier</a> and
--   <a>ColumnIdentifier</a>.
identifierToTableIdentifier :: Identifier -> TableIdentifier

-- | The type of identifiers representing scalar values
newtype ColumnIdentifier
ColumnIdentifier :: Text -> ColumnIdentifier
[unColumnIdentifier] :: ColumnIdentifier -> Text
pgFmtIdentifier :: Text -> Text
pgFmtLit :: Text -> Text
newtype TableName
TableName :: Text -> TableName
[getTableTxt] :: TableName -> Text
isView :: TableType -> Bool
newtype ConstraintName
ConstraintName :: Text -> ConstraintName
[getConstraintTxt] :: ConstraintName -> Text
newtype FunctionName
FunctionName :: Text -> FunctionName
[getFunctionTxt] :: FunctionName -> Text
newtype SchemaName
SchemaName :: Text -> SchemaName
[getSchemaTxt] :: SchemaName -> Text
publicSchema :: SchemaName
hdbCatalogSchema :: SchemaName
data QualifiedObject a
QualifiedObject :: SchemaName -> a -> QualifiedObject a
[qSchema] :: QualifiedObject a -> SchemaName
[qName] :: QualifiedObject a -> a
qualifiedObjectToText :: ToTxt a => QualifiedObject a -> Text
snakeCaseQualifiedObject :: ToTxt a => QualifiedObject a -> Text
getIdentifierQualifiedObject :: ToTxt a => QualifiedObject a -> Either QErr GQLNameIdentifier
namingConventionSupport :: SupportedNamingCase
qualifiedObjectToName :: (ToTxt a, MonadError QErr m) => QualifiedObject a -> m Name

-- | Represents a database table qualified with the schema name.
type QualifiedTable = QualifiedObject TableName
type QualifiedFunction = QualifiedObject FunctionName
newtype PGDescription
PGDescription :: Text -> PGDescription
[getPGDescription] :: PGDescription -> Text
data PGCol
unsafePGCol :: Text -> PGCol
showPGCols :: (Foldable t, Functor t) => t PGCol -> Text
data PGScalarType
PGSmallInt :: PGScalarType
PGInteger :: PGScalarType
PGBigInt :: PGScalarType
PGSerial :: PGScalarType
PGBigSerial :: PGScalarType
PGFloat :: PGScalarType
PGDouble :: PGScalarType
PGNumeric :: PGScalarType
PGMoney :: PGScalarType
PGBoolean :: PGScalarType
PGChar :: PGScalarType
PGVarchar :: PGScalarType
PGText :: PGScalarType
PGCitext :: PGScalarType
PGDate :: PGScalarType
PGTimeStamp :: PGScalarType
PGTimeStampTZ :: PGScalarType
PGTimeTZ :: PGScalarType
PGJSON :: PGScalarType
PGJSONB :: PGScalarType
PGGeometry :: PGScalarType
PGGeography :: PGScalarType
PGRaster :: PGScalarType
PGUUID :: PGScalarType
PGLtree :: PGScalarType
PGLquery :: PGScalarType
PGLtxtquery :: PGScalarType
PGArray :: PGScalarType -> PGScalarType
PGUnknown :: Text -> PGScalarType
PGCompositeScalar :: Text -> PGScalarType
PGEnumScalar :: Text -> PGScalarType
pgScalarTypeToText :: PGScalarType -> Text
textToPGScalarType :: Text -> PGScalarType
pgScalarTranslations :: [(Text, PGScalarType)]
isNumType :: PGScalarType -> Bool
stringTypes :: [PGScalarType]
isStringType :: PGScalarType -> Bool
isJSONType :: PGScalarType -> Bool
isComparableType :: PGScalarType -> Bool
isBigNum :: PGScalarType -> Bool
geoTypes :: [PGScalarType]
isGeoType :: PGScalarType -> Bool
data PGTypeKind
PGKindBase :: PGTypeKind
PGKindComposite :: PGTypeKind
PGKindDomain :: PGTypeKind
PGKindEnum :: PGTypeKind
PGKindRange :: PGTypeKind
PGKindPseudo :: PGTypeKind
PGKindUnknown :: Text -> PGTypeKind
data QualifiedPGType
QualifiedPGType :: SchemaName -> PGScalarType -> PGTypeKind -> QualifiedPGType
[_qptSchema] :: QualifiedPGType -> SchemaName
[_qptName] :: QualifiedPGType -> PGScalarType
[_qptType] :: QualifiedPGType -> PGTypeKind
isBaseType :: QualifiedPGType -> Bool
typeToTable :: QualifiedPGType -> QualifiedTable
mkFunctionArgScalarType :: QualifiedPGType -> PGScalarType

-- | Metadata describing SQL functions at the DB level, i.e. below the
--   GraphQL layer.
data PGRawFunctionInfo
PGRawFunctionInfo :: OID -> Bool -> FunctionVolatility -> SchemaName -> PGScalarType -> PGTypeKind -> Bool -> [QualifiedPGType] -> [FunctionArgName] -> Int -> Bool -> Maybe PGDescription -> PGRawFunctionInfo
[rfiOid] :: PGRawFunctionInfo -> OID
[rfiHasVariadic] :: PGRawFunctionInfo -> Bool
[rfiFunctionType] :: PGRawFunctionInfo -> FunctionVolatility
[rfiReturnTypeSchema] :: PGRawFunctionInfo -> SchemaName
[rfiReturnTypeName] :: PGRawFunctionInfo -> PGScalarType
[rfiReturnTypeType] :: PGRawFunctionInfo -> PGTypeKind
[rfiReturnsSet] :: PGRawFunctionInfo -> Bool
[rfiInputArgTypes] :: PGRawFunctionInfo -> [QualifiedPGType]
[rfiInputArgNames] :: PGRawFunctionInfo -> [FunctionArgName]
[rfiDefaultArgs] :: PGRawFunctionInfo -> Int
[rfiReturnsTable] :: PGRawFunctionInfo -> Bool
[rfiDescription] :: PGRawFunctionInfo -> Maybe PGDescription
mkScalarTypeName :: MonadError QErr m => NamingCase -> PGScalarType -> m Name
pgTypeOid :: PGScalarType -> Oid
data PGExtraTableMetadata
PGExtraTableMetadata :: SourceTableType -> PGExtraTableMetadata
[_petmTableType] :: PGExtraTableMetadata -> SourceTableType
instance GHC.Base.Semigroup Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.Identifier
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.Identifier
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.Identifier
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.Identifier
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.Identifier
instance GHC.Base.Semigroup Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance GHC.Base.Semigroup Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Data.String.IsString Hasura.Backends.Postgres.SQL.Types.TableName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.TableName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.TableName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.TableName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.TableType
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.FunctionName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.String.IsString Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.SchemaName
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Data.Data.Data a => Data.Data.Data (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Base.Functor Hasura.Backends.Postgres.SQL.Types.QualifiedObject
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGDescription
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.PGDescription
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.PGDescription
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGDescription
instance Data.String.IsString Hasura.Backends.Postgres.SQL.Types.PGCol
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.Postgres.SQL.Types.PGCol
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.PGCol
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGCol
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Data.Data Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance GHC.Classes.Ord Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGExtraTableMetadata
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGRawFunctionInfo
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.QualifiedPGType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGTypeKind
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.PGScalarType
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.SQL.Types.PGCol
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.PGCol
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.PGCol
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.PGCol
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.PGCol
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance (Autodocodec.Class.HasCodec a, Data.Typeable.Internal.Typeable a) => Autodocodec.Class.HasCodec (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance (Data.Aeson.Types.ToJSON.ToJSON a, Data.Text.Extended.ToTxt a) => Data.Aeson.Types.ToJSON.ToJSONKey (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Text.Extended.ToTxt a => Data.Text.Extended.ToTxt (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Text.Extended.ToTxt a => Hasura.Base.ToErrorValue.ToErrorValue (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Hasura.SQL.Types.ToSQL a => Hasura.SQL.Types.ToSQL (Hasura.Backends.Postgres.SQL.Types.QualifiedObject a)
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.SchemaName
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.FunctionName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.Postgres.SQL.Types.ConstraintName
instance Database.PG.Query.Class.FromCol Hasura.Backends.Postgres.SQL.Types.TableType
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.SQL.Types.TableName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.TableName
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.SQL.Types.TableName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.TableName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.ColumnIdentifier
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.TableIdentifier
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.Types.Identifier
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.RQL.Types.ComputedField.Name.ComputedFieldName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.RQL.Types.Common.RelName
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.RQL.Types.Common.FieldName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.Types.Identifier


module Hasura.RQL.Types.ComputedField
data FunctionTrackedAs (b :: BackendType)
FTAComputedField :: ComputedFieldName -> SourceName -> TableName b -> FunctionTrackedAs (b :: BackendType)
FTACustomFunction :: CustomFunctionNames -> FunctionTrackedAs (b :: BackendType)

-- | The function name and input arguments name for the "args" field
--   parser.
--   
--   <pre>
--   function_name(args: args_name)
--   </pre>
data CustomFunctionNames
CustomFunctionNames :: Name -> Name -> CustomFunctionNames
[cfnFunctionName] :: CustomFunctionNames -> Name
[cfnArgsName] :: CustomFunctionNames -> Name
data ComputedFieldFunction (b :: BackendType)
ComputedFieldFunction :: FunctionName b -> Seq (FunctionArgument b) -> ComputedFieldImplicitArguments b -> Maybe PGDescription -> ComputedFieldFunction (b :: BackendType)
[_cffName] :: ComputedFieldFunction (b :: BackendType) -> FunctionName b
[_cffInputArgs] :: ComputedFieldFunction (b :: BackendType) -> Seq (FunctionArgument b)
[_cffComputedFieldImplicitArgs] :: ComputedFieldFunction (b :: BackendType) -> ComputedFieldImplicitArguments b
[_cffDescription] :: ComputedFieldFunction (b :: BackendType) -> Maybe PGDescription
data ComputedFieldInfo (b :: BackendType)
ComputedFieldInfo :: XComputedField b -> ComputedFieldName -> ComputedFieldFunction b -> ComputedFieldReturn b -> Maybe Text -> ComputedFieldInfo (b :: BackendType)
[_cfiXComputedFieldInfo] :: ComputedFieldInfo (b :: BackendType) -> XComputedField b
[_cfiName] :: ComputedFieldInfo (b :: BackendType) -> ComputedFieldName
[_cfiFunction] :: ComputedFieldInfo (b :: BackendType) -> ComputedFieldFunction b
[_cfiReturnType] :: ComputedFieldInfo (b :: BackendType) -> ComputedFieldReturn b
[_cfiDescription] :: ComputedFieldInfo (b :: BackendType) -> Maybe Text

-- | Return all the computed fields in the given list that have numeric
--   types.
onlyNumComputedFields :: forall b. Backend b => [ComputedFieldInfo b] -> [ComputedFieldInfo b]

-- | Check whether a computed field has a numeric type.
isNumComputedField :: forall b. Backend b => ComputedFieldInfo b -> Bool

-- | Return all the computed fields in the given list that have numeric
--   types.
onlyComparableComputedFields :: forall b. Backend b => [ComputedFieldInfo b] -> [ComputedFieldInfo b]

-- | Check whether a computed field has a numeric type.
isComparableComputedField :: forall b. Backend b => ComputedFieldInfo b -> Bool
cfiXComputedFieldInfo :: forall b_a6m6H. Lens' (ComputedFieldInfo b_a6m6H) (XComputedField b_a6m6H)
cfiReturnType :: forall b_a6m6H. Lens' (ComputedFieldInfo b_a6m6H) (ComputedFieldReturn b_a6m6H)
cfiName :: forall b_a6m6H. Lens' (ComputedFieldInfo b_a6m6H) ComputedFieldName
cfiFunction :: forall b_a6m6H. Lens' (ComputedFieldInfo b_a6m6H) (ComputedFieldFunction b_a6m6H)
cfiDescription :: forall b_a6m6H. Lens' (ComputedFieldInfo b_a6m6H) (Maybe Text)

-- | Filter computed fields not returning rows of existing table
removeComputedFieldsReturningExistingTable :: forall backend. Backend backend => [ComputedFieldInfo backend] -> [ComputedFieldInfo backend]
instance GHC.Generics.Generic Hasura.RQL.Types.ComputedField.CustomFunctionNames
instance GHC.Classes.Eq Hasura.RQL.Types.ComputedField.CustomFunctionNames
instance GHC.Show.Show Hasura.RQL.Types.ComputedField.CustomFunctionNames
instance GHC.Generics.Generic (Hasura.RQL.Types.ComputedField.FunctionTrackedAs b)
instance GHC.Generics.Generic (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance GHC.Generics.Generic (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.ComputedField.FunctionTrackedAs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.ComputedField.FunctionTrackedAs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.ComputedField.ComputedFieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.ComputedField.ComputedFieldFunction b)


-- | Postgres Types Functions
--   
--   Postgres specific types related to SQL functions
module Hasura.Backends.Postgres.Types.Function
newtype HasDefault
HasDefault :: Bool -> HasDefault
[unHasDefault] :: HasDefault -> Bool
data FunctionArg
FunctionArg :: Maybe FunctionArgName -> QualifiedPGType -> HasDefault -> FunctionArg
[faName] :: FunctionArg -> Maybe FunctionArgName
[faType] :: FunctionArg -> QualifiedPGType
[faHasDefault] :: FunctionArg -> HasDefault
data ArgumentExp a

-- | Table row accessor
AETableRow :: ArgumentExp a

-- | Hardcoded reference to
--   <tt>hdb_catalog.hdb_action_log.response_payload</tt>
AEActionResponsePayload :: ArgumentExp a

-- | JSON/JSONB hasura session variable object
AESession :: a -> ArgumentExp a
AEInput :: a -> ArgumentExp a

-- | Eliminate <a>ArgumentExp</a>
--   
--   Used to ensure that the right column is used for
--   <a>AEActionResponsePayload</a>.
onArgumentExp :: a -> (Text -> a) -> ArgumentExp a -> a

-- | Hardcoded <tt>hdb_catalog.hdb_action_log.response_payload</tt> column
--   name
actionResponsePayloadColumn :: Text
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.Function.HasDefault
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.Function.HasDefault
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Show.Show Hasura.Backends.Postgres.Types.Function.HasDefault
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.Function.FunctionArg
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.Function.FunctionArg
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.Function.FunctionArg
instance GHC.Show.Show Hasura.Backends.Postgres.Types.Function.FunctionArg
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance Data.Traversable.Traversable Hasura.Backends.Postgres.Types.Function.ArgumentExp
instance Data.Foldable.Foldable Hasura.Backends.Postgres.Types.Function.ArgumentExp
instance GHC.Base.Functor Hasura.Backends.Postgres.Types.Function.ArgumentExp
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.Types.Function.ArgumentExp a)
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.Function.FunctionArg
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.Function.FunctionArg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.Function.FunctionArg


-- | Postgres types related to computed fields
module Hasura.Backends.Postgres.Types.ComputedField
data ComputedFieldDefinition
ComputedFieldDefinition :: QualifiedFunction -> Maybe FunctionArgName -> Maybe FunctionArgName -> ComputedFieldDefinition
[_cfdFunction] :: ComputedFieldDefinition -> QualifiedFunction
[_cfdTableArgument] :: ComputedFieldDefinition -> Maybe FunctionArgName
[_cfdSessionArgument] :: ComputedFieldDefinition -> Maybe FunctionArgName

-- | The function table argument is either the very first argument or the
--   named argument with an index. The index is 0 if the named argument is
--   the first.
data FunctionTableArgument
FTAFirst :: FunctionTableArgument
FTANamed :: FunctionArgName -> Int -> FunctionTableArgument

-- | The session argument, which passes Hasura session variables to a SQL
--   function as a JSON object.
data FunctionSessionArgument
FunctionSessionArgument :: FunctionArgName -> Int -> FunctionSessionArgument
data ComputedFieldImplicitArguments
ComputedFieldImplicitArguments :: FunctionTableArgument -> Maybe FunctionSessionArgument -> ComputedFieldImplicitArguments
[_cffaTableArgument] :: ComputedFieldImplicitArguments -> FunctionTableArgument
[_cffaSessionArgument] :: ComputedFieldImplicitArguments -> Maybe FunctionSessionArgument
fromComputedFieldImplicitArguments :: v -> ComputedFieldImplicitArguments -> [ArgumentExp v]
data ComputedFieldReturn
CFRScalar :: PGScalarType -> ComputedFieldReturn
CFRSetofTable :: QualifiedTable -> ComputedFieldReturn
_CFRSetofTable :: Prism' ComputedFieldReturn QualifiedTable
_CFRScalar :: Prism' ComputedFieldReturn PGScalarType
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance GHC.Show.Show Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance GHC.Show.Show Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance GHC.Show.Show Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance GHC.Show.Show Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance GHC.Classes.Ord Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance GHC.Show.Show Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldReturn
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldImplicitArguments
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.FunctionSessionArgument
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.FunctionTableArgument
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Autodocodec.Class.HasCodec Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Types.ComputedField.ComputedFieldDefinition

module Hasura.Server.Version
data Version
VersionDev :: Text -> Version
VersionRelease :: Version -> Version
VersionCE :: Text -> Version
currentVersion :: Version
versionToAssetsVersion :: Version -> Text

-- | A version-based string used to form the CDN URL for fetching console
--   assets.
consoleAssetsVersion :: Text
instance GHC.Classes.Eq Hasura.Server.Version.Version
instance GHC.Show.Show Hasura.Server.Version.Version
instance Data.Text.Conversions.ToText Hasura.Server.Version.Version
instance Data.Text.Conversions.FromText Hasura.Server.Version.Version
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Version.Version
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Version.Version

module Hasura.HTTP
hdrsToText :: [Header] -> [(Text, Text)]
textToHdrs :: [(Text, Text)] -> [Header]
wreqOptions :: Manager -> [Header] -> Options
addDefaultHeaders :: [Header] -> [Header]
defaultHeaders :: [Header]
newtype HttpException
HttpException :: HttpException -> HttpException
[unHttpException] :: HttpException -> HttpException
getHTTPExceptionStatus :: HttpException -> Maybe Int
serializeHTTPExceptionMessage :: HttpException -> Text
newtype ShowHeadersAndEnvVarInfo
ShowHeadersAndEnvVarInfo :: Bool -> ShowHeadersAndEnvVarInfo
[unShowHeadersAndEnvVarInfo] :: ShowHeadersAndEnvVarInfo -> Bool
serializeHTTPExceptionWithErrorMessage :: ShowHeadersAndEnvVarInfo -> HttpException -> Text
serializeHTTPExceptionMessageForDebugging :: HttpException -> Text
encodeHTTPRequestJSON :: Request -> Value
newtype ShowErrorInfo
ShowErrorInfo :: Bool -> ShowErrorInfo
[unShowErrorInfo] :: ShowErrorInfo -> Bool
getHttpExceptionJson :: ShowErrorInfo -> HttpException -> Value
data HttpResponse a
HttpResponse :: !a -> !ResponseHeaders -> HttpResponse a
[_hrBody] :: HttpResponse a -> !a
[_hrHeaders] :: HttpResponse a -> !ResponseHeaders
addHttpResponseHeaders :: ResponseHeaders -> HttpResponse a -> HttpResponse a
serializeServantClientErrorMessage :: ClientError -> Text
serializeServantClientErrorMessageForDebugging :: ClientError -> Text
instance GHC.Show.Show Hasura.HTTP.HttpException
instance GHC.Classes.Eq Hasura.HTTP.ShowHeadersAndEnvVarInfo
instance GHC.Show.Show Hasura.HTTP.ShowHeadersAndEnvVarInfo
instance GHC.Classes.Eq Hasura.HTTP.ShowErrorInfo
instance GHC.Show.Show Hasura.HTTP.ShowErrorInfo
instance Data.Traversable.Traversable Hasura.HTTP.HttpResponse
instance Data.Foldable.Foldable Hasura.HTTP.HttpResponse
instance GHC.Base.Functor Hasura.HTTP.HttpResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.HTTP.HttpException

module Hasura.Session

-- | Converts a <a>SessionVariable</a> value to a GraphQL name. This will
--   fail if the session variable contains characters that are not valid
--   for a graphql names. It is the caller's responsibility to decide what
--   to do in such a case.
sessionVariableToGraphQLName :: SessionVariable -> Maybe Name
filterSessionVariables :: (SessionVariable -> SessionVariableValue -> Bool) -> SessionVariables -> SessionVariables
mkSessionVariablesHeaders :: [Header] -> SessionVariables
sessionVariablesToHeaders :: SessionVariables -> [Header]
getSessionVariables :: SessionVariables -> [Text]
getSessionVariablesSet :: SessionVariables -> HashSet SessionVariable
getSessionVariableValue :: SessionVariable -> SessionVariables -> Maybe SessionVariableValue

-- | Represent the admin secret state; whether the secret is sent in the
--   request or if actually authorization is not configured.
data UserAdminSecret
UAdminSecretSent :: UserAdminSecret
UAdminSecretNotSent :: UserAdminSecret
UAuthNotSet :: UserAdminSecret
askCurRole :: UserInfoM m => m RoleName

-- | Build <tt><a>UserInfo</a> from </tt><a>SessionVariables</a>
mkUserInfo :: forall m. MonadError QErr m => UserRoleBuild -> UserAdminSecret -> SessionVariables -> m UserInfo
maybeRoleFromSessionVariables :: SessionVariables -> Maybe RoleName
adminUserInfo :: UserInfo
instance GHC.Classes.Eq Hasura.Session.UserAdminSecret
instance GHC.Show.Show Hasura.Session.UserAdminSecret

module Hasura.RemoteSchema.SchemaCache.Types
type RemoteSchemaRelationshipsG remoteFieldInfo = InsOrdHashMap Name (InsOrdHashMap RelName remoteFieldInfo)
data IntrospectionResult
IntrospectionResult :: RemoteSchemaIntrospection -> Name -> Maybe Name -> Maybe Name -> IntrospectionResult
[irDoc] :: IntrospectionResult -> RemoteSchemaIntrospection
[irQueryRoot] :: IntrospectionResult -> Name
[irMutationRoot] :: IntrospectionResult -> Maybe Name
[irSubscriptionRoot] :: IntrospectionResult -> Maybe Name

-- | The resolved information of a remote schema. It is parameterized by
--   <tt>remoteFieldInfo</tt> so as to work on an arbitrary 'remote
--   relationship' TODO: Get rid of this <tt>G</tt> suffix using pattern
--   synonyms or qualified usage
data RemoteSchemaCtxG remoteFieldInfo
RemoteSchemaCtx :: RemoteSchemaName -> IntrospectionResult -> RemoteSchemaInfo -> ByteString -> HashMap RoleName IntrospectionResult -> RemoteSchemaRelationshipsG remoteFieldInfo -> RemoteSchemaCtxG remoteFieldInfo
[_rscName] :: RemoteSchemaCtxG remoteFieldInfo -> RemoteSchemaName

-- | Original remote schema without customizations
[_rscIntroOriginal] :: RemoteSchemaCtxG remoteFieldInfo -> IntrospectionResult
[_rscInfo] :: RemoteSchemaCtxG remoteFieldInfo -> RemoteSchemaInfo

-- | The raw response from the introspection query against the remote
--   server. We store this so we can efficiently service
--   <tt>introspect_remote_schema</tt>.
[_rscRawIntrospectionResult] :: RemoteSchemaCtxG remoteFieldInfo -> ByteString
[_rscPermissions] :: RemoteSchemaCtxG remoteFieldInfo -> HashMap RoleName IntrospectionResult
[_rscRemoteRelationships] :: RemoteSchemaCtxG remoteFieldInfo -> RemoteSchemaRelationshipsG remoteFieldInfo

-- | Resolved information of a remote relationship with the local
--   information that we have. Currently this is only the typename on which
--   the relationship is defined. TODO: also add the available join fields
--   on the type
data PartiallyResolvedRemoteRelationship remoteRelationshipDefinition
PartiallyResolvedRemoteRelationship :: Name -> RemoteRelationshipG remoteRelationshipDefinition -> PartiallyResolvedRemoteRelationship remoteRelationshipDefinition
[_prrrTypeName] :: PartiallyResolvedRemoteRelationship remoteRelationshipDefinition -> Name
[_prrrDefinition] :: PartiallyResolvedRemoteRelationship remoteRelationshipDefinition -> RemoteRelationshipG remoteRelationshipDefinition

-- | We can't go from RemoteSchemaMetadata to RemoteSchemaCtx in a single
--   phase because we don't have information to resolve remote
--   relationships. So we annotate remote relationships with as much
--   information as we know about them which would be further resolved in a
--   later stage.
type PartiallyResolvedRemoteSchemaCtxG remoteRelationshipDefinition = RemoteSchemaCtxG (PartiallyResolvedRemoteRelationship remoteRelationshipDefinition)

-- | <a>RemoteSchemaDef</a> after validation and baking-in of defaults in
--   <a>validateRemoteSchemaDef</a>.
data ValidatedRemoteSchemaDef
ValidatedRemoteSchemaDef :: EnvRecord URI -> [HeaderConf] -> Bool -> Int -> Maybe RemoteSchemaCustomization -> ValidatedRemoteSchemaDef
[_vrsdUrl] :: ValidatedRemoteSchemaDef -> EnvRecord URI
[_vrsdHeaders] :: ValidatedRemoteSchemaDef -> [HeaderConf]
[_vrsdFwdClientHeaders] :: ValidatedRemoteSchemaDef -> Bool
[_vrsdTimeoutSeconds] :: ValidatedRemoteSchemaDef -> Int

-- | See <a>_rsdCustomization</a>.
[_vrsdCustomization] :: ValidatedRemoteSchemaDef -> Maybe RemoteSchemaCustomization
data RemoteSchemaCustomizer
RemoteSchemaCustomizer :: Maybe Name -> HashMap Name Name -> HashMap Name (HashMap Name Name) -> RemoteSchemaCustomizer
[_rscNamespaceFieldName] :: RemoteSchemaCustomizer -> Maybe Name

-- | type name -&gt; type name
[_rscCustomizeTypeName] :: RemoteSchemaCustomizer -> HashMap Name Name

-- | type name -&gt; field name -&gt; field name
[_rscCustomizeFieldName] :: RemoteSchemaCustomizer -> HashMap Name (HashMap Name Name)
identityCustomizer :: RemoteSchemaCustomizer
remoteSchemaCustomizeTypeName :: RemoteSchemaCustomizer -> MkTypename
newtype CustomizeRemoteFieldName
CustomizeRemoteFieldName :: (Name -> Name -> Name) -> CustomizeRemoteFieldName
[runCustomizeRemoteFieldName] :: CustomizeRemoteFieldName -> Name -> Name -> Name
withRemoteFieldNameCustomization :: forall m r a. (MonadReader r m, Has CustomizeRemoteFieldName r) => CustomizeRemoteFieldName -> m a -> m a
remoteSchemaCustomizeFieldName :: RemoteSchemaCustomizer -> CustomizeRemoteFieldName
hasTypeOrFieldCustomizations :: RemoteSchemaCustomizer -> Bool

-- | <a>RemoteSchemaDef</a> after the RemoteSchemaCustomizer has been
--   generated by fetchRemoteSchema
data RemoteSchemaInfo
RemoteSchemaInfo :: ValidatedRemoteSchemaDef -> RemoteSchemaCustomizer -> RemoteSchemaInfo
[rsDef] :: RemoteSchemaInfo -> ValidatedRemoteSchemaDef
[rsCustomizer] :: RemoteSchemaInfo -> RemoteSchemaCustomizer
validateRemoteSchemaCustomization :: MonadError QErr m => Maybe RemoteSchemaCustomization -> m ()
validateRemoteSchemaDef :: MonadError QErr m => Environment -> RemoteSchemaDef -> m ValidatedRemoteSchemaDef

-- | See <tt>resolveRemoteVariable</tt> function. This data type is used
--   for validation of the session variable value
data SessionArgumentPresetInfo
SessionArgumentPresetScalar :: SessionArgumentPresetInfo
SessionArgumentPresetEnum :: HashSet EnumValue -> SessionArgumentPresetInfo

-- | Details required to resolve a "session variable preset" variable.
--   
--   See Notes [Remote Schema Argument Presets] and [Remote Schema
--   Permissions Architecture] for additional information.
data RemoteSchemaVariable
SessionPresetVariable :: SessionVariable -> Name -> SessionArgumentPresetInfo -> RemoteSchemaVariable
QueryVariable :: Variable -> RemoteSchemaVariable
RemoteJSONValue :: GType -> Value -> RemoteSchemaVariable

-- | Extends <a>InputValueDefinition</a> with an optional preset argument.
--   
--   See Note [Remote Schema Argument Presets] for additional information.
data RemoteSchemaInputValueDefinition
RemoteSchemaInputValueDefinition :: InputValueDefinition -> Maybe (Value RemoteSchemaVariable) -> RemoteSchemaInputValueDefinition
[_rsitdDefinition] :: RemoteSchemaInputValueDefinition -> InputValueDefinition
[_rsitdPresetArgument] :: RemoteSchemaInputValueDefinition -> Maybe (Value RemoteSchemaVariable)
newtype RemoteSchemaIntrospection
RemoteSchemaIntrospection :: HashMap Name (TypeDefinition [Name] RemoteSchemaInputValueDefinition) -> RemoteSchemaIntrospection

-- | Extracts the name of a given type from its definition. TODO: move this
--   to Language.GraphQL.Draft.Syntax.
getTypeName :: TypeDefinition possibleTypes inputType -> Name
lookupType :: RemoteSchemaIntrospection -> Name -> Maybe (TypeDefinition [Name] RemoteSchemaInputValueDefinition)
lookupObject :: RemoteSchemaIntrospection -> Name -> Maybe (ObjectTypeDefinition RemoteSchemaInputValueDefinition)
lookupInterface :: RemoteSchemaIntrospection -> Name -> Maybe (InterfaceTypeDefinition [Name] RemoteSchemaInputValueDefinition)
lookupScalar :: RemoteSchemaIntrospection -> Name -> Maybe ScalarTypeDefinition
lookupUnion :: RemoteSchemaIntrospection -> Name -> Maybe UnionTypeDefinition
lookupEnum :: RemoteSchemaIntrospection -> Name -> Maybe EnumTypeDefinition
lookupInputObject :: RemoteSchemaIntrospection -> Name -> Maybe (InputObjectTypeDefinition RemoteSchemaInputValueDefinition)
newtype LHSIdentifier
LHSIdentifier :: Text -> LHSIdentifier
[getLHSIdentifier] :: LHSIdentifier -> Text
remoteSchemaToLHSIdentifier :: RemoteSchemaName -> LHSIdentifier

-- | Generates a valid graphql name from an arbitrary LHS identifier. This
--   is done by replacing all unrecognized characters by '_'. This function
--   still returns a <tt>Maybe</tt> value, in cases we can't adjust the raw
--   text (such as the case of empty identifiers).
lhsIdentifierToGraphQLName :: LHSIdentifier -> Maybe Name

-- | Schema cache information for a table field targeting a remote schema.
data RemoteSchemaFieldInfo
RemoteSchemaFieldInfo :: RelName -> HashMap Name RemoteSchemaInputValueDefinition -> RemoteFields -> RemoteSchemaInfo -> [TypeDefinition [Name] RemoteSchemaInputValueDefinition] -> RemoteSchemaName -> LHSIdentifier -> RemoteSchemaFieldInfo

-- | Field name to which we'll map the remote in hasura; this becomes part
--   of the hasura schema.
[_rrfiName] :: RemoteSchemaFieldInfo -> RelName

-- | Input arguments to the remote field info; The <tt>_rfiParamMap</tt>
--   will only include the arguments to the remote field that is being
--   joined. The names of the arguments here are modified, it will be in
--   the format of <a>Field Name</a>_remote_rel_<a>table
--   schema</a>_<a>table name</a><a>relationship name</a>
[_rrfiParamMap] :: RemoteSchemaFieldInfo -> HashMap Name RemoteSchemaInputValueDefinition
[_rrfiRemoteFields] :: RemoteSchemaFieldInfo -> RemoteFields
[_rrfiRemoteSchema] :: RemoteSchemaFieldInfo -> RemoteSchemaInfo

-- | The new input value definitions created for this remote field
[_rrfiInputValueDefinitions] :: RemoteSchemaFieldInfo -> [TypeDefinition [Name] RemoteSchemaInputValueDefinition]

-- | Name of the remote schema, that's used for joining
[_rrfiRemoteSchemaName] :: RemoteSchemaFieldInfo -> RemoteSchemaName

-- | TODO: this one should be gone when <tt>validateRemoteRelationship</tt>
--   function is cleaned up
[_rrfiLHSIdentifier] :: RemoteSchemaFieldInfo -> LHSIdentifier
graphQLValueToJSON :: Value Void -> Value
rscRemoteRelationships :: forall remoteFieldInfo_a6Cb5 remoteFieldInfo_a6Ena. Lens (RemoteSchemaCtxG remoteFieldInfo_a6Cb5) (RemoteSchemaCtxG remoteFieldInfo_a6Ena) (RemoteSchemaRelationshipsG remoteFieldInfo_a6Cb5) (RemoteSchemaRelationshipsG remoteFieldInfo_a6Ena)
rscRawIntrospectionResult :: forall remoteFieldInfo_a6Cb5. Lens' (RemoteSchemaCtxG remoteFieldInfo_a6Cb5) ByteString
rscPermissions :: forall remoteFieldInfo_a6Cb5. Lens' (RemoteSchemaCtxG remoteFieldInfo_a6Cb5) (HashMap RoleName IntrospectionResult)
rscName :: forall remoteFieldInfo_a6Cb5. Lens' (RemoteSchemaCtxG remoteFieldInfo_a6Cb5) RemoteSchemaName
rscIntroOriginal :: forall remoteFieldInfo_a6Cb5. Lens' (RemoteSchemaCtxG remoteFieldInfo_a6Cb5) IntrospectionResult
rscInfo :: forall remoteFieldInfo_a6Cb5. Lens' (RemoteSchemaCtxG remoteFieldInfo_a6Cb5) RemoteSchemaInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance Data.Aeson.Types.ToJSON.ToJSON remoteFieldInfo => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG remoteFieldInfo)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaFieldInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance GHC.Generics.Generic (Hasura.RemoteSchema.SchemaCache.Types.PartiallyResolvedRemoteRelationship remoteRelationshipDefinition)
instance GHC.Classes.Eq remoteRelationshipDefinition => GHC.Classes.Eq (Hasura.RemoteSchema.SchemaCache.Types.PartiallyResolvedRemoteRelationship remoteRelationshipDefinition)
instance GHC.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance GHC.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance GHC.Base.Monoid Hasura.RemoteSchema.SchemaCache.Types.CustomizeRemoteFieldName
instance GHC.Base.Semigroup Hasura.RemoteSchema.SchemaCache.Types.CustomizeRemoteFieldName
instance GHC.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance GHC.Classes.Ord Hasura.RemoteSchema.SchemaCache.Types.SessionArgumentPresetInfo
instance GHC.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.SessionArgumentPresetInfo
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.SessionArgumentPresetInfo
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Types.SessionArgumentPresetInfo
instance GHC.Classes.Ord Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaVariable
instance GHC.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaVariable
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaVariable
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaVariable
instance GHC.Classes.Ord Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance GHC.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance GHC.Classes.Ord Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance GHC.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance GHC.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.IntrospectionResult
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.IntrospectionResult
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Types.IntrospectionResult
instance Data.Traversable.Traversable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG
instance Data.Foldable.Foldable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG
instance GHC.Base.Functor Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG
instance GHC.Classes.Eq remoteFieldInfo => GHC.Classes.Eq (Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG remoteFieldInfo)
instance GHC.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.LHSIdentifier
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.LHSIdentifier
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Types.LHSIdentifier
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaFieldInfo
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaFieldInfo
instance GHC.Generics.Generic Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaFieldInfo
instance Witherable.Filterable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCtxG
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaVariable
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.SessionArgumentPresetInfo
instance Control.DeepSeq.NFData Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInfo
instance Control.DeepSeq.NFData Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaCustomizer
instance Control.DeepSeq.NFData Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef
instance Data.Hashable.Class.Hashable Hasura.RemoteSchema.SchemaCache.Types.ValidatedRemoteSchemaDef


-- | Validate input queries against remote schemas.
module Hasura.RemoteSchema.SchemaCache.RemoteRelationship
errorToText :: ValidationError -> Text

-- | Validate a remote schema relationship given a context.
validateToSchemaRelationship :: MonadError ValidationError m => ToSchemaRelationshipDef -> LHSIdentifier -> RelName -> (RemoteSchemaInfo, IntrospectionResult) -> HashMap FieldName joinField -> m (HashMap FieldName joinField, RemoteSchemaFieldInfo)
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.RemoteRelationship.ValidationError
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.RemoteRelationship.ValidationError


-- | Representation for queries going to remote schemas. Due to the
--   existence of remote relationships from remote schemas, we can't simply
--   reuse the GraphQL document AST we define in graphql-parser-hs, and
--   instead redefine a custom structure to represent such queries.
module Hasura.RQL.IR.RemoteSchema

-- | Custom representation of a selection set.
--   
--   Similarly to other parts of the IR, the <tt>r</tt> argument is used
--   for remote relationships.
data SelectionSet r var
SelectionSetObject :: ObjectSelectionSet r var -> SelectionSet r var
SelectionSetUnion :: DeduplicatedSelectionSet r var -> SelectionSet r var
SelectionSetInterface :: DeduplicatedSelectionSet r var -> SelectionSet r var
SelectionSetNone :: SelectionSet r var

-- | Representation of the normalized selection set of an interface/union
--   type.
--   
--   This representation is used to attempt to minimize the size of the
--   GraphQL query that eventually gets sent to the GraphQL server by
--   defining as many fields as possible on the abstract type.
data DeduplicatedSelectionSet r var
DeduplicatedSelectionSet :: HashSet Name -> HashMap Name (ObjectSelectionSet r var) -> DeduplicatedSelectionSet r var

-- | Fields that aren't explicitly defined for member types
[_dssCommonFields] :: DeduplicatedSelectionSet r var -> HashSet Name

-- | SelectionSets of individual member types
[_dssMemberSelectionSets] :: DeduplicatedSelectionSet r var -> HashMap Name (ObjectSelectionSet r var)
type ObjectSelectionSet r var = InsOrdHashMap Name (Field r var)

-- | Constructs an <tt>InterfaceSelectionSet</tt> from a set of interface
--   fields and an association list of the fields. This function ensures
--   that <tt>__typename</tt> is present in the set of interface fields.
mkInterfaceSelectionSet :: HashSet Name -> [(Name, ObjectSelectionSet r var)] -> DeduplicatedSelectionSet r var

-- | Constructs an <tt>UnionSelectionSet</tt> from a list of the fields,
--   using a singleton set of <tt>__typename</tt> for the set of common
--   fields.
mkUnionSelectionSet :: [(Name, ObjectSelectionSet r var)] -> DeduplicatedSelectionSet r var

-- | Representation of one individual field.
--   
--   This particular type is the reason why we need a different
--   representation from the one in 'graphql-parser-hs': we differentiate
--   between selection fields that target the actual remote schema, and
--   fields that, instead, are remote from it and need to be treated
--   differently.
data Field r var
FieldGraphQL :: GraphQLField r var -> Field r var
FieldRemote :: SchemaRemoteRelationshipSelect r -> Field r var

-- | Normalized representation of a GraphQL field.
--   
--   This type is almost identical to <a>Field</a>, except for the fact
--   that the selection set is our annotated <a>SelectionSet</a>, instead
--   of the original <a>SelectionSet</a>. We use this type to represent the
--   fields of a selection that do target the remote schema.
data GraphQLField r var
GraphQLField :: Name -> Name -> HashMap Name (Value var) -> [Directive var] -> SelectionSet r var -> GraphQLField r var
[_fAlias] :: GraphQLField r var -> Name
[_fName] :: GraphQLField r var -> Name
[_fArguments] :: GraphQLField r var -> HashMap Name (Value var)
[_fDirectives] :: GraphQLField r var -> [Directive var]
[_fSelectionSet] :: GraphQLField r var -> SelectionSet r var
mkGraphQLField :: Maybe Name -> Name -> HashMap Name (Value var) -> [Directive var] -> SelectionSet r var -> GraphQLField r var

-- | Root entry point for a remote schema.
data RemoteSchemaRootField r var
RemoteSchemaRootField :: RemoteSchemaInfo -> ResultCustomizer -> GraphQLField r var -> RemoteSchemaRootField r var
[_rfRemoteSchemaInfo] :: RemoteSchemaRootField r var -> RemoteSchemaInfo
[_rfResultCustomizer] :: RemoteSchemaRootField r var -> ResultCustomizer
[_rfField] :: RemoteSchemaRootField r var -> GraphQLField r var

-- | A remote relationship's selection and fields required for its join
--   condition.
data SchemaRemoteRelationshipSelect r
SchemaRemoteRelationshipSelect :: HashMap FieldName Name -> r -> SchemaRemoteRelationshipSelect r

-- | The fields on the table that are required for the join condition of
--   the remote relationship
[_srrsLHSJoinFields] :: SchemaRemoteRelationshipSelect r -> HashMap FieldName Name

-- | The field that captures the relationship r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
[_srrsRelationship] :: SchemaRemoteRelationshipSelect r -> r
data RemoteFieldArgument
RemoteFieldArgument :: Name -> InputValue RemoteSchemaVariable -> RemoteFieldArgument
[_rfaArgument] :: RemoteFieldArgument -> Name
[_rfaValue] :: RemoteFieldArgument -> InputValue RemoteSchemaVariable
data RemoteSchemaSelect r
RemoteSchemaSelect :: [RemoteFieldArgument] -> ResultCustomizer -> SelectionSet r RemoteSchemaVariable -> NonEmpty FieldCall -> RemoteSchemaInfo -> RemoteSchemaSelect r
[_rselArgs] :: RemoteSchemaSelect r -> [RemoteFieldArgument]
[_rselResultCustomizer] :: RemoteSchemaSelect r -> ResultCustomizer
[_rselSelection] :: RemoteSchemaSelect r -> SelectionSet r RemoteSchemaVariable
[_rselFieldCall] :: RemoteSchemaSelect r -> NonEmpty FieldCall
[_rselRemoteSchema] :: RemoteSchemaSelect r -> RemoteSchemaInfo

-- | Converts a normalized selection set back into a selection set as
--   defined in GraphQL spec, in order to send it to a remote server.
--   
--   This function expects a <a>SelectionSet</a> for which <tt>r</tt> is
--   <a>Void</a>, which guarantees that there is no longer any remote join
--   field in the selection set.
convertSelectionSet :: forall var. Eq var => SelectionSet Void var -> SelectionSet NoFragments var
convertGraphQLField :: Eq var => GraphQLField Void var -> Field NoFragments var
_FieldRemote :: forall r_a6OYc var_a6OYd. Prism' (Field r_a6OYc var_a6OYd) (SchemaRemoteRelationshipSelect r_a6OYc)
_FieldGraphQL :: forall r_a6OYc var_a6QxY var_a6OYd. Prism (Field r_a6OYc var_a6QxY) (Field r_a6OYc var_a6OYd) (GraphQLField r_a6OYc var_a6QxY) (GraphQLField r_a6OYc var_a6OYd)
fSelectionSet :: forall r_a6OYa var_a6OYb r_a6QAm. Lens (GraphQLField r_a6OYa var_a6OYb) (GraphQLField r_a6QAm var_a6OYb) (SelectionSet r_a6OYa var_a6OYb) (SelectionSet r_a6QAm var_a6OYb)
fName :: forall r_a6OYa var_a6OYb. Lens' (GraphQLField r_a6OYa var_a6OYb) Name
fDirectives :: forall r_a6OYa var_a6OYb. Lens' (GraphQLField r_a6OYa var_a6OYb) [Directive var_a6OYb]
fArguments :: forall r_a6OYa var_a6OYb. Lens' (GraphQLField r_a6OYa var_a6OYb) (HashMap Name (Value var_a6OYb))
fAlias :: forall r_a6OYa var_a6OYb. Lens' (GraphQLField r_a6OYa var_a6OYb) Name
dssMemberSelectionSets :: forall r_a6OYg var_a6OYh r_a6QEA var_a6QEB. Lens (DeduplicatedSelectionSet r_a6OYg var_a6OYh) (DeduplicatedSelectionSet r_a6QEA var_a6QEB) (HashMap Name (ObjectSelectionSet r_a6OYg var_a6OYh)) (HashMap Name (ObjectSelectionSet r_a6QEA var_a6QEB))
dssCommonFields :: forall r_a6OYg var_a6OYh. Lens' (DeduplicatedSelectionSet r_a6OYg var_a6OYh) (HashSet Name)
instance Data.Traversable.Traversable Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect
instance Data.Foldable.Foldable Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect
instance GHC.Base.Functor Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect
instance GHC.Show.Show r => GHC.Show.Show (Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.SchemaRemoteRelationshipSelect r)
instance GHC.Generics.Generic (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r var)
instance Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r)
instance Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r)
instance GHC.Base.Functor (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r)
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r var)
instance (GHC.Show.Show var, GHC.Show.Show r) => GHC.Show.Show (Hasura.RQL.IR.RemoteSchema.DeduplicatedSelectionSet r var)
instance Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.SelectionSet r)
instance Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.SelectionSet r)
instance GHC.Base.Functor (Hasura.RQL.IR.RemoteSchema.SelectionSet r)
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.SelectionSet r var)
instance (GHC.Show.Show var, GHC.Show.Show r) => GHC.Show.Show (Hasura.RQL.IR.RemoteSchema.SelectionSet r var)
instance Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.GraphQLField r)
instance Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.GraphQLField r)
instance GHC.Base.Functor (Hasura.RQL.IR.RemoteSchema.GraphQLField r)
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.GraphQLField r var)
instance (GHC.Show.Show var, GHC.Show.Show r) => GHC.Show.Show (Hasura.RQL.IR.RemoteSchema.GraphQLField r var)
instance Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.Field r)
instance Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.Field r)
instance GHC.Base.Functor (Hasura.RQL.IR.RemoteSchema.Field r)
instance (GHC.Classes.Eq var, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.RemoteSchema.Field r var)
instance (GHC.Show.Show var, GHC.Show.Show r) => GHC.Show.Show (Hasura.RQL.IR.RemoteSchema.Field r var)
instance Data.Traversable.Traversable (Hasura.RQL.IR.RemoteSchema.RemoteSchemaRootField r)
instance Data.Foldable.Foldable (Hasura.RQL.IR.RemoteSchema.RemoteSchemaRootField r)
instance GHC.Base.Functor (Hasura.RQL.IR.RemoteSchema.RemoteSchemaRootField r)
instance GHC.Show.Show Hasura.RQL.IR.RemoteSchema.RemoteFieldArgument
instance GHC.Classes.Eq Hasura.RQL.IR.RemoteSchema.RemoteFieldArgument
instance GHC.Show.Show r => GHC.Show.Show (Hasura.RQL.IR.RemoteSchema.RemoteSchemaSelect r)

module Hasura.RQL.Types.Webhook.Transform.Request

-- | Common context that is made available to all request transformations.
data RequestTransformCtx
RequestTransformCtx :: Maybe Value -> Value -> Maybe SessionVariables -> Maybe Value -> TemplatingEngine -> RequestTransformCtx
[rtcBaseUrl] :: RequestTransformCtx -> Maybe Value
[rtcBody] :: RequestTransformCtx -> Value
[rtcSessionVariables] :: RequestTransformCtx -> Maybe SessionVariables
[rtcQueryParams] :: RequestTransformCtx -> Maybe Value
[rtcEngine] :: RequestTransformCtx -> TemplatingEngine

-- | <tt>RequestTransform</tt> Versioning
data Version
V1 :: Version
V2 :: Version
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Request.Version
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Webhook.Transform.Request.Version
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Request.Version
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Request.Version
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Request.Version
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Request.Version
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Request.Version
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Request.RequestTransformCtx

module Hasura.RQL.Types.Webhook.Transform.Url

-- | The actual URL string we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Url
Url :: Text -> Url
[unUrl] :: Url -> Text

-- | The defunctionalized transformation function on <a>Url</a>
newtype UrlTransformFn
Modify :: UnescapedTemplate -> UrlTransformFn
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Url.Url
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Url.Url
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance GHC.Show.Show (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance GHC.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Url.Url)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Url.UrlTransformFn

module Hasura.RQL.Types.Webhook.Transform.QueryParams

-- | The actual query params we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype QueryParams
QueryParams :: Query -> QueryParams
[unQueryParams] :: QueryParams -> Query

-- | The defunctionalized transformation <a>QueryParams</a>
data QueryParamsTransformFn
AddOrReplace :: [(UnescapedTemplate, Maybe UnescapedTemplate)] -> QueryParamsTransformFn
ParamTemplate :: UnescapedTemplate -> QueryParamsTransformFn
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)
instance Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)
instance GHC.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)
instance GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)
instance GHC.Show.Show (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParamsTransformFn

module Hasura.RQL.Types.Webhook.Transform.Method

-- | The actual request method we are transforming.
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Method
Method :: CI Text -> Method

-- | The defunctionalized transformation on <a>Method</a>.
newtype MethodTransformFn

-- | Replace the HTTP existing <a>Method</a> with a new one.
Replace :: Method -> MethodTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Method.Method
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Method.Method
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Method.Method
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Method.Method
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)
instance Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)
instance GHC.Show.Show (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)
instance GHC.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)
instance GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Method.Method)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Method.MethodTransformFn
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Method.Method
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Method.Method
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Method.Method

module Hasura.RQL.Types.Webhook.Transform.Headers

-- | The actual header data we are transforming..
--   
--   This newtype is necessary because otherwise we end up with an orphan
--   instance.
newtype Headers
Headers :: [Header] -> Headers

-- | The defunctionalized transformation on <a>Headers</a>
newtype HeadersTransformFn

-- | Add or replace matching <a>Header</a>s.
AddReplaceOrRemove :: AddReplaceOrRemoveFields -> HeadersTransformFn

-- | The user can supply a set of header keys to be filtered from the
--   request and a set of headers to be added to the request.
data AddReplaceOrRemoveFields
AddReplaceOrRemoveFields :: [(CI Text, UnescapedTemplate)] -> [CI Text] -> AddReplaceOrRemoveFields

-- | A list of key-value pairs for <a>Header</a>s which should be added (if
--   they don't exist) or replaced (if they do) within the HTTP message.
[addOrReplaceHeaders] :: AddReplaceOrRemoveFields -> [(CI Text, UnescapedTemplate)]

-- | A list of <a>Header</a> keys which should be removed from the HTTP
--   message.
[removeHeaders] :: AddReplaceOrRemoveFields -> [CI Text]
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Classes.Ord Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)
instance Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)
instance GHC.Show.Show (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)
instance GHC.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)
instance GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Headers.Headers)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance GHC.Classes.Ord Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Headers.HeaderKey
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Headers.HeadersTransformFn
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Headers.AddReplaceOrRemoveFields

module Hasura.RQL.Types.Webhook.Transform.Body

-- | HTTP message body being transformed.
data Body
JSONBody :: Maybe Value -> Body
RawBody :: ByteString -> Body

-- | The transformations which can be applied to an HTTP message body.
data BodyTransformFn

-- | Remove the HTTP message body.
Remove :: BodyTransformFn

-- | Modify the JSON message body by applying a <a>Template</a>
--   transformation.
ModifyAsJSON :: Template -> BodyTransformFn

-- | Modify the JSON message body by applying <a>UnescapedTemplate</a>
--   transformations to each field with a matching <a>Text</a> key.
ModifyAsFormURLEncoded :: HashMap Text UnescapedTemplate -> BodyTransformFn
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Body.Body
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Body.Body
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)
instance Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)
instance GHC.Show.Show (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)
instance GHC.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)
instance GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.Class.TransformFn Hasura.RQL.Types.Webhook.Transform.Body.Body)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.Body.BodyTransformFn

module Hasura.RQL.Types.Webhook.Transform
data MetadataResponseTransform
MetadataResponseTransform :: Version -> Maybe BodyTransformFn -> TemplatingEngine -> MetadataResponseTransform
[mrtVersion] :: MetadataResponseTransform -> Version
[mrtBodyTransform] :: MetadataResponseTransform -> Maybe BodyTransformFn
[mrtTemplatingEngine] :: MetadataResponseTransform -> TemplatingEngine

-- | <a>RequestTransform</a> is the metadata representation of a request
--   transformation. It consists of a record of higher kinded data (HKD)
--   along with some regular data. We seperate the HKD data into its own
--   record field called <a>requestFields</a> which we nest inside our
--   non-HKD record. The actual transformation operations are contained in
--   the HKD.
data RequestTransform
RequestTransform :: Version -> RequestFields (WithOptional TransformFn) -> TemplatingEngine -> RequestTransform
[version] :: RequestTransform -> Version
[requestFields] :: RequestTransform -> RequestFields (WithOptional TransformFn)
[templateEngine] :: RequestTransform -> TemplatingEngine

-- | Defunctionalized Webhook Request Transformation
--   
--   We represent a defunctionalized request transformation by
--   parameterizing our HKD with <a>WithOptional</a><tt>
--   </tt><a>TransformFn</a>, which marks each of the fields as optional
--   and supplies the appropriate transformation function to them if if
--   they are provided.
type RequestTransformFns = RequestFields (WithOptional TransformFn)

-- | Actual Request Data
--   
--   We represent the actual request data by parameterizing our HKD with
--   <a>Identity</a>, which allows us to trivially unwrap the fields (which
--   should exist after any transformations have been applied).
type RequestData = RequestFields Identity

-- | This is our HKD type. It is a record with fields for each component of
--   an <a>Request</a> we wish to transform.
data RequestFields f
RequestFields :: f Method -> f Url -> f Body -> f QueryParams -> f Headers -> RequestFields f
[method] :: RequestFields f -> f Method
[url] :: RequestFields f -> f Url
[body] :: RequestFields f -> f Body
[queryParams] :: RequestFields f -> f QueryParams
[requestHeaders] :: RequestFields f -> f Headers
type RequestContext = RequestFields TransformCtx
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance Barbies.Internal.ConstraintsB.ConstraintsB Hasura.RQL.Types.Webhook.Transform.RequestFields
instance Barbies.Internal.TraversableB.TraversableB Hasura.RQL.Types.Webhook.Transform.RequestFields
instance Barbies.Internal.ApplicativeB.ApplicativeB Hasura.RQL.Types.Webhook.Transform.RequestFields
instance Barbies.Internal.FunctorB.FunctorB Hasura.RQL.Types.Webhook.Transform.RequestFields
instance GHC.Generics.Generic (Hasura.RQL.Types.Webhook.Transform.RequestFields f)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance GHC.Generics.Generic Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance GHC.Classes.Eq Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance GHC.Show.Show Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance Barbies.Internal.ConstraintsB.AllBF GHC.Show.Show f Hasura.RQL.Types.Webhook.Transform.RequestFields => GHC.Show.Show (Hasura.RQL.Types.Webhook.Transform.RequestFields f)
instance Barbies.Internal.ConstraintsB.AllBF GHC.Classes.Eq f Hasura.RQL.Types.Webhook.Transform.RequestFields => GHC.Classes.Eq (Hasura.RQL.Types.Webhook.Transform.RequestFields f)
instance Barbies.Internal.ConstraintsB.AllBF Control.DeepSeq.NFData f Hasura.RQL.Types.Webhook.Transform.RequestFields => Control.DeepSeq.NFData (Hasura.RQL.Types.Webhook.Transform.RequestFields f)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.RequestContext
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.RequestTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.RequestTransformFns
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.RequestTransformFns
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Webhook.Transform.MetadataResponseTransform

module Hasura.RQL.Types.EventTrigger

-- | Unique name for event trigger.
newtype TriggerName
TriggerName :: NonEmptyText -> TriggerName
[unTriggerName] :: TriggerName -> NonEmptyText
triggerNameToTxt :: TriggerName -> Text
isIllegalTriggerName :: TriggerName -> Bool
data Ops
INSERT :: Ops
UPDATE :: Ops
DELETE :: Ops
MANUAL :: Ops
data SubscribeColumns (b :: BackendType)
SubCStar :: SubscribeColumns (b :: BackendType)
SubCArray :: [Column b] -> SubscribeColumns (b :: BackendType)
data SubscribeOpSpec (b :: BackendType)
SubscribeOpSpec :: SubscribeColumns b -> Maybe (SubscribeColumns b) -> SubscribeOpSpec (b :: BackendType)

-- | Columns of the table that user can subscribe to listen for changes.
[sosColumns] :: SubscribeOpSpec (b :: BackendType) -> SubscribeColumns b

-- | Columns that the event trigger payload should consists. If set, only
--   those columns will be visible in the payload. By default, the payload
--   consists of all the columns of the table.
[sosPayload] :: SubscribeOpSpec (b :: BackendType) -> Maybe (SubscribeColumns b)
defaultTimeoutSeconds :: Int
defaultRetryConf :: RetryConf
data RetryConf
RetryConf :: Int -> Int -> Maybe Int -> RetryConf
[rcNumRetries] :: RetryConf -> Int
[rcIntervalSec] :: RetryConf -> Int
[rcTimeoutSec] :: RetryConf -> Maybe Int
data EventHeaderInfo
EventHeaderInfo :: HeaderConf -> Text -> EventHeaderInfo
[ehiHeaderConf] :: EventHeaderInfo -> HeaderConf
[ehiCachedValue] :: EventHeaderInfo -> Text
data WebhookConf
WCValue :: InputWebhook -> WebhookConf
WCEnv :: Text -> WebhookConf
data WebhookConfInfo
WebhookConfInfo :: WebhookConf -> EnvRecord ResolvedWebhook -> WebhookConfInfo
[wciWebhookConf] :: WebhookConfInfo -> WebhookConf
[wciCachedValue] :: WebhookConfInfo -> EnvRecord ResolvedWebhook

-- | The table operations on which the event trigger will be invoked.
data TriggerOpsDef (b :: BackendType)
TriggerOpsDef :: Maybe (SubscribeOpSpec b) -> Maybe (SubscribeOpSpec b) -> Maybe (SubscribeOpSpec b) -> Maybe Bool -> TriggerOpsDef (b :: BackendType)
[tdInsert] :: TriggerOpsDef (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[tdUpdate] :: TriggerOpsDef (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[tdDelete] :: TriggerOpsDef (b :: BackendType) -> Maybe (SubscribeOpSpec b)
[tdEnableManual] :: TriggerOpsDef (b :: BackendType) -> Maybe Bool
data EventTriggerCleanupStatus
ETCSPaused :: EventTriggerCleanupStatus
ETCSUnpaused :: EventTriggerCleanupStatus

-- | Automatic event trigger log cleanup configuration
data AutoTriggerLogCleanupConfig
AutoTriggerLogCleanupConfig :: CronSchedule -> Int -> Int -> Int -> Bool -> EventTriggerCleanupStatus -> AutoTriggerLogCleanupConfig

-- | cron schedule for the automatic cleanup
[_atlccSchedule] :: AutoTriggerLogCleanupConfig -> CronSchedule

-- | maximum number of events to be deleted in a single cleanup action
[_atlccBatchSize] :: AutoTriggerLogCleanupConfig -> Int

-- | retention period (in hours) for the event trigger logs
[_atlccClearOlderThan] :: AutoTriggerLogCleanupConfig -> Int

-- | SQL query timeout (in seconds)
[_atlccTimeout] :: AutoTriggerLogCleanupConfig -> Int

-- | should we clean the invocation logs as well
[_atlccCleanInvocationLogs] :: AutoTriggerLogCleanupConfig -> Bool

-- | is the cleanup action paused
[_atlccPaused] :: AutoTriggerLogCleanupConfig -> EventTriggerCleanupStatus

-- | Manual event trigger log cleanup configuration
data TriggerLogCleanupConfig
TriggerLogCleanupConfig :: TriggerName -> SourceName -> Int -> Int -> Int -> Bool -> TriggerLogCleanupConfig

-- | name of the event trigger
[tlccEventTriggerName] :: TriggerLogCleanupConfig -> TriggerName

-- | source of the event trigger
[tlccSourceName] :: TriggerLogCleanupConfig -> SourceName

-- | batch size of for the cleanup action
[tlccBatchSize] :: TriggerLogCleanupConfig -> Int

-- | retention period (in hours) for the event trigger logs
[tlccClearOlderThan] :: TriggerLogCleanupConfig -> Int

-- | SQL query timeout (in seconds)
[tlccTimeout] :: TriggerLogCleanupConfig -> Int

-- | should we clean the invocation logs as well
[tlccCleanInvocationLogs] :: TriggerLogCleanupConfig -> Bool
data EventTriggerQualifier
EventTriggerQualifier :: SourceName -> NonEmpty TriggerName -> EventTriggerQualifier
[_etqSourceName] :: EventTriggerQualifier -> SourceName
[_etqEventTriggers] :: EventTriggerQualifier -> NonEmpty TriggerName
data TriggerLogCleanupSources
TriggerAllSource :: TriggerLogCleanupSources
TriggerSource :: NonEmpty SourceName -> TriggerLogCleanupSources
data TriggerLogCleanupToggleConfig
TriggerLogCleanupSources :: TriggerLogCleanupSources -> TriggerLogCleanupToggleConfig
TriggerQualifier :: NonEmpty EventTriggerQualifier -> TriggerLogCleanupToggleConfig
data EventTriggerConf (b :: BackendType)
EventTriggerConf :: TriggerName -> TriggerOpsDef b -> Maybe InputWebhook -> Maybe Text -> RetryConf -> Maybe [HeaderConf] -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> Maybe AutoTriggerLogCleanupConfig -> TriggerOnReplication -> EventTriggerConf (b :: BackendType)
[etcName] :: EventTriggerConf (b :: BackendType) -> TriggerName
[etcDefinition] :: EventTriggerConf (b :: BackendType) -> TriggerOpsDef b
[etcWebhook] :: EventTriggerConf (b :: BackendType) -> Maybe InputWebhook
[etcWebhookFromEnv] :: EventTriggerConf (b :: BackendType) -> Maybe Text
[etcRetryConf] :: EventTriggerConf (b :: BackendType) -> RetryConf
[etcHeaders] :: EventTriggerConf (b :: BackendType) -> Maybe [HeaderConf]
[etcRequestTransform] :: EventTriggerConf (b :: BackendType) -> Maybe RequestTransform
[etcResponseTransform] :: EventTriggerConf (b :: BackendType) -> Maybe MetadataResponseTransform
[etcCleanupConfig] :: EventTriggerConf (b :: BackendType) -> Maybe AutoTriggerLogCleanupConfig
[etcTriggerOnReplication] :: EventTriggerConf (b :: BackendType) -> TriggerOnReplication
updateCleanupConfig :: Maybe AutoTriggerLogCleanupConfig -> EventTriggerConf b -> EventTriggerConf b
data RecreateEventTriggers
RETRecreate :: RecreateEventTriggers
RETDoNothing :: RecreateEventTriggers
data TriggerMetadata
TriggerMetadata :: TriggerName -> TriggerMetadata
[tmName] :: TriggerMetadata -> TriggerName

-- | Change data for a particular row
--   
--   
--   <a>https://docs.hasura.io/1.0/graphql/manual/event-triggers/payload.html</a>
data Event (b :: BackendType)
Event :: EventId -> SourceName -> TableName b -> TriggerMetadata -> Value -> Int -> LocalTime -> Maybe UTCTime -> UTCTime -> Maybe UTCTime -> Event (b :: BackendType)
[eId] :: Event (b :: BackendType) -> EventId
[eSource] :: Event (b :: BackendType) -> SourceName
[eTable] :: Event (b :: BackendType) -> TableName b
[eTrigger] :: Event (b :: BackendType) -> TriggerMetadata
[eEvent] :: Event (b :: BackendType) -> Value
[eTries] :: Event (b :: BackendType) -> Int
[eCreatedAt] :: Event (b :: BackendType) -> LocalTime
[eRetryAt] :: Event (b :: BackendType) -> Maybe UTCTime

-- | The values <a>eCreatedAtUTC</a> and <a>eRetryAtUTC</a> are only used
--   for calculating the <tt>event_processing_time</tt> metric.
[eCreatedAtUTC] :: Event (b :: BackendType) -> UTCTime
[eRetryAtUTC] :: Event (b :: BackendType) -> Maybe UTCTime

-- | The event payload processed by <tt>processEvent</tt>
data EventWithSource (b :: BackendType)
EventWithSource :: Event b -> SourceConfig b -> SourceName -> UTCTime -> EventWithSource (b :: BackendType)
[_ewsEvent] :: EventWithSource (b :: BackendType) -> Event b
[_ewsSourceConfig] :: EventWithSource (b :: BackendType) -> SourceConfig b
[_ewsSourceName] :: EventWithSource (b :: BackendType) -> SourceName

-- | The <a>UTCTime</a> represents the time when the event was fetched from
--   DB. ^ Used to calculate Event Lock time
[_ewsFetchTime] :: EventWithSource (b :: BackendType) -> UTCTime
data ProcessEventError
PESetRetry :: UTCTime -> ProcessEventError
PESetError :: ProcessEventError
data EventTriggerInfo (b :: BackendType)
EventTriggerInfo :: TriggerName -> TriggerOpsDef b -> RetryConf -> WebhookConfInfo -> [EventHeaderInfo] -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> Maybe AutoTriggerLogCleanupConfig -> TriggerOnReplication -> EventTriggerInfo (b :: BackendType)
[etiName] :: EventTriggerInfo (b :: BackendType) -> TriggerName
[etiOpsDef] :: EventTriggerInfo (b :: BackendType) -> TriggerOpsDef b
[etiRetryConf] :: EventTriggerInfo (b :: BackendType) -> RetryConf

-- | The HTTP(s) URL which will be called with the event payload on
--   configured operation. Must be a POST handler. This URL can be entered
--   manually or can be picked up from an environment variable (the
--   environment variable needs to be set before using it for this
--   configuration).
[etiWebhookInfo] :: EventTriggerInfo (b :: BackendType) -> WebhookConfInfo

-- | Custom headers can be added to an event trigger. Each webhook request
--   will have these headers added.
[etiHeaders] :: EventTriggerInfo (b :: BackendType) -> [EventHeaderInfo]
[etiRequestTransform] :: EventTriggerInfo (b :: BackendType) -> Maybe RequestTransform
[etiResponseTransform] :: EventTriggerInfo (b :: BackendType) -> Maybe MetadataResponseTransform
[etiCleanupConfig] :: EventTriggerInfo (b :: BackendType) -> Maybe AutoTriggerLogCleanupConfig
[etiTriggerOnReplication] :: EventTriggerInfo (b :: BackendType) -> TriggerOnReplication
type EventTriggerInfoMap b = HashMap TriggerName (EventTriggerInfo b)
newtype FetchBatchSize
FetchBatchSize :: Int -> FetchBatchSize
[_unFetchBatchSize] :: FetchBatchSize -> Int

-- | Statistics of deleted event logs and invocation logs
data DeletedEventLogStats
DeletedEventLogStats :: Int -> Int -> DeletedEventLogStats
[deletedEventLogs] :: DeletedEventLogStats -> Int
[deletedInvocationLogs] :: DeletedEventLogStats -> Int
data EventLogStatus
Processed :: EventLogStatus
Pending :: EventLogStatus
All :: EventLogStatus
data GetEventLogs (b :: BackendType)
GetEventLogs :: TriggerName -> SourceName -> Int -> Int -> EventLogStatus -> GetEventLogs (b :: BackendType)
[_gelName] :: GetEventLogs (b :: BackendType) -> TriggerName
[_gelSourceName] :: GetEventLogs (b :: BackendType) -> SourceName
[_gelLimit] :: GetEventLogs (b :: BackendType) -> Int
[_gelOffset] :: GetEventLogs (b :: BackendType) -> Int
[_gelStatus] :: GetEventLogs (b :: BackendType) -> EventLogStatus
data EventLog
EventLog :: EventId -> Text -> Text -> TriggerName -> Value -> Bool -> Bool -> Int -> UTCTime -> Maybe UTCTime -> Maybe UTCTime -> Bool -> EventLog
[elId] :: EventLog -> EventId
[elSchemaName] :: EventLog -> Text
[elTableName] :: EventLog -> Text
[elTriggerName] :: EventLog -> TriggerName
[elPayload] :: EventLog -> Value
[elDelivered] :: EventLog -> Bool
[elError] :: EventLog -> Bool
[elTries] :: EventLog -> Int
[elCreatedAt] :: EventLog -> UTCTime
[elLocked] :: EventLog -> Maybe UTCTime
[elNextRetryAt] :: EventLog -> Maybe UTCTime
[elArchived] :: EventLog -> Bool
data GetEventInvocations (b :: BackendType)
GetEventInvocations :: TriggerName -> SourceName -> Int -> Int -> GetEventInvocations (b :: BackendType)
[_geiName] :: GetEventInvocations (b :: BackendType) -> TriggerName
[_geiSourceName] :: GetEventInvocations (b :: BackendType) -> SourceName
[_geiLimit] :: GetEventInvocations (b :: BackendType) -> Int
[_geiOffset] :: GetEventInvocations (b :: BackendType) -> Int
data EventInvocationLog
EventInvocationLog :: Text -> TriggerName -> EventId -> Maybe Int -> Value -> Value -> UTCTime -> EventInvocationLog
[eilId] :: EventInvocationLog -> Text
[eilTriggerName] :: EventInvocationLog -> TriggerName
[eilEventId] :: EventInvocationLog -> EventId
[eilHttpStatus] :: EventInvocationLog -> Maybe Int
[eilRequest] :: EventInvocationLog -> Value
[eilResponse] :: EventInvocationLog -> Value
[eilCreatedAt] :: EventInvocationLog -> UTCTime
data GetEventById (b :: BackendType)
GetEventById :: SourceName -> EventId -> Int -> Int -> GetEventById (b :: BackendType)
[_gebiSourceName] :: GetEventById (b :: BackendType) -> SourceName
[_gebiEventId] :: GetEventById (b :: BackendType) -> EventId
[_gebiInvocationLogLimit] :: GetEventById (b :: BackendType) -> Int
[_gebiInvocationLogOffset] :: GetEventById (b :: BackendType) -> Int
data EventLogWithInvocations
EventLogWithInvocations :: Maybe EventLog -> [EventInvocationLog] -> EventLogWithInvocations
[elwiEvent] :: EventLogWithInvocations -> Maybe EventLog
[elwiInvocations] :: EventLogWithInvocations -> [EventInvocationLog]
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.EventTrigger.TriggerName
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.TriggerName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.EventTrigger.TriggerName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Classes.Ord Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.TriggerName
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.Ops
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.Ops
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.Ops
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.RetryConf
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.RetryConf
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.RetryConf
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.WebhookConf
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.WebhookConf
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.WebhookConf
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.Event b)
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.ProcessEventError
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.ProcessEventError
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.FetchBatchSize
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.FetchBatchSize
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.DeletedEventLogStats
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.DeletedEventLogStats
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.EventLogStatus
instance GHC.Show.Show Hasura.RQL.Types.EventTrigger.EventLogStatus
instance GHC.Show.Show (Hasura.RQL.Types.EventTrigger.GetEventLogs b)
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.EventLog
instance GHC.Classes.Eq Hasura.RQL.Types.EventTrigger.EventLog
instance GHC.Show.Show (Hasura.RQL.Types.EventTrigger.GetEventInvocations b)
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.EventInvocationLog
instance GHC.Show.Show (Hasura.RQL.Types.EventTrigger.GetEventById b)
instance GHC.Generics.Generic Hasura.RQL.Types.EventTrigger.EventLogWithInvocations
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.EventTrigger.Event b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.EventTrigger.Event b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventLogWithInvocations
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.GetEventById b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.GetEventById b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventInvocationLog
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.GetEventInvocations b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.GetEventInvocations b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventLog
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.GetEventLogs b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.GetEventLogs b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventLogStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.EventLogStatus
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.EventTriggerInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.Event b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerMetadata
instance GHC.Base.Semigroup Hasura.RQL.Types.EventTrigger.RecreateEventTriggers
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.EventTriggerConf b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupToggleConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupSources
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventTriggerQualifier
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.TriggerLogCleanupConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.AutoTriggerLogCleanupConfig
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.EventTriggerCleanupStatus
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.TriggerOpsDef b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.WebhookConfInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.WebhookConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.WebhookConf
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.WebhookConf
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.EventHeaderInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.EventTrigger.RetryConf
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.EventTrigger.RetryConf
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.EventTrigger.RetryConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.EventTrigger.RetryConf
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.SubscribeOpSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.SubscribeColumns b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.EventTrigger.Ops
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.EventTrigger.TriggerName


-- | Mutable references for Prometheus metrics.
--   
--   These metrics are independent from the metrics in
--   <a>Hasura.Server.Metrics</a>.
module Hasura.Server.Prometheus

-- | Mutable references for Prometheus metrics.
data PrometheusMetrics
PrometheusMetrics :: ConnectionsGauge -> GraphQLRequestMetrics -> EventTriggerMetrics -> Counter -> CounterVector DynamicSubscriptionLabel -> Counter -> Counter -> ScheduledTriggerMetrics -> SubscriptionMetrics -> Histogram -> Histogram -> CacheRequestMetrics -> OpenTelemetryMetrics -> PrometheusMetrics
[pmConnections] :: PrometheusMetrics -> ConnectionsGauge
[pmGraphQLRequestMetrics] :: PrometheusMetrics -> GraphQLRequestMetrics
[pmEventTriggerMetrics] :: PrometheusMetrics -> EventTriggerMetrics
[pmWebSocketBytesReceived] :: PrometheusMetrics -> Counter
[pmWebSocketBytesSent] :: PrometheusMetrics -> CounterVector DynamicSubscriptionLabel
[pmActionBytesReceived] :: PrometheusMetrics -> Counter
[pmActionBytesSent] :: PrometheusMetrics -> Counter
[pmScheduledTriggerMetrics] :: PrometheusMetrics -> ScheduledTriggerMetrics
[pmSubscriptionMetrics] :: PrometheusMetrics -> SubscriptionMetrics
[pmWebsocketMsgQueueTimeSeconds] :: PrometheusMetrics -> Histogram
[pmWebsocketMsgWriteTimeSeconds] :: PrometheusMetrics -> Histogram
[pmCacheRequestMetrics] :: PrometheusMetrics -> CacheRequestMetrics
[pmOpenTelemetryMetrics] :: PrometheusMetrics -> OpenTelemetryMetrics
data GraphQLRequestMetrics
GraphQLRequestMetrics :: Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> Histogram -> Histogram -> GraphQLRequestMetrics
[gqlRequestsQuerySuccess] :: GraphQLRequestMetrics -> Counter
[gqlRequestsQueryFailure] :: GraphQLRequestMetrics -> Counter
[gqlRequestsMutationSuccess] :: GraphQLRequestMetrics -> Counter
[gqlRequestsMutationFailure] :: GraphQLRequestMetrics -> Counter
[gqlRequestsSubscriptionSuccess] :: GraphQLRequestMetrics -> Counter
[gqlRequestsSubscriptionFailure] :: GraphQLRequestMetrics -> Counter
[gqlRequestsUnknownFailure] :: GraphQLRequestMetrics -> Counter
[gqlExecutionTimeSecondsQuery] :: GraphQLRequestMetrics -> Histogram
[gqlExecutionTimeSecondsMutation] :: GraphQLRequestMetrics -> Histogram
data EventTriggerMetrics
EventTriggerMetrics :: Gauge -> Gauge -> HistogramVector (Maybe DynamicEventTriggerLabel) -> Histogram -> HistogramVector (Maybe DynamicEventTriggerLabel) -> HistogramVector (Maybe DynamicEventTriggerLabel) -> Counter -> Counter -> CounterVector EventStatusWithTriggerLabel -> CounterVector EventStatusWithTriggerLabel -> EventTriggerMetrics
[eventTriggerHTTPWorkers] :: EventTriggerMetrics -> Gauge
[eventsFetchedPerBatch] :: EventTriggerMetrics -> Gauge
[eventQueueTimeSeconds] :: EventTriggerMetrics -> HistogramVector (Maybe DynamicEventTriggerLabel)
[eventsFetchTimePerBatch] :: EventTriggerMetrics -> Histogram
[eventWebhookProcessingTime] :: EventTriggerMetrics -> HistogramVector (Maybe DynamicEventTriggerLabel)
[eventProcessingTime] :: EventTriggerMetrics -> HistogramVector (Maybe DynamicEventTriggerLabel)
[eventTriggerBytesReceived] :: EventTriggerMetrics -> Counter
[eventTriggerBytesSent] :: EventTriggerMetrics -> Counter
[eventProcessedTotal] :: EventTriggerMetrics -> CounterVector EventStatusWithTriggerLabel
[eventInvocationTotal] :: EventTriggerMetrics -> CounterVector EventStatusWithTriggerLabel
data ScheduledTriggerMetrics
ScheduledTriggerMetrics :: Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> ScheduledTriggerMetrics
[stmScheduledTriggerBytesReceived] :: ScheduledTriggerMetrics -> Counter
[stmScheduledTriggerBytesSent] :: ScheduledTriggerMetrics -> Counter
[stmCronEventsInvocationTotalSuccess] :: ScheduledTriggerMetrics -> Counter
[stmCronEventsInvocationTotalFailure] :: ScheduledTriggerMetrics -> Counter
[stmOneOffEventsInvocationTotalSuccess] :: ScheduledTriggerMetrics -> Counter
[stmOneOffEventsInvocationTotalFailure] :: ScheduledTriggerMetrics -> Counter
[stmCronEventsProcessedTotalSuccess] :: ScheduledTriggerMetrics -> Counter
[stmCronEventsProcessedTotalFailure] :: ScheduledTriggerMetrics -> Counter
[stmOneOffEventsProcessedTotalSuccess] :: ScheduledTriggerMetrics -> Counter
[stmOneOffEventsProcessedTotalFailure] :: ScheduledTriggerMetrics -> Counter
data SubscriptionMetrics
SubscriptionMetrics :: Gauge -> Gauge -> Gauge -> Gauge -> HistogramVector SubscriptionLabel -> HistogramVector SubscriptionLabel -> GaugeVector SubscriptionLabel -> SubscriptionMetrics
[submActiveLiveQueryPollers] :: SubscriptionMetrics -> Gauge
[submActiveStreamingPollers] :: SubscriptionMetrics -> Gauge
[submActiveLiveQueryPollersInError] :: SubscriptionMetrics -> Gauge
[submActiveStreamingPollersInError] :: SubscriptionMetrics -> Gauge
[submTotalTime] :: SubscriptionMetrics -> HistogramVector SubscriptionLabel
[submDBExecTotalTime] :: SubscriptionMetrics -> HistogramVector SubscriptionLabel
[submActiveSubscriptions] :: SubscriptionMetrics -> GaugeVector SubscriptionLabel
data CacheRequestMetrics
CacheRequestMetrics :: Counter -> Counter -> CacheRequestMetrics
[crmCacheHits] :: CacheRequestMetrics -> Counter
[crmCacheMisses] :: CacheRequestMetrics -> Counter

-- | Metrics related to OTel telemetry export; for now the volume of logs
--   and trace spans shipped, and counts of log lines and spans dropped due
--   to high volume.
data OpenTelemetryMetrics
OpenTelemetryMetrics :: Counter -> Counter -> Counter -> Counter -> Counter -> Counter -> OpenTelemetryMetrics
[otmSentSpans] :: OpenTelemetryMetrics -> Counter

-- | Dropped due to the send buffer being full
[otmDroppedSpansInBuffer] :: OpenTelemetryMetrics -> Counter

-- | Dropped due to some error (after retrying) when sending to collector
[otmDroppedSpansInSend] :: OpenTelemetryMetrics -> Counter
[otmSentLogs] :: OpenTelemetryMetrics -> Counter
[otmDroppedLogsInBuffer] :: OpenTelemetryMetrics -> Counter
[otmDroppedLogsInSend] :: OpenTelemetryMetrics -> Counter

-- | Create dummy mutable references without associating them to a metrics
--   store.
makeDummyPrometheusMetrics :: IO PrometheusMetrics

-- | A mutable reference for atomically sampling the number of websocket
--   connections and number of threads forked by the warp webserver.
--   
--   Because we derive the number of (non-websocket) HTTP connections by
--   the difference of these two metrics, we must sample them
--   simultaneously, otherwise we might report a negative number of HTTP
--   connections.
data ConnectionsGauge
data Connections
Connections :: Int64 -> Int64 -> Connections
[connWarpThreads] :: Connections -> Int64
[connWebsockets] :: Connections -> Int64
newConnectionsGauge :: IO ConnectionsGauge
readConnectionsGauge :: ConnectionsGauge -> IO Connections
incWarpThreads :: ConnectionsGauge -> IO ()
decWarpThreads :: ConnectionsGauge -> IO ()
incWebsocketConnections :: ConnectionsGauge -> IO ()
decWebsocketConnections :: ConnectionsGauge -> IO ()
data DynamicEventTriggerLabel
DynamicEventTriggerLabel :: TriggerName -> SourceName -> DynamicEventTriggerLabel
[_detlTriggerName] :: DynamicEventTriggerLabel -> TriggerName
[_detlSourceName] :: DynamicEventTriggerLabel -> SourceName
data ResponseStatus
Success :: ResponseStatus
Failed :: ResponseStatus
responseStatusToLabelValue :: ResponseStatus -> Text
newtype EventStatusLabel
EventStatusLabel :: Text -> EventStatusLabel
[status] :: EventStatusLabel -> Text
eventSuccessLabel :: EventStatusLabel
eventFailedLabel :: EventStatusLabel
data EventStatusWithTriggerLabel
EventStatusWithTriggerLabel :: EventStatusLabel -> Maybe DynamicEventTriggerLabel -> EventStatusWithTriggerLabel
[_eswtlStatus] :: EventStatusWithTriggerLabel -> EventStatusLabel
[_eswtlDynamicLabels] :: EventStatusWithTriggerLabel -> Maybe DynamicEventTriggerLabel
data SubscriptionKindLabel
SubscriptionKindLabel :: Text -> SubscriptionKindLabel
[subscription_kind] :: SubscriptionKindLabel -> Text
streamingSubscriptionLabel :: SubscriptionKindLabel
liveQuerySubscriptionLabel :: SubscriptionKindLabel
data DynamicSubscriptionLabel
DynamicSubscriptionLabel :: Maybe ParameterizedQueryHash -> Maybe OperationName -> DynamicSubscriptionLabel
[_dslParamQueryHash] :: DynamicSubscriptionLabel -> Maybe ParameterizedQueryHash
[_dslOperationName] :: DynamicSubscriptionLabel -> Maybe OperationName
data SubscriptionLabel
SubscriptionLabel :: SubscriptionKindLabel -> Maybe DynamicSubscriptionLabel -> SubscriptionLabel
[_slKind] :: SubscriptionLabel -> SubscriptionKindLabel
[_slDynamicLabels] :: SubscriptionLabel -> Maybe DynamicSubscriptionLabel

-- | Record metrics with dynamic label
recordMetricWithLabel :: MonadIO m => IO GranularPrometheusMetricsState -> Bool -> IO () -> IO () -> m ()

-- | Observe a histogram metric with a label.
--   
--   If the granularity is set to <a>GranularMetricsOn</a>, the label will
--   be included in the metric. Otherwise, the label will be set to
--   <a>Nothing</a>
observeHistogramWithLabel :: (Ord l, MonadIO m) => IO GranularPrometheusMetricsState -> Bool -> HistogramVector (Maybe l) -> l -> Double -> m ()

-- | Record a subscription metric for all the operation names present in
--   the subscription. Use this when you want to update the same value of
--   the metric for all the operation names.
recordSubcriptionMetric :: MonadIO m => IO GranularPrometheusMetricsState -> Bool -> HashMap (Maybe OperationName) Int -> ParameterizedQueryHash -> SubscriptionKindLabel -> (SubscriptionLabel -> IO ()) -> m ()
instance GHC.Classes.Eq Hasura.Server.Prometheus.DynamicEventTriggerLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.DynamicEventTriggerLabel
instance System.Metrics.Prometheus.ToLabels Hasura.Server.Prometheus.EventStatusLabel
instance GHC.Classes.Eq Hasura.Server.Prometheus.EventStatusLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.EventStatusLabel
instance GHC.Generics.Generic Hasura.Server.Prometheus.EventStatusLabel
instance GHC.Classes.Eq Hasura.Server.Prometheus.EventStatusWithTriggerLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.EventStatusWithTriggerLabel
instance GHC.Generics.Generic Hasura.Server.Prometheus.EventStatusWithTriggerLabel
instance System.Metrics.Prometheus.ToLabels Hasura.Server.Prometheus.SubscriptionKindLabel
instance GHC.Classes.Eq Hasura.Server.Prometheus.SubscriptionKindLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.SubscriptionKindLabel
instance GHC.Generics.Generic Hasura.Server.Prometheus.SubscriptionKindLabel
instance GHC.Classes.Eq Hasura.Server.Prometheus.DynamicSubscriptionLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.DynamicSubscriptionLabel
instance GHC.Generics.Generic Hasura.Server.Prometheus.DynamicSubscriptionLabel
instance GHC.Classes.Eq Hasura.Server.Prometheus.SubscriptionLabel
instance GHC.Classes.Ord Hasura.Server.Prometheus.SubscriptionLabel
instance GHC.Generics.Generic Hasura.Server.Prometheus.SubscriptionLabel
instance System.Metrics.Prometheus.ToLabels Hasura.Server.Prometheus.SubscriptionLabel
instance System.Metrics.Prometheus.ToLabels Hasura.Server.Prometheus.DynamicSubscriptionLabel
instance System.Metrics.Prometheus.ToLabels Hasura.Server.Prometheus.EventStatusWithTriggerLabel
instance System.Metrics.Prometheus.ToLabels (GHC.Maybe.Maybe Hasura.Server.Prometheus.DynamicEventTriggerLabel)


-- | These are types for Scheduled Trigger definition; see
--   <a>Hasura.Eventing.ScheduledTrigger</a>
module Hasura.RQL.Types.ScheduledTrigger
type CronEventId = EventId
type OneOffScheduledEventId = EventId
type ScheduledEventId = EventId
type InvocationId = Text
data STRetryConf
STRetryConf :: Int -> Refined NonNegative DiffTime -> Refined NonNegative DiffTime -> Refined NonNegative DiffTime -> STRetryConf
[strcNumRetries] :: STRetryConf -> Int
[strcRetryIntervalSeconds] :: STRetryConf -> Refined NonNegative DiffTime
[strcTimeoutSeconds] :: STRetryConf -> Refined NonNegative DiffTime

-- | The tolerance configuration is used to determine whether a scheduled
--   event is not too old to process. The age of the scheduled event is the
--   difference between the current timestamp and the scheduled event's
--   timestamp, if the age is than the tolerance then the scheduled event
--   is marked as dead.
[strcToleranceSeconds] :: STRetryConf -> Refined NonNegative DiffTime
defaultSTRetryConf :: STRetryConf
data CronTriggerMetadata
CronTriggerMetadata :: TriggerName -> InputWebhook -> CronSchedule -> Maybe Value -> STRetryConf -> [HeaderConf] -> Bool -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CronTriggerMetadata
[ctName] :: CronTriggerMetadata -> TriggerName
[ctWebhook] :: CronTriggerMetadata -> InputWebhook
[ctSchedule] :: CronTriggerMetadata -> CronSchedule
[ctPayload] :: CronTriggerMetadata -> Maybe Value
[ctRetryConf] :: CronTriggerMetadata -> STRetryConf
[ctHeaders] :: CronTriggerMetadata -> [HeaderConf]
[ctIncludeInMetadata] :: CronTriggerMetadata -> Bool
[ctComment] :: CronTriggerMetadata -> Maybe Text
[ctRequestTransform] :: CronTriggerMetadata -> Maybe RequestTransform
[ctResponseTransform] :: CronTriggerMetadata -> Maybe MetadataResponseTransform
data CreateCronTrigger
CreateCronTrigger :: TriggerName -> InputWebhook -> CronSchedule -> Maybe Value -> STRetryConf -> [HeaderConf] -> Bool -> Maybe Text -> Bool -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CreateCronTrigger
[_cctName] :: CreateCronTrigger -> TriggerName
[_cctWebhook] :: CreateCronTrigger -> InputWebhook
[_cctCronSchedule] :: CreateCronTrigger -> CronSchedule
[_cctPayload] :: CreateCronTrigger -> Maybe Value
[_cctRetryConf] :: CreateCronTrigger -> STRetryConf
[_cctHeaders] :: CreateCronTrigger -> [HeaderConf]
[_cctIncludeInMetadata] :: CreateCronTrigger -> Bool
[_cctComment] :: CreateCronTrigger -> Maybe Text
[_cctReplace] :: CreateCronTrigger -> Bool
[_cctRequestTransform] :: CreateCronTrigger -> Maybe RequestTransform
[_cctResponseTransform] :: CreateCronTrigger -> Maybe MetadataResponseTransform
cctWebhook :: Lens' CreateCronTrigger InputWebhook
cctRetryConf :: Lens' CreateCronTrigger STRetryConf
cctResponseTransform :: Lens' CreateCronTrigger (Maybe MetadataResponseTransform)
cctRequestTransform :: Lens' CreateCronTrigger (Maybe RequestTransform)
cctReplace :: Lens' CreateCronTrigger Bool
cctPayload :: Lens' CreateCronTrigger (Maybe Value)
cctName :: Lens' CreateCronTrigger TriggerName
cctIncludeInMetadata :: Lens' CreateCronTrigger Bool
cctHeaders :: Lens' CreateCronTrigger [HeaderConf]
cctCronSchedule :: Lens' CreateCronTrigger CronSchedule
cctComment :: Lens' CreateCronTrigger (Maybe Text)
newtype ScheduledTriggerName
ScheduledTriggerName :: TriggerName -> ScheduledTriggerName
[unName] :: ScheduledTriggerName -> TriggerName
formatTime' :: UTCTime -> Text
data CreateScheduledEvent
CreateScheduledEvent :: InputWebhook -> UTCTime -> Maybe Value -> [HeaderConf] -> STRetryConf -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CreateScheduledEvent
[cseWebhook] :: CreateScheduledEvent -> InputWebhook

-- | The timestamp should be in the <a>8601
--   https://en.wikipedia.org/wiki/ISO_8601</a> format (which is what
--   <tt>aeson</tt> expects by default for <a>UTCTime</a>).
[cseScheduleAt] :: CreateScheduledEvent -> UTCTime
[csePayload] :: CreateScheduledEvent -> Maybe Value
[cseHeaders] :: CreateScheduledEvent -> [HeaderConf]
[cseRetryConf] :: CreateScheduledEvent -> STRetryConf
[cseComment] :: CreateScheduledEvent -> Maybe Text
[cseRequestTransform] :: CreateScheduledEvent -> Maybe RequestTransform
[cseResponseTransform] :: CreateScheduledEvent -> Maybe MetadataResponseTransform

-- | The <a>ScheduledEventType</a> data type is needed to differentiate
--   between a <tt>CronScheduledEvent</tt> and <a>OneOffScheduledEvent</a>
--   scheduled event because they both have different configurations and
--   they live in different tables.
data ScheduledEventType

-- | A Cron scheduled event has a template defined which will contain the
--   webhook, header configuration, retry configuration and a payload.
--   Every cron event created uses the above mentioned configurations
--   defined in the template. The configuration defined with the cron
--   trigger is cached and hence it's not fetched along the cron scheduled
--   events.
Cron :: ScheduledEventType

-- | A One-off scheduled event doesn't have any template defined so all the
--   configuration is fetched along the scheduled events.
OneOff :: ScheduledEventType
data ScheduledEventInvocation
ScheduledEventInvocation :: InvocationId -> EventId -> Maybe Int -> Maybe Value -> Maybe Value -> UTCTime -> ScheduledEventInvocation
[_seiId] :: ScheduledEventInvocation -> InvocationId
[_seiEventId] :: ScheduledEventInvocation -> EventId
[_seiStatus] :: ScheduledEventInvocation -> Maybe Int
[_seiRequest] :: ScheduledEventInvocation -> Maybe Value
[_seiResponse] :: ScheduledEventInvocation -> Maybe Value
[_seiCreatedAt] :: ScheduledEventInvocation -> UTCTime
data ScheduledEvent
SEOneOff :: ScheduledEvent
SECron :: TriggerName -> ScheduledEvent
data CronEventSeed
CronEventSeed :: TriggerName -> UTCTime -> CronEventSeed
[cesName] :: CronEventSeed -> TriggerName
[cesScheduledTime] :: CronEventSeed -> UTCTime
type OneOffEvent = CreateScheduledEvent
data ScheduledEventStatus
SESScheduled :: ScheduledEventStatus
SESLocked :: ScheduledEventStatus
SESDelivered :: ScheduledEventStatus
SESError :: ScheduledEventStatus
SESDead :: ScheduledEventStatus
scheduledEventStatusToText :: ScheduledEventStatus -> Text
data OneOffScheduledEvent
OneOffScheduledEvent :: OneOffScheduledEventId -> InputWebhook -> UTCTime -> STRetryConf -> Maybe Value -> [HeaderConf] -> Text -> Int -> UTCTime -> Maybe UTCTime -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> OneOffScheduledEvent
[_ooseId] :: OneOffScheduledEvent -> OneOffScheduledEventId
[_ooseWebhookConf] :: OneOffScheduledEvent -> InputWebhook
[_ooseScheduledTime] :: OneOffScheduledEvent -> UTCTime
[_ooseRetryConf] :: OneOffScheduledEvent -> STRetryConf
[_oosePayload] :: OneOffScheduledEvent -> Maybe Value
[_ooseHeaderConf] :: OneOffScheduledEvent -> [HeaderConf]
[_ooseStatus] :: OneOffScheduledEvent -> Text
[_ooseTries] :: OneOffScheduledEvent -> Int
[_ooseCreatedAt] :: OneOffScheduledEvent -> UTCTime
[_ooseNextRetryAt] :: OneOffScheduledEvent -> Maybe UTCTime
[_ooseComment] :: OneOffScheduledEvent -> Maybe Text
[_ooseRequestTransform] :: OneOffScheduledEvent -> Maybe RequestTransform
[_ooseResponseTransform] :: OneOffScheduledEvent -> Maybe MetadataResponseTransform
data CronEvent
CronEvent :: CronEventId -> TriggerName -> UTCTime -> Text -> Int -> UTCTime -> Maybe UTCTime -> CronEvent
[_ceId] :: CronEvent -> CronEventId
[_ceTriggerName] :: CronEvent -> TriggerName

-- | We expect this to always be at second zero, since cron events have
--   minute resolution. Note that a OneOffScheduledEvent has full timestamp
--   precision.
[_ceScheduledTime] :: CronEvent -> UTCTime
[_ceStatus] :: CronEvent -> Text
[_ceTries] :: CronEvent -> Int

-- | it is the time at which the cron event generator created the event
[_ceCreatedAt] :: CronEvent -> UTCTime
[_ceNextRetryAt] :: CronEvent -> Maybe UTCTime
data ScheduledEventPagination
ScheduledEventPagination :: Maybe Int -> Maybe Int -> ScheduledEventPagination
[_sepLimit] :: ScheduledEventPagination -> Maybe Int
[_sepOffset] :: ScheduledEventPagination -> Maybe Int
data RowsCountOption
IncludeRowsCount :: RowsCountOption
DontIncludeRowsCount :: RowsCountOption

-- | Query type to fetch all one-off/cron scheduled events
data GetScheduledEvents
GetScheduledEvents :: ScheduledEvent -> ScheduledEventPagination -> [ScheduledEventStatus] -> RowsCountOption -> GetScheduledEvents
[_gseScheduledEvent] :: GetScheduledEvents -> ScheduledEvent
[_gsePagination] :: GetScheduledEvents -> ScheduledEventPagination
[_gseStatus] :: GetScheduledEvents -> [ScheduledEventStatus]
[_gseGetRowsCount] :: GetScheduledEvents -> RowsCountOption
data WithOptionalTotalCount a
WithOptionalTotalCount :: Maybe Int -> a -> WithOptionalTotalCount a
[_wtcCount] :: WithOptionalTotalCount a -> Maybe Int
[_wtcData] :: WithOptionalTotalCount a -> a

-- | Query type to delete cron/one-off events.
data DeleteScheduledEvent
DeleteScheduledEvent :: ScheduledEventType -> ScheduledEventId -> DeleteScheduledEvent
[_dseType] :: DeleteScheduledEvent -> ScheduledEventType
[_dseEventId] :: DeleteScheduledEvent -> ScheduledEventId
data GetScheduledEventInvocationsBy
GIBEventId :: EventId -> ScheduledEventType -> GetScheduledEventInvocationsBy
GIBEvent :: ScheduledEvent -> GetScheduledEventInvocationsBy
data GetScheduledEventInvocations
GetScheduledEventInvocations :: GetScheduledEventInvocationsBy -> ScheduledEventPagination -> RowsCountOption -> GetScheduledEventInvocations
[_geiInvocationsBy] :: GetScheduledEventInvocations -> GetScheduledEventInvocationsBy
[_geiPagination] :: GetScheduledEventInvocations -> ScheduledEventPagination

-- | Option to include the total rows corresponding in response.
[_geiGetRowsCount] :: GetScheduledEventInvocations -> RowsCountOption
data ClearCronEvents

-- | Used to delete the cron events only of the specified cron trigger
SingleCronTrigger :: TriggerName -> ClearCronEvents

-- | Used to delete all the cron events of the cron triggers with
--   `include_in_metadata: true` It is used in the case of the
--   <tt>replace_metadata</tt> API
MetadataCronTriggers :: [TriggerName] -> ClearCronEvents
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEvent
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CronEventSeed
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.CronEventSeed
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ScheduledEventPagination
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ScheduledEventPagination
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.RowsCountOption
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.RowsCountOption
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.ScheduledTrigger.WithOptionalTotalCount a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.ScheduledTrigger.WithOptionalTotalCount a)
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocationsBy
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocationsBy
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocations
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocations
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.ClearCronEvents
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.ClearCronEvents
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocations
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.GetScheduledEventInvocations
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.DeleteScheduledEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.GetScheduledEvents
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.RowsCountOption
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.RowsCountOption
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CronEvent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.OneOffScheduledEvent
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventInvocation
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledEventType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CreateScheduledEvent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.ScheduledTriggerName
instance Control.DeepSeq.NFData Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance GHC.Generics.Generic Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance GHC.Classes.Eq Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance GHC.Show.Show Hasura.RQL.Types.ScheduledTrigger.CreateCronTrigger
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance Control.DeepSeq.NFData Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.CronTriggerMetadata
instance Control.DeepSeq.NFData Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.ScheduledTrigger.STRetryConf
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.ScheduledTrigger.STRetryConf

module Hasura.RQL.IR.Value

-- | Where did this variable come from?
data Provenance
FromGraphQL :: VariableInfo -> Provenance

-- | An internal source
FromInternal :: Text -> Provenance

-- | A unique, fresh occurrence of a variable. E.g. a native query
--   argument, or generated values that benefit from being prepared rather
--   than inlined.
FreshVar :: Provenance
data UnpreparedValue (b :: BackendType)

-- | A SQL value that can be parameterized over.
UVParameter :: Provenance -> ColumnValue b -> UnpreparedValue (b :: BackendType)

-- | A literal SQL expression that <i>cannot</i> be parameterized over.
UVLiteral :: SQLExpression b -> UnpreparedValue (b :: BackendType)

-- | The entire session variables JSON object.
UVSession :: UnpreparedValue (b :: BackendType)

-- | A single session variable.
UVSessionVar :: SessionVarType b -> SessionVariable -> UnpreparedValue (b :: BackendType)

-- | This indicates whether a variable value came from a certain GraphQL
--   variable
data ValueWithOrigin a
ValueWithOrigin :: VariableInfo -> a -> ValueWithOrigin a
ValueNoOrigin :: a -> ValueWithOrigin a
openValueOrigin :: ValueWithOrigin a -> a
mkParameter :: ValueWithOrigin (ColumnValue b) -> UnpreparedValue b
instance GHC.Show.Show Hasura.RQL.IR.Value.Provenance
instance GHC.Classes.Eq Hasura.RQL.IR.Value.Provenance
instance GHC.Base.Functor Hasura.RQL.IR.Value.ValueWithOrigin
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Column.ColumnValue b)) => GHC.Classes.Eq (Hasura.RQL.IR.Value.UnpreparedValue b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Column.ColumnValue b)) => GHC.Show.Show (Hasura.RQL.IR.Value.UnpreparedValue b)


-- | Boolean Expressions
--   
--   This module defines the IR representation of boolean expressions used
--   in <tt>_where</tt> clauses in GraphQL queries, permissions, and so on.
--   
--   The types in this module define a <i>generic</i> structure with
--   "holes" to be filled by each backend. Specifically, holes will include
--   things like types for table names, and backend field types.
module Hasura.RQL.IR.BoolExp

-- | This type represents a boolean expression tree. It is parametric over
--   the actual implementation of the actual boolean term values. It
--   nonetheless leaks some information: "exists" is only used in
--   permissions, to add conditions based on another table.
--   
--   <ul>
--   <li>The <tt>backend</tt> parameter is used to find the
--   backend-specific type for table names in the <tt>BoolExists</tt>
--   constructor.</li>
--   <li>The <tt>field</tt> type represent the type of database-specific
--   field types.</li>
--   </ul>
data GBoolExp (backend :: BackendType) field
BoolAnd :: [GBoolExp backend field] -> GBoolExp (backend :: BackendType) field
BoolOr :: [GBoolExp backend field] -> GBoolExp (backend :: BackendType) field
BoolNot :: GBoolExp backend field -> GBoolExp (backend :: BackendType) field

-- | Represents a condition on an aribtrary table. since the
--   <tt>backend</tt> and <tt>field</tt> are the same, the table must be of
--   the same database type.
BoolExists :: GExists backend field -> GBoolExp (backend :: BackendType) field

-- | A column field
BoolField :: field -> GBoolExp (backend :: BackendType) field

-- | A default representation for a <tt>true</tt> boolean value.
gBoolExpTrue :: GBoolExp backend field

-- | Represents a condition on an aribtrary table. Used as part of our
--   permissions boolean expressions. See our documentation for more
--   information:
--   <a>https://hasura.io/docs/latest/graphql/core/auth/authorization/permission-rules.html#using-unrelated-tables-views</a>
data GExists (backend :: BackendType) field
GExists :: TableName backend -> GBoolExp backend field -> GExists (backend :: BackendType) field
[_geTable] :: GExists (backend :: BackendType) field -> TableName backend
[_geWhere] :: GExists (backend :: BackendType) field -> GBoolExp backend field

-- | We don't allow conditions across relationships in permissions: the
--   type we use as the terms in GBoolExp is this one, ColExp, which only
--   contains a FieldName and a JSON Value.
data ColExp
ColExp :: FieldName -> Value -> ColExp
[ceCol] :: ColExp -> FieldName
[ceVal] :: ColExp -> Value

-- | This <tt>BoolExp</tt> type is a simple alias for the boolean
--   expressions used in permissions, that uses <a>ColExp</a> as the term
--   in GBoolExp.
newtype BoolExp (b :: BackendType)
BoolExp :: GBoolExp b ColExp -> BoolExp (b :: BackendType)
[unBoolExp] :: BoolExp (b :: BackendType) -> GBoolExp b ColExp

-- | Permissions get translated into boolean expressions that are threaded
--   throuhgout the parsers. For the leaf values of those permissions, we
--   use this type, which references but doesn't inline the session
--   variables.
data PartialSQLExp (backend :: BackendType)
PSESessVar :: SessionVarType backend -> SessionVariable -> PartialSQLExp (backend :: BackendType)
PSESession :: PartialSQLExp (backend :: BackendType)
PSESQLExp :: SQLExpression backend -> PartialSQLExp (backend :: BackendType)
isStaticValue :: PartialSQLExp backend -> Bool
hasStaticExp :: Backend b => OpExpG b (PartialSQLExp b) -> Bool

-- | Operand for cast operator
type CastExp backend field = HashMap (ScalarType backend) [OpExpG backend field]
data ComparisonNullability
NonNullableComparison :: ComparisonNullability
NullableComparison :: ComparisonNullability

-- | This type represents the boolean operators that can be applied on
--   values of a column. This type only contains the common core, that we
--   expect to be ultimately entirely supported in most if not all
--   backends. Backends can extend this with the <tt>BooleanOperators</tt>
--   type in <tt>Backend</tt>.
data OpExpG (backend :: BackendType) field
ACast :: CastExp backend field -> OpExpG (backend :: BackendType) field
AEQ :: ComparisonNullability -> field -> OpExpG (backend :: BackendType) field
ANE :: ComparisonNullability -> field -> OpExpG (backend :: BackendType) field
AIN :: field -> OpExpG (backend :: BackendType) field
ANIN :: field -> OpExpG (backend :: BackendType) field
AGT :: field -> OpExpG (backend :: BackendType) field
ALT :: field -> OpExpG (backend :: BackendType) field
AGTE :: field -> OpExpG (backend :: BackendType) field
ALTE :: field -> OpExpG (backend :: BackendType) field
ALIKE :: field -> OpExpG (backend :: BackendType) field
ANLIKE :: field -> OpExpG (backend :: BackendType) field
CEQ :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CNE :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CGT :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CLT :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CGTE :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
CLTE :: RootOrCurrentColumn backend -> OpExpG (backend :: BackendType) field
ANISNULL :: OpExpG (backend :: BackendType) field
ANISNOTNULL :: OpExpG (backend :: BackendType) field
ABackendSpecific :: BooleanOperators backend field -> OpExpG (backend :: BackendType) field
data RootOrCurrentColumn b
RootOrCurrentColumn :: RootOrCurrent -> Column b -> RootOrCurrentColumn b

-- | The arguments of column-operators may refer to either the so-called
--   'root tabular value' or 'current tabular value'.
data RootOrCurrent
IsRoot :: RootOrCurrent
IsCurrent :: RootOrCurrent
opExpDepCol :: OpExpG backend field -> Maybe (RootOrCurrentColumn backend)

-- | This type is used to represent the kinds of boolean expression used
--   for computed fields based on the return type of the SQL function.
data ComputedFieldBoolExp (backend :: BackendType) scalar

-- | SQL function returning a scalar
CFBEScalar :: AnnRedactionExp backend scalar -> [OpExpG backend scalar] -> ComputedFieldBoolExp (backend :: BackendType) scalar

-- | SQL function returning SET OF table
CFBETable :: TableName backend -> AnnBoolExp backend scalar -> ComputedFieldBoolExp (backend :: BackendType) scalar

-- | Using a computed field in boolean expression. Example: A computed
--   field "full_name" ("first_name" || "last_name") is defined to the
--   "user" table. Boolean expression to filter whose "full_name" is LIKE
--   "%bob%" query { user(where: {full_name: {_like: "%bob%"}}){ id
--   first_name last_name full_name } } Limitation: We only support
--   computed fields in boolean expressions when they are functions with no
--   input arguments, because it is complex to generate schema for
--   <tt>where</tt> clauses for functions that have input arguments.
data AnnComputedFieldBoolExp (backend :: BackendType) scalar
AnnComputedFieldBoolExp :: XComputedField backend -> ComputedFieldName -> FunctionName backend -> FunctionArgsExp backend scalar -> ComputedFieldBoolExp backend scalar -> AnnComputedFieldBoolExp (backend :: BackendType) scalar
[_acfbXFieldInfo] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> XComputedField backend
[_acfbName] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> ComputedFieldName
[_acfbFunction] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> FunctionName backend
[_acfbFunctionArgsExp] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> FunctionArgsExp backend scalar
[_acfbBoolExp] :: AnnComputedFieldBoolExp (backend :: BackendType) scalar -> ComputedFieldBoolExp backend scalar

-- | This type is used for boolean terms in GBoolExp in the schema; there
--   are four kinds boolean terms: - operators on a column of the current
--   table, using the <a>OpExpG</a> kind of operators - arbitrary
--   expressions on columns of tables in relationships (in the same source)
--   - A computed field of the current table - aggregation operations on
--   array relationships on the current tables.
--   
--   This type is parameterized over the type of leaf values, the values on
--   which we operate.
data AnnBoolExpFld (backend :: BackendType) leaf
AVColumn :: ColumnInfo backend -> AnnRedactionExp backend leaf -> [OpExpG backend leaf] -> AnnBoolExpFld (backend :: BackendType) leaf
AVNestedObject :: NestedObjectInfo backend -> AnnBoolExp backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf
AVRelationship :: RelInfo backend -> RelationshipFilters backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf
AVComputedField :: AnnComputedFieldBoolExp backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf
AVAggregationPredicates :: AggregationPredicates backend leaf -> AnnBoolExpFld (backend :: BackendType) leaf

-- | This type represents a boolean expression over a relationship. In
--   addition to the actual user-specified predicate, we need to also
--   consider the permissions of the target table.
--   
--   Because the permissions may include column-comparison-operators, they
--   need to be translated in the context of the table they apply to. Thus
--   we keep the permissions and filters separate.
data RelationshipFilters (backend :: BackendType) leaf
RelationshipFilters :: AnnBoolExp backend leaf -> AnnBoolExp backend leaf -> RelationshipFilters (backend :: BackendType) leaf
[rfTargetTablePermissions] :: RelationshipFilters (backend :: BackendType) leaf -> AnnBoolExp backend leaf
[rfFilter] :: RelationshipFilters (backend :: BackendType) leaf -> AnnBoolExp backend leaf

-- | A simple alias for the kind of boolean expressions used in the schema,
--   that ties together <a>GBoolExp</a>, <a>OpExpG</a>, and
--   <a>AnnBoolExpFld</a>.
type AnnBoolExp backend scalar = GBoolExp backend (AnnBoolExpFld backend scalar)
type AnnBoolExpFldSQL backend = AnnBoolExpFld backend (SQLExpression backend)
type AnnBoolExpSQL backend = AnnBoolExp backend (SQLExpression backend)
type AnnBoolExpPartialSQL backend = AnnBoolExp backend (PartialSQLExp backend)
annBoolExpTrue :: AnnBoolExp backend scalar
andAnnBoolExps :: AnnBoolExp backend scalar -> AnnBoolExp backend scalar -> AnnBoolExp backend scalar

-- | Operand for STDWithin opoerator
data DWithinGeomOp field
DWithinGeomOp :: field -> field -> DWithinGeomOp field
[dwgeomDistance] :: DWithinGeomOp field -> field
[dwgeomFrom] :: DWithinGeomOp field -> field

-- | Operand for STDWithin opoerator
data DWithinGeogOp field
DWithinGeogOp :: field -> field -> field -> DWithinGeogOp field
[dwgeogDistance] :: DWithinGeogOp field -> field
[dwgeogFrom] :: DWithinGeogOp field -> field
[dwgeogUseSpheroid] :: DWithinGeogOp field -> field

-- | Operand for STIntersect
data STIntersectsNbandGeommin field
STIntersectsNbandGeommin :: field -> field -> STIntersectsNbandGeommin field
[singNband] :: STIntersectsNbandGeommin field -> field
[singGeommin] :: STIntersectsNbandGeommin field -> field

-- | Operand for STIntersect
data STIntersectsGeomminNband field
STIntersectsGeomminNband :: field -> Maybe field -> STIntersectsGeomminNband field
[signGeommin] :: STIntersectsGeomminNband field -> field
[signNband] :: STIntersectsGeomminNband field -> Maybe field

-- | This captures a boolean expression where, if it is false, some
--   associated data needs to be redacted (in practice, nulled out) because
--   the user doesn't have access to it. Alternatively, "no redaction" is
--   explicitly defined, which is used as an optimization to avoid
--   evaluating a boolexp if unnecessary (as opposed to defining a boolean
--   exp which always evaluates to true).
data AnnRedactionExp b v
NoRedaction :: AnnRedactionExp b v
RedactIfFalse :: GBoolExp b (AnnBoolExpFld b v) -> AnnRedactionExp b v
type AnnRedactionExpPartialSQL b = AnnRedactionExp b (PartialSQLExp b)
type AnnRedactionExpUnpreparedValue b = AnnRedactionExp b (UnpreparedValue b)
type PreSetColsG b v = HashMap (Column b) v
type PreSetColsPartial b = HashMap (Column b) (PartialSQLExp b)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance (Hasura.RQL.Types.Backend.Backend backend, Data.Data.Data field) => Data.Data.Data (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.GBoolExp backend)
instance Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.GBoolExp backend)
instance GHC.Base.Functor (Hasura.RQL.IR.BoolExp.GBoolExp backend)
instance (Hasura.RQL.Types.Backend.Backend backend, GHC.Classes.Eq field) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance (Hasura.RQL.Types.Backend.Backend backend, GHC.Show.Show field) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.GExists backend field)
instance Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.GExists backend)
instance Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.GExists backend)
instance GHC.Base.Functor (Hasura.RQL.IR.BoolExp.GExists backend)
instance GHC.Generics.Generic Hasura.RQL.IR.BoolExp.ColExp
instance Data.Data.Data Hasura.RQL.IR.BoolExp.ColExp
instance GHC.Classes.Eq Hasura.RQL.IR.BoolExp.ColExp
instance GHC.Show.Show Hasura.RQL.IR.BoolExp.ColExp
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.BoolExp b)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.BoolExp.BoolExp b)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.PartialSQLExp backend)
instance GHC.Generics.Generic Hasura.RQL.IR.BoolExp.ComparisonNullability
instance GHC.Generics.Generic Hasura.RQL.IR.BoolExp.RootOrCurrent
instance GHC.Show.Show Hasura.RQL.IR.BoolExp.RootOrCurrent
instance GHC.Classes.Eq Hasura.RQL.IR.BoolExp.RootOrCurrent
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.OpExpG backend field)
instance Data.Data.Data field => Data.Data.Data (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.DWithinGeomOp
instance Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.DWithinGeomOp
instance GHC.Base.Functor Hasura.RQL.IR.BoolExp.DWithinGeomOp
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance GHC.Show.Show field => GHC.Show.Show (Hasura.RQL.IR.BoolExp.DWithinGeomOp field)
instance Data.Data.Data field => Data.Data.Data (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.DWithinGeogOp
instance Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.DWithinGeogOp
instance GHC.Base.Functor Hasura.RQL.IR.BoolExp.DWithinGeogOp
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance GHC.Show.Show field => GHC.Show.Show (Hasura.RQL.IR.BoolExp.DWithinGeogOp field)
instance Data.Data.Data field => Data.Data.Data (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin
instance Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin
instance GHC.Base.Functor Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance GHC.Show.Show field => GHC.Show.Show (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Data.Data.Data field => Data.Data.Data (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance Data.Traversable.Traversable Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband
instance Data.Foldable.Foldable Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband
instance GHC.Base.Functor Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance GHC.Show.Show field => GHC.Show.Show (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend scalar)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp backend)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp backend scalar)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.RelationshipFilters backend leaf)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.RelationshipFilters backend)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.RelationshipFilters backend)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.RelationshipFilters backend)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend leaf)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend)
instance Hasura.RQL.Types.Backend.Backend backend => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend)
instance Hasura.RQL.Types.Backend.Backend backend => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.AnnBoolExpFld backend)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AnnRedactionExp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AnnRedactionExp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.AnnRedactionExp b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Data.Data a) => Data.Data.Data (Hasura.RQL.IR.BoolExp.GExists b a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance GHC.Show.Show Hasura.RQL.IR.BoolExp.ComparisonNullability
instance GHC.Classes.Eq Hasura.RQL.IR.BoolExp.ComparisonNullability
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.OpExpG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.OpExpG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.OpExpG b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Backend.BooleanOperators b a), GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Backend.BooleanOperators b a), GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.OpExpG b a)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), GHC.Show.Show (Hasura.RQL.IR.BoolExp.OpExpG b a)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a), GHC.Classes.Eq (Hasura.Function.Cache.FunctionArgsExp b a)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a), GHC.Show.Show (Hasura.Function.Cache.FunctionArgsExp b a)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Backend.AggregationPredicates b a), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.OpExpG b a)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Backend.AggregationPredicates b a), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a), GHC.Show.Show (Hasura.RQL.IR.BoolExp.OpExpG b a)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b a)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.RelationshipFilters b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b a)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.RelationshipFilters b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.GBoolExp b (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b v))) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.GBoolExp b (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b v))) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.OpExpG b a)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.OpExpG b a)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a), Control.DeepSeq.NFData (Hasura.Function.Cache.FunctionArgsExp b a)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.ComputedFieldBoolExp b a), Data.Hashable.Class.Hashable (Hasura.Function.Cache.FunctionArgsExp b a)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.Types.Backend.AggregationPredicates b a), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.OpExpG b a)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.Types.Backend.AggregationPredicates b a), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.OpExpG b a)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.Types.Backend.AggregationPredicates b a), Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.OpExpG b a), Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExp b a)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.RelationshipFilters b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b a)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.RelationshipFilters b a)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExp backend leaf) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.RelationshipFilters backend leaf)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.GBoolExp b (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b v))) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.GBoolExp b (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b v))) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.GBoolExp b (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b v))) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband a)
instance Data.Aeson.Types.FromJSON.FromJSON field => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance Data.Aeson.Types.ToJSON.ToJSON field => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.STIntersectsGeomminNband field)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin a)
instance Data.Aeson.Types.FromJSON.FromJSON field => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Data.Aeson.Types.ToJSON.ToJSON field => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.STIntersectsNbandGeommin field)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.DWithinGeogOp a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.DWithinGeogOp a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.DWithinGeogOp a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.DWithinGeogOp a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.DWithinGeomOp a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.DWithinGeomOp a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.DWithinGeomOp a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.DWithinGeomOp a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.Types.Backend.BooleanOperators b a), Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.Types.Backend.BooleanOperators b a), Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.Types.Backend.BooleanOperators b a), Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.OpExpG b a)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.RootOrCurrentColumn b)
instance Control.DeepSeq.NFData Hasura.RQL.IR.BoolExp.RootOrCurrent
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.BoolExp.RootOrCurrent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.IR.BoolExp.RootOrCurrent
instance Control.DeepSeq.NFData Hasura.RQL.IR.BoolExp.ComparisonNullability
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.BoolExp.ComparisonNullability
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.IR.BoolExp.ComparisonNullability
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.PartialSQLExp b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.IR.BoolExp.BoolExp b)
instance Control.DeepSeq.NFData Hasura.RQL.IR.BoolExp.ColExp
instance Data.Aeson.Extended.FromJSONKeyValue Hasura.RQL.IR.BoolExp.ColExp
instance Data.Aeson.Extended.ToJSONKeyValue Hasura.RQL.IR.BoolExp.ColExp
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Data.Data a) => Control.Lens.Plated.Plated (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.FromJSONKeyValue a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend backend, Data.Aeson.Extended.ToJSONKeyValue field) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.GBoolExp backend field)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Data.Data a) => Control.Lens.Plated.Plated (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.FromJSONKeyValue a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.IR.BoolExp.GExists b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.ToJSONKeyValue a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.GExists b a)

module Hasura.RQL.Types.Permission
data PermType
PTInsert :: PermType
PTSelect :: PermType
PTUpdate :: PermType
PTDelete :: PermType
permTypeToCode :: PermType -> Text
data PermColSpec b
PCStar :: PermColSpec b
PCCols :: [Column b] -> PermColSpec b
data PermDef (b :: BackendType) (perm :: BackendType -> Type)
PermDef :: RoleName -> PermDefPermission b perm -> Maybe Text -> PermDef (b :: BackendType) (perm :: BackendType -> Type)
[_pdRole] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> RoleName
[_pdPermission] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> PermDefPermission b perm
[_pdComment] :: PermDef (b :: BackendType) (perm :: BackendType -> Type) -> Maybe Text

-- | The permission data as it appears in a <a>PermDef</a>. Since this type
--   is a GADT it facilitates that values which are polymorphic may
--   re-discover its specific type of permission by case analysis.
--   
--   The fact that permission types are tracked in types are more
--   accidental than intentional and something we want to move away from,
--   see <a>https://github.com/hasura/graphql-engine-mono/issues/4076</a>.
data PermDefPermission (b :: BackendType) (perm :: BackendType -> Type)
[SelPerm'] :: SelPerm b -> PermDefPermission b SelPerm
[InsPerm'] :: InsPerm b -> PermDefPermission b InsPerm
[UpdPerm'] :: UpdPerm b -> PermDefPermission b UpdPerm
[DelPerm'] :: DelPerm b -> PermDefPermission b DelPerm
unPermDefPermission :: PermDefPermission b perm -> perm b
reflectPermDefPermission :: PermDefPermission b a -> PermType
data QueryRootFieldType
QRFTSelect :: QueryRootFieldType
QRFTSelectByPk :: QueryRootFieldType
QRFTSelectAggregate :: QueryRootFieldType
data SubscriptionRootFieldType
SRFTSelect :: SubscriptionRootFieldType
SRFTSelectByPk :: SubscriptionRootFieldType
SRFTSelectAggregate :: SubscriptionRootFieldType
SRFTSelectStream :: SubscriptionRootFieldType
data InsPerm (b :: BackendType)
InsPerm :: BoolExp b -> Maybe (ColumnValues b Value) -> Maybe (PermColSpec b) -> Bool -> Maybe (ValidateInput InputWebhook) -> InsPerm (b :: BackendType)
[ipCheck] :: InsPerm (b :: BackendType) -> BoolExp b
[ipSet] :: InsPerm (b :: BackendType) -> Maybe (ColumnValues b Value)
[ipColumns] :: InsPerm (b :: BackendType) -> Maybe (PermColSpec b)
[ipBackendOnly] :: InsPerm (b :: BackendType) -> Bool
[ipValidateInput] :: InsPerm (b :: BackendType) -> Maybe (ValidateInput InputWebhook)
type InsPermDef b = PermDef b InsPerm
data AllowedRootFields rootFieldType
ARFAllowAllRootFields :: AllowedRootFields rootFieldType
ARFAllowConfiguredRootFields :: HashSet rootFieldType -> AllowedRootFields rootFieldType
isRootFieldAllowed :: Eq rootField => rootField -> AllowedRootFields rootField -> Bool
data ValidateInputHttpDefinition webhook
ValidateInputHttpDefinition :: webhook -> [HeaderConf] -> Timeout -> Bool -> ValidateInputHttpDefinition webhook
[_vihdUrl] :: ValidateInputHttpDefinition webhook -> webhook
[_vihdHeaders] :: ValidateInputHttpDefinition webhook -> [HeaderConf]
[_vihdTimeout] :: ValidateInputHttpDefinition webhook -> Timeout
[_vihdForwardClientHeaders] :: ValidateInputHttpDefinition webhook -> Bool
data ValidateInput webhook
VIHttp :: ValidateInputHttpDefinition webhook -> ValidateInput webhook
data SelPerm (b :: BackendType)
SelPerm :: PermColSpec b -> BoolExp b -> Maybe Int -> Bool -> [ComputedFieldName] -> AllowedRootFields QueryRootFieldType -> AllowedRootFields SubscriptionRootFieldType -> SelPerm (b :: BackendType)

-- | Allowed columns
[spColumns] :: SelPerm (b :: BackendType) -> PermColSpec b

-- | Filter expression
[spFilter] :: SelPerm (b :: BackendType) -> BoolExp b

-- | Limit value
[spLimit] :: SelPerm (b :: BackendType) -> Maybe Int

-- | Allow aggregation
[spAllowAggregations] :: SelPerm (b :: BackendType) -> Bool

-- | Allowed computed fields which should not include the fields returning
--   rows of existing table.
[spComputedFields] :: SelPerm (b :: BackendType) -> [ComputedFieldName]
[spAllowedQueryRootFields] :: SelPerm (b :: BackendType) -> AllowedRootFields QueryRootFieldType
[spAllowedSubscriptionRootFields] :: SelPerm (b :: BackendType) -> AllowedRootFields SubscriptionRootFieldType
type SelPermDef b = PermDef b SelPerm
data DelPerm (b :: BackendType)
DelPerm :: BoolExp b -> Bool -> Maybe (ValidateInput InputWebhook) -> DelPerm (b :: BackendType)
[dcFilter] :: DelPerm (b :: BackendType) -> BoolExp b
[dcBackendOnly] :: DelPerm (b :: BackendType) -> Bool
[dcValidateInput] :: DelPerm (b :: BackendType) -> Maybe (ValidateInput InputWebhook)
type DelPermDef b = PermDef b DelPerm
data UpdPerm (b :: BackendType)
UpdPerm :: PermColSpec b -> Maybe (ColumnValues b Value) -> BoolExp b -> Maybe (BoolExp b) -> Bool -> Maybe (ValidateInput InputWebhook) -> UpdPerm (b :: BackendType)
[ucColumns] :: UpdPerm (b :: BackendType) -> PermColSpec b
[ucSet] :: UpdPerm (b :: BackendType) -> Maybe (ColumnValues b Value)
[ucFilter] :: UpdPerm (b :: BackendType) -> BoolExp b

-- | Check expression, which must be true after update. This is optional
--   because we don't want to break the v1 API but Nothing should be
--   equivalent to the expression which always returns true.
[ucCheck] :: UpdPerm (b :: BackendType) -> Maybe (BoolExp b)
[ucBackendOnly] :: UpdPerm (b :: BackendType) -> Bool
[ucValidateInput] :: UpdPerm (b :: BackendType) -> Maybe (ValidateInput InputWebhook)
type UpdPermDef b = PermDef b UpdPerm
pdRole :: forall b_a8TWC perm_a8TWD. Lens' (PermDef b_a8TWC perm_a8TWD) RoleName
pdPermission :: forall b_a8TWC perm_a8TWD b_a96mI perm_a96mJ. Lens (PermDef b_a8TWC perm_a8TWD) (PermDef b_a96mI perm_a96mJ) (PermDefPermission b_a8TWC perm_a8TWD) (PermDefPermission b_a96mI perm_a96mJ)
pdComment :: forall b_a8TWC perm_a8TWD. Lens' (PermDef b_a8TWC perm_a8TWD) (Maybe Text)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.SelPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.InsPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.UpdPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b Hasura.RQL.Types.Permission.DelPerm)
instance GHC.Generics.Generic Hasura.RQL.Types.Permission.PermType
instance GHC.Classes.Ord Hasura.RQL.Types.Permission.PermType
instance GHC.Classes.Eq Hasura.RQL.Types.Permission.PermType
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.PermColSpec b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Permission.QueryRootFieldType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Permission.QueryRootFieldType
instance GHC.Enum.Bounded Hasura.RQL.Types.Permission.QueryRootFieldType
instance GHC.Enum.Enum Hasura.RQL.Types.Permission.QueryRootFieldType
instance GHC.Generics.Generic Hasura.RQL.Types.Permission.QueryRootFieldType
instance GHC.Classes.Eq Hasura.RQL.Types.Permission.QueryRootFieldType
instance GHC.Show.Show Hasura.RQL.Types.Permission.QueryRootFieldType
instance Control.DeepSeq.NFData Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Enum.Bounded Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Enum.Enum Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Generics.Generic Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Classes.Eq Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Show.Show Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance GHC.Classes.Eq rootFieldType => GHC.Classes.Eq (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance GHC.Show.Show rootFieldType => GHC.Show.Show (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance Data.Traversable.Traversable Hasura.RQL.Types.Permission.ValidateInputHttpDefinition
instance Data.Foldable.Foldable Hasura.RQL.Types.Permission.ValidateInputHttpDefinition
instance GHC.Base.Functor Hasura.RQL.Types.Permission.ValidateInputHttpDefinition
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance GHC.Classes.Eq webhook => GHC.Classes.Eq (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance GHC.Show.Show webhook => GHC.Show.Show (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance Data.Traversable.Traversable Hasura.RQL.Types.Permission.ValidateInput
instance Data.Foldable.Foldable Hasura.RQL.Types.Permission.ValidateInput
instance GHC.Base.Functor Hasura.RQL.Types.Permission.ValidateInput
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance GHC.Classes.Eq webhook => GHC.Classes.Eq (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance GHC.Show.Show webhook => GHC.Show.Show (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.InsPerm b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.SelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.SelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.SelPerm b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.DelPerm b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.UpdPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.UpdPerm b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.UpdPerm b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.PermColSpec b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.PermColSpec b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (perm b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.PermDef b perm)
instance Hasura.RQL.Types.Backend.Backend b => Hasura.RQL.Types.Common.ToAesonPairs (Hasura.RQL.Types.Permission.PermDef b perm)
instance (Hasura.RQL.Types.Backend.Backend b, Autodocodec.Class.HasCodec (perm b), Hasura.RQL.Types.Permission.IsPerm perm) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.PermDef b perm)
instance (Hasura.RQL.Types.Backend.Backend b, Autodocodec.Class.HasCodec (perm b), Hasura.RQL.Types.Permission.IsPerm perm) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance Hasura.RQL.Types.Permission.IsPerm Hasura.RQL.Types.Permission.SelPerm
instance Hasura.RQL.Types.Permission.IsPerm Hasura.RQL.Types.Permission.InsPerm
instance Hasura.RQL.Types.Permission.IsPerm Hasura.RQL.Types.Permission.UpdPerm
instance Hasura.RQL.Types.Permission.IsPerm Hasura.RQL.Types.Permission.DelPerm
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.SelPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.InsPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.UpdPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDefPermission b Hasura.RQL.Types.Permission.DelPerm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.PermDefPermission b perm)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.UpdPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.UpdPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.UpdPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.DelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.SelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.SelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.SelPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.InsPerm b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.InsPerm b)
instance Control.DeepSeq.NFData webhook => Control.DeepSeq.NFData (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance Data.Aeson.Types.FromJSON.FromJSON webhook => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance Data.Aeson.Types.ToJSON.ToJSON webhook => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance (Autodocodec.Class.HasCodec webhook, Data.Typeable.Internal.Typeable webhook) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.ValidateInput webhook)
instance Control.DeepSeq.NFData webhook => Control.DeepSeq.NFData (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance Data.Aeson.Types.FromJSON.FromJSON webhook => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance Data.Aeson.Types.ToJSON.ToJSON webhook => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance Autodocodec.Class.HasCodec webhook => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.ValidateInputHttpDefinition webhook)
instance Control.DeepSeq.NFData rootFieldType => Control.DeepSeq.NFData (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance Data.Aeson.Types.ToJSON.ToJSON rootFieldType => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance (Data.Hashable.Class.Hashable rootFieldType, Autodocodec.Class.HasCodec rootFieldType) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance GHC.Base.Semigroup (Data.HashSet.Internal.HashSet rootFieldType) => GHC.Base.Semigroup (Hasura.RQL.Types.Permission.AllowedRootFields rootFieldType)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Permission.SubscriptionRootFieldType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Permission.QueryRootFieldType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Permission.QueryRootFieldType
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Permission.QueryRootFieldType
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Permission.PermColSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermColSpec b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Permission.PermColSpec b)
instance Control.DeepSeq.NFData Hasura.RQL.Types.Permission.PermType
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Permission.PermType
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Permission.PermType
instance GHC.Show.Show Hasura.RQL.Types.Permission.PermType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Permission.PermType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Permission.PermType

module Hasura.LogicalModelResolver.Metadata

-- | the name of a Logical Model, or an inline Logical Model
data LogicalModelIdentifier (b :: BackendType)
LMILogicalModelName :: LogicalModelName -> LogicalModelIdentifier (b :: BackendType)
LMIInlineLogicalModel :: InlineLogicalModelMetadata b -> LogicalModelIdentifier (b :: BackendType)

-- | Description of an inline logical model to use in metadata (before
--   schema cache) this has no name - it is up to the resolving user (ie,
--   the Native Query, etc) to give the generated type a name
data InlineLogicalModelMetadata (b :: BackendType)
InlineLogicalModelMetadata :: InsOrdHashMap (Column b) (LogicalModelField b) -> InsOrdHashMap RoleName (SelPermDef b) -> InlineLogicalModelMetadata (b :: BackendType)
[_ilmmFields] :: InlineLogicalModelMetadata (b :: BackendType) -> InsOrdHashMap (Column b) (LogicalModelField b)
[_ilmmSelectPermissions] :: InlineLogicalModelMetadata (b :: BackendType) -> InsOrdHashMap RoleName (SelPermDef b)
instance GHC.Generics.Generic (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)
instance GHC.Generics.Generic (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModelResolver.Metadata.LogicalModelIdentifier b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModelResolver.Metadata.InlineLogicalModelMetadata b)


-- | Metadata representation of a native query in the metadata, as well as
--   a parser and prettyprinter for the query code.
module Hasura.NativeQuery.Metadata

-- | The representation of native queries within the metadata structure.
data NativeQueryMetadata (b :: BackendType)
NativeQueryMetadata :: NativeQueryName -> InterpolatedQuery ArgumentName -> LogicalModelIdentifier b -> HashMap ArgumentName (NullableScalarType b) -> Relationships (RelDef (RelManualConfig b)) -> Relationships (RelDef (RelManualConfig b)) -> Maybe Text -> NativeQueryMetadata (b :: BackendType)
[_nqmRootFieldName] :: NativeQueryMetadata (b :: BackendType) -> NativeQueryName
[_nqmCode] :: NativeQueryMetadata (b :: BackendType) -> InterpolatedQuery ArgumentName
[_nqmReturns] :: NativeQueryMetadata (b :: BackendType) -> LogicalModelIdentifier b
[_nqmArguments] :: NativeQueryMetadata (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[_nqmArrayRelationships] :: NativeQueryMetadata (b :: BackendType) -> Relationships (RelDef (RelManualConfig b))
[_nqmObjectRelationships] :: NativeQueryMetadata (b :: BackendType) -> Relationships (RelDef (RelManualConfig b))
[_nqmDescription] :: NativeQueryMetadata (b :: BackendType) -> Maybe Text

-- | A wrapper to tie something to a particular native query. Specifically,
--   it assumes the underlying <tt>_wlmInfo</tt> is represented as an
--   object, and adds two keys to that object: <tt>source</tt> and
--   <tt>root_field_name</tt>.
data WithNativeQuery a
WithNativeQuery :: SourceName -> NativeQueryName -> a -> WithNativeQuery a
[_wnqSource] :: WithNativeQuery a -> SourceName
[_wnqName] :: WithNativeQuery a -> NativeQueryName
[_wnqInfo] :: WithNativeQuery a -> a
instance GHC.Generics.Generic (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.NativeQuery.Metadata.WithNativeQuery a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.NativeQuery.Metadata.WithNativeQuery a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.NativeQuery.Metadata.WithNativeQuery a)
instance Hasura.RQL.Types.Common.ToAesonPairs a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.Metadata.WithNativeQuery a)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.NativeQuery.Metadata.NativeQueryMetadata b)


-- | Generic validation of native queries while tracking them.
module Hasura.NativeQuery.Validation

-- | Check that the set of declared arguments and the set of used arguments
--   (in the code) is the same.
validateArgumentDeclaration :: (MonadIO m, MonadError QErr m) => NativeQueryMetadata b -> m ()


-- | The RQL IR representation of an invocation of a native query.
module Hasura.NativeQuery.IR

-- | The RQL IR representation of an invocation of a native query.
data NativeQuery b field
NativeQuery :: NativeQueryName -> InterpolatedQuery field -> LogicalModel b -> NativeQuery b field

-- | The graphql name of the native query.
[nqRootFieldName] :: NativeQuery b field -> NativeQueryName

-- | The raw sql to use in the query
[nqInterpolatedQuery] :: NativeQuery b field -> InterpolatedQuery field

-- | The return type of the native query
[nqLogicalModel] :: NativeQuery b field -> LogicalModel b
instance GHC.Generics.Generic (Hasura.NativeQuery.IR.NativeQuery b field)
instance Data.Traversable.Traversable (Hasura.NativeQuery.IR.NativeQuery b)
instance Data.Foldable.Foldable (Hasura.NativeQuery.IR.NativeQuery b)
instance GHC.Base.Functor (Hasura.NativeQuery.IR.NativeQuery b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq field) => GHC.Classes.Eq (Hasura.NativeQuery.IR.NativeQuery b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show field) => GHC.Show.Show (Hasura.NativeQuery.IR.NativeQuery b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON field, field GHC.Types.~ Hasura.LogicalModelResolver.Types.ArgumentName) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.IR.NativeQuery b field)


-- | Postgres SQL DML
--   
--   Provide types and combinators for defining Postgres SQL queries and
--   mutations.
module Hasura.Backends.Postgres.SQL.DML

-- | An select statement that does not require mutation CTEs.
--   
--   See <a>SelectWithG</a> or <a>SelectWithG</a> for select statements
--   with mutations as CTEs.
data Select
Select :: [(TableAlias, InnerCTE)] -> Maybe DistinctExpr -> [Extractor] -> Maybe FromExp -> Maybe WhereFrag -> Maybe GroupByExp -> Maybe HavingExp -> Maybe OrderByExp -> Maybe LimitExp -> Maybe OffsetExp -> Select

-- | An empty select statement.
mkSelect :: Select

-- | A dummy select list to avoid an empty select list, which doesn't work
--   for cockroach db. This is just the value <tt>1</tt> without an alias.
dummySelectList :: [Extractor]
newtype LimitExp
LimitExp :: SQLExp -> LimitExp
newtype OffsetExp
OffsetExp :: SQLExp -> OffsetExp
newtype OrderByExp
OrderByExp :: NonEmpty OrderByItem -> OrderByExp
data OrderByItem
OrderByItem :: SQLExp -> Maybe OrderType -> Maybe NullsOrder -> OrderByItem

-- | Order by ascending or descending
data OrderType
OTAsc :: OrderType
OTDesc :: OrderType
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder
newtype GroupByExp
GroupByExp :: [SQLExp] -> GroupByExp
newtype FromExp
FromExp :: [FromItem] -> FromExp
mkIdenFromExp :: TableIdentifier -> FromExp
mkSimpleFromExp :: QualifiedTable -> FromExp
mkSelFromExp :: Bool -> Select -> TableName -> FromItem
mkRowExp :: [Extractor] -> SQLExp
newtype HavingExp
HavingExp :: BoolExp -> HavingExp
newtype WhereFrag
WhereFrag :: BoolExp -> WhereFrag
mkSIdenExp :: IsIdentifier a => a -> SQLExp
mkQIdenExp :: IsIdentifier b => TableIdentifier -> b -> SQLExp
data Qual
QualifiedIdentifier :: TableIdentifier -> Maybe TypeAnn -> Qual
QualTable :: QualifiedTable -> Qual
QualVar :: Text -> Qual
mkQual :: QualifiedTable -> Qual
mkQIdentifier :: IsIdentifier b => TableIdentifier -> b -> QIdentifier
mkQIdentifierTable :: IsIdentifier a => QualifiedTable -> a -> QIdentifier
mkIdentifierSQLExp :: forall a. IsIdentifier a => Qual -> a -> SQLExp
data QIdentifier
QIdentifier :: Qual -> Identifier -> QIdentifier
data ColumnOp
ColumnOp :: SQLOp -> SQLExp -> ColumnOp
[_colOp] :: ColumnOp -> SQLOp
[_colExp] :: ColumnOp -> SQLExp
newtype SQLOp
SQLOp :: Text -> SQLOp
incOp :: SQLOp
mulOp :: SQLOp
jsonbPathOp :: SQLOp
jsonbConcatOp :: SQLOp
jsonbDeleteOp :: SQLOp
jsonbDeleteAtPathOp :: SQLOp
newtype TypeAnn
TypeAnn :: Text -> TypeAnn
mkTypeAnn :: CollectableType PGScalarType -> TypeAnn
intTypeAnn :: TypeAnn
numericTypeAnn :: TypeAnn
textTypeAnn :: TypeAnn
textArrTypeAnn :: TypeAnn
jsonTypeAnn :: TypeAnn
jsonbTypeAnn :: TypeAnn
boolTypeAnn :: TypeAnn
data CountType columnType
CTStar :: CountType columnType
CTSimple :: [columnType] -> CountType columnType
CTDistinct :: [columnType] -> CountType columnType
newtype TupleExp
TupleExp :: [SQLExp] -> TupleExp
data SQLExp
SEPrep :: Int -> SQLExp
SENull :: SQLExp
SELit :: Text -> SQLExp
SEUnsafe :: Text -> SQLExp
SESelect :: Select -> SQLExp

-- | all fields (<tt>*</tt>) or all fields from relation (<tt>iden.*</tt>)
SEStar :: Maybe Qual -> SQLExp

-- | A column name
SEIdentifier :: Identifier -> SQLExp

-- | SEIdentifier and SERowIdentifier are distinguished for easier rewrite
--   rules
SERowIdentifier :: Identifier -> SQLExp

-- | A qualified column name
SEQIdentifier :: QIdentifier -> SQLExp

-- | this is used to apply a sql function to an expression. The <a>Text</a>
--   is the function name
SEFnApp :: Text -> [SQLExp] -> Maybe OrderByExp -> SQLExp
SEOpApp :: SQLOp -> [SQLExp] -> SQLExp
SETyAnn :: SQLExp -> TypeAnn -> SQLExp
SECond :: BoolExp -> SQLExp -> SQLExp -> SQLExp
SEBool :: BoolExp -> SQLExp
SEExcluded :: Identifier -> SQLExp
SEArray :: [SQLExp] -> SQLExp
SEArrayIndex :: SQLExp -> SQLExp -> SQLExp
SETuple :: TupleExp -> SQLExp
SECount :: CountType QIdentifier -> SQLExp
SENamedArg :: Identifier -> SQLExp -> SQLExp
SEFunction :: FunctionExp -> SQLExp

-- | Represents an alias assignment for a column
newtype ColumnAlias
ColumnAlias :: Identifier -> ColumnAlias
[getColumnAlias] :: ColumnAlias -> Identifier
mkColumnAlias :: Text -> ColumnAlias
tableIdentifierToColumnAlias :: TableIdentifier -> ColumnAlias
toColumnAlias :: IsIdentifier a => a -> ColumnAlias

-- | Represents an alias assignment for a table, relation or row
newtype TableAlias
TableAlias :: Identifier -> TableAlias
[getTableAlias] :: TableAlias -> Identifier

-- | Create a table alias.
mkTableAlias :: Text -> TableAlias

-- | Create a table identifier from a table alias.
tableAliasToIdentifier :: TableAlias -> TableIdentifier
toTableAlias :: IsIdentifier a => a -> TableAlias
countStar :: SQLExp
intToSQLExp :: Int -> SQLExp
int64ToSQLExp :: Int64 -> SQLExp

-- | Extractor can be used to apply Postgres alias to a column
data Extractor
Extractor :: SQLExp -> Maybe ColumnAlias -> Extractor
mkSQLOpExp :: SQLOp -> SQLExp -> SQLExp -> SQLExp
columnDefaultValue :: SQLExp
handleIfNull :: SQLExp -> SQLExp -> SQLExp
applyJsonBuildObj :: [SQLExp] -> SQLExp
applyJsonBuildArray :: [SQLExp] -> SQLExp
applyRowToJson :: [Extractor] -> SQLExp
applyUppercase :: SQLExp -> SQLExp
mkExtr :: IsIdentifier a => a -> Extractor
data DistinctExpr
DistinctSimple :: DistinctExpr
DistinctOn :: [SQLExp] -> DistinctExpr
data FunctionArgs
FunctionArgs :: [SQLExp] -> HashMap Text SQLExp -> FunctionArgs
data FunctionDefinitionListItem
FunctionDefinitionListItem :: ColumnAlias -> PGScalarType -> FunctionDefinitionListItem
[_dliColumn] :: FunctionDefinitionListItem -> ColumnAlias
[_dliType] :: FunctionDefinitionListItem -> PGScalarType

-- | We can alias the result of a function call that returns a <tt>SETOF
--   RECORD</tt> by naming the result relation, and the columns and their
--   types. For example:
--   
--   <pre>
--   SELECT * FROM
--   function_returns_record(arg1, arg2 ...) AS relation_name(column_1 column_1_type, column_2 column_2_type, ...)
--   </pre>
--   
--   Note: a function that returns a table (instead of a record) cannot
--   name the types as seen in the above example.
data FunctionAlias
FunctionAlias :: TableAlias -> Maybe [FunctionDefinitionListItem] -> FunctionAlias

-- | Construct a function alias which represents the "relation signature"
--   for the function invocation, Using the function name as the relation
--   name, and the columns as the relation schema.
mkFunctionAlias :: QualifiedObject FunctionName -> Maybe [(ColumnAlias, PGScalarType)] -> FunctionAlias

-- | A function call
data FunctionExp
FunctionExp :: QualifiedFunction -> FunctionArgs -> Maybe FunctionAlias -> FunctionExp

-- | See <tt>from_item</tt> in
--   <a>https://www.postgresql.org/docs/current/sql-select.html</a>
data FromItem

-- | A simple table
FISimple :: QualifiedTable -> Maybe TableAlias -> FromItem

-- | An identifier (from CTEs)
FIIdentifier :: TableIdentifier -> FromItem

-- | A function call (that should return a relation (<tt>SETOF</tt>) and
--   not a scalar)
FIFunc :: FunctionExp -> FromItem

-- | <tt>unnest</tt> converts (an) array(s) to a relation.
--   
--   We have: * The unnest function arguments * The relation alias * A list
--   of column aliases
--   
--   See <tt>unnest</tt> in
--   <a>https://www.postgresql.org/docs/current/functions-array.html</a>.
FIUnnest :: [SQLExp] -> TableAlias -> [ColumnAlias] -> FromItem
FISelect :: Lateral -> Select -> TableAlias -> FromItem
FISelectWith :: Lateral -> SelectWithG Select -> TableAlias -> FromItem
FIValues :: ValuesExp -> TableAlias -> Maybe [ColumnAlias] -> FromItem
FIJoin :: JoinExpr -> FromItem
mkSelFromItem :: Select -> TableAlias -> FromItem
mkSelectWithFromItem :: SelectWithG Select -> TableAlias -> FromItem
mkLateralFromItem :: Select -> TableAlias -> FromItem
newtype Lateral
Lateral :: Bool -> Lateral
data JoinExpr
JoinExpr :: FromItem -> JoinType -> FromItem -> JoinCond -> JoinExpr
data JoinType
Inner :: JoinType
LeftOuter :: JoinType
data JoinCond
JoinOn :: BoolExp -> JoinCond
JoinUsing :: [Identifier] -> JoinCond
data BoolExp
BELit :: Bool -> BoolExp
BEBin :: BinOp -> BoolExp -> BoolExp -> BoolExp
BENot :: BoolExp -> BoolExp
BECompare :: CompareOp -> SQLExp -> SQLExp -> BoolExp
BECompareAny :: CompareOp -> SQLExp -> SQLExp -> BoolExp
BENull :: SQLExp -> BoolExp
BENotNull :: SQLExp -> BoolExp
BEExists :: Select -> BoolExp
BEIN :: SQLExp -> [SQLExp] -> BoolExp
BEExp :: SQLExp -> BoolExp
simplifyBoolExp :: BoolExp -> BoolExp
mkExists :: FromItem -> BoolExp -> BoolExp
data BinOp
AndOp :: BinOp
OrOp :: BinOp
data CompareOp
SEQ :: CompareOp
SGT :: CompareOp
SLT :: CompareOp
SNE :: CompareOp
SGTE :: CompareOp
SLTE :: CompareOp
SLIKE :: CompareOp
SNLIKE :: CompareOp
SILIKE :: CompareOp
SNILIKE :: CompareOp
SSIMILAR :: CompareOp
SNSIMILAR :: CompareOp
SREGEX :: CompareOp
SIREGEX :: CompareOp
SNREGEX :: CompareOp
SNIREGEX :: CompareOp
SContains :: CompareOp
SContainedIn :: CompareOp
SHasKey :: CompareOp
SHasKeysAny :: CompareOp
SHasKeysAll :: CompareOp
SMatchesFulltext :: CompareOp
data SQLDelete
SQLDelete :: QualifiedTable -> Maybe UsingExp -> Maybe WhereFrag -> Maybe RetExp -> SQLDelete
data SQLUpdate
SQLUpdate :: QualifiedTable -> SetExp -> Maybe FromExp -> Maybe WhereFrag -> Maybe RetExp -> SQLUpdate
[upTable] :: SQLUpdate -> QualifiedTable
[upSet] :: SQLUpdate -> SetExp
[upFrom] :: SQLUpdate -> Maybe FromExp
[upWhere] :: SQLUpdate -> Maybe WhereFrag
[upRet] :: SQLUpdate -> Maybe RetExp
newtype SetExp
SetExp :: [SetExpItem] -> SetExp
newtype SetExpItem
SetExpItem :: (PGCol, SQLExp) -> SetExpItem
buildUpsertSetExp :: [PGCol] -> HashMap PGCol SQLExp -> SetExp
newtype RetExp
RetExp :: [Extractor] -> RetExp
selectStar :: Extractor
selectStar' :: Qual -> Extractor
returningStar :: RetExp
data SQLConflictTarget
SQLColumn :: [PGCol] -> SQLConflictTarget
SQLConstraint :: ConstraintName -> SQLConflictTarget
data SQLConflict
DoNothing :: Maybe SQLConflictTarget -> SQLConflict
Update :: SQLConflictTarget -> SetExp -> Maybe WhereFrag -> SQLConflict
newtype ValuesExp
ValuesExp :: [TupleExp] -> ValuesExp
data SQLInsert
SQLInsert :: QualifiedTable -> [PGCol] -> ValuesExp -> Maybe SQLConflict -> Maybe RetExp -> SQLInsert
[siTable] :: SQLInsert -> QualifiedTable
[siCols] :: SQLInsert -> [PGCol]
[siValues] :: SQLInsert -> ValuesExp
[siConflict] :: SQLInsert -> Maybe SQLConflict
[siRet] :: SQLInsert -> Maybe RetExp

-- | Top-level Common Table Expression statement.
--   
--   A top level CTE can be a query or a mutation statement.
--   
--   Postgres supports mutations only in top-level CTEs. See
--   <a>https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-MODIFYING</a>
data TopLevelCTE
CTESelect :: Select -> TopLevelCTE
CTEInsert :: SQLInsert -> TopLevelCTE
CTEUpdate :: SQLUpdate -> TopLevelCTE
CTEDelete :: SQLDelete -> TopLevelCTE
CTEUnsafeRawSQL :: InterpolatedQuery SQLExp -> TopLevelCTE

-- | Represents a common table expresion that can be used in nested
--   selects.
data InnerCTE
ICTESelect :: Select -> InnerCTE
ICTEUnsafeRawSQL :: InterpolatedQuery SQLExp -> InnerCTE

-- | A <tt>SELECT</tt> statement with Common Table Expressions.
--   <a>https://www.postgresql.org/docs/current/queries-with.html</a>
--   
--   These CTEs are determined by the <tt>statement</tt> parameter.
--   Currently they are either <a>TopLevelCTE</a>, which allow for a query
--   or mutation statement, or <a>Select</a>, which only allow for querying
--   results.
--   
--   The distinction is required because Postgres only supports mutations
--   in CTEs at the top level. See
--   <a>https://www.postgresql.org/docs/current/queries-with.html#QUERIES-WITH-MODIFYING</a>
data SelectWithG statement
SelectWith :: [(TableAlias, statement)] -> Select -> SelectWithG statement
[swCTEs] :: SelectWithG statement -> [(TableAlias, statement)]
[swSelect] :: SelectWithG statement -> Select

-- | A top-level select with CTEs.
type SelectWith = SelectWithG TopLevelCTE
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OrderType
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.OrderType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OrderType
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.OrderType
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.SQLOp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.SQLOp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.SQLOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLOp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLOp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Qual
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.Qual
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Qual
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.Qual
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Data.Traversable.Traversable Hasura.Backends.Postgres.SQL.DML.CountType
instance Data.Foldable.Foldable Hasura.Backends.Postgres.SQL.DML.CountType
instance GHC.Base.Functor Hasura.Backends.Postgres.SQL.DML.CountType
instance Data.Data.Data columnType => Data.Data.Data (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance GHC.Classes.Eq columnType => GHC.Classes.Eq (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance GHC.Show.Show columnType => GHC.Show.Show (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Lateral
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Lateral
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Lateral
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Lateral
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.Lateral
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.JoinType
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.JoinType
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.JoinType
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.JoinType
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.BinOp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.BinOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.BinOp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.BinOp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.UsingExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.UsingExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLConflictTarget
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLConflictTarget
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.LimitExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.LimitExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.JoinCond
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.JoinCond
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.JoinCond
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FromItem
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FromItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FromItem
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FromItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FromExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FromExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FromExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FromExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FromExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.HavingExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.HavingExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Extractor
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.Extractor
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Extractor
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.Extractor
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.TupleExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TupleExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.BoolExp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.BoolExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.BoolExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.SQLExp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.SQLExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.Select
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.Select
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.Select
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.Select
instance Data.Data.Data statement => Data.Data.Data (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Classes.Eq statement => GHC.Classes.Eq (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Show.Show statement => GHC.Show.Show (Hasura.Backends.Postgres.SQL.DML.SelectWithG statement)
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SetExpItem
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SetExpItem
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SetExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SetExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLConflict
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLConflict
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.RetExp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.RetExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLUpdate
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLUpdate
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLDelete
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLDelete
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.SQLInsert
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.SQLInsert
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.TopLevelCTE
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.TopLevelCTE
instance Data.Data.Data Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance GHC.Generics.Generic Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.ColumnOp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.TopLevelCTE
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLInsert
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLDelete
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLUpdate
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.RetExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLConflict
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SetExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SetExpItem
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Select
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Select
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.LimitExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OffsetExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OrderByItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OrderByExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.GroupByExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FromExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.HavingExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.WhereFrag
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Select
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.TupleExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Extractor
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Extractor
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Extractor
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.DistinctExpr
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionArgs
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FromItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FromItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FromItem
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.JoinExpr
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.JoinCond
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.BoolExp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.ValuesExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.InnerCTE
instance Control.DeepSeq.NFData v => Control.DeepSeq.NFData (Hasura.Backends.Postgres.SQL.DML.SelectWithG v)
instance Data.Hashable.Class.Hashable v => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.SQL.DML.SelectWithG v)
instance Hasura.SQL.Types.ToSQL v => Hasura.SQL.Types.ToSQL (Hasura.Backends.Postgres.SQL.DML.SelectWithG v)
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.SQLConflictTarget
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.UsingExp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.CompareOp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.CompareOp
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.DML.CompareOp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.CompareOp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.BinOp
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.BinOp
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.BinOp
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.JoinType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.JoinType
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.JoinType
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Lateral
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionAlias
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.FunctionDefinitionListItem
instance Data.String.IsString Hasura.Backends.Postgres.SQL.DML.TableAlias
instance GHC.Base.Semigroup Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.DML.TableAlias
instance Data.String.IsString Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance GHC.Base.Semigroup Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.Backends.Postgres.SQL.DML.ColumnAlias
instance Control.DeepSeq.NFData columnType => Control.DeepSeq.NFData (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance Data.Hashable.Class.Hashable columnType => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.SQL.DML.CountType columnType)
instance Hasura.SQL.Types.ToSQL (Hasura.Backends.Postgres.SQL.DML.CountType Hasura.Backends.Postgres.SQL.DML.QIdentifier)
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.QIdentifier
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.Qual
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.Qual
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.Qual
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.TypeAnn
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.DML.NullsOrder
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.SQL.DML.OrderType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.SQL.DML.OrderType
instance Hasura.SQL.Types.ToSQL Hasura.Backends.Postgres.SQL.DML.OrderType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.DML.OrderType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.DML.OrderType


-- | Postgres SQL Value
--   
--   Deals with Postgres scalar values, converting them to and from
--   <a>Text</a>, and to JSON <a>Value</a>.
module Hasura.Backends.Postgres.SQL.Value
data PGScalarValue
PGValInteger :: Int32 -> PGScalarValue
PGValSmallInt :: Int16 -> PGScalarValue
PGValBigInt :: Int64 -> PGScalarValue
PGValFloat :: Float -> PGScalarValue
PGValDouble :: Double -> PGScalarValue
PGValNumeric :: Scientific -> PGScalarValue
PGValMoney :: Scientific -> PGScalarValue
PGValBoolean :: Bool -> PGScalarValue
PGValChar :: Char -> PGScalarValue
PGValVarchar :: Text -> PGScalarValue
PGValText :: Text -> PGScalarValue
PGValCitext :: Text -> PGScalarValue
PGValDate :: Day -> PGScalarValue
PGValTimeStamp :: LocalTime -> PGScalarValue
PGValTimeStampTZ :: UTCTime -> PGScalarValue
PGValTimeTZ :: ZonedTimeOfDay -> PGScalarValue
PGNull :: PGScalarType -> PGScalarValue
PGValJSON :: JSON -> PGScalarValue
PGValJSONB :: JSONB -> PGScalarValue
PGValGeo :: GeometryWithCRS -> PGScalarValue
PGValRaster :: RasterWKB -> PGScalarValue
PGValUUID :: UUID -> PGScalarValue
PGValLtree :: Ltree -> PGScalarValue
PGValLquery :: Text -> PGScalarValue
PGValLtxtquery :: Text -> PGScalarValue
PGValUnknown :: Text -> PGScalarValue
PGValArray :: [PGScalarValue] -> PGScalarValue
pgScalarValueToJson :: PGScalarValue -> Value
textToScalarValue :: Maybe Text -> PGScalarValue
withConstructorFn :: PGScalarType -> SQLExp -> SQLExp
withScalarTypeAnn :: PGScalarType -> SQLExp -> SQLExp
withTypeAnn :: CollectableType PGScalarType -> SQLExp -> SQLExp
scientificToInteger :: (Integral i, Bounded i) => Scientific -> Parser i
scientificToFloat :: RealFloat f => Scientific -> Parser f
parsePGValue :: PGScalarType -> Value -> Parser PGScalarValue
txtEncodedVal :: PGScalarValue -> TxtEncodedVal
binEncoder :: PGScalarValue -> PrepArg
txtEncoder :: PGScalarValue -> SQLExp
toPrepParam :: Int -> PGScalarType -> SQLExp
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Value.RasterWKB
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Value.RasterWKB
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Value.Ltree
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Value.Ltree
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.Value.PGScalarValue
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.Value.PGScalarValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Value.Ltree
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Value.Ltree
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.SQL.Value.RasterWKB
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.SQL.Value.RasterWKB


-- | Postgres SQL Rename Identifiers
--   
--   <ol>
--   <li>Prefix table names with underscores to avoid issues where column
--   names and tables conflict. This can happen because we give columns and
--   tables the name <tt>root</tt> for some reason, and that can trip up
--   <tt>row_to_json</tt>. See
--   <a>https://github.com/PostgREST/postgrest/issues/993#issuecomment-340377813</a>.
--   An alternative solution would be to not create a <tt>TableAlias</tt>
--   with the name <tt>root</tt>, but that seemed a bit complicated for me
--   to do at the time.</li>
--   <li>Bypass the Postgres limitation of truncating identifiers to 63
--   characters long by prepending they identifier's md5 hash when they are
--   longer than 63 characters.</li>
--   </ol>
--   
--   We do both operations in the same traversal for performance reasons,
--   but a simpler implementation of (1) would be <tt>transformBi
--   prefixHash</tt> from the uniplate or the generic-plate package.
--   
--   See Postgres docs:
--   <a>https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS</a>
module Hasura.Backends.Postgres.SQL.RenameIdentifiers

-- | Prefix table names with undescores and rename long identifiers.
renameIdentifiers :: Select -> Select

-- | prefix table names with undescores and rename long identifiers.
renameIdentifiersSelectWith :: SelectWithG Select -> SelectWithG Select

-- | prefix table names with undescores and rename long identifiers.
renameIdentifiersSelectWithTopLevelCTE :: SelectWithG TopLevelCTE -> SelectWithG TopLevelCTE
instance GHC.Classes.Eq Hasura.Backends.Postgres.SQL.RenameIdentifiers.TableNames
instance GHC.Show.Show Hasura.Backends.Postgres.SQL.RenameIdentifiers.TableNames

module Hasura.LogicalModelResolver.Lenses
ilmmSelectPermissions :: forall b_i9nmA. Lens' (InlineLogicalModelMetadata b_i9nmA) (InsOrdHashMap RoleName (SelPermDef b_i9nmA))
ilmmFields :: forall b_i9nmA. Lens' (InlineLogicalModelMetadata b_i9nmA) (InsOrdHashMap (Column b_i9nmA) (LogicalModelField b_i9nmA))
_LMIInlineLogicalModel :: forall b_aalUK b_i9nmC. Prism (LogicalModelIdentifier b_aalUK) (LogicalModelIdentifier b_i9nmC) (InlineLogicalModelMetadata b_aalUK) (InlineLogicalModelMetadata b_i9nmC)
_LMILogicalModelName :: forall b_i9nmC. Prism' (LogicalModelIdentifier b_i9nmC) LogicalModelName

module Hasura.LogicalModel.Metadata

-- | Description of a logical model for use in metadata (before schema
--   cache)
data LogicalModelMetadata (b :: BackendType)
LogicalModelMetadata :: LogicalModelName -> LogicalModelFields b -> Maybe Text -> InsOrdHashMap RoleName (SelPermDef b) -> LogicalModelMetadata (b :: BackendType)
[_lmmName] :: LogicalModelMetadata (b :: BackendType) -> LogicalModelName
[_lmmFields] :: LogicalModelMetadata (b :: BackendType) -> LogicalModelFields b
[_lmmDescription] :: LogicalModelMetadata (b :: BackendType) -> Maybe Text
[_lmmSelectPermissions] :: LogicalModelMetadata (b :: BackendType) -> InsOrdHashMap RoleName (SelPermDef b)

-- | A wrapper to tie something to a particular native query. Specifically,
--   it assumes the underlying <a>_wlmInfo</a> is represented as an object,
--   and adds two keys to that object: <tt>source</tt> and
--   <tt>root_field_name</tt>.
data WithLogicalModel a
WithLogicalModel :: SourceName -> LogicalModelName -> a -> WithLogicalModel a
[_wlmSource] :: WithLogicalModel a -> SourceName
[_wlmName] :: WithLogicalModel a -> LogicalModelName
[_wlmInfo] :: WithLogicalModel a -> a
instance GHC.Generics.Generic (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.LogicalModel.Metadata.WithLogicalModel a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.LogicalModel.Metadata.WithLogicalModel a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.Metadata.WithLogicalModel a)
instance Hasura.RQL.Types.Common.ToAesonPairs a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Metadata.WithLogicalModel a)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.Metadata.LogicalModelMetadata b)

module Hasura.RQL.Types.Source.Table

-- | Table schema data from the <tt>SchemaResponse</tt>.
data SourceTableInfo b
SourceTableInfo :: TableName b -> SourceTableType -> [SourceColumnInfo b] -> [LogicalModelMetadata b] -> Maybe (NonEmpty (Column b)) -> SourceForeignKeys b -> Maybe Text -> Bool -> Bool -> Bool -> SourceTableInfo b
[_stiName] :: SourceTableInfo b -> TableName b
[_stiType] :: SourceTableInfo b -> SourceTableType
[_stiColumns] :: SourceTableInfo b -> [SourceColumnInfo b]
[_stiLogicalModels] :: SourceTableInfo b -> [LogicalModelMetadata b]
[_stiPrimaryKey] :: SourceTableInfo b -> Maybe (NonEmpty (Column b))
[_stiForeignKeys] :: SourceTableInfo b -> SourceForeignKeys b
[_stiDescription] :: SourceTableInfo b -> Maybe Text
[_stiInsertable] :: SourceTableInfo b -> Bool
[_stiUpdatable] :: SourceTableInfo b -> Bool
[_stiDeletable] :: SourceTableInfo b -> Bool
newtype SourceForeignKeys b
SourceForeignKeys :: HashMap (ConstraintName b) (SourceConstraint b) -> SourceForeignKeys b
[_unSourceForeignKeys] :: SourceForeignKeys b -> HashMap (ConstraintName b) (SourceConstraint b)
data SourceConstraint b
SourceConstraint :: TableName b -> HashMap (Column b) (Column b) -> SourceConstraint b
[_scForeignTable] :: SourceConstraint b -> TableName b
[_scColumnMapping] :: SourceConstraint b -> HashMap (Column b) (Column b)
stiUpdatable :: forall b_aaocG. Lens' (SourceTableInfo b_aaocG) Bool
stiType :: forall b_aaocG. Lens' (SourceTableInfo b_aaocG) SourceTableType
stiPrimaryKey :: forall b_aaocG. Lens' (SourceTableInfo b_aaocG) (Maybe (NonEmpty (Column b_aaocG)))
stiName :: forall b_aaocG. Lens' (SourceTableInfo b_aaocG) (TableName b_aaocG)
stiLogicalModels :: forall b_aaocG. Lens' (SourceTableInfo b_aaocG) [LogicalModelMetadata b_aaocG]
stiInsertable :: forall b_aaocG. Lens' (SourceTableInfo b_aaocG) Bool
stiForeignKeys :: forall b_aaocG. Lens' (SourceTableInfo b_aaocG) (SourceForeignKeys b_aaocG)
stiDescription :: forall b_aaocG. Lens' (SourceTableInfo b_aaocG) (Maybe Text)
stiDeletable :: forall b_aaocG. Lens' (SourceTableInfo b_aaocG) Bool
stiColumns :: forall b_aaocG. Lens' (SourceTableInfo b_aaocG) [SourceColumnInfo b_aaocG]
scForeignTable :: forall b_aaocE. Lens' (SourceConstraint b_aaocE) (TableName b_aaocE)
scColumnMapping :: forall b_aaocE. Lens' (SourceConstraint b_aaocE) (HashMap (Column b_aaocE) (Column b_aaocE))
unSourceForeignKeys :: forall b_aaocF b_aat82. Iso (SourceForeignKeys b_aaocF) (SourceForeignKeys b_aat82) (HashMap (ConstraintName b_aaocF) (SourceConstraint b_aaocF)) (HashMap (ConstraintName b_aat82) (SourceConstraint b_aat82))
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Source.Table.SourceConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Source.Table.SourceTableInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Source.Table.SourceForeignKeys b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Source.Table.SourceConstraint b)


-- | Postgres Types CitusExtraTableMetadata
--   
--   Additional metadata information for Citus tables.
--   
--   See
--   <a>https://www.citusdata.com/blog/2017/07/27/database-table-types-with-citus-and-postgres/</a>
--   for more details on the Citus table types.
module Hasura.Backends.Postgres.Types.CitusExtraTableMetadata
data ExtraTableMetadata
Local :: SourceTableType -> ExtraTableMetadata
[tableType] :: ExtraTableMetadata -> SourceTableType
Reference :: SourceTableType -> ExtraTableMetadata
[tableType] :: ExtraTableMetadata -> SourceTableType
Distributed :: Text -> SourceTableType -> ExtraTableMetadata
instance GHC.Generics.Generic Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance GHC.Classes.Eq Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance GHC.Show.Show Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Types.CitusExtraTableMetadata.ExtraTableMetadata


-- | Contains types that can be used by backends to structure updates to
--   batches of rows in a table
module Hasura.RQL.IR.Update.Batch

-- | Represents a set of update operations (<a>_ubOperations</a>) applied
--   to a batch of rows selected from a table by filtering it with a
--   boolean expression (<a>_ubWhere</a>).
--   
--   This type may be used by specific backends as a part their
--   <a>UpdateVariant</a>. See <a>PgUpdateVariant</a> for an example.
--   
--   The actual operators used to affect changes against columns in
--   <a>_ubOperations</a> are abstract here and are specified by the
--   specific backends based on what they actually support
data UpdateBatch (b :: BackendType) updateOperators v
UpdateBatch :: HashMap (Column b) (updateOperators v) -> AnnBoolExp b v -> UpdateBatch (b :: BackendType) updateOperators v
[_ubOperations] :: UpdateBatch (b :: BackendType) updateOperators v -> HashMap (Column b) (updateOperators v)
[_ubWhere] :: UpdateBatch (b :: BackendType) updateOperators v -> AnnBoolExp b v

-- | Are we actually updating anything in the batch?
updateBatchIsEmpty :: UpdateBatch b updateOperators v -> Bool
instance (Hasura.RQL.Types.Backend.Backend b, Data.Traversable.Traversable updateOperators) => Data.Traversable.Traversable (Hasura.RQL.IR.Update.Batch.UpdateBatch b updateOperators)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Foldable.Foldable updateOperators) => Data.Foldable.Foldable (Hasura.RQL.IR.Update.Batch.UpdateBatch b updateOperators)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Base.Functor updateOperators) => GHC.Base.Functor (Hasura.RQL.IR.Update.Batch.UpdateBatch b updateOperators)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v, GHC.Show.Show (updateOperators v), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Update.Batch.UpdateBatch b updateOperators v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq (updateOperators v), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Update.Batch.UpdateBatch b updateOperators v)


-- | Postgres Types Update
--   
--   This module defines the Update-related IR types specific to Postgres.
module Hasura.Backends.Postgres.Types.Update

-- | The various <tt>update operators</tt> supported by PostgreSQL, i.e.
--   the <tt>_set</tt>, <tt>_inc</tt> operators that appear in the schema.
--   
--   See <a>Update Mutations User docs</a>
data UpdateOpExpression v
UpdateSet :: v -> UpdateOpExpression v
UpdateInc :: v -> UpdateOpExpression v
UpdateAppend :: v -> UpdateOpExpression v
UpdatePrepend :: v -> UpdateOpExpression v
UpdateDeleteKey :: v -> UpdateOpExpression v
UpdateDeleteElem :: v -> UpdateOpExpression v
UpdateDeleteAtPath :: [v] -> UpdateOpExpression v

-- | The different <tt>variants</tt> of updates that the Postgres backend
--   supports.
--   
--   This is parameterised over <tt>v</tt> which enables different phases
--   of IR transformation to maintain the overall structure while
--   enriching/transforming the data at the leaves.
data PgUpdateVariant pgKind v
SingleBatch :: UpdateBatch ('Postgres pgKind) UpdateOpExpression v -> PgUpdateVariant pgKind v
MultipleBatches :: [UpdateBatch ('Postgres pgKind) UpdateOpExpression v] -> PgUpdateVariant pgKind v

-- | Are we updating anything?
updateVariantIsEmpty :: PgUpdateVariant b v -> Bool
instance GHC.Classes.Eq v => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance GHC.Show.Show v => GHC.Show.Show (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance Data.Data.Data v => Data.Data.Data (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v)
instance Data.Traversable.Traversable Hasura.Backends.Postgres.Types.Update.UpdateOpExpression
instance Data.Foldable.Foldable Hasura.Backends.Postgres.Types.Update.UpdateOpExpression
instance GHC.Base.Functor Hasura.Backends.Postgres.Types.Update.UpdateOpExpression
instance GHC.Classes.Eq (Hasura.RQL.IR.Update.Batch.UpdateBatch ('Hasura.RQL.Types.BackendType.Postgres pgKind) Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v) => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Update.PgUpdateVariant pgKind v)
instance GHC.Show.Show (Hasura.RQL.IR.Update.Batch.UpdateBatch ('Hasura.RQL.Types.BackendType.Postgres pgKind) Hasura.Backends.Postgres.Types.Update.UpdateOpExpression v) => GHC.Show.Show (Hasura.Backends.Postgres.Types.Update.PgUpdateVariant pgKind v)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Base.Functor (Hasura.Backends.Postgres.Types.Update.PgUpdateVariant pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Data.Foldable.Foldable (Hasura.Backends.Postgres.Types.Update.PgUpdateVariant pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Data.Traversable.Traversable (Hasura.Backends.Postgres.Types.Update.PgUpdateVariant pgKind)

module Hasura.Backends.DataConnector.Adapter.Types.Mutations

-- | The Data Connector-specific data of an Insert expression. Currently,
--   we don't have any.
--   
--   This is parameterised over <tt>v</tt> which enables different phases
--   of IR transformation to maintain the overall structure while
--   enriching/transforming the data at the leaves.
data BackendInsert v
BackendInsert :: BackendInsert v
data DataConnectorUpdateVariant v
SingleBatch :: UpdateBatch 'DataConnector UpdateOperator v -> DataConnectorUpdateVariant v
MultipleBatches :: [UpdateBatch 'DataConnector UpdateOperator v] -> DataConnectorUpdateVariant v

-- | The operators that are used to mutate specific columns on a table
data UpdateOperator v
UpdateSet :: v -> UpdateOperator v
UpdateCustomOperator :: UpdateColumnOperatorName -> v -> UpdateOperator v
instance Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Types.Mutations.BackendInsert
instance Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Types.Mutations.BackendInsert
instance GHC.Base.Functor Hasura.Backends.DataConnector.Adapter.Types.Mutations.BackendInsert
instance Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Types.Mutations.UpdateOperator
instance Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Types.Mutations.UpdateOperator
instance GHC.Base.Functor Hasura.Backends.DataConnector.Adapter.Types.Mutations.UpdateOperator
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => GHC.Base.Functor Hasura.Backends.DataConnector.Adapter.Types.Mutations.DataConnectorUpdateVariant
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Types.Mutations.DataConnectorUpdateVariant
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Types.Mutations.DataConnectorUpdateVariant


-- | Arbitrarily putting leaves from RQL.IR.Select into own files to
--   parallelise compilation
module Hasura.RQL.IR.Select.TablePerm
data TablePermG (b :: BackendType) v
TablePerm :: AnnBoolExp b v -> Maybe Int -> TablePermG (b :: BackendType) v
[$sel:_tpFilter:TablePerm] :: TablePermG (b :: BackendType) v -> AnnBoolExp b v
[$sel:_tpLimit:TablePerm] :: TablePermG (b :: BackendType) v -> Maybe Int
type TablePerm b = TablePermG b (SQLExpression b)
noTablePermissions :: TablePermG backend v
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.TablePerm.TablePermG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.TablePerm.TablePermG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.TablePerm.TablePermG b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.TablePerm.TablePermG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.TablePerm.TablePermG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.TablePerm.TablePermG b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.TablePerm.TablePermG b v)

module Hasura.RQL.IR.Select.OrderBy
data AnnotatedOrderByElement (b :: BackendType) v
AOCColumn :: ColumnInfo b -> AnnRedactionExp b v -> AnnotatedOrderByElement (b :: BackendType) v
AOCNestedObject :: NestedObjectInfo b -> AnnotatedOrderByElement b v -> AnnotatedOrderByElement (b :: BackendType) v
AOCObjectRelation :: RelInfo b -> AnnBoolExp b v -> AnnotatedOrderByElement b v -> AnnotatedOrderByElement (b :: BackendType) v
AOCArrayAggregation :: RelInfo b -> AnnBoolExp b v -> AnnotatedAggregateOrderBy b v -> AnnotatedOrderByElement (b :: BackendType) v
AOCComputedField :: ComputedFieldOrderBy b v -> AnnotatedOrderByElement (b :: BackendType) v
data AnnotatedAggregateOrderBy (b :: BackendType) v
AAOCount :: AnnotatedAggregateOrderBy (b :: BackendType) v

-- | Order by an aggregate function applied to a column
AAOOp :: AggregateOrderByColumn b v -> AnnotatedAggregateOrderBy (b :: BackendType) v
data AggregateOrderByColumn b v
AggregateOrderByColumn :: Text -> ColumnType b -> ColumnInfo b -> AnnRedactionExp b v -> AggregateOrderByColumn b v
[$sel:_aobcAggregateFunctionName:AggregateOrderByColumn] :: AggregateOrderByColumn b v -> Text
[$sel:_aobcAggregateFunctionReturnType:AggregateOrderByColumn] :: AggregateOrderByColumn b v -> ColumnType b
[$sel:_aobcColumn:AggregateOrderByColumn] :: AggregateOrderByColumn b v -> ColumnInfo b

-- | This type is used to determine whether the column should be redacted
--   before being aggregated and then ordered over
[$sel:_aobcRedactionExpression:AggregateOrderByColumn] :: AggregateOrderByColumn b v -> AnnRedactionExp b v
type AnnotatedOrderByItemG b v = OrderByItemG b (AnnotatedOrderByElement b v)
type AnnotatedOrderByItem b = AnnotatedOrderByItemG b (SQLExpression b)

-- | The order by element for a computed field based on its return type
data ComputedFieldOrderByElement (b :: BackendType) v

-- | Sort by the scalar computed field
CFOBEScalar :: ScalarType b -> AnnRedactionExp b v -> ComputedFieldOrderByElement (b :: BackendType) v
CFOBETableAggregation :: TableName b -> AnnBoolExp b v -> AnnotatedAggregateOrderBy b v -> ComputedFieldOrderByElement (b :: BackendType) v
data ComputedFieldOrderBy (b :: BackendType) v
ComputedFieldOrderBy :: XComputedField b -> ComputedFieldName -> FunctionName b -> FunctionArgsExp b v -> ComputedFieldOrderByElement b v -> ComputedFieldOrderBy (b :: BackendType) v
[$sel:_cfobXField:ComputedFieldOrderBy] :: ComputedFieldOrderBy (b :: BackendType) v -> XComputedField b
[$sel:_cfobName:ComputedFieldOrderBy] :: ComputedFieldOrderBy (b :: BackendType) v -> ComputedFieldName
[$sel:_cfobFunction:ComputedFieldOrderBy] :: ComputedFieldOrderBy (b :: BackendType) v -> FunctionName b
[$sel:_cfobFunctionArgsExp:ComputedFieldOrderBy] :: ComputedFieldOrderBy (b :: BackendType) v -> FunctionArgsExp b v
[$sel:_cfobOrderByElement:ComputedFieldOrderBy] :: ComputedFieldOrderBy (b :: BackendType) v -> ComputedFieldOrderByElement b v
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b v)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b v), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v), GHC.Show.Show (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b v), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b v), GHC.Classes.Eq (Hasura.Function.Cache.FunctionArgsExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b v), GHC.Show.Show (Hasura.Function.Cache.FunctionArgsExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v), Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b v), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b v), Data.Hashable.Class.Hashable (Hasura.Function.Cache.FunctionArgsExp b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.ComputedFieldOrderByElement b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.AnnotatedAggregateOrderBy b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.AggregateOrderByColumn b v)


-- | Removed from <a>Select</a> to speed up compilation
module Hasura.RQL.IR.Select.Args
data SelectStreamArgsG (b :: BackendType) v
SelectStreamArgsG :: Maybe (AnnBoolExp b v) -> Int -> StreamCursorItem b v -> SelectStreamArgsG (b :: BackendType) v

-- | optional filter to filter the stream results
[$sel:_ssaWhere:SelectStreamArgsG] :: SelectStreamArgsG (b :: BackendType) v -> Maybe (AnnBoolExp b v)

-- | maximum number of rows to be returned in a single fetch
[$sel:_ssaBatchSize:SelectStreamArgsG] :: SelectStreamArgsG (b :: BackendType) v -> Int

-- | info related to the cursor column, a single item data type currently
--   because only single column cursors are supported
[$sel:_ssaCursorArg:SelectStreamArgsG] :: SelectStreamArgsG (b :: BackendType) v -> StreamCursorItem b v
type SelectStreamArgs b = SelectStreamArgsG b (SQLExpression b)
data SelectArgsG (b :: BackendType) v
SelectArgs :: Maybe (AnnBoolExp b v) -> Maybe (NonEmpty (AnnotatedOrderByItemG b v)) -> Maybe Int -> Maybe Int64 -> Maybe (NonEmpty (AnnDistinctColumn b v)) -> SelectArgsG (b :: BackendType) v
[$sel:_saWhere:SelectArgs] :: SelectArgsG (b :: BackendType) v -> Maybe (AnnBoolExp b v)
[$sel:_saOrderBy:SelectArgs] :: SelectArgsG (b :: BackendType) v -> Maybe (NonEmpty (AnnotatedOrderByItemG b v))
[$sel:_saLimit:SelectArgs] :: SelectArgsG (b :: BackendType) v -> Maybe Int
[$sel:_saOffset:SelectArgs] :: SelectArgsG (b :: BackendType) v -> Maybe Int64
[$sel:_saDistinct:SelectArgs] :: SelectArgsG (b :: BackendType) v -> Maybe (NonEmpty (AnnDistinctColumn b v))
type SelectArgs b = SelectArgsG b (SQLExpression b)
noSelectArgs :: SelectArgsG backend v
data AnnDistinctColumn b v
AnnDistinctColumn :: Column b -> AnnRedactionExp b v -> AnnDistinctColumn b v
[$sel:_adcColumn:AnnDistinctColumn] :: AnnDistinctColumn b v -> Column b

-- | This type is used to determine whether the column should be redacted
--   before being distincted-upon
[$sel:_adcRedactionExpression:AnnDistinctColumn] :: AnnDistinctColumn b v -> AnnRedactionExp b v

-- | Cursor for streaming subscription
data StreamCursorItem (b :: BackendType) v
StreamCursorItem :: CursorOrdering -> ColumnInfo b -> AnnRedactionExp b v -> ColumnValue b -> StreamCursorItem (b :: BackendType) v

-- | Specifies how the cursor item should be ordered
[$sel:_sciOrdering:StreamCursorItem] :: StreamCursorItem (b :: BackendType) v -> CursorOrdering

-- | Column info of the cursor item
[$sel:_sciColInfo:StreamCursorItem] :: StreamCursorItem (b :: BackendType) v -> ColumnInfo b

-- | This type is used to determine whether the column should be redacted
--   before it is sorted upon
[$sel:_sciRedactionExpression:StreamCursorItem] :: StreamCursorItem (b :: BackendType) v -> AnnRedactionExp b v

-- | Initial value of the cursor item from where the streaming should start
[$sel:_sciInitialValue:StreamCursorItem] :: StreamCursorItem (b :: BackendType) v -> ColumnValue b
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.Args.SelectArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.Args.SelectArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.Args.SelectArgsG b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.Args.SelectArgsG b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.Args.StreamCursorItem b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.Args.StreamCursorItem b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.Args.StreamCursorItem b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.Args.StreamCursorItem b v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show v) => GHC.Show.Show (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByItemG b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.Args.SelectArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByItemG b v), GHC.Show.Show (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.Args.SelectArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.Args.StreamCursorItem b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.Args.StreamCursorItem b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByItemG b v), Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.Args.SelectArgsG b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.Args.AnnDistinctColumn b v)

module Hasura.RQL.IR.Conflict
data ConflictTarget (b :: BackendType)
CTColumn :: [Column b] -> ConflictTarget (b :: BackendType)
CTConstraint :: ConstraintName b -> ConflictTarget (b :: BackendType)
data OnConflictClauseData b v
OnConflictClauseData :: ConflictTarget b -> [Column b] -> PreSetColsG b v -> AnnBoolExp b v -> OnConflictClauseData b v
[cp1udConflictTarget] :: OnConflictClauseData b v -> ConflictTarget b
[cp1udAffectedColumns] :: OnConflictClauseData b v -> [Column b]
[cp1udValues] :: OnConflictClauseData b v -> PreSetColsG b v
[cp1udFilter] :: OnConflictClauseData b v -> AnnBoolExp b v
data OnConflictClause (b :: BackendType) v
OCCDoNothing :: Maybe (ConflictTarget b) -> OnConflictClause (b :: BackendType) v
OCCUpdate :: OnConflictClauseData b v -> OnConflictClause (b :: BackendType) v
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Conflict.OnConflictClauseData b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Conflict.OnConflictClauseData b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Conflict.OnConflictClauseData b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Conflict.OnConflictClause b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Conflict.OnConflictClause b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Conflict.OnConflictClause b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.Conflict.ConflictTarget b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.Conflict.ConflictTarget b)


-- | Postgres Types Insert
--   
--   This module defines the Insert-related IR types specific to Postgres.
module Hasura.Backends.Postgres.Types.Insert

-- | The PostgreSQL-specific data of an Insert expression.
--   
--   This is parameterised over <tt>v</tt> which enables different phases
--   of IR transformation to maintain the overall structure while
--   enriching/transforming the data at the leaves.
newtype BackendInsert pgKind v
BackendInsert :: Maybe (OnConflictClause ('Postgres pgKind) v) -> BackendInsert pgKind v
[_biConflictClause] :: BackendInsert pgKind v -> Maybe (OnConflictClause ('Postgres pgKind) v)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Base.Functor (Hasura.Backends.Postgres.Types.Insert.BackendInsert pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Data.Foldable.Foldable (Hasura.Backends.Postgres.Types.Insert.BackendInsert pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Data.Traversable.Traversable (Hasura.Backends.Postgres.Types.Insert.BackendInsert pgKind)

module Hasura.RQL.IR.BoolExp.Lenses
geWhere :: forall backend_iaGfb field_iaGfc field_abg83. Lens (GExists backend_iaGfb field_iaGfc) (GExists backend_iaGfb field_abg83) (GBoolExp backend_iaGfb field_iaGfc) (GBoolExp backend_iaGfb field_abg83)
geTable :: forall backend_iaGfb field_iaGfc. Lens' (GExists backend_iaGfb field_iaGfc) (TableName backend_iaGfb)
_BoolExists :: forall backend_i96Vk field_i96Vl. Prism' (GBoolExp backend_i96Vk field_i96Vl) (GExists backend_i96Vk field_i96Vl)
_RedactIfFalse :: forall b_abggL v_abggM b_iaGfK v_iaGfL. Prism (AnnRedactionExp b_abggL v_abggM) (AnnRedactionExp b_iaGfK v_iaGfL) (GBoolExp b_abggL (AnnBoolExpFld b_abggL v_abggM)) (GBoolExp b_iaGfK (AnnBoolExpFld b_iaGfK v_iaGfL))
_NoRedaction :: forall b_iaGfK v_iaGfL. Prism' (AnnRedactionExp b_iaGfK v_iaGfL) ()
instance (Hasura.RQL.IR.BoolExp.BoolExp b1 GHC.Types.~ t) => Control.Lens.Wrapped.Rewrapped (Hasura.RQL.IR.BoolExp.BoolExp b2) t
instance Control.Lens.Wrapped.Wrapped (Hasura.RQL.IR.BoolExp.BoolExp b)


-- | This module contains the default types and function that model
--   aggregation predicates.
module Hasura.RQL.IR.BoolExp.AggregationPredicates

-- | This type the default non-empty implementation of the
--   <tt>AggregationPredicates</tt> type family of 'class Backend'.
--   
--   This represents an _applied_ aggregation predicate, i.e. _not_ an
--   aggegation function in isolation.
--   
--   In the default schema implementation, this type results from parsing
--   graphql such as:
--   
--   table(_where( <a>relation</a>_aggregate: {<a>functionname</a>: {
--   arguments: <a>arguments</a>, predicate: <a>predicate</a>, distinct:
--   bool } } )) { ... }
--   
--   Note that we make no attempt at modelling window functions or
--   so-called <tt>analytical</tt> functions such as
--   <tt>percentile_cont</tt>.
data AggregationPredicatesImplementation (b :: BackendType) field
AggregationPredicatesImplementation :: RelInfo b -> AnnBoolExp b field -> AggregationPredicate b field -> AggregationPredicatesImplementation (b :: BackendType) field
[aggRelation] :: AggregationPredicatesImplementation (b :: BackendType) field -> RelInfo b
[aggRowPermission] :: AggregationPredicatesImplementation (b :: BackendType) field -> AnnBoolExp b field
[aggPredicate] :: AggregationPredicatesImplementation (b :: BackendType) field -> AggregationPredicate b field
data AggregationPredicate (b :: BackendType) field
AggregationPredicate :: Text -> Bool -> Maybe (AnnBoolExp b field) -> AggregationPredicateArguments b field -> [OpExpG b field] -> AggregationPredicate (b :: BackendType) field
[aggPredFunctionName] :: AggregationPredicate (b :: BackendType) field -> Text
[aggPredDistinct] :: AggregationPredicate (b :: BackendType) field -> Bool
[aggPredFilter] :: AggregationPredicate (b :: BackendType) field -> Maybe (AnnBoolExp b field)
[aggPredArguments] :: AggregationPredicate (b :: BackendType) field -> AggregationPredicateArguments b field
[aggPredPredicate] :: AggregationPredicate (b :: BackendType) field -> [OpExpG b field]
data AggregationPredicateArguments (b :: BackendType) field
AggregationPredicateArgumentsStar :: AggregationPredicateArguments (b :: BackendType) field
AggregationPredicateArguments :: NonEmpty (Column b, AnnRedactionExp b field) -> AggregationPredicateArguments (b :: BackendType) field
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b)
instance GHC.Generics.Generic (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b field)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b field)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.OpExpG b field), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), GHC.Show.Show (Hasura.RQL.IR.BoolExp.OpExpG b field), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b field)) => GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp b field)) => GHC.Show.Show (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b field)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExp b field)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.OpExpG b field), Hasura.RQL.Types.Backend.Backend b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicatesImplementation b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.Types.Backend.BooleanOperators b field), Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), Data.Hashable.Class.Hashable field) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.OpExpG b field)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field), Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExp b field), Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.OpExpG b field)) => Data.Aeson.Extended.ToJSONKeyValue (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicate b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AnnRedactionExp b field)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnRedactionExp b field)) => Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnRedactionExp b field)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AggregationPredicates.AggregationPredicateArguments b field)


-- | Postgres Types BoolExp
--   
--   Postgres-specific <tt>BooleanOperator</tt> extensions.
module Hasura.Backends.Postgres.Types.BoolExp
data BooleanOperators a
AILIKE :: a -> BooleanOperators a
ANILIKE :: a -> BooleanOperators a
ASIMILAR :: a -> BooleanOperators a
ANSIMILAR :: a -> BooleanOperators a
AREGEX :: a -> BooleanOperators a
AIREGEX :: a -> BooleanOperators a
ANREGEX :: a -> BooleanOperators a
ANIREGEX :: a -> BooleanOperators a
AContains :: a -> BooleanOperators a
AContainedIn :: a -> BooleanOperators a
AHasKey :: a -> BooleanOperators a
AHasKeysAny :: a -> BooleanOperators a
AHasKeysAll :: a -> BooleanOperators a
ASTContains :: a -> BooleanOperators a
ASTCrosses :: a -> BooleanOperators a
ASTEquals :: a -> BooleanOperators a
ASTIntersects :: a -> BooleanOperators a
AST3DIntersects :: a -> BooleanOperators a
ASTOverlaps :: a -> BooleanOperators a
ASTTouches :: a -> BooleanOperators a
ASTWithin :: a -> BooleanOperators a
ASTIntersectsRast :: a -> BooleanOperators a
ASTDWithinGeom :: DWithinGeomOp a -> BooleanOperators a
AST3DDWithinGeom :: DWithinGeomOp a -> BooleanOperators a
ASTDWithinGeog :: DWithinGeogOp a -> BooleanOperators a
ASTIntersectsGeomNband :: STIntersectsGeomminNband a -> BooleanOperators a
ASTIntersectsNbandGeom :: STIntersectsNbandGeommin a -> BooleanOperators a
AAncestor :: a -> BooleanOperators a
AAncestorAny :: a -> BooleanOperators a
ADescendant :: a -> BooleanOperators a
ADescendantAny :: a -> BooleanOperators a
AMatches :: a -> BooleanOperators a
AMatchesAny :: a -> BooleanOperators a
AMatchesFulltext :: a -> BooleanOperators a
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Data.Traversable.Traversable Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators
instance GHC.Base.Functor Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators
instance Data.Foldable.Foldable Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.Postgres.Types.BoolExp.BooleanOperators a)

module Hasura.Backends.Postgres.Types.Aggregates

-- | This newtype allows us to reuse <a>CountType</a> for the
--   <a>CountType</a> type family We reuse the overall structure, but our
--   column type is a PGCol column name, plus the column redaction
--   expression used by inherited roles. See [SQL generation for inherited
--   roles] for more information about column redaction
newtype CountAggregate pgKind v
CountAggregate :: CountType (PGCol, AnnRedactionExp ('Postgres pgKind) v) -> CountAggregate pgKind v
[getCountType] :: CountAggregate pgKind v -> CountType (PGCol, AnnRedactionExp ('Postgres pgKind) v)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind v)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => GHC.Base.Functor (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Data.Foldable.Foldable (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Data.Traversable.Traversable (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp ('Hasura.RQL.Types.BackendType.Postgres pgKind) v), GHC.Show.Show v) => GHC.Show.Show (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind v)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp ('Hasura.RQL.Types.BackendType.Postgres pgKind) v), GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.Backends.Postgres.Types.Aggregates.CountAggregate pgKind v)


-- | MSSQL Types Internal
--   
--   Types for Transact-SQL aka T-SQL; the language of SQL Server.
--   
--   In this module we define various MS SQL Server specific data types
--   used for T-SQL generation.
--   
--   These types are also used as underlying types in the <tt>Backend
--   'MSSQL</tt> instance which is defined in
--   <a>Hasura.Backends.MSSQL.Instances.Types</a>.
--   
--   We convert RQL IR ASTs to types defined here in the
--   <a>Hasura.Backends.MSSQL.FromIr</a> module, and we implement
--   pretty-printing for these types in the
--   <a>Hasura.Backends.MSSQL.ToQuery</a> module.
--   
--   NOTE: Various type class instances (including simple once such as Eq
--   and Show) are implemented in the
--   <a>Hasura.Backends.MSSQL.Types.Instances</a> module.
module Hasura.Backends.MSSQL.Types.Internal
type Column (b :: BackendType) = ColumnName
type ColumnType (b :: BackendType) = ScalarType
type Value = Value
data UnifiedColumn
UnifiedColumn :: ColumnName -> ScalarType -> UnifiedColumn
[$sel:name:UnifiedColumn] :: UnifiedColumn -> ColumnName
[$sel:type':UnifiedColumn] :: UnifiedColumn -> ScalarType
data UnifiedTableName
UnifiedTableName :: Text -> Text -> UnifiedTableName
[$sel:schema:UnifiedTableName] :: UnifiedTableName -> Text
[$sel:name:UnifiedTableName] :: UnifiedTableName -> Text
data UnifiedObjectRelationship
UnifiedObjectRelationship :: UnifiedUsing -> Text -> UnifiedObjectRelationship
[$sel:using:UnifiedObjectRelationship] :: UnifiedObjectRelationship -> UnifiedUsing
[$sel:name:UnifiedObjectRelationship] :: UnifiedObjectRelationship -> Text
data UnifiedArrayRelationship
UnifiedArrayRelationship :: UnifiedUsing -> Text -> UnifiedArrayRelationship
[$sel:using:UnifiedArrayRelationship] :: UnifiedArrayRelationship -> UnifiedUsing
[$sel:name:UnifiedArrayRelationship] :: UnifiedArrayRelationship -> Text
newtype UnifiedUsing
UnifiedUsing :: UnifiedOn -> UnifiedUsing
[$sel:foreign_key_constraint_on:UnifiedUsing] :: UnifiedUsing -> UnifiedOn
data UnifiedOn
UnifiedOn :: UnifiedTableName -> Text -> UnifiedOn
[$sel:table:UnifiedOn] :: UnifiedOn -> UnifiedTableName
[$sel:column:UnifiedOn] :: UnifiedOn -> Text
data BooleanOperators a
ASTContains :: a -> BooleanOperators a
ASTCrosses :: a -> BooleanOperators a
ASTEquals :: a -> BooleanOperators a
ASTIntersects :: a -> BooleanOperators a
ASTOverlaps :: a -> BooleanOperators a
ASTTouches :: a -> BooleanOperators a
ASTWithin :: a -> BooleanOperators a
data Select
Select :: Maybe With -> Top -> [Projection] -> Maybe From -> [Join] -> Where -> For -> Maybe (NonEmpty OrderBy) -> Maybe Expression -> Select
[$sel:selectWith:Select] :: Select -> Maybe With
[$sel:selectTop:Select] :: Select -> Top
[$sel:selectProjections:Select] :: Select -> [Projection]
[$sel:selectFrom:Select] :: Select -> Maybe From
[$sel:selectJoins:Select] :: Select -> [Join]
[$sel:selectWhere:Select] :: Select -> Where
[$sel:selectFor:Select] :: Select -> For
[$sel:selectOrderBy:Select] :: Select -> Maybe (NonEmpty OrderBy)
[$sel:selectOffset:Select] :: Select -> Maybe Expression
emptySelect :: Select
newtype OutputColumn
OutputColumn :: ColumnName -> OutputColumn
[$sel:unOutputColumn:OutputColumn] :: OutputColumn -> ColumnName
data Inserted
Inserted :: Inserted
data Deleted
Deleted :: Deleted
data Output t
Output :: t -> [OutputColumn] -> Output t
[$sel:outputType:Output] :: Output t -> t
[$sel:outputColumns:Output] :: Output t -> [OutputColumn]
type InsertOutput = Output Inserted
newtype Values
Values :: [Expression] -> Values
data Insert
Insert :: TableName -> [ColumnName] -> InsertOutput -> TempTable -> [Values] -> Insert
[$sel:insertTable:Insert] :: Insert -> TableName
[$sel:insertColumns:Insert] :: Insert -> [ColumnName]
[$sel:insertOutput:Insert] :: Insert -> InsertOutput
[$sel:insertTempTable:Insert] :: Insert -> TempTable
[$sel:insertValues:Insert] :: Insert -> [Values]
data SetValue
SetON :: SetValue
SetOFF :: SetValue
data SetIdentityInsert
SetIdentityInsert :: SomeTableName -> SetValue -> SetIdentityInsert
[$sel:setTable:SetIdentityInsert] :: SetIdentityInsert -> SomeTableName
[$sel:setValue:SetIdentityInsert] :: SetIdentityInsert -> SetValue
type DeleteOutput = Output Deleted
data Delete
Delete :: Aliased TableName -> DeleteOutput -> TempTable -> Where -> Delete
[$sel:deleteTable:Delete] :: Delete -> Aliased TableName
[$sel:deleteOutput:Delete] :: Delete -> DeleteOutput
[$sel:deleteTempTable:Delete] :: Delete -> TempTable
[$sel:deleteWhere:Delete] :: Delete -> Where

-- | MERGE statement. Used for upserts and is responsible for actually
--   inserting or updating the data in the table.
data Merge
Merge :: TableName -> MergeUsing -> MergeOn -> MergeWhenMatched -> MergeWhenNotMatched -> InsertOutput -> TempTable -> Merge
[$sel:mergeTargetTable:Merge] :: Merge -> TableName
[$sel:mergeUsing:Merge] :: Merge -> MergeUsing
[$sel:mergeOn:Merge] :: Merge -> MergeOn
[$sel:mergeWhenMatched:Merge] :: Merge -> MergeWhenMatched
[$sel:mergeWhenNotMatched:Merge] :: Merge -> MergeWhenNotMatched
[$sel:mergeInsertOutput:Merge] :: Merge -> InsertOutput
[$sel:mergeOutputTempTable:Merge] :: Merge -> TempTable

-- | The <tt>USING</tt> section of a <tt>MERGE</tt> statement. Specifies
--   the temp table schema where the input values are.
data MergeUsing
MergeUsing :: TempTableName -> [ColumnName] -> MergeUsing
[$sel:mergeUsingTempTable:MergeUsing] :: MergeUsing -> TempTableName
[$sel:mergeUsingColumns:MergeUsing] :: MergeUsing -> [ColumnName]

-- | The <tt>ON</tt> section of a <tt>MERGE</tt> statement. Which columns
--   to match on?
data MergeOn
MergeOn :: [ColumnName] -> MergeOn
[$sel:mergeOnColumns:MergeOn] :: MergeOn -> [ColumnName]

-- | The <tt>WHEN MATCHED</tt> section of a <tt>MERGE</tt> statement. Which
--   columns to update when <tt>match_columns</tt> match (including
--   presets), and on which condition to actually update the values.
data MergeWhenMatched
MergeWhenMatched :: [ColumnName] -> Expression -> HashMap ColumnName Expression -> MergeWhenMatched
[$sel:mwmUpdateColumns:MergeWhenMatched] :: MergeWhenMatched -> [ColumnName]
[$sel:mwmCondition:MergeWhenMatched] :: MergeWhenMatched -> Expression
[$sel:mwmUpdatePreset:MergeWhenMatched] :: MergeWhenMatched -> HashMap ColumnName Expression

-- | The <tt>WHEN MATCHED</tt> section of a <tt>MERGE</tt> statement. Which
--   columns to insert?
newtype MergeWhenNotMatched
MergeWhenNotMatched :: [ColumnName] -> MergeWhenNotMatched
[$sel:mergeWhenNotMatchedInsertColumns:MergeWhenNotMatched] :: MergeWhenNotMatched -> [ColumnName]

-- | SELECT INTO temporary table statement without values. Used to create a
--   temporary table with the same schema as an existing table.
data SelectIntoTempTable
SelectIntoTempTable :: TempTableName -> [UnifiedColumn] -> TableName -> SITTConstraints -> SelectIntoTempTable
[$sel:sittTempTableName:SelectIntoTempTable] :: SelectIntoTempTable -> TempTableName
[$sel:sittColumns:SelectIntoTempTable] :: SelectIntoTempTable -> [UnifiedColumn]
[$sel:sittFromTableName:SelectIntoTempTable] :: SelectIntoTempTable -> TableName
[$sel:sittConstraints:SelectIntoTempTable] :: SelectIntoTempTable -> SITTConstraints

-- | When creating a temporary table from an existing table schema, what
--   should we do with the constraints (such as <tt>IDENTITY</tt>?)
data SITTConstraints
KeepConstraints :: SITTConstraints
RemoveConstraints :: SITTConstraints

-- | Simple insert into a temporary table.
data InsertValuesIntoTempTable
InsertValuesIntoTempTable :: TempTableName -> [ColumnName] -> [Values] -> InsertValuesIntoTempTable
[$sel:ivittTempTableName:InsertValuesIntoTempTable] :: InsertValuesIntoTempTable -> TempTableName
[$sel:ivittColumns:InsertValuesIntoTempTable] :: InsertValuesIntoTempTable -> [ColumnName]
[$sel:ivittValues:InsertValuesIntoTempTable] :: InsertValuesIntoTempTable -> [Values]

-- | A temporary table name is prepended by a hash-sign
newtype TempTableName
TempTableName :: Text -> TempTableName

-- | A name of a regular table or temporary table
data SomeTableName
RegularTableName :: TableName -> SomeTableName
TemporaryTableName :: TempTableName -> SomeTableName
data TempTable
TempTable :: TempTableName -> [ColumnName] -> TempTable
[$sel:ttName:TempTable] :: TempTable -> TempTableName
[$sel:ttColumns:TempTable] :: TempTable -> [ColumnName]

-- | A version of <a>Select</a> without a <tt>FROM</tt> clause. This means
--   it can only project expressions already selected in adjacent join
--   clauses, hence the name <tt>reselect</tt>.
data Reselect
Reselect :: [Projection] -> For -> Where -> Reselect
[$sel:reselectProjections:Reselect] :: Reselect -> [Projection]
[$sel:reselectFor:Reselect] :: Reselect -> For
[$sel:reselectWhere:Reselect] :: Reselect -> Where
data OrderBy
OrderBy :: Expression -> Order -> NullsOrder -> Maybe ScalarType -> OrderBy
[$sel:orderByExpression:OrderBy] :: OrderBy -> Expression
[$sel:orderByOrder:OrderBy] :: OrderBy -> Order
[$sel:orderByNullsOrder:OrderBy] :: OrderBy -> NullsOrder
[$sel:orderByType:OrderBy] :: OrderBy -> Maybe ScalarType
data Order
AscOrder :: Order
DescOrder :: Order
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder
NullsAnyOrder :: NullsOrder
data For
JsonFor :: ForJson -> For
NoFor :: For
data ForJson
ForJson :: JsonCardinality -> Root -> ForJson
[$sel:jsonCardinality:ForJson] :: ForJson -> JsonCardinality
[$sel:jsonRoot:ForJson] :: ForJson -> Root
data Root
NoRoot :: Root
Root :: Text -> Root
data JsonCardinality
JsonArray :: JsonCardinality
JsonSingleton :: JsonCardinality
data Projection
ExpressionProjection :: Aliased Expression -> Projection
FieldNameProjection :: Aliased FieldName -> Projection
AggregateProjection :: Aliased Aggregate -> Projection
StarProjection :: Projection
data Join
Join :: JoinSource -> JoinAlias -> Where -> Join
[$sel:joinSource:Join] :: Join -> JoinSource
[$sel:joinJoinAlias:Join] :: Join -> JoinAlias
[$sel:joinWhere:Join] :: Join -> Where
data JoinSource
JoinSelect :: Select -> JoinSource
JoinReselect :: Reselect -> JoinSource
data JoinAlias
JoinAlias :: Text -> Maybe Text -> JoinAlias
[$sel:joinAliasEntity:JoinAlias] :: JoinAlias -> Text
[$sel:joinAliasField:JoinAlias] :: JoinAlias -> Maybe Text
newtype Where
Where :: [Expression] -> Where
newtype With
With :: NonEmpty (Aliased CTEBody) -> With

-- | Something that can appear in a CTE body.
data CTEBody
CTESelect :: Select -> CTEBody
CTEUnsafeRawSQL :: InterpolatedQuery Expression -> CTEBody

-- | Extra query steps that can be emitted from the main query to do things
--   like setup temp tables
data TempTableDDL

-- | create a temp table
TempTableCreate :: TempTableName -> [UnifiedColumn] -> TempTableDDL

-- | insert output of a statement into a temp table
TempTableInsert :: TempTableName -> [Declare] -> InterpolatedQuery Expression -> TempTableDDL

-- | Drop a temp table
TempTableDrop :: TempTableName -> TempTableDDL
data Declare
Declare :: Text -> ScalarType -> Expression -> Declare
[$sel:dName:Declare] :: Declare -> Text
[$sel:dType:Declare] :: Declare -> ScalarType
[$sel:dValue:Declare] :: Declare -> Expression
data Top
NoTop :: Top
Top :: Int -> Top
data Expression
ValueExpression :: Value -> Expression
AndExpression :: [Expression] -> Expression
OrExpression :: [Expression] -> Expression
NotExpression :: Expression -> Expression
ExistsExpression :: Select -> Expression
SelectExpression :: Select -> Expression
IsNullExpression :: Expression -> Expression
IsNotNullExpression :: Expression -> Expression
ColumnExpression :: FieldName -> Expression

-- | This one acts like a "cast to JSON" and makes SQL Server behave like
--   it knows your field is JSON and not double-encode it.
JsonQueryExpression :: Expression -> Expression
ToStringExpression :: Expression -> Expression
MethodApplicationExpression :: Expression -> MethodApplicationExpression -> Expression
FunctionApplicationExpression :: FunctionApplicationExpression -> Expression

-- | This is for getting actual atomic values out of a JSON string.
JsonValueExpression :: Expression -> JsonPath -> Expression
OpExpression :: Op -> Expression -> Expression -> Expression
ListExpression :: [Expression] -> Expression
STOpExpression :: SpatialOp -> Expression -> Expression -> Expression
CastExpression :: Expression -> ScalarType -> DataLength -> Expression

-- | "CASE WHEN (expression) THEN (expression) ELSE (expression) END"
ConditionalExpression :: Expression -> Expression -> Expression -> Expression

-- | The <tt>DEFAULT</tt> value. TODO: Make this as a part of
--   @<a>Value</a>.
DefaultExpression :: Expression

-- | Data type describing the length of a datatype. Used in
--   <a>CastExpression</a>s.
data DataLength
DataLengthUnspecified :: DataLength
DataLengthInt :: Int -> DataLength
DataLengthMax :: DataLength

-- | SQL functions application: <tt>some_function(e1, e2, ..)</tt>.
data FunctionApplicationExpression
FunExpISNULL :: Expression -> Expression -> FunctionApplicationExpression

-- | Object expression method application: <tt>(expression).text(e1, e2,
--   ..)</tt>
data MethodApplicationExpression
MethExpSTAsText :: MethodApplicationExpression
data JsonPath
RootPath :: JsonPath
FieldPath :: JsonPath -> Text -> JsonPath
IndexPath :: JsonPath -> Integer -> JsonPath
data Aggregate
CountAggregate :: Countable Expression -> Aggregate
OpAggregate :: Text -> [Expression] -> Aggregate
TextAggregate :: Text -> Aggregate
newtype CountType field
CountType :: Countable (ColumnName, AnnRedactionExp 'MSSQL field) -> CountType field
[$sel:getCountType:CountType] :: CountType field -> Countable (ColumnName, AnnRedactionExp 'MSSQL field)
data Countable name
StarCountable :: Countable name
NonNullFieldCountable :: name -> Countable name
DistinctCountable :: name -> Countable name
data From
FromQualifiedTable :: Aliased TableName -> From
FromOpenJson :: Aliased OpenJson -> From
FromSelect :: Aliased Select -> From
FromIdentifier :: Text -> From
FromTempTable :: Aliased TempTableName -> From

-- | Extract the name bound in a <a>From</a> clause as an
--   <a>EntityAlias</a>.
fromAlias :: From -> EntityAlias
data OpenJson
OpenJson :: Expression -> Maybe (NonEmpty JsonFieldSpec) -> OpenJson
[$sel:openJsonExpression:OpenJson] :: OpenJson -> Expression
[$sel:openJsonWith:OpenJson] :: OpenJson -> Maybe (NonEmpty JsonFieldSpec)
data JsonFieldSpec
ScalarField :: ScalarType -> DataLength -> Text -> Maybe JsonPath -> JsonFieldSpec
JsonField :: Text -> Maybe JsonPath -> JsonFieldSpec
StringField :: Text -> Maybe JsonPath -> JsonFieldSpec
data Aliased a
Aliased :: a -> Text -> Aliased a
[$sel:aliasedThing:Aliased] :: Aliased a -> a
[$sel:aliasedAlias:Aliased] :: Aliased a -> Text
newtype SchemaName
SchemaName :: Text -> SchemaName
[$sel:_unSchemaName:SchemaName] :: SchemaName -> Text
data TableName
TableName :: Text -> SchemaName -> TableName
[$sel:tableName:TableName] :: TableName -> Text
[$sel:tableSchema:TableName] :: TableName -> SchemaName
data FieldName
FieldName :: Text -> Text -> FieldName
[$sel:fieldName:FieldName] :: FieldName -> Text
[$sel:fieldNameEntity:FieldName] :: FieldName -> Text
data Comment
DueToPermission :: Comment
RequestedSingleObject :: Comment
newtype EntityAlias
EntityAlias :: Text -> EntityAlias
[$sel:entityAliasText:EntityAlias] :: EntityAlias -> Text
columnNameToFieldName :: ColumnName -> EntityAlias -> FieldName
data Op
LT :: Op
LTE :: Op
GT :: Op
GTE :: Op
IN :: Op
LIKE :: Op
NLIKE :: Op
NIN :: Op
EQ' :: Op
NEQ' :: Op

-- | Supported operations for spatial data types
data SpatialOp
STEquals :: SpatialOp
STContains :: SpatialOp
STCrosses :: SpatialOp
STIntersects :: SpatialOp
STOverlaps :: SpatialOp
STWithin :: SpatialOp
STTouches :: SpatialOp

-- | Column name of some database table -- this differs to FieldName that
--   is used for referring to things within a query.
newtype ColumnName
ColumnName :: Text -> ColumnName
[$sel:columnNameText:ColumnName] :: ColumnName -> Text
newtype ConstraintName
ConstraintName :: Text -> ConstraintName
[$sel:constraintNameText:ConstraintName] :: ConstraintName -> Text
data FunctionName
FunctionName :: Text -> SchemaName -> FunctionName
[$sel:functionName:FunctionName] :: FunctionName -> Text
[$sel:functionSchema:FunctionName] :: FunctionName -> SchemaName

-- | type for a query generated from IR along with any DDL actions
data QueryWithDDL a
QueryWithDDL :: [TempTableDDL] -> a -> [TempTableDDL] -> QueryWithDDL a
[$sel:qwdBeforeSteps:QueryWithDDL] :: QueryWithDDL a -> [TempTableDDL]
[$sel:qwdQuery:QueryWithDDL] :: QueryWithDDL a -> a
[$sel:qwdAfterSteps:QueryWithDDL] :: QueryWithDDL a -> [TempTableDDL]

-- | Derived from the odbc package.
data ScalarType
CharType :: ScalarType
NumericType :: ScalarType
DecimalType :: ScalarType
IntegerType :: ScalarType
SmallintType :: ScalarType
FloatType :: ScalarType
RealType :: ScalarType
DateType :: ScalarType
Ss_time2Type :: ScalarType
VarcharType :: ScalarType
WcharType :: ScalarType
WvarcharType :: ScalarType
WtextType :: ScalarType
TimestampType :: ScalarType
TextType :: ScalarType
BinaryType :: ScalarType
VarbinaryType :: ScalarType
BigintType :: ScalarType
TinyintType :: ScalarType
BitType :: ScalarType
GuidType :: ScalarType
GeographyType :: ScalarType
GeometryType :: ScalarType
UnknownType :: Text -> ScalarType
scalarTypeDBName :: DataLength -> ScalarType -> Text
mkMSSQLScalarTypeName :: MonadError QErr m => ScalarType -> m Name
parseScalarType :: Text -> ScalarType
parseScalarValue :: ScalarType -> Value -> Either QErr Value
isComparableType :: ScalarType -> Bool
isNumType :: ScalarType -> Bool
getGQLTableName :: TableName -> Either QErr Name
getGQLFunctionName :: FunctionName -> Either QErr Name
snakeCaseName :: Text -> SchemaName -> Text
getTableIdentifier :: TableName -> Either QErr GQLNameIdentifier
namingConventionSupport :: SupportedNamingCase
stringTypes :: [ScalarType]
geoTypes :: [ScalarType]
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.String.IsString Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Base.Semigroup Hasura.Backends.MSSQL.Types.Internal.With
instance GHC.Base.Functor Hasura.Backends.MSSQL.Types.Internal.Countable


-- | MSSQL Types Instances
--   
--   Instances for types from <a>Hasura.Backends.MSSQL.Types.Internal</a>
--   that're slow to compile.
module Hasura.Backends.MSSQL.Types.Instances
instance GHC.Generics.Generic (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Base.Functor Hasura.Backends.MSSQL.Types.Internal.Aliased
instance Data.Data.Data a => Data.Data.Data (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Where
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.For
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.For
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.For
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.For
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ForJson
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ForJson
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.ForJson
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ForJson
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Root
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Root
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Root
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Root
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Reselect
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Reselect
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Reselect
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Reselect
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.DataLength
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.DataLength
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.DataLength
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.DataLength
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Expression
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Expression
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Expression
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Expression
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Order
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Order
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Order
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Select
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Select
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Select
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Select
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.With
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.With
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.With
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.With
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Top
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.FieldName
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.FieldName
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.FieldName
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Op
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Op
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Op
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Op
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Projection
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Projection
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Projection
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Projection
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.From
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.From
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.From
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.From
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Join
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Join
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Join
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Join
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Inserted
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Inserted
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Inserted
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Inserted
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.TempTable
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.TempTable
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.TempTable
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.TempTable
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Deleted
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Deleted
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Deleted
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Deleted
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Values
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Values
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Values
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Values
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Delete
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Delete
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Delete
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Delete
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Insert
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Insert
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Insert
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Insert
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.Merge
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.Merge
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.Merge
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.Merge
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance GHC.Classes.Eq Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance GHC.Show.Show Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance Data.Data.Data Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.TableName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.TableName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.MSSQL.Types.Internal.Order
instance GHC.Generics.Generic Data.Time.LocalTime.Internal.TimeZone.TimeZone
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Generics.Generic (Hasura.Backends.MSSQL.Types.Internal.CountType n)
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL, GHC.Show.Show n, GHC.Show.Show (Hasura.RQL.Types.Backend.AggregationPredicates 'Hasura.RQL.Types.BackendType.MSSQL n), GHC.Show.Show (Hasura.RQL.Types.Backend.FunctionArgumentExp 'Hasura.RQL.Types.BackendType.MSSQL n), GHC.Show.Show (Hasura.RQL.Types.Backend.BooleanOperators 'Hasura.RQL.Types.BackendType.MSSQL n)) => GHC.Show.Show (Hasura.Backends.MSSQL.Types.Internal.CountType n)
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => GHC.Base.Functor Hasura.Backends.MSSQL.Types.Internal.CountType
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Internal.CountType
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Internal.CountType
instance Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Internal.Countable
instance Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Internal.Countable
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL, GHC.Classes.Eq n, GHC.Classes.Eq (Hasura.RQL.Types.Backend.AggregationPredicates 'Hasura.RQL.Types.BackendType.MSSQL n), GHC.Classes.Eq (Hasura.RQL.Types.Backend.FunctionArgumentExp 'Hasura.RQL.Types.BackendType.MSSQL n), GHC.Classes.Eq (Hasura.RQL.Types.Backend.BooleanOperators 'Hasura.RQL.Types.BackendType.MSSQL n)) => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Internal.CountType n)
instance GHC.Generics.Generic (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Classes.Eq n => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Show.Show n => GHC.Show.Show (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Data.Data.Data n => Data.Data.Data (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Classes.Ord Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance GHC.Base.Monoid Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Base.Semigroup Hasura.Backends.MSSQL.Types.Internal.Where
instance GHC.Generics.Generic (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance GHC.Base.Functor Hasura.Backends.MSSQL.Types.Internal.BooleanOperators
instance Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Internal.BooleanOperators
instance Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Internal.BooleanOperators
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.MSSQL.Types.Internal.Aliased a)
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedTableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedObjectRelationship
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedArrayRelationship
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedUsing
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedOn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.UnifiedColumn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.TempTableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.SomeTableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Where
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Where
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.For
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.For
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Aggregate
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.EntityAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ForJson
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ForJson
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JsonCardinality
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Root
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Root
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.OrderBy
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JoinAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Reselect
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Reselect
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.DataLength
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.DataLength
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Expression
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Expression
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.FunctionApplicationExpression
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MethodApplicationExpression
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Order
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.TableName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Select
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Select
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.With
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.With
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.CTEBody
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Top
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Top
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JsonPath
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Op
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Op
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SpatialOp
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Projection
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Projection
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.From
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.From
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.OpenJson
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JsonFieldSpec
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Join
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Join
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.JoinSource
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SelectIntoTempTable
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.SITTConstraints
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.InsertValuesIntoTempTable
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.InsertOutput
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Inserted
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Inserted
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.OutputColumn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.TempTable
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.TempTable
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Deleted
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Deleted
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.DeleteOutput
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Values
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Values
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Delete
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Delete
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Insert
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Insert
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.Merge
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.Merge
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeUsing
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeOn
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeWhenMatched
instance Data.Hashable.Class.Hashable Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance Control.DeepSeq.NFData Hasura.Backends.MSSQL.Types.Internal.MergeWhenNotMatched
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.TableName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Types.Internal.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.Order
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.NullsOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.FieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Types.Internal.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.FunctionName
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Types.Internal.TableName
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Types.Internal.SchemaName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.MSSQL.Types.Internal.ScalarType
instance Data.Hashable.Class.Hashable n => Data.Hashable.Class.Hashable (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Control.DeepSeq.NFData n => Control.DeepSeq.NFData (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Data.Aeson.Types.ToJSON.ToJSON n => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance Data.Aeson.Types.FromJSON.FromJSON n => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.MSSQL.Types.Internal.Countable n)
instance GHC.Base.Monoid Hasura.Backends.MSSQL.Types.Internal.Top
instance GHC.Base.Semigroup Hasura.Backends.MSSQL.Types.Internal.Top
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.MSSQL.Types.Internal.BooleanOperators a)
instance Autodocodec.Class.HasCodec Hasura.Backends.MSSQL.Types.Internal.ScalarType


-- | MSSQL Types Update
--   
--   This module defines the Update-related IR types specific to MSSQL.
module Hasura.Backends.MSSQL.Types.Update

-- | The various <tt>update operators</tt> supported by MSSQL, i.e. the
--   <tt>_set</tt>, <tt>_inc</tt> operators that appear in the schema.
--   
--   TODO: Docs for MSSQL! See <a>Update Mutations User docs</a>
data UpdateOperator v
UpdateSet :: v -> UpdateOperator v
UpdateInc :: v -> UpdateOperator v
type UpdateSet = HashMap ColumnName (UpdateOperator Expression)
type UpdateOutput = Output Inserted

-- | UPDATE [table_alias] SET [table_alias].column = <tt>value</tt> OUTPUT
--   INSERTED.column INTO #updated FROM [table_name] AS [table_alias] WHERE
--   <a>filter-expression</a>
data Update
Update :: Aliased TableName -> UpdateSet -> UpdateOutput -> TempTable -> Where -> Update
[updateTable] :: Update -> Aliased TableName
[updateSet] :: Update -> UpdateSet
[updateOutput] :: Update -> UpdateOutput
[updateTempTable] :: Update -> TempTable
[updateWhere] :: Update -> Where
instance Data.Data.Data v => Data.Data.Data (Hasura.Backends.MSSQL.Types.Update.UpdateOperator v)
instance GHC.Generics.Generic (Hasura.Backends.MSSQL.Types.Update.UpdateOperator v)
instance Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Update.UpdateOperator
instance Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Update.UpdateOperator
instance GHC.Base.Functor Hasura.Backends.MSSQL.Types.Update.UpdateOperator


-- | MSSQL Types Insert
--   
--   Types for MSSQL Insert IR.
module Hasura.Backends.MSSQL.Types.Insert

-- | Defines the part in insert mutation that is unique for MSSQL the
--   <tt>if_matched</tt> clause.
data BackendInsert v
BackendInsert :: Maybe (IfMatched v) -> BackendInsert v

-- | <tt>if_matched</tt> can be omitted (and in that case will be
--   <tt>Nothing</tt>). If omitted, we only insert new rows (without
--   upserting).
[_biIfMatched] :: BackendInsert v -> Maybe (IfMatched v)

-- | The IR data representing an <tt>if_matched</tt> clause, which handles
--   upserts.
data IfMatched v
IfMatched :: [Column 'MSSQL] -> [Column 'MSSQL] -> AnnBoolExp 'MSSQL v -> HashMap ColumnName v -> IfMatched v

-- | Columns to compare when checking if there's a match
[_imMatchColumns] :: IfMatched v -> [Column 'MSSQL]

-- | Columns to update when there's a match
[_imUpdateColumns] :: IfMatched v -> [Column 'MSSQL]

-- | A condition for updating columns in case of a match
[_imConditions] :: IfMatched v -> AnnBoolExp 'MSSQL v

-- | Default values (presets) for some columns
[_imColumnPresets] :: IfMatched v -> HashMap ColumnName v
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL, GHC.Show.Show (Hasura.Backends.MSSQL.Types.Insert.IfMatched v), GHC.Show.Show v) => GHC.Show.Show (Hasura.Backends.MSSQL.Types.Insert.BackendInsert v)
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => GHC.Base.Functor Hasura.Backends.MSSQL.Types.Insert.BackendInsert
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Insert.BackendInsert
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Insert.BackendInsert
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp 'Hasura.RQL.Types.BackendType.MSSQL v), GHC.Show.Show v) => GHC.Show.Show (Hasura.Backends.MSSQL.Types.Insert.IfMatched v)
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => GHC.Base.Functor Hasura.Backends.MSSQL.Types.Insert.IfMatched
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => Data.Foldable.Foldable Hasura.Backends.MSSQL.Types.Insert.IfMatched
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => Data.Traversable.Traversable Hasura.Backends.MSSQL.Types.Insert.IfMatched


-- | This module exports modules <tt>Hasura.Backends.MSSQL.Types.*</tt>.
--   
--   The types in <a>Hasura.Backends.MSSQL.Types.Internal</a> define types
--   which represent T-SQL AST.
--   
--   The other modules such as <a>Hasura.Backends.MSSQL.Types.Insert</a>
--   and <a>Hasura.Backends.MSSQL.Types.Update</a> represent GraphQL AST
--   parts that are unique for MSSQL.
module Hasura.Backends.MSSQL.Types


-- | MSSQL ToQuery
--   
--   Convert the simple T-SQL AST to an SQL query, ready to be passed to
--   the odbc package's query/exec functions.
--   
--   We define a custom prettyprinter with the type <a>Printer</a>.
--   
--   If you'd like to trace and see what a <a>Printer</a> looks like as
--   SQL, you can use something like: &gt; ltraceM "sql" (ODBC.renderQuery
--   (toQueryPretty myPrinter))
module Hasura.Backends.MSSQL.ToQuery
data Printer
SeqPrinter :: [Printer] -> Printer
SepByPrinter :: Printer -> [Printer] -> Printer
NewlinePrinter :: Printer
QueryPrinter :: Query -> Printer
IndentPrinter :: Int -> Printer -> Printer
(<+>) :: Printer -> Printer -> Printer
fromInsert :: Insert -> Printer
fromSetIdentityInsert :: SetIdentityInsert -> Printer

-- | Generate a statement to insert values into temporary table.
fromInsertValuesIntoTempTable :: InsertValuesIntoTempTable -> Printer

-- | Generate a MERGE SQL statement
fromMerge :: Merge -> Printer

-- | Generate a delete statement
--   
--   <pre>
--   Delete
--     (Aliased (TableName "table" "schema") "alias")
--     [ColumnName "id", ColumnName "name"]
--     (Where [OpExpression EQ' (ValueExpression (IntValue 1)) (ValueExpression (IntValue 1))])
--   </pre>
--   
--   Becomes:
--   
--   <pre>
--   DELETE [alias] OUTPUT DELETED.[id], DELETED.[name] INTO #deleted([id], [name]) FROM [schema].[table] AS [alias] WHERE ((1) = (1))
--   </pre>
fromDelete :: Delete -> Printer

-- | Generate an update statement
--   
--   <pre>
--   Update
--      (Aliased (TableName "table" "schema") "alias")
--      (fromList [(ColumnName "name", ValueExpression (TextValue "updated_name"))])
--      (Output Inserted)
--      (TempTable (TempTableName "updated") [ColumnName "id", ColumnName "name"])
--      (Where [OpExpression EQ' (ColumnName "id") (ValueExpression (IntValue 1))])
--   </pre>
--   
--   Becomes:
--   
--   <pre>
--   UPDATE [alias] SET [alias].[name] = 'updated_name' OUTPUT INSERTED.[id], INSERTED.[name] INTO
--   #updated([id], [name]) FROM [schema].[table] AS [alias] WHERE (id = 1)
--   </pre>
fromUpdate :: Update -> Printer
fromTempTableDDL :: TempTableDDL -> Printer

-- | Converts <a>SelectIntoTempTable</a>.
--   
--   <pre>
--   SelectIntoTempTable (TempTableName "deleted")  [UnifiedColumn "id" IntegerType, UnifiedColumn "name" TextType] (TableName "table" "schema")
--   </pre>
--   
--   Becomes:
--   
--   <pre>
--   SELECT [id], [name] INTO #deleted([id], [name]) FROM [schema].[table] WHERE (1&lt;&gt;1) UNION ALL SELECT [id], [name] FROM [schema].[table];
--   </pre>
--   
--   We add the `UNION ALL` part to avoid copying identity constraints, and
--   we cast columns with types such as <tt>timestamp</tt> which are
--   non-insertable to a different type.
fromSelectIntoTempTable :: SelectIntoTempTable -> Printer

-- | @TempTableName "temp_table" is converted to "DROP TABLE #temp_table"
dropTempTableQuery :: TempTableName -> Printer
fromSelect :: Select -> Printer
fromReselect :: Reselect -> Printer
fromTableName :: TableName -> Printer
fromRawUnescapedText :: Text -> Printer

-- | Pretty-prints a <a>Printer</a> as one line, converting
--   <a>NewlinePrinter</a> to space.
toQueryFlat :: Printer -> Query

-- | Pretty-prints a <a>Printer</a> as multiple lines as defined by the
--   printer.
toQueryPretty :: Printer -> Query
instance GHC.Classes.Eq Hasura.Backends.MSSQL.ToQuery.Printer
instance GHC.Show.Show Hasura.Backends.MSSQL.ToQuery.Printer
instance Data.String.IsString Hasura.Backends.MSSQL.ToQuery.Printer
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.Types.Internal.Expression


-- | MSSQL Instances Types
--   
--   Defines a <a>Backend</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.Types
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.RQL.Types.SourceConfiguration.HasSourceConfiguration 'Hasura.RQL.Types.BackendType.MSSQL


-- | This module contains supporting definitions for building temporary
--   tables based off of the schema of other tables. This is used in
--   mutations to capture the data of rows that are affected.
module Hasura.Backends.MSSQL.FromIr.SelectIntoTempTable

-- | Create a temporary table with the same schema as the given table.
toSelectIntoTempTable :: TempTableName -> TableName -> [ColumnInfo 'MSSQL] -> SITTConstraints -> SelectIntoTempTable


-- | This module provides constants that are either:
--   
--   <ul>
--   <li>Simply in common user</li>
--   <li>Define names that that multiple pieces of code reference.</li>
--   </ul>
module Hasura.Backends.MSSQL.FromIr.Constants
trueExpression :: Expression
nullExpression :: Expression
emptyArrayExpression :: Expression
jsonFieldName :: Text
aggSubselectName :: Text
existsFieldName :: Text
aggFieldName :: Text
tempTableNameInserted :: TempTableName
tempTableNameValues :: TempTableName
tempTableNameDeleted :: TempTableName
tempTableNameUpdated :: TempTableName

module Hasura.Backends.DataConnector.Adapter.Types
data ConnSourceConfig
ConnSourceConfig :: Config -> Maybe Text -> Maybe SourceTimeout -> ConnSourceConfig

-- | An arbitrary JSON payload to be passed to the agent in a header. HGE
--   validates this against the OpenAPI Spec provided by the agent.
[value] :: ConnSourceConfig -> Config

-- | Kriti Template for transforming the supplied <a>Config</a> value.
[template] :: ConnSourceConfig -> Maybe Text

-- | Timeout setting for HTTP requests to the agent. -- TODO: verify with
--   lyndon
[timeout] :: ConnSourceConfig -> Maybe SourceTimeout
data SourceTimeout
sourceTimeoutMicroseconds :: SourceTimeout -> Int
data SourceConfig
SourceConfig :: BaseUrl -> Config -> Maybe Text -> Capabilities -> Manager -> Maybe Int -> DataConnectorName -> Environment -> SourceConfig
[_scEndpoint] :: SourceConfig -> BaseUrl
[_scConfig] :: SourceConfig -> Config
[_scTemplate] :: SourceConfig -> Maybe Text
[_scCapabilities] :: SourceConfig -> Capabilities
[_scManager] :: SourceConfig -> Manager
[_scTimeoutMicroseconds] :: SourceConfig -> Maybe Int
[_scDataConnectorName] :: SourceConfig -> DataConnectorName
[_scEnvironment] :: SourceConfig -> Environment

-- | This represents what information can be known about the return type of
--   a user-defined function. For now, either the return type will be the
--   name of a table that exists in the schema, or <a>Unknown</a> -
--   implying that this information can be derived from another source, or
--   if there is no other source, then it is an error. In future, this type
--   may be extended with additional constructors including scalar and row
--   types from the Logical Models feature.
--   
--   Note: This is very similar to ComputedFieldReturnType defined above.
--   The two types may be unified in future.
data FunctionReturnType
FunctionReturnsTable :: TableName -> FunctionReturnType
FunctionReturnsUnknown :: FunctionReturnType
data DataConnectorOptions
DataConnectorOptions :: BaseUrl -> Maybe Text -> DataConnectorOptions
[_dcoUri] :: DataConnectorOptions -> BaseUrl
[_dcoDisplayName] :: DataConnectorOptions -> Maybe Text
data DataConnectorInfo
DataConnectorInfo :: DataConnectorOptions -> Capabilities -> ConfigSchemaResponse -> Maybe Text -> Maybe Text -> DataConnectorInfo
[_dciOptions] :: DataConnectorInfo -> DataConnectorOptions
[_dciCapabilities] :: DataConnectorInfo -> Capabilities
[_dciConfigSchemaResponse] :: DataConnectorInfo -> ConfigSchemaResponse
[_dciDisplayName] :: DataConnectorInfo -> Maybe Text
[_dciReleaseName] :: DataConnectorInfo -> Maybe Text

-- | The fully qualified name of a table. The last element in the list is
--   the table name and all other elements represent namespacing of the
--   table name. For example, for a database that has schemas, the name
--   would be '[<a>schema</a>,<a>name</a>]'
newtype TableName
TableName :: NonEmpty Text -> TableName
[unTableName] :: TableName -> NonEmpty Text
newtype ConstraintName
ConstraintName :: Text -> ConstraintName
[unConstraintName] :: ConstraintName -> Text
newtype ColumnName
ColumnName :: Text -> ColumnName
[unColumnName] :: ColumnName -> Text
newtype FunctionName
FunctionName :: NonEmpty Text -> FunctionName
[unFunctionName] :: FunctionName -> NonEmpty Text
data ArgumentExp a

-- | Table row accessor AETableRow | -- | Hardcoded reference to
--   <tt>hdb_catalog.hdb_action_log.response_payload</tt>
--   AEActionResponsePayload | -- | JSON/JSONB hasura session variable
--   object AESession a |
AEInput :: a -> ArgumentExp a
data CountAggregate v
StarCount :: CountAggregate v
ColumnCount :: (ColumnName, AnnRedactionExp 'DataConnector v) -> CountAggregate v
ColumnDistinctCount :: (ColumnName, AnnRedactionExp 'DataConnector v) -> CountAggregate v
data Literal
ValueLiteral :: ScalarType -> Value -> Literal
ArrayLiteral :: ScalarType -> [Value] -> Literal
data OrderDirection
Ascending :: OrderDirection
Descending :: OrderDirection
newtype ScalarType
ScalarType :: Text -> ScalarType
[unScalarType] :: ScalarType -> Text
fromGQLType :: Name -> ScalarType

-- | This type captures backend-specific "extra" information about tables
--   and is used on types like <tt>DBTableMetadata</tt>
data ExtraTableMetadata
ExtraTableMetadata :: TableType -> HashMap ColumnName ExtraColumnMetadata -> ExtraTableMetadata
[_etmTableType] :: ExtraTableMetadata -> TableType
[_etmExtraColumnMetadata] :: ExtraTableMetadata -> HashMap ColumnName ExtraColumnMetadata
data ExtraColumnMetadata
ExtraColumnMetadata :: Maybe ColumnValueGenerationStrategy -> ExtraColumnMetadata
[_ecmValueGenerated] :: ExtraColumnMetadata -> Maybe ColumnValueGenerationStrategy
scTimeoutMicroseconds :: Lens' SourceConfig (Maybe Int)
scTemplate :: Lens' SourceConfig (Maybe Text)
scManager :: Lens' SourceConfig Manager
scEnvironment :: Lens' SourceConfig Environment
scEndpoint :: Lens' SourceConfig BaseUrl
scDataConnectorName :: Lens' SourceConfig DataConnectorName
scConfig :: Lens' SourceConfig Config
scCapabilities :: Lens' SourceConfig Capabilities
instance Data.Has.Has Hasura.Backends.DataConnector.API.V0.Capabilities.ScalarTypesCapabilities Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.DataConnectorInfo
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.DataConnectorInfo
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.DataConnectorInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.TableName
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.TableName
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.TableName
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.TableName
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Data.Data.Data Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Data.Data Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Data.Data Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Data.Data.Data Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance GHC.Generics.Generic (Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp a)
instance Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp
instance Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp
instance GHC.Base.Functor Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp a)
instance GHC.Generics.Generic (Hasura.Backends.DataConnector.Adapter.Types.CountAggregate v)
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance Data.Data.Data Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.Literal
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.Literal
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.Literal
instance GHC.Classes.Ord Hasura.Backends.DataConnector.Adapter.Types.Literal
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.Literal
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.Literal
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.Literal
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ExtraColumnMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance Control.DeepSeq.NFData Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance Data.Hashable.Class.Hashable Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance GHC.Generics.Generic Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.ExtraTableMetadata
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp 'Hasura.RQL.Types.BackendType.DataConnector v), GHC.Show.Show v) => GHC.Show.Show (Hasura.Backends.DataConnector.Adapter.Types.CountAggregate v)
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => GHC.Base.Functor Hasura.Backends.DataConnector.Adapter.Types.CountAggregate
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Types.CountAggregate
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Types.CountAggregate
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp 'Hasura.RQL.Types.BackendType.DataConnector v), GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.Backends.DataConnector.Adapter.Types.CountAggregate v)
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector, Data.Data.Data (Hasura.RQL.IR.BoolExp.AnnRedactionExp 'Hasura.RQL.Types.BackendType.DataConnector v), Data.Data.Data v) => Data.Data.Data (Hasura.Backends.DataConnector.Adapter.Types.CountAggregate v)
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.ScalarType Hasura.Backends.DataConnector.API.V0.Scalar.ScalarType
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Scalar.ScalarType Hasura.Backends.DataConnector.Adapter.Types.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.OrderBy.OrderDirection Hasura.Backends.DataConnector.Adapter.Types.OrderDirection
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.OrderDirection Hasura.Backends.DataConnector.API.V0.OrderBy.OrderDirection
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.DataConnector.Adapter.Types.ArgumentExp a)
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.FunctionName Hasura.Backends.DataConnector.API.V0.Function.FunctionName
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Function.FunctionName Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Witch.From.From (GHC.Base.NonEmpty Data.Text.Internal.Text) Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.Adapter.Types.FunctionName
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Column.ColumnName Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.ColumnName Hasura.Backends.DataConnector.API.V0.Column.ColumnName
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.Adapter.Types.ColumnName
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Table.ConstraintName Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.ConstraintName Hasura.Backends.DataConnector.API.V0.Table.ConstraintName
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.Adapter.Types.ConstraintName
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.FunctionReturnType
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Witch.From.From Hasura.Backends.DataConnector.API.V0.Table.TableName Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Witch.From.From Hasura.Backends.DataConnector.Adapter.Types.TableName Hasura.Backends.DataConnector.API.V0.Table.TableName
instance Data.Text.Extended.ToTxt Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.DataConnector.Adapter.Types.TableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorInfo
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.DataConnectorOptions
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.SourceConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.ConnSourceConfig
instance Autodocodec.Class.HasCodec Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.Types.SourceTimeout

module Hasura.Backends.DataConnector.Adapter.Backend
data CustomBooleanOperator a
CustomBooleanOperator :: Text -> Maybe a -> CustomBooleanOperator a
[_cboName] :: CustomBooleanOperator a -> Text
[_cboRHS] :: CustomBooleanOperator a -> Maybe a
parseValue :: ScalarTypesCapabilities -> ScalarType -> Value -> Parser Value
lookupGraphQLType :: ScalarTypesCapabilities -> ScalarType -> Maybe GraphQLType
columnTypeToScalarType :: ColumnType 'DataConnector -> ScalarType
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Data.Traversable.Traversable Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator
instance GHC.Base.Functor Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator
instance Data.Foldable.Foldable Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator
instance GHC.Generics.Generic (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.DataConnector.Adapter.Backend.CustomBooleanOperator a)
instance Hasura.RQL.Types.SourceConfiguration.HasSourceConfiguration 'Hasura.RQL.Types.BackendType.DataConnector


-- | Types for BigQuery
module Hasura.Backends.BigQuery.Types
data Select
Select :: Maybe With -> Top -> AsStruct -> NonEmpty Projection -> From -> [Join] -> Where -> Maybe (NonEmpty OrderBy) -> Maybe Expression -> [FieldName] -> Maybe [Text] -> Cardinality -> Select
[$sel:selectWith:Select] :: Select -> Maybe With
[$sel:selectTop:Select] :: Select -> Top
[$sel:selectAsStruct:Select] :: Select -> AsStruct
[$sel:selectProjections:Select] :: Select -> NonEmpty Projection
[$sel:selectFrom:Select] :: Select -> From
[$sel:selectJoins:Select] :: Select -> [Join]
[$sel:selectWhere:Select] :: Select -> Where
[$sel:selectOrderBy:Select] :: Select -> Maybe (NonEmpty OrderBy)
[$sel:selectOffset:Select] :: Select -> Maybe Expression
[$sel:selectGroupBy:Select] :: Select -> [FieldName]
[$sel:selectFinalWantedFields:Select] :: Select -> Maybe [Text]
[$sel:selectCardinality:Select] :: Select -> Cardinality

-- | Helper type allowing addition of extra fields used in PARTITION BY.
--   
--   The main purpose of this type is sumulation of DISTINCT ON implemented
--   in Hasura.Backends.BigQuery.FromIr.simulateDistinctOn
data PartitionableSelect
PartitionableSelect :: (Maybe [FieldName] -> Select) -> From -> PartitionableSelect
[$sel:pselectFinalize:PartitionableSelect] :: PartitionableSelect -> Maybe [FieldName] -> Select
[$sel:pselectFrom:PartitionableSelect] :: PartitionableSelect -> From
simpleSelect :: Select -> PartitionableSelect
noExtraPartitionFields :: PartitionableSelect -> Select
withExtraPartitionFields :: PartitionableSelect -> [FieldName] -> Select
data ArrayAgg
ArrayAgg :: NonEmpty Projection -> Maybe (NonEmpty OrderBy) -> Top -> ArrayAgg
[$sel:arrayAggProjections:ArrayAgg] :: ArrayAgg -> NonEmpty Projection
[$sel:arrayAggOrderBy:ArrayAgg] :: ArrayAgg -> Maybe (NonEmpty OrderBy)
[$sel:arrayAggTop:ArrayAgg] :: ArrayAgg -> Top
data Reselect
Reselect :: NonEmpty Projection -> Where -> Reselect
[$sel:reselectProjections:Reselect] :: Reselect -> NonEmpty Projection
[$sel:reselectWhere:Reselect] :: Reselect -> Where
data OrderBy
OrderBy :: Expression -> FieldName -> Order -> NullsOrder -> OrderBy
[$sel:orderByExpression:OrderBy] :: OrderBy -> Expression
[$sel:orderByFieldName:OrderBy] :: OrderBy -> FieldName
[$sel:orderByOrder:OrderBy] :: OrderBy -> Order
[$sel:orderByNullsOrder:OrderBy] :: OrderBy -> NullsOrder
data Order
AscOrder :: Order
DescOrder :: Order
data NullsOrder
NullsFirst :: NullsOrder
NullsLast :: NullsOrder
NullsAnyOrder :: NullsOrder
data FieldOrigin
NoOrigin :: FieldOrigin
AggregateOrigin :: [Aliased Aggregate] -> FieldOrigin
aggregateProjectionsFieldOrigin :: Projection -> FieldOrigin
data Projection
ExpressionProjection :: Aliased Expression -> Projection
FieldNameProjection :: Aliased FieldName -> Projection
AggregateProjections :: Aliased (NonEmpty (Aliased Aggregate)) -> Projection
AggregateProjection :: Aliased Aggregate -> Projection
StarProjection :: Projection
ArrayAggProjection :: Aliased ArrayAgg -> Projection
EntityProjection :: Aliased [(FieldName, FieldOrigin)] -> Projection
ArrayEntityProjection :: EntityAlias -> Aliased [FieldName] -> Projection
WindowProjection :: Aliased WindowFunction -> Projection
data WindowFunction

-- | ROW_NUMBER() OVER(PARTITION BY field)
RowNumberOverPartitionBy :: NonEmpty FieldName -> Maybe (NonEmpty OrderBy) -> WindowFunction
data JoinType
LeftOuter :: JoinType
Inner :: JoinType
data Join
Join :: JoinSource -> EntityAlias -> [(FieldName, FieldName)] -> JoinProvenance -> Text -> Maybe Text -> EntityAlias -> JoinType -> Join
[$sel:joinSource:Join] :: Join -> JoinSource
[$sel:joinAlias:Join] :: Join -> EntityAlias
[$sel:joinOn:Join] :: Join -> [(FieldName, FieldName)]
[$sel:joinProvenance:Join] :: Join -> JoinProvenance
[$sel:joinFieldName:Join] :: Join -> Text
[$sel:joinExtractPath:Join] :: Join -> Maybe Text
[$sel:joinRightTable:Join] :: Join -> EntityAlias
[$sel:joinType:Join] :: Join -> JoinType
data JoinProvenance
OrderByJoinProvenance :: JoinProvenance
ObjectJoinProvenance :: [Text] -> JoinProvenance
ArrayAggregateJoinProvenance :: [(Text, FieldOrigin)] -> JoinProvenance
ArrayJoinProvenance :: [Text] -> JoinProvenance
data JoinSource
JoinSelect :: Select -> JoinSource
newtype Where
Where :: [Expression] -> Where
data Cardinality
Many :: Cardinality
One :: Cardinality
data AsStruct
NoAsStruct :: AsStruct
AsStruct :: AsStruct

-- | A Common Table Expression clause.
newtype With
With :: NonEmpty (Aliased (InterpolatedQuery Expression)) -> With
data Top
NoTop :: Top
Top :: Int64 -> Top
data Expression
ValueExpression :: TypedValue -> Expression
InExpression :: Expression -> TypedValue -> Expression
AndExpression :: [Expression] -> Expression
OrExpression :: [Expression] -> Expression
NotExpression :: Expression -> Expression
ExistsExpression :: Select -> Expression
SelectExpression :: Select -> Expression
IsNullExpression :: Expression -> Expression
IsNotNullExpression :: Expression -> Expression
ColumnExpression :: FieldName -> Expression
EqualExpression :: Expression -> Expression -> Expression
NotEqualExpression :: Expression -> Expression -> Expression

-- | This one acts like a "cast to JSON" and makes SQL Server behave like
--   it knows your field is JSON and not double-encode it.
JsonQueryExpression :: Expression -> Expression
ToStringExpression :: Expression -> Expression

-- | This is for getting actual atomic values out of a JSON string.
JsonValueExpression :: Expression -> JsonPath -> Expression
OpExpression :: Op -> Expression -> Expression -> Expression
ListExpression :: [Expression] -> Expression
CastExpression :: Expression -> ScalarType -> Expression
FunctionExpression :: FunctionName -> [Expression] -> Expression
ConditionalProjection :: Expression -> FieldName -> Expression

-- | A function input argument expression with argument name
--   <tt>argument_name</tt> =&gt; <tt>argument_value</tt>
FunctionNamedArgument :: Text -> Expression -> Expression
data JsonPath
RootPath :: JsonPath
FieldPath :: JsonPath -> Text -> JsonPath
IndexPath :: JsonPath -> Integer -> JsonPath
data Aggregate
CountAggregate :: Countable Expression -> Aggregate
OpAggregates :: Text -> NonEmpty (Text, Expression) -> Aggregate
OpAggregate :: Text -> Expression -> Aggregate
TextAggregate :: Text -> Aggregate
newtype CountType field
CountType :: Countable (ColumnName, AnnRedactionExp 'BigQuery field) -> CountType field
[$sel:getCountType:CountType] :: CountType field -> Countable (ColumnName, AnnRedactionExp 'BigQuery field)
data Countable fieldname
StarCountable :: Countable fieldname
NonNullFieldCountable :: NonEmpty fieldname -> Countable fieldname
DistinctCountable :: NonEmpty fieldname -> Countable fieldname
data From
FromQualifiedTable :: Aliased TableName -> From
FromSelect :: Aliased Select -> From
FromSelectJson :: Aliased SelectJson -> From
FromFunction :: Aliased SelectFromFunction -> From
FromNativeQuery :: Aliased NativeQueryName -> From
data SelectJson
SelectJson :: Expression -> [(ColumnName, ScalarType)] -> SelectJson
[$sel:selectJsonBody:SelectJson] :: SelectJson -> Expression
[$sel:selectJsonFields:SelectJson] :: SelectJson -> [(ColumnName, ScalarType)]
data SelectFromFunction
SelectFromFunction :: FunctionName -> [Expression] -> SelectFromFunction
[$sel:sffFunctionName:SelectFromFunction] :: SelectFromFunction -> FunctionName
[$sel:sffArguments:SelectFromFunction] :: SelectFromFunction -> [Expression]
data Aliased a
Aliased :: a -> Text -> Aliased a
[$sel:aliasedThing:Aliased] :: Aliased a -> a
[$sel:aliasedAlias:Aliased] :: Aliased a -> Text
data TableName
TableName :: Text -> Text -> TableName
[$sel:tableName:TableName] :: TableName -> Text
[$sel:tableNameSchema:TableName] :: TableName -> Text
data FieldName
FieldName :: Text -> Text -> FieldName
[$sel:fieldName:FieldName] :: FieldName -> Text
[$sel:fieldNameEntity:FieldName] :: FieldName -> Text
newtype ColumnName
ColumnName :: Text -> ColumnName
newtype EntityAlias
EntityAlias :: Text -> EntityAlias
[$sel:entityAliasText:EntityAlias] :: EntityAlias -> Text
columnToFieldName :: EntityAlias -> ColumnName -> FieldName
data Op
LessOp :: Op
LessOrEqualOp :: Op
MoreOp :: Op
MoreOrEqualOp :: Op
InOp :: Op
NotInOp :: Op
LikeOp :: Op
NotLikeOp :: Op

-- | Source for this represenation type:
--   
--   
--   <a>https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#google.protobuf.Value</a>
--   
--   BigQuery results come in via the REST API as one of these simply
--   types.
--   
--   TODO: This omits StructValue -- do we need it?
data Value
NullValue :: Value

-- | 64-bit
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#integer_type</a>
IntegerValue :: Int64 -> Value

-- | Fixed precision
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#decimal_types</a>
DecimalValue :: Decimal -> Value

-- | Fixed precision
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#decimal_types</a>
BigDecimalValue :: BigDecimal -> Value

-- | Floating point
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#floating_point_types</a>
FloatValue :: Float64 -> Value
GeographyValue :: Geography -> Value
StringValue :: Text -> Value
BytesValue :: Base64 -> Value
BoolValue :: Bool -> Value
ArrayValue :: Vector Value -> Value
TimestampValue :: Timestamp -> Value
DateValue :: Date -> Value
TimeValue :: Time -> Value
JsonValue :: Value -> Value
DatetimeValue :: Datetime -> Value

-- | BigQuery's conception of a timestamp.
newtype Timestamp
Timestamp :: Text -> Timestamp

-- | BigQuery's conception of a date.
newtype Date
Date :: Text -> Date

-- | BigQuery's conception of a time.
newtype Time
Time :: Text -> Time

-- | BigQuery's conception of a datetime.
newtype Datetime
Datetime :: Text -> Datetime

-- | BigQuery's conception of an INTEGER/INT64 (they are the same).
newtype Int64
Int64 :: Text -> Int64
data TypedValue
TypedValue :: ScalarType -> Value -> TypedValue
[$sel:tvType:TypedValue] :: TypedValue -> ScalarType
[$sel:tvValue:TypedValue] :: TypedValue -> Value
intToInt64 :: Int64 -> Int64
int64Expr :: Int64 -> Expression

-- | BigQuery's conception of a fixed precision decimal.
newtype Decimal
Decimal :: Text -> Decimal

-- | Convert <a>Scientific</a> to <a>Text</a>
scientificToText :: Scientific -> Text

-- | BigQuery's conception of a "big" fixed precision decimal.
newtype BigDecimal
BigDecimal :: Text -> BigDecimal
doubleToBigDecimal :: Double -> BigDecimal

-- | BigQuery's conception of a fixed precision decimal.
data Float64
doubleToFloat64 :: Double -> Float64

-- | A base-64 encoded binary string.
data Base64
newtype Geography
Geography :: Text -> Geography
data ScalarType
StringScalarType :: ScalarType
BytesScalarType :: ScalarType
IntegerScalarType :: ScalarType
FloatScalarType :: ScalarType
BoolScalarType :: ScalarType
TimestampScalarType :: ScalarType
DateScalarType :: ScalarType
TimeScalarType :: ScalarType
DatetimeScalarType :: ScalarType
GeographyScalarType :: ScalarType
DecimalScalarType :: ScalarType
BigDecimalScalarType :: ScalarType
JsonScalarType :: ScalarType
StructScalarType :: ScalarType
data BooleanOperators a
ASTContains :: a -> BooleanOperators a
ASTEquals :: a -> BooleanOperators a
ASTTouches :: a -> BooleanOperators a
ASTWithin :: a -> BooleanOperators a
ASTIntersects :: a -> BooleanOperators a
ASTDWithin :: DWithinGeogOp a -> BooleanOperators a
data FunctionName
FunctionName :: Text -> Maybe Text -> FunctionName
[$sel:functionName:FunctionName] :: FunctionName -> Text

-- | System functions like "unnest" don't have schema/dataset
[$sel:functionNameSchema:FunctionName] :: FunctionName -> Maybe Text

-- | The metadata required to define a computed field for a BigQuery table
data ComputedFieldDefinition
ComputedFieldDefinition :: FunctionName -> Maybe TableName -> HashMap FunctionArgName ColumnName -> ComputedFieldDefinition

-- | Name of the user defined routine
[$sel:_bqcfdFunction:ComputedFieldDefinition] :: ComputedFieldDefinition -> FunctionName

-- | Name of the table which the function returns. If not provided the
--   return table schema is inferred from the routine API metadata.
[$sel:_bqcfdReturnTable:ComputedFieldDefinition] :: ComputedFieldDefinition -> Maybe TableName

-- | A mapping context to determine argument value from table column
[$sel:_bqcfdArgumentMapping:ComputedFieldDefinition] :: ComputedFieldDefinition -> HashMap FunctionArgName ColumnName

-- | A argument expression for SQL functions
data ArgumentExp v

-- | Value coming from user's input through GraphQL query
AEInput :: v -> ArgumentExp v

-- | For computed fields, value of column from the table
AETableColumn :: ColumnName -> ArgumentExp v
type ComputedFieldImplicitArguments = HashMap FunctionArgName ColumnName

-- | Returning type of the function underlying a computed field
data ComputedFieldReturn

-- | Returns existing table, needs to be present in the metadata
ReturnExistingTable :: TableName -> ComputedFieldReturn

-- | An arbitrary table schema specified by column name and type pairs
ReturnTableSchema :: [(ColumnName, Name, ScalarType)] -> ComputedFieldReturn

-- | Function input argument specification
data FunctionArgument
FunctionArgument :: FunctionArgName -> ScalarType -> FunctionArgument

-- | Argument name of a table valued function is required Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language#create_table_function_statement</a>
[$sel:_faName:FunctionArgument] :: FunctionArgument -> FunctionArgName

-- | The data type of the argument
[$sel:_faType:FunctionArgument] :: FunctionArgument -> ScalarType
parseScalarValue :: ScalarType -> Value -> Either QErr Value
isComparableType :: ScalarType -> Bool
isNumType :: ScalarType -> Bool
getGQLTableName :: TableName -> Either QErr Name
projectionAlias :: Projection -> Maybe Text
data Job
Job :: Text -> Text -> Text -> Job
[$sel:state:Job] :: Job -> Text
[$sel:jobId:Job] :: Job -> Text
[$sel:location:Job] :: Job -> Text
data ExecutionStatistics
ExecutionStatistics :: Job -> ExecutionStatistics
[$sel:_esJob:ExecutionStatistics] :: ExecutionStatistics -> Job
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Order
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Order
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Order
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Order
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Order
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Order
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Order
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Order
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Order
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Order
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.NullsOrder
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.NullsOrder
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.NullsOrder
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.NullsOrder
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.NullsOrder
instance Data.Data.Data Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.NullsOrder
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.NullsOrder
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.JoinType
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JoinType
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JoinType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.JoinType
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JoinType
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JoinType
instance Data.Data.Data Hasura.Backends.BigQuery.Types.JoinType
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.JoinType
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.JoinType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JoinType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Cardinality
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Cardinality
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Cardinality
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Cardinality
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Cardinality
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Cardinality
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Cardinality
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.AsStruct
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.AsStruct
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.AsStruct
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.AsStruct
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.AsStruct
instance Data.Data.Data Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.AsStruct
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.AsStruct
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Top
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Top
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Top
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Top
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Top
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Top
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Top
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Top
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Top
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Top
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.JsonPath
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JsonPath
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JsonPath
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.JsonPath
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JsonPath
instance Data.Data.Data Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JsonPath
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JsonPath
instance Data.Traversable.Traversable Hasura.Backends.BigQuery.Types.Countable
instance GHC.Base.Functor Hasura.Backends.BigQuery.Types.Countable
instance Data.Foldable.Foldable Hasura.Backends.BigQuery.Types.Countable
instance Language.Haskell.TH.Syntax.Lift fieldname => Language.Haskell.TH.Syntax.Lift (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance Data.Data.Data fieldname => Data.Data.Data (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Generics.Generic (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Show.Show fieldname => GHC.Show.Show (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Classes.Ord fieldname => GHC.Classes.Ord (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance GHC.Classes.Eq fieldname => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.Countable fieldname)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance Data.Data.Data Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JsonFieldSpec
instance GHC.Base.Functor Hasura.Backends.BigQuery.Types.Aliased
instance Language.Haskell.TH.Syntax.Lift a => Language.Haskell.TH.Syntax.Lift (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Data.Data a => Data.Data.Data (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Generics.Generic (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Hasura.Backends.BigQuery.Types.Aliased a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.TableName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.TableName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.TableName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.TableName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.TableName
instance Data.Data.Data Hasura.Backends.BigQuery.Types.TableName
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.TableName
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.TableName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.FieldName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FieldName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.FieldName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.FieldName
instance Data.Data.Data Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.FieldName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FieldName
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.ColumnName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.ColumnName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Data.Data Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ColumnName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ColumnName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Comment
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Comment
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Comment
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Comment
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Comment
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Comment
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Comment
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Comment
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Comment
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Comment
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.EntityAlias
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.EntityAlias
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.EntityAlias
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.EntityAlias
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.EntityAlias
instance Data.Data.Data Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.EntityAlias
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.EntityAlias
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Op
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Op
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Op
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Op
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Op
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Op
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Op
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Op
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Op
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Op
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Timestamp
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Timestamp
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Timestamp
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Timestamp
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Timestamp
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Timestamp
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Timestamp
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Date
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Date
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Date
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Date
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Date
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Date
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Date
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Date
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Date
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Date
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Time
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Time
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Time
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Time
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Time
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Time
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Time
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Time
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Time
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Time
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Datetime
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Datetime
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Datetime
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Datetime
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Datetime
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Datetime
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Datetime
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Int64
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Int64
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Int64
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Int64
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Int64
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Int64
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Int64
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Int64
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Decimal
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Decimal
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Decimal
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Decimal
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Decimal
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.BigDecimal
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.BigDecimal
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.BigDecimal
instance Data.Data.Data Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.BigDecimal
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.BigDecimal
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Float64
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Float64
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Float64
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Float64
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Float64
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Float64
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Float64
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Float64
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Base64
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Base64
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Base64
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Base64
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Base64
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Base64
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Geography
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Geography
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Geography
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Geography
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Geography
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Geography
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Geography
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Geography
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Geography
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Geography
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Value
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Value
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Value
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Value
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Value
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Value
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Value
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Value
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Value
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Value
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.ScalarType
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ScalarType
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Data.Data Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Enum.Enum Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Enum.Bounded Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ScalarType
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.ScalarType
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.TypedValue
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.TypedValue
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.TypedValue
instance Data.Data.Data Hasura.Backends.BigQuery.Types.TypedValue
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.TypedValue
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.TypedValue
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.TypedValue
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.TypedValue
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedColumn
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedColumn
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedColumn
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedTableName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedTableName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedTableName
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedOn
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedOn
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedOn
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedUsing
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedUsing
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedUsing
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedArrayRelationship
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedArrayRelationship
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedArrayRelationship
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedObjectRelationship
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedObjectRelationship
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedObjectRelationship
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedTableMetadata
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedTableMetadata
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedTableMetadata
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.UnifiedMetadata
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.UnifiedMetadata
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.UnifiedMetadata
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Data.Traversable.Traversable Hasura.Backends.BigQuery.Types.BooleanOperators
instance GHC.Base.Functor Hasura.Backends.BigQuery.Types.BooleanOperators
instance Data.Foldable.Foldable Hasura.Backends.BigQuery.Types.BooleanOperators
instance GHC.Generics.Generic (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Types.FunctionName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.FunctionName
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Data.Data Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.FunctionName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FunctionName
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ArrayAgg
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ArrayAgg
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.ArrayAgg
instance Data.Data.Data Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ArrayAgg
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ArrayAgg
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.OrderBy
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.OrderBy
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.OrderBy
instance Data.Data.Data Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.OrderBy
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.OrderBy
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.WindowFunction
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.WindowFunction
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.WindowFunction
instance Data.Data.Data Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.WindowFunction
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.WindowFunction
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Projection
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Projection
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Projection
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Projection
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Projection
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Projection
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Projection
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Projection
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Aggregate
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Aggregate
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Aggregate
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Aggregate
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Aggregate
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FieldOrigin
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FieldOrigin
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.FieldOrigin
instance Data.Data.Data Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.FieldOrigin
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FieldOrigin
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JoinProvenance
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JoinProvenance
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JoinProvenance
instance Data.Data.Data Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JoinProvenance
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JoinProvenance
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.JoinSource
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.JoinSource
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.JoinSource
instance Data.Data.Data Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.JoinSource
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.JoinSource
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Join
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Join
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Join
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Join
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Join
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Join
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Join
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Join
instance GHC.Base.Semigroup Hasura.Backends.BigQuery.Types.Where
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Where
instance GHC.Base.Monoid Hasura.Backends.BigQuery.Types.Where
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Where
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Where
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Where
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Where
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Where
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Where
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Where
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.With
instance GHC.Base.Semigroup Hasura.Backends.BigQuery.Types.With
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.With
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.With
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.With
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.With
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.With
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.With
instance Data.Data.Data Hasura.Backends.BigQuery.Types.With
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.SelectJson
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.SelectJson
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.SelectJson
instance Data.Data.Data Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.SelectJson
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.SelectJson
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Data.Data.Data Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.SelectFromFunction
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.SelectFromFunction
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.From
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.From
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.From
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.From
instance Data.Data.Data Hasura.Backends.BigQuery.Types.From
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.From
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.From
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.From
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Select
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Select
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Select
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Select
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Select
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Select
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Select
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Select
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Expression
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Expression
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Expression
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Expression
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Expression
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Expression
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Expression
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Expression
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.OpenJson
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.OpenJson
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.OpenJson
instance Data.Data.Data Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.OpenJson
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.OpenJson
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Reselect
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Reselect
instance Language.Haskell.TH.Syntax.Lift Hasura.Backends.BigQuery.Types.Reselect
instance Data.Data.Data Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.Reselect
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.Reselect
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Data.Data.Data Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance GHC.Generics.Generic (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance Data.Traversable.Traversable Hasura.Backends.BigQuery.Types.ArgumentExp
instance Data.Foldable.Foldable Hasura.Backends.BigQuery.Types.ArgumentExp
instance GHC.Base.Functor Hasura.Backends.BigQuery.Types.ArgumentExp
instance GHC.Show.Show v => GHC.Show.Show (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance GHC.Classes.Eq v => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.FunctionArgument
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.FunctionArgument
instance GHC.Show.Show Hasura.Backends.BigQuery.Types.Job
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Types.ExecutionStatistics
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.BigQuery => Data.Foldable.Foldable Hasura.Backends.BigQuery.Types.CountType
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.BigQuery => GHC.Base.Functor Hasura.Backends.BigQuery.Types.CountType
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.BigQuery => Data.Traversable.Traversable Hasura.Backends.BigQuery.Types.CountType
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.BigQuery, GHC.Classes.Eq field, GHC.Classes.Eq (Hasura.RQL.Types.Backend.AggregationPredicates 'Hasura.RQL.Types.BackendType.BigQuery field), GHC.Classes.Eq (Hasura.RQL.Types.Backend.BooleanOperators 'Hasura.RQL.Types.BackendType.BigQuery field), GHC.Classes.Eq (Hasura.RQL.Types.Backend.FunctionArgumentExp 'Hasura.RQL.Types.BackendType.BigQuery field)) => GHC.Classes.Eq (Hasura.Backends.BigQuery.Types.CountType field)
instance (Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.BigQuery, GHC.Show.Show field, GHC.Show.Show (Hasura.RQL.Types.Backend.AggregationPredicates 'Hasura.RQL.Types.BackendType.BigQuery field), GHC.Show.Show (Hasura.RQL.Types.Backend.BooleanOperators 'Hasura.RQL.Types.BackendType.BigQuery field), GHC.Show.Show (Hasura.RQL.Types.Backend.FunctionArgumentExp 'Hasura.RQL.Types.BackendType.BigQuery field)) => GHC.Show.Show (Hasura.Backends.BigQuery.Types.CountType field)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.BigQuery.Types.Countable a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.Countable a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.BigQuery.Types.Countable a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Types.Countable a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.BigQuery.Types.Aliased a)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Types.Aliased a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ExecutionStatistics
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Job
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Job
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.FunctionArgument
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ComputedFieldReturn
instance Data.Hashable.Class.Hashable v => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.ArgumentExp v)
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.ComputedFieldDefinition
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.FunctionName
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.FunctionName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.FunctionName
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Data.Hashable.Class.Hashable a => Data.Hashable.Class.Hashable (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Extended.ToJSONKeyValue (Hasura.Backends.BigQuery.Types.BooleanOperators a)
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.ScalarType
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.ScalarType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Base64
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Base64
instance Control.DeepSeq.NFData Hasura.Backends.BigQuery.Types.Base64
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Types.Base64
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Float64
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Float64
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.BigDecimal
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.BigDecimal
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Decimal
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Decimal
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.Int64
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Int64
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Types.ColumnName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.ColumnName
instance Autodocodec.Class.HasCodec Hasura.Backends.BigQuery.Types.TableName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Types.TableName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.TableName
instance Data.Text.Extended.ToTxt Hasura.Backends.BigQuery.Types.TableName
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.Backends.BigQuery.Types.TableName
instance GHC.Base.Monoid Hasura.Backends.BigQuery.Types.Top
instance GHC.Base.Semigroup Hasura.Backends.BigQuery.Types.Top


-- | Convert the simple BigQuery AST to an SQL query, ready to be passed to
--   the odbc package's query/exec functions.
module Hasura.Backends.BigQuery.ToQuery
data Printer
SeqPrinter :: [Printer] -> Printer
SepByPrinter :: Printer -> [Printer] -> Printer
NewlinePrinter :: Printer
UnsafeTextPrinter :: Text -> Printer
IndentPrinter :: Int -> Printer -> Printer
ValuePrinter :: TypedValue -> Printer
fromExpression :: Expression -> Printer
fromSelect :: Select -> Printer
fromReselect :: Reselect -> Printer
toBuilderFlat :: Printer -> Builder
toBuilderPretty :: Printer -> Builder
toTextPretty :: Printer -> Text
toTextFlat :: Printer -> Text

-- | Produces a query with holes, and a mapping for each
renderBuilderFlat :: Printer -> (Builder, InsOrdHashMap Int TypedValue)

-- | Produces a query with holes, and a mapping for each
renderBuilderPretty :: Printer -> (Builder, InsOrdHashMap Int TypedValue)
paramName :: Int -> Builder
instance GHC.Classes.Eq Hasura.Backends.BigQuery.ToQuery.Printer
instance GHC.Show.Show Hasura.Backends.BigQuery.ToQuery.Printer
instance Data.String.IsString Hasura.Backends.BigQuery.ToQuery.Printer
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Types.Expression


-- | This module defines the scalars we use specific to the BigQuery
--   schema.
--   
--   An idiosyncracy of BigQuery is that numbers serialized via JSON uses
--   string literals instead of number literals, because BigQuery handles
--   wider-bit numbers than JSON/JavaScript does.
--   
--   Therefore, the BigQuery Backend uses bespoke parsers for numeric
--   scalar input, which accept string literals as well as number literals,
--   such that we preserve symmetry with with output formats.
module Hasura.Backends.BigQuery.Parser.Scalars
bqInt64 :: forall origin m. MonadParse m => Parser origin 'Both m Int64
bqFloat64 :: forall origin m. MonadParse m => Parser origin 'Both m Float64
bqBigDecimal :: MonadParse m => Parser origin 'Both m BigDecimal
bqDecimal :: MonadParse m => Parser origin 'Both m Decimal

module Hasura.Backends.BigQuery.Meta
data MetadataError
RestProblem :: RestProblem -> MetadataError
data RestTableReference
RestTableReference :: Text -> Text -> Text -> RestTableReference
[$sel:datasetId:RestTableReference] :: RestTableReference -> Text
[$sel:projectId:RestTableReference] :: RestTableReference -> Text
[$sel:tableId:RestTableReference] :: RestTableReference -> Text
data RestTable
RestTable :: RestTableReference -> RestTableSchema -> RestTable
[$sel:tableReference:RestTable] :: RestTable -> RestTableReference
[$sel:schema:RestTable] :: RestTable -> RestTableSchema
data RestTableSchema
RestTableSchema :: [RestFieldSchema] -> RestTableSchema
[$sel:fields:RestTableSchema] :: RestTableSchema -> [RestFieldSchema]
data RestFieldSchema
RestFieldSchema :: Text -> RestType -> Mode -> RestFieldSchema
[$sel:name:RestFieldSchema] :: RestFieldSchema -> Text

-- | The field data type. Possible values include STRING, BYTES, INTEGER,
--   INT64 (same as INTEGER), FLOAT, FLOAT64 (same as FLOAT), BOOLEAN, BOOL
--   (same as BOOLEAN), TIMESTAMP, DATE, TIME, DATETIME, GEOGRAPHY,
--   NUMERIC, RECORD (where RECORD indicates that the field contains a
--   nested schema) or STRUCT (same as RECORD).
[$sel:type':RestFieldSchema] :: RestFieldSchema -> RestType
[$sel:mode:RestFieldSchema] :: RestFieldSchema -> Mode
data Mode
Nullable :: Mode
Required :: Mode
Repeated :: Mode
data RestType
STRING :: RestType
BYTES :: RestType
INTEGER :: RestType
FLOAT :: RestType
BOOL :: RestType
TIMESTAMP :: RestType
DATE :: RestType
TIME :: RestType
DATETIME :: RestType
GEOGRAPHY :: RestType
DECIMAL :: RestType
BIGDECIMAL :: RestType
JSON :: RestType
STRUCT :: RestType

-- | Get all tables from all specified data sets.
getTables :: MonadIO m => BigQuerySourceConfig -> m (Either RestProblem [RestTable])

-- | The fine-grained type of the routine Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#RoutineType</a>
data RestRoutineType
ROUTINE_TYPE_UNSPECIFIED :: RestRoutineType
SCALAR_FUNCTION :: RestRoutineType
PROCEDURE :: RestRoutineType
TABLE_VALUED_FUNCTION :: RestRoutineType

-- | Input argument of a function/routine. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#Argument</a>
data RestArgument
RestArgument :: Maybe Text -> Maybe RestType -> RestArgument

-- | The name of this argument. Can be absent for function return argument.
[$sel:_raName:RestArgument] :: RestArgument -> Maybe Text
[$sel:_raDataType:RestArgument] :: RestArgument -> Maybe RestType

-- | A field or a column. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/StandardSqlField</a>
data RestStandardSqlField
RestStandardSqlField :: Maybe Text -> Maybe RestType -> RestStandardSqlField

-- | The field name is optional and is absent for fields with STRUCT type.
[$sel:_rssfName:RestStandardSqlField] :: RestStandardSqlField -> Maybe Text
[$sel:_rssType:RestStandardSqlField] :: RestStandardSqlField -> Maybe RestType

-- | A table type, which has only list of columns with names and types.
--   Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#StandardSqlTableType</a>
data RestStandardSqlTableType
RestStandardSqlTableType :: [RestStandardSqlField] -> RestStandardSqlTableType
[$sel:_rrttColumns:RestStandardSqlTableType] :: RestStandardSqlTableType -> [RestStandardSqlField]

-- | Id path of a routine. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#RoutineReference</a>
data RestRoutineReference
RestRoutineReference :: Text -> Text -> Text -> RestRoutineReference
[$sel:datasetId:RestRoutineReference] :: RestRoutineReference -> Text
[$sel:projectId:RestRoutineReference] :: RestRoutineReference -> Text
[$sel:routineId:RestRoutineReference] :: RestRoutineReference -> Text
routineReferenceToFunctionName :: RestRoutineReference -> FunctionName

-- | A user-defined function. Ref:
--   <a>https://cloud.google.com/bigquery/docs/reference/rest/v2/routines#Routine</a>
data RestRoutine
RestRoutine :: RestRoutineReference -> RestRoutineType -> Maybe [RestArgument] -> Maybe RestStandardSqlTableType -> RestRoutine

-- | Reference describing the ID of this routine
[$sel:routineReference:RestRoutine] :: RestRoutine -> RestRoutineReference

-- | The type of routine
[$sel:routineType:RestRoutine] :: RestRoutine -> RestRoutineType

-- | List of arguments defined
[$sel:arguments:RestRoutine] :: RestRoutine -> Maybe [RestArgument]

-- | Routines defined with 'RETURNS TABLE' clause has this information
[$sel:returnTableType:RestRoutine] :: RestRoutine -> Maybe RestStandardSqlTableType

-- | Get all routines from all specified data sets.
getRoutines :: MonadIO m => BigQuerySourceConfig -> m (Either RestProblem [RestRoutine])
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestProblem
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.MetadataError
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTableReference
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestTableReference
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTableBrief
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestTableBrief
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestTableList
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.Mode
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestType
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestFieldSchema
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestFieldSchema
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTableSchema
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestTableSchema
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestTable
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestTable
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestRoutineType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestRoutineType
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutineType
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestArgument
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestArgument
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestArgument
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Meta.RestRoutine
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutine
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Meta.RestRoutine
instance GHC.Show.Show Hasura.Backends.BigQuery.Meta.RestRoutineList
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutineList
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutine
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestRoutine
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestRoutineReference
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestStandardSqlTableType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestStandardSqlField
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestArgument
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestArgument
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestRoutineType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestRoutineType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableSchema
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestFieldSchema
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Meta.RestType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.Mode
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableList
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableBrief
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Meta.RestTableReference

module Hasura.Backends.BigQuery.Instances.Types
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.BigQuery
instance Hasura.RQL.Types.SourceConfiguration.HasSourceConfiguration 'Hasura.RQL.Types.BackendType.BigQuery


-- | <h1>Reasonably efficient PostgreSQL live queries</h1>
--   
--   The module implements <i>query multiplexing</i>, which is our
--   implementation strategy for live queries (i.e. GraphQL subscriptions)
--   made against Postgres. Fundamentally, our implementation is built
--   around polling, which is never ideal, but itâ€™s a lot easier to
--   implement than trying to do something event-based. To minimize the
--   resource cost of polling, we use <i>multiplexing</i>, which is
--   essentially a two-tier batching strategy.
--   
--   <h2>The high-level idea</h2>
--   
--   The objective is to minimize the number of concurrent polling workers
--   to reduce database load as much as possible. A very naÃ¯ve strategy
--   would be to group identical queries together so we only have one
--   poller per <i>unique</i> active subscription. Thatâ€™s a good start, but
--   of course, in practice, most queries differ slightly. However, it
--   happens that they very frequently /only differ in their variables/
--   (that is, GraphQL query variables and session variables), and in those
--   cases, we try to generated parameterized SQL. This means that the same
--   prepared SQL query can be reused, just with a different set of
--   variables.
--   
--   To give a concrete example, consider the following query:
--   
--   <pre>
--   subscription vote_count($post_id: Int!) {
--     vote_count(where: {post_id: {_eq: $post_id}}) {
--       votes
--     }
--   }
--   </pre>
--   
--   No matter what the client provides for <tt>$post_id</tt>, we will
--   always generate the same SQL:
--   
--   <pre>
--   SELECT votes FROM vote_count WHERE post_id = $1
--   </pre>
--   
--   If multiple clients subscribe to <tt>vote_count</tt>, we can certainly
--   reuse the same prepared query. For example, imagine we had 10
--   concurrent subscribers, each listening on a distinct
--   <tt>$post_id</tt>:
--   
--   <pre>
--   let postIds = [3, 11, 32, 56, 13, 97, 24, 43, 109, 48]
--   </pre>
--   
--   We could iterate over <tt>postIds</tt> in Haskell, executing the same
--   prepared query 10 times:
--   
--   <pre>
--   for postIds $ \postId -&gt;
--     PG.withQE defaultTxErrorHandler preparedQuery (Identity postId) True
--   </pre>
--   
--   Sadly, that on its own isnâ€™t good enough. The overhead of running each
--   query is large enough that Postgres becomes overwhelmed if we have to
--   serve lots of concurrent subscribers. Therefore, what we want to be
--   able to do is somehow make one query instead of ten.
--   
--   <h3>Multiplexing</h3>
--   
--   This is where multiplexing comes in. By taking advantage of Postgres
--   <a>lateral joins</a>, we can do the iteration in Postgres rather than
--   in Haskell, allowing us to pay the query overhead just once for all
--   ten subscribers. Essentially, lateral joins add <a>map</a>-like
--   functionality to SQL, so we can run our query once per
--   <tt>$post_id</tt>:
--   
--   <pre>
--   SELECT results.votes
--   FROM unnest($1::integer[]) query_variables (post_id)
--   LEFT JOIN LATERAL (
--     SELECT coalesce(json_agg(votes), '[]')
--     FROM vote_count WHERE vote_count.post_id = query_variables.post_id
--   ) results ON true
--   </pre>
--   
--   If we generalize this approach just a little bit more, we can apply
--   this transformation to arbitrary queries parameterized over arbitrary
--   session and query variables!
--   
--   <h2>Implementation overview</h2>
--   
--   To support query multiplexing, we maintain a tree of the following
--   types, where <tt>&gt;</tt> should be read as â€œcontainsâ€:
--   
--   <pre>
--   <tt>SubscriptionsState</tt> &gt; <tt>Poller</tt> &gt; <tt>Cohort</tt> &gt; <tt>Subscriber</tt>
--   </pre>
--   
--   Hereâ€™s a brief summary of each typeâ€™s role:
--   
--   <ul>
--   <li>A <tt>Subscriber</tt> is an actual client with an open websocket
--   connection.</li>
--   <li>A <tt>Cohort</tt> is a set of <tt>Subscriber</tt>s that are all
--   subscribed to the same query /with the exact same variables/. (By
--   batching these together, we can do better than multiplexing, since we
--   can just query the data once.)</li>
--   <li>A <tt>Poller</tt> is a worker thread for a single, multiplexed
--   query. It fetches data for a set of <tt>Cohort</tt>s that all use the
--   same parameterized query, but have different sets of variables.</li>
--   <li>Finally, the <tt>SubscriptionsState</tt> is the top-level
--   container that holds all the active <tt>Poller</tt>s.</li>
--   </ul>
--   
--   Additional details are provided by the documentation for individual
--   bindings.
module Hasura.GraphQL.Execute.Subscription.Plan

-- | When running multiplexed queries, we have to be especially careful
--   about user input, since invalid values will cause the query to fail,
--   causing collateral damage for anyone else multiplexed into the same
--   query. Therefore, we pre-validate variables against Postgres by
--   executing a no-op query of the shape
--   
--   <pre>
--   SELECT 'v1'::t1, 'v2'::t2, ..., 'vn'::tn
--   </pre>
--   
--   so if any variable values are invalid, the error will be caught early.
newtype ValidatedVariables f
ValidatedVariables :: f TxtEncodedVal -> ValidatedVariables f
[_unValidatedVariables] :: ValidatedVariables f -> f TxtEncodedVal
unValidatedVariables :: forall f_afcy5 f_afcH3. Iso (ValidatedVariables f_afcy5) (ValidatedVariables f_afcH3) (f_afcy5 TxtEncodedVal) (f_afcH3 TxtEncodedVal)
type ValidatedQueryVariables = ValidatedVariables (HashMap Name)
type ValidatedSyntheticVariables = ValidatedVariables []
type ValidatedCursorVariables = ValidatedVariables (HashMap Name)
mkUnsafeValidateVariables :: f TxtEncodedVal -> ValidatedVariables f
data CohortId
newCohortId :: MonadIO m => m CohortId
dummyCohortId :: CohortId
data CohortVariables
cvSyntheticVariables :: Lens' CohortVariables ValidatedSyntheticVariables
cvSessionVariables :: Lens' CohortVariables SessionVariables
cvQueryVariables :: Lens' CohortVariables ValidatedQueryVariables
cvCursorVariables :: Lens' CohortVariables ValidatedCursorVariables
modifyCursorCohortVariables :: ValidatedCursorVariables -> CohortVariables -> CohortVariables

-- | Builds a cohort's variables by only using the session variables that
--   are required for the subscription
mkCohortVariables :: HashSet SessionVariable -> SessionVariables -> ValidatedQueryVariables -> ValidatedSyntheticVariables -> ValidatedCursorVariables -> CohortVariables
newtype CohortIdArray
CohortIdArray :: [CohortId] -> CohortIdArray
[unCohortIdArray] :: CohortIdArray -> [CohortId]
newtype CohortVariablesArray
CohortVariablesArray :: [CohortVariables] -> CohortVariablesArray
[unCohortVariablesArray] :: CohortVariablesArray -> [CohortVariables]
applyModifier :: Maybe (Endo Value) -> ByteString -> ByteString

-- | A self-contained, ready-to-execute subscription plan. Contains enough
--   information to find an existing poller that this can be added to
--   <i>or</i> to create a new poller if necessary.
data SubscriptionQueryPlan (b :: BackendType) q
SubscriptionQueryPlan :: ParameterizedSubscriptionQueryPlan b q -> SourceConfig b -> CohortId -> ResolvedConnectionTemplate b -> CohortVariables -> Maybe Name -> SubscriptionQueryPlan (b :: BackendType) q
[_sqpParameterizedPlan] :: SubscriptionQueryPlan (b :: BackendType) q -> ParameterizedSubscriptionQueryPlan b q
[_sqpSourceConfig] :: SubscriptionQueryPlan (b :: BackendType) q -> SourceConfig b
[_sqpCohortId] :: SubscriptionQueryPlan (b :: BackendType) q -> CohortId
[_sqpResolvedConnectionTemplate] :: SubscriptionQueryPlan (b :: BackendType) q -> ResolvedConnectionTemplate b
[_sqpVariables] :: SubscriptionQueryPlan (b :: BackendType) q -> CohortVariables

-- | We need to know if the source has a namespace so that we can wrap it
--   around the response from the DB
[_sqpNamespace] :: SubscriptionQueryPlan (b :: BackendType) q -> Maybe Name
data ParameterizedSubscriptionQueryPlan (b :: BackendType) q
ParameterizedSubscriptionQueryPlan :: !RoleName -> !q -> ParameterizedSubscriptionQueryPlan (b :: BackendType) q
[_plqpRole] :: ParameterizedSubscriptionQueryPlan (b :: BackendType) q -> !RoleName
[_plqpQuery] :: ParameterizedSubscriptionQueryPlan (b :: BackendType) q -> !q
data SubscriptionQueryPlanExplanation
SubscriptionQueryPlanExplanation :: !Text -> ![Text] -> !CohortVariables -> SubscriptionQueryPlanExplanation
[_sqpeSql] :: SubscriptionQueryPlanExplanation -> !Text
[_sqpePlan] :: SubscriptionQueryPlanExplanation -> ![Text]
[_sqpeVariables] :: SubscriptionQueryPlanExplanation -> !CohortVariables
newtype CursorVariableValues
CursorVariableValues :: HashMap Name TxtEncodedVal -> CursorVariableValues
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Plan.CursorVariableValues
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.SubscriptionQueryPlanExplanation
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.SubscriptionQueryPlanExplanation
instance Data.Aeson.Types.ToJSON.ToJSON q => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Execute.Subscription.Plan.ParameterizedSubscriptionQueryPlan b q)
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortIdArray
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortIdArray
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortVariablesArray
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortVariablesArray
instance GHC.Show.Show q => GHC.Show.Show (Hasura.GraphQL.Execute.Subscription.Plan.ParameterizedSubscriptionQueryPlan b q)
instance Database.PG.Query.Class.ToPrepArg Hasura.GraphQL.Execute.Subscription.Plan.CohortVariablesArray
instance Database.PG.Query.Class.ToPrepArg Hasura.GraphQL.Execute.Subscription.Plan.CohortIdArray
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance Database.PG.Query.Class.FromCol Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortId
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Plan.CohortVariables
instance GHC.Show.Show (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Show.Show (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance GHC.Classes.Eq (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Classes.Eq (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance Data.Hashable.Class.Hashable (f Hasura.SQL.Value.TxtEncodedVal) => Data.Hashable.Class.Hashable (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance Data.Aeson.Types.ToJSON.ToJSON (f Hasura.SQL.Value.TxtEncodedVal) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance GHC.Base.Semigroup (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Base.Semigroup (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)
instance GHC.Base.Monoid (f Hasura.SQL.Value.TxtEncodedVal) => GHC.Base.Monoid (Hasura.GraphQL.Execute.Subscription.Plan.ValidatedVariables f)

module Hasura.Backends.Postgres.Execute.ConnectionTemplate

-- | This connection tag represents primary database connection
data PrimaryTag
PrimaryTag :: PrimaryTag

-- | This connection tag represents default behaviour of database
--   connections.
--   
--   For example, if read replica is set, then it will redirect GQL queries
--   to read replicas and mutations to the primary connection
data DefaultTag
DefaultTag :: DefaultTag

-- | This connection tag represents read replica database connection
data ReadReplicasTag
ReadReplicasTag :: ReadReplicasTag

-- | Data type for single member in connection_set for connection template
--   context
data ConnectionSetMemberTemplateContext
ConnectionSetMemberTemplateContext :: ConnectionSetTemplateContextType -> PostgresConnectionSetMemberName -> ConnectionSetMemberTemplateContext
[_cseType] :: ConnectionSetMemberTemplateContext -> ConnectionSetTemplateContextType
[_cseName] :: ConnectionSetMemberTemplateContext -> PostgresConnectionSetMemberName
mkConnectionSetMemberTemplateContext :: PostgresConnectionSetMemberName -> ConnectionSetMemberTemplateContext

-- | Outcome of the connection template resolution
data PostgresResolvedConnectionTemplate
PCTODefault :: DefaultTag -> PostgresResolvedConnectionTemplate
PCTOPrimary :: PrimaryTag -> PostgresResolvedConnectionTemplate
PCTOReadReplicas :: ReadReplicasTag -> PostgresResolvedConnectionTemplate
PCTOConnectionSet :: PostgresConnectionSetMemberName -> PostgresResolvedConnectionTemplate

-- | Headers information for the connection template context
data RequestContextHeaders
RequestContextHeaders :: HashMap Text Text -> RequestContextHeaders

-- | Data type for connection_set for connection template context
data ConnectionSetTemplateContext
newtype QueryOperationType
QueryOperationType :: OperationType -> QueryOperationType

-- | Query information (operation name and operation type) for connection
--   template context
data QueryContext
QueryContext :: Maybe Name -> QueryOperationType -> QueryContext
[_qcOperationName] :: QueryContext -> Maybe Name
[_qcOperationType] :: QueryContext -> QueryOperationType

-- | Request information for connection template context
data RequestContext
RequestContext :: RequestContextHeaders -> SessionVariables -> Maybe QueryContext -> RequestContext
[_rcHeaders] :: RequestContext -> RequestContextHeaders
[_rcSession] :: RequestContext -> SessionVariables
[_rcQuery] :: RequestContext -> Maybe QueryContext

-- | The complete connection template context used for resolving connection
--   template
data PostgresConnectionTemplateContext
PostgresConnectionTemplateContext :: RequestContext -> PrimaryTag -> ReadReplicasTag -> DefaultTag -> ConnectionSetTemplateContext -> PostgresConnectionTemplateContext
[_pctcRequest] :: PostgresConnectionTemplateContext -> RequestContext
[_pctcPrimary] :: PostgresConnectionTemplateContext -> PrimaryTag
[_pctcReadReplicas] :: PostgresConnectionTemplateContext -> ReadReplicasTag
[_pctcDefault] :: PostgresConnectionTemplateContext -> DefaultTag
[_pctcConnectionSet] :: PostgresConnectionTemplateContext -> ConnectionSetTemplateContext

-- | Construct template context
makeConnectionTemplateContext :: RequestContext -> [PostgresConnectionSetMemberName] -> PostgresConnectionTemplateContext

-- | We should move this to Data.Aeson.Kriti.Functions
runKritiEval :: PostgresConnectionTemplateContext -> KritiTemplate -> Either EvalError Value
makeRequestContext :: Maybe QueryContext -> [Header] -> SessionVariables -> RequestContext
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContextHeaders
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContextHeaders
instance GHC.Base.Monoid Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContext
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContext
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContext
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryOperationType
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryContext
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryContext
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContext
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContext
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresConnectionTemplateContext
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresConnectionTemplateContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresConnectionTemplateContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresConnectionTemplateContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryOperationType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.QueryOperationType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContext
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContextHeaders
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.RequestContextHeaders
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PostgresResolvedConnectionTemplate
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetMemberTemplateContext
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ConnectionSetTemplateContextType
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.ReadReplicasTag
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.DefaultTag
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance Control.DeepSeq.NFData Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.ConnectionTemplate.PrimaryTag


-- | Postgres Execute Types
--   
--   Execution context and source configuration for Postgres databases.
--   Provides support for things such as read-only transactions and read
--   replicas.
module Hasura.Backends.Postgres.Execute.Types
data PGExecCtx
PGExecCtx :: (PGExecCtxInfo -> RunTx) -> IO () -> (ServerReplicas -> IO SourceResizePoolSummary) -> PGExecCtx

-- | Run a PG transaction using the information provided by PGExecCtxInfo
[_pecRunTx] :: PGExecCtx -> PGExecCtxInfo -> RunTx

-- | Destroy connection pools
[_pecDestroyConnections] :: PGExecCtx -> IO ()

-- | Resize pools based on number of server instances and return the
--   summary
[_pecResizePools] :: PGExecCtx -> ServerReplicas -> IO SourceResizePoolSummary

-- | Holds the information required to exceute a PG transaction
data PGExecCtxInfo
PGExecCtxInfo :: PGExecTxType -> PGExecFrom -> PGExecCtxInfo

-- | The tranasction mode for executing the transaction
[_peciTxType] :: PGExecCtxInfo -> PGExecTxType

-- | The level from where the PG transaction is being executed from
[_peciFrom] :: PGExecCtxInfo -> PGExecFrom

-- | The tranasction mode (isolation level, transaction access) for
--   executing the transaction
data PGExecTxType

-- | a transaction without an explicit tranasction block
NoTxRead :: PGExecTxType

-- | a transaction block with custom transaction access and isolation
--   level. Choose defaultIsolationLevel defined in
--   <tt>SourceConnConfiguration</tt> if <a>Nothing</a> is provided for
--   isolation level.
Tx :: TxAccess -> Maybe TxIsolation -> PGExecTxType

-- | The level from where the transaction is being run
data PGExecFrom

-- | transaction initated via a GraphQLRequest
GraphQLQuery :: Maybe PostgresResolvedConnectionTemplate -> PGExecFrom

-- | transaction initiated during run_sql
RunSQLQuery :: PGExecFrom

-- | custom transaction Hasura runs on the database. This is usually used
--   in event_trigger and actions
InternalRawQuery :: PGExecFrom

-- | transactions initiated via other API's other than <tt>run_sql</tt> in
--   <i>v1</i>query or <i>v2</i>query
LegacyRQLQuery :: PGExecFrom

-- | Creates a Postgres execution context for a single Postgres master pool
mkPGExecCtx :: TxIsolation -> PGPool -> ResizePoolStrategy -> PGExecCtx

-- | Resize Postgres pool by setting the number of connections equal to
--   allowed maximum connections across all server instances divided by
--   number of instances
resizePostgresPool :: PGPool -> Int -> ServerReplicas -> IO ()
defaultTxErrorHandler :: PGTxErr -> QErr

-- | Constructs a transaction error handler tailored for the needs of RQL's
--   DML.
dmlTxErrorHandler :: PGTxErr -> QErr

-- | Constructs a transaction error handler given a predicate that
--   determines which errors are expected and should be reported to the
--   user. All other errors are considered internal errors.
mkTxErrorHandler :: (PGErrorType -> Bool) -> PGTxErr -> QErr
data ConnectionTemplateConfig

-- | Connection templates are disabled for Hasura CE
ConnTemplate_NotApplicable :: ConnectionTemplateConfig
ConnTemplate_NotConfigured :: ConnectionTemplateConfig
ConnTemplate_Resolver :: ConnectionTemplateResolver -> ConnectionTemplateConfig
connectionTemplateConfigResolver :: ConnectionTemplateConfig -> Maybe ConnectionTemplateResolver

-- | A hook to resolve connection template
newtype ConnectionTemplateResolver
ConnectionTemplateResolver :: (forall m. MonadError QErr m => SessionVariables -> [Header] -> Maybe QueryContext -> m PostgresResolvedConnectionTemplate) -> ConnectionTemplateResolver

-- | Runs the connection template resolver.
[_runResolver] :: ConnectionTemplateResolver -> forall m. MonadError QErr m => SessionVariables -> [Header] -> Maybe QueryContext -> m PostgresResolvedConnectionTemplate
data PGSourceConfig
PGSourceConfig :: PGExecCtx -> ConnInfo -> Maybe (NonEmpty ConnInfo) -> IO () -> ExtensionsSchema -> HashMap PostgresConnectionSetMemberName ConnInfo -> ConnectionTemplateConfig -> PGSourceConfig
[_pscExecCtx] :: PGSourceConfig -> PGExecCtx
[_pscConnInfo] :: PGSourceConfig -> ConnInfo
[_pscReadReplicaConnInfos] :: PGSourceConfig -> Maybe (NonEmpty ConnInfo)
[_pscPostDropHook] :: PGSourceConfig -> IO ()
[_pscExtensionsSchema] :: PGSourceConfig -> ExtensionsSchema
[_pscConnectionSet] :: PGSourceConfig -> HashMap PostgresConnectionSetMemberName ConnInfo
[_pscConnectionTemplateConfig] :: PGSourceConfig -> ConnectionTemplateConfig
runPgSourceReadTx :: (MonadIO m, MonadBaseControl IO m) => PGSourceConfig -> TxET QErr m a -> m (Either QErr a)
runPgSourceWriteTx :: (MonadIO m, MonadBaseControl IO m) => PGSourceConfig -> PGExecFrom -> TxET QErr m a -> m (Either QErr a)

-- | Resolve connection templates only for non-admin roles
applyConnectionTemplateResolverNonAdmin :: MonadError QErr m => Maybe ConnectionTemplateResolver -> UserInfo -> [Header] -> Maybe QueryContext -> m (Maybe PostgresResolvedConnectionTemplate)
pgResolveConnectionTemplate :: MonadError QErr m => PGSourceConfig -> RequestContext -> Maybe ConnectionTemplate -> m EncJSON
resolvePostgresConnectionTemplate :: MonadError QErr m => ConnectionTemplate -> [PostgresConnectionSetMemberName] -> SessionVariables -> [Header] -> Maybe QueryContext -> m PostgresResolvedConnectionTemplate
sourceConfigNumReadReplicas :: PGSourceConfig -> Int
sourceConfigConnectonTemplateEnabled :: PGSourceConfig -> Bool
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.Types.PGSourceConfig
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.Types.PGSourceConfig
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Types.PGSourceConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.Types.PGSourceConfig
instance Data.Has.Has () Hasura.Backends.Postgres.Execute.Types.PGSourceConfig

module Hasura.ClientCredentials
getEEClientCredentialsTx :: TxE QErr (Maybe EEClientCredentials)
setEEClientCredentialsTx :: EEClientCredentials -> TxE QErr ()


-- | This module contains Data Connector request/response planning code and
--   utility functions and types that are common across the different
--   categories of requests (ie queries, mutations, etc). It contains code
--   and concepts that are independent of these different categories.
--   
--   Both <a>QueryPlan</a> and <a>MutationPlan</a> use the contents of this
--   module, for example <a>mkQueryPlan</a>.
module Hasura.Backends.DataConnector.Plan.Common

-- | Represents a <tt>request</tt> to be sent to a data connector agent
--   (<a>_pRequest</a>) and a function that is capable of reshaping the
--   response to that request into the final JSON form expected to be
--   returned by the GraphQL endpoint (<a>_pResponseReshaper</a>).
data Plan request response
Plan :: request -> (forall m. MonadError QErr m => response -> m Encoding) -> Plan request response
[_pRequest] :: Plan request response -> request
[_pResponseReshaper] :: Plan request response -> forall m. MonadError QErr m => response -> m Encoding

-- | Writes some output to state, like one might do if one was using a
--   Writer monad. The output is combined with the existing output using
--   <a>&lt;&gt;</a> from <a>Semigroup</a>
writeOutput :: (Semigroup output, MonadState state m, Has output state) => output -> m ()

-- | Replaces some output in the state with a new version of the output.
--   Also, a value can be returned from the replacement function.
--   
--   This is useful if you need to inspect the existing state, make a
--   decision, and update it based on that decision. The result of the
--   decision can be returned from the transformation as your <tt>a</tt>
--   value.
replaceOutput :: (MonadState state m, Has output state) => (output -> (output, a)) -> m a

-- | A monoidal data structure used to record Table Relationships
--   encountered during request translation. Used with
--   <tt>recordTableRelationship</tt>.
newtype TableRelationships
TableRelationships :: HashMap TargetName (HashMap RelationshipName Relationship) -> TableRelationships
[unTableRelationships] :: TableRelationships -> HashMap TargetName (HashMap RelationshipName Relationship)

-- | Records a relationship encountered during request translation into the
--   output of the current <a>WriterT</a>
recordRelationship :: (MonadState state m, Has TableRelationships state) => TargetName -> RelationshipName -> Relationship -> m ()
recordTableRelationshipFromRelInfo :: (MonadState state m, Has TableRelationships state) => TargetName -> RelInfo 'DataConnector -> m (RelationshipName, Relationship)

-- | Records a Native Query encountered during request translation into the
--   output of the current <a>WriterT</a>
recordNativeQuery :: (Has InterpolatedQueries state, Has ScalarTypesCapabilities r, MonadReader r m, MonadState state m, MonadError QErr m, Has SessionVariables r) => NativeQuery 'DataConnector (UnpreparedValue 'DataConnector) -> m InterpolatedQueryId

-- | Collects encountered redaction expressions on a per table/function
--   basis. Expressions are deduplicated and assigned a unique name (within
--   that table/function) that is then used to reference the expression
--   inside the query.
newtype RedactionExpressionState
RedactionExpressionState :: HashMap TargetName (HashMap RedactionExpression RedactionExpressionName) -> RedactionExpressionState
[unRedactionExpressionState] :: RedactionExpressionState -> HashMap TargetName (HashMap RedactionExpression RedactionExpressionName)
recordRedactionExpression :: (MonadState state m, Has TableRelationships state, Has RedactionExpressionState state, Has InterpolatedQueries state, MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r) => TargetName -> AnnRedactionExp 'DataConnector (UnpreparedValue 'DataConnector) -> m (Maybe RedactionExpressionName)
translateRedactionExpressions :: RedactionExpressionState -> Set TargetRedactionExpressions

-- | Represents a potential prefix that can be applied to a field name,
--   useful for namespacing field names that may be otherwise duplicated.
data FieldPrefix
noPrefix :: FieldPrefix
prefixWith :: FieldName -> FieldPrefix
applyPrefix :: FieldPrefix -> FieldName -> FieldName
data Cardinality
Single :: Cardinality
Many :: Cardinality
prepareLiteral :: (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r) => UnpreparedValue 'DataConnector -> m Literal
data ColumnStack
emptyColumnStack :: ColumnStack
pushColumn :: ColumnStack -> ColumnName -> ColumnStack
toColumnSelector :: ColumnStack -> ColumnName -> ColumnSelector
translateBoolExpToExpression :: (MonadState state m, Has TableRelationships state, Has InterpolatedQueries state, Has RedactionExpressionState state, MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r) => TargetName -> AnnBoolExp 'DataConnector (UnpreparedValue 'DataConnector) -> m (Maybe Expression)

-- | Helper function to convert targets into Keys
targetToTargetName :: Target -> TargetName
mkRelationshipName :: RelName -> RelationshipName
mapFieldNameHashMap :: HashMap FieldName v -> HashMap FieldName v
encodeAssocListAsObject :: [(Text, Encoding)] -> Encoding
instance GHC.Show.Show Hasura.Backends.DataConnector.Plan.Common.TableRelationships
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.Common.TableRelationships
instance GHC.Show.Show Hasura.Backends.DataConnector.Plan.Common.RedactionExpressionState
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.Common.RedactionExpressionState
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.Common.FieldPrefix
instance GHC.Show.Show Hasura.Backends.DataConnector.Plan.Common.FieldPrefix
instance GHC.Base.Semigroup Hasura.Backends.DataConnector.Plan.Common.FieldPrefix
instance GHC.Base.Monoid Hasura.Backends.DataConnector.Plan.Common.FieldPrefix
instance GHC.Base.Semigroup Hasura.Backends.DataConnector.Plan.Common.TableRelationships
instance GHC.Base.Monoid Hasura.Backends.DataConnector.Plan.Common.TableRelationships


-- | Module of reusable functions for Kriti transforms.
--   
--   NOTE: This defines an alternative <a>runKritiWith</a> that includes
--   the basicFunctions by default. You should probably invoke Kriti
--   through this module rather than directly in order to make updating the
--   functions available only require touching this module.
--   
--   TODO: This should be added to the documentation and referenced in
--   (for-example) REST Connectors once the documentation refactor project
--   is complete.
module Data.Aeson.Kriti.Functions

-- | <a>runKriti</a> attaches the basicFunctions by default NOTE: The error
--   type is SerializedError due to KritiError not currently being exported
runKriti :: Text -> [(Text, Value)] -> Either SerializedError Value

-- | <a>runKritiWith</a> attaches the basicFunctions by default.
runKritiWith :: Text -> [(Text, Value)] -> HashMap Text KritiFunc -> Either SerializedError Value

-- | Re-Export of the Kriti <tt>stdlib</tt>
basicFunctions :: HashMap Text KritiFunc

-- | Functions that interact with environment variables
environmentFunctions :: Environment -> HashMap Text KritiFunc

-- | Functions that interact with HGE session during requests
sessionFunctions :: Maybe SessionVariables -> HashMap Text KritiFunc


-- | Types and subroutines related to constructing transformations on HTTP
--   responses.
module Hasura.RQL.DDL.Webhook.Transform.Response

-- | Common context that is made available to all response transformations.
data ResponseTransformCtx
ResponseTransformCtx :: Value -> Value -> Maybe SessionVariables -> TemplatingEngine -> Int -> ResponseTransformCtx
[responseTransformBody] :: ResponseTransformCtx -> Value
[responseTransformReqCtx] :: ResponseTransformCtx -> Value
[responseSessionVariables] :: ResponseTransformCtx -> Maybe SessionVariables
[responseTransformEngine] :: ResponseTransformCtx -> TemplatingEngine
[responseStatusCode] :: ResponseTransformCtx -> Int

-- | A helper function for executing transformations from a <a>Template</a>
--   and a <a>ResponseTransformCtx</a>.
--   
--   NOTE: This and all related funtions are hard-coded to Kriti at the
--   moment. When we add additional template engines this function will
--   need to take a <a>TemplatingEngine</a> parameter.
runResponseTemplateTransform :: Template -> ResponseTransformCtx -> Either TransformErrorBundle Value

-- | Run an <a>UnescapedTemplate</a> with a <a>ResponseTransformCtx</a>.
runUnescapedResponseTemplateTransform :: ResponseTransformCtx -> UnescapedTemplate -> Either TransformErrorBundle ByteString

-- | Run an <a>UnescapedTemplate</a> with a <a>ResponseTransformCtx</a> in
--   <a>Validation</a>.
runUnescapedResponseTemplateTransform' :: ResponseTransformCtx -> UnescapedTemplate -> Validation TransformErrorBundle ByteString


-- | Types and subroutines related to constructing transformations on HTTP
--   requests.
module Hasura.RQL.DDL.Webhook.Transform.Request

-- | A smart constructor for constructing the <a>RequestTransformCtx</a>
--   
--   XXX: This function makes internal usage of <a>decodeUtf8</a>, which
--   throws an impure exception when the supplied <a>ByteString</a> cannot
--   be decoded into valid UTF8 text!
mkReqTransformCtx :: Text -> Maybe SessionVariables -> TemplatingEngine -> Request -> RequestTransformCtx

-- | A helper function for executing transformations from a <a>Template</a>
--   and a <a>RequestTransformCtx</a>.
--   
--   NOTE: This and all related funtions are hard-coded to Kriti at the
--   moment. When we add additional template engines this function will
--   need to take a <a>TemplatingEngine</a> parameter.
runRequestTemplateTransform :: Template -> RequestTransformCtx -> Either TransformErrorBundle Value
validateRequestTemplateTransform :: TemplatingEngine -> Template -> Either TransformErrorBundle ()
validateRequestTemplateTransform' :: TemplatingEngine -> Template -> Validation TransformErrorBundle ()

-- | A helper function for executing Kriti transformations from a
--   <a>UnescapedTemplate</a> and a <tt>RequestTrasformCtx</tt>.
--   
--   The difference from <a>runRequestTemplateTransform</a> is that this
--   function will wrap the template text in double quotes before running
--   Kriti.
runUnescapedRequestTemplateTransform :: RequestTransformCtx -> UnescapedTemplate -> Either TransformErrorBundle ByteString

-- | Run a Kriti transformation with an unescaped template in
--   <a>Validation</a> instead of <a>Either</a>.
runUnescapedRequestTemplateTransform' :: RequestTransformCtx -> UnescapedTemplate -> Validation TransformErrorBundle ByteString
validateRequestUnescapedTemplateTransform :: TemplatingEngine -> UnescapedTemplate -> Either TransformErrorBundle ()
validateRequestUnescapedTemplateTransform' :: TemplatingEngine -> UnescapedTemplate -> Validation TransformErrorBundle ()

module Hasura.RQL.DDL.Webhook.Transform.Url
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.Types.Webhook.Transform.Url.Url

module Hasura.RQL.DDL.Webhook.Transform.QueryParams
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.Types.Webhook.Transform.QueryParams.QueryParams

module Hasura.RQL.DDL.Webhook.Transform.Method
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.Types.Webhook.Transform.Method.Method

module Hasura.RQL.DDL.Webhook.Transform.Headers
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.Types.Webhook.Transform.Headers.Headers

module Hasura.RQL.DDL.Webhook.Transform.Body

-- | Validate that the provided <a>BodyTransformFn</a> is correct in the
--   context of a particular <a>TemplatingEngine</a>.
--   
--   This is a product of the fact that the correctness of a given
--   transformation may be dependent on zero, one, or more of the templated
--   transformations encoded within the given <a>BodyTransformFn</a>.
validateBodyTransformFn :: TemplatingEngine -> BodyTransformFn -> Validation TransformErrorBundle ()

-- | Fold a <a>HashMap</a> of header key/value pairs into an
--   <tt>x-www-form-urlencoded</tt> message body.
foldFormEncoded :: HashMap Text ByteString -> ByteString
instance Hasura.RQL.DDL.Webhook.Transform.Class.Transform Hasura.RQL.Types.Webhook.Transform.Body.Body


-- | Webhook Transformations are data transformations used to modify HTTP
--   Requests/Responses before requests are executed and after responses
--   are received.
--   
--   Transformations are supplied by users as part of the Metadata for a
--   particular Action or EventTrigger as a <a>RequestTransform</a> record.
--   Per-field Transformations are stored as data (defunctionalized), often
--   in the form of a Kriti template, and then converted into actual
--   functions (reified) at runtime by the <a>Transform</a> typeclass.
--   
--   We take a Higher Kinded Data (HKD) approach to representing the
--   transformations. <a>RequestFields</a> is an HKD which can represent
--   the actual request data as 'RequestFields Identity' or the
--   defunctionalized transforms as 'RequestFields (WithOptional
--   TransformFn)'.
--   
--   We can then traverse over the entire <a>RequestFields</a> HKD to reify
--   all the fields at once and apply them to our actual request data.
--   
--   NOTE: We don't literally use <a>traverse</a> or the HKD equivalent
--   <tt>btraverse</tt>, but you can think of this operation morally as a
--   traversal. See <a>applyRequestTransform</a> for implementation
--   details.
module Hasura.RQL.DDL.Webhook.Transform

-- | Transform an <a>Request</a> with a <a>RequestTransform</a>.
--   
--   Note: we pass in the request url explicitly for use in the
--   <tt>ReqTransformCtx</tt>. We do this so that we can ensure that the
--   url is syntactically identical to what the use submits. If we use the
--   parsed request from the <a>Request</a> term then it is possible that
--   the url is semantically equivalent but syntactically different. An
--   example of this is the presence or lack of a trailing slash on the URL
--   path. This important when performing string interpolation on the
--   request url.
applyRequestTransform :: forall m. MonadError TransformErrorBundle m => (Request -> RequestContext) -> RequestTransformFns -> Request -> m Request

-- | A set of data transformation functions generated from a
--   <a>MetadataResponseTransform</a>. <a>Nothing</a> means use the
--   original response value.
data ResponseTransform
ResponseTransform :: Maybe (ResponseTransformCtx -> Either TransformErrorBundle Value) -> TemplatingEngine -> ResponseTransform
[respTransformBody] :: ResponseTransform -> Maybe (ResponseTransformCtx -> Either TransformErrorBundle Value)
[respTransformTemplateEngine] :: ResponseTransform -> TemplatingEngine

-- | A helper function for constructing the <a>ResponseTransformCtx</a>
buildRespTransformCtx :: Maybe RequestContext -> Maybe SessionVariables -> TemplatingEngine -> ByteString -> Int -> ResponseTransformCtx
mkResponseTransform :: MetadataResponseTransform -> ResponseTransform

-- | At the moment we only transform the body of Responses. 'http-client'
--   does not export the constructors for <tt>Response</tt>. If we want to
--   transform other fields then we will need additional <tt>apply</tt>
--   functions.
applyResponseTransform :: ResponseTransform -> ResponseTransformCtx -> Either TransformErrorBundle ByteString
mkRequestContext :: RequestTransformCtx -> RequestContext


-- | We validate <a>TransformFn</a> terms inside <a>RequestTransform</a>
--   before dispatching Metadata actions in <tt>runMetadataQueryV1M</tt>.
--   Validation follows the same HKD pattern from
--   <a>applyRequestTransform</a> but using <a>btraverseC</a> to call
--   <a>validate</a> from the <a>Transform</a> class on all the HKD fields.
module Hasura.RQL.DDL.Webhook.Transform.Validation

-- | Validate all 'TransformFn a' fields in the <a>RequestTransform</a>.
validateRequestTransform :: MonadError QErr m => RequestTransform -> m RequestTransform

-- | Used to annotate that a <a>RequestTransform</a>, or some record
--   containing a <a>RequestTransform</a> has not yet been validated.
newtype Unvalidated a
Unvalidated :: a -> Unvalidated a
[_unUnvalidate] :: Unvalidated a -> a

-- | A lens for focusing through <a>Unvalidated</a> in
--   <a>validateTransforms</a>.
unUnvalidate :: Lens' (Unvalidated a) a

-- | Used to annotate that a higher kinded type containing a
--   <a>RequestTransform</a> has not yet been validated.
--   
--   This is needed specifically for <tt>CreateEventTriggerQuery</tt> and
--   any other type that is paramterized by a <tt>BackendType</tt>.
newtype Unvalidated1 (f :: k -> Type) (a :: k)
Unvalidated1 :: f a -> Unvalidated1 (f :: k -> Type) (a :: k)
[_unUnvalidate1] :: Unvalidated1 (f :: k -> Type) (a :: k) -> f a

-- | A lens for focusing through <a>Unvalidated1</a> in
--   <a>validateTransforms</a>.
unUnvalidate1 :: Lens' (Unvalidated1 f a) (f a)

-- | Used to focus into a records in <tt>RQLMetadataV1</tt> and validate
--   any <a>RequestTransform</a> terms present.
validateTransforms :: MonadError QErr m => LensLike m api api RequestTransform RequestTransform -> LensLike m api api MetadataResponseTransform MetadataResponseTransform -> (api -> m EncJSON) -> api -> m EncJSON
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated a)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated a)
instance forall k (f :: k -> *) (a :: k). Data.Aeson.Types.ToJSON.ToJSON (f a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated1 f a)
instance forall k (f :: k -> *) (a :: k). Data.Aeson.Types.FromJSON.FromJSON (f a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Webhook.Transform.Validation.Unvalidated1 f a)

module Hasura.Backends.DataConnector.Adapter.ConfigTransform
transformSourceConfig :: MonadError QErr m => SourceConfig -> Maybe SessionVariables -> m SourceConfig

-- | Apply a transformation to a <a>ConnSourceConfig</a> and validate the
--   result.
validateConnSourceConfig :: MonadError QErr m => DataConnectorName -> SourceName -> ConfigSchemaResponse -> ConnSourceConfig -> Maybe SessionVariables -> Environment -> m ()


-- | Types for stored procedures.
module Hasura.StoredProcedure.Types

-- | Tracked stored procedure configuration, and payload of the
--   'pg_track_stored procedure'.
data StoredProcedureConfig
StoredProcedureConfig :: StoredProcedureExposedAs -> Maybe Name -> StoredProcedureConfig

-- | In which top-level field should we expose this stored procedure?
[_spcExposedAs] :: StoredProcedureConfig -> StoredProcedureExposedAs
[_spcCustomName] :: StoredProcedureConfig -> Maybe Name

-- | Indicates whether the user requested the corresponding stored
--   procedure to be tracked as a mutation or a query, in
--   <tt>track_stored_procedure</tt>. currently only query is supported.
data StoredProcedureExposedAs
SPEAQuery :: StoredProcedureExposedAs
instance GHC.Generics.Generic Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance GHC.Classes.Eq Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance GHC.Show.Show Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance GHC.Generics.Generic Hasura.StoredProcedure.Types.StoredProcedureConfig
instance GHC.Classes.Eq Hasura.StoredProcedure.Types.StoredProcedureConfig
instance GHC.Show.Show Hasura.StoredProcedure.Types.StoredProcedureConfig
instance Control.DeepSeq.NFData Hasura.StoredProcedure.Types.StoredProcedureConfig
instance Autodocodec.Class.HasCodec Hasura.StoredProcedure.Types.StoredProcedureConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.StoredProcedure.Types.StoredProcedureConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.StoredProcedure.Types.StoredProcedureConfig
instance Control.DeepSeq.NFData Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance Autodocodec.Class.HasCodec Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.StoredProcedure.Types.StoredProcedureExposedAs
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.StoredProcedure.Types.StoredProcedureExposedAs


-- | Metadata representation of a stored procedure in the metadata, as well
--   as a parser and prettyprinter for the query code.
module Hasura.StoredProcedure.Metadata

-- | The representation of stored procedures within the metadata structure.
data StoredProcedureMetadata (b :: BackendType)
StoredProcedureMetadata :: FunctionName b -> StoredProcedureConfig -> LogicalModelName -> HashMap ArgumentName (NullableScalarType b) -> Maybe Text -> StoredProcedureMetadata (b :: BackendType)
[_spmStoredProcedure] :: StoredProcedureMetadata (b :: BackendType) -> FunctionName b
[_spmConfig] :: StoredProcedureMetadata (b :: BackendType) -> StoredProcedureConfig
[_spmReturns] :: StoredProcedureMetadata (b :: BackendType) -> LogicalModelName
[_spmArguments] :: StoredProcedureMetadata (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[_spmDescription] :: StoredProcedureMetadata (b :: BackendType) -> Maybe Text
spmStoredProcedure :: forall b_afzFn. Lens' (StoredProcedureMetadata b_afzFn) (FunctionName b_afzFn)
spmReturns :: forall b_afzFn. Lens' (StoredProcedureMetadata b_afzFn) LogicalModelName
spmDescription :: forall b_afzFn. Lens' (StoredProcedureMetadata b_afzFn) (Maybe Text)
spmConfig :: forall b_afzFn. Lens' (StoredProcedureMetadata b_afzFn) StoredProcedureConfig
spmArguments :: forall b_afzFn. Lens' (StoredProcedureMetadata b_afzFn) (HashMap ArgumentName (NullableScalarType b_afzFn))
instance GHC.Generics.Generic (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.StoredProcedure.Metadata.StoredProcedureMetadata b)


-- | The RQL IR representation of an invocation of a stored procedure.
module Hasura.StoredProcedure.IR

-- | The RQL IR representation of an invocation of a stored procedure.
data StoredProcedure b field
StoredProcedure :: FunctionName b -> Name -> HashMap ArgumentName (ScalarType b, field) -> LogicalModel b -> StoredProcedure b field

-- | The SQL name of the stored procedure.
[spStoredProcedure] :: StoredProcedure b field -> FunctionName b

-- | The graphql name of the stored procedure.
[spGraphqlName] :: StoredProcedure b field -> Name

-- | The arguments passed to the query, if any.
[spArgs] :: StoredProcedure b field -> HashMap ArgumentName (ScalarType b, field)

-- | The return type of the stored procedure
[spLogicalModel] :: StoredProcedure b field -> LogicalModel b
instance Data.Traversable.Traversable (Hasura.StoredProcedure.IR.StoredProcedure b)
instance Data.Foldable.Foldable (Hasura.StoredProcedure.IR.StoredProcedure b)
instance GHC.Base.Functor (Hasura.StoredProcedure.IR.StoredProcedure b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq field) => GHC.Classes.Eq (Hasura.StoredProcedure.IR.StoredProcedure b field)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show field) => GHC.Show.Show (Hasura.StoredProcedure.IR.StoredProcedure b field)


-- | More leaves peeled from <a>Select</a> for compilation speed
module Hasura.RQL.IR.Select.From
data SelectFromG (b :: BackendType) v
FromTable :: TableName b -> SelectFromG (b :: BackendType) v
FromIdentifier :: FIIdentifier -> SelectFromG (b :: BackendType) v
FromFunction :: FunctionName b -> FunctionArgsExp b v -> Maybe [(Column b, ScalarType b)] -> SelectFromG (b :: BackendType) v
FromNativeQuery :: NativeQuery b v -> SelectFromG (b :: BackendType) v
FromStoredProcedure :: StoredProcedure b v -> SelectFromG (b :: BackendType) v
type SelectFrom b = SelectFromG b (SQLExpression b)

-- | Identifier used exclusively as the argument to <a>FromIdentifier</a>
newtype FIIdentifier
FIIdentifier :: Text -> FIIdentifier
[$sel:unFIIdentifier:FIIdentifier] :: FIIdentifier -> Text
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.Select.From.FIIdentifier
instance GHC.Show.Show Hasura.RQL.IR.Select.From.FIIdentifier
instance GHC.Classes.Eq Hasura.RQL.IR.Select.From.FIIdentifier
instance GHC.Generics.Generic Hasura.RQL.IR.Select.From.FIIdentifier
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.From.SelectFromG b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.From.SelectFromG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.From.SelectFromG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.From.SelectFromG b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq (Hasura.RQL.Types.Backend.FunctionArgumentExp b v), GHC.Classes.Eq (Hasura.NativeQuery.IR.NativeQuery b v), GHC.Classes.Eq (Hasura.StoredProcedure.IR.StoredProcedure b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.From.SelectFromG b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v, GHC.Show.Show (Hasura.RQL.Types.Backend.FunctionArgumentExp b v), GHC.Show.Show (Hasura.NativeQuery.IR.NativeQuery b v), GHC.Show.Show (Hasura.StoredProcedure.IR.StoredProcedure b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.From.SelectFromG b v)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v, Data.Hashable.Class.Hashable (Hasura.RQL.Types.Backend.FunctionArgumentExp b v), Data.Hashable.Class.Hashable (Hasura.NativeQuery.IR.NativeQuery b v), Data.Hashable.Class.Hashable (Hasura.StoredProcedure.IR.StoredProcedure b v)) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.From.SelectFromG b v)
instance Hasura.Backends.Postgres.SQL.Types.IsIdentifier Hasura.RQL.IR.Select.From.FIIdentifier


-- | More leaves from <a>Select</a>
module Hasura.RQL.IR.Select.AnnSelectG
data AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type)
AnnSelectG :: Fields (f v) -> SelectFromG b v -> TablePermG b v -> SelectArgsG b v -> StringifyNumbers -> Maybe NamingCase -> AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type)
[$sel:_asnFields:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> Fields (f v)
[$sel:_asnFrom:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> SelectFromG b v
[$sel:_asnPerm:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> TablePermG b v
[$sel:_asnArgs:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> SelectArgsG b v
[$sel:_asnStrfyNum:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> StringifyNumbers
[$sel:_asnNamingConvention:AnnSelectG] :: AnnSelectG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> Maybe NamingCase

-- | IR type representing nodes for streaming subscriptions
data AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type)
AnnSelectStreamG :: XStreamingSubscription b -> Fields (f v) -> SelectFromG b v -> TablePermG b v -> SelectStreamArgsG b v -> StringifyNumbers -> AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type)

-- | type to indicate if streaming subscription has been enabled in the
--   <a>BackendType</a>. This type helps avoiding missing case match
--   patterns for backends where it's disabled.
[$sel:_assnXStreamingSubscription:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> XStreamingSubscription b

-- | output selection fields
[$sel:_assnFields:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> Fields (f v)

-- | table information to select from
[$sel:_assnFrom:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> SelectFromG b v

-- | select permissions
[$sel:_assnPerm:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> TablePermG b v

-- | streaming arguments
[$sel:_assnArgs:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> SelectStreamArgsG b v
[$sel:_assnStrfyNum:AnnSelectStreamG] :: AnnSelectStreamG (b :: BackendType) (f :: Type -> Type) (v :: Type) -> StringifyNumbers

-- | We can't write a Bifoldable instance for AnnSelectG because the types
--   don't line up. Instead, we provide this function which can be used to
--   help define Bifoldable instances of other types containing AnnSelectG
--   values.
bifoldMapAnnSelectG :: (Backend b, Bifoldable (f b), Monoid m) => (r -> m) -> (v -> m) -> AnnSelectG b (f b r) v -> m
bifoldMapAnnSelectStreamG :: (Backend b, Bifoldable (f b), Monoid m) => (r -> m) -> (v -> m) -> AnnSelectStreamG b (f b r) v -> m
instance (Hasura.RQL.Types.Backend.Backend b, Data.Traversable.Traversable f) => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b f)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Foldable.Foldable f) => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Base.Functor f) => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b f)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Traversable.Traversable f) => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectStreamG b f)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Foldable.Foldable f) => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectStreamG b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Base.Functor f) => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectStreamG b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Common.Fields (f v)), GHC.Classes.Eq (Hasura.RQL.IR.Select.Args.SelectArgsG b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.From.SelectFromG b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.TablePerm.TablePermG b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b f v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Common.Fields (f v)), GHC.Show.Show (Hasura.RQL.IR.Select.Args.SelectArgsG b v), GHC.Show.Show (Hasura.RQL.IR.Select.From.SelectFromG b v), GHC.Show.Show (Hasura.RQL.IR.Select.TablePerm.TablePermG b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b f v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.From.SelectFromG b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.TablePerm.TablePermG b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b v), GHC.Classes.Eq (f v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectStreamG b f v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.From.SelectFromG b v), GHC.Show.Show (Hasura.RQL.IR.Select.TablePerm.TablePermG b v), GHC.Show.Show (Hasura.RQL.IR.Select.Args.SelectStreamArgsG b v), GHC.Show.Show (f v)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectStreamG b f v)

module Hasura.Tracing.Sampling

-- | B3 propagation sampling state.
--   
--   Debug sampling state not represented.
data SamplingState
SamplingDefer :: SamplingState
SamplingDeny :: SamplingState
SamplingAccept :: SamplingState

-- | Convert a sampling state to a value for the X-B3-Sampled header. A
--   return value of Nothing indicates that the header should not be set.
samplingStateToHeader :: IsString s => SamplingState -> Maybe s

-- | Convert a X-B3-Sampled header value to a sampling state. An input of
--   Nothing indicates that the header was not set.
samplingStateFromHeader :: (IsString s, Eq s) => Maybe s -> SamplingState

-- | A local decision about whether or not to sample spans.
data SamplingDecision
SampleNever :: SamplingDecision
SampleAlways :: SamplingDecision

-- | An IO action for deciding whether or not to sample a trace.
--   
--   Currently restricted to deny access to the B3 sampling state, but we
--   may want to be more flexible in the future.
type SamplingPolicy = IO SamplingDecision
sampleNever :: SamplingPolicy
sampleAlways :: SamplingPolicy
sampleRandomly :: Double -> SamplingPolicy
sampleOneInN :: Refined Positive Int -> SamplingPolicy

module Hasura.Tracing.TraceId

-- | 128-bit trace identifiers.
--   
--   <a>TraceId</a>s are guaranteed to have at least one non-zero bit.
data TraceId
randomTraceId :: MonadIO m => m TraceId

-- | Create a <a>TraceId</a> from a <a>ByteString</a>.
--   
--   Fails if the <a>ByteString</a> is not exactly 16 bytes long, or if it
--   contains only zero bytes.
traceIdFromBytes :: ByteString -> Maybe TraceId

-- | Convert a <a>TraceId</a> to a <a>ByteString</a> of 16 bytes.
traceIdToBytes :: TraceId -> ByteString

-- | Parse a <a>TraceId</a> from the standard ASCII-encoded hex string
--   format.
--   
--   Fails if the <a>ByteString</a> is not exactly 32 characters long, or
--   if it contains only zero characters.
traceIdFromHex :: ByteString -> Maybe TraceId

-- | Serialize a <a>TraceId</a> to the standard ASCII-encoded hex
--   representation.
traceIdToHex :: TraceId -> ByteString

-- | 64-bit span identifiers
--   
--   <a>SpanId</a>s are guaranteed to have at least one non-zero bit.
data SpanId
randomSpanId :: MonadIO m => m SpanId

-- | Create a <a>SpanId</a> from a <a>ByteString</a>.
--   
--   Fails if the <a>ByteString</a> is not exactly 8 bytes long, or if it
--   contains only zero bytes.
spanIdFromBytes :: ByteString -> Maybe SpanId

-- | Convert a <a>SpanId</a> to a <a>ByteString</a> of 8 bytes.
spanIdToBytes :: SpanId -> ByteString

-- | Parse a <a>SpanId</a> from the standard ASCII-encoded hex string
--   format.
--   
--   Fails if the <a>ByteString</a> is not exactly 16 characters long, or
--   if it contains only zero characters.
spanIdFromHex :: ByteString -> Maybe SpanId

-- | Serialize a <a>SpanId</a> to the standard ASCII-encoded hex
--   representation.
spanIdToHex :: SpanId -> ByteString
instance GHC.Classes.Eq Hasura.Tracing.TraceId.TraceId
instance GHC.Classes.Eq Hasura.Tracing.TraceId.SpanId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Tracing.TraceId.SpanId
instance GHC.Show.Show Hasura.Tracing.TraceId.SpanId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Tracing.TraceId.TraceId
instance GHC.Show.Show Hasura.Tracing.TraceId.TraceId

module Hasura.Tracing.Context

-- | Any additional human-readable key-value pairs relevant to the
--   execution of a span.
--   
--   When the Open Telemetry exporter is in use these become attributes.
--   Where possible and appropriate, consider using key names from the
--   documented OT semantic conventions here:
--   <a>https://opentelemetry.io/docs/reference/specification/trace/semantic_conventions/</a>
--   This can serve to document the metadata, even for users not using open
--   telemetry.
--   
--   We may make this type more closely align with the OT data model in the
--   future (e.g. supporting int, etc)
type TraceMetadata = [(Text, Text)]

-- | A trace context records the current active trace, the active span
--   within that trace, and the span's parent, unless the current span is
--   the root. This is like a call stack.
data TraceContext
TraceContext :: TraceId -> SpanId -> Maybe SpanId -> SamplingState -> TraceContext
[tcCurrentTrace] :: TraceContext -> TraceId
[tcCurrentSpan] :: TraceContext -> SpanId
[tcCurrentParent] :: TraceContext -> Maybe SpanId
[tcSamplingState] :: TraceContext -> SamplingState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Tracing.Context.TraceContext

module Hasura.Tracing.Reporter
newtype Reporter
Reporter :: (forall m a. (MonadIO m, MonadBaseControl IO m) => TraceContext -> Text -> IO TraceMetadata -> m a -> m a) -> Reporter
[runReporter] :: Reporter -> forall m a. (MonadIO m, MonadBaseControl IO m) => TraceContext -> Text -> IO TraceMetadata -> m a -> m a
noReporter :: Reporter


-- | Defines the Tracing API.
--   
--   The <a>MonadTrace</a> class defines the "public API" of this
--   component.
module Hasura.Tracing.Class
class (MonadTraceContext m) => MonadTrace m

-- | Trace the execution of a block of code, attaching a human-readable
--   name. This starts a new trace and its corresponding root span, to
--   which subsequent spans will be attached.
newTraceWith :: MonadTrace m => TraceContext -> SamplingPolicy -> Text -> m a -> m a

-- | Starts a new span within the current trace. No-op if there's no
--   current trace.
--   
--   TODO: we could rewrite this to start a new trace if there isn't one,
--   using the default reporter and policy? This would guarantee that no
--   span is ever lost, but would also risk reporting undesired spans.
newSpanWith :: MonadTrace m => SpanId -> Text -> m a -> m a

-- | Log some arbitrary metadata to be attached to the current span, if
--   any.
attachMetadata :: MonadTrace m => TraceMetadata -> m ()

-- | Access to the current tracing context, factored out of
--   <a>MonadTrace</a> so we can use it separately and dispatch the
--   constraint in cases outside of a MonadTrace context.
class (Monad m) => MonadTraceContext m

-- | Ask for the current tracing context, so that we can provide it to any
--   downstream services, e.g. in HTTP headers. Returns <a>Nothing</a> if
--   we're not currently tracing anything.
currentContext :: MonadTraceContext m => m (Maybe TraceContext)

-- | Provide an empty <a>TraceContext</a> where we aren't in a
--   <a>MonadTrace</a> context.
runNoMonadTraceContext :: NoMonadTraceContext f a -> f a

-- | Create a new trace using a randomly-generated context.
newTrace :: (MonadIO m, MonadTrace m) => SamplingPolicy -> Text -> m a -> m a

-- | Create a new span with a randomly-generated id.
newSpan :: (MonadIO m, MonadTrace m) => Text -> m a -> m a
instance Control.Monad.IO.Class.MonadIO f => Control.Monad.IO.Class.MonadIO (Hasura.Tracing.Class.NoMonadTraceContext f)
instance GHC.Base.Monad f => GHC.Base.Monad (Hasura.Tracing.Class.NoMonadTraceContext f)
instance GHC.Base.Functor f => GHC.Base.Functor (Hasura.Tracing.Class.NoMonadTraceContext f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Hasura.Tracing.Class.NoMonadTraceContext f)
instance GHC.Base.Monad m => Hasura.Tracing.Class.MonadTraceContext (Hasura.Tracing.Class.NoMonadTraceContext m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Control.Monad.Trans.State.Strict.StateT e m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Control.Monad.Trans.Maybe.MaybeT m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Control.Monad.Trans.State.Strict.StateT e m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Control.Monad.Trans.Maybe.MaybeT m)

module Hasura.Tracing.Monad

-- | TraceT is the standard implementation of <a>MonadTrace</a>. Via a
--   <a>Reader</a>, it keeps track of the default policy and reporter to
--   use thoughout the stack, as well as the current trace.
newtype TraceT m a
TraceT :: ReaderT (Reporter, Maybe TraceEnv) m a -> TraceT m a

-- | Runs the <a>TraceT</a> monad, by providing the default reporter. This
--   does NOT start a trace.
--   
--   TODO: we could change this to always start a trace with a default
--   name? This would allow us to guarantee that there is always a current
--   trace, but this might not always be the correct behaviour: in
--   practice, we would end up generating one that spans the entire
--   lifetime of the engine if <a>runTraceT</a> were to be used from
--   <tt>main</tt>.
runTraceT :: Reporter -> TraceT m a -> m a

-- | Run the <a>TraceT</a> monad, but without actually tracing anything: no
--   report will be emitted, even if calls to <a>newTraceWith</a> force the
--   trace to be sampled.
ignoreTraceT :: TraceT m a -> m a
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Tracing.Monad.TraceT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.Tracing.Monad.TraceT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Hasura.Tracing.Monad.TraceT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.Tracing.Monad.TraceT
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.Tracing.Monad.TraceT m)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m) => Hasura.Tracing.Class.MonadTrace (Hasura.Tracing.Monad.TraceT m)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO m) => Hasura.Tracing.Class.MonadTraceContext (Hasura.Tracing.Monad.TraceT m)
instance Hasura.RQL.Types.Session.UserInfoM m => Hasura.RQL.Types.Session.UserInfoM (Hasura.Tracing.Monad.TraceT m)
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Hasura.Tracing.Monad.TraceT m)

module Hasura.Logging

-- | A zoned timestamp with defined serialized format (via the ToJSON
--   instance)
--   
--   Internals not exported. Construct with <a>getFormattedTime</a>
data FormattedTime

-- | Timestamp as uniz epoch time, in nanoseconds.
toPOSIX_ns :: FormattedTime -> Word64

-- | Typeclass representing any type which can be parsed into a list of
--   enabled log types, and has a <tt>Set</tt> of default enabled log
--   types, and can find out if a log type is enabled
class (Eq (EngineLogType impl), Hashable (EngineLogType impl)) => EnabledLogTypes impl
parseEnabledLogTypes :: EnabledLogTypes impl => String -> Either String [EngineLogType impl]
defaultEnabledLogTypes :: EnabledLogTypes impl => HashSet (EngineLogType impl)
isLogTypeEnabled :: EnabledLogTypes impl => HashSet (EngineLogType impl) -> EngineLogType impl -> Bool

-- | A family of EngineLogType types
data family EngineLogType impl
data Hasura
data InternalLogTypes

-- | mostly for debug logs - see <tt>debugT</tt>, <tt>debugBS</tt> and
--   <tt>debugLBS</tt> functions
ILTUnstructured :: InternalLogTypes
ILTUnhandledInternalError :: InternalLogTypes
ILTEventTrigger :: InternalLogTypes
ILTEventTriggerProcess :: InternalLogTypes
ILTScheduledTrigger :: InternalLogTypes
ILTScheduledTriggerProcess :: InternalLogTypes
ILTCronEventGeneratorProcess :: InternalLogTypes

-- | internal logs for the websocket server
ILTWsServer :: InternalLogTypes
ILTPgClient :: InternalLogTypes

-- | log type for logging metadata related actions; currently used in
--   logging inconsistent metadata
ILTMetadata :: InternalLogTypes
ILTTelemetry :: InternalLogTypes
ILTSchemaSync :: InternalLogTypes
ILTSourceCatalogMigration :: InternalLogTypes
ILTStoredIntrospection :: InternalLogTypes
ILTStoredIntrospectionStorage :: InternalLogTypes
defaultEnabledEngineLogTypes :: HashSet (EngineLogType Hasura)
isEngineLogTypeEnabled :: HashSet (EngineLogType Hasura) -> EngineLogType Hasura -> Bool
readLogTypes :: String -> Either String [EngineLogType Hasura]
userAllowedLogTypes :: [EngineLogType Hasura]
data LogLevel
LevelDebug :: LogLevel
LevelInfo :: LogLevel
LevelWarn :: LogLevel
LevelError :: LogLevel
LevelOther :: Text -> LogLevel

-- | Human-readable LogLevel, as serialized for end-users
prettyLogLevel :: LogLevel -> Text

-- | This is the top-level log type emitted for OSS and on-prem enterprise.
--   It is built from the output of <a>toEngineLog</a>
data EngineLog impl
EngineLog :: !FormattedTime -> !LogLevel -> !EngineLogType impl -> !Value -> !Maybe TraceId -> !Maybe SpanId -> EngineLog impl
[_elTimestamp] :: EngineLog impl -> !FormattedTime
[_elLevel] :: EngineLog impl -> !LogLevel
[_elType] :: EngineLog impl -> !EngineLogType impl
[_elDetail] :: EngineLog impl -> !Value

-- | The trace context in which this log message was emitted, if any. See
--   <a>unLoggerTracing</a>.
[_elTraceId] :: EngineLog impl -> !Maybe TraceId

-- | The span context in which this log message was emitted, if any. See
--   <a>unLoggerTracing</a>.
[_elSpanId] :: EngineLog impl -> !Maybe SpanId

-- | Typeclass representing any data type that can be converted to
--   <tt>EngineLog</tt> for the purpose of logging
class (EnabledLogTypes impl) => ToEngineLog a impl
toEngineLog :: ToEngineLog a impl => a -> (LogLevel, EngineLogType impl, Value)
data UnstructuredLog
UnstructuredLog :: !LogLevel -> !SerializableBlob -> UnstructuredLog
[_ulLevel] :: UnstructuredLog -> !LogLevel
[_ulPayload] :: UnstructuredLog -> !SerializableBlob
debugT :: Text -> UnstructuredLog
debugBS :: ByteString -> UnstructuredLog
debugLBS :: ByteString -> UnstructuredLog
data LoggerCtx impl
LoggerCtx :: !LoggerSet -> !LogLevel -> !IO FormattedTime -> !HashSet (EngineLogType impl) -> LoggerCtx impl
[_lcLoggerSet] :: LoggerCtx impl -> !LoggerSet
[_lcLogLevel] :: LoggerCtx impl -> !LogLevel
[_lcTimeGetter] :: LoggerCtx impl -> !IO FormattedTime
[_lcEnabledLogTypes] :: LoggerCtx impl -> !HashSet (EngineLogType impl)

-- | We expect situations where there are code paths that should not occur
--   and we throw an <a>error</a> on this code paths. If our assumptions
--   are incorrect and infact these errors do occur, we want to log them.
newtype UnhandledInternalErrorLog
UnhandledInternalErrorLog :: ErrorCall -> UnhandledInternalErrorLog
data LoggerSettings
LoggerSettings :: !Bool -> !Maybe TimeZone -> !LogLevel -> LoggerSettings

-- | should current time be cached (refreshed every sec)
[_lsCachedTimestamp] :: LoggerSettings -> !Bool
[_lsTimeZone] :: LoggerSettings -> !Maybe TimeZone
[_lsLevel] :: LoggerSettings -> !LogLevel
defaultLoggerSettings :: Bool -> LogLevel -> LoggerSettings

-- | Get the current time, formatted with the current or specified timezone
getFormattedTime :: Maybe TimeZone -> IO FormattedTime

-- | Creates a new <a>LoggerCtx</a>.
--   
--   The underlying <tt>LoggerSet</tt> is bound to the <a>ManagedT</a>
--   context: when it exits, the log will be flushed and cleared regardless
--   of whether it was exited properly or not (<a>ManagedT</a> uses
--   <tt>bracket</tt> underneath). This guarantees that the logs will
--   always be flushed, even in case of error, avoiding a repeat of
--   <a>https://github.com/hasura/graphql-engine/issues/4772</a>.
mkLoggerCtx :: (MonadIO io, MonadBaseControl IO io) => LoggerSettings -> HashSet (EngineLogType impl) -> ManagedT io (LoggerCtx impl)
cleanLoggerCtx :: LoggerCtx a -> IO ()

-- | A callback capable of actually emitting a log line (e.g. to stdout).
--   If not in a <tt>MonadTrace</tt> context you can make use of the old
--   API via <a>Logger</a> and <a>unLogger</a>.
newtype Logger impl
LoggerTracing :: (forall a m. (ToEngineLog a impl, MonadTraceContext m, MonadIO m) => a -> m ()) -> Logger impl
[unLoggerTracing] :: Logger impl -> forall a m. (ToEngineLog a impl, MonadTraceContext m, MonadIO m) => a -> m ()

-- | This is kept for compatibility with the old interface, which didn't
--   require a <tt>MonadTraceContext</tt> environment
pattern Logger :: forall impl. (forall a m. (ToEngineLog a impl, MonadIO m) => a -> m ()) -> Logger impl

-- | A callback capable of actually emitting a log line (e.g. to stdout).
--   If not in a <tt>MonadTrace</tt> context you can make use of the old
--   API via <a>Logger</a> and <a>unLogger</a>.
newtype Logger impl
LoggerTracing :: (forall a m. (ToEngineLog a impl, MonadTraceContext m, MonadIO m) => a -> m ()) -> Logger impl
[unLoggerTracing] :: Logger impl -> forall a m. (ToEngineLog a impl, MonadTraceContext m, MonadIO m) => a -> m ()

-- | This is kept for compatibility with the old interface, which didn't
--   require a <tt>MonadTraceContext</tt> environment
pattern Logger :: forall impl. (forall a m. (ToEngineLog a impl, MonadIO m) => a -> m ()) -> Logger impl
mkLogger :: ToJSON (EngineLogType impl) => LoggerCtx impl -> Logger impl
nullLogger :: Logger Hasura
eventTriggerLogType :: EngineLogType Hasura
eventTriggerProcessLogType :: EngineLogType Hasura
scheduledTriggerLogType :: EngineLogType Hasura
scheduledTriggerProcessLogType :: EngineLogType Hasura
cronEventGeneratorProcessType :: EngineLogType Hasura
sourceCatalogMigrationLogType :: EngineLogType Hasura

-- | Emit when stored introspection is used
data StoredIntrospectionLog
StoredIntrospectionLog :: Text -> QErr -> StoredIntrospectionLog
[silMessage] :: StoredIntrospectionLog -> Text

-- | upstream data source errors
[silSourceError] :: StoredIntrospectionLog -> QErr

-- | Logs related to errors while interacting with the stored introspection
--   storage
data StoredIntrospectionStorageLog
StoredIntrospectionStorageLog :: Text -> QErr -> StoredIntrospectionStorageLog
[sislMessage] :: StoredIntrospectionStorageLog -> Text
[sislError] :: StoredIntrospectionStorageLog -> QErr

-- | A logger useful for accumulating and logging stats, in tight polling
--   loops. It also debounces to not flood with excessive logs. Use
--   @<a>logStats</a> to record statistics for logging.
createStatsLogger :: forall m stats impl. (MonadIO m, ToEngineLog stats impl, Monoid stats) => Logger impl -> m (Trigger stats stats)

-- | Safely close the statistics logger. When occurred, exception is
--   logged.
closeStatsLogger :: (MonadIO m, EnabledLogTypes impl) => EngineLogType impl -> Logger impl -> Trigger stats stats -> m ()

-- | This won't log the given stats immediately. The stats are accumulated
--   over the specific timeframe and logged only once. See
--   @<a>createStatsLogger</a> for more details.
logStats :: MonadIO m => Trigger stats stats -> stats -> m ()
instance GHC.Classes.Eq Hasura.Logging.FormattedTime
instance GHC.Show.Show Hasura.Logging.FormattedTime
instance GHC.Generics.Generic Hasura.Logging.InternalLogTypes
instance GHC.Classes.Eq Hasura.Logging.InternalLogTypes
instance GHC.Show.Show Hasura.Logging.InternalLogTypes
instance GHC.Generics.Generic (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance GHC.Classes.Eq (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance GHC.Show.Show (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance GHC.Classes.Ord Hasura.Logging.LogLevel
instance GHC.Classes.Eq Hasura.Logging.LogLevel
instance GHC.Show.Show Hasura.Logging.LogLevel
instance GHC.Generics.Generic (Hasura.Logging.EngineLog impl)
instance GHC.Show.Show Hasura.Logging.UnstructuredLog
instance GHC.Classes.Eq Hasura.Logging.LoggerSettings
instance GHC.Show.Show Hasura.Logging.LoggerSettings
instance GHC.Generics.Generic Hasura.Logging.StoredIntrospectionLog
instance GHC.Generics.Generic Hasura.Logging.StoredIntrospectionStorageLog
instance GHC.Show.Show (Hasura.Logging.EngineLogType impl) => GHC.Show.Show (Hasura.Logging.EngineLog impl)
instance GHC.Classes.Eq (Hasura.Logging.EngineLogType impl) => GHC.Classes.Eq (Hasura.Logging.EngineLog impl)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.StoredIntrospectionStorageLog
instance Hasura.Logging.ToEngineLog Hasura.Logging.StoredIntrospectionStorageLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.StoredIntrospectionLog
instance Hasura.Logging.ToEngineLog Hasura.Logging.StoredIntrospectionLog Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Logging.UnhandledInternalErrorLog Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog Hasura.Logging.UnstructuredLog Hasura.Logging.Hasura
instance Hasura.Logging.EnabledLogTypes impl => Hasura.Logging.ToEngineLog (Control.FoldDebounce.OpException, Hasura.Logging.EngineLogType impl) impl
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Logging.EngineLogType impl) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Logging.EngineLog impl)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.LogLevel
instance Data.Hashable.Class.Hashable Hasura.Logging.InternalLogTypes
instance Witch.From.From Hasura.Logging.InternalLogTypes Data.Text.Internal.Text
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.InternalLogTypes
instance Data.Hashable.Class.Hashable (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance Witch.From.From (Hasura.Logging.EngineLogType Hasura.Logging.Hasura) Data.Text.Internal.Text
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.Logging.EngineLogType Hasura.Logging.Hasura)
instance Hasura.Logging.EnabledLogTypes Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Logging.FormattedTime

module Hasura.Server.Auth.JWT.Logging

-- | Possible errors during fetching and parsing JWK (the <a>Text</a> type
--   at the end is a friendly error message)
data JwkFetchError

-- | Exception while making the HTTP request
JFEHttpException :: !HttpException -> !Text -> JwkFetchError

-- | Non-2xx HTTP errors from the upstream server
JFEHttpError :: !URI -> !Status -> !ByteString -> !Text -> JwkFetchError

-- | Error parsing the JWK response itself
JFEJwkParseError :: !Text -> !Text -> JwkFetchError

-- | Error parsing the expiry of the JWK
JFEExpiryParseError :: !Maybe Text -> Text -> JwkFetchError
data JwkRefreshLog
JwkRefreshLog :: !LogLevel -> !Maybe Text -> !Maybe JwkFetchError -> JwkRefreshLog
[jrlLogLevel] :: JwkRefreshLog -> !LogLevel
[jrlMessage] :: JwkRefreshLog -> !Maybe Text
[jrlError] :: JwkRefreshLog -> !Maybe JwkFetchError
instance GHC.Show.Show Hasura.Server.Auth.JWT.Logging.JwkFetchError
instance GHC.Show.Show Hasura.Server.Auth.JWT.Logging.JwkRefreshLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.Logging.JwkRefreshLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Auth.JWT.Logging.JwkRefreshLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.Logging.JwkFetchError


-- | This module implements the bulk of Hasura's JWT capabilities and
--   interactions. Its main point of non-testing invocation is <a>Auth</a>.
--   
--   It exports both <a>processJwt</a> and <a>processJwt_</a> with
--   <a>processJwt_</a> being the majority of the implementation with the
--   JWT Token processing function passed in as an argument in order to
--   enable mocking in test-code.
--   
--   In <a>processJwt_</a>, prior to validation of the token, first the
--   token locations and issuers are reconciled. Locations are either
--   specified as auth or cookie (with cookie name) or assumed to be auth.
--   Issuers can be omitted or specified, where an omitted configured
--   issuer can match any issuer specified by a request.
--   
--   If none match, then this is considered an no-auth request, if one
--   matches, then normal token auth is performed, and if multiple match,
--   then this is considered an ambiguity error.
module Hasura.Server.Auth.JWT
data RawJWT
data JWTClaimsFormat
JCFJson :: JWTClaimsFormat
JCFStringifiedJson :: JWTClaimsFormat
data JWTHeader
JHAuthorization :: JWTHeader
JHCookie :: Text -> JWTHeader
JHCustomHeader :: Text -> JWTHeader
defaultClaimsFormat :: JWTClaimsFormat
allowedRolesClaim :: SessionVariable
defaultRoleClaim :: SessionVariable
defaultClaimsNamespace :: Text

-- | <a>JWTCustomClaimsMapValueG</a> is used to represent a single value of
--   the <a>JWTCustomClaimsMap</a>. A <a>JWTCustomClaimsMapValueG</a> can
--   either be an JSON object or the literal value of the claim. If the
--   value is an JSON object, then it should contain a key <tt>path</tt>,
--   which is the JSON path to the claim value in the JWT token. There's
--   also an option to specify a default value in the map via the 'default'
--   key, which will be used when a peek at the JWT token using the JSON
--   path fails (key does not exist).
data JWTCustomClaimsMapValueG v

-- | JSONPath to the key in the claims map, in case the key doesn't exist
--   in the claims map then the default value will be used (if provided)
JWTCustomClaimsMapJSONPath :: !JSONPath -> !Maybe v -> JWTCustomClaimsMapValueG v
JWTCustomClaimsMapStatic :: !v -> JWTCustomClaimsMapValueG v
type JWTCustomClaimsMapDefaultRole = JWTCustomClaimsMapValueG RoleName
type JWTCustomClaimsMapAllowedRoles = JWTCustomClaimsMapValueG [RoleName]
type JWTCustomClaimsMapValue = JWTCustomClaimsMapValueG SessionVariableValue

-- | JWTClaimsMap is an option to provide a custom JWT claims map. The
--   JWTClaimsMap should be specified in the
--   <tt>HASURA_GRAPHQL_JWT_SECRET</tt> in the <tt>claims_map</tt>. The
--   JWTClaimsMap, if specified, requires two mandatory fields, namely,
--   `x-hasura-allowed-roles` and the `x-hasura-default-role`, other claims
--   may also be provided in the claims map.
data JWTCustomClaimsMap
JWTCustomClaimsMap :: !JWTCustomClaimsMapDefaultRole -> !JWTCustomClaimsMapAllowedRoles -> !CustomClaimsMap -> JWTCustomClaimsMap
[jcmDefaultRole] :: JWTCustomClaimsMap -> !JWTCustomClaimsMapDefaultRole
[jcmAllowedRoles] :: JWTCustomClaimsMap -> !JWTCustomClaimsMapAllowedRoles
[jcmCustomClaims] :: JWTCustomClaimsMap -> !CustomClaimsMap

-- | JWTNamespace is used to locate the claims map within the JWT token.
--   The location can be either provided via a JSON path or the name of the
--   key in the JWT token.
data JWTNamespace
ClaimNsPath :: JSONPath -> JWTNamespace
ClaimNs :: Text -> JWTNamespace
data JWTClaims
JCNamespace :: !JWTNamespace -> !JWTClaimsFormat -> JWTClaims
JCMap :: !JWTCustomClaimsMap -> JWTClaims

-- | Hashable Wrapper for constructing a HashMap of JWTConfigs
newtype StringOrURI
StringOrURI :: StringOrURI -> StringOrURI
[unStringOrURI] :: StringOrURI -> StringOrURI

-- | The JWT configuration we got from the user.
data JWTConfig
JWTConfig :: !Either JWK URI -> !Maybe Audience -> !Maybe StringOrURI -> !JWTClaims -> !Maybe NominalDiffTime -> !Maybe JWTHeader -> JWTConfig
[jcKeyOrUrl] :: JWTConfig -> !Either JWK URI
[jcAudience] :: JWTConfig -> !Maybe Audience
[jcIssuer] :: JWTConfig -> !Maybe StringOrURI
[jcClaims] :: JWTConfig -> !JWTClaims
[jcAllowedSkew] :: JWTConfig -> !Maybe NominalDiffTime
[jcHeader] :: JWTConfig -> !Maybe JWTHeader

-- | The validated runtime JWT configuration returned by <tt>mkJwtCtx</tt>
--   in <tt>setupAuthMode</tt>.
data JWTCtx
JWTCtx :: !Maybe URI -> !IORef (JWKSet, Maybe UTCTime) -> !Maybe Audience -> !Maybe StringOrURI -> !JWTClaims -> !Maybe NominalDiffTime -> !JWTHeader -> JWTCtx
[jcxUrl] :: JWTCtx -> !Maybe URI

-- | This needs to be a mutable variable for <a>fetchJwk</a>. | We add the
--   expiry time of the JWK to the IORef, to determine | if the JWK has
--   expired and needs to be refreshed.
[jcxKeyConfig] :: JWTCtx -> !IORef (JWKSet, Maybe UTCTime)
[jcxAudience] :: JWTCtx -> !Maybe Audience
[jcxIssuer] :: JWTCtx -> !Maybe StringOrURI
[jcxClaims] :: JWTCtx -> !JWTClaims
[jcxAllowedSkew] :: JWTCtx -> !Maybe NominalDiffTime
[jcxHeader] :: JWTCtx -> !JWTHeader

-- | An action that fetches the JWKs and updates the expiry time and JWKs
--   in the IORef
fetchAndUpdateJWKs :: (MonadIO m, MonadBaseControl IO m) => Logger Hasura -> Manager -> URI -> IORef (JWKSet, Maybe UTCTime) -> m ()

-- | Given a JWK url, fetch JWK from it
fetchJwk :: (MonadIO m, MonadBaseControl IO m, MonadError JwkFetchError m) => Logger Hasura -> Manager -> URI -> m (JWKSet, ResponseHeaders)

-- | First check for Cache-Control header, if not found, look for Expires
--   header
determineJwkExpiryLifetime :: forall m. (MonadIO m, MonadError JwkFetchError m) => m UTCTime -> Logger Hasura -> ResponseHeaders -> m (Maybe UTCTime)
type ClaimsMap = HashMap SessionVariable Value

-- | Extract the issuer from a bearer tokena _without_ verifying it.
tokenIssuer :: RawJWT -> Maybe StringOrURI

-- | Process the request headers to verify the JWT and extract UserInfo
--   from it From the JWT config, we check which header to expect, it can
--   be the <a>Authorization</a> or <a>Cookie</a> header
--   
--   If no <a>Authorization</a>/<a>Cookie</a> header was passed, we will
--   fall back to the unauthenticated user role [1], if one was configured
--   at server start.
--   
--   When no 'x-hasura-user-role' is specified in the request, the
--   mandatory 'x-hasura-default-role' [2] from the JWT claims will be
--   used.
processJwt :: (MonadIO m, MonadError QErr m) => [JWTCtx] -> RequestHeaders -> Maybe RoleName -> m (UserInfo, Maybe UTCTime, [Header], Maybe JWTCtx)
processJwt_ :: MonadError QErr m => (JWTCtx -> ByteString -> m (ClaimsMap, Maybe UTCTime)) -> (RawJWT -> Maybe StringOrURI) -> (JWTCtx -> JWTHeader) -> [JWTCtx] -> RequestHeaders -> Maybe RoleName -> m (UserInfo, Maybe UTCTime, [Header], Maybe JWTCtx)

-- | parse the claims map from the JWT token or custom claims from the JWT
--   config
parseClaimsMap :: MonadError QErr m => ClaimsSet -> JWTClaims -> m ClaimsMap
instance GHC.Generics.Generic Hasura.Server.Auth.JWT.JWTClaimsFormat
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTClaimsFormat
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTClaimsFormat
instance GHC.Generics.Generic Hasura.Server.Auth.JWT.JWTHeader
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTHeader
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTHeader
instance Data.Traversable.Traversable Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG
instance Data.Foldable.Foldable Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG
instance GHC.Base.Functor Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG
instance GHC.Classes.Eq v => GHC.Classes.Eq (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance GHC.Show.Show v => GHC.Show.Show (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTNamespace
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTNamespace
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTClaims
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTClaims
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.StringOrURI
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.StringOrURI
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.StringOrURI
instance GHC.Show.Show Hasura.Server.Auth.JWT.StringOrURI
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTConfig
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTConfig
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.JWTCtx
instance GHC.Generics.Generic Hasura.Server.Auth.JWT.HasuraClaims
instance GHC.Classes.Eq Hasura.Server.Auth.JWT.HasuraClaims
instance GHC.Show.Show Hasura.Server.Auth.JWT.HasuraClaims
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.HasuraClaims
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.HasuraClaims
instance GHC.Show.Show Hasura.Server.Auth.JWT.JWTCtx
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTConfig
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Server.Auth.JWT.StringOrURI
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.Server.Auth.JWT.StringOrURI
instance Data.Aeson.Types.ToJSON.ToJSONKey (GHC.Maybe.Maybe Hasura.Server.Auth.JWT.StringOrURI)
instance Data.Aeson.Types.FromJSON.FromJSONKey (GHC.Maybe.Maybe Hasura.Server.Auth.JWT.StringOrURI)
instance Data.Hashable.Class.Hashable Hasura.Server.Auth.JWT.StringOrURI
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTNamespace
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTCustomClaimsMap
instance Data.Aeson.Types.FromJSON.FromJSON v => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance Data.Aeson.Types.ToJSON.ToJSON v => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Server.Auth.JWT.JWTCustomClaimsMapValueG v)
instance Data.Hashable.Class.Hashable Hasura.Server.Auth.JWT.JWTHeader
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTHeader
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTHeader
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Auth.JWT.JWTClaimsFormat
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Auth.JWT.JWTClaimsFormat

module Control.Concurrent.Extended

-- | Like <a>threadDelay</a>, but takes a <a>DiffTime</a> instead of an
--   <a>Int</a> microseconds.
--   
--   NOTE: you cannot simply replace e.g. <tt>threadDelay 1000</tt> with
--   <tt>sleep 1000</tt> since those literals have different meanings!
sleep :: DiffTime -> IO ()

-- | Note: Please consider using <a>forkManagedT</a> instead to ensure
--   reliable resource cleanup.
forkImmortal :: ForkableMonadIO m => String -> Logger Hasura -> m Void -> m Thread
data ThreadState
ThreadForked :: ThreadState
ThreadBlocking :: ThreadState
ThreadShutdownInitiated :: ThreadState

-- | <tt>ThreadShutdown</tt> is a newtype wrapper over an action which is
--   intended to execute when a thread's shutdown is initiated before
--   killing the thread
newtype ThreadShutdown m
ThreadShutdown :: m () -> ThreadShutdown m
[tsThreadShutdown] :: ThreadShutdown m -> m ()

-- | This function pairs a call to <a>forkImmortal</a> with a finalizer
--   which stops the immortal thread.
forkManagedT :: ForkableMonadIO m => String -> Logger Hasura -> m Void -> ManagedT m Thread

-- | The <tt>Forever</tt> type defines an infinite looping monadic action
--   (like <tt>m void</tt>), but allows the caller to control the recursion
--   or insert code before each iteration. The <tt>a</tt> is the initial
--   argument, and subsequent iterations will be fed the argument returned
--   by the previous one. See <tt>forkManagedTWithGracefulShutdown</tt> to
--   see how it's used
data Forever m
Forever :: a -> (a -> m a) -> Forever m

-- | <tt>forkManagedTWithGracefulShutdown</tt> is an extension of the
--   <tt>forkManagedT</tt> function this function also attempts to
--   gracefully shutdown the thread. This function accepts a `m (Forever
--   m)` argument. The <tt>Forever</tt> type contains a function and an
--   argument to the function. The function supplied will be run repeatedly
--   until shutdown is initiated. The response of the function will be the
--   argument to the next iteration.
--   
--   For reference, this function is used to run the async actions
--   processor. Check <tt>asyncActionsProcessor</tt>
forkManagedTWithGracefulShutdown :: ForkableMonadIO m => String -> Logger Hasura -> ThreadShutdown m -> m (Forever m) -> ManagedT m Thread
data ImmortalThreadLog

-- | Synchronous Exception
ImmortalThreadUnexpectedException :: String -> SomeException -> ImmortalThreadLog

-- | Asynchronous Exception about to be sent
ImmortalThreadStopping :: String -> ImmortalThreadLog
ImmortalThreadRestarted :: String -> ImmortalThreadLog

-- | Like <a>MonadIO</a> but constrained to stacks in which forking a new
--   thread is reasonable/safe. In particular <a>StateT</a> causes
--   problems.
--   
--   This is the constraint you can use for functions that call
--   <a>async</a>, or <tt>immortal</tt>.
type ForkableMonadIO m = (MonadIO m, MonadBaseControl IO m, Forall (Pure m))

-- | A somewhat wonky function for parallelizing <tt>for xs f</tt> where
--   <tt>f</tt> is <tt>(MonadIO m, MonadError e m)</tt>. This is equivalent
--   to <tt>for xs f</tt> modulo the IO effects (i.e. when the IO has no
--   real side effects we care about).
--   
--   This also takes a <tt>chunkSize</tt> argument so you can manipulate
--   the amount of work given to each thread.
forConcurrentlyEIO :: (MonadIO m, MonadError e m) => Int -> [a] -> (a -> ExceptT e IO b) -> m [b]
concurrentlyEIO :: (MonadIO m, MonadError e m) => ExceptT e IO a -> ExceptT e IO b -> m (a, b)
instance GHC.Classes.Eq Control.Concurrent.Extended.ThreadState
instance GHC.Show.Show Control.Concurrent.Extended.ThreadState
instance Hasura.Logging.ToEngineLog Control.Concurrent.Extended.ImmortalThreadLog Hasura.Logging.Hasura

module Hasura.ShutdownLatch

-- | A latch for the graceful shutdown of a server process.
data ShutdownLatch
newShutdownLatch :: IO ShutdownLatch

-- | Block the current thread, waiting on the latch.
waitForShutdown :: ShutdownLatch -> IO ()

-- | Initiate a graceful shutdown of the server associated with the
--   provided latch.
shutdownGracefully :: ShutdownLatch -> IO ()

-- | Returns True if the latch is set for shutdown and vice-versa
shuttingDown :: ShutdownLatch -> IO Bool

module Hasura.Server.CheckUpdates
checkForUpdates :: LoggerCtx a -> Manager -> IO void
instance GHC.Generics.Generic Hasura.Server.CheckUpdates.UpdateInfo
instance GHC.Show.Show Hasura.Server.CheckUpdates.UpdateInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.CheckUpdates.UpdateInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.CheckUpdates.UpdateInfo


-- | This file contains types for both the websocket protocols (Apollo) and
--   (graphql-ws) | See Apollo:
--   <a>https://github.com/apollographql/subscriptions-transport-ws/blob/master/PROTOCOL.md</a>
--   | See graphql-ws:
--   <a>https://github.com/enisdenjo/graphql-ws/blob/master/PROTOCOL.md</a>
module Hasura.GraphQL.Transport.WebSocket.Protocol
data WSSubProtocol
Apollo :: WSSubProtocol
GraphQLWS :: WSSubProtocol
showSubProtocol :: WSSubProtocol -> String
toWSSubProtocol :: String -> WSSubProtocol
data OperationId
unsafeMkOperationId :: Text -> OperationId
data ServerMsgType
SMT_GQL_CONNECTION_KEEP_ALIVE :: ServerMsgType
SMT_GQL_CONNECTION_ERROR :: ServerMsgType
SMT_GQL_DATA :: ServerMsgType
SMT_GQL_NEXT :: ServerMsgType
SMT_GQL_PING :: ServerMsgType
SMT_GQL_PONG :: ServerMsgType
SMT_GQL_CONNECTION_ACK :: ServerMsgType
SMT_GQL_ERROR :: ServerMsgType
SMT_GQL_COMPLETE :: ServerMsgType
data ConnParams
data StartMsg
StartMsg :: !OperationId -> !GQLReqUnparsed -> StartMsg
data StopMsg
StopMsg :: OperationId -> StopMsg
data PingPongPayload
keepAliveMessage :: PingPongPayload
data ClientMsg
CMConnInit :: !Maybe ConnParams -> ClientMsg
CMStart :: !StartMsg -> ClientMsg
CMStop :: !StopMsg -> ClientMsg
CMConnTerm :: ClientMsg
CMPing :: !Maybe PingPongPayload -> ClientMsg
CMPong :: !Maybe PingPongPayload -> ClientMsg
data DataMsg
DataMsg :: !OperationId -> !GQResponse -> DataMsg
data ErrorMsg
ErrorMsg :: !OperationId -> !Encoding -> ErrorMsg
newtype CompletionMsg
CompletionMsg :: OperationId -> CompletionMsg
newtype ConnErrMsg
ConnErrMsg :: Text -> ConnErrMsg
[unConnErrMsg] :: ConnErrMsg -> Text
data ServerMsg
SMConnAck :: ServerMsg
SMConnKeepAlive :: ServerMsg
SMConnErr :: !ConnErrMsg -> ServerMsg
SMData :: !DataMsg -> ServerMsg
SMErr :: !ErrorMsg -> ServerMsg
SMComplete :: !CompletionMsg -> ServerMsg
SMNext :: !DataMsg -> ServerMsg
SMPing :: !Maybe PingPongPayload -> ServerMsg
SMPong :: !Maybe PingPongPayload -> ServerMsg

-- | This is sent from the server to the client while closing the websocket
--   on encountering an error.
data ServerErrorCode
ProtocolError1002 :: ServerErrorCode
GenericError4400 :: !String -> ServerErrorCode
Unauthorized4401 :: ServerErrorCode
Forbidden4403 :: ServerErrorCode
ConnectionInitTimeout4408 :: ServerErrorCode
NonUniqueSubscription4409 :: !OperationId -> ServerErrorCode
TooManyRequests4429 :: ServerErrorCode
encodeServerErrorMsg :: ServerErrorCode -> ByteString
encodeServerMsg :: ServerMsg -> ByteString
data WSConnInitTimerStatus
Done :: WSConnInitTimerStatus
getWSTimerState :: WSConnInitTimer -> IO WSConnInitTimerStatus
getNewWSTimer :: Seconds -> IO WSConnInitTimer
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.WSSubProtocol
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.WSSubProtocol
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance Data.String.IsString Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.OperationId
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ServerMsgType
instance GHC.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance GHC.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance GHC.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance GHC.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance GHC.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ClientMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ClientMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ErrorMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ErrorMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance Data.String.IsString Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ConnErrMsg
instance GHC.Generics.Generic Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorCode
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Protocol.WSConnInitTimerStatus
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.WSConnInitTimerStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ServerErrorMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.CompletionMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ClientMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.SubscribeMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.PingPongPayload
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StopMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.StartMsg
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ConnParams
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Protocol.ServerMsgType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Protocol.ServerMsgType

module Hasura.GC

-- | The RTS's idle GC doesn't work for us:
--   
--   <ul>
--   <li>when `-I` is too low it may fire continuously causing scary high
--   CPU when idle among other issues (see #2565)</li>
--   <li>when we set it higher it won't run at all leading to memory being
--   retained when idle (especially noticeable when users are benchmarking
--   and see memory stay high after finishing). In the theoretical worst
--   case there is such low haskell heap pressure that we never run
--   finalizers to free the foreign data from e.g. libpq.</li>
--   <li>as of GHC 8.10.2 we have access to `-Iw`, but those two knobs
--   still donâ€™t give us a guarantee that a major GC will always run at
--   some minumum frequency (e.g. for finalizers)</li>
--   </ul>
--   
--   ...so we hack together our own using GHC.Stats, which should have
--   insignificant runtime overhead.
--   
--   NOTE: as always the cost of a major GC (forced here, or initiated by
--   the RTS) with the default copying collector is proportional to live
--   (non-garbage) heap data. Tune parameters here to balance: more
--   frequent GC pauses vs. prompt cleanup of foreign data (which does not
--   exert GC pressure).
--   
--   NOTE: larger nursery size (+RTS -A) may help us run more finalizers
--   during cheaper minor GCs, before they are promoted, making it feasible
--   (maybe) to run this with longer interval parameters.
ourIdleGC :: Logger Hasura -> DiffTime -> DiffTime -> DiffTime -> IO void


-- | Execute a Select query against the BigQuery REST API.
module Hasura.Backends.BigQuery.Execute

-- | A set of records produced by the database. These are joined together.
--   There are all sorts of optimizations possible here, from using a
--   matrix/flat vector, unboxed sums for Value, etc. Presently we choose a
--   naive implementation in the interest of getting other work done.
data RecordSet
RecordSet :: Vector (InsOrdHashMap FieldNameText OutputValue) -> Maybe [Text] -> RecordSet
[$sel:rows:RecordSet] :: RecordSet -> Vector (InsOrdHashMap FieldNameText OutputValue)
[$sel:wantedFields:RecordSet] :: RecordSet -> Maybe [Text]

-- | As opposed to BigQuery.FieldName which is a qualified name, this is
--   just the unqualified text name itself.
newtype FieldNameText
FieldNameText :: Text -> FieldNameText
data OutputValue
DecimalOutputValue :: Decimal -> OutputValue
BigDecimalOutputValue :: BigDecimal -> OutputValue
IntegerOutputValue :: Int64 -> OutputValue
FloatOutputValue :: Float64 -> OutputValue
GeographyOutputValue :: Geography -> OutputValue
TextOutputValue :: Text -> OutputValue
TimestampOutputValue :: Timestamp -> OutputValue
DateOutputValue :: Date -> OutputValue
TimeOutputValue :: Time -> OutputValue
DatetimeOutputValue :: Datetime -> OutputValue
BytesOutputValue :: Base64 -> OutputValue
BoolOutputValue :: Bool -> OutputValue
ArrayOutputValue :: Vector OutputValue -> OutputValue
RecordOutputValue :: InsOrdHashMap FieldNameText OutputValue -> OutputValue
JsonOutputValue :: Value -> OutputValue
NullOutputValue :: OutputValue
data ExecuteProblem
GetJobDecodeProblem :: String -> ExecuteProblem
CreateQueryJobDecodeProblem :: String -> ExecuteProblem
InsertDatasetDecodeProblem :: String -> ExecuteProblem
ExecuteRunBigQueryProblem :: BigQueryProblem -> ExecuteProblem
RESTRequestNonOK :: Status -> Value -> ExecuteProblem

-- | We use this to hide certain details from the front-end, while allowing
--   them in tests. We have not actually decided whether showing the
--   details is insecure, but until we decide otherwise, it's probably best
--   to err on the side of caution.
data ShowDetails
HideDetails :: ShowDetails
InsecurelyShowDetails :: ShowDetails
executeProblemMessage :: ShowDetails -> ExecuteProblem -> Text

-- | Execute monad; as queries are performed, the record sets are stored in
--   the map.
data Execute a
data BigQuery
BigQuery :: Text -> InsOrdHashMap ParameterName Parameter -> BigQuery
[$sel:query:BigQuery] :: BigQuery -> Text
[$sel:parameters:BigQuery] :: BigQuery -> InsOrdHashMap ParameterName Parameter
runExecute :: MonadIO m => BigQuerySourceConfig -> Execute (Job, RecordSet) -> m (Either ExecuteProblem (Job, RecordSet))
executeSelect :: Select -> Execute (Job, RecordSet)

-- | TODO: WARNING: This function hasn't been tested on Big Data(tm), and
--   therefore I was unable to get BigQuery to produce paginated results
--   that would contain the <a>JobResults</a> field in the JSON response.
--   Until that test has been done, we should consider this a preliminary
--   implementation.
streamBigQuery :: MonadIO m => BigQueryConnection -> BigQuery -> m (Either ExecuteProblem (Job, RecordSet))

-- | Execute a query without expecting any output (e.g. CREATE TABLE or
--   INSERT)
executeBigQuery :: MonadIO m => BigQueryConnection -> BigQuery -> m (Either ExecuteProblem ())

-- | Delete a dataset
deleteDataset :: (MonadError ExecuteProblem m, MonadIO m) => BigQueryConnection -> Text -> m ()

-- | Insert a new dataset
insertDataset :: (MonadError ExecuteProblem m, MonadIO m) => BigQueryConnection -> Text -> m Dataset
instance Data.String.IsString Hasura.Backends.BigQuery.Execute.FieldNameText
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.Backends.BigQuery.Execute.FieldNameText
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.FieldNameText
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Execute.FieldNameText
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Execute.FieldNameText
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Execute.FieldNameText
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.FieldNameText
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Execute.OutputValue
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Execute.OutputValue
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.OutputValue
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.RecordSet
instance GHC.Generics.Generic Hasura.Backends.BigQuery.Execute.ExecuteProblem
instance Control.Monad.Error.Class.MonadError Hasura.Backends.BigQuery.Execute.ExecuteProblem Hasura.Backends.BigQuery.Execute.Execute
instance Control.Monad.IO.Class.MonadIO Hasura.Backends.BigQuery.Execute.Execute
instance Control.Monad.Reader.Class.MonadReader Hasura.Backends.BigQuery.Execute.ExecuteReader Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Base.Monad Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Base.Applicative Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Base.Functor Hasura.Backends.BigQuery.Execute.Execute
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.Parameter
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Execute.ParameterName
instance GHC.Classes.Eq Hasura.Backends.BigQuery.Execute.ParameterName
instance GHC.Classes.Ord Hasura.Backends.BigQuery.Execute.ParameterName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Execute.ParameterName
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.ParameterName
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.BigQuery
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.Mode
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.BigQueryFieldType
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.BigQueryField
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.JobResults
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.JobResultsResponse
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.Fetch
instance GHC.Show.Show Hasura.Backends.BigQuery.Execute.Dataset
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.Dataset
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.JobResultsResponse
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.JobResults
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.BigQueryField
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.Execute.Mode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Execute.ExecuteProblem
instance Data.Hashable.Class.Hashable Hasura.Backends.BigQuery.Execute.OutputValue
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.Execute.OutputValue


-- | This module contains a collection of utility functions we use with
--   tracing throughout the codebase, but that are not a core part of the
--   library. If we were to move tracing to a separate library, those
--   functions should be kept here in the core engine code.
module Hasura.Tracing.Utils

-- | Wrap the execution of an HTTP request in a span in the current trace.
--   Despite its name, this function does not start a new trace, and the
--   span will therefore not be recorded if the surrounding context isn't
--   traced (see <tt>spanWith</tt>).
--   
--   Additionally, this function adds metadata regarding the request to the
--   created span, and injects the trace context into the HTTP header.
traceHTTPRequest :: (MonadIO m, MonadTrace m) => Request -> (Request -> m a) -> m a
attachSourceConfigAttributes :: forall b m. (HasSourceConfiguration b, MonadTrace m) => SourceConfig b -> m ()

module Hasura.Tracing


-- | Network service provider.
--   
--   This module defines a Service (see Note [Services]) that provides
--   access to the network; for now, that only means providing a HTTP
--   Manager. This is consequentlt a simple analogue to `(MonadReader r m,
--   Has Manager r)`, but could be updated to either encompass other
--   network utilities, or to provide a more restricted interface if deemed
--   useful. Alternatively this could be removed altogether if all network
--   calls were to be hidden behind more specific services.
module Hasura.Services.Network
class (Monad m) => ProvidesNetwork m
askHTTPManager :: ProvidesNetwork m => m Manager
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Control.Monad.Trans.Reader.ReaderT r m)
instance (GHC.Base.Monoid w, Hasura.Services.Network.ProvidesNetwork m) => Hasura.Services.Network.ProvidesNetwork (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Hasura.Tracing.Monad.TraceT m)

module Hasura.Services

-- | A constraint alias that groups all services together.
type ProvidesHasuraServices m = (ProvidesNetwork m)

module Hasura.Server.Limits

-- | Resource limits, represented by a function which modifies IO actions
--   to enforce those limits by throwing errors using <a>MonadError</a> in
--   the case where they are exceeded.
data ResourceLimits
ResourceLimits :: (forall m a. (MonadBaseControl IO m, MonadError QErr m) => m a -> m a) -> ResourceLimits
[runResourceLimits] :: ResourceLimits -> forall m a. (MonadBaseControl IO m, MonadError QErr m) => m a -> m a

-- | Monads which support resource (memory, CPU time, etc.) limiting
class (Monad m) => HasResourceLimits m
askHTTPHandlerLimit :: HasResourceLimits m => m ResourceLimits
askGraphqlOperationLimit :: HasResourceLimits m => RequestId -> UserInfo -> ApiLimit -> m ResourceLimits
askHTTPHandlerLimit :: (HasResourceLimits m, m ~ t n, MonadTrans t, HasResourceLimits n) => m ResourceLimits
askGraphqlOperationLimit :: (HasResourceLimits m, m ~ t n, MonadTrans t, HasResourceLimits n) => RequestId -> UserInfo -> ApiLimit -> m ResourceLimits
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Hasura.Tracing.Monad.TraceT m)


-- | <h1>Hasura.Eventing.HTTP</h1>
--   
--   This module is an utility module providing HTTP utilities for
--   <a>Hasura.Eventing.EventTriggers</a> and
--   <a>Hasura.Eventing.ScheduledTriggers</a>.
--   
--   The event triggers and scheduled triggers share the event delivery
--   mechanism using the <tt>tryWebhook</tt> function defined in this
--   module.
module Hasura.Eventing.HTTP
data ExtraLogContext
ExtraLogContext :: !EventId -> !Maybe TriggerName -> ExtraLogContext
[elEventId] :: ExtraLogContext -> !EventId
[elEventName] :: ExtraLogContext -> !Maybe TriggerName
data HTTPResp (a :: TriggerTypes)
HTTPResp :: !Int -> ![HeaderConf] -> !SerializableBlob -> !Int64 -> HTTPResp (a :: TriggerTypes)
[hrsStatus] :: HTTPResp (a :: TriggerTypes) -> !Int
[hrsHeaders] :: HTTPResp (a :: TriggerTypes) -> ![HeaderConf]
[hrsBody] :: HTTPResp (a :: TriggerTypes) -> !SerializableBlob
[hrsSize] :: HTTPResp (a :: TriggerTypes) -> !Int64
data HTTPErr (a :: TriggerTypes)
HClient :: !HttpException -> HTTPErr (a :: TriggerTypes)
HStatus :: !HTTPResp a -> HTTPErr (a :: TriggerTypes)
HOther :: !String -> HTTPErr (a :: TriggerTypes)
httpExceptionErrorEncoding :: HttpException -> ByteString
data RequestDetails
RequestDetails :: Request -> Int64 -> Maybe Request -> Maybe Int64 -> Maybe RequestContext -> Maybe SessionVariables -> RequestDetails
[_rdOriginalRequest] :: RequestDetails -> Request
[_rdOriginalSize] :: RequestDetails -> Int64
[_rdTransformedRequest] :: RequestDetails -> Maybe Request
[_rdTransformedSize] :: RequestDetails -> Maybe Int64
[_rdReqTransformCtx] :: RequestDetails -> Maybe RequestContext
[_rdSessionVars] :: RequestDetails -> Maybe SessionVariables
extractRequest :: RequestDetails -> Request
isNetworkError :: HTTPErr a -> Bool
isNetworkErrorHC :: HttpException -> Bool
logHTTPForET :: (MonadReader r m, Has (Logger Hasura) r, MonadIO m) => Either (HTTPErr 'EventType) (HTTPResp 'EventType) -> ExtraLogContext -> RequestDetails -> Text -> [HeaderConf] -> TriggersErrorLogLevelStatus -> m ()
logHTTPForST :: (MonadReader r m, Has (Logger Hasura) r, MonadIO m) => Either (HTTPErr 'ScheduledType) (HTTPResp 'ScheduledType) -> ExtraLogContext -> RequestDetails -> Text -> [HeaderConf] -> TriggersErrorLogLevelStatus -> m ()
runHTTP :: MonadIO m => Manager -> Request -> m (Either (HTTPErr a) (HTTPResp a))
data TransformableRequestError a
HTTPError :: Value -> HTTPErr a -> TransformableRequestError a
TransformationError :: Value -> TransformErrorBundle -> TransformableRequestError a
mkRequest :: MonadError (TransformableRequestError a) m => [Header] -> ResponseTimeout -> ByteString -> Maybe RequestTransform -> ResolvedWebhook -> m RequestDetails
invokeRequest :: (MonadReader r m, MonadError (TransformableRequestError a) m, Has Manager r, Has (Logger Hasura) r, MonadIO m, MonadTrace m) => RequestDetails -> Maybe ResponseTransform -> Maybe SessionVariables -> (Either (HTTPErr a) (HTTPResp a) -> RequestDetails -> m ()) -> m (HTTPResp a)
mkResp :: Int -> SerializableBlob -> [HeaderConf] -> Response a
mkClientErr :: SerializableBlob -> Response a
mkWebhookReq :: Value -> [HeaderConf] -> InvocationVersion -> WebhookRequest
mkInvocationResp :: Maybe Int -> SerializableBlob -> [HeaderConf] -> Response a
isClientError :: Int -> Bool

-- | Encodes given request headers along with our <a>defaultHeaders</a> and
--   returns them along with the re-decoded set of headers (for logging
--   purposes).
prepareHeaders :: [EventHeaderInfo] -> ([Header], [HeaderConf])
getRetryAfterHeaderFromHTTPErr :: HTTPErr a -> Maybe Text
getRetryAfterHeaderFromResp :: HTTPResp a -> Maybe Text
parseRetryHeaderValue :: Text -> Maybe Int
instance GHC.Classes.Eq Hasura.Eventing.HTTP.ExtraLogContext
instance GHC.Show.Show Hasura.Eventing.HTTP.ExtraLogContext
instance GHC.Show.Show (Hasura.Eventing.HTTP.HTTPResp a)
instance GHC.Generics.Generic (Hasura.Eventing.HTTP.HTTPResp a)
instance GHC.Show.Show (Hasura.Eventing.HTTP.HTTPErr a)
instance GHC.Generics.Generic Hasura.Eventing.HTTP.RequestDetails
instance GHC.Classes.Eq Hasura.Eventing.HTTP.HTTPReq
instance GHC.Generics.Generic Hasura.Eventing.HTTP.HTTPReq
instance GHC.Show.Show Hasura.Eventing.HTTP.HTTPReq
instance GHC.Show.Show (Hasura.Eventing.HTTP.TransformableRequestError a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.HTTP.HTTPReq
instance Hasura.Logging.ToEngineLog Hasura.Eventing.HTTP.HTTPReq Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPRespExtraLog 'Hasura.RQL.Types.Eventing.EventType) Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPRespExtraLog 'Hasura.RQL.Types.Eventing.ScheduledType) Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.HTTP.HTTPRespExtra a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.HTTP.RequestDetails
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.HTTP.HTTPErr a)
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPErr 'Hasura.RQL.Types.Eventing.EventType) Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPErr 'Hasura.RQL.Types.Eventing.ScheduledType) Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.HTTP.HTTPResp a)
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPResp 'Hasura.RQL.Types.Eventing.EventType) Hasura.Logging.Hasura
instance Hasura.Logging.ToEngineLog (Hasura.Eventing.HTTP.HTTPResp 'Hasura.RQL.Types.Eventing.ScheduledType) Hasura.Logging.Hasura

module Hasura.Eventing.ScheduledTrigger.Types
newtype ScheduledTriggerInternalErr
ScheduledTriggerInternalErr :: QErr -> ScheduledTriggerInternalErr
data CronTriggerStats
CronTriggerStats :: !TriggerName -> !Int -> !UTCTime -> CronTriggerStats
data FetchedCronTriggerStats
FetchedCronTriggerStats :: [CronTriggerStats] -> Int -> FetchedCronTriggerStats
[_fctsCronTriggers] :: FetchedCronTriggerStats -> [CronTriggerStats]
[_fctsNumFetches] :: FetchedCronTriggerStats -> Int
type FetchedCronTriggerStatsLogger = Trigger FetchedCronTriggerStats FetchedCronTriggerStats
data RetryContext
RetryContext :: !Int -> !STRetryConf -> RetryContext
data ScheduledEventWebhookPayload
ScheduledEventWebhookPayload :: !EventId -> !Maybe TriggerName -> !UTCTime -> !Value -> !Maybe Text -> !Maybe UTCTime -> !Maybe RequestTransform -> !Maybe MetadataResponseTransform -> ScheduledEventWebhookPayload
data ScheduledEventOp
SEOpRetry :: !UTCTime -> ScheduledEventOp
SEOpStatus :: !ScheduledEventStatus -> ScheduledEventOp
newtype CronEventsCount
CronEventsCount :: Int -> CronEventsCount
[unCronEventsCount] :: CronEventsCount -> Int
newtype OneOffScheduledEventsCount
OneOffScheduledEventsCount :: Int -> OneOffScheduledEventsCount
[unOneOffScheduledEventsCount] :: OneOffScheduledEventsCount -> Int

-- | Statistics of scheduled events fetched within a timeframe
data FetchedScheduledEventsStats
FetchedScheduledEventsStats :: CronEventsCount -> OneOffScheduledEventsCount -> Int -> FetchedScheduledEventsStats
[_fsesNumCronEventsFetched] :: FetchedScheduledEventsStats -> CronEventsCount
[_fsesNumOneOffScheduledEventsFetched] :: FetchedScheduledEventsStats -> OneOffScheduledEventsCount
[_fsesNumFetches] :: FetchedScheduledEventsStats -> Int
type FetchedScheduledEventsStatsLogger = Trigger FetchedScheduledEventsStats FetchedScheduledEventsStats
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.ScheduledTriggerInternalErr
instance GHC.Generics.Generic Hasura.Eventing.ScheduledTrigger.Types.CronTriggerStats
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.CronTriggerStats
instance GHC.Generics.Generic Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.RetryContext
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventWebhookPayload
instance GHC.Generics.Generic Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventWebhookPayload
instance GHC.Show.Show Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventWebhookPayload
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventOp
instance GHC.Show.Show Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventOp
instance GHC.Num.Num Hasura.Eventing.ScheduledTrigger.Types.CronEventsCount
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Eventing.ScheduledTrigger.Types.CronEventsCount
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.CronEventsCount
instance GHC.Show.Show Hasura.Eventing.ScheduledTrigger.Types.CronEventsCount
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.CronEventsCount
instance GHC.Num.Num Hasura.Eventing.ScheduledTrigger.Types.OneOffScheduledEventsCount
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Eventing.ScheduledTrigger.Types.OneOffScheduledEventsCount
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.OneOffScheduledEventsCount
instance GHC.Show.Show Hasura.Eventing.ScheduledTrigger.Types.OneOffScheduledEventsCount
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.OneOffScheduledEventsCount
instance GHC.Show.Show Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance GHC.Generics.Generic Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance GHC.Classes.Eq Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance Hasura.Logging.ToEngineLog Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats Hasura.Logging.Hasura
instance GHC.Base.Semigroup Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance GHC.Base.Monoid Hasura.Eventing.ScheduledTrigger.Types.FetchedScheduledEventsStats
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.ScheduledEventWebhookPayload
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats
instance Hasura.Logging.ToEngineLog Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats Hasura.Logging.Hasura
instance GHC.Base.Semigroup Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats
instance GHC.Base.Monoid Hasura.Eventing.ScheduledTrigger.Types.FetchedCronTriggerStats
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.ScheduledTrigger.Types.CronTriggerStats
instance Hasura.Logging.ToEngineLog Hasura.Eventing.ScheduledTrigger.Types.ScheduledTriggerInternalErr Hasura.Logging.Hasura


-- | Postgres Connection MonadTx
--   
--   This module contains <a>MonadTx</a> and related combinators.
--   
--   <a>MonadTx</a>, a class which abstracts the <a>QErr</a> in <a>TxE</a>
--   via <a>MonadError</a>.
--   
--   The combinators are used for running, tracing, or otherwise perform
--   database related tasks. Please consult the individual documentation
--   for more information.
module Hasura.Backends.Postgres.Connection.MonadTx
class (MonadError QErr m) => MonadTx m
liftTx :: MonadTx m => TxE QErr a -> m a
runTxWithCtx :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m, UserInfoM m) => PGExecCtx -> PGExecTxType -> PGExecFrom -> TxET QErr m a -> m a
runTxWithCtxAndUserInfo :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m) => UserInfo -> PGExecCtx -> PGExecTxType -> PGExecFrom -> TxET QErr m a -> m a

-- | This runs the given set of statements (Tx) without wrapping them in
--   BEGIN and COMMIT. This should only be used for running a single
--   statement query!
runQueryTx :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => PGExecCtx -> PGExecFrom -> TxET QErr m a -> m a
setHeadersTx :: MonadIO m => SessionVariables -> TxET QErr m ()
sessionInfoJsonExp :: SessionVariables -> SQLExp
withUserInfo :: MonadIO m => UserInfo -> TxET QErr m a -> TxET QErr m a
setTraceContextInTx :: MonadIO m => Maybe TraceContext -> TxET QErr m ()

-- | Inject the trace context as a transaction-local variable, so that it
--   can be picked up by any triggers (including event triggers).
withTraceContext :: MonadIO m => Maybe TraceContext -> TxET QErr m a -> TxET QErr m a
checkDbConnection :: MonadTx m => m ()
doesSchemaExist :: MonadTx m => SchemaName -> m Bool
doesTableExist :: MonadTx m => SchemaName -> TableName -> m Bool
enablePgcryptoExtension :: forall m. MonadTx m => ExtensionsSchema -> m ()
dropHdbCatalogSchema :: MonadTx m => m ()
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Database.PG.Query.Transaction.TxET e m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Database.PG.Query.Transaction.TxET e m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Trans.Reader.ReaderT s m)
instance (GHC.Base.Monoid w, Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m) => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Control.Monad.Validate.Internal.ValidateT e m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.IO.Class.MonadIO m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)


-- | Postgres Connetion
--   
--   This module re-exports:
--   
--   <ul>
--   <li>MonadTx for abstracting postgres transactions</li>
--   <li>Settings for dealing with connection, pool, and replica
--   settings</li>
--   <li>ET for execution contexts and source configurations</li>
--   </ul>
module Hasura.Backends.Postgres.Connection

module Hasura.LogicalModel.Fields

-- | Class for looking up Logical Models
class (Monad m) => LogicalModelFieldsRM b m
lookupLogicalModelFields :: LogicalModelFieldsRM b m => LogicalModelName -> m (Maybe (LogicalModelFields b))
getLogicalModelFieldsLookup :: LogicalModelFieldsRM b m => m (LogicalModelFieldsLookup b)
newtype LogicalModelFieldsLookupRT b m a
LogicalModelFieldsLookupRT :: (LogicalModelFieldsLookup b -> m a) -> LogicalModelFieldsLookupRT b m a
[runLogicalModelFieldsLookupRT] :: LogicalModelFieldsLookupRT b m a -> LogicalModelFieldsLookup b -> m a
runLogicalModelFieldsLookup :: (x -> LogicalModelFields b) -> HashMap LogicalModelName x -> LogicalModelFieldsLookupRT b m a -> m a
instance Control.Monad.Trans.Class.MonadTrans (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b)
instance Hasura.RQL.Types.Session.UserInfoM m => Hasura.RQL.Types.Session.UserInfoM (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance GHC.Base.Monad m => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Hasura.LogicalModel.Fields.LogicalModelFieldsRM b m => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.LogicalModel.Fields.LogicalModelFieldsRM b m => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Hasura.LogicalModel.Fields.LogicalModelFieldsRM b m) => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.LogicalModel.Fields.LogicalModelFieldsRM b m => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Hasura.Tracing.Monad.TraceT m)


-- | Connect to a postgres db and run queries. This module is meant for
--   simple one-off checks against a postgres database, such as health
--   checks or version checks, and not for normal work.
module Hasura.Backends.Postgres.Connection.Connect

-- | Connect to a postgres database and run a transaction.
withPostgresDB :: Environment -> SourceName -> PostgresConnConfiguration -> TxET QErr IO a -> IO (Either QErr a)

module Hasura.Backends.Postgres.Instances.PingSource
runCockroachDBPing :: Environment -> (String -> IO ()) -> SourceName -> PostgresConnConfiguration -> IO ()


-- | Check version compatability against postgres-like flavors.
module Hasura.Backends.Postgres.Connection.VersionCheck

-- | Cockroach version
data CockroachDbVersion
CockroachDbVersion :: Word -> Word -> Word -> String -> CockroachDbVersion
[crdbMajor] :: CockroachDbVersion -> Word
[crdbMinor] :: CockroachDbVersion -> Word
[crdbPatch] :: CockroachDbVersion -> Word

-- | includes additional information such as "-beta.4"
[crdbRest] :: CockroachDbVersion -> String

-- | Check cockroachdb version compatability.
runCockroachVersionCheck :: Environment -> SourceName -> PostgresConnConfiguration -> IO (Either QErr ())

-- | Check version is &gt;= 22.2.0
--   <a>https://hasura.io/docs/latest/databases/postgres/cockroachdb/index</a>
crdbVersionIsSupported :: CockroachDbVersion -> Bool

-- | Parse a cockroachDB version string
parseCrdbVersion :: Text -> Either ParseError CockroachDbVersion
instance GHC.Show.Show Hasura.Backends.Postgres.Connection.VersionCheck.CockroachDbVersion
instance GHC.Classes.Eq Hasura.Backends.Postgres.Connection.VersionCheck.CockroachDbVersion


-- | Postgres Instances Types
--   
--   Defines a <a>Backend</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.Types
instance Hasura.Backends.Postgres.Instances.Types.PostgresBackend 'Hasura.RQL.Types.BackendType.Vanilla
instance Hasura.Backends.Postgres.Instances.Types.PostgresBackend 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.Instances.Types.PostgresBackend 'Hasura.RQL.Types.BackendType.Cockroach
instance (Hasura.RQL.Types.BackendTag.HasTag ('Hasura.RQL.Types.BackendType.Postgres pgKind), Data.Typeable.Internal.Typeable ('Hasura.RQL.Types.BackendType.Postgres pgKind), Hasura.Backends.Postgres.Instances.Types.PostgresBackend pgKind, Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres pgKind)), Autodocodec.Class.HasCodec (Hasura.RQL.Types.BackendType.BackendSourceKind ('Hasura.RQL.Types.BackendType.Postgres pgKind))) => Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance Hasura.RQL.Types.BackendTag.HasTag ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Hasura.RQL.Types.SourceConfiguration.HasSourceConfiguration ('Hasura.RQL.Types.BackendType.Postgres pgKind)

module Hasura.RQL.Types.Instances

module Hasura.RQL.Types.Relationships.Remote
type RemoteRelationship = RemoteRelationshipG RemoteRelationshipDefinition

-- | Represents the format of the metadata a remote relationship was read
--   from and must be written back as. We don't have a good way of doing
--   metadata versioning yet, and we therefore use this to keep track of
--   the format used.
data RRFormat

-- | The remote relationship was parsed from the old format, that was only
--   used only for db-to-rs schemas.
RRFOldDBToRemoteSchema :: RRFormat

-- | The remote relationship was parsed from the new unified format.
RRFUnifiedFormat :: RRFormat

-- | Specify whether remote schema &lt;&gt; source relationships should be
--   built
data RemoteSourceRelationshipBuilder
IncludeRemoteSourceRelationship :: RemoteSourceRelationshipBuilder
ExcludeRemoteSourceRelationship :: RemoteSourceRelationshipBuilder

-- | Metadata representation of the internal definition of a remote
--   relationship.
data RemoteRelationshipDefinition

-- | Remote relationship targetting a source.
RelationshipToSource :: ToSourceRelationshipDef -> RemoteRelationshipDefinition

-- | Remote relationship targetting a remote schema.
RelationshipToSchema :: RRFormat -> ToSchemaRelationshipDef -> RemoteRelationshipDefinition

-- | Whether to accept legacy fields when parsing
--   <a>RemoteRelationshipDefinition</a>
data RRParseMode

-- | Only allow legacy fields when parsing
--   <a>RemoteRelationshipDefinition</a>
RRPLegacy :: RRParseMode

-- | Allow legacy fields when parsing <a>RemoteRelationshipDefinition</a>
RRPLenient :: RRParseMode

-- | Reject legacy fields when parsing <a>RemoteRelationshipDefinition</a>
RRPStrict :: RRParseMode

-- | Parse <a>RemoteRelationshipDefinition</a> letting the caller decide
--   how lenient to be.
--   
--   This is necessary because <a>RemoteRelationshipDefinition</a> is
--   parsed in different contexts. In <a>RemoteRelationship</a>, the
--   <a>RemoteRelationshipDefinition</a> is always parsed out from a
--   top-level @"definition" field. Thus, a legacy payload looks like this:
--   
--   <pre>
--   {
--     "name": "thing",
--     "definition": {
--       "remote_schema": "stuff",
--       "hasura_fields": ...
--       "remote_field": ...
--     }
--   }
--   </pre>
--   
--   and a new payload looks like this:
--   
--   <pre>
--   {
--     "name": "thing",
--     "definition": {
--       "to_remote_schema": {
--         "schema": "stuff",
--         "lhs_fields": ...
--         "remote_field": ...
--       }
--     }
--   }
--   </pre>
--   
--   In contrast, <tt>CreateFromSourceRelationship</tt> does not have a
--   top- level <tt>"definition"</tt> in its legacy format. Instead, the
--   legacy fields themselves are top-level:
--   
--   <pre>
--   {
--     "remote_schema": "stuff",
--     "hasura_fields": ...
--     "remote_field": ...
--   }
--   </pre>
--   
--   Furthermore, the presence of a <tt>"definition"</tt> field is used to
--   detect that the new payload is being used:
--   
--   <pre>
--   {
--     "definition": {
--       "to_remote_schema": {
--         "schema": "stuff",
--         "lhs_fields": ...
--         "remote_field": ...
--       }
--     }
--   }
--   </pre>
--   
--   In this latter case, we should not allow <tt>"remote_schema"</tt> to
--   appear under <tt>"definition"</tt>.
parseRemoteRelationshipDefinition :: RRParseMode -> Value -> Parser RemoteRelationshipDefinition

-- | Resolved remote relationship, as stored in the schema cache.
data RemoteFieldInfo lhsJoinField
RemoteFieldInfo :: HashMap FieldName lhsJoinField -> RemoteFieldInfoRHS -> RemoteFieldInfo lhsJoinField
[_rfiLHS] :: RemoteFieldInfo lhsJoinField -> HashMap FieldName lhsJoinField
[_rfiRHS] :: RemoteFieldInfo lhsJoinField -> RemoteFieldInfoRHS

-- | Resolved remote relationship's RHS
data RemoteFieldInfoRHS
RFISchema :: RemoteSchemaFieldInfo -> RemoteFieldInfoRHS
RFISource :: AnyBackend RemoteSourceFieldInfo -> RemoteFieldInfoRHS

-- | Information about the field on the LHS of a join against a remote
--   schema.
data DBJoinField (b :: BackendType)
JoinColumn :: Column b -> ColumnType b -> DBJoinField (b :: BackendType)
JoinComputedField :: ScalarComputedField b -> DBJoinField (b :: BackendType)

-- | Information about a computed field appearing on the LHS of a remote
--   join. FIXME: why do we need all of this?
data ScalarComputedField (b :: BackendType)
ScalarComputedField :: XComputedField b -> ComputedFieldName -> FunctionName b -> ComputedFieldImplicitArguments b -> ScalarType b -> ScalarComputedField (b :: BackendType)
[_scfXField] :: ScalarComputedField (b :: BackendType) -> XComputedField b
[_scfName] :: ScalarComputedField (b :: BackendType) -> ComputedFieldName
[_scfFunction] :: ScalarComputedField (b :: BackendType) -> FunctionName b
[_scfComputedFieldImplicitArgs] :: ScalarComputedField (b :: BackendType) -> ComputedFieldImplicitArguments b
[_scfType] :: ScalarComputedField (b :: BackendType) -> ScalarType b
tableNameToLHSIdentifier :: Backend b => TableName b -> LHSIdentifier
_RelationshipToSchema :: Prism' RemoteRelationshipDefinition (RRFormat, ToSchemaRelationshipDef)
_RelationshipToSource :: Prism' RemoteRelationshipDefinition ToSourceRelationshipDef
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RRFormat
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RRFormat
instance GHC.Show.Show Hasura.RQL.Types.Relationships.Remote.RRFormat
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance GHC.Show.Show Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RRParseMode
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RRParseMode
instance GHC.Show.Show Hasura.RQL.Types.Relationships.Remote.RRParseMode
instance GHC.Classes.Eq Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfoRHS
instance GHC.Generics.Generic Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfoRHS
instance GHC.Classes.Eq lhsJoinField => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfo lhsJoinField)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfo lhsJoinField)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Remote.DBJoinField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Remote.ScalarComputedField b)
instance Data.Aeson.Types.ToJSON.ToJSON lhsJoinField => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfo lhsJoinField)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.Remote.RemoteFieldInfoRHS
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Relationships.Remote.RemoteRelationship
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.Remote.RemoteRelationship
instance (TypeError ...) => Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Relationships.Remote.RemoteRelationshipDefinition

module Hasura.Table.Cache

-- | A wrapper around <a>GType</a> which allows us to define custom JSON
--   instances.
--   
--   TODO: this name is ambiguous, and conflicts with
--   Hasura.RQL.DDL.RemoteSchema.Permission.GraphQLType; it should perhaps
--   be renamed, made internal to this module, or removed altogether?
newtype GraphQLType
GraphQLType :: GType -> GraphQLType
[unGraphQLType] :: GraphQLType -> GType
isListType :: GraphQLType -> Bool
isNullableType :: GraphQLType -> Bool
data CustomRootField
CustomRootField :: Maybe Name -> Comment -> CustomRootField
[_crfName] :: CustomRootField -> Maybe Name
[_crfComment] :: CustomRootField -> Comment
data TableCustomRootFields
TableCustomRootFields :: CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> CustomRootField -> TableCustomRootFields
[_tcrfSelect] :: TableCustomRootFields -> CustomRootField
[_tcrfSelectByPk] :: TableCustomRootFields -> CustomRootField
[_tcrfSelectAggregate] :: TableCustomRootFields -> CustomRootField
[_tcrfSelectStream] :: TableCustomRootFields -> CustomRootField
[_tcrfInsert] :: TableCustomRootFields -> CustomRootField
[_tcrfInsertOne] :: TableCustomRootFields -> CustomRootField
[_tcrfUpdate] :: TableCustomRootFields -> CustomRootField
[_tcrfUpdateByPk] :: TableCustomRootFields -> CustomRootField
[_tcrfUpdateMany] :: TableCustomRootFields -> CustomRootField
[_tcrfDelete] :: TableCustomRootFields -> CustomRootField
[_tcrfDeleteByPk] :: TableCustomRootFields -> CustomRootField
emptyCustomRootFields :: TableCustomRootFields
getAllCustomRootFields :: TableCustomRootFields -> [CustomRootField]
data FieldInfo (b :: BackendType)
FIColumn :: StructuredColumnInfo b -> FieldInfo (b :: BackendType)
FIRelationship :: RelInfo b -> FieldInfo (b :: BackendType)
FIComputedField :: ComputedFieldInfo b -> FieldInfo (b :: BackendType)
FIRemoteRelationship :: RemoteFieldInfo (DBJoinField b) -> FieldInfo (b :: BackendType)
_FIRemoteRelationship :: forall b_agT3e. Prism' (FieldInfo b_agT3e) (RemoteFieldInfo (DBJoinField b_agT3e))
_FIComputedField :: forall b_agT3e. Prism' (FieldInfo b_agT3e) (ComputedFieldInfo b_agT3e)
_FIRelationship :: forall b_agT3e. Prism' (FieldInfo b_agT3e) (RelInfo b_agT3e)
_FIColumn :: forall b_agT3e. Prism' (FieldInfo b_agT3e) (StructuredColumnInfo b_agT3e)
type FieldInfoMap = HashMap FieldName
fieldInfoName :: forall b. Backend b => FieldInfo b -> FieldName
fieldInfoGraphQLName :: FieldInfo b -> Maybe Name
getRemoteFieldInfoName :: RemoteFieldInfo lhsJoinField -> RelName

-- | Returns all the field names created for the given field. Columns,
--   object relationships, and computed fields only ever produce a single
--   field, but array relationships also contain an <tt>_aggregate</tt>
--   field.
fieldInfoGraphQLNames :: FieldInfo b -> [Name]
getCols :: FieldInfoMap (FieldInfo backend) -> [StructuredColumnInfo backend]

-- | Sort columns based on their ordinal position
sortCols :: [ColumnInfo backend] -> [ColumnInfo backend]
getRels :: FieldInfoMap (FieldInfo backend) -> [RelInfo backend]
getComputedFieldInfos :: FieldInfoMap (FieldInfo backend) -> [ComputedFieldInfo backend]
data InsPermInfo (b :: BackendType)
InsPermInfo :: HashSet (Column b) -> AnnBoolExpPartialSQL b -> PreSetColsPartial b -> Bool -> HashSet Text -> Maybe (ValidateInput ResolvedWebhook) -> InsPermInfo (b :: BackendType)
[ipiCols] :: InsPermInfo (b :: BackendType) -> HashSet (Column b)
[ipiCheck] :: InsPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[ipiSet] :: InsPermInfo (b :: BackendType) -> PreSetColsPartial b
[ipiBackendOnly] :: InsPermInfo (b :: BackendType) -> Bool
[ipiRequiredHeaders] :: InsPermInfo (b :: BackendType) -> HashSet Text
[ipiValidateInput] :: InsPermInfo (b :: BackendType) -> Maybe (ValidateInput ResolvedWebhook)

-- | This type is only used as an intermediate type to combine more than
--   one select permissions for inherited roles.
data CombinedSelPermInfo (b :: BackendType)
CombinedSelPermInfo :: [HashMap (Column b) (AnnRedactionExpPartialSQL b)] -> [HashMap ComputedFieldName (AnnRedactionExpPartialSQL b)] -> [AnnBoolExpPartialSQL b] -> Maybe (Max Int) -> Any -> HashSet Text -> AllowedRootFields QueryRootFieldType -> AllowedRootFields SubscriptionRootFieldType -> CombinedSelPermInfo (b :: BackendType)
[cspiCols] :: CombinedSelPermInfo (b :: BackendType) -> [HashMap (Column b) (AnnRedactionExpPartialSQL b)]
[cspiComputedFields] :: CombinedSelPermInfo (b :: BackendType) -> [HashMap ComputedFieldName (AnnRedactionExpPartialSQL b)]
[cspiFilter] :: CombinedSelPermInfo (b :: BackendType) -> [AnnBoolExpPartialSQL b]
[cspiLimit] :: CombinedSelPermInfo (b :: BackendType) -> Maybe (Max Int)
[cspiAllowAgg] :: CombinedSelPermInfo (b :: BackendType) -> Any
[cspiRequiredHeaders] :: CombinedSelPermInfo (b :: BackendType) -> HashSet Text
[cspiAllowedQueryRootFieldTypes] :: CombinedSelPermInfo (b :: BackendType) -> AllowedRootFields QueryRootFieldType
[cspiAllowedSubscriptionRootFieldTypes] :: CombinedSelPermInfo (b :: BackendType) -> AllowedRootFields SubscriptionRootFieldType
combinedSelPermInfoToSelPermInfo :: Backend b => Int -> CombinedSelPermInfo b -> SelPermInfo b
data SelPermInfo (b :: BackendType)
SelPermInfo :: HashMap (Column b) (AnnRedactionExpPartialSQL b) -> HashMap ComputedFieldName (AnnRedactionExpPartialSQL b) -> AnnBoolExpPartialSQL b -> Maybe Int -> Bool -> HashSet Text -> AllowedRootFields QueryRootFieldType -> AllowedRootFields SubscriptionRootFieldType -> SelPermInfo (b :: BackendType)

-- | HashMap of accessible columns to the role, the <a>Column</a> may be
--   mapped to an <a>AnnRedactionExpPartialSQL</a>, which is
--   <a>RedactIfFalse</a> only in the case of an inherited role, for a
--   non-inherited role, it will always be <a>NoRedaction</a>. The
--   <a>RedactIfFalse</a> bool exp will determine if the column should be
--   nullified in a row, when there aren't requisite permissions.
[spiCols] :: SelPermInfo (b :: BackendType) -> HashMap (Column b) (AnnRedactionExpPartialSQL b)

-- | HashMap of accessible computed fields to the role, mapped to
--   <a>AnnRedactionExpPartialSQL</a>, simililar to <a>spiCols</a>. These
--   computed fields do not return rows of existing table.
[spiComputedFields] :: SelPermInfo (b :: BackendType) -> HashMap ComputedFieldName (AnnRedactionExpPartialSQL b)
[spiFilter] :: SelPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[spiLimit] :: SelPermInfo (b :: BackendType) -> Maybe Int
[spiAllowAgg] :: SelPermInfo (b :: BackendType) -> Bool
[spiRequiredHeaders] :: SelPermInfo (b :: BackendType) -> HashSet Text

-- | allowed root field types to be exposed in the query_root
[spiAllowedQueryRootFields] :: SelPermInfo (b :: BackendType) -> AllowedRootFields QueryRootFieldType

-- | allowed root field types to be exposed in the subscription_root
[spiAllowedSubscriptionRootFields] :: SelPermInfo (b :: BackendType) -> AllowedRootFields SubscriptionRootFieldType
data UpdPermInfo (b :: BackendType)
UpdPermInfo :: HashSet (Column b) -> TableName b -> AnnBoolExpPartialSQL b -> Maybe (AnnBoolExpPartialSQL b) -> PreSetColsPartial b -> Bool -> HashSet Text -> Maybe (ValidateInput ResolvedWebhook) -> UpdPermInfo (b :: BackendType)
[upiCols] :: UpdPermInfo (b :: BackendType) -> HashSet (Column b)
[upiTable] :: UpdPermInfo (b :: BackendType) -> TableName b
[upiFilter] :: UpdPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[upiCheck] :: UpdPermInfo (b :: BackendType) -> Maybe (AnnBoolExpPartialSQL b)
[upiSet] :: UpdPermInfo (b :: BackendType) -> PreSetColsPartial b
[upiBackendOnly] :: UpdPermInfo (b :: BackendType) -> Bool
[upiRequiredHeaders] :: UpdPermInfo (b :: BackendType) -> HashSet Text
[upiValidateInput] :: UpdPermInfo (b :: BackendType) -> Maybe (ValidateInput ResolvedWebhook)
data DelPermInfo (b :: BackendType)
DelPermInfo :: TableName b -> AnnBoolExpPartialSQL b -> !Bool -> HashSet Text -> Maybe (ValidateInput ResolvedWebhook) -> DelPermInfo (b :: BackendType)
[dpiTable] :: DelPermInfo (b :: BackendType) -> TableName b
[dpiFilter] :: DelPermInfo (b :: BackendType) -> AnnBoolExpPartialSQL b
[dpiBackendOnly] :: DelPermInfo (b :: BackendType) -> !Bool
[dpiRequiredHeaders] :: DelPermInfo (b :: BackendType) -> HashSet Text
[dpiValidateInput] :: DelPermInfo (b :: BackendType) -> Maybe (ValidateInput ResolvedWebhook)
data RolePermInfo (b :: BackendType)
RolePermInfo :: Maybe (InsPermInfo b) -> Maybe (SelPermInfo b) -> Maybe (UpdPermInfo b) -> Maybe (DelPermInfo b) -> RolePermInfo (b :: BackendType)
[_permIns] :: RolePermInfo (b :: BackendType) -> Maybe (InsPermInfo b)
[_permSel] :: RolePermInfo (b :: BackendType) -> Maybe (SelPermInfo b)
[_permUpd] :: RolePermInfo (b :: BackendType) -> Maybe (UpdPermInfo b)
[_permDel] :: RolePermInfo (b :: BackendType) -> Maybe (DelPermInfo b)
permUpd :: forall b_agUhf. Lens' (RolePermInfo b_agUhf) (Maybe (UpdPermInfo b_agUhf))
permSel :: forall b_agUhf. Lens' (RolePermInfo b_agUhf) (Maybe (SelPermInfo b_agUhf))
permIns :: forall b_agUhf. Lens' (RolePermInfo b_agUhf) (Maybe (InsPermInfo b_agUhf))
permDel :: forall b_agUhf. Lens' (RolePermInfo b_agUhf) (Maybe (DelPermInfo b_agUhf))
type RolePermInfoMap b = HashMap RoleName (RolePermInfo b)
data ViewInfo
ViewInfo :: Bool -> Bool -> Bool -> ViewInfo
[viIsUpdatable] :: ViewInfo -> Bool
[viIsDeletable] :: ViewInfo -> Bool
[viIsInsertable] :: ViewInfo -> Bool
isMutable :: (ViewInfo -> Bool) -> Maybe ViewInfo -> Bool
data ColumnConfig
ColumnConfig :: Maybe Name -> Comment -> ColumnConfig
[_ccfgCustomName] :: ColumnConfig -> Maybe Name
[_ccfgComment] :: ColumnConfig -> Comment
data TableConfig b
TableConfig :: TableCustomRootFields -> HashMap (Column b) ColumnConfig -> Maybe Name -> Comment -> TableConfig b
[_tcCustomRootFields] :: TableConfig b -> TableCustomRootFields
[_tcColumnConfig] :: TableConfig b -> HashMap (Column b) ColumnConfig
[_tcCustomName] :: TableConfig b -> Maybe Name
[_tcComment] :: TableConfig b -> Comment
tcCustomRootFields :: forall b_agYxe. Lens' (TableConfig b_agYxe) TableCustomRootFields
tcCustomName :: forall b_agYxe. Lens' (TableConfig b_agYxe) (Maybe Name)
tcComment :: forall b_agYxe. Lens' (TableConfig b_agYxe) Comment
tcColumnConfig :: forall b_agYxe b_agZfs. Lens (TableConfig b_agYxe) (TableConfig b_agZfs) (HashMap (Column b_agYxe) ColumnConfig) (HashMap (Column b_agZfs) ColumnConfig)
emptyTableConfig :: TableConfig b
data Constraint (b :: BackendType)
Constraint :: ConstraintName b -> OID -> Constraint (b :: BackendType)
[_cName] :: Constraint (b :: BackendType) -> ConstraintName b
[_cOid] :: Constraint (b :: BackendType) -> OID
data PrimaryKey (b :: BackendType) a
PrimaryKey :: Constraint b -> NESeq a -> PrimaryKey (b :: BackendType) a
[_pkConstraint] :: PrimaryKey (b :: BackendType) a -> Constraint b
[_pkColumns] :: PrimaryKey (b :: BackendType) a -> NESeq a
pkConstraint :: forall b_agZg4 a_agZg5 b_ah1Mr. Lens (PrimaryKey b_agZg4 a_agZg5) (PrimaryKey b_ah1Mr a_agZg5) (Constraint b_agZg4) (Constraint b_ah1Mr)
pkColumns :: forall b_agZg4 a_agZg5 a_ah1Mq. Lens (PrimaryKey b_agZg4 a_agZg5) (PrimaryKey b_agZg4 a_ah1Mq) (NESeq a_agZg5) (NESeq a_ah1Mq)

-- | Data type modelling uniqueness constraints. Occasionally this will
--   include primary keys, although those are tracked separately in
--   <a>TableCoreInfoG</a>.
--   
--   For more information about unique constraints, visit the postgresql
--   documentation:
--   <a>https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-UNIQUE-CONSTRAINTS</a>.
data UniqueConstraint (b :: BackendType)
UniqueConstraint :: Constraint b -> HashSet (Column b) -> UniqueConstraint (b :: BackendType)

-- | The postgresql name and object id of a unique constraint.
[_ucConstraint] :: UniqueConstraint (b :: BackendType) -> Constraint b

-- | The set of columns which should be unique for this particular
--   constraint. Used for permissions calculation.
[_ucColumns] :: UniqueConstraint (b :: BackendType) -> HashSet (Column b)
data ForeignKey (b :: BackendType)
ForeignKey :: Constraint b -> TableName b -> NEHashMap (Column b) (Column b) -> ForeignKey (b :: BackendType)
[_fkConstraint] :: ForeignKey (b :: BackendType) -> Constraint b
[_fkForeignTable] :: ForeignKey (b :: BackendType) -> TableName b
[_fkColumnMapping] :: ForeignKey (b :: BackendType) -> NEHashMap (Column b) (Column b)

-- | The <tt>field</tt> and <tt>primaryKeyColumn</tt> type parameters vary
--   as the schema cache is built and more information is accumulated. See
--   also <a>TableCoreInfo</a>.
data TableCoreInfoG (b :: BackendType) field primaryKeyColumn
TableCoreInfo :: TableName b -> Maybe PGDescription -> FieldInfoMap field -> Maybe (PrimaryKey b primaryKeyColumn) -> HashSet (UniqueConstraint b) -> HashSet (ForeignKey b) -> Maybe ViewInfo -> Maybe EnumValues -> TableConfig b -> ExtraTableMetadata b -> Maybe ApolloFederationConfig -> [RawColumnInfo b] -> TableCoreInfoG (b :: BackendType) field primaryKeyColumn
[_tciName] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> TableName b
[_tciDescription] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe PGDescription
[_tciFieldInfoMap] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> FieldInfoMap field
[_tciPrimaryKey] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe (PrimaryKey b primaryKeyColumn)

-- | Does <i>not</i> include the primary key; use
--   <a>tciUniqueOrPrimaryKeyConstraints</a> if you need both.
[_tciUniqueConstraints] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> HashSet (UniqueConstraint b)
[_tciForeignKeys] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> HashSet (ForeignKey b)
[_tciViewInfo] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe ViewInfo
[_tciEnumValues] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe EnumValues
[_tciCustomConfig] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> TableConfig b
[_tciExtraTableMetadata] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> ExtraTableMetadata b
[_tciApolloFederationConfig] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> Maybe ApolloFederationConfig
[_tciRawColumns] :: TableCoreInfoG (b :: BackendType) field primaryKeyColumn -> [RawColumnInfo b]
tciViewInfo :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1. Lens' (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) (Maybe ViewInfo)
tciUniqueConstraints :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1. Lens' (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) (HashSet (UniqueConstraint b_ah1MZ))
tciRawColumns :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1. Lens' (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) [RawColumnInfo b_ah1MZ]
tciPrimaryKey :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1 primaryKeyColumn_ah4i7. Lens (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah4i7) (Maybe (PrimaryKey b_ah1MZ primaryKeyColumn_ah1N1)) (Maybe (PrimaryKey b_ah1MZ primaryKeyColumn_ah4i7))
tciName :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1. Lens' (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) (TableName b_ah1MZ)
tciForeignKeys :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1. Lens' (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) (HashSet (ForeignKey b_ah1MZ))
tciFieldInfoMap :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1 field_ah4i6. Lens (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) (TableCoreInfoG b_ah1MZ field_ah4i6 primaryKeyColumn_ah1N1) (FieldInfoMap field_ah1N0) (FieldInfoMap field_ah4i6)
tciExtraTableMetadata :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1. Lens' (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) (ExtraTableMetadata b_ah1MZ)
tciEnumValues :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1. Lens' (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) (Maybe EnumValues)
tciDescription :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1. Lens' (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) (Maybe PGDescription)
tciCustomConfig :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1. Lens' (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) (TableConfig b_ah1MZ)
tciApolloFederationConfig :: forall b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1. Lens' (TableCoreInfoG b_ah1MZ field_ah1N0 primaryKeyColumn_ah1N1) (Maybe ApolloFederationConfig)

-- | Fully-processed table info that includes non-column fields.
type TableCoreInfo b = TableCoreInfoG b (FieldInfo b) (ColumnInfo b)
tciUniqueOrPrimaryKeyConstraints :: forall b f. Hashable (Column b) => TableCoreInfoG b f (ColumnInfo b) -> Maybe (NonEmpty (UniqueConstraint b))
data TableInfo (b :: BackendType)
TableInfo :: TableCoreInfo b -> RolePermInfoMap b -> EventTriggerInfoMap b -> RolePermInfo b -> TableInfo (b :: BackendType)
[_tiCoreInfo] :: TableInfo (b :: BackendType) -> TableCoreInfo b
[_tiRolePermInfoMap] :: TableInfo (b :: BackendType) -> RolePermInfoMap b
[_tiEventTriggerInfoMap] :: TableInfo (b :: BackendType) -> EventTriggerInfoMap b
[_tiAdminRolePermInfo] :: TableInfo (b :: BackendType) -> RolePermInfo b
tiRolePermInfoMap :: forall b_ah4la. Lens' (TableInfo b_ah4la) (RolePermInfoMap b_ah4la)
tiEventTriggerInfoMap :: forall b_ah4la. Lens' (TableInfo b_ah4la) (EventTriggerInfoMap b_ah4la)
tiCoreInfo :: forall b_ah4la. Lens' (TableInfo b_ah4la) (TableCoreInfo b_ah4la)
tiAdminRolePermInfo :: forall b_ah4la. Lens' (TableInfo b_ah4la) (RolePermInfo b_ah4la)
tiName :: Lens' (TableInfo b) (TableName b)
tableInfoName :: TableInfo b -> TableName b
tableArrayRelationships :: TableInfo b -> [RelInfo b]
getRolePermInfo :: RoleName -> TableInfo b -> RolePermInfo b
type TableCoreCache b = HashMap (TableName b) (TableCoreInfo b)
type TableCache b = HashMap (TableName b) (TableInfo b)
type TableEventTriggers b = HashMap (TableName b) [TriggerName]

-- | Metadata of a Postgres foreign key constraint which is being extracted
--   from database via 'src-rsr/pg_table_metadata.sql'
newtype ForeignKeyMetadata (b :: BackendType)
ForeignKeyMetadata :: ForeignKey b -> ForeignKeyMetadata (b :: BackendType)
[unForeignKeyMetadata] :: ForeignKeyMetadata (b :: BackendType) -> ForeignKey b

-- | Metadata of any Backend table which is being extracted from source
--   database
data DBTableMetadata (b :: BackendType)
DBTableMetadata :: OID -> [RawColumnInfo b] -> Maybe (PrimaryKey b (Column b)) -> HashSet (UniqueConstraint b) -> HashSet (ForeignKeyMetadata b) -> Maybe ViewInfo -> Maybe PGDescription -> ExtraTableMetadata b -> DBTableMetadata (b :: BackendType)
[_ptmiOid] :: DBTableMetadata (b :: BackendType) -> OID
[_ptmiColumns] :: DBTableMetadata (b :: BackendType) -> [RawColumnInfo b]
[_ptmiPrimaryKey] :: DBTableMetadata (b :: BackendType) -> Maybe (PrimaryKey b (Column b))

-- | Does <i>not</i> include the primary key
[_ptmiUniqueConstraints] :: DBTableMetadata (b :: BackendType) -> HashSet (UniqueConstraint b)
[_ptmiForeignKeys] :: DBTableMetadata (b :: BackendType) -> HashSet (ForeignKeyMetadata b)
[_ptmiViewInfo] :: DBTableMetadata (b :: BackendType) -> Maybe ViewInfo
[_ptmiDescription] :: DBTableMetadata (b :: BackendType) -> Maybe PGDescription
[_ptmiExtraTableMetadata] :: DBTableMetadata (b :: BackendType) -> ExtraTableMetadata b
type DBTablesMetadata b = HashMap (TableName b) (DBTableMetadata b)
getFieldInfoM :: TableInfo b -> FieldName -> Maybe (FieldInfo b)
getColumnInfoM :: TableInfo b -> FieldName -> Maybe (ColumnInfo b)
askFieldInfo :: MonadError QErr m => FieldInfoMap fieldInfo -> FieldName -> m fieldInfo
askColumnType :: (MonadError QErr m, Backend backend) => FieldInfoMap (FieldInfo backend) -> Column backend -> Text -> m (ColumnType backend)
askColInfo :: forall m backend. (MonadError QErr m, Backend backend) => FieldInfoMap (FieldInfo backend) -> Column backend -> Text -> m (ColumnInfo backend)
askComputedFieldInfo :: MonadError QErr m => FieldInfoMap (FieldInfo backend) -> ComputedFieldName -> m (ComputedFieldInfo backend)
assertColumnExists :: forall backend m. (MonadError QErr m, Backend backend) => FieldInfoMap (FieldInfo backend) -> Text -> Column backend -> m ()
askRelType :: MonadError QErr m => FieldInfoMap (FieldInfo backend) -> RelName -> Text -> m (RelInfo backend)
askRemoteRel :: MonadError QErr m => FieldInfoMap (FieldInfo backend) -> RelName -> m (RemoteFieldInfo (DBJoinField backend))
mkAdminRolePermInfo :: Backend b => TableCoreInfo b -> RolePermInfo b

-- | Builds field name with proper case. Please note that this is a pure
--   function as all the validation has already been done while preparing
--   <tt>GQLNameIdentifier</tt>.
setFieldNameCase :: NamingCase -> TableInfo b -> CustomRootField -> (GQLNameIdentifier -> GQLNameIdentifier) -> GQLNameIdentifier -> Name
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.Table.Cache.ForeignKeyMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.ForeignKeyMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.ForeignKeyMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.Cache.ForeignKeyMetadata b)
instance GHC.Generics.Generic (Hasura.Table.Cache.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.Cache.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.DBTableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.ForeignKeyMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.ForeignKeyMetadata b)
instance GHC.Generics.Generic (Hasura.Table.Cache.TableInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.EventTrigger.EventTriggerInfoMap b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfoMap b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.TableCoreInfo b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.TableInfo b)
instance GHC.Generics.Generic (Hasura.Table.Cache.UniqueConstraint b)
instance GHC.Generics.Generic (Hasura.Table.Cache.ForeignKey b)
instance GHC.Generics.Generic (Hasura.Table.Cache.TableCoreInfoG b field primaryKeyColumn)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.UniqueConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.Cache.UniqueConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.Cache.ForeignKey b)
instance (GHC.Classes.Eq field, GHC.Classes.Eq pkCol, Hasura.RQL.Types.Backend.Backend b) => GHC.Classes.Eq (Hasura.Table.Cache.TableCoreInfoG b field pkCol)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Generics.Generic pkCol, Data.Aeson.Types.ToJSON.ToJSON field, Data.Aeson.Types.ToJSON.ToJSON pkCol) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.TableCoreInfoG b field pkCol)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.Table.Cache.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.ForeignKey b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.UniqueConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.Table.Cache.UniqueConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.UniqueConstraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.UniqueConstraint b)
instance GHC.Generics.Generic (Hasura.Table.Cache.Constraint b)
instance Data.Foldable.Foldable (Hasura.Table.Cache.PrimaryKey b)
instance GHC.Generics.Generic (Hasura.Table.Cache.PrimaryKey b a)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.Cache.Constraint b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.Table.Cache.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.Table.Cache.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData a) => Control.DeepSeq.NFData (Hasura.Table.Cache.PrimaryKey b a)
instance (GHC.Classes.Eq a, Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Data.Sequence.NonEmpty.Internal.NESeq a)) => Data.Hashable.Class.Hashable (Hasura.Table.Cache.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.PrimaryKey b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.PrimaryKey b a)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.Table.Cache.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.Constraint b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.Table.Cache.TableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Cache.TableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.TableConfig b)
instance GHC.Generics.Generic Hasura.Table.Cache.ColumnConfig
instance GHC.Show.Show Hasura.Table.Cache.ColumnConfig
instance GHC.Classes.Eq Hasura.Table.Cache.ColumnConfig
instance GHC.Generics.Generic (Hasura.Table.Cache.TableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.TableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.Cache.TableConfig b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.Table.Cache.TableConfig b)
instance Control.DeepSeq.NFData Hasura.Table.Cache.ColumnConfig
instance Autodocodec.Class.HasCodec Hasura.Table.Cache.ColumnConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Table.Cache.ColumnConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.Cache.ColumnConfig
instance GHC.Base.Semigroup Hasura.Table.Cache.ColumnConfig
instance GHC.Base.Monoid Hasura.Table.Cache.ColumnConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Table.Cache.ViewInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.Cache.ViewInfo
instance GHC.Generics.Generic Hasura.Table.Cache.ViewInfo
instance GHC.Classes.Eq Hasura.Table.Cache.ViewInfo
instance GHC.Show.Show Hasura.Table.Cache.ViewInfo
instance Control.DeepSeq.NFData Hasura.Table.Cache.ViewInfo
instance GHC.Generics.Generic (Hasura.Table.Cache.InsPermInfo b)
instance GHC.Generics.Generic (Hasura.Table.Cache.SelPermInfo b)
instance GHC.Generics.Generic (Hasura.Table.Cache.UpdPermInfo b)
instance GHC.Generics.Generic (Hasura.Table.Cache.DelPermInfo b)
instance GHC.Generics.Generic (Hasura.Table.Cache.RolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.Table.Cache.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Show.Show (Hasura.Table.Cache.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.Table.Cache.SelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Show.Show (Hasura.Table.Cache.SelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.Table.Cache.UpdPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Show.Show (Hasura.Table.Cache.UpdPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Classes.Eq (Hasura.Table.Cache.DelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => GHC.Show.Show (Hasura.Table.Cache.DelPermInfo b)
instance GHC.Show.Show (Hasura.Table.Cache.RolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.Table.Cache.InsPermInfo b), Control.DeepSeq.NFData (Hasura.Table.Cache.SelPermInfo b), Control.DeepSeq.NFData (Hasura.Table.Cache.UpdPermInfo b), Control.DeepSeq.NFData (Hasura.Table.Cache.DelPermInfo b)) => Control.DeepSeq.NFData (Hasura.Table.Cache.RolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.InsPermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.SelPermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.UpdPermInfo b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.DelPermInfo b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Control.DeepSeq.NFData (Hasura.Table.Cache.DelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.DelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.PreSetColsPartial b)) => Control.DeepSeq.NFData (Hasura.Table.Cache.UpdPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.UpdPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Control.DeepSeq.NFData (Hasura.Table.Cache.SelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.SelPermInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Semigroup (Hasura.Table.Cache.CombinedSelPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b), Control.DeepSeq.NFData (Hasura.RQL.IR.BoolExp.PreSetColsPartial b)) => Control.DeepSeq.NFData (Hasura.Table.Cache.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.InsPermInfo b)
instance Control.DeepSeq.NFData Hasura.Table.Cache.GraphQLType
instance GHC.Generics.Generic Hasura.Table.Cache.GraphQLType
instance GHC.Classes.Ord Hasura.Table.Cache.GraphQLType
instance GHC.Classes.Eq Hasura.Table.Cache.GraphQLType
instance GHC.Show.Show Hasura.Table.Cache.GraphQLType
instance GHC.Generics.Generic Hasura.Table.Cache.CustomRootField
instance GHC.Classes.Eq Hasura.Table.Cache.CustomRootField
instance GHC.Show.Show Hasura.Table.Cache.CustomRootField
instance GHC.Generics.Generic Hasura.Table.Cache.TableCustomRootFields
instance GHC.Classes.Eq Hasura.Table.Cache.TableCustomRootFields
instance GHC.Show.Show Hasura.Table.Cache.TableCustomRootFields
instance GHC.Generics.Generic (Hasura.Table.Cache.FieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Cache.FieldInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.FieldInfo b)
instance Control.DeepSeq.NFData Hasura.Table.Cache.TableCustomRootFields
instance Autodocodec.Class.HasCodec Hasura.Table.Cache.TableCustomRootFields
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Table.Cache.TableCustomRootFields
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.Cache.TableCustomRootFields
instance Control.DeepSeq.NFData Hasura.Table.Cache.CustomRootField
instance Autodocodec.Class.HasCodec Hasura.Table.Cache.CustomRootField
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.Cache.CustomRootField
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Table.Cache.CustomRootField
instance Autodocodec.Class.HasCodec Hasura.Table.Cache.GraphQLType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Table.Cache.GraphQLType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.Cache.GraphQLType


-- | In order to avoid circular dependencies while splitting
--   <a>Metadata</a> into multiple modules, some definitions must be moved
--   out of that module. This module is the bucket for definitions that
--   have not been specifically moved elsewhere.
module Hasura.Table.Metadata
data ComputedFieldMetadata b
ComputedFieldMetadata :: ComputedFieldName -> ComputedFieldDefinition b -> Comment -> ComputedFieldMetadata b
[_cfmName] :: ComputedFieldMetadata b -> ComputedFieldName
[_cfmDefinition] :: ComputedFieldMetadata b -> ComputedFieldDefinition b
[_cfmComment] :: ComputedFieldMetadata b -> Comment
type Relationships a = InsOrdHashMap RelName a
type ComputedFields b = InsOrdHashMap ComputedFieldName (ComputedFieldMetadata b)
type Permissions a = InsOrdHashMap RoleName a
data TableMetadata b
TableMetadata :: TableName b -> Bool -> TableConfig b -> Relationships (ObjRelDef b) -> Relationships (ArrRelDef b) -> ComputedFields b -> RemoteRelationships -> Permissions (InsPermDef b) -> Permissions (SelPermDef b) -> Permissions (UpdPermDef b) -> Permissions (DelPermDef b) -> EventTriggers b -> Maybe ApolloFederationConfig -> Maybe LogicalModelName -> TableMetadata b
[_tmTable] :: TableMetadata b -> TableName b
[_tmIsEnum] :: TableMetadata b -> Bool
[_tmConfiguration] :: TableMetadata b -> TableConfig b
[_tmObjectRelationships] :: TableMetadata b -> Relationships (ObjRelDef b)
[_tmArrayRelationships] :: TableMetadata b -> Relationships (ArrRelDef b)
[_tmComputedFields] :: TableMetadata b -> ComputedFields b
[_tmRemoteRelationships] :: TableMetadata b -> RemoteRelationships
[_tmInsertPermissions] :: TableMetadata b -> Permissions (InsPermDef b)
[_tmSelectPermissions] :: TableMetadata b -> Permissions (SelPermDef b)
[_tmUpdatePermissions] :: TableMetadata b -> Permissions (UpdPermDef b)
[_tmDeletePermissions] :: TableMetadata b -> Permissions (DelPermDef b)
[_tmEventTriggers] :: TableMetadata b -> EventTriggers b
[_tmApolloFederationConfig] :: TableMetadata b -> Maybe ApolloFederationConfig
[_tmLogicalModel] :: TableMetadata b -> Maybe LogicalModelName
tmUpdatePermissions :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (Permissions (UpdPermDef b_ahu14))
tmTable :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (TableName b_ahu14)
tmSelectPermissions :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (Permissions (SelPermDef b_ahu14))
tmRemoteRelationships :: forall b_ahu14. Lens' (TableMetadata b_ahu14) RemoteRelationships
tmObjectRelationships :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (Relationships (ObjRelDef b_ahu14))
tmLogicalModel :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (Maybe LogicalModelName)
tmIsEnum :: forall b_ahu14. Lens' (TableMetadata b_ahu14) Bool
tmInsertPermissions :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (Permissions (InsPermDef b_ahu14))
tmEventTriggers :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (EventTriggers b_ahu14)
tmDeletePermissions :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (Permissions (DelPermDef b_ahu14))
tmConfiguration :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (TableConfig b_ahu14)
tmComputedFields :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (ComputedFields b_ahu14)
tmArrayRelationships :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (Relationships (ArrRelDef b_ahu14))
tmApolloFederationConfig :: forall b_ahu14. Lens' (TableMetadata b_ahu14) (Maybe ApolloFederationConfig)
mkTableMeta :: TableName b -> Bool -> TableConfig b -> TableMetadata b
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Metadata.TableMetadata b)
instance GHC.Generics.Generic (Hasura.Table.Metadata.ComputedFieldMetadata b)
instance GHC.Generics.Generic (Hasura.Table.Metadata.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.Metadata.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Metadata.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.Metadata.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.Metadata.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Metadata.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.Table.Metadata.TableMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.Table.Metadata.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Metadata.ComputedFieldMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.Metadata.ComputedFieldMetadata b)

module Hasura.RQL.Types.BoolExp

-- | Context to parse a RHS value in a boolean expression
data BoolExpRHSParser (b :: BackendType) m v
BoolExpRHSParser :: ValueParser b m v -> v -> BoolExpRHSParser (b :: BackendType) m v

-- | Parse a JSON value with enforcing a column type
[_berpValueParser] :: BoolExpRHSParser (b :: BackendType) m v -> ValueParser b m v

-- | Required for a computed field SQL function with session argument
[_berpSessionValue] :: BoolExpRHSParser (b :: BackendType) m v -> v

-- | A function which resolves boolean expression from given table fields
newtype BoolExpResolver b m v
BoolExpResolver :: (BoolExpRHSParser b m v -> FieldInfoMap (FieldInfo b) -> FieldInfoMap (FieldInfo b) -> GBoolExp b ColExp -> m (AnnBoolExp b v)) -> BoolExpResolver b m v
[getBoolExpResolver] :: BoolExpResolver b m v -> BoolExpRHSParser b m v -> FieldInfoMap (FieldInfo b) -> FieldInfoMap (FieldInfo b) -> GBoolExp b ColExp -> m (AnnBoolExp b v)


-- | Types and functions for interacting with and manipulating SQL enums
--   represented by <i>single-column tables</i>, <b>not</b> native Postgres
--   enum types. Native enum types in Postgres are difficult to change, so
--   we discourage their use, but we might add support for native enum
--   types in the future.
module Hasura.RQL.DDL.Schema.Enum

-- | Given a map of enum tables, computes all enum references implied by
--   the given set of foreign keys. A foreign key constitutes an enum
--   reference iff the following conditions hold:
--   
--   <ol>
--   <li>The key only includes a single column.</li>
--   <li>The referenced column is the tableâ€™s primary key.</li>
--   <li>The referenced table is, in fact, an enum table.</li>
--   </ol>
resolveEnumReferences :: forall b. Backend b => HashMap (TableName b) (PrimaryKey b (Column b), TableConfig b, EnumValues) -> HashSet (ForeignKey b) -> HashMap (Column b) (NonEmpty (EnumReference b))

module Hasura.LogicalModel.Cache
type LogicalModelCache b = HashMap LogicalModelName (LogicalModelInfo b)

-- | Description of a logical model for use in metadata (after schema
--   cache)
data LogicalModelInfo (b :: BackendType)
LogicalModelInfo :: LogicalModelName -> LogicalModelFields b -> Maybe Text -> RolePermInfoMap b -> LogicalModelInfo (b :: BackendType)
[_lmiName] :: LogicalModelInfo (b :: BackendType) -> LogicalModelName
[_lmiFields] :: LogicalModelInfo (b :: BackendType) -> LogicalModelFields b
[_lmiDescription] :: LogicalModelInfo (b :: BackendType) -> Maybe Text
[_lmiPermissions] :: LogicalModelInfo (b :: BackendType) -> RolePermInfoMap b
instance GHC.Generics.Generic (Hasura.LogicalModel.Cache.LogicalModelInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.LogicalModel.Cache.LogicalModelInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfoMap b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.Cache.LogicalModelInfo b)


-- | The representation of stored procedures as derived from the schema
--   cache.
module Hasura.StoredProcedure.Cache
type StoredProcedureCache b = HashMap (FunctionName b) (StoredProcedureInfo b)

-- | The type into which <tt>StoredProcedureMetadata</tt> is resolved in
--   'Hasura<i>RQL</i>DDL<i>Schema</i>Cache.buildSchemaCacheRule'.
data StoredProcedureInfo (b :: BackendType)
StoredProcedureInfo :: FunctionName b -> Name -> StoredProcedureConfig -> LogicalModelInfo b -> HashMap ArgumentName (NullableScalarType b) -> Maybe Text -> StoredProcedureInfo (b :: BackendType)
[_spiStoredProcedure] :: StoredProcedureInfo (b :: BackendType) -> FunctionName b

-- | The GraphQL name of the stored procedure.
[_spiGraphqlName] :: StoredProcedureInfo (b :: BackendType) -> Name
[_spiConfig] :: StoredProcedureInfo (b :: BackendType) -> StoredProcedureConfig
[_spiReturns] :: StoredProcedureInfo (b :: BackendType) -> LogicalModelInfo b
[_spiArguments] :: StoredProcedureInfo (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[_spiDescription] :: StoredProcedureInfo (b :: BackendType) -> Maybe Text
instance GHC.Generics.Generic (Hasura.StoredProcedure.Cache.StoredProcedureInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfoMap b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.Cache.StoredProcedureInfo b)

module Hasura.StoredProcedure.Lenses
spiStoredProcedure :: forall b_ihDpV. Lens' (StoredProcedureInfo b_ihDpV) (FunctionName b_ihDpV)
spiReturns :: forall b_ihDpV. Lens' (StoredProcedureInfo b_ihDpV) (LogicalModelInfo b_ihDpV)
spiGraphqlName :: forall b_ihDpV. Lens' (StoredProcedureInfo b_ihDpV) Name
spiDescription :: forall b_ihDpV. Lens' (StoredProcedureInfo b_ihDpV) (Maybe Text)
spiConfig :: forall b_ihDpV. Lens' (StoredProcedureInfo b_ihDpV) StoredProcedureConfig
spiArguments :: forall b_ihDpV. Lens' (StoredProcedureInfo b_ihDpV) (HashMap ArgumentName (NullableScalarType b_ihDpV))


-- | The representation of native queries as derived from the schema cache.
module Hasura.NativeQuery.Cache
type NativeQueryCache b = HashMap NativeQueryName (NativeQueryInfo b)

-- | The type into which <tt>NativeQueryMetadata</tt> is resolved in
--   'Hasura<i>RQL</i>DDL<i>Schema</i>Cache.buildSchemaCacheRule'.
data NativeQueryInfo (b :: BackendType)
NativeQueryInfo :: NativeQueryName -> InterpolatedQuery ArgumentName -> LogicalModelInfo b -> HashMap ArgumentName (NullableScalarType b) -> InsOrdHashMap RelName (RelInfo b) -> Maybe Text -> NativeQueryInfo (b :: BackendType)
[_nqiRootFieldName] :: NativeQueryInfo (b :: BackendType) -> NativeQueryName
[_nqiCode] :: NativeQueryInfo (b :: BackendType) -> InterpolatedQuery ArgumentName
[_nqiReturns] :: NativeQueryInfo (b :: BackendType) -> LogicalModelInfo b
[_nqiArguments] :: NativeQueryInfo (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[_nqiRelationships] :: NativeQueryInfo (b :: BackendType) -> InsOrdHashMap RelName (RelInfo b)
[_nqiDescription] :: NativeQueryInfo (b :: BackendType) -> Maybe Text
instance GHC.Generics.Generic (Hasura.NativeQuery.Cache.NativeQueryInfo b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.NativeQuery.Cache.NativeQueryInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.RolePermInfoMap b)) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.Cache.NativeQueryInfo b)

module Hasura.NativeQuery.Lenses
nqmRootFieldName :: forall b_i9pUR. Lens' (NativeQueryMetadata b_i9pUR) NativeQueryName
nqmReturns :: forall b_i9pUR. Lens' (NativeQueryMetadata b_i9pUR) (LogicalModelIdentifier b_i9pUR)
nqmObjectRelationships :: forall b_i9pUR. Lens' (NativeQueryMetadata b_i9pUR) (Relationships (RelDef (RelManualConfig b_i9pUR)))
nqmDescription :: forall b_i9pUR. Lens' (NativeQueryMetadata b_i9pUR) (Maybe Text)
nqmCode :: forall b_i9pUR. Lens' (NativeQueryMetadata b_i9pUR) (InterpolatedQuery ArgumentName)
nqmArrayRelationships :: forall b_i9pUR. Lens' (NativeQueryMetadata b_i9pUR) (Relationships (RelDef (RelManualConfig b_i9pUR)))
nqmArguments :: forall b_i9pUR. Lens' (NativeQueryMetadata b_i9pUR) (HashMap ArgumentName (NullableScalarType b_i9pUR))
nqiRootFieldName :: forall b_ihFgt. Lens' (NativeQueryInfo b_ihFgt) NativeQueryName
nqiReturns :: forall b_ihFgt. Lens' (NativeQueryInfo b_ihFgt) (LogicalModelInfo b_ihFgt)
nqiRelationships :: forall b_ihFgt. Lens' (NativeQueryInfo b_ihFgt) (InsOrdHashMap RelName (RelInfo b_ihFgt))
nqiDescription :: forall b_ihFgt. Lens' (NativeQueryInfo b_ihFgt) (Maybe Text)
nqiCode :: forall b_ihFgt. Lens' (NativeQueryInfo b_ihFgt) (InterpolatedQuery ArgumentName)
nqiArguments :: forall b_ihFgt. Lens' (NativeQueryInfo b_ihFgt) (HashMap ArgumentName (NullableScalarType b_ihFgt))

module Hasura.LogicalModel.Lenses
lmiPermissions :: forall b_ihCwC. Lens' (LogicalModelInfo b_ihCwC) (RolePermInfoMap b_ihCwC)
lmiName :: forall b_ihCwC. Lens' (LogicalModelInfo b_ihCwC) LogicalModelName
lmiFields :: forall b_ihCwC. Lens' (LogicalModelInfo b_ihCwC) (LogicalModelFields b_ihCwC)
lmiDescription :: forall b_ihCwC. Lens' (LogicalModelInfo b_ihCwC) (Maybe Text)
lmmSelectPermissions :: forall b_iaoci. Lens' (LogicalModelMetadata b_iaoci) (InsOrdHashMap RoleName (SelPermDef b_iaoci))
lmmName :: forall b_iaoci. Lens' (LogicalModelMetadata b_iaoci) LogicalModelName
lmmFields :: forall b_iaoci. Lens' (LogicalModelMetadata b_iaoci) (LogicalModelFields b_iaoci)
lmmDescription :: forall b_iaoci. Lens' (LogicalModelMetadata b_iaoci) (Maybe Text)


-- | Postgres Types Table
--   
--   Defines a single combinator to throw an error if the view is not
--   mutable.
module Hasura.Backends.Postgres.Types.Table
mutableView :: MonadError QErr m => QualifiedTable -> (ViewInfo -> Bool) -> Maybe ViewInfo -> Text -> m ()


-- | Postgres Translate BoolExp
--   
--   Convert IR boolean expressions to Postgres-specific SQL expressions.
module Hasura.Backends.Postgres.Translate.BoolExp

-- | Translate an IR boolean expression to an SQL boolean expression.
--   References to columns etc are relative to the given
--   <a>rootReference</a>.
toSQLBoolExp :: forall pgKind. Backend ('Postgres pgKind) => Qual -> AnnBoolExpSQL ('Postgres pgKind) -> BoolExp
withRedactionExp :: Backend ('Postgres pgKind) => Qual -> AnnRedactionExp ('Postgres pgKind) SQLExp -> SQLExp -> SQLExp
instance Control.Monad.State.Class.MonadState GHC.Word.Word64 Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM
instance Control.Monad.Reader.Class.MonadReader Hasura.Backends.Postgres.Translate.BoolExp.BoolExpCtx Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM
instance GHC.Base.Monad Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM
instance GHC.Base.Applicative Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM
instance GHC.Base.Functor Hasura.Backends.Postgres.Translate.BoolExp.BoolExpM


-- | Postgres DDL Table
--   
--   Used to fill up the enum values field of <a>TableCoreInfoG</a>.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.Table
fetchAndValidateEnumValues :: forall pgKind m. (Backend ('Postgres pgKind), MonadIO m, MonadBaseControl IO m) => PGSourceConfig -> QualifiedTable -> Maybe (PrimaryKey ('Postgres pgKind) (RawColumnInfo ('Postgres pgKind))) -> [RawColumnInfo ('Postgres pgKind)] -> m (Either QErr EnumValues)


-- | Metadata related types, functions and helpers.
--   
--   Provides a single function which loads the MSSQL database metadata.
--   See the file at src-rsr<i>mssql</i>mssql_table_metadata.sql for the
--   SQL we use to build this metadata. See <a>DBTableMetadata</a> for the
--   Haskell type we use forall storing this metadata.
module Hasura.Backends.MSSQL.Meta
loadDBMetadata :: MonadIO m => TxET QErr m (DBTablesMetadata 'MSSQL)
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysPrimaryKeyColumn
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysPrimaryKeyColumn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysPrimaryKey
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysPrimaryKey
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysSchema
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysSchema
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysType
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysType
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysForeignKeyColumn
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysForeignKeyColumn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysColumn
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysColumn
instance GHC.Generics.Generic Hasura.Backends.MSSQL.Meta.SysTable
instance GHC.Show.Show Hasura.Backends.MSSQL.Meta.SysTable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysTable
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysColumn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysForeignKeyColumn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysSchema
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysPrimaryKey
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Meta.SysPrimaryKeyColumn


-- | This modules defines the tree of Select types: how we represent a
--   query internally, from its top level <a>QueryDB</a> down to each
--   individual field. Most of those types have three type arguments:
--   
--   b: BackendType The backend that is targeted by that specific select
--   (Postgres Vanilla, MSSQL...); we use the type families in the Backend
--   class to decide how different parts of the IR are represented in
--   different backends.
--   
--   v: Type The type of the leaf values in our AST; used almost
--   exclusively for column values, over which queries can be
--   parameterized. The output of the parser phase will use
--   <tt>UnpreparedValue b</tt> for the leaves, and most backends will then
--   transform the AST to interpret those values and consequently change
--   <tt>v</tt> to be <tt>SQLExpression b</tt>
--   
--   r: BackendType -&gt; Type Joins across backends mean that the
--   aforementioned <tt>b</tt> parameter won't be the same throughout the
--   entire tree; at some point we will have an <tt>AnyBackend</tt> used to
--   encapsulate a branch that uses a different <tt>b</tt>. We still want,
--   however, to be able to parameterize the values of the leaves in that
--   separate branch, and that's what the <tt>r</tt> parameter is for. We
--   also use <tt>UnpreparedValue</tt> here during the parsing phase,
--   meaning all leaf values will be <tt>UnpreparedValue b</tt> for their
--   respective backend <tt>b</tt>, and most backends will then transform
--   their AST, cutting all such remote branches, and therefore using
--   <tt>Const Void</tt> for <tt>r</tt>.
module Hasura.RQL.IR.Select
data QueryDB (b :: BackendType) (r :: Type) v
QDBMultipleRows :: AnnSimpleSelectG b r v -> QueryDB (b :: BackendType) (r :: Type) v
QDBSingleRow :: AnnSimpleSelectG b r v -> QueryDB (b :: BackendType) (r :: Type) v
QDBAggregation :: AnnAggregateSelectG b r v -> QueryDB (b :: BackendType) (r :: Type) v
QDBConnection :: ConnectionSelect b r v -> QueryDB (b :: BackendType) (r :: Type) v
QDBStreamMultipleRows :: AnnSimpleStreamSelectG b r v -> QueryDB (b :: BackendType) (r :: Type) v
type AnnSimpleSelectG b r v = AnnSelectG b (AnnFieldG b r) v
type AnnAggregateSelectG b r v = AnnSelectG b (TableAggregateFieldG b r) v
type AnnSimpleStreamSelectG b r v = AnnSelectStreamG b (AnnFieldG b r) v
type AnnSimpleSelect b = AnnSimpleSelectG b Void (SQLExpression b)
type AnnAggregateSelect b = AnnAggregateSelectG b Void (SQLExpression b)
type AnnSimpleStreamSelect b = AnnSimpleStreamSelectG b Void (SQLExpression b)
data ConnectionSelect (b :: BackendType) (r :: Type) v
ConnectionSelect :: XRelay b -> PrimaryKeyColumns b -> Maybe (NonEmpty (ConnectionSplit b v)) -> Maybe ConnectionSlice -> AnnSelectG b (ConnectionField b r) v -> ConnectionSelect (b :: BackendType) (r :: Type) v
[$sel:_csXRelay:ConnectionSelect] :: ConnectionSelect (b :: BackendType) (r :: Type) v -> XRelay b
[$sel:_csPrimaryKeyColumns:ConnectionSelect] :: ConnectionSelect (b :: BackendType) (r :: Type) v -> PrimaryKeyColumns b
[$sel:_csSplit:ConnectionSelect] :: ConnectionSelect (b :: BackendType) (r :: Type) v -> Maybe (NonEmpty (ConnectionSplit b v))
[$sel:_csSlice:ConnectionSelect] :: ConnectionSelect (b :: BackendType) (r :: Type) v -> Maybe ConnectionSlice
[$sel:_csSelect:ConnectionSelect] :: ConnectionSelect (b :: BackendType) (r :: Type) v -> AnnSelectG b (ConnectionField b r) v
data ConnectionSplit (b :: BackendType) v
ConnectionSplit :: ConnectionSplitKind -> v -> OrderByItemG b (AnnotatedOrderByElement b v) -> ConnectionSplit (b :: BackendType) v
[$sel:_csKind:ConnectionSplit] :: ConnectionSplit (b :: BackendType) v -> ConnectionSplitKind
[$sel:_csValue:ConnectionSplit] :: ConnectionSplit (b :: BackendType) v -> v
[$sel:_csOrderBy:ConnectionSplit] :: ConnectionSplit (b :: BackendType) v -> OrderByItemG b (AnnotatedOrderByElement b v)
data ConnectionSlice
SliceFirst :: Int -> ConnectionSlice
SliceLast :: Int -> ConnectionSlice
data ConnectionSplitKind
CSKBefore :: ConnectionSplitKind
CSKAfter :: ConnectionSplitKind

-- | captures a remote relationship's selection and the necessary context
data RemoteRelationshipSelect b r
RemoteRelationshipSelect :: HashMap FieldName (DBJoinField b) -> r -> RemoteRelationshipSelect b r

-- | The fields on the table that are required for the join condition of
--   the remote relationship
[$sel:_rrsLHSJoinFields:RemoteRelationshipSelect] :: RemoteRelationshipSelect b r -> HashMap FieldName (DBJoinField b)

-- | The field that captures the relationship r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
[$sel:_rrsRelationship:RemoteRelationshipSelect] :: RemoteRelationshipSelect b r -> r
data AnnFieldG (b :: BackendType) (r :: Type) v
AFColumn :: AnnColumnField b v -> AnnFieldG (b :: BackendType) (r :: Type) v
AFObjectRelation :: ObjectRelationSelectG b r v -> AnnFieldG (b :: BackendType) (r :: Type) v
AFArrayRelation :: ArraySelectG b r v -> AnnFieldG (b :: BackendType) (r :: Type) v
AFComputedField :: XComputedField b -> ComputedFieldName -> ComputedFieldSelect b r v -> AnnFieldG (b :: BackendType) (r :: Type) v

-- | A remote relationship field
AFRemote :: RemoteRelationshipSelect b r -> AnnFieldG (b :: BackendType) (r :: Type) v
AFNodeId :: XRelay b -> SourceName -> TableName b -> PrimaryKeyColumns b -> AnnFieldG (b :: BackendType) (r :: Type) v
AFExpression :: Text -> AnnFieldG (b :: BackendType) (r :: Type) v

-- | Nested object.
AFNestedObject :: AnnNestedObjectSelectG b r v -> AnnFieldG (b :: BackendType) (r :: Type) v

-- | Nested array
AFNestedArray :: XNestedObjects b -> AnnNestedArraySelectG b r v -> AnnFieldG (b :: BackendType) (r :: Type) v
type AnnField b = AnnFieldG b Void (SQLExpression b)
type AnnFields b = AnnFieldsG b Void (SQLExpression b)
mkAnnColumnField :: Column backend -> ColumnType backend -> AnnRedactionExp backend v -> Maybe (ScalarSelectionArguments backend) -> AnnFieldG backend r v
mkAnnColumnFieldAsText :: ColumnInfo backend -> AnnFieldG backend r v
traverseSourceRelationshipSelection :: (Applicative f, Backend backend) => (vf backend -> f (vg backend)) -> SourceRelationshipSelection backend r vf -> f (SourceRelationshipSelection backend r vg)
data TableAggregateFieldG (b :: BackendType) (r :: Type) v
TAFAgg :: AggregateFields b v -> TableAggregateFieldG (b :: BackendType) (r :: Type) v
TAFNodes :: XNodesAgg b -> AnnFieldsG b r v -> TableAggregateFieldG (b :: BackendType) (r :: Type) v
TAFGroupBy :: XGroupBy b -> GroupByG b r v -> TableAggregateFieldG (b :: BackendType) (r :: Type) v
TAFExp :: Text -> TableAggregateFieldG (b :: BackendType) (r :: Type) v
data AggregateField (b :: BackendType) v
AFCount :: CountType b v -> AggregateField (b :: BackendType) v
AFOp :: AggregateOp b v -> AggregateField (b :: BackendType) v
AFExp :: Text -> AggregateField (b :: BackendType) v
data AggregateOp (b :: BackendType) v
AggregateOp :: Text -> SelectionFields b v -> AggregateOp (b :: BackendType) v
[$sel:_aoOp:AggregateOp] :: AggregateOp (b :: BackendType) v -> Text
[$sel:_aoFields:AggregateOp] :: AggregateOp (b :: BackendType) v -> SelectionFields b v
data GroupByG (b :: BackendType) r v
GroupByG :: [GroupKeyField b] -> Fields (GroupByField b r v) -> GroupByG (b :: BackendType) r v
[$sel:_gbgKeys:GroupByG] :: GroupByG (b :: BackendType) r v -> [GroupKeyField b]
[$sel:_gbgFields:GroupByG] :: GroupByG (b :: BackendType) r v -> Fields (GroupByField b r v)
data GroupByField (b :: BackendType) r v
GBFGroupKey :: Fields (GroupKeyField b) -> GroupByField (b :: BackendType) r v
GBFAggregate :: AggregateFields b v -> GroupByField (b :: BackendType) r v
GBFNodes :: AnnFieldsG b r v -> GroupByField (b :: BackendType) r v
GBFExp :: Text -> GroupByField (b :: BackendType) r v
data GroupKeyField (b :: BackendType)
GKFColumn :: Column b -> GroupKeyField (b :: BackendType)
GKFExp :: Text -> GroupKeyField (b :: BackendType)

-- | Types of fields that can be selected in a user query.
data SelectionField (b :: BackendType) v
SFCol :: Column b -> ColumnType b -> AnnRedactionExp b v -> SelectionField (b :: BackendType) v
SFComputedField :: ComputedFieldName -> ComputedFieldScalarSelect b v -> SelectionField (b :: BackendType) v
SFExp :: Text -> SelectionField (b :: BackendType) v
type TableAggregateField b = TableAggregateFieldG b Void (SQLExpression b)
type TableAggregateFields b = TableAggregateFieldsG b Void (SQLExpression b)
type TableAggregateFieldsG b r v = Fields (TableAggregateFieldG b r v)
type SelectionFields b v = Fields (SelectionField b v)
type AggregateFields b v = Fields (AggregateField b v)
type AnnFieldsG b r v = Fields (AnnFieldG b r v)
data ConnectionField (b :: BackendType) (r :: Type) v
ConnectionTypename :: Text -> ConnectionField (b :: BackendType) (r :: Type) v
ConnectionPageInfo :: PageInfoFields -> ConnectionField (b :: BackendType) (r :: Type) v
ConnectionEdges :: EdgeFields b r v -> ConnectionField (b :: BackendType) (r :: Type) v
data PageInfoField
PageInfoTypename :: Text -> PageInfoField
PageInfoHasNextPage :: PageInfoField
PageInfoHasPreviousPage :: PageInfoField
PageInfoStartCursor :: PageInfoField
PageInfoEndCursor :: PageInfoField
data EdgeField (b :: BackendType) (r :: Type) v
EdgeTypename :: Text -> EdgeField (b :: BackendType) (r :: Type) v
EdgeCursor :: EdgeField (b :: BackendType) (r :: Type) v
EdgeNode :: AnnFieldsG b r v -> EdgeField (b :: BackendType) (r :: Type) v
type ConnectionFields b r v = Fields (ConnectionField b r v)
type PageInfoFields = Fields PageInfoField
type EdgeFields b r v = Fields (EdgeField b r v)
data AnnColumnField (b :: BackendType) v
AnnColumnField :: Column b -> ColumnType b -> Bool -> Maybe (ScalarSelectionArguments b) -> AnnRedactionExp b v -> AnnColumnField (b :: BackendType) v
[$sel:_acfColumn:AnnColumnField] :: AnnColumnField (b :: BackendType) v -> Column b
[$sel:_acfType:AnnColumnField] :: AnnColumnField (b :: BackendType) v -> ColumnType b

-- | If this field is <a>True</a>, columns are explicitly casted to
--   <tt>text</tt> when fetched, which avoids an issue that occurs because
--   we donâ€™t currently have proper support for array types. See
--   <a>https://github.com/hasura/graphql-engine/pull/3198</a> for more
--   details.
[$sel:_acfAsText:AnnColumnField] :: AnnColumnField (b :: BackendType) v -> Bool

-- | Arguments of this column's selection. See
--   <a>ScalarSelectionArguments</a>
[$sel:_acfArguments:AnnColumnField] :: AnnColumnField (b :: BackendType) v -> Maybe (ScalarSelectionArguments b)

-- | This type is used to determine whether the column should be redacted
[$sel:_acfRedactionExpression:AnnColumnField] :: AnnColumnField (b :: BackendType) v -> AnnRedactionExp b v
data ComputedFieldScalarSelect (b :: BackendType) v
ComputedFieldScalarSelect :: FunctionName b -> FunctionArgsExp b v -> ScalarType b -> Maybe (ScalarSelectionArguments b) -> AnnRedactionExp b v -> ComputedFieldScalarSelect (b :: BackendType) v
[$sel:_cfssFunction:ComputedFieldScalarSelect] :: ComputedFieldScalarSelect (b :: BackendType) v -> FunctionName b
[$sel:_cfssArguments:ComputedFieldScalarSelect] :: ComputedFieldScalarSelect (b :: BackendType) v -> FunctionArgsExp b v
[$sel:_cfssType:ComputedFieldScalarSelect] :: ComputedFieldScalarSelect (b :: BackendType) v -> ScalarType b
[$sel:_cfssScalarArguments:ComputedFieldScalarSelect] :: ComputedFieldScalarSelect (b :: BackendType) v -> Maybe (ScalarSelectionArguments b)

-- | This type is used to determine whether the computed field should be
--   redacted
[$sel:_cfssRedactionExpression:ComputedFieldScalarSelect] :: ComputedFieldScalarSelect (b :: BackendType) v -> AnnRedactionExp b v
data ComputedFieldSelect (b :: BackendType) (r :: Type) v
CFSScalar :: ComputedFieldScalarSelect b v -> ComputedFieldSelect (b :: BackendType) (r :: Type) v
CFSTable :: JsonAggSelect -> AnnSimpleSelectG b r v -> ComputedFieldSelect (b :: BackendType) (r :: Type) v
type ArrayRelationSelectG b r v = AnnRelationSelectG b (AnnSimpleSelectG b r v)
type ArrayAggregateSelectG b r v = AnnRelationSelectG b (AnnAggregateSelectG b r v)
type ArrayConnectionSelect b r v = AnnRelationSelectG b (ConnectionSelect b r v)
type ArrayAggregateSelect b = ArrayAggregateSelectG b Void (SQLExpression b)
data AnnObjectSelectG (b :: BackendType) (r :: Type) v
AnnObjectSelectG :: AnnFieldsG b r v -> SelectFromG b v -> AnnBoolExp b v -> AnnObjectSelectG (b :: BackendType) (r :: Type) v
[$sel:_aosFields:AnnObjectSelectG] :: AnnObjectSelectG (b :: BackendType) (r :: Type) v -> AnnFieldsG b r v
[$sel:_aosTarget:AnnObjectSelectG] :: AnnObjectSelectG (b :: BackendType) (r :: Type) v -> SelectFromG b v
[$sel:_aosTargetFilter:AnnObjectSelectG] :: AnnObjectSelectG (b :: BackendType) (r :: Type) v -> AnnBoolExp b v
type AnnObjectSelect b r = AnnObjectSelectG b r (SQLExpression b)
type ObjectRelationSelectG b r v = AnnRelationSelectG b (AnnObjectSelectG b r v)
type ObjectRelationSelect b = ObjectRelationSelectG b Void (SQLExpression b)
data ArraySelectG (b :: BackendType) (r :: Type) v
ASSimple :: ArrayRelationSelectG b r v -> ArraySelectG (b :: BackendType) (r :: Type) v
ASAggregate :: ArrayAggregateSelectG b r v -> ArraySelectG (b :: BackendType) (r :: Type) v
ASConnection :: ArrayConnectionSelect b r v -> ArraySelectG (b :: BackendType) (r :: Type) v
type ArraySelect b = ArraySelectG b Void (SQLExpression b)
type ArraySelectFieldsG b r v = Fields (ArraySelectG b r v)

-- | Captures the selection set of a remote source relationship.
data SourceRelationshipSelection (b :: BackendType) (r :: Type) (vf :: BackendType -> Type)
SourceRelationshipObject :: AnnObjectSelectG b r (vf b) -> SourceRelationshipSelection (b :: BackendType) (r :: Type) (vf :: BackendType -> Type)
SourceRelationshipArray :: AnnSimpleSelectG b r (vf b) -> SourceRelationshipSelection (b :: BackendType) (r :: Type) (vf :: BackendType -> Type)
SourceRelationshipArrayAggregate :: AnnAggregateSelectG b r (vf b) -> SourceRelationshipSelection (b :: BackendType) (r :: Type) (vf :: BackendType -> Type)

-- | A relationship to a remote source. <tt>vf</tt> (could use a better
--   name) is analogous to <tt>v</tt> in other IR types such as
--   <a>AnnFieldG</a>. vf's kind is (BackendType -&gt; Type) instead of v's
--   <a>Type</a> so that <tt>v</tt> of <a>AnnFieldG</a> can be specific to
--   the backend that it captures (<tt>b</tt> of an AnnFieldG changes as we
--   walk down the IR branches which capture relationships to other
--   databases)
data RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType)
RemoteSourceSelect :: SourceName -> SourceConfig tgt -> SourceRelationshipSelection tgt r vf -> HashMap FieldName (ScalarType tgt, Column tgt) -> StringifyNumbers -> RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType)
[$sel:_rssName:RemoteSourceSelect] :: RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType) -> SourceName
[$sel:_rssConfig:RemoteSourceSelect] :: RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType) -> SourceConfig tgt
[$sel:_rssSelection:RemoteSourceSelect] :: RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType) -> SourceRelationshipSelection tgt r vf

-- | Additional information about the source's join columns: (ScalarType
--   tgt) so that the remote can interpret the join values coming from src
--   (Column tgt) so that an appropriate join condition / IN clause can be
--   built by the remote
[$sel:_rssJoinMapping:RemoteSourceSelect] :: RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType) -> HashMap FieldName (ScalarType tgt, Column tgt)
[$sel:_rssStringifyNums:RemoteSourceSelect] :: RemoteSourceSelect (r :: Type) (vf :: BackendType -> Type) (tgt :: BackendType) -> StringifyNumbers
data AnnNestedObjectSelectG (b :: BackendType) (r :: Type) v
AnnNestedObjectSelectG :: XNestedObjects b -> Column b -> AnnFieldsG b r v -> AnnNestedObjectSelectG (b :: BackendType) (r :: Type) v
[$sel:_anosSupportsNestedObjects:AnnNestedObjectSelectG] :: AnnNestedObjectSelectG (b :: BackendType) (r :: Type) v -> XNestedObjects b
[$sel:_anosColumn:AnnNestedObjectSelectG] :: AnnNestedObjectSelectG (b :: BackendType) (r :: Type) v -> Column b
[$sel:_anosFields:AnnNestedObjectSelectG] :: AnnNestedObjectSelectG (b :: BackendType) (r :: Type) v -> AnnFieldsG b r v
type AnnNestedObjectSelect b r = AnnNestedObjectSelectG b r (SQLExpression b)
data AnnNestedArraySelectG (b :: BackendType) (r :: Type) v
ANASSimple :: AnnFieldG b r v -> AnnNestedArraySelectG (b :: BackendType) (r :: Type) v
ANASAggregate :: AnnAggregateSelectG b r v -> AnnNestedArraySelectG (b :: BackendType) (r :: Type) v
type AnnNestedArraySelect b r = AnnNestedArraySelectG b r (SQLExpression b)

-- | If argument positional index is less than or equal to length of
--   <tt>positional</tt> arguments then insert the value in
--   <tt>positional</tt> arguments else insert the value with argument name
--   in <tt>named</tt> arguments
insertFunctionArg :: FunctionArgName -> Int -> a -> FunctionArgsExpG a -> FunctionArgsExpG a

-- | The "distinct" input field inside "count" aggregate field
--   
--   count ( distinct: Boolean ): Int
data CountDistinct
SelectCountDistinct :: CountDistinct
SelectCountNonDistinct :: CountDistinct
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.Select.ConnectionSlice
instance GHC.Generics.Generic Hasura.RQL.IR.Select.ConnectionSlice
instance GHC.Classes.Eq Hasura.RQL.IR.Select.ConnectionSlice
instance GHC.Show.Show Hasura.RQL.IR.Select.ConnectionSlice
instance Data.Hashable.Class.Hashable Hasura.RQL.IR.Select.ConnectionSplitKind
instance GHC.Generics.Generic Hasura.RQL.IR.Select.ConnectionSplitKind
instance GHC.Classes.Eq Hasura.RQL.IR.Select.ConnectionSplitKind
instance GHC.Show.Show Hasura.RQL.IR.Select.ConnectionSplitKind
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ConnectionSplit b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ConnectionSplit b)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.ConnectionSplit b v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ConnectionSplit b)
instance Data.Traversable.Traversable (Hasura.RQL.IR.Select.RemoteRelationshipSelect b)
instance Data.Foldable.Foldable (Hasura.RQL.IR.Select.RemoteRelationshipSelect b)
instance GHC.Base.Functor (Hasura.RQL.IR.Select.RemoteRelationshipSelect b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show r) => GHC.Show.Show (Hasura.RQL.IR.Select.RemoteRelationshipSelect b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq r) => GHC.Classes.Eq (Hasura.RQL.IR.Select.RemoteRelationshipSelect b r)
instance GHC.Classes.Eq Hasura.RQL.IR.Select.PageInfoField
instance GHC.Show.Show Hasura.RQL.IR.Select.PageInfoField
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnColumnField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnColumnField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnColumnField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.SelectionField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.SelectionField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.SelectionField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AggregateOp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AggregateOp b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.AggregateOp b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ComputedFieldSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ComputedFieldSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ComputedFieldSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.GroupByField b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.GroupByField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.GroupByField b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.GroupByG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.GroupByG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.GroupByG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.TableAggregateFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.TableAggregateFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.TableAggregateFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.EdgeField b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.EdgeField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.EdgeField b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ConnectionField b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ConnectionField b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ConnectionField b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ConnectionSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ConnectionSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ConnectionSelect b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.ArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.ArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.ArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnFieldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.QueryDB b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.QueryDB b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.QueryDB b r)
instance GHC.Generics.Generic (Hasura.RQL.IR.Select.QueryDB b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b (Hasura.RQL.IR.Select.ConnectionField b r) v), GHC.Classes.Eq Hasura.RQL.IR.Select.ConnectionSlice, GHC.Classes.Eq (Hasura.RQL.IR.Select.ConnectionSplit b v), GHC.Classes.Eq (Hasura.RQL.Types.Column.PrimaryKeyColumns b)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ConnectionSelect b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AnnSelectG.AnnSelectG b (Hasura.RQL.IR.Select.ConnectionField b r) v), GHC.Show.Show Hasura.RQL.IR.Select.ConnectionSlice, GHC.Show.Show (Hasura.RQL.IR.Select.ConnectionSplit b v), GHC.Show.Show (Hasura.RQL.Types.Column.PrimaryKeyColumns b)) => GHC.Show.Show (Hasura.RQL.IR.Select.ConnectionSelect b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq (Hasura.RQL.IR.OrderBy.OrderByItemG b (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b v))) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ConnectionSplit b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v, GHC.Show.Show (Hasura.RQL.IR.OrderBy.OrderByItemG b (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b v))) => GHC.Show.Show (Hasura.RQL.IR.Select.ConnectionSplit b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnColumnField b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ArraySelectG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldSelect b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ObjectRelationSelectG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.RemoteRelationshipSelect b r), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AnnColumnField b v), GHC.Show.Show (Hasura.RQL.IR.Select.ArraySelectG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldSelect b r v), GHC.Show.Show (Hasura.RQL.IR.Select.ObjectRelationSelectG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.RemoteRelationshipSelect b r), GHC.Show.Show (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AggregateFields b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldsG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.GroupByG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.TableAggregateFieldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AggregateFields b v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldsG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.GroupByG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Select.TableAggregateFieldG b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Select.AggregateField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Select.AggregateField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Select.AggregateField b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Backend.CountType b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AggregateOp b v), GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AggregateField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Backend.CountType b v), GHC.Show.Show (Hasura.RQL.IR.Select.AggregateOp b v), GHC.Show.Show v) => GHC.Show.Show (Hasura.RQL.IR.Select.AggregateField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.SelectionFields b v), GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AggregateOp b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.SelectionFields b v), GHC.Show.Show v) => GHC.Show.Show (Hasura.RQL.IR.Select.AggregateOp b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.GroupByField b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.GroupKeyField b)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.GroupByG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.GroupByField b r v), GHC.Show.Show (Hasura.RQL.IR.Select.GroupKeyField b)) => GHC.Show.Show (Hasura.RQL.IR.Select.GroupByG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.GroupKeyField b), GHC.Classes.Eq (Hasura.RQL.IR.Select.AggregateField b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.GroupByField b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.GroupKeyField b), GHC.Show.Show (Hasura.RQL.IR.Select.AggregateField b v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Select.GroupByField b r v)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.IR.Select.GroupKeyField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.IR.Select.GroupKeyField b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.Types.Backend.FunctionArgumentExp b v), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v), GHC.Classes.Eq v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.SelectionField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.Types.Backend.FunctionArgumentExp b v), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v), GHC.Show.Show v) => GHC.Show.Show (Hasura.RQL.IR.Select.SelectionField b v)
instance GHC.Classes.Eq (Hasura.RQL.IR.Select.EdgeFields b r v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ConnectionField b r v)
instance GHC.Show.Show (Hasura.RQL.IR.Select.EdgeFields b r v) => GHC.Show.Show (Hasura.RQL.IR.Select.ConnectionField b r v)
instance GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldsG b r v) => GHC.Classes.Eq (Hasura.RQL.IR.Select.EdgeField b r v)
instance GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldsG b r v) => GHC.Show.Show (Hasura.RQL.IR.Select.EdgeField b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnColumnField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnColumnField b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v, GHC.Show.Show (Hasura.RQL.Types.Backend.FunctionArgumentExp b v), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq (Hasura.RQL.Types.Backend.FunctionArgumentExp b v), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSimpleSelectG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ComputedFieldSelect b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AnnSimpleSelectG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldScalarSelect b v)) => GHC.Show.Show (Hasura.RQL.IR.Select.ComputedFieldSelect b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.From.SelectFromG b v), GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnObjectSelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.From.SelectFromG b v), GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnObjectSelectG b r v)
instance (GHC.Classes.Eq (Hasura.RQL.IR.Select.ArrayRelationSelectG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ArrayAggregateSelectG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.ArrayConnectionSelect b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.ArraySelectG b r v)
instance (GHC.Show.Show (Hasura.RQL.IR.Select.ArrayRelationSelectG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.ArrayAggregateSelectG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.ArrayConnectionSelect b r v)) => GHC.Show.Show (Hasura.RQL.IR.Select.ArraySelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnAggregateSelectG b r (vf b)), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnObjectSelectG b r (vf b)), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnSimpleSelectG b r (vf b))) => GHC.Classes.Eq (Hasura.RQL.IR.Select.SourceRelationshipSelection b r vf)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AnnAggregateSelectG b r (vf b)), GHC.Show.Show (Hasura.RQL.IR.Select.AnnObjectSelectG b r (vf b)), GHC.Show.Show (Hasura.RQL.IR.Select.AnnSimpleSelectG b r (vf b))) => GHC.Show.Show (Hasura.RQL.IR.Select.SourceRelationshipSelection b r vf)
instance (Hasura.RQL.Types.Backend.Backend tgt, GHC.Classes.Eq (Hasura.RQL.IR.Select.SourceRelationshipSelection tgt r vf)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.RemoteSourceSelect r vf tgt)
instance (Hasura.RQL.Types.Backend.Backend tgt, GHC.Show.Show (Hasura.RQL.IR.Select.SourceRelationshipSelection tgt r vf), GHC.Show.Show (Hasura.RQL.Types.SourceConfiguration.SourceConfig tgt)) => GHC.Show.Show (Hasura.RQL.IR.Select.RemoteSourceSelect r vf tgt)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnAggregateSelectG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnAggregateSelectG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Select.AnnNestedArraySelectG b r v)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.QueryDB b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ConnectionSelect b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.AnnFieldG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.TableAggregateFieldG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.GroupByG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.GroupByField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ConnectionField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.EdgeField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ComputedFieldSelect b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.AnnObjectSelectG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.ArraySelectG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.AnnNestedObjectSelectG b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Bifoldable.Bifoldable (Hasura.RQL.IR.Select.AnnNestedArraySelectG b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable v, Data.Hashable.Class.Hashable (Hasura.RQL.IR.OrderBy.OrderByItemG b (Hasura.RQL.IR.Select.OrderBy.AnnotatedOrderByElement b v))) => Data.Hashable.Class.Hashable (Hasura.RQL.IR.Select.ConnectionSplit b v)

module Hasura.RQL.IR.Select.Lenses
asnStrfyNum :: forall b_ihTy4 f_ihTy5 v_ihTy6. Lens' (AnnSelectG b_ihTy4 f_ihTy5 v_ihTy6) StringifyNumbers
asnPerm :: forall b_ihTy4 f_ihTy5 v_ihTy6. Lens' (AnnSelectG b_ihTy4 f_ihTy5 v_ihTy6) (TablePermG b_ihTy4 v_ihTy6)
asnNamingConvention :: forall b_ihTy4 f_ihTy5 v_ihTy6. Lens' (AnnSelectG b_ihTy4 f_ihTy5 v_ihTy6) (Maybe NamingCase)
asnFrom :: forall b_ihTy4 f_ihTy5 v_ihTy6. Lens' (AnnSelectG b_ihTy4 f_ihTy5 v_ihTy6) (SelectFromG b_ihTy4 v_ihTy6)
asnFields :: forall b_ihTy4 f_ihTy5 v_ihTy6 f_aj4XI. Lens (AnnSelectG b_ihTy4 f_ihTy5 v_ihTy6) (AnnSelectG b_ihTy4 f_aj4XI v_ihTy6) (Fields (f_ihTy5 v_ihTy6)) (Fields (f_aj4XI v_ihTy6))
asnArgs :: forall b_ihTy4 f_ihTy5 v_ihTy6. Lens' (AnnSelectG b_ihTy4 f_ihTy5 v_ihTy6) (SelectArgsG b_ihTy4 v_ihTy6)
saWhere :: forall b_ifFeT v_ifFeU. Lens' (SelectArgsG b_ifFeT v_ifFeU) (Maybe (AnnBoolExp b_ifFeT v_ifFeU))
saOrderBy :: forall b_ifFeT v_ifFeU. Lens' (SelectArgsG b_ifFeT v_ifFeU) (Maybe (NonEmpty (AnnotatedOrderByItemG b_ifFeT v_ifFeU)))
saOffset :: forall b_ifFeT v_ifFeU. Lens' (SelectArgsG b_ifFeT v_ifFeU) (Maybe Int64)
saLimit :: forall b_ifFeT v_ifFeU. Lens' (SelectArgsG b_ifFeT v_ifFeU) (Maybe Int)
saDistinct :: forall b_ifFeT v_ifFeU. Lens' (SelectArgsG b_ifFeT v_ifFeU) (Maybe (NonEmpty (AnnDistinctColumn b_ifFeT v_ifFeU)))
aosTargetFilter :: forall b_ij57w r_ij57x v_ij57y. Lens' (AnnObjectSelectG b_ij57w r_ij57x v_ij57y) (AnnBoolExp b_ij57w v_ij57y)
aosTarget :: forall b_ij57w r_ij57x v_ij57y. Lens' (AnnObjectSelectG b_ij57w r_ij57x v_ij57y) (SelectFromG b_ij57w v_ij57y)
aosFields :: forall b_ij57w r_ij57x v_ij57y r_aj57I. Lens (AnnObjectSelectG b_ij57w r_ij57x v_ij57y) (AnnObjectSelectG b_ij57w r_aj57I v_ij57y) (AnnFieldsG b_ij57w r_ij57x v_ij57y) (AnnFieldsG b_ij57w r_aj57I v_ij57y)
anosSupportsNestedObjects :: forall b_ij5aq r_ij5ar v_ij5as. Lens' (AnnNestedObjectSelectG b_ij5aq r_ij5ar v_ij5as) (XNestedObjects b_ij5aq)
anosFields :: forall b_ij5aq r_ij5ar v_ij5as r_aj5aw v_aj5ax. Lens (AnnNestedObjectSelectG b_ij5aq r_ij5ar v_ij5as) (AnnNestedObjectSelectG b_ij5aq r_aj5aw v_aj5ax) (AnnFieldsG b_ij5aq r_ij5ar v_ij5as) (AnnFieldsG b_ij5aq r_aj5aw v_aj5ax)
anosColumn :: forall b_ij5aq r_ij5ar v_ij5as. Lens' (AnnNestedObjectSelectG b_ij5aq r_ij5ar v_ij5as) (Column b_ij5aq)
csXRelay :: forall b_ij5dv r_ij5dw v_ij5dx. Lens' (ConnectionSelect b_ij5dv r_ij5dw v_ij5dx) (XRelay b_ij5dv)
csSplit :: forall b_ij5dv r_ij5dw v_ij5dx. Lens' (ConnectionSelect b_ij5dv r_ij5dw v_ij5dx) (Maybe (NonEmpty (ConnectionSplit b_ij5dv v_ij5dx)))
csSlice :: forall b_ij5dv r_ij5dw v_ij5dx. Lens' (ConnectionSelect b_ij5dv r_ij5dw v_ij5dx) (Maybe ConnectionSlice)
csSelect :: forall b_ij5dv r_ij5dw v_ij5dx r_aj5dG. Lens (ConnectionSelect b_ij5dv r_ij5dw v_ij5dx) (ConnectionSelect b_ij5dv r_aj5dG v_ij5dx) (AnnSelectG b_ij5dv (ConnectionField b_ij5dv r_ij5dw) v_ij5dx) (AnnSelectG b_ij5dv (ConnectionField b_ij5dv r_aj5dG) v_ij5dx)
csPrimaryKeyColumns :: forall b_ij5dv r_ij5dw v_ij5dx. Lens' (ConnectionSelect b_ij5dv r_ij5dw v_ij5dx) (PrimaryKeyColumns b_ij5dv)
aarRelationshipName :: forall b_ihTxX a_ihTxY. Lens' (AnnRelationSelectG b_ihTxX a_ihTxY) RelName
aarNullable :: forall b_ihTxX a_ihTxY. Lens' (AnnRelationSelectG b_ihTxX a_ihTxY) Nullable
aarColumnMapping :: forall b_ihTxX a_ihTxY b_aj5ix. Lens (AnnRelationSelectG b_ihTxX a_ihTxY) (AnnRelationSelectG b_aj5ix a_ihTxY) (HashMap (Column b_ihTxX) (Column b_ihTxX)) (HashMap (Column b_aj5ix) (Column b_aj5ix))
aarAnnSelect :: forall b_ihTxX a_ihTxY a_aj5iw. Lens (AnnRelationSelectG b_ihTxX a_ihTxY) (AnnRelationSelectG b_ihTxX a_aj5iw) a_ihTxY a_aj5iw
gbgKeys :: forall b_ij5m4 r_ij5m5 v_ij5m6. Lens' (GroupByG b_ij5m4 r_ij5m5 v_ij5m6) [GroupKeyField b_ij5m4]
gbgFields :: forall b_ij5m4 r_ij5m5 v_ij5m6 r_aj5me v_aj5mf. Lens (GroupByG b_ij5m4 r_ij5m5 v_ij5m6) (GroupByG b_ij5m4 r_aj5me v_aj5mf) (Fields (GroupByField b_ij5m4 r_ij5m5 v_ij5m6)) (Fields (GroupByField b_ij5m4 r_aj5me v_aj5mf))
_AOCComputedField :: forall b_ib03V v_ib03W. Prism' (AnnotatedOrderByElement b_ib03V v_ib03W) (ComputedFieldOrderBy b_ib03V v_ib03W)
_AOCArrayAggregation :: forall b_ib03V v_ib03W. Prism' (AnnotatedOrderByElement b_ib03V v_ib03W) (RelInfo b_ib03V, AnnBoolExp b_ib03V v_ib03W, AnnotatedAggregateOrderBy b_ib03V v_ib03W)
_AOCObjectRelation :: forall b_ib03V v_ib03W. Prism' (AnnotatedOrderByElement b_ib03V v_ib03W) (RelInfo b_ib03V, AnnBoolExp b_ib03V v_ib03W, AnnotatedOrderByElement b_ib03V v_ib03W)
_AOCColumn :: forall b_ib03V v_ib03W. Prism' (AnnotatedOrderByElement b_ib03V v_ib03W) (ColumnInfo b_ib03V, AnnRedactionExp b_ib03V v_ib03W)
_AFExpression :: forall b_ij57F r_ij57G v_ij57H. Prism' (AnnFieldG b_ij57F r_ij57G v_ij57H) Text
_AFNodeId :: forall b_ij57F r_ij57G v_ij57H. Prism' (AnnFieldG b_ij57F r_ij57G v_ij57H) (XRelay b_ij57F, SourceName, TableName b_ij57F, PrimaryKeyColumns b_ij57F)
_AFRemote :: forall b_ij57F r_ij57G v_ij57H. Prism' (AnnFieldG b_ij57F r_ij57G v_ij57H) (RemoteRelationshipSelect b_ij57F r_ij57G)
_AFComputedField :: forall b_ij57F r_ij57G v_ij57H. Prism' (AnnFieldG b_ij57F r_ij57G v_ij57H) (XComputedField b_ij57F, ComputedFieldName, ComputedFieldSelect b_ij57F r_ij57G v_ij57H)
_AFArrayRelation :: forall b_ij57F r_ij57G v_ij57H. Prism' (AnnFieldG b_ij57F r_ij57G v_ij57H) (ArraySelectG b_ij57F r_ij57G v_ij57H)
_AFObjectRelation :: forall b_ij57F r_ij57G v_ij57H. Prism' (AnnFieldG b_ij57F r_ij57G v_ij57H) (ObjectRelationSelectG b_ij57F r_ij57G v_ij57H)
_AFColumn :: forall b_ij57F r_ij57G v_ij57H. Prism' (AnnFieldG b_ij57F r_ij57G v_ij57H) (AnnColumnField b_ij57F v_ij57H)
_TAFExp :: forall b_ij5G2 r_ij5G3 v_ij5G4. Prism' (TableAggregateFieldG b_ij5G2 r_ij5G3 v_ij5G4) Text
_TAFNodes :: forall b_ij5G2 r_ij5G3 v_ij5G4. Prism' (TableAggregateFieldG b_ij5G2 r_ij5G3 v_ij5G4) (XNodesAgg b_ij5G2, AnnFieldsG b_ij5G2 r_ij5G3 v_ij5G4)
_TAFAgg :: forall b_ij5G2 r_ij5G3 v_ij5G4. Prism' (TableAggregateFieldG b_ij5G2 r_ij5G3 v_ij5G4) (AggregateFields b_ij5G2 v_ij5G4)
_GBFExp :: forall b_ij5mb r_ij5mc v_ij5md. Prism' (GroupByField b_ij5mb r_ij5mc v_ij5md) Text
_GBFNodes :: forall b_ij5mb r_aj5LL v_ij5md r_ij5mc. Prism (GroupByField b_ij5mb r_aj5LL v_ij5md) (GroupByField b_ij5mb r_ij5mc v_ij5md) (AnnFieldsG b_ij5mb r_aj5LL v_ij5md) (AnnFieldsG b_ij5mb r_ij5mc v_ij5md)
_GBFAggregate :: forall b_ij5mb r_ij5mc v_ij5md. Prism' (GroupByField b_ij5mb r_ij5mc v_ij5md) (AggregateFields b_ij5mb v_ij5md)
_GBFGroupKey :: forall b_ij5mb r_ij5mc v_ij5md. Prism' (GroupByField b_ij5mb r_ij5mc v_ij5md) (Fields (GroupKeyField b_ij5mb))
_ConnectionEdges :: forall b_aj5R5 r_aj5R6 v_aj5R7 b_ij5dD r_ij5dE v_ij5dF. Prism (ConnectionField b_aj5R5 r_aj5R6 v_aj5R7) (ConnectionField b_ij5dD r_ij5dE v_ij5dF) (EdgeFields b_aj5R5 r_aj5R6 v_aj5R7) (EdgeFields b_ij5dD r_ij5dE v_ij5dF)
_ConnectionPageInfo :: forall b_ij5dD r_ij5dE v_ij5dF. Prism' (ConnectionField b_ij5dD r_ij5dE v_ij5dF) PageInfoFields
_ConnectionTypename :: forall b_ij5dD r_ij5dE v_ij5dF. Prism' (ConnectionField b_ij5dD r_ij5dE v_ij5dF) Text
_EdgeNode :: forall b_aj5Vb r_aj5Vc v_aj5Vd b_ij5QW r_ij5QX v_ij5QY. Prism (EdgeField b_aj5Vb r_aj5Vc v_aj5Vd) (EdgeField b_ij5QW r_ij5QX v_ij5QY) (AnnFieldsG b_aj5Vb r_aj5Vc v_aj5Vd) (AnnFieldsG b_ij5QW r_ij5QX v_ij5QY)
_EdgeCursor :: forall b_ij5QW r_ij5QX v_ij5QY. Prism' (EdgeField b_ij5QW r_ij5QX v_ij5QY) ()
_EdgeTypename :: forall b_ij5QW r_ij5QX v_ij5QY. Prism' (EdgeField b_ij5QW r_ij5QX v_ij5QY) Text

module Hasura.RQL.IR.Returning
data MutFldG (b :: BackendType) (r :: Type) v
MCount :: MutFldG (b :: BackendType) (r :: Type) v
MExp :: Text -> MutFldG (b :: BackendType) (r :: Type) v
MRet :: AnnFieldsG b r v -> MutFldG (b :: BackendType) (r :: Type) v
type MutFld b = MutFldG b Void (SQLExpression b)
type MutFldsG b r v = Fields (MutFldG b r v)
data MutationOutputG (b :: BackendType) (r :: Type) v
MOutMultirowFields :: MutFldsG b r v -> MutationOutputG (b :: BackendType) (r :: Type) v
MOutSinglerowObject :: AnnFieldsG b r v -> MutationOutputG (b :: BackendType) (r :: Type) v
type MutationOutput b = MutationOutputG b Void (SQLExpression b)
type MutFlds b = MutFldsG b Void (SQLExpression b)
buildEmptyMutResp :: MutationOutput backend -> EncJSON
hasNestedFld :: MutationOutputG backend r a -> Bool
_MRet :: forall b_ajajk r_ajajl v_ajajm b_aj74y r_aj74z v_aj74A. Prism (MutFldG b_ajajk r_ajajl v_ajajm) (MutFldG b_aj74y r_aj74z v_aj74A) (AnnFieldsG b_ajajk r_ajajl v_ajajm) (AnnFieldsG b_aj74y r_aj74z v_aj74A)
_MExp :: forall b_aj74y r_aj74z v_aj74A. Prism' (MutFldG b_aj74y r_aj74z v_aj74A) Text
_MCount :: forall b_aj74y r_aj74z v_aj74A. Prism' (MutFldG b_aj74y r_aj74z v_aj74A) ()
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Returning.MutFldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Returning.MutFldG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Returning.MutFldG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Returning.MutationOutputG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Returning.MutationOutputG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Returning.MutationOutputG b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Returning.MutFldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Returning.MutFldG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Returning.MutFldsG b r v), GHC.Show.Show (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Returning.MutationOutputG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Returning.MutFldsG b r v), GHC.Classes.Eq (Hasura.RQL.IR.Select.AnnFieldsG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Returning.MutationOutputG b r v)

module Hasura.RQL.IR.Update
data AnnotatedUpdateG (b :: BackendType) (r :: Type) v
AnnotatedUpdateG :: TableName b -> AnnBoolExp b v -> AnnBoolExp b v -> UpdateVariant b v -> MutationOutputG b r v -> [ColumnInfo b] -> Maybe NamingCase -> Maybe (ValidateInput ResolvedWebhook) -> AnnotatedUpdateG (b :: BackendType) (r :: Type) v
[_auTable] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> TableName b
[_auUpdatePermissions] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> AnnBoolExp b v
[_auCheck] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> AnnBoolExp b v
[_auUpdateVariant] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> UpdateVariant b v

-- | Selection set
[_auOutput] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> MutationOutputG b r v
[_auAllCols] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> [ColumnInfo b]
[_auNamingConvention] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> Maybe NamingCase
[_auValidateInput] :: AnnotatedUpdateG (b :: BackendType) (r :: Type) v -> Maybe (ValidateInput ResolvedWebhook)
type AnnotatedUpdate b = AnnotatedUpdateG b Void (SQLExpression b)
auValidateInput :: forall b_ajc64 r_ajc65 v_ajc66. Lens' (AnnotatedUpdateG b_ajc64 r_ajc65 v_ajc66) (Maybe (ValidateInput ResolvedWebhook))
auUpdateVariant :: forall b_ajc64 r_ajc65 v_ajc66. Lens' (AnnotatedUpdateG b_ajc64 r_ajc65 v_ajc66) (UpdateVariant b_ajc64 v_ajc66)
auUpdatePermissions :: forall b_ajc64 r_ajc65 v_ajc66. Lens' (AnnotatedUpdateG b_ajc64 r_ajc65 v_ajc66) (AnnBoolExp b_ajc64 v_ajc66)
auTable :: forall b_ajc64 r_ajc65 v_ajc66. Lens' (AnnotatedUpdateG b_ajc64 r_ajc65 v_ajc66) (TableName b_ajc64)
auOutput :: forall b_ajc64 r_ajc65 v_ajc66 r_ajdKU. Lens (AnnotatedUpdateG b_ajc64 r_ajc65 v_ajc66) (AnnotatedUpdateG b_ajc64 r_ajdKU v_ajc66) (MutationOutputG b_ajc64 r_ajc65 v_ajc66) (MutationOutputG b_ajc64 r_ajdKU v_ajc66)
auNamingConvention :: forall b_ajc64 r_ajc65 v_ajc66. Lens' (AnnotatedUpdateG b_ajc64 r_ajc65 v_ajc66) (Maybe NamingCase)
auCheck :: forall b_ajc64 r_ajc65 v_ajc66. Lens' (AnnotatedUpdateG b_ajc64 r_ajc65 v_ajc66) (AnnBoolExp b_ajc64 v_ajc66)
auAllCols :: forall b_ajc64 r_ajc65 v_ajc66. Lens' (AnnotatedUpdateG b_ajc64 r_ajc65 v_ajc66) [ColumnInfo b_ajc64]
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Update.AnnotatedUpdateG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Update.AnnotatedUpdateG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Update.AnnotatedUpdateG b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show v, GHC.Show.Show r, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Show.Show (Hasura.RQL.Types.Backend.UpdateVariant b v), GHC.Show.Show (Hasura.RQL.IR.Returning.MutationOutputG b r v)) => GHC.Show.Show (Hasura.RQL.IR.Update.AnnotatedUpdateG b r v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq v, GHC.Classes.Eq r, GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnBoolExp b v), GHC.Classes.Eq (Hasura.RQL.Types.Backend.UpdateVariant b v), GHC.Classes.Eq (Hasura.RQL.IR.Returning.MutationOutputG b r v)) => GHC.Classes.Eq (Hasura.RQL.IR.Update.AnnotatedUpdateG b r v)


-- | Internal representation of an insertion in a database table.
--   
--   What makes this specific mutation tricky is that we support recursive
--   insertions, across local relationships. Because local joins come in
--   two different kinds (object relationships and array relations), and
--   because for each table we expose two root different root fields
--   (insert_one and insert), we distinguish between *single row inserts*
--   and *multi rows inserts*.
--   
--   TODO: the distinction between single-row inserts and multi-rows
--   inserts does not need to be enforced the way it currently is, with
--   booleans and different types. The distinction could be made in the
--   translation layer, if need be.
module Hasura.RQL.IR.Insert

-- | Overall representation of an insert mutation, corresponding to one
--   root field in our mutation, including the parsed selection set of the
--   mutation's output. For historical reasons, it will always contain a
--   <a>MultiObjectInsert</a>, whether the root mutation is a single row or
--   not, and will distinguish between them using a boolean field.
data AnnotatedInsert (b :: BackendType) (r :: Type) v
AnnotatedInsert :: Text -> Bool -> MultiObjectInsert b v -> MutationOutputG b r v -> Maybe NamingCase -> AnnotatedInsert (b :: BackendType) (r :: Type) v
[_aiFieldName] :: AnnotatedInsert (b :: BackendType) (r :: Type) v -> Text
[_aiIsSingle] :: AnnotatedInsert (b :: BackendType) (r :: Type) v -> Bool
[_aiData] :: AnnotatedInsert (b :: BackendType) (r :: Type) v -> MultiObjectInsert b v
[_aiOutput] :: AnnotatedInsert (b :: BackendType) (r :: Type) v -> MutationOutputG b r v
[_aiNamingConvention] :: AnnotatedInsert (b :: BackendType) (r :: Type) v -> Maybe NamingCase

-- | One individual insert, one node from the tree. The <tt>f</tt>
--   parameter is used to construct the container for the values to be
--   inserted: <a>Single</a> for a single-row insert, '[]' for a multi-row
--   insert.
data AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type)
AnnotatedInsertData :: f (AnnotatedInsertRow b v) -> TableName b -> (AnnBoolExp b v, Maybe (AnnBoolExp b v)) -> [ColumnInfo b] -> Maybe (NESeq (Column b)) -> ExtraTableMetadata b -> PreSetColsG b v -> BackendInsert b v -> Maybe (ValidateInput ResolvedWebhook) -> AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type)
[_aiInsertObject] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> f (AnnotatedInsertRow b v)
[_aiTableName] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> TableName b
[_aiCheckCondition] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> (AnnBoolExp b v, Maybe (AnnBoolExp b v))
[_aiTableColumns] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> [ColumnInfo b]
[_aiPrimaryKey] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> Maybe (NESeq (Column b))
[_aiExtraTableMetadata] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> ExtraTableMetadata b
[_aiPresetValues] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> PreSetColsG b v
[_aiBackendInsert] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> BackendInsert b v
[_aiValidateInput] :: AnnotatedInsertData (b :: BackendType) (f :: Type -> Type) (v :: Type) -> Maybe (ValidateInput ResolvedWebhook)

-- | Ad-hoc helper. We differientate between single row inserts
--   (<tt>SingleObjIns</tt>) and multiple row inserts
--   (<tt>MultiObjIns</tt>), but both use the same underlying
--   representation: <tt>AnnIns</tt>. The only difference is which functor
--   is used as a parameter. We use '[]' for <tt>MultiObjIns</tt>, and we
--   use this trivial <a>Single</a> for <tt>SingleObjIns</tt>.
newtype Single a
Single :: a -> Single a
[unSingle] :: Single a -> a
type SingleObjectInsert b v = AnnotatedInsertData b Single v
type MultiObjectInsert b v = AnnotatedInsertData b [] v

-- | An insert item. The object and array relationships are not unavailable
--   when 'XNestedInserts b = XDisable'
data AnnotatedInsertField (b :: BackendType) v
AIColumn :: (Column b, v) -> AnnotatedInsertField (b :: BackendType) v
AIObjectRelationship :: XNestedInserts b -> ObjectRelationInsert b v -> AnnotatedInsertField (b :: BackendType) v
AIArrayRelationship :: XNestedInserts b -> ArrayRelationInsert b v -> AnnotatedInsertField (b :: BackendType) v

-- | One individual row to be inserted. Contains the columns' values and
--   all the matching recursive relationship inserts.
type AnnotatedInsertRow b v = [AnnotatedInsertField b v]

-- | One individual relationship. Unlike other types, this one is not
--   parameterized by the type of the leaves <tt>v</tt>, but by the kind of
--   insert has to be performed: multi-row or single row. See
--   <a>ObjectRelationInsert</a> and <a>ArrayRelationInsert</a>.
data RelationInsert (b :: BackendType) a
RelationInsert :: a -> RelInfo b -> RelationInsert (b :: BackendType) a
[_riInsertData] :: RelationInsert (b :: BackendType) a -> a
[_riRelationInfo] :: RelationInsert (b :: BackendType) a -> RelInfo b

-- | Insert across an object relationship. Object relationships are 1:1
--   relationships across tables; an insert across such a relationship can
--   only insert one single row at a time; <tt>RelIns</tt> is therefore
--   parameterized by a <a>SingleObjectInsert</a>.
type ObjectRelationInsert b v = RelationInsert b (SingleObjectInsert b v)

-- | Insert across an array relationship. Array relationships are 1:*
--   relationships across tables; an insert across such a relationship may
--   therefore contain multiple rows; <tt>RelIns</tt> is therefore
--   parameterized by a <a>MultiObjectInsert</a>.
type ArrayRelationInsert b v = RelationInsert b (MultiObjectInsert b v)

-- | Old-style representation used for non-recursive insertions. This is
--   the representation used by RQL.DML, instead of the new fancy recursive
--   one present in this file. Postgres supports both representations, and
--   actually translates recursive queries that do not have any
--   relationships into this representation first.
data InsertQueryP1 (b :: BackendType)
InsertQueryP1 :: TableName b -> [Column b] -> [[SQLExpression b]] -> Maybe (OnConflictClause b (SQLExpression b)) -> (AnnBoolExpSQL b, Maybe (AnnBoolExpSQL b)) -> MutationOutput b -> [ColumnInfo b] -> InsertQueryP1 (b :: BackendType)
[iqp1Table] :: InsertQueryP1 (b :: BackendType) -> TableName b
[iqp1Cols] :: InsertQueryP1 (b :: BackendType) -> [Column b]
[iqp1Tuples] :: InsertQueryP1 (b :: BackendType) -> [[SQLExpression b]]
[iqp1Conflict] :: InsertQueryP1 (b :: BackendType) -> Maybe (OnConflictClause b (SQLExpression b))
[iqp1CheckCond] :: InsertQueryP1 (b :: BackendType) -> (AnnBoolExpSQL b, Maybe (AnnBoolExpSQL b))
[iqp1Output] :: InsertQueryP1 (b :: BackendType) -> MutationOutput b
[iqp1AllCols] :: InsertQueryP1 (b :: BackendType) -> [ColumnInfo b]
aiOutput :: forall b_ajfhb r_ajfhc v_ajfhd r_ajluh. Lens (AnnotatedInsert b_ajfhb r_ajfhc v_ajfhd) (AnnotatedInsert b_ajfhb r_ajluh v_ajfhd) (MutationOutputG b_ajfhb r_ajfhc v_ajfhd) (MutationOutputG b_ajfhb r_ajluh v_ajfhd)
aiNamingConvention :: forall b_ajfhb r_ajfhc v_ajfhd. Lens' (AnnotatedInsert b_ajfhb r_ajfhc v_ajfhd) (Maybe NamingCase)
aiIsSingle :: forall b_ajfhb r_ajfhc v_ajfhd. Lens' (AnnotatedInsert b_ajfhb r_ajfhc v_ajfhd) Bool
aiFieldName :: forall b_ajfhb r_ajfhc v_ajfhd. Lens' (AnnotatedInsert b_ajfhb r_ajfhc v_ajfhd) Text
aiData :: forall b_ajfhb r_ajfhc v_ajfhd. Lens' (AnnotatedInsert b_ajfhb r_ajfhc v_ajfhd) (MultiObjectInsert b_ajfhb v_ajfhd)
_AIArrayRelationship :: forall b_ajfh1 v_ajfh2. Prism' (AnnotatedInsertField b_ajfh1 v_ajfh2) (XNestedInserts b_ajfh1, ArrayRelationInsert b_ajfh1 v_ajfh2)
_AIObjectRelationship :: forall b_ajfh1 v_ajfh2. Prism' (AnnotatedInsertField b_ajfh1 v_ajfh2) (XNestedInserts b_ajfh1, ObjectRelationInsert b_ajfh1 v_ajfh2)
_AIColumn :: forall b_ajfh1 v_ajfh2. Prism' (AnnotatedInsertField b_ajfh1 v_ajfh2) (Column b_ajfh1, v_ajfh2)
getInsertColumns :: AnnotatedInsertRow b v -> [(Column b, v)]
getInsertObjectRelationships :: AnnotatedInsertRow b v -> [ObjectRelationInsert b v]
getInsertArrayRelationships :: AnnotatedInsertRow b v -> [ArrayRelationInsert b v]
instance Data.Traversable.Traversable Hasura.RQL.IR.Insert.Single
instance Data.Foldable.Foldable Hasura.RQL.IR.Insert.Single
instance GHC.Base.Functor Hasura.RQL.IR.Insert.Single
instance Data.Traversable.Traversable (Hasura.RQL.IR.Insert.RelationInsert b)
instance Data.Foldable.Foldable (Hasura.RQL.IR.Insert.RelationInsert b)
instance GHC.Base.Functor (Hasura.RQL.IR.Insert.RelationInsert b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.RQL.IR.Insert.RelationInsert b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.IR.Insert.RelationInsert b a)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Insert.AnnotatedInsertField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Insert.AnnotatedInsertField b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Insert.AnnotatedInsertField b)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Traversable.Traversable f) => Data.Traversable.Traversable (Hasura.RQL.IR.Insert.AnnotatedInsertData b f)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Foldable.Foldable f) => Data.Foldable.Foldable (Hasura.RQL.IR.Insert.AnnotatedInsertData b f)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Base.Functor f) => GHC.Base.Functor (Hasura.RQL.IR.Insert.AnnotatedInsertData b f)
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Insert.AnnotatedInsert b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Insert.AnnotatedInsert b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Insert.AnnotatedInsert b r)

module Hasura.RQL.IR.Delete
data AnnDelG (b :: BackendType) (r :: Type) v
AnnDel :: TableName b -> (AnnBoolExp b v, AnnBoolExp b v) -> MutationOutputG b r v -> [ColumnInfo b] -> Maybe NamingCase -> Maybe (ValidateInput ResolvedWebhook) -> Bool -> AnnDelG (b :: BackendType) (r :: Type) v
[_adTable] :: AnnDelG (b :: BackendType) (r :: Type) v -> TableName b
[_adWhere] :: AnnDelG (b :: BackendType) (r :: Type) v -> (AnnBoolExp b v, AnnBoolExp b v)
[_adOutput] :: AnnDelG (b :: BackendType) (r :: Type) v -> MutationOutputG b r v
[_adAllCols] :: AnnDelG (b :: BackendType) (r :: Type) v -> [ColumnInfo b]
[_adNamingConvention] :: AnnDelG (b :: BackendType) (r :: Type) v -> Maybe NamingCase
[_adValidateInput] :: AnnDelG (b :: BackendType) (r :: Type) v -> Maybe (ValidateInput ResolvedWebhook)
[_adIsDeleteByPk] :: AnnDelG (b :: BackendType) (r :: Type) v -> Bool
type AnnDel b = AnnDelG b Void (SQLExpression b)
adWhere :: forall b_ajp64 r_ajp65 v_ajp66. Lens' (AnnDelG b_ajp64 r_ajp65 v_ajp66) (AnnBoolExp b_ajp64 v_ajp66, AnnBoolExp b_ajp64 v_ajp66)
adValidateInput :: forall b_ajp64 r_ajp65 v_ajp66. Lens' (AnnDelG b_ajp64 r_ajp65 v_ajp66) (Maybe (ValidateInput ResolvedWebhook))
adTable :: forall b_ajp64 r_ajp65 v_ajp66. Lens' (AnnDelG b_ajp64 r_ajp65 v_ajp66) (TableName b_ajp64)
adOutput :: forall b_ajp64 r_ajp65 v_ajp66 r_ajqAC. Lens (AnnDelG b_ajp64 r_ajp65 v_ajp66) (AnnDelG b_ajp64 r_ajqAC v_ajp66) (MutationOutputG b_ajp64 r_ajp65 v_ajp66) (MutationOutputG b_ajp64 r_ajqAC v_ajp66)
adNamingConvention :: forall b_ajp64 r_ajp65 v_ajp66. Lens' (AnnDelG b_ajp64 r_ajp65 v_ajp66) (Maybe NamingCase)
adIsDeleteByPk :: forall b_ajp64 r_ajp65 v_ajp66. Lens' (AnnDelG b_ajp64 r_ajp65 v_ajp66) Bool
adAllCols :: forall b_ajp64 r_ajp65 v_ajp66. Lens' (AnnDelG b_ajp64 r_ajp65 v_ajp66) [ColumnInfo b_ajp64]
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Delete.AnnDelG b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Delete.AnnDelG b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Delete.AnnDelG b r)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), GHC.Show.Show (Hasura.RQL.IR.Returning.MutationOutputG b r a), GHC.Show.Show a) => GHC.Show.Show (Hasura.RQL.IR.Delete.AnnDelG b r a)


-- | Postgres Translate Delete
--   
--   Tranlates an IR delete term to a Postgres SQL DELETE statement.
--   
--   See <a>execDeleteQuery</a>.
module Hasura.Backends.Postgres.Translate.Delete
mkDelete :: Backend ('Postgres pgKind) => AnnDel ('Postgres pgKind) -> SQLDelete


-- | Postgres Translate Types
--   
--   Intermediary / helper types used for translating IR to Postgres SQL.
module Hasura.Backends.Postgres.Translate.Types
data SourcePrefixes
SourcePrefixes :: Identifier -> Identifier -> SourcePrefixes

-- | Current source prefix
[_pfThis] :: SourcePrefixes -> Identifier

-- | Base table source row identifier to generate the table's column
--   identifiers for computed field function input parameters
[_pfBase] :: SourcePrefixes -> Identifier

-- | Select portion of rows generated by the query using limit and offset
data SelectSlicing
SelectSlicing :: Maybe Int -> Maybe Int64 -> SelectSlicing
[_ssLimit] :: SelectSlicing -> Maybe Int
[_ssOffset] :: SelectSlicing -> Maybe Int64
data DistinctAndOrderByExpr
ASorting :: (OrderByExp, Maybe DistinctExpr) -> Maybe (OrderByExp, Maybe DistinctExpr) -> DistinctAndOrderByExpr

-- | Sorting with -- Note [Optimizing queries using limit/offset])
data SelectSorting
NoSorting :: Maybe DistinctExpr -> SelectSorting
Sorting :: DistinctAndOrderByExpr -> SelectSorting
data SortingAndSlicing
SortingAndSlicing :: SelectSorting -> SelectSlicing -> SortingAndSlicing
data SelectSource
SelectSource :: Identifier -> FromItem -> BoolExp -> SortingAndSlicing -> SelectSource
noSortingAndSlicing :: SortingAndSlicing
orderByForJsonAgg :: SelectSource -> Maybe OrderByExp
data ApplySortingAndSlicing
ApplySortingAndSlicing :: (Maybe OrderByExp, SelectSlicing, Maybe DistinctExpr) -> (Maybe OrderByExp, SelectSlicing, Maybe DistinctExpr) -> ApplySortingAndSlicing
applySortingAndSlicing :: SortingAndSlicing -> ApplySortingAndSlicing
data SelectNode
SelectNode :: InsOrdHashMap ColumnAlias SQLExp -> JoinTree -> SelectNode
data ObjectSelectSource
ObjectSelectSource :: Identifier -> FromItem -> BoolExp -> ObjectSelectSource
objectSelectSourceToSelectSource :: ObjectSelectSource -> SelectSource
data ObjectRelationSource
ObjectRelationSource :: RelName -> HashMap PGCol PGCol -> ObjectSelectSource -> Nullable -> ObjectRelationSource
[_orsRelationshipName] :: ObjectRelationSource -> RelName
[_orsRelationMapping] :: ObjectRelationSource -> HashMap PGCol PGCol
[_orsSelectSource] :: ObjectRelationSource -> ObjectSelectSource
[_orsNullable] :: ObjectRelationSource -> Nullable
data ArrayRelationSource
ArrayRelationSource :: TableAlias -> HashMap PGCol PGCol -> SelectSource -> ArrayRelationSource
data MultiRowSelectNode
MultiRowSelectNode :: [Extractor] -> SelectNode -> MultiRowSelectNode
[_mrsnTopExtractors] :: MultiRowSelectNode -> [Extractor]
[_mrsnSelectNode] :: MultiRowSelectNode -> SelectNode
data ComputedFieldTableSetSource
ComputedFieldTableSetSource :: FieldName -> SelectSource -> ComputedFieldTableSetSource
data ArrayConnectionSource
ArrayConnectionSource :: TableAlias -> HashMap PGCol PGCol -> Maybe BoolExp -> Maybe ConnectionSlice -> SelectSource -> ArrayConnectionSource
data JoinTree
JoinTree :: HashMap ObjectRelationSource SelectNode -> HashMap ArrayRelationSource MultiRowSelectNode -> HashMap ArrayConnectionSource MultiRowSelectNode -> HashMap ComputedFieldTableSetSource MultiRowSelectNode -> JoinTree
[_jtObjectRelations] :: JoinTree -> HashMap ObjectRelationSource SelectNode
[_jtArrayRelations] :: JoinTree -> HashMap ArrayRelationSource MultiRowSelectNode
[_jtArrayConnections] :: JoinTree -> HashMap ArrayConnectionSource MultiRowSelectNode
[_jtComputedFieldTableSets] :: JoinTree -> HashMap ComputedFieldTableSetSource MultiRowSelectNode
data PermissionLimitSubQuery

-- | Permission limit
PLSQRequired :: Int -> PermissionLimitSubQuery
PLSQNotRequired :: PermissionLimitSubQuery
type SimilarArrayFields = HashMap FieldName [FieldName]
newtype CustomSQLCTEs
CustomSQLCTEs :: HashMap TableAlias (InterpolatedQuery SQLExp) -> CustomSQLCTEs
[getCustomSQLCTEs] :: CustomSQLCTEs -> HashMap TableAlias (InterpolatedQuery SQLExp)
data SelectWriter
SelectWriter :: JoinTree -> CustomSQLCTEs -> SelectWriter
[_swJoinTree] :: SelectWriter -> JoinTree
[_swCustomSQLCTEs] :: SelectWriter -> CustomSQLCTEs
newtype NativeQueryFreshIdStore
NativeQueryFreshIdStore :: Int -> NativeQueryFreshIdStore
[nqNextFreshId] :: NativeQueryFreshIdStore -> Int
initialNativeQueryFreshIdStore :: NativeQueryFreshIdStore
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SourcePrefixes
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SourcePrefixes
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.SourcePrefixes
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.SelectSource
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.ObjectRelationSource
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ObjectRelationSource
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.ArrayRelationSource
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ArrayRelationSource
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.ArrayConnectionSource
instance GHC.Generics.Generic Hasura.Backends.Postgres.Translate.Types.ArrayConnectionSource
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.SelectNode
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectNode
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.MultiRowSelectNode
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.MultiRowSelectNode
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.JoinTree
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.JoinTree
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.PermissionLimitSubQuery
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.PermissionLimitSubQuery
instance GHC.Base.Monoid Hasura.Backends.Postgres.Translate.Types.CustomSQLCTEs
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.CustomSQLCTEs
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.CustomSQLCTEs
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.CustomSQLCTEs
instance GHC.Enum.Enum Hasura.Backends.Postgres.Translate.Types.NativeQueryFreshIdStore
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.NativeQueryFreshIdStore
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.NativeQueryFreshIdStore
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.SelectSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.SelectSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ObjectRelationSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ArrayRelationSource
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Types.ArrayConnectionSource
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.SelectWriter
instance GHC.Base.Monoid Hasura.Backends.Postgres.Translate.Types.SelectWriter
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.SelectNode
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.MultiRowSelectNode
instance GHC.Base.Semigroup Hasura.Backends.Postgres.Translate.Types.JoinTree
instance GHC.Base.Monoid Hasura.Backends.Postgres.Translate.Types.JoinTree
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ArrayConnectionSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ComputedFieldTableSetSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ArrayRelationSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ObjectRelationSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.ObjectSelectSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SelectSource
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SortingAndSlicing
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SelectSorting
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.DistinctAndOrderByExpr
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SelectSlicing
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Translate.Types.SourcePrefixes


-- | Stuff gutted from Translate.Select
module Hasura.Backends.Postgres.Translate.Select.Internal.JoinTree

-- | This is the lowest level function which deals with <tt>MonadWriter
--   SelectWriter</tt>, which contains <tt>JoinTree</tt> whose purpose is
--   to essentially create the selection tree across relationships.
--   
--   Each type of relationship uses a different kind of update function;
--   see <a>withWriteObjectRelation</a>, <a>withWriteArrayRelation</a>,
--   <a>withWriteArrayConnection</a>, and
--   <a>withWriteComputedFieldTableSet</a>.
--   
--   See the definition of <a>JoinTree</a> for details before diving
--   further (particularly its components and Monoid instance).
withWriteJoinTree :: MonadWriter SelectWriter m => (JoinTree -> b -> JoinTree) -> m (a, b) -> m a
withWriteObjectRelation :: MonadWriter SelectWriter m => m (ObjectRelationSource, InsOrdHashMap ColumnAlias SQLExp, a) -> m a
withWriteArrayRelation :: MonadWriter SelectWriter m => m (ArrayRelationSource, Extractor, InsOrdHashMap ColumnAlias SQLExp, a) -> m a
withWriteArrayConnection :: MonadWriter SelectWriter m => m (ArrayConnectionSource, Extractor, InsOrdHashMap ColumnAlias SQLExp, a) -> m a
withWriteComputedFieldTableSet :: MonadWriter SelectWriter m => m (ComputedFieldTableSetSource, Extractor, InsOrdHashMap ColumnAlias SQLExp, a) -> m a


-- | Stuff gutted from Translate.Select
module Hasura.Backends.Postgres.Translate.Select.Internal.Aliases

-- | Generate alias for order by extractors
mkAnnOrderByAlias :: TableIdentifier -> FieldName -> SimilarArrayFields -> AnnotatedOrderByElement ('Postgres pgKind) v -> ColumnAlias
mkObjectRelationTableAlias :: TableIdentifier -> RelName -> TableIdentifier
mkComputedFieldTableIdentifier :: TableIdentifier -> FieldName -> TableIdentifier
mkBaseTableIdentifier :: TableIdentifier -> TableIdentifier
mkBaseTableAlias :: TableAlias -> TableAlias
contextualizeBaseTableColumn :: TableIdentifier -> PGCol -> ColumnAlias
contextualizeField :: TableIdentifier -> FieldName -> ColumnAlias
contextualizeAggregateInput :: TableIdentifier -> FieldName -> FieldName -> ColumnAlias
mkAggregateOrderByAlias :: AnnotatedAggregateOrderBy ('Postgres pgKind) v -> ColumnAlias
mkOrderByFieldName :: ToTxt a => a -> FieldName
mkArrayRelationSourcePrefix :: TableIdentifier -> FieldName -> HashMap FieldName [FieldName] -> FieldName -> TableIdentifier
mkArrayRelationAlias :: FieldName -> HashMap FieldName [FieldName] -> FieldName -> TableAlias


-- | Stuff gutted from Translate.Select.
module Hasura.Backends.Postgres.Translate.Select.Internal.Helpers

-- | First element extractor expression from given record set For example:-
--   To get first "id" column from given row set, the function generates
--   the SQL expression AS `(array_agg("id"))[1]`
mkFirstElementExp :: SQLExp -> SQLExp

-- | Last element extractor expression from given record set. For example:-
--   To get first "id" column from given row set, the function generates
--   the SQL expression AS `(array_agg("id"))[array_length(array_agg("id"),
--   1)]`
mkLastElementExp :: SQLExp -> SQLExp
cursorIdentifier :: Identifier
startCursorIdentifier :: Identifier
endCursorIdentifier :: Identifier
hasPreviousPageIdentifier :: Identifier
hasNextPageIdentifier :: Identifier
pageInfoSelectAlias :: TableAlias
pageInfoSelectAliasIdentifier :: TableIdentifier
cursorsSelectAlias :: TableAlias
cursorsSelectAliasIdentifier :: TableIdentifier
encodeBase64 :: SQLExp -> SQLExp
fromTableRowArgs :: TableIdentifier -> FunctionArgsExpG (ArgumentExp SQLExp) -> FunctionArgs

-- | Given a <tt>NativeQueryName</tt>, what should we call the CTE
--   generated for it?
nativeQueryNameToAlias :: NativeQueryName -> Int -> TableAlias

-- | Converts a function name to an <a>Identifier</a>.
--   
--   If the schema name is public, it will just use its name, otherwise it
--   will prefix it by the schema name.
functionToIdentifier :: QualifiedFunction -> Identifier
withJsonBuildObj :: FieldName -> [SQLExp] -> (ColumnAlias, SQLExp)

-- | Forces aggregation
withForceAggregation :: TypeAnn -> SQLExp -> SQLExp

-- | unwrap any emitted TopLevelCTEs for custom sql from the Writer and
--   combine them with a <tt>Select</tt> to create a <tt>SelectWith</tt>
selectToSelectWith :: Writer CustomSQLCTEs Select -> SelectWith

-- | convert map of CustomSQL CTEs into named TopLevelCTEs
customSQLToTopLevelCTEs :: CustomSQLCTEs -> [(TableAlias, TopLevelCTE)]

-- | convert map of CustomSQL CTEs into named InnerCTEs
customSQLToInnerCTEs :: CustomSQLCTEs -> [(TableAlias, InnerCTE)]
toQuery :: SelectWithG TopLevelCTE -> Query


-- | This module defines the type class <a>PostgresAnnotatedFieldJSON</a>.
module Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON
class PostgresAnnotatedFieldJSON (pgKind :: PostgresKind)
annRowToJson :: PostgresAnnotatedFieldJSON pgKind => FieldName -> [(FieldName, SQLExp)] -> (ColumnAlias, SQLExp)
instance Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON.PostgresAnnotatedFieldJSON 'Hasura.RQL.Types.BackendType.Vanilla
instance Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON.PostgresAnnotatedFieldJSON 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.Translate.Select.AnnotatedFieldJSON.PostgresAnnotatedFieldJSON 'Hasura.RQL.Types.BackendType.Cockroach


-- | This module contains worker definitions pertaining to generating
--   <tt>Select</tt> AST nodes.
--   
--   NOTE: <a>generateSQLSelect</a> is mutually recursive with
--   <a>connectionToSelectWith</a>, thus these two cohabitate in this
--   module.
module Hasura.Backends.Postgres.Translate.Select.Internal.GenerateSelect
class PostgresGenerateSQLSelect (pgKind :: PostgresKind)
generateSQLSelect :: PostgresGenerateSQLSelect pgKind => BoolExp -> SelectSource -> SelectNode -> Select

-- | Create a select query
generateSQLSelectFromArrayNode :: forall pgKind. PostgresGenerateSQLSelect pgKind => SelectSource -> MultiRowSelectNode -> BoolExp -> Select
connectionToSelectWith :: forall pgKind. PostgresGenerateSQLSelect pgKind => TableAlias -> ArrayConnectionSource -> MultiRowSelectNode -> SelectWithG Select
instance Hasura.Backends.Postgres.Translate.Select.Internal.GenerateSelect.PostgresGenerateSQLSelect 'Hasura.RQL.Types.BackendType.Vanilla
instance Hasura.Backends.Postgres.Translate.Select.Internal.GenerateSelect.PostgresGenerateSQLSelect 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.Translate.Select.Internal.GenerateSelect.PostgresGenerateSQLSelect 'Hasura.RQL.Types.BackendType.Cockroach


-- | Extractors are a pair of an SQL expression and an alias; they get
--   translated like "[SELECT ...] <a>expr</a> as <a>alias</a>"
module Hasura.Backends.Postgres.Translate.Select.Internal.Extractor

-- | Creates node extractors for all of the columns and computed fields
--   used in aggregated fields. The ColumnAliases for all the extractors
--   are namespaced aliases using the 'contextualize*` functions so that
--   none of the extractors names will conflict with one another (for
--   example, if a column name is the same as a field name (eg
--   <tt>nodes</tt>))
aggregateFieldsToExtractorExps :: forall pgKind. Backend ('Postgres pgKind) => TableIdentifier -> AggregateFields ('Postgres pgKind) SQLExp -> [(ColumnAlias, SQLExp)]
mkAggregateOrderByExtractorAndFields :: forall pgKind. Backend ('Postgres pgKind) => TableIdentifier -> AnnotatedAggregateOrderBy ('Postgres pgKind) SQLExp -> (Extractor, AggregateFields ('Postgres pgKind) SQLExp)
mkRawComputedFieldExpression :: forall pgKind. Backend ('Postgres pgKind) => TableIdentifier -> ComputedFieldScalarSelect ('Postgres pgKind) SQLExp -> SQLExp
withJsonAggExtr :: PermissionLimitSubQuery -> Maybe OrderByExp -> ColumnAlias -> SQLExp
asSingleRowExtr :: ColumnAlias -> SQLExp
asJsonAggExtr :: JsonAggSelect -> ColumnAlias -> PermissionLimitSubQuery -> Maybe OrderByExp -> Extractor
withColumnOp :: Maybe ColumnOp -> SQLExp -> SQLExp


-- | This module relates to the processing of Order-By clauses.
module Hasura.Backends.Postgres.Translate.Select.Internal.OrderBy
processOrderByItems :: forall pgKind m. (MonadReader StringifyNumbers m, MonadWriter SelectWriter m, Backend ('Postgres pgKind)) => TableIdentifier -> Qual -> FieldName -> SimilarArrayFields -> Maybe (NonEmpty (AnnDistinctColumn ('Postgres pgKind) SQLExp)) -> Maybe (NonEmpty (AnnotatedOrderByItem ('Postgres pgKind))) -> m ([(ColumnAlias, SQLExp)], SelectSorting, Maybe SQLExp)

module Hasura.Backends.DataConnector.Plan.QueryPlan

-- | Map a 'QueryDB <a>DataConnector</a> term into a <a>Plan</a>
mkQueryPlan :: forall m r. (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r) => QueryDB 'DataConnector Void (UnpreparedValue 'DataConnector) -> m (Plan QueryRequest QueryResponse)
translateAnnSimpleSelectToQueryRequest :: forall m r. (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r) => AnnSimpleSelectG 'DataConnector Void (UnpreparedValue 'DataConnector) -> m QueryRequest
translateAnnAggregateSelectToQueryRequest :: forall m r. (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r) => AnnAggregateSelectG 'DataConnector Void (UnpreparedValue 'DataConnector) -> m QueryRequest
translateAnnFields :: (MonadState state m, Has TableRelationships state, Has RedactionExpressionState state, Has InterpolatedQueries state, MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r) => FieldPrefix -> TargetName -> AnnFieldsG 'DataConnector Void (UnpreparedValue 'DataConnector) -> m (HashMap FieldName Field)
reshapeSimpleSelectRows :: MonadError QErr m => Cardinality -> AnnFieldsG 'DataConnector Void v -> QueryResponse -> m Encoding
reshapeTableAggregateFields :: MonadError QErr m => TableAggregateFieldsG 'DataConnector Void v -> QueryResponse -> m Encoding
reshapeAnnFields :: MonadError QErr m => FieldPrefix -> AnnFieldsG 'DataConnector Void v -> HashMap FieldName FieldValue -> m Encoding
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.QueryPlan.FieldsAndAggregates
instance GHC.Show.Show Hasura.Backends.DataConnector.Plan.QueryPlan.FieldsAndAggregates
instance GHC.Base.Semigroup Hasura.Backends.DataConnector.Plan.QueryPlan.FieldsAndAggregates
instance GHC.Base.Monoid Hasura.Backends.DataConnector.Plan.QueryPlan.FieldsAndAggregates

module Hasura.Backends.DataConnector.Plan.RemoteRelationshipPlan
mkRemoteRelationshipPlan :: forall m r. (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r) => SourceConfig -> NonEmpty Object -> HashMap FieldName (ColumnName, ScalarType) -> FieldName -> FieldName -> SourceRelationshipSelection 'DataConnector Void UnpreparedValue -> m (Plan QueryRequest QueryResponse)

module Hasura.RQL.Types.CustomTypes
isInBuiltScalar :: Text -> Bool

-- | A set of custom GraphQL types, sorted by "kind".
data CustomTypes
CustomTypes :: [InputObjectTypeDefinition] -> [ObjectTypeDefinition] -> [ScalarTypeDefinition] -> [EnumTypeDefinition] -> CustomTypes
[_ctInputObjects] :: CustomTypes -> [InputObjectTypeDefinition]
[_ctObjects] :: CustomTypes -> [ObjectTypeDefinition]
[_ctScalars] :: CustomTypes -> [ScalarTypeDefinition]
[_ctEnums] :: CustomTypes -> [EnumTypeDefinition]
emptyCustomTypes :: CustomTypes
data InputObjectTypeDefinition
InputObjectTypeDefinition :: InputObjectTypeName -> Maybe Description -> NonEmpty InputObjectFieldDefinition -> InputObjectTypeDefinition
[_iotdName] :: InputObjectTypeDefinition -> InputObjectTypeName
[_iotdDescription] :: InputObjectTypeDefinition -> Maybe Description
[_iotdFields] :: InputObjectTypeDefinition -> NonEmpty InputObjectFieldDefinition
newtype InputObjectTypeName
InputObjectTypeName :: Name -> InputObjectTypeName
[unInputObjectTypeName] :: InputObjectTypeName -> Name
data InputObjectFieldDefinition
InputObjectFieldDefinition :: InputObjectFieldName -> Maybe Description -> GraphQLType -> InputObjectFieldDefinition
[_iofdName] :: InputObjectFieldDefinition -> InputObjectFieldName
[_iofdDescription] :: InputObjectFieldDefinition -> Maybe Description
[_iofdType] :: InputObjectFieldDefinition -> GraphQLType
newtype InputObjectFieldName
InputObjectFieldName :: Name -> InputObjectFieldName
[unInputObjectFieldName] :: InputObjectFieldName -> Name
data ObjectTypeDefinition
ObjectTypeDefinition :: ObjectTypeName -> Maybe Description -> NonEmpty (ObjectFieldDefinition GraphQLType) -> [TypeRelationshipDefinition] -> ObjectTypeDefinition
[_otdName] :: ObjectTypeDefinition -> ObjectTypeName
[_otdDescription] :: ObjectTypeDefinition -> Maybe Description
[_otdFields] :: ObjectTypeDefinition -> NonEmpty (ObjectFieldDefinition GraphQLType)
[_otdRelationships] :: ObjectTypeDefinition -> [TypeRelationshipDefinition]
newtype ObjectTypeName
ObjectTypeName :: Name -> ObjectTypeName
[unObjectTypeName] :: ObjectTypeName -> Name
data ObjectFieldDefinition field
ObjectFieldDefinition :: ObjectFieldName -> Maybe Value -> Maybe Description -> field -> ObjectFieldDefinition field
[_ofdName] :: ObjectFieldDefinition field -> ObjectFieldName
[_ofdArguments] :: ObjectFieldDefinition field -> Maybe Value
[_ofdDescription] :: ObjectFieldDefinition field -> Maybe Description
[_ofdType] :: ObjectFieldDefinition field -> field
newtype ObjectFieldName
ObjectFieldName :: Name -> ObjectFieldName
[unObjectFieldName] :: ObjectFieldName -> Name
data ScalarTypeDefinition
ScalarTypeDefinition :: Name -> Maybe Description -> ScalarTypeDefinition
[_stdName] :: ScalarTypeDefinition -> Name
[_stdDescription] :: ScalarTypeDefinition -> Maybe Description
defaultGraphQLScalars :: HashMap Name ScalarTypeDefinition
data EnumTypeDefinition
EnumTypeDefinition :: EnumTypeName -> Maybe Description -> NonEmpty EnumValueDefinition -> EnumTypeDefinition
[_etdName] :: EnumTypeDefinition -> EnumTypeName
[_etdDescription] :: EnumTypeDefinition -> Maybe Description
[_etdValues] :: EnumTypeDefinition -> NonEmpty EnumValueDefinition
newtype EnumTypeName
EnumTypeName :: Name -> EnumTypeName
[unEnumTypeName] :: EnumTypeName -> Name
data EnumValueDefinition
EnumValueDefinition :: EnumValue -> Maybe Description -> Maybe Bool -> EnumValueDefinition
[_evdValue] :: EnumValueDefinition -> EnumValue
[_evdDescription] :: EnumValueDefinition -> Maybe Description
[_evdIsDeprecated] :: EnumValueDefinition -> Maybe Bool
data TypeRelationshipDefinition
TypeRelationshipDefinition :: RelationshipName -> RelType -> SourceName -> QualifiedTable -> HashMap ObjectFieldName PGCol -> TypeRelationshipDefinition
[_trdName] :: TypeRelationshipDefinition -> RelationshipName
[_trdType] :: TypeRelationshipDefinition -> RelType
[_trdSource] :: TypeRelationshipDefinition -> SourceName
[_trdRemoteTable] :: TypeRelationshipDefinition -> QualifiedTable
[_trdFieldMapping] :: TypeRelationshipDefinition -> HashMap ObjectFieldName PGCol

-- | TODO: deduplicate this in favour of RelName
newtype RelationshipName
RelationshipName :: Name -> RelationshipName
[unRelationshipName] :: RelationshipName -> Name

-- | While we do not persist resolved types in the schema cache, they are
--   used when building the cache to validate and resolve actions and their
--   relationships.
data AnnotatedCustomTypes
AnnotatedCustomTypes :: HashMap Name AnnotatedInputType -> HashMap Name AnnotatedObjectType -> AnnotatedCustomTypes
[_actInputTypes] :: AnnotatedCustomTypes -> HashMap Name AnnotatedInputType
[_actObjectTypes] :: AnnotatedCustomTypes -> HashMap Name AnnotatedObjectType
data AnnotatedInputType
NOCTScalar :: AnnotatedScalarType -> AnnotatedInputType
NOCTEnum :: EnumTypeDefinition -> AnnotatedInputType
NOCTInputObject :: InputObjectTypeDefinition -> AnnotatedInputType
data AnnotatedScalarType
ASTCustom :: ScalarTypeDefinition -> AnnotatedScalarType
ASTReusedScalar :: Name -> AnyBackend ScalarWrapper -> AnnotatedScalarType
data ScalarWrapper b
ScalarWrapper :: ScalarType b -> ScalarTypeParsingContext b -> ScalarWrapper b
[unwrapScalar] :: ScalarWrapper b -> ScalarType b
[parsingContext] :: ScalarWrapper b -> ScalarTypeParsingContext b
data AnnotatedOutputType
AOTObject :: AnnotatedObjectType -> AnnotatedOutputType
AOTScalar :: AnnotatedScalarType -> AnnotatedOutputType
data AnnotatedObjectType
AnnotatedObjectType :: ObjectTypeName -> Maybe Description -> NonEmpty (ObjectFieldDefinition (GType, AnnotatedObjectFieldType)) -> [AnnotatedTypeRelationship] -> AnnotatedObjectType
[_aotName] :: AnnotatedObjectType -> ObjectTypeName
[_aotDescription] :: AnnotatedObjectType -> Maybe Description
[_aotFields] :: AnnotatedObjectType -> NonEmpty (ObjectFieldDefinition (GType, AnnotatedObjectFieldType))
[_aotRelationships] :: AnnotatedObjectType -> [AnnotatedTypeRelationship]
data AnnotatedObjectFieldType
AOFTScalar :: AnnotatedScalarType -> AnnotatedObjectFieldType
AOFTEnum :: EnumTypeDefinition -> AnnotatedObjectFieldType
AOFTObject :: Name -> AnnotatedObjectFieldType
data AnnotatedTypeRelationship
AnnotatedTypeRelationship :: RelationshipName -> RelType -> SourceName -> SourceConfig ('Postgres 'Vanilla) -> TableName ('Postgres 'Vanilla) -> HashMap ObjectFieldName (ColumnInfo ('Postgres 'Vanilla)) -> AnnotatedTypeRelationship
[_atrName] :: AnnotatedTypeRelationship -> RelationshipName
[_atrType] :: AnnotatedTypeRelationship -> RelType
[_atrSource] :: AnnotatedTypeRelationship -> SourceName
[_atrSourceConfig] :: AnnotatedTypeRelationship -> SourceConfig ('Postgres 'Vanilla)
[_atrTableName] :: AnnotatedTypeRelationship -> TableName ('Postgres 'Vanilla)
[_atrFieldMapping] :: AnnotatedTypeRelationship -> HashMap ObjectFieldName (ColumnInfo ('Postgres 'Vanilla))
trdType :: Lens' TypeRelationshipDefinition RelType
trdSource :: Lens' TypeRelationshipDefinition SourceName
trdRemoteTable :: Lens' TypeRelationshipDefinition QualifiedTable
trdName :: Lens' TypeRelationshipDefinition RelationshipName
trdFieldMapping :: Lens' TypeRelationshipDefinition (HashMap ObjectFieldName PGCol)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedOutputType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedObjectType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedTypeRelationship
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedObjectFieldType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedInputType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.CustomTypes
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.CustomTypes
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.AnnotatedScalarType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON field => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Data.Aeson.Types.FromJSON.FromJSON field => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectTypeName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance GHC.Generics.Generic (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Data.Traversable.Traversable Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition
instance Data.Foldable.Foldable Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition
instance GHC.Base.Functor Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition
instance GHC.Classes.Eq field => GHC.Classes.Eq (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance GHC.Show.Show field => GHC.Show.Show (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.EnumTypeName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.RelationshipName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.CustomTypes.RelationshipName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.CustomTypes.RelationshipName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.RelationshipName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.RelationshipName
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.CustomTypes
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.CustomTypes
instance GHC.Show.Show Hasura.RQL.Types.CustomTypes.CustomTypes
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedScalarType
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.AnnotatedScalarType
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.AnnotatedScalarType
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedInputType
instance GHC.Classes.Ord Hasura.RQL.Types.CustomTypes.AnnotatedInputType
instance GHC.Classes.Eq Hasura.RQL.Types.CustomTypes.AnnotatedInputType
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedObjectFieldType
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedTypeRelationship
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedObjectType
instance GHC.Generics.Generic Hasura.RQL.Types.CustomTypes.AnnotatedOutputType
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.CustomTypes.ScalarWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.CustomTypes.ScalarWrapper b)
instance GHC.Base.Semigroup Hasura.RQL.Types.CustomTypes.AnnotatedCustomTypes
instance GHC.Base.Monoid Hasura.RQL.Types.CustomTypes.AnnotatedCustomTypes
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.CustomTypes
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.CustomTypes
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.ObjectTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.CustomTypes.TypeRelationshipDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.RelationshipName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.EnumTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.EnumValueDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.EnumTypeName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.ScalarTypeDefinition
instance Control.DeepSeq.NFData field => Control.DeepSeq.NFData (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance (Autodocodec.Class.HasCodec field, Data.Typeable.Internal.Typeable field) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.CustomTypes.ObjectFieldDefinition field)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.ObjectFieldName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.ObjectTypeName
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.InputObjectTypeDefinition
instance Control.DeepSeq.NFData Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.InputObjectFieldDefinition
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.InputObjectFieldName
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.CustomTypes.InputObjectTypeName

module Hasura.RQL.Types.Action
data ActionMetadata
ActionMetadata :: ActionName -> Maybe Text -> ActionDefinitionInput -> [ActionPermissionMetadata] -> ActionMetadata
[_amName] :: ActionMetadata -> ActionName
[_amComment] :: ActionMetadata -> Maybe Text
[_amDefinition] :: ActionMetadata -> ActionDefinitionInput
[_amPermissions] :: ActionMetadata -> [ActionPermissionMetadata]
data ActionPermissionMetadata
ActionPermissionMetadata :: RoleName -> Maybe Text -> ActionPermissionMetadata
[_apmRole] :: ActionPermissionMetadata -> RoleName
[_apmComment] :: ActionPermissionMetadata -> Maybe Text
newtype ActionName
ActionName :: Name -> ActionName
[unActionName] :: ActionName -> Name
newtype ActionId
ActionId :: UUID -> ActionId
[unActionId] :: ActionId -> UUID
actionIdToText :: ActionId -> Text
type ActionDefinitionInput = ActionDefinition GraphQLType InputWebhook
data ActionDefinition arg webhook
ActionDefinition :: [ArgumentDefinition arg] -> GraphQLType -> ActionType -> [HeaderConf] -> Bool -> Timeout -> webhook -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> ActionDefinition arg webhook
[_adArguments] :: ActionDefinition arg webhook -> [ArgumentDefinition arg]
[_adOutputType] :: ActionDefinition arg webhook -> GraphQLType
[_adType] :: ActionDefinition arg webhook -> ActionType
[_adHeaders] :: ActionDefinition arg webhook -> [HeaderConf]
[_adForwardClientHeaders] :: ActionDefinition arg webhook -> Bool

-- | If the timeout is not provided by the user, then the default timeout
--   of 30 seconds will be used
[_adTimeout] :: ActionDefinition arg webhook -> Timeout
[_adHandler] :: ActionDefinition arg webhook -> webhook
[_adRequestTransform] :: ActionDefinition arg webhook -> Maybe RequestTransform
[_adResponseTransform] :: ActionDefinition arg webhook -> Maybe MetadataResponseTransform
data ActionType
ActionQuery :: ActionType
ActionMutation :: ActionMutationKind -> ActionType
data ActionMutationKind
ActionSynchronous :: ActionMutationKind
ActionAsynchronous :: ActionMutationKind
data ArgumentDefinition a
ArgumentDefinition :: ArgumentName -> a -> Maybe Description -> ArgumentDefinition a
[_argName] :: ArgumentDefinition a -> ArgumentName
[_argType] :: ArgumentDefinition a -> a
[_argDescription] :: ArgumentDefinition a -> Maybe Description
newtype ArgumentName
ArgumentName :: Name -> ArgumentName
[unArgumentName] :: ArgumentName -> Name
data ActionInfo
ActionInfo :: ActionName -> (GType, AnnotatedOutputType) -> ResolvedActionDefinition -> HashMap RoleName ActionPermissionInfo -> Bool -> Maybe Text -> ActionInfo
[_aiName] :: ActionInfo -> ActionName
[_aiOutputType] :: ActionInfo -> (GType, AnnotatedOutputType)
[_aiDefinition] :: ActionInfo -> ResolvedActionDefinition
[_aiPermissions] :: ActionInfo -> HashMap RoleName ActionPermissionInfo
[_aiForwardedClientHeaders] :: ActionInfo -> Bool
[_aiComment] :: ActionInfo -> Maybe Text
type ResolvedActionDefinition = ActionDefinition (GType, AnnotatedInputType) (EnvRecord ResolvedWebhook)
newtype ActionPermissionInfo
ActionPermissionInfo :: RoleName -> ActionPermissionInfo
[_apiRole] :: ActionPermissionInfo -> RoleName
data ActionExecContext
ActionExecContext :: RequestHeaders -> SessionVariables -> ActionExecContext
[_aecHeaders] :: ActionExecContext -> RequestHeaders
[_aecSessionVariables] :: ActionExecContext -> SessionVariables
data ActionLogItem
ActionLogItem :: ActionId -> ActionName -> [Header] -> SessionVariables -> Value -> ActionLogItem
[_aliId] :: ActionLogItem -> ActionId
[_aliActionName] :: ActionLogItem -> ActionName
[_aliRequestHeaders] :: ActionLogItem -> [Header]
[_aliSessionVariables] :: ActionLogItem -> SessionVariables
[_aliInputPayload] :: ActionLogItem -> Value
data ActionLogResponse
ActionLogResponse :: ActionId -> UTCTime -> Maybe Value -> Maybe Value -> SessionVariables -> ActionLogResponse
[_alrId] :: ActionLogResponse -> ActionId
[_alrCreatedAt] :: ActionLogResponse -> UTCTime
[_alrResponsePayload] :: ActionLogResponse -> Maybe Value
[_alrErrors] :: ActionLogResponse -> Maybe Value
[_alrSessionVariables] :: ActionLogResponse -> SessionVariables
type ActionLogResponseMap = HashMap ActionId ActionLogResponse
data AsyncActionStatus
AASCompleted :: Value -> AsyncActionStatus
AASError :: QErr -> AsyncActionStatus
data ActionsInfo
ActionsInfo :: ActionName -> Bool -> ActionsInfo
[_asiName] :: ActionsInfo -> ActionName
[_asiForwardClientHeaders] :: ActionsInfo -> Bool
type LockedActionEventId = EventId
newtype LockedActionIdArray
LockedActionIdArray :: [LockedActionEventId] -> LockedActionIdArray
[unCohortIdArray] :: LockedActionIdArray -> [LockedActionEventId]
amPermissions :: Lens' ActionMetadata [ActionPermissionMetadata]
amName :: Lens' ActionMetadata ActionName
amDefinition :: Lens' ActionMetadata ActionDefinitionInput
amComment :: Lens' ActionMetadata (Maybe Text)
adType :: forall arg_ak6iH webhook_ak6iI. Lens' (ActionDefinition arg_ak6iH webhook_ak6iI) ActionType
adTimeout :: forall arg_ak6iH webhook_ak6iI. Lens' (ActionDefinition arg_ak6iH webhook_ak6iI) Timeout
adResponseTransform :: forall arg_ak6iH webhook_ak6iI. Lens' (ActionDefinition arg_ak6iH webhook_ak6iI) (Maybe MetadataResponseTransform)
adRequestTransform :: forall arg_ak6iH webhook_ak6iI. Lens' (ActionDefinition arg_ak6iH webhook_ak6iI) (Maybe RequestTransform)
adOutputType :: forall arg_ak6iH webhook_ak6iI. Lens' (ActionDefinition arg_ak6iH webhook_ak6iI) GraphQLType
adHeaders :: forall arg_ak6iH webhook_ak6iI. Lens' (ActionDefinition arg_ak6iH webhook_ak6iI) [HeaderConf]
adHandler :: forall arg_ak6iH webhook_ak6iI webhook_ak9oJ. Lens (ActionDefinition arg_ak6iH webhook_ak6iI) (ActionDefinition arg_ak6iH webhook_ak9oJ) webhook_ak6iI webhook_ak9oJ
adForwardClientHeaders :: forall arg_ak6iH webhook_ak6iI. Lens' (ActionDefinition arg_ak6iH webhook_ak6iI) Bool
adArguments :: forall arg_ak6iH webhook_ak6iI arg_ak9oI. Lens (ActionDefinition arg_ak6iH webhook_ak6iI) (ActionDefinition arg_ak9oI webhook_ak6iI) [ArgumentDefinition arg_ak6iH] [ArgumentDefinition arg_ak9oI]
aiPermissions :: Lens' ActionInfo (HashMap RoleName ActionPermissionInfo)
aiOutputType :: Lens' ActionInfo (GType, AnnotatedOutputType)
aiName :: Lens' ActionInfo ActionName
aiForwardedClientHeaders :: Lens' ActionInfo Bool
aiDefinition :: Lens' ActionInfo ResolvedActionDefinition
aiComment :: Lens' ActionInfo (Maybe Text)
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionPermissionMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionPermissionMetadata
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionPermissionMetadata
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Action.ActionName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionName
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionName
instance GHC.Classes.Ord Hasura.RQL.Types.Action.ActionName
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionName
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionName
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Action.ActionId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionId
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Action.ActionId
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Action.ActionId
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionId
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionId
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Enum.Enum Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Enum.Bounded Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionMutationKind
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionType
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionType
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionType
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ArgumentName
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ArgumentName
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Action.ArgumentName
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.Action.ArgumentName
instance Data.Aeson.Types.FromJSON.FromJSONKey Hasura.RQL.Types.Action.ArgumentName
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ArgumentName
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ArgumentName
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ArgumentName
instance GHC.Show.Show Hasura.RQL.Types.Action.ArgumentName
instance GHC.Generics.Generic (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance Data.Traversable.Traversable Hasura.RQL.Types.Action.ArgumentDefinition
instance Data.Foldable.Foldable Hasura.RQL.Types.Action.ArgumentDefinition
instance GHC.Base.Functor Hasura.RQL.Types.Action.ArgumentDefinition
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance GHC.Generics.Generic (Hasura.RQL.Types.Action.ActionDefinition arg webhook)
instance Data.Traversable.Traversable (Hasura.RQL.Types.Action.ActionDefinition arg)
instance Data.Foldable.Foldable (Hasura.RQL.Types.Action.ActionDefinition arg)
instance GHC.Base.Functor (Hasura.RQL.Types.Action.ActionDefinition arg)
instance (GHC.Classes.Eq arg, GHC.Classes.Eq webhook) => GHC.Classes.Eq (Hasura.RQL.Types.Action.ActionDefinition arg webhook)
instance (GHC.Show.Show arg, GHC.Show.Show webhook) => GHC.Show.Show (Hasura.RQL.Types.Action.ActionDefinition arg webhook)
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionMetadata
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionPermissionInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionPermissionInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionPermissionInfo
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionPermissionInfo
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionLogItem
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionLogItem
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionLogResponse
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionLogResponse
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionLogResponse
instance GHC.Generics.Generic Hasura.RQL.Types.Action.ActionsInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Action.ActionsInfo
instance GHC.Show.Show Hasura.RQL.Types.Action.ActionsInfo
instance GHC.Classes.Eq Hasura.RQL.Types.Action.LockedActionIdArray
instance GHC.Show.Show Hasura.RQL.Types.Action.LockedActionIdArray
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Action.LockedActionIdArray
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionLogResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionInfo
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionMetadata
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Action.ActionMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionMetadata
instance (Control.DeepSeq.NFData a, Control.DeepSeq.NFData w) => Control.DeepSeq.NFData (Hasura.RQL.Types.Action.ActionDefinition a w)
instance (GHC.Classes.Eq arg, Autodocodec.Class.HasCodec (Hasura.RQL.Types.Action.ArgumentDefinition arg), Autodocodec.Class.HasCodec webhook, Data.Typeable.Internal.Typeable arg, Data.Typeable.Internal.Typeable webhook) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Action.ActionDefinition arg webhook)
instance (Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON b) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Action.ActionDefinition a b)
instance (Data.Aeson.Types.ToJSON.ToJSON a, Data.Aeson.Types.ToJSON.ToJSON b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Action.ActionDefinition a b)
instance Control.DeepSeq.NFData a => Control.DeepSeq.NFData (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance (Autodocodec.Class.HasCodec a, Data.Typeable.Internal.Typeable a) => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Action.ArgumentDefinition a)
instance Data.Aeson.Types.FromJSON.FromJSON arg => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Action.ArgumentDefinition arg)
instance Data.Aeson.Types.ToJSON.ToJSON arg => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Action.ArgumentDefinition arg)
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Action.ArgumentName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionType
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionMutationKind
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Action.ActionMutationKind
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionMutationKind
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionMutationKind
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Action.ActionName
instance Database.PG.Query.Class.FromCol Hasura.RQL.Types.Action.ActionName
instance Database.PG.Query.Class.ToPrepArg Hasura.RQL.Types.Action.ActionName
instance Control.DeepSeq.NFData Hasura.RQL.Types.Action.ActionPermissionMetadata
instance Autodocodec.Class.HasCodec Hasura.RQL.Types.Action.ActionPermissionMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Action.ActionPermissionMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Action.ActionPermissionMetadata

module Hasura.RQL.Types.Metadata.Object
data TableMetadataObjId
MTORel :: RelName -> RelType -> TableMetadataObjId
MTOComputedField :: ComputedFieldName -> TableMetadataObjId
MTOPerm :: RoleName -> PermType -> TableMetadataObjId
MTOTrigger :: TriggerName -> TableMetadataObjId
MTORemoteRelationship :: RelName -> TableMetadataObjId

-- | Identifiers for logical model elements within the metadata structure.
data LogicalModelMetadataObjId
LMMOPerm :: RoleName -> PermType -> LogicalModelMetadataObjId
LMMOReferencedLogicalModel :: LogicalModelName -> LogicalModelMetadataObjId

-- | the native query should probably also link to its logical model
data NativeQueryMetadataObjId
NQMORel :: RelName -> RelType -> NativeQueryMetadataObjId
data SourceMetadataObjId b
SMOTable :: TableName b -> SourceMetadataObjId b
SMOFunction :: FunctionName b -> SourceMetadataObjId b
SMOFunctionPermission :: FunctionName b -> RoleName -> SourceMetadataObjId b
SMOTableObj :: TableName b -> TableMetadataObjId -> SourceMetadataObjId b
SMONativeQuery :: NativeQueryName -> SourceMetadataObjId b
SMONativeQueryObj :: NativeQueryName -> NativeQueryMetadataObjId -> SourceMetadataObjId b
SMOStoredProcedure :: FunctionName b -> SourceMetadataObjId b
SMOLogicalModel :: LogicalModelName -> SourceMetadataObjId b
SMOLogicalModelObj :: LogicalModelLocation -> LogicalModelMetadataObjId -> SourceMetadataObjId b
data MetadataObjId
MOSource :: SourceName -> MetadataObjId
MOSourceObjId :: SourceName -> AnyBackend SourceMetadataObjId -> MetadataObjId

-- | Originates from user-defined <tt>_arsqName</tt>
MORemoteSchema :: RemoteSchemaName -> MetadataObjId
MORemoteSchemaPermissions :: RemoteSchemaName -> RoleName -> MetadataObjId

-- | A remote relationship on a remote schema type, identified by 1. remote
--   schema name 2. remote schema type on which the relationship is defined
--   3. name of the relationship
MORemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> MetadataObjId
MOCustomTypes :: MetadataObjId
MOAction :: ActionName -> MetadataObjId
MOActionPermission :: ActionName -> RoleName -> MetadataObjId
MOCronTrigger :: TriggerName -> MetadataObjId
MOInheritedRole :: RoleName -> MetadataObjId
MOEndpoint :: EndpointName -> MetadataObjId
MOQueryCollectionsQuery :: CollectionName -> ListedQuery -> MetadataObjId
MODataConnectorAgent :: DataConnectorName -> MetadataObjId
MOOpenTelemetry :: OpenTelemetryConfigSubobject -> MetadataObjId
_MOEndpoint :: Prism' MetadataObjId EndpointName
_MOInheritedRole :: Prism' MetadataObjId RoleName
_MOCronTrigger :: Prism' MetadataObjId TriggerName
_MOActionPermission :: Prism' MetadataObjId (ActionName, RoleName)
_MOAction :: Prism' MetadataObjId ActionName
_MOCustomTypes :: Prism' MetadataObjId ()
_MORemoteSchemaPermissions :: Prism' MetadataObjId (RemoteSchemaName, RoleName)
_MORemoteSchema :: Prism' MetadataObjId RemoteSchemaName
_MOSourceObjId :: Prism' MetadataObjId (SourceName, AnyBackend SourceMetadataObjId)
_MOSource :: Prism' MetadataObjId SourceName
moiTypeName :: MetadataObjId -> Text
moiName :: MetadataObjId -> Text
data MetadataObject
MetadataObject :: MetadataObjId -> Value -> MetadataObject
[_moId] :: MetadataObject -> MetadataObjId
[_moDefinition] :: MetadataObject -> Value
moId :: Lens' MetadataObject MetadataObjId
moDefinition :: Lens' MetadataObject Value
data InconsistentRoleEntity
InconsistentTablePermission :: SourceName -> Text -> PermType -> InconsistentRoleEntity
InconsistentRemoteSchemaPermission :: RemoteSchemaName -> InconsistentRoleEntity
data InconsistentMetadata
InconsistentObject :: Text -> Maybe Value -> MetadataObject -> InconsistentMetadata
ConflictingObjects :: Text -> [MetadataObject] -> InconsistentMetadata
DuplicateObjects :: MetadataObjId -> [Value] -> InconsistentMetadata
DuplicateRestVariables :: Text -> MetadataObject -> InconsistentMetadata
InvalidRestSegments :: Text -> MetadataObject -> InconsistentMetadata
AmbiguousRestEndpoints :: Text -> [MetadataObject] -> InconsistentMetadata
ConflictingInheritedPermission :: RoleName -> InconsistentRoleEntity -> InconsistentMetadata
_ConflictingInheritedPermission :: Prism' InconsistentMetadata (RoleName, InconsistentRoleEntity)
_AmbiguousRestEndpoints :: Prism' InconsistentMetadata (Text, [MetadataObject])
_InvalidRestSegments :: Prism' InconsistentMetadata (Text, MetadataObject)
_DuplicateRestVariables :: Prism' InconsistentMetadata (Text, MetadataObject)
_DuplicateObjects :: Prism' InconsistentMetadata (MetadataObjId, [Value])
_ConflictingObjects :: Prism' InconsistentMetadata (Text, [MetadataObject])
_InconsistentObject :: Prism' InconsistentMetadata (Text, Maybe Value, MetadataObject)

-- | Helper function to differentiate which type of inconsistent metadata
--   can be dropped, if an inconsistency cannot be resolved by dropping any
--   part of the metadata then this function should return <a>False</a>,
--   otherwise it should return <a>True</a>
droppableInconsistentMetadata :: InconsistentMetadata -> Bool
getInconsistentRemoteSchemas :: [InconsistentMetadata] -> [RemoteSchemaName]
imObjectIds :: InconsistentMetadata -> [MetadataObjId]
imReason :: InconsistentMetadata -> Text

-- | Builds a map from each unique metadata object id to the
--   inconsistencies associated with it. Note that a single inconsistency
--   can involve multiple metadata objects, so the same inconsistency may
--   appear in the resulting map multiple times!
groupInconsistentMetadataById :: [InconsistentMetadata] -> HashMap MetadataObjId (NonEmpty InconsistentMetadata)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.InconsistentMetadata
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance Data.Text.Extended.ToTxt Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Object.InconsistentRoleEntity
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.MetadataObject
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.MetadataObject
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.MetadataObject
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.MetadataObject
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.MetadataObject
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance Hasura.Base.ToErrorValue.ToErrorValue Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.TableMetadataObjId
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.LogicalModelMetadataObjId
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.LogicalModelMetadataObjId
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.LogicalModelMetadataObjId
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.LogicalModelMetadataObjId
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.NativeQueryMetadataObjId
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.NativeQueryMetadataObjId
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.NativeQueryMetadataObjId
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.NativeQueryMetadataObjId
instance GHC.Generics.Generic (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance GHC.Classes.Ord Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Object.MetadataObjId
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Ord (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.Metadata.Object.SourceMetadataObjId b)
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.NativeQueryMetadataObjId
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.LogicalModelMetadataObjId
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.Metadata.Object.TableMetadataObjId


-- | Warnings for metadata APIs
--   
--   This module provides a mechanism for metadata APIs to emit warnings.
--   An example use of <tt>MonadWarnings</tt> to emit warnings with success
--   message is given below:
--   
--   <pre>
--   import Hasura.RQL.DDL.Warnings
--   
--   someMetadataAPIHandler :: args -&gt; m EncJSON
--   someMetadataAPIHandler args = successMsgWithWarnings $ do
--     -- do some stuff
--     let warning = MetadataWarning (MOSource defaultSource) "some warning message"
--     warn $ warning
--     -- do some more stuff
--     pure ()
--   </pre>
module Hasura.RQL.DDL.Warnings

-- | Allow/Disallow metadata warnings
data AllowWarnings
AllowWarnings :: AllowWarnings
DisallowWarnings :: AllowWarnings
data WarningCode
WCSourceCleanupFailed :: WarningCode
WCIllegalEventTriggerName :: WarningCode
WCTimeLimitExceededSystemLimit :: WarningCode
WCTrackTableFailed :: WarningCode
WCUntrackTableFailed :: WarningCode
data MetadataWarning
MetadataWarning :: WarningCode -> MetadataObjId -> Text -> MetadataWarning
[_mwCode] :: MetadataWarning -> WarningCode
[_mwMetadataObj] :: MetadataWarning -> MetadataObjId
[_mwMessage] :: MetadataWarning -> Text
type MetadataWarnings = Seq MetadataWarning
class (Monad m) => MonadWarnings m

-- | Add a warning to the current context
warn :: MonadWarnings m => MetadataWarning -> m ()
runMetadataWarnings :: StateT MetadataWarnings m a -> m (a, MetadataWarnings)
mkSuccessResponseWithWarnings :: MetadataWarnings -> EncJSON
successMsgWithWarnings :: Monad m => StateT MetadataWarnings m () -> m EncJSON
instance GHC.Classes.Eq Hasura.RQL.DDL.Warnings.AllowWarnings
instance GHC.Show.Show Hasura.RQL.DDL.Warnings.AllowWarnings
instance GHC.Classes.Ord Hasura.RQL.DDL.Warnings.WarningCode
instance GHC.Classes.Eq Hasura.RQL.DDL.Warnings.WarningCode
instance GHC.Classes.Ord Hasura.RQL.DDL.Warnings.MetadataWarning
instance GHC.Classes.Eq Hasura.RQL.DDL.Warnings.MetadataWarning
instance GHC.Base.Monad m => Hasura.RQL.DDL.Warnings.MonadWarnings (Control.Monad.Trans.State.Strict.StateT Hasura.RQL.DDL.Warnings.MetadataWarnings m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Warnings.MetadataWarning
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Warnings.WarningCode
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Warnings.AllowWarnings
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Warnings.AllowWarnings


-- | In <a>Parser</a>, the <a>Definition</a> type has a <a>dOrigin</a>
--   field that allows to track where a fragment of GraphQL type
--   information comes from. This is useful for error reporting and
--   internal repair mechanisms such as inconsistency tracking.
--   
--   Morally, within the HGE codebase, this origin is always
--   <a>MetadataObjId</a>. However, in order to avoid an import of
--   <a>RQL</a> from <a>Parser</a>, the <a>dOrigin</a> has been defined
--   through a type parameter of <a>Definition</a>. This type parameter
--   then has to get threaded through throughout the <a>Parser</a> module
--   hierarchy, so that it ends up in a lot of types. This is very noisy.
--   
--   In order to avoid the noise of this type parameter, which really only
--   has one value, and is really only used in one type, this module erases
--   the type parameter by filling in the desired value, exporting type
--   synonyms of the now-fixed notion of "origin". So most modules in the
--   HGE codebase should import this module rather than <a>Parser</a>.
module Hasura.GraphQL.Schema.Parser
type FieldParser = FieldParser MetadataObjId
type Parser = Parser MetadataObjId
type Schema = Schema MetadataObjId
type ConflictingDefinitions = ConflictingDefinitions MetadataObjId
type Type = Type MetadataObjId
type TypeInfo = TypeInfo MetadataObjId
type InputFieldsParser = InputFieldsParser MetadataObjId
type InputObjectInfo = InputObjectInfo MetadataObjId
type Definition = Definition MetadataObjId
type Directive = Directive MetadataObjId
type DirectiveInfo = DirectiveInfo MetadataObjId
type FieldInfo = FieldInfo MetadataObjId
type InputFieldInfo = InputFieldInfo MetadataObjId
type HasTypeDefinitions = HasTypeDefinitions MetadataObjId
type SomeDefinitionTypeInfo = SomeDefinitionTypeInfo MetadataObjId
type TypeDefinitionsWrapper = TypeDefinitionsWrapper MetadataObjId

-- | In order to aid type inference and type checking, we define this
--   pattern synonym (an actual one) which restricts
--   <a>TypeDefinitionsWrapper</a> to have <a>MetadataObjId</a> set for its
--   origin type parameter.
pattern TypeDefinitionsWrapper :: () => forall a. HasTypeDefinitions a => a -> TypeDefinitionsWrapper
toQErr :: MonadError QErr m => Either ParseError a -> m a
memoizeOn :: (MonadMemoize m, Ord a, Typeable a, Typeable p, MonadParse n, Typeable b) => Name -> a -> m (p n b) -> m (p n b)

-- | A wrapper around <a>memoizeOn</a> that memoizes a function by using
--   its argument as the key.
memoize :: (MonadMemoize m, Ord a, Typeable a, Typeable p, MonadParse n, Typeable b) => Name -> (a -> m (p n b)) -> a -> m (p n b)

module Hasura.GraphQL.Schema.Introspect

-- | Builds a <tt>Schema</tt> from GraphQL types for the query_root,
--   mutation_root and subscription_root.
--   
--   See Note [What introspection exposes]
buildIntrospectionSchema :: Type 'Output -> Maybe (Type 'Output) -> Maybe (Type 'Output) -> Either ConflictingDefinitions Schema

-- | Generate a __type introspection parser
typeIntrospection :: forall n. MonadParse n => FieldParser n (Schema -> Value)

-- | Generate a __schema introspection parser.
schema :: forall n. MonadParse n => FieldParser n (Schema -> Value)

module Hasura.GraphQL.Namespace
data RootFieldAlias
RootFieldAlias :: !Maybe Name -> !Name -> RootFieldAlias
[_rfaNamespace] :: RootFieldAlias -> !Maybe Name
[_rfaAlias] :: RootFieldAlias -> !Name
mkUnNamespacedRootFieldAlias :: Name -> RootFieldAlias
mkNamespacedRootFieldAlias :: Name -> Name -> RootFieldAlias
type RootFieldMap = InsOrdHashMap RootFieldAlias
data NamespacedField a

-- | Normal field
NotNamespaced :: a -> NamespacedField a

-- | Namespace field with other fields nested within
Namespaced :: InsOrdHashMap Name a -> NamespacedField a
namespacedField :: (a -> b) -> (InsOrdHashMap Name a -> b) -> NamespacedField a -> b
type NamespacedFieldMap a = InsOrdHashMap Name (NamespacedField a)
flattenNamespaces :: forall a. NamespacedFieldMap a -> RootFieldMap a
unflattenNamespaces :: RootFieldMap a -> NamespacedFieldMap a

-- | Wrap the field parser results in <tt>NamespacedField</tt>
customizeNamespace :: forall n a. MonadParse n => Maybe Name -> (Name -> ParsedSelection a -> a) -> MkTypename -> [FieldParser n a] -> [FieldParser n (NamespacedField a)]
instance GHC.Generics.Generic Hasura.GraphQL.Namespace.RootFieldAlias
instance GHC.Classes.Eq Hasura.GraphQL.Namespace.RootFieldAlias
instance GHC.Show.Show Hasura.GraphQL.Namespace.RootFieldAlias
instance GHC.Base.Functor Hasura.GraphQL.Namespace.NamespacedField
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Namespace.NamespacedField a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Namespace.NamespacedField a)
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Namespace.RootFieldAlias
instance Data.Text.Extended.ToTxt Hasura.GraphQL.Namespace.RootFieldAlias
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Namespace.RootFieldAlias


-- | This module has the various metadata we want to attach to the
--   generated/executed query
module Hasura.QueryTags

-- | Query Tags are SQL comments which are made up of (key=value) pairs.
--   
--   These are appended to the SQL statements generated by Hasura for
--   GraphQL operations. This enables the ability to get some application
--   context in the database logs and also use native database monitoring
--   tools (e.g. pganalyze) for better performance analysis.
--   
--   The application context(query tags) can be used to detect slow GQL
--   operation and relate them back to the SQL that was generated.
--   
--   For eg: SELECT name FROM child <i>*
--   request_id=487c2ed5-08a4-429a-b0e0-4666a82e3cc6, field_name=child,
--   operation_name=GetChild *</i>
--   
--   For more usage information, refer <a>Query Tags Docs</a>
data QueryTags
QTQuery :: !QueryMetadata -> QueryTags
QTMutation :: !MutationMetadata -> QueryTags
QTLiveQuery :: !LivequeryMetadata -> QueryTags

-- | query-tags as SQL comment which is appended to the prepared SQL
--   statement
newtype QueryTagsComment
QueryTagsComment :: Text -> QueryTagsComment
[_unQueryTagsComment] :: QueryTagsComment -> Text
type Attribute = (Text, Text)
data QueryTagsAttributes
emptyQueryTagsAttributes :: QueryTagsAttributes
emptyQueryTagsComment :: QueryTagsComment
data QueryMetadata
QueryMetadata :: Maybe RequestId -> Maybe Name -> RootFieldAlias -> ParameterizedQueryHash -> QueryMetadata
data MutationMetadata
MutationMetadata :: Maybe RequestId -> Maybe Name -> RootFieldAlias -> ParameterizedQueryHash -> MutationMetadata
data LivequeryMetadata
LivequeryMetadata :: RootFieldAlias -> ParameterizedQueryHash -> LivequeryMetadata
encodeQueryTags :: QueryTags -> QueryTagsAttributes
class (Monad m) => MonadQueryTags m

-- | Creates Query Tags. These are appended to the Generated SQL. Helps
--   users to use native database monitoring tools to get some
--   'application-context'.
createQueryTags :: MonadQueryTags m => QueryTagsAttributes -> Maybe QueryTagsConfig -> Tagged m QueryTagsComment

-- | Creates Query Tags. These are appended to the Generated SQL. Helps
--   users to use native database monitoring tools to get some
--   'application-context'.
createQueryTags :: forall t n. (MonadQueryTags m, m ~ t n, MonadQueryTags n) => QueryTagsAttributes -> Maybe QueryTagsConfig -> Tagged m QueryTagsComment
instance GHC.Classes.Eq Hasura.QueryTags.QueryTagsComment
instance GHC.Show.Show Hasura.QueryTags.QueryTagsComment
instance GHC.Classes.Eq Hasura.QueryTags.QueryTagsAttributes
instance GHC.Show.Show Hasura.QueryTags.QueryTagsAttributes
instance GHC.Show.Show Hasura.QueryTags.QueryMetadata
instance GHC.Show.Show Hasura.QueryTags.MutationMetadata
instance GHC.Show.Show Hasura.QueryTags.LivequeryMetadata
instance GHC.Show.Show Hasura.QueryTags.QueryTags
instance Hasura.QueryTags.MonadQueryTags m => Hasura.QueryTags.MonadQueryTags (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.QueryTags.MonadQueryTags m => Hasura.QueryTags.MonadQueryTags (Control.Monad.Trans.Except.ExceptT e m)

module Hasura.Backends.MSSQL.Execute.QueryTags
withQueryTags :: Query -> QueryTagsComment -> Query
withQueryTagsPrinter :: Printer -> QueryTagsComment -> Printer


-- | Add metadata tags as comments to SQL queries.
module Data.SqlCommenter

-- | query-tags format as defined in the Spec
--   <a>https://google.github.io/sqlcommenter/spec/#sql-commenter</a>
sqlCommenterGoogle :: QueryTagsAttributes -> QueryTagsComment

-- | Default 'Query Tags' format in the Hasura GraphQL Engine Creates
--   simple 'key=value' pairs of query tags. No sorting, No URL encoding.
--   If the format of query tags is not mentioned in the metadata then,
--   query-tags are formatted using hte below format
sqlCommenterStandard :: QueryTagsAttributes -> QueryTagsComment


-- | In order to avoid circular dependencies while splitting
--   <a>Metadata</a> into multiple modules, some definitions must be moved
--   out of that module. This module is the bucket for definitions that
--   have not been specifically moved elsewhere.
module Hasura.RQL.Types.Metadata.Common
type EventTriggers b = InsOrdHashMap TriggerName (EventTriggerConf b)
type RemoteSchemaMetadata = RemoteSchemaMetadataG RemoteRelationshipDefinition
type RemoteSchemas = InsOrdHashMap RemoteSchemaName RemoteSchemaMetadata
type Tables b = InsOrdHashMap (TableName b) (TableMetadata b)
type Functions b = InsOrdHashMap (FunctionName b) (FunctionMetadata b)
type NativeQueries b = InsOrdHashMap NativeQueryName (NativeQueryMetadata b)
type StoredProcedures b = InsOrdHashMap (FunctionName b) (StoredProcedureMetadata b)
type LogicalModels b = InsOrdHashMap LogicalModelName (LogicalModelMetadata b)
type Endpoints = InsOrdHashMap EndpointName CreateEndpoint
type Actions = InsOrdHashMap ActionName ActionMetadata
type CronTriggers = InsOrdHashMap TriggerName CronTriggerMetadata
type InheritedRoles = InsOrdHashMap RoleName InheritedRole

-- | Source configuration for a source of backend type <tt>b</tt> as stored
--   in the Metadata DB.
data SourceMetadata b
SourceMetadata :: SourceName -> BackendSourceKind b -> Tables b -> Functions b -> NativeQueries b -> StoredProcedures b -> LogicalModels b -> SourceConnConfiguration b -> Maybe QueryTagsConfig -> SourceCustomization -> Maybe (HealthCheckConfig b) -> SourceMetadata b
[_smName] :: SourceMetadata b -> SourceName
[_smKind] :: SourceMetadata b -> BackendSourceKind b
[_smTables] :: SourceMetadata b -> Tables b
[_smFunctions] :: SourceMetadata b -> Functions b
[_smNativeQueries] :: SourceMetadata b -> NativeQueries b
[_smStoredProcedures] :: SourceMetadata b -> StoredProcedures b
[_smLogicalModels] :: SourceMetadata b -> LogicalModels b
[_smConfiguration] :: SourceMetadata b -> SourceConnConfiguration b
[_smQueryTags] :: SourceMetadata b -> Maybe QueryTagsConfig
[_smCustomization] :: SourceMetadata b -> SourceCustomization

-- | 
--   <a>https://hasura.io/docs/latest/deployment/health-checks/source-health-check/</a>
[_smHealthCheckConfig] :: SourceMetadata b -> Maybe (HealthCheckConfig b)
smTables :: forall b_akFcG. Lens' (SourceMetadata b_akFcG) (Tables b_akFcG)
smStoredProcedures :: forall b_akFcG. Lens' (SourceMetadata b_akFcG) (StoredProcedures b_akFcG)
smQueryTags :: forall b_akFcG. Lens' (SourceMetadata b_akFcG) (Maybe QueryTagsConfig)
smNativeQueries :: forall b_akFcG. Lens' (SourceMetadata b_akFcG) (NativeQueries b_akFcG)
smName :: forall b_akFcG. Lens' (SourceMetadata b_akFcG) SourceName
smLogicalModels :: forall b_akFcG. Lens' (SourceMetadata b_akFcG) (LogicalModels b_akFcG)
smKind :: forall b_akFcG. Lens' (SourceMetadata b_akFcG) (BackendSourceKind b_akFcG)
smHealthCheckConfig :: forall b_akFcG. Lens' (SourceMetadata b_akFcG) (Maybe (HealthCheckConfig b_akFcG))
smFunctions :: forall b_akFcG. Lens' (SourceMetadata b_akFcG) (Functions b_akFcG)
smCustomization :: forall b_akFcG. Lens' (SourceMetadata b_akFcG) SourceCustomization
smConfiguration :: forall b_akFcG. Lens' (SourceMetadata b_akFcG) (SourceConnConfiguration b_akFcG)
backendSourceMetadataCodec :: JSONCodec BackendSourceMetadata
mkSourceMetadata :: forall (b :: BackendType). Backend b => SourceName -> BackendSourceKind b -> SourceConnConfiguration b -> SourceCustomization -> Maybe (HealthCheckConfig b) -> BackendSourceMetadata

-- | Source configuration as stored in the Metadata DB for some
--   existentialized backend.
newtype BackendSourceMetadata
BackendSourceMetadata :: AnyBackend SourceMetadata -> BackendSourceMetadata
[unBackendSourceMetadata] :: BackendSourceMetadata -> AnyBackend SourceMetadata
toSourceMetadata :: forall b. Backend b => Prism' BackendSourceMetadata (SourceMetadata b)
getSourceName :: BackendSourceMetadata -> SourceName
type Sources = InsOrdHashMap SourceName BackendSourceMetadata
sourcesCodec :: JSONCodec Sources
parseNonSourcesMetadata :: Object -> Parser (RemoteSchemas, QueryCollections, MetadataAllowlist, CustomTypes, Actions, CronTriggers, ApiLimit, MetricsConfig, InheritedRoles, SetGraphqlIntrospectionOptions)

-- | This newtype simply wraps the BackendConfig type family so that it can
--   be used with BackendMap in the Metadata type. GHC will not allow the
--   type family to be used directly. :(
newtype BackendConfigWrapper b
BackendConfigWrapper :: BackendConfig b -> BackendConfigWrapper b
[unBackendConfigWrapper] :: BackendConfigWrapper b -> BackendConfig b
data CatalogStateType
CSTCli :: CatalogStateType
CSTConsole :: CatalogStateType
data SetCatalogState
SetCatalogState :: CatalogStateType -> Value -> SetCatalogState
[_scsType] :: SetCatalogState -> CatalogStateType
[_scsState] :: SetCatalogState -> Value
data CatalogState
CatalogState :: Text -> Value -> Value -> CatalogState
[_csId] :: CatalogState -> Text
[_csCliState] :: CatalogState -> Value
[_csConsoleState] :: CatalogState -> Value
data GetCatalogState
GetCatalogState :: GetCatalogState
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.BackendSourceMetadata
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.BackendSourceMetadata
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Common.CatalogState
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.CatalogState
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.CatalogState
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance GHC.Base.Semigroup (Hasura.RQL.Types.Backend.BackendConfig b) => GHC.Base.Semigroup (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance GHC.Base.Monoid (Hasura.RQL.Types.Backend.BackendConfig b) => GHC.Base.Monoid (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.GetCatalogState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.CatalogState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.SetCatalogState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Common.CatalogStateType
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Metadata.Common.BackendConfigWrapper b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Extended.FromJSONWithContext (Hasura.RQL.Types.BackendType.BackendSourceKind b) (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Metadata.Common.SourceMetadata b)

module Hasura.RQL.Types.Source
data SourceInfo b
SourceInfo :: SourceName -> BackendSourceKind b -> TableCache b -> FunctionCache b -> NativeQueryCache b -> StoredProcedureCache b -> LogicalModelCache b -> ~SourceConfig b -> Maybe QueryTagsConfig -> ResolvedSourceCustomization -> DBObjectsIntrospection b -> SourceInfo b
[_siName] :: SourceInfo b -> SourceName
[_siSourceKind] :: SourceInfo b -> BackendSourceKind b
[_siTables] :: SourceInfo b -> TableCache b
[_siFunctions] :: SourceInfo b -> FunctionCache b
[_siNativeQueries] :: SourceInfo b -> NativeQueryCache b
[_siStoredProcedures] :: SourceInfo b -> StoredProcedureCache b
[_siLogicalModels] :: SourceInfo b -> LogicalModelCache b
[_siConfiguration] :: SourceInfo b -> ~SourceConfig b
[_siQueryTagsConfig] :: SourceInfo b -> Maybe QueryTagsConfig
[_siCustomization] :: SourceInfo b -> ResolvedSourceCustomization
[_siDbObjectsIntrospection] :: SourceInfo b -> DBObjectsIntrospection b
type BackendSourceInfo = AnyBackend SourceInfo
type SourceCache = HashMap SourceName BackendSourceInfo
unsafeSourceInfo :: forall b. HasTag b => BackendSourceInfo -> Maybe (SourceInfo b)
unsafeSourceName :: BackendSourceInfo -> SourceName
unsafeSourceTables :: forall b. HasTag b => BackendSourceInfo -> Maybe (TableCache b)
unsafeSourceFunctions :: forall b. HasTag b => BackendSourceInfo -> Maybe (FunctionCache b)
unsafeSourceConfiguration :: forall b. HasTag b => BackendSourceInfo -> Maybe (SourceConfig b)
unsafeSourceLogicalModels :: forall b. HasTag b => BackendSourceInfo -> Maybe (LogicalModelCache b)

-- | Contains metadata (introspection) from the database, used to build the
--   schema cache. This type only contains results of introspecting DB
--   objects, i.e. the DB types specified by tables, functions, and
--   scalars. Notably, it does not include the additional introspection
--   that takes place on Postgres, namely reading the contents of tables
--   used as Enum Values -- see <tt>fetchAndValidateEnumValues</tt>.
data DBObjectsIntrospection b
DBObjectsIntrospection :: DBTablesMetadata b -> DBFunctionsMetadata b -> ScalarMap b -> LogicalModels b -> DBObjectsIntrospection b
[_rsTables] :: DBObjectsIntrospection b -> DBTablesMetadata b
[_rsFunctions] :: DBObjectsIntrospection b -> DBFunctionsMetadata b
[_rsScalars] :: DBObjectsIntrospection b -> ScalarMap b
[_rsLogicalModels] :: DBObjectsIntrospection b -> LogicalModels b

-- | A map from GraphQL name to equivalent scalar type for a given backend.
newtype ScalarMap b
ScalarMap :: HashMap Name (ScalarType b) -> ScalarMap b

-- | FIXME: this should be either in <tt>BackendMetadata</tt>, or into a
--   new dedicated <tt>BackendResolve</tt>, instead of listing backends
--   explicitly. It could also be moved to the app level.
type SourceResolver b = Environment -> SourceName -> SourceConnConfiguration b -> IO (Either QErr (SourceConfig b))
class (Monad m) => MonadResolveSource m
getPGSourceResolver :: MonadResolveSource m => m (SourceResolver ('Postgres 'Vanilla))
getMSSQLSourceResolver :: MonadResolveSource m => m (SourceResolver 'MSSQL)
data MaintenanceModeVersion

-- | should correspond to the source catalog version from which the user is
--   migrating from
PreviousMMVersion :: MaintenanceModeVersion

-- | should correspond to the latest source catalog version
CurrentMMVersion :: MaintenanceModeVersion
data SourceHealthCheckInfo b
SourceHealthCheckInfo :: SourceName -> SourceConnConfiguration b -> HealthCheckConfig b -> SourceHealthCheckInfo b
[_shciName] :: SourceHealthCheckInfo b -> SourceName
[_shciConnection] :: SourceHealthCheckInfo b -> SourceConnConfiguration b
[_shciHealthCheck] :: SourceHealthCheckInfo b -> HealthCheckConfig b
type BackendSourceHealthCheckInfo = AnyBackend SourceHealthCheckInfo
type SourceHealthCheckCache = HashMap SourceName BackendSourceHealthCheckInfo
data SourcePingInfo b
SourcePingInfo :: SourceName -> SourceConnConfiguration b -> SourcePingInfo b
[_spiName] :: SourcePingInfo b -> SourceName
[_spiConnection] :: SourcePingInfo b -> SourceConnConfiguration b
type BackendSourcePingInfo = AnyBackend SourcePingInfo
type SourcePingCache = HashMap SourceName BackendSourcePingInfo
siTables :: forall b_akOcZ. Lens' (SourceInfo b_akOcZ) (TableCache b_akOcZ)
siStoredProcedures :: forall b_akOcZ. Lens' (SourceInfo b_akOcZ) (StoredProcedureCache b_akOcZ)
siSourceKind :: forall b_akOcZ. Lens' (SourceInfo b_akOcZ) (BackendSourceKind b_akOcZ)
siQueryTagsConfig :: forall b_akOcZ. Lens' (SourceInfo b_akOcZ) (Maybe QueryTagsConfig)
siNativeQueries :: forall b_akOcZ. Lens' (SourceInfo b_akOcZ) (NativeQueryCache b_akOcZ)
siName :: forall b_akOcZ. Lens' (SourceInfo b_akOcZ) SourceName
siLogicalModels :: forall b_akOcZ. Lens' (SourceInfo b_akOcZ) (LogicalModelCache b_akOcZ)
siFunctions :: forall b_akOcZ. Lens' (SourceInfo b_akOcZ) (FunctionCache b_akOcZ)
siDbObjectsIntrospection :: forall b_akOcZ. Lens' (SourceInfo b_akOcZ) (DBObjectsIntrospection b_akOcZ)
siCustomization :: forall b_akOcZ. Lens' (SourceInfo b_akOcZ) ResolvedSourceCustomization
siConfiguration :: forall b_akOcZ. Lens' (SourceInfo b_akOcZ) (SourceConfig b_akOcZ)
instance GHC.Base.Monoid (Hasura.RQL.Types.Source.ScalarMap b)
instance GHC.Base.Semigroup (Hasura.RQL.Types.Source.ScalarMap b)
instance GHC.Generics.Generic (Hasura.RQL.Types.Source.DBObjectsIntrospection b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.DBObjectsIntrospection b)
instance GHC.Classes.Eq Hasura.RQL.Types.Source.MaintenanceModeVersion
instance GHC.Show.Show Hasura.RQL.Types.Source.MaintenanceModeVersion
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.Source.ScalarMap b)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Hasura.Tracing.Monad.TraceT m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON (Hasura.Table.Cache.TableCache b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.Cache.FunctionCache b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.Cache.NativeQueryCache b), Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.Cache.StoredProcedureCache b), Data.Aeson.Types.ToJSON.ToJSON Hasura.QueryTags.Types.QueryTagsConfig, Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SourceCustomization.SourceCustomization) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.SourceInfo b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Source.DBObjectsIntrospection b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Source.DBObjectsIntrospection b)
instance Hasura.Logging.ToEngineLog (Hasura.RQL.Types.Source.DBObjectsIntrospection b) Hasura.Logging.Hasura


-- | This is taken from wai-logger and customised for our use
module Hasura.Server.Logging
data StartupLog
StartupLog :: !LogLevel -> !Text -> !Value -> StartupLog
[slLogLevel] :: StartupLog -> !LogLevel
[slKind] :: StartupLog -> !Text
[slInfo] :: StartupLog -> !Value
data PGLog
PGLog :: !LogLevel -> !Value -> PGLog
[plLogLevel] :: PGLog -> !LogLevel
[plMessage] :: PGLog -> !Value
data MetadataLog
MetadataLog :: !LogLevel -> !Text -> !Value -> MetadataLog
[mlLogLevel] :: MetadataLog -> !LogLevel
[mlMessage] :: MetadataLog -> !Text
[mlInfo] :: MetadataLog -> !Value
mkInconsMetadataLog :: [InconsistentMetadata] -> MetadataLog
data WebHookLog
WebHookLog :: !LogLevel -> !Maybe Status -> !Text -> !StdMethod -> !Maybe HttpException -> !Maybe Text -> !Maybe Text -> WebHookLog
[whlLogLevel] :: WebHookLog -> !LogLevel
[whlStatusCode] :: WebHookLog -> !Maybe Status
[whlUrl] :: WebHookLog -> !Text
[whlMethod] :: WebHookLog -> !StdMethod
[whlError] :: WebHookLog -> !Maybe HttpException
[whlResponse] :: WebHookLog -> !Maybe Text
[whlMessage] :: WebHookLog -> !Maybe Text

-- | GQLQueryOperationSuccessLog captures all the data required to
--   construct an HTTP success log.
data GQLQueryOperationSuccessLog
GQLQueryOperationSuccessLog :: !GQLReqUnparsed -> !DiffTime -> !Int64 -> !Int64 -> !ParameterizedQueryHash -> GQLQueryOperationSuccessLog
[gqolQuery] :: GQLQueryOperationSuccessLog -> !GQLReqUnparsed
[gqolQueryExecutionTime] :: GQLQueryOperationSuccessLog -> !DiffTime
[gqolResponseSize] :: GQLQueryOperationSuccessLog -> !Int64
[gqolRequestSize] :: GQLQueryOperationSuccessLog -> !Int64
[gqolParameterizedQueryHash] :: GQLQueryOperationSuccessLog -> !ParameterizedQueryHash

-- | GQLQueryOperationErrorLog captures the request along with the error
--   message
data GQLQueryOperationErrorLog
GQLQueryOperationErrorLog :: !GQLReqUnparsed -> !QErr -> GQLQueryOperationErrorLog
[gqelQuery] :: GQLQueryOperationErrorLog -> !GQLReqUnparsed
[gqelError] :: GQLQueryOperationErrorLog -> !QErr
data GQLBatchQueryOperationLog
GQLQueryOperationSuccess :: !GQLQueryOperationSuccessLog -> GQLBatchQueryOperationLog
GQLQueryOperationError :: !GQLQueryOperationErrorLog -> GQLBatchQueryOperationLog

-- | whether a request is executed in batched mode or not
data RequestMode

-- | this request is batched
RequestModeBatched :: RequestMode

-- | this is a single request
RequestModeSingle :: RequestMode

-- | this request is of a kind for which batching is not done or does not
--   make sense
RequestModeNonBatchable :: RequestMode

-- | the execution of this request failed
RequestModeError :: RequestMode
data CommonHttpLogMetadata
CommonHttpLogMetadata :: !RequestMode -> !Maybe (GQLBatchedReqs GQLBatchQueryOperationLog) -> CommonHttpLogMetadata
[_chlmRequestMode] :: CommonHttpLogMetadata -> !RequestMode
[_chlmBatchOperationLog] :: CommonHttpLogMetadata -> !Maybe (GQLBatchedReqs GQLBatchQueryOperationLog)
type HttpLogGraphQLInfo = (CommonHttpLogMetadata, ParameterizedQueryHashList)
emptyHttpLogGraphQLInfo :: HttpLogGraphQLInfo

-- | The http-log metadata attached to HTTP requests running in the monad
--   <tt>m</tt>, split into a common portion that is present regardless of
--   <tt>m</tt>, and a monad-specific one defined in the <a>HttpLog</a>
--   instance.
--   
--   This allows us to not have to duplicate the code that generates the
--   common part of the metadata across OSS and Pro, so that instances only
--   have to implement the part of it unique to them.
type HttpLogMetadata m = (CommonHttpLogMetadata, ExtraHttpLogMetadata m)
buildHttpLogMetadata :: forall m. HttpLog m => HttpLogGraphQLInfo -> ExtraUserInfo -> HttpLogMetadata m

-- | synonym for clarity, writing `emptyHttpLogMetadata <tt>m` instead of
--   `def </tt>(HttpLogMetadata m)`
emptyHttpLogMetadata :: forall m. HttpLog m => HttpLogMetadata m
data MetadataQueryLoggingMode
MetadataQueryLoggingEnabled :: MetadataQueryLoggingMode
MetadataQueryLoggingDisabled :: MetadataQueryLoggingMode

-- | Setting used to control the information in logs
data LoggingSettings
LoggingSettings :: HashSet (EngineLogType Hasura) -> MetadataQueryLoggingMode -> LoggingSettings

-- | this is only required for the short-term fix in
--   <a>https://github.com/hasura/graphql-engine-mono/issues/1770</a> See
--   Note [Disable query printing when query-log is disabled]
[_lsEnabledLogTypes] :: LoggingSettings -> HashSet (EngineLogType Hasura)
[_lsMetadataQueryLoggingMode] :: LoggingSettings -> MetadataQueryLoggingMode
class (Monad m) => HttpLog m where {
    
    -- | Extra http-log metadata that we attach when operating in <tt>m</tt>.
    type ExtraHttpLogMetadata m;
}
emptyExtraHttpLogMetadata :: HttpLog m => ExtraHttpLogMetadata m
buildExtraHttpLogMetadata :: HttpLog m => ParameterizedQueryHashList -> ExtraUserInfo -> ExtraHttpLogMetadata m
logHttpError :: HttpLog m => Logger Hasura -> LoggingSettings -> Maybe UserInfo -> RequestId -> Request -> (ByteString, Maybe Value) -> QErr -> [Header] -> HttpLogMetadata m -> m ()
logHttpSuccess :: HttpLog m => Logger Hasura -> LoggingSettings -> Maybe UserInfo -> RequestId -> Request -> (ByteString, Maybe Value) -> ByteString -> ByteString -> Maybe (DiffTime, DiffTime) -> Maybe CompressionType -> [Header] -> HttpLogMetadata m -> m ()

-- | Log information about the HTTP request
data HttpInfoLog
HttpInfoLog :: !Status -> !Text -> !IpAddress -> !Text -> !HttpVersion -> !Maybe CompressionType -> ![Header] -> HttpInfoLog
[hlStatus] :: HttpInfoLog -> !Status
[hlMethod] :: HttpInfoLog -> !Text
[hlSource] :: HttpInfoLog -> !IpAddress
[hlPath] :: HttpInfoLog -> !Text
[hlHttpVersion] :: HttpInfoLog -> !HttpVersion
[hlCompression] :: HttpInfoLog -> !Maybe CompressionType

-- | all the request headers
[hlHeaders] :: HttpInfoLog -> ![Header]

-- | Information about a GraphQL/Hasura metadata operation over HTTP
data OperationLog
OperationLog :: !RequestId -> !Maybe SessionVariables -> !Maybe Int64 -> !Int64 -> !Maybe Seconds -> !Maybe Seconds -> !Maybe Value -> !Maybe Text -> !Maybe QErr -> !RequestMode -> OperationLog
[olRequestId] :: OperationLog -> !RequestId
[olUserVars] :: OperationLog -> !Maybe SessionVariables
[olResponseSize] :: OperationLog -> !Maybe Int64

-- | Response size before compression
[olUncompressedResponseSize] :: OperationLog -> !Int64

-- | Request IO wait time, i.e. time spent reading the full request from
--   the socket.
[olRequestReadTime] :: OperationLog -> !Maybe Seconds

-- | Service time, not including request IO wait time.
[olQueryExecutionTime] :: OperationLog -> !Maybe Seconds
[olQuery] :: OperationLog -> !Maybe Value
[olRawQuery] :: OperationLog -> !Maybe Text
[olError] :: OperationLog -> !Maybe QErr
[olRequestMode] :: OperationLog -> !RequestMode
data HttpLogContext
HttpLogContext :: !HttpInfoLog -> !OperationLog -> !RequestId -> !Maybe (NonEmpty BatchOperationLog) -> HttpLogContext
[hlcHttpInfo] :: HttpLogContext -> !HttpInfoLog
[hlcOperation] :: HttpLogContext -> !OperationLog
[hlcRequestId] :: HttpLogContext -> !RequestId
[hlcBatchedOperations] :: HttpLogContext -> !Maybe (NonEmpty BatchOperationLog)
mkHttpAccessLogContext :: Maybe UserInfo -> LoggingSettings -> RequestId -> Request -> (ByteString, Maybe Value) -> Int64 -> ByteString -> Maybe (DiffTime, DiffTime) -> Maybe CompressionType -> [Header] -> RequestMode -> Maybe (GQLBatchedReqs GQLBatchQueryOperationLog) -> HttpLogContext
mkHttpErrorLogContext :: Maybe UserInfo -> LoggingSettings -> RequestId -> Request -> (ByteString, Maybe Value) -> QErr -> Maybe (DiffTime, DiffTime) -> Maybe CompressionType -> [Header] -> HttpLogContext
mkHttpLog :: HttpLogContext -> HttpLogLine

-- | Log warning messages for deprecated environment variables
logDeprecatedEnvVars :: Logger Hasura -> Environment -> SourceCache -> IO ()
data SchemaSyncThreadType
TTListener :: SchemaSyncThreadType
TTProcessor :: SchemaSyncThreadType
TTMetadataApi :: SchemaSyncThreadType
data SchemaSyncLog
SchemaSyncLog :: !LogLevel -> !SchemaSyncThreadType -> !Value -> SchemaSyncLog
[sslLogLevel] :: SchemaSyncLog -> !LogLevel
[sslThreadType] :: SchemaSyncLog -> !SchemaSyncThreadType
[sslInfo] :: SchemaSyncLog -> !Value
instance GHC.Classes.Eq Hasura.Server.Logging.StartupLog
instance GHC.Classes.Eq Hasura.Server.Logging.PGLog
instance GHC.Classes.Eq Hasura.Server.Logging.MetadataLog
instance GHC.Generics.Generic Hasura.Server.Logging.GQLQueryOperationSuccessLog
instance GHC.Classes.Eq Hasura.Server.Logging.GQLQueryOperationSuccessLog
instance GHC.Generics.Generic Hasura.Server.Logging.GQLQueryOperationErrorLog
instance GHC.Classes.Eq Hasura.Server.Logging.GQLQueryOperationErrorLog
instance GHC.Classes.Eq Hasura.Server.Logging.GQLBatchQueryOperationLog
instance GHC.Classes.Eq Hasura.Server.Logging.RequestMode
instance GHC.Classes.Eq Hasura.Server.Logging.CommonHttpLogMetadata
instance GHC.Classes.Eq Hasura.Server.Logging.MetadataQueryLoggingMode
instance GHC.Show.Show Hasura.Server.Logging.MetadataQueryLoggingMode
instance GHC.Classes.Eq Hasura.Server.Logging.LoggingSettings
instance GHC.Classes.Eq Hasura.Server.Logging.HttpInfoLog
instance GHC.Generics.Generic Hasura.Server.Logging.OperationLog
instance GHC.Classes.Eq Hasura.Server.Logging.OperationLog
instance GHC.Generics.Generic Hasura.Server.Logging.BatchOperationSuccessLog
instance GHC.Classes.Eq Hasura.Server.Logging.BatchOperationSuccessLog
instance GHC.Generics.Generic Hasura.Server.Logging.BatchOperationErrorLog
instance GHC.Classes.Eq Hasura.Server.Logging.BatchOperationErrorLog
instance GHC.Classes.Eq Hasura.Server.Logging.BatchOperationLog
instance GHC.Generics.Generic Hasura.Server.Logging.HttpLogContext
instance GHC.Classes.Eq Hasura.Server.Logging.HttpLogContext
instance GHC.Classes.Eq Hasura.Server.Logging.SchemaSyncThreadType
instance GHC.Classes.Eq Hasura.Server.Logging.SchemaSyncLog
instance GHC.Show.Show Hasura.Server.Logging.SchemaSyncLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.SchemaSyncLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.SchemaSyncLog Hasura.Logging.Hasura
instance GHC.Show.Show Hasura.Server.Logging.SchemaSyncThreadType
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.HttpLogLine Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.HttpLogContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.BatchOperationLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.BatchOperationErrorLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.BatchOperationSuccessLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.OperationLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.HttpInfoLog
instance Hasura.Server.Logging.HttpLog m => Hasura.Server.Logging.HttpLog (Hasura.Tracing.Monad.TraceT m)
instance Hasura.Server.Logging.HttpLog m => Hasura.Server.Logging.HttpLog (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.Logging.HttpLog m => Hasura.Server.Logging.HttpLog (Control.Monad.Trans.Except.ExceptT e m)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Logging.MetadataQueryLoggingMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.MetadataQueryLoggingMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.RequestMode
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.GQLBatchQueryOperationLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.GQLQueryOperationErrorLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.GQLQueryOperationSuccessLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.WebHookLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.WebHookLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.MetadataLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.MetadataLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.PGLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.PGLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Logging.StartupLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Logging.StartupLog Hasura.Logging.Hasura

module Hasura.Server.Migrate.Version

-- | Represents the catalog version. This is stored in the database and
--   then compared with the latest version on startup.
data MetadataCatalogVersion

-- | A typical catalog version.
MetadataCatalogVersion :: Int -> MetadataCatalogVersion

-- | Maintained for compatibility with catalog version 0.8.
MetadataCatalogVersion08 :: MetadataCatalogVersion

-- | This is the source catalog version, used when deciding whether to
--   (re-)create event triggers.
newtype SourceCatalogVersion (backend :: BackendType)
SourceCatalogVersion :: Int -> SourceCatalogVersion (backend :: BackendType)
[unSourceCatalogVersion] :: SourceCatalogVersion (backend :: BackendType) -> Int
data SourceCatalogMigrationState

-- | Source has not been initialized yet.
SCMSUninitializedSource :: SourceCatalogMigrationState

-- | Source catalog is already at the latest catalog version.
SCMSNothingToDo :: Int -> SourceCatalogMigrationState

-- | Initialization of the source catalog along with the catalog version.
SCMSInitialized :: Int -> SourceCatalogMigrationState

-- | Source catalog migration <a>catalog version</a> to <a>catalog
--   version</a>.
SCMSMigratedTo :: Int -> Int -> SourceCatalogMigrationState

-- | Source catalog migration on hold with reason (Maintenance mode, read
--   only mode etc).
SCMSMigrationOnHold :: Text -> SourceCatalogMigrationState
SCMSNotSupported :: SourceCatalogMigrationState
instance Language.Haskell.TH.Syntax.Lift Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Classes.Eq Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance Language.Haskell.TH.Syntax.Lift (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Read.Read (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Show.Show (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Enum.Enum (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance GHC.Classes.Eq (Hasura.Server.Migrate.Version.SourceCatalogVersion backend)
instance Hasura.Logging.ToEngineLog (Hasura.RQL.Types.Common.SourceName, Hasura.Server.Migrate.Version.SourceCatalogMigrationState) Hasura.Logging.Hasura
instance GHC.Classes.Ord Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Enum.Enum Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Show.Show Hasura.Server.Migrate.Version.MetadataCatalogVersion
instance GHC.Read.Read Hasura.Server.Migrate.Version.MetadataCatalogVersion


-- | A module that defines the current catalog version and nothing else.
--   This is necessary to circumvent the unfortunate â€œGHC stage
--   restriction,â€ which prevents us from using a binding in a compile-time
--   splice unless it is defined in a different module. The actual
--   migration code is in <a>Hasura.Server.Migrate</a>.
module Hasura.Server.Migrate.LatestVersion

-- | The current catalog schema version. We store this in a file because we
--   want to append the current verson to the catalog_versions file when
--   tagging a new release, in <tt>tag-release.sh</tt>.
latestCatalogVersion :: MetadataCatalogVersion
latestCatalogVersionString :: Text

module Hasura.Server.Migrate.Internal

-- | The old 0.8 catalog version is non-integral, so the version has always
--   been stored as a string.
getCatalogVersion :: TxE QErr MetadataCatalogVersion
from3To4 :: forall m. (Backend ('Postgres 'Vanilla), MonadTx m) => m ()
setCatalogVersion :: MonadTx m => Text -> UTCTime -> m ()


-- | Postgres DDL Source Version
--   
--   Deals with catalog version - used by <a>Source</a>.
module Hasura.Backends.Postgres.DDL.Source.Version
type SourceCatalogVersion (pgKind :: PostgresKind) = SourceCatalogVersion ('Postgres pgKind)
initialSourceCatalogVersion :: SourceCatalogVersion pgKind
latestSourceCatalogVersion :: SourceCatalogVersion pgKind
previousSourceCatalogVersions :: [SourceCatalogVersion pgKind]
setSourceCatalogVersion :: MonadTx m => m ()
getSourceCatalogVersion :: MonadTx m => m (SourceCatalogVersion postgres)

module Hasura.Backends.MSSQL.DDL.Source.Version
type SourceCatalogVersion = SourceCatalogVersion 'MSSQL
initialSourceCatalogVersion :: SourceCatalogVersion
latestSourceCatalogVersion :: SourceCatalogVersion
previousSourceCatalogVersions :: [SourceCatalogVersion]
setSourceCatalogVersion :: MonadMSSQLTx m => SourceCatalogVersion -> m ()
getSourceCatalogVersion :: MonadMSSQLTx m => m SourceCatalogVersion

module Hasura.Server.Auth.WebHook
data AuthHookType
AHTGet :: AuthHookType
AHTPost :: AuthHookType
data AuthHook
AuthHook :: Text -> AuthHookType -> Bool -> AuthHook
[ahUrl] :: AuthHook -> Text
[ahType] :: AuthHook -> AuthHookType

-- | Whether to send the request body to the auth hook
[ahSendRequestBody] :: AuthHook -> Bool

-- | Makes an authentication request to the given AuthHook and returns
--   UserInfo parsed from the response, plus an expiration time if one was
--   returned. Optionally passes a batch of raw GraphQL requests for
--   finer-grained auth. (#2666)
userInfoFromAuthHook :: forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => Logger Hasura -> Manager -> AuthHook -> [Header] -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])
instance GHC.Classes.Eq Hasura.Server.Auth.WebHook.AuthHookType
instance GHC.Classes.Eq Hasura.Server.Auth.WebHook.AuthHook
instance GHC.Show.Show Hasura.Server.Auth.WebHook.AuthHook
instance GHC.Show.Show Hasura.Server.Auth.WebHook.AuthHookType

module Hasura.Server.Auth

-- | Typeclass representing the <tt>UserInfo</tt> authorization and
--   resolving effect
class (Monad m) => UserAuthentication m
resolveUserInfo :: UserAuthentication m => Logger Hasura -> Manager -> [Header] -> AuthMode -> Maybe ReqsText -> m (Either QErr (UserInfo, Maybe UTCTime, [Header], ExtraUserInfo))

-- | The hashed admin password. <a>hashAdminSecret</a> is our public
--   interface for constructing the secret.
--   
--   To prevent misuse and leaking we keep this opaque and don't provide
--   instances that could leak information. Likewise for <a>AuthMode</a>.
--   
--   Although this exists only in memory we store only a hash of the admin
--   secret primarily in order to:
--   
--   <ul>
--   <li>prevent theoretical timing attacks from a naive <a>==</a>
--   check</li>
--   <li>prevent misuse or inadvertent leaking of the secret</li>
--   </ul>
data AdminSecretHash
unsafeMkAdminSecretHash :: Digest SHA512 -> AdminSecretHash
hashAdminSecret :: Text -> AdminSecretHash

-- | The methods we'll use to derive roles for authenticating requests.
--   
--   <tt>Maybe RoleName</tt> below is the optionally-defined role for the
--   unauthenticated (anonymous) user.
--   
--   See:
--   <a>https://hasura.io/docs/latest/graphql/core/auth/authentication/unauthenticated-access.html</a>
data AuthMode
AMNoAuth :: AuthMode
AMAdminSecret :: !HashSet AdminSecretHash -> !Maybe RoleName -> AuthMode
AMAdminSecretAndHook :: !HashSet AdminSecretHash -> !AuthHook -> AuthMode
AMAdminSecretAndJWT :: !HashSet AdminSecretHash -> ![JWTCtx] -> !Maybe RoleName -> AuthMode

-- | In case JWT is used as an authentication mode, the JWKs are stored
--   inside JWTCtx as an <tt>IORef</tt>. <tt>IORef</tt> has pointer
--   equality, so we need to compare the values inside the <tt>IORef</tt>
--   to check if the <a>JWTCtx</a> is same.
compareAuthMode :: AuthMode -> AuthMode -> IO Bool

-- | Validate the user's requested authentication configuration, launching
--   any required maintenance threads for JWT etc.
--   
--   This must only be run once, on launch.
setupAuthMode :: (MonadError Text m, MonadIO m, MonadBaseControl IO m) => HashSet AdminSecretHash -> Maybe AuthHook -> [JWTConfig] -> Maybe RoleName -> Logger Hasura -> Manager -> m AuthMode
mkJwtCtx :: (MonadIO m, MonadBaseControl IO m, MonadError Text m) => JWTConfig -> Logger Hasura -> Manager -> m JWTCtx

-- | Update the JWK based on the expiry time specified in <tt>Expires</tt>
--   header or <tt>Cache-Control</tt> header
updateJwkCtx :: forall m. (MonadIO m, MonadBaseControl IO m) => AuthMode -> Manager -> Logger Hasura -> m ()
updateJwkFromUrl :: forall m. (MonadIO m, MonadBaseControl IO m) => JWTCtx -> Manager -> Logger Hasura -> m ()

-- | Authenticate the request using the headers and the configured
--   <a>AuthMode</a>.
getUserInfoWithExpTime :: forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => Logger Hasura -> Manager -> [Header] -> AuthMode -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])
getUserInfoWithExpTime_ :: forall m mgr logger. (MonadIO m, MonadError QErr m) => (logger -> mgr -> AuthHook -> [Header] -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])) -> ([JWTCtx] -> [Header] -> Maybe RoleName -> m (UserInfo, Maybe UTCTime, [Header], Maybe JWTCtx)) -> logger -> mgr -> [Header] -> AuthMode -> Maybe ReqsText -> m (UserInfo, Maybe UTCTime, [Header])
instance GHC.Classes.Eq Hasura.Server.Auth.AdminSecretHash
instance GHC.Classes.Ord Hasura.Server.Auth.AdminSecretHash
instance GHC.Show.Show Hasura.Server.Auth.AuthMode
instance GHC.Classes.Eq Hasura.Server.Auth.AuthMode
instance Data.Hashable.Class.Hashable Hasura.Server.Auth.AdminSecretHash
instance GHC.Show.Show Hasura.Server.Auth.AdminSecretHash

module Hasura.PingSources

-- | A forever running IO loop that performs regular pings for DBs that
--   need it these are used to send a fingerprint to third parties that
--   wish to attribute users to Hasura
runPingSources :: Environment -> (String -> IO ()) -> IO SourcePingCache -> IO a

module Hasura.Backends.BigQuery.DDL.Source
resolveSourceConfig :: MonadIO m => SourceName -> BigQueryConnSourceConfig -> BackendSourceKind 'BigQuery -> BackendConfig 'BigQuery -> Environment -> manager -> m (Either QErr BigQuerySourceConfig)
resolveSource :: MonadIO m => BigQuerySourceConfig -> m (Either QErr (DBObjectsIntrospection 'BigQuery))
restTypeToScalarType :: RestType -> ScalarType
postDropSourceHook :: MonadIO m => BigQuerySourceConfig -> TableEventTriggers 'BigQuery -> m ()


-- | BigQuery DDL ComputedField
--   
--   Implementation to build <a>ComputedFieldInfo</a> for a BigQuery table
--   from metadata
module Hasura.Backends.BigQuery.DDL.ComputedField

-- | Validate computed field metadata and build field information
buildComputedFieldInfo :: forall m. MonadError QErr m => HashSet TableName -> TableName -> HashSet ColumnName -> ComputedFieldName -> ComputedFieldDefinition -> RestRoutine -> Comment -> m (ComputedFieldInfo 'BigQuery)


-- | Helpers used in the implementations of <tt>metadataToOrdJSON</tt> and
--   <tt>metadataToDTO</tt>
module Hasura.RQL.Types.Metadata.Serialization
sourcesToOrdJSONList :: Sources -> Array
remoteSchemasToOrdJSONList :: RemoteSchemas -> Maybe Array
backendConfigsToOrdJSON :: BackendMap BackendConfigWrapper -> Maybe Value
openTelemetryConfigToOrdJSON :: OpenTelemetryConfig -> Maybe Value
inheritedRolesToOrdJSONList :: InheritedRoles -> Maybe Array
queryCollectionsToOrdJSONList :: QueryCollections -> Maybe Array
allowlistToOrdJSONList :: MetadataAllowlist -> Maybe Array
apiLimitsToOrdJSON :: ApiLimit -> Maybe Value
cronTriggersToOrdJSONList :: CronTriggers -> Maybe Array
customTypesToOrdJSON :: CustomTypes -> Maybe Object
endpointsToOrdJSONList :: Endpoints -> Maybe Array
introspectionDisabledRolesToOrdJSON :: SetGraphqlIntrospectionOptions -> Maybe Value
metricsConfigToOrdJSON :: MetricsConfig -> Maybe Value
networkConfigToOrdJSON :: Network -> Maybe Value
actionMetadataToOrdJSONList :: Actions -> Maybe Array

module Hasura.GraphQL.Execute.Action.Types
newtype ActionExecution
ActionExecution :: (forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m) => m (EncJSON, ResponseHeaders)) -> ActionExecution
[unActionExecution] :: ActionExecution -> forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m) => m (EncJSON, ResponseHeaders)
data AsyncActionQuerySourceExecution v
AsyncActionQuerySourceExecution :: !SourceName -> !JsonAggSelect -> !ActionLogResponse -> AnnSimpleSelectG ('Postgres 'Vanilla) Void v -> AsyncActionQuerySourceExecution v
[_aaqseSource] :: AsyncActionQuerySourceExecution v -> !SourceName
[_aaqseJsonAggSelect] :: AsyncActionQuerySourceExecution v -> !JsonAggSelect
[_aaqseSelectBuilder] :: AsyncActionQuerySourceExecution v -> !ActionLogResponse -> AnnSimpleSelectG ('Postgres 'Vanilla) Void v
data AsyncActionQueryExecution v

-- | Async actions associated with no relationships.
AAQENoRelationships :: !ActionLogResponse -> Either QErr EncJSON -> AsyncActionQueryExecution v

-- | Async actions with relationships defined to Postgres (as of now, we
--   may have support for other backends as well in further iterations)
--   tables.
AAQEOnSourceDB :: !SourceConfig ('Postgres 'Vanilla) -> !AsyncActionQuerySourceExecution v -> AsyncActionQueryExecution v

-- | A plan to execute async action query
data AsyncActionQueryExecutionPlan
AsyncActionQueryExecutionPlan :: !ActionId -> !AsyncActionQueryExecution (UnpreparedValue ('Postgres 'Vanilla)) -> AsyncActionQueryExecutionPlan
[_aaqepId] :: AsyncActionQueryExecutionPlan -> !ActionId
[_aaqepExecution] :: AsyncActionQueryExecutionPlan -> !AsyncActionQueryExecution (UnpreparedValue ('Postgres 'Vanilla))
data ActionExecutionPlan
AEPSync :: !ActionExecution -> ActionExecutionPlan
AEPAsyncQuery :: !AsyncActionQueryExecutionPlan -> ActionExecutionPlan
AEPAsyncMutation :: !ActionId -> ActionExecutionPlan
newtype ActionContext
ActionContext :: ActionName -> ActionContext
[_acName] :: ActionContext -> ActionName
data ActionWebhookPayload
ActionWebhookPayload :: !ActionContext -> !SessionVariables -> !Value -> !Maybe GQLQueryText -> ActionWebhookPayload
[_awpAction] :: ActionWebhookPayload -> !ActionContext
[_awpSessionVariables] :: ActionWebhookPayload -> !SessionVariables
[_awpInput] :: ActionWebhookPayload -> !Value
[_awpRequestQuery] :: ActionWebhookPayload -> !Maybe GQLQueryText
data ActionWebhookErrorResponse
ActionWebhookErrorResponse :: !Text -> !Maybe Text -> !Maybe Value -> ActionWebhookErrorResponse
[_awerMessage] :: ActionWebhookErrorResponse -> !Text
[_awerCode] :: ActionWebhookErrorResponse -> !Maybe Text
[_awerExtensions] :: ActionWebhookErrorResponse -> !Maybe Value
type ActionWebhookResponse = Value
data ActionRequestInfo
ActionRequestInfo :: !Text -> !Value -> ![HeaderConf] -> !Maybe Request -> ActionRequestInfo
[_areqiUrl] :: ActionRequestInfo -> !Text
[_areqiBody] :: ActionRequestInfo -> !Value
[_areqiHeaders] :: ActionRequestInfo -> ![HeaderConf]
[_areqiTransformedRequest] :: ActionRequestInfo -> !Maybe Request
data ActionResponseInfo
ActionResponseInfo :: !Int -> !Value -> ![HeaderConf] -> ActionResponseInfo
[_aresiStatus] :: ActionResponseInfo -> !Int
[_aresiBody] :: ActionResponseInfo -> !Value
[_aresiHeaders] :: ActionResponseInfo -> ![HeaderConf]
data ActionInternalError
ActionInternalError :: !Value -> !ActionRequestInfo -> !Maybe ActionResponseInfo -> ActionInternalError
[_aieError] :: ActionInternalError -> !Value
[_aieRequest] :: ActionInternalError -> !ActionRequestInfo
[_aieResponse] :: ActionInternalError -> !Maybe ActionResponseInfo
data ActionHandlerLog
ActionHandlerLog :: !Request -> !Maybe Request -> !Int64 -> !Maybe Int64 -> !Int64 -> !ActionName -> ActionHandlerLog
[_ahlRequest] :: ActionHandlerLog -> !Request
[_ahlRequestTrans] :: ActionHandlerLog -> !Maybe Request
[_ahlRequestSize] :: ActionHandlerLog -> !Int64
[_ahlTransformedRequestSize] :: ActionHandlerLog -> !Maybe Int64
[_ahlResponseSize] :: ActionHandlerLog -> !Int64
[_ahlActionName] :: ActionHandlerLog -> !ActionName
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionContext
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionContext
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionContext
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionRequestInfo
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionRequestInfo
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionInternalError
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionInternalError
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Action.Types.ActionHandlerLog
instance GHC.Show.Show Hasura.GraphQL.Execute.Action.Types.ActionHandlerLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionHandlerLog
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Execute.Action.Types.ActionHandlerLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionInternalError
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionResponseInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionRequestInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookErrorResponse
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionWebhookPayload
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Execute.Action.Types.ActionContext
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Action.Types.ActionContext

module Hasura.Eventing.Common
data LockedEventsCtx
LockedEventsCtx :: TVar (Set CronEventId) -> TVar (Set OneOffScheduledEventId) -> TVar (HashMap SourceName (Set EventId)) -> TVar (Set LockedActionEventId) -> LockedEventsCtx
[leCronEvents] :: LockedEventsCtx -> TVar (Set CronEventId)
[leOneOffEvents] :: LockedEventsCtx -> TVar (Set OneOffScheduledEventId)
[leEvents] :: LockedEventsCtx -> TVar (HashMap SourceName (Set EventId))
[leActionEvents] :: LockedEventsCtx -> TVar (Set LockedActionEventId)

-- | After the events are fetched from the DB, we store the locked events
--   in a hash set(order doesn't matter and look ups are faster) in the
--   event engine context
saveLockedEvents :: MonadIO m => [EventId] -> TVar (Set EventId) -> m ()

-- | Remove an event from the <a>LockedEventsCtx</a> after it has been
--   processed
removeEventFromLockedEvents :: MonadIO m => EventId -> TVar (Set EventId) -> m ()

-- | Generates next <tt>n events starting </tt>from according to
--   <a>CronSchedule</a>
generateScheduleTimes :: UTCTime -> Int -> CronSchedule -> [UTCTime]

-- | number of cleanup schedules to be generated in one iteration
cleanupSchedulesToBeGenerated :: Int
deleteEventTriggerLogsInBatchesWith :: (MonadIO m, MonadError QErr m) => IO (Maybe (TriggerLogCleanupConfig, EventTriggerCleanupStatus)) -> TriggerLogCleanupConfig -> (TriggerLogCleanupConfig -> IO (Either QErr DeletedEventLogStats)) -> m DeletedEventLogStats

module Hasura.RQL.IR.Action

-- | Internal representation for a selection of fields on the result of an
--   action. Type parameter r will be either r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
data ActionFieldG (r :: Type)

-- | Scalar value. G.Name is the original field name from the object type.
ACFScalar :: Name -> ActionFieldG (r :: Type)

-- | Remote relationship
ACFRemote :: ActionRemoteRelationshipSelect r -> ActionFieldG (r :: Type)

-- | Constant text value (used for __typename fields)
ACFExpression :: Text -> ActionFieldG (r :: Type)

-- | Nested object. G.Name is the original field name from the object type.
ACFNestedObject :: Name -> ActionFieldsG r -> ActionFieldG (r :: Type)
type ActionFieldsG r = Fields (ActionFieldG r)
type ActionFields = ActionFieldsG Void
data ActionRemoteRelationshipSelect r
ActionRemoteRelationshipSelect :: HashMap FieldName Name -> r -> ActionRemoteRelationshipSelect r

-- | The fields on the table that are required for the join condition of
--   the remote relationship
[_arrsLHSJoinFields] :: ActionRemoteRelationshipSelect r -> HashMap FieldName Name

-- | The field that captures the relationship r ~ (RemoteRelationshipField
--   UnpreparedValue) when the AST is emitted by the parser. r ~ Void when
--   an execution tree is constructed so that a backend is absolved of
--   dealing with remote relationships.
[_arrsRelationship] :: ActionRemoteRelationshipSelect r -> r
_ACFNestedObject :: forall r_alrlg. Prism' (ActionFieldG r_alrlg) (Name, ActionFieldsG r_alrlg)
_ACFExpression :: forall r_alrlg. Prism' (ActionFieldG r_alrlg) Text
_ACFRemote :: forall r_alrlg. Prism' (ActionFieldG r_alrlg) (ActionRemoteRelationshipSelect r_alrlg)
_ACFScalar :: forall r_alrlg. Prism' (ActionFieldG r_alrlg) Name
data AnnActionExecution (r :: Type)
AnnActionExecution :: ActionName -> GraphQLType -> ActionFieldsG r -> Value -> ActionOutputFields -> EnvRecord ResolvedWebhook -> [HeaderConf] -> Bool -> Timeout -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> AnnActionExecution (r :: Type)
[_aaeName] :: AnnActionExecution (r :: Type) -> ActionName

-- | output type
[_aaeOutputType] :: AnnActionExecution (r :: Type) -> GraphQLType

-- | output selection
[_aaeFields] :: AnnActionExecution (r :: Type) -> ActionFieldsG r

-- | jsonified input arguments
[_aaePayload] :: AnnActionExecution (r :: Type) -> Value

-- | to validate the response fields from webhook
[_aaeOutputFields] :: AnnActionExecution (r :: Type) -> ActionOutputFields
[_aaeWebhook] :: AnnActionExecution (r :: Type) -> EnvRecord ResolvedWebhook
[_aaeHeaders] :: AnnActionExecution (r :: Type) -> [HeaderConf]
[_aaeForwardClientHeaders] :: AnnActionExecution (r :: Type) -> Bool
[_aaeTimeOut] :: AnnActionExecution (r :: Type) -> Timeout
[_aaeRequestTransform] :: AnnActionExecution (r :: Type) -> Maybe RequestTransform
[_aaeResponseTransform] :: AnnActionExecution (r :: Type) -> Maybe MetadataResponseTransform
type ActionOutputFields = HashMap Name GType
getActionOutputFields :: AnnotatedOutputType -> ActionOutputFields
data AnnActionMutationAsync
AnnActionMutationAsync :: ActionName -> Bool -> Value -> AnnActionMutationAsync
[_aamaName] :: AnnActionMutationAsync -> ActionName
[_aamaForwardClientHeaders] :: AnnActionMutationAsync -> Bool

-- | jsonified input arguments
[_aamaPayload] :: AnnActionMutationAsync -> Value
data AsyncActionQueryFieldG (r :: Type)
AsyncTypename :: Text -> AsyncActionQueryFieldG (r :: Type)
AsyncOutput :: ActionFieldsG r -> AsyncActionQueryFieldG (r :: Type)
AsyncId :: AsyncActionQueryFieldG (r :: Type)
AsyncCreatedAt :: AsyncActionQueryFieldG (r :: Type)
AsyncErrors :: AsyncActionQueryFieldG (r :: Type)
data AnnActionAsyncQuery (b :: BackendType) (r :: Type)
AnnActionAsyncQuery :: ActionName -> ActionId -> GraphQLType -> AsyncActionQueryFieldsG r -> [(Column b, ScalarType b)] -> StringifyNumbers -> Bool -> ActionSourceInfo b -> AnnActionAsyncQuery (b :: BackendType) (r :: Type)
[_aaaqName] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> ActionName
[_aaaqActionId] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> ActionId
[_aaaqOutputType] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> GraphQLType
[_aaaqFields] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> AsyncActionQueryFieldsG r
[_aaaqDefinitionList] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> [(Column b, ScalarType b)]
[_aaaqStringifyNum] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> StringifyNumbers
[_aaaqForwardClientHeaders] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> Bool
[_aaaqSource] :: AnnActionAsyncQuery (b :: BackendType) (r :: Type) -> ActionSourceInfo b
data ActionSourceInfo b

-- | No relationships defined on the action output object
ASINoSource :: ActionSourceInfo b

-- | All relationships refer to tables in one source
ASISource :: SourceName -> SourceConfig b -> ActionSourceInfo b
aaaqStringifyNum :: forall b_alrLr r_alrLs. Lens' (AnnActionAsyncQuery b_alrLr r_alrLs) StringifyNumbers
aaaqSource :: forall b_alrLr r_alrLs. Lens' (AnnActionAsyncQuery b_alrLr r_alrLs) (ActionSourceInfo b_alrLr)
aaaqOutputType :: forall b_alrLr r_alrLs. Lens' (AnnActionAsyncQuery b_alrLr r_alrLs) GraphQLType
aaaqName :: forall b_alrLr r_alrLs. Lens' (AnnActionAsyncQuery b_alrLr r_alrLs) ActionName
aaaqForwardClientHeaders :: forall b_alrLr r_alrLs. Lens' (AnnActionAsyncQuery b_alrLr r_alrLs) Bool
aaaqFields :: forall b_alrLr r_alrLs r_alsoN. Lens (AnnActionAsyncQuery b_alrLr r_alrLs) (AnnActionAsyncQuery b_alrLr r_alsoN) (AsyncActionQueryFieldsG r_alrLs) (AsyncActionQueryFieldsG r_alsoN)
aaaqDefinitionList :: forall b_alrLr r_alrLs. Lens' (AnnActionAsyncQuery b_alrLr r_alrLs) [(Column b_alrLr, ScalarType b_alrLr)]
aaaqActionId :: forall b_alrLr r_alrLs. Lens' (AnnActionAsyncQuery b_alrLr r_alrLs) ActionId
aaeWebhook :: forall r_alrLv. Lens' (AnnActionExecution r_alrLv) (EnvRecord ResolvedWebhook)
aaeTimeOut :: forall r_alrLv. Lens' (AnnActionExecution r_alrLv) Timeout
aaeResponseTransform :: forall r_alrLv. Lens' (AnnActionExecution r_alrLv) (Maybe MetadataResponseTransform)
aaeRequestTransform :: forall r_alrLv. Lens' (AnnActionExecution r_alrLv) (Maybe RequestTransform)
aaePayload :: forall r_alrLv. Lens' (AnnActionExecution r_alrLv) Value
aaeOutputType :: forall r_alrLv. Lens' (AnnActionExecution r_alrLv) GraphQLType
aaeOutputFields :: forall r_alrLv. Lens' (AnnActionExecution r_alrLv) ActionOutputFields
aaeName :: forall r_alrLv. Lens' (AnnActionExecution r_alrLv) ActionName
aaeHeaders :: forall r_alrLv. Lens' (AnnActionExecution r_alrLv) [HeaderConf]
aaeForwardClientHeaders :: forall r_alrLv. Lens' (AnnActionExecution r_alrLv) Bool
aaeFields :: forall r_alrLv r_alswt. Lens (AnnActionExecution r_alrLv) (AnnActionExecution r_alswt) (ActionFieldsG r_alrLv) (ActionFieldsG r_alswt)
_AsyncErrors :: forall r_alrLu. Prism' (AsyncActionQueryFieldG r_alrLu) ()
_AsyncCreatedAt :: forall r_alrLu. Prism' (AsyncActionQueryFieldG r_alrLu) ()
_AsyncId :: forall r_alrLu. Prism' (AsyncActionQueryFieldG r_alrLu) ()
_AsyncOutput :: forall r_alsGM r_alrLu. Prism (AsyncActionQueryFieldG r_alsGM) (AsyncActionQueryFieldG r_alrLu) (ActionFieldsG r_alsGM) (ActionFieldsG r_alrLu)
_AsyncTypename :: forall r_alrLu. Prism' (AsyncActionQueryFieldG r_alrLu) Text
instance Data.Traversable.Traversable Hasura.RQL.IR.Action.AnnActionExecution
instance Data.Foldable.Foldable Hasura.RQL.IR.Action.AnnActionExecution
instance GHC.Base.Functor Hasura.RQL.IR.Action.AnnActionExecution
instance GHC.Classes.Eq Hasura.RQL.IR.Action.AnnActionMutationAsync
instance GHC.Show.Show Hasura.RQL.IR.Action.AnnActionMutationAsync
instance Data.Traversable.Traversable Hasura.RQL.IR.Action.AsyncActionQueryFieldG
instance Data.Foldable.Foldable Hasura.RQL.IR.Action.AsyncActionQueryFieldG
instance GHC.Base.Functor Hasura.RQL.IR.Action.AsyncActionQueryFieldG
instance Data.Traversable.Traversable (Hasura.RQL.IR.Action.AnnActionAsyncQuery b)
instance Data.Foldable.Foldable (Hasura.RQL.IR.Action.AnnActionAsyncQuery b)
instance GHC.Base.Functor (Hasura.RQL.IR.Action.AnnActionAsyncQuery b)
instance Data.Traversable.Traversable Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect
instance Data.Foldable.Foldable Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect
instance GHC.Base.Functor Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect
instance GHC.Show.Show r => GHC.Show.Show (Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RQL.IR.Action.ActionRemoteRelationshipSelect r)
instance Data.Traversable.Traversable Hasura.RQL.IR.Action.ActionFieldG
instance Data.Foldable.Foldable Hasura.RQL.IR.Action.ActionFieldG
instance GHC.Base.Functor Hasura.RQL.IR.Action.ActionFieldG
instance GHC.Show.Show r => GHC.Show.Show (Hasura.RQL.IR.Action.ActionFieldG r)
instance GHC.Classes.Eq r => GHC.Classes.Eq (Hasura.RQL.IR.Action.ActionFieldG r)

module Hasura.RQL.IR.Root
data SourceConfigWith (db :: BackendType -> Type) (b :: BackendType)
SourceConfigWith :: SourceConfig b -> Maybe QueryTagsConfig -> db b -> SourceConfigWith (db :: BackendType -> Type) (b :: BackendType)
data RootField (db :: BackendType -> Type) remote action raw
[RFDB] :: SourceName -> AnyBackend (SourceConfigWith db) -> RootField db remote action raw
[RFRemote] :: remote -> RootField db remote action raw
[RFAction] :: action -> RootField db remote action raw
[RFRaw] :: raw -> RootField db remote action raw
[RFMulti] :: [RootField db remote action raw] -> RootField db remote action raw
data MutationDB (b :: BackendType) (r :: Type) v
MDBInsert :: AnnotatedInsert b r v -> MutationDB (b :: BackendType) (r :: Type) v
MDBUpdate :: AnnotatedUpdateG b r v -> MutationDB (b :: BackendType) (r :: Type) v
MDBDelete :: AnnDelG b r v -> MutationDB (b :: BackendType) (r :: Type) v

-- | This represents a VOLATILE function, and is AnnSimpleSelG for easy
--   re-use of non-VOLATILE function tracking code.
MDBFunction :: JsonAggSelect -> AnnSimpleSelectG b r v -> MutationDB (b :: BackendType) (r :: Type) v
data ActionQuery (r :: Type)
AQQuery :: AnnActionExecution r -> ActionQuery (r :: Type)
AQAsync :: AnnActionAsyncQuery ('Postgres 'Vanilla) r -> ActionQuery (r :: Type)
data ActionMutation (r :: Type)
AMSync :: AnnActionExecution r -> ActionMutation (r :: Type)
AMAsync :: AnnActionMutationAsync -> ActionMutation (r :: Type)
newtype QueryDBRoot r v b
QDBR :: QueryDB b r (v b) -> QueryDBRoot r v b
newtype MutationDBRoot r v b
MDBR :: MutationDB b r (v b) -> MutationDBRoot r v b

-- | IR of a remote relationship. A remote relationship currently can be to
--   either a remote schema or a database's table. See RemoteSourceSelect
--   for explanation on <tt>vf</tt>.
data RemoteRelationshipField vf
RemoteSchemaField :: RemoteSchemaSelect (RemoteRelationshipField vf) -> RemoteRelationshipField vf

-- | AnyBackend is used here to capture a relationship to an arbitrary
--   target
RemoteSourceField :: AnyBackend (RemoteSourceSelect (RemoteRelationshipField vf) vf) -> RemoteRelationshipField vf
type QueryRootField v = RootField (QueryDBRoot (RemoteRelationshipField v) v) (RemoteSchemaRootField (RemoteRelationshipField v) RemoteSchemaVariable) (QueryActionRoot v) Value
type MutationRootField v = RootField (MutationDBRoot (RemoteRelationshipField v) v) (RemoteSchemaRootField (RemoteRelationshipField v) RemoteSchemaVariable) (MutationActionRoot v) Value
type SubscriptionRootField v = RootField (QueryDBRoot (RemoteRelationshipField v) v) (RemoteSchemaRootField (RemoteRelationshipField v) RemoteSchemaVariable) (QueryActionRoot v) Value
instance Hasura.RQL.Types.Backend.Backend b => Data.Traversable.Traversable (Hasura.RQL.IR.Root.MutationDB b r)
instance Hasura.RQL.Types.Backend.Backend b => Data.Foldable.Foldable (Hasura.RQL.IR.Root.MutationDB b r)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Base.Functor (Hasura.RQL.IR.Root.MutationDB b r)
instance GHC.Generics.Generic (Hasura.RQL.IR.Root.MutationDB b r v)
instance Data.Traversable.Traversable Hasura.RQL.IR.Root.ActionQuery
instance Data.Foldable.Foldable Hasura.RQL.IR.Root.ActionQuery
instance GHC.Base.Functor Hasura.RQL.IR.Root.ActionQuery
instance Hasura.SQL.AnyBackend.SatisfiesForAllBackends vf GHC.Show.Show => GHC.Show.Show (Hasura.RQL.IR.Root.RemoteRelationshipField vf)

module Hasura.Backends.DataConnector.Plan.MutationPlan
mkMutationPlan :: (MonadError QErr m, MonadReader r m, Has ScalarTypesCapabilities r, Has SessionVariables r) => MutationDB 'DataConnector Void (UnpreparedValue 'DataConnector) -> m (Plan MutationRequest MutationResponse)
instance GHC.Show.Show Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchema
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchema
instance GHC.Show.Show Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchemas
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchemas
instance GHC.Base.Semigroup Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchemas
instance GHC.Base.Monoid Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchemas
instance GHC.Base.Semigroup Hasura.Backends.DataConnector.Plan.MutationPlan.TableInsertSchema

module Hasura.RQL.IR


-- | A collection of types and utilities around the <tt>Node</tt> GraphQL
--   type exposed by the Relay API.
module Hasura.GraphQL.Schema.Node
data NodeId
NodeIdV1 :: V1NodeId -> NodeId
NodeIdV2 :: AnyBackend V2NodeId -> NodeId

-- | V1 format of a node.
--   
--   This id does NOT uniquely identify the table properly, as it only
--   knows the table's name, but doesn't store a source name.
data V1NodeId
V1NodeId :: QualifiedTable -> NESeq Value -> V1NodeId
[_ni1Table] :: V1NodeId -> QualifiedTable
[_ni1Columns] :: V1NodeId -> NESeq Value

-- | V2 format of a node.
--   
--   Uniquely identifies a table with source name and table name, and
--   uniquely identifies a row within that table with a list of primary key
--   values.
data V2NodeId b
V2NodeId :: SourceName -> TableName b -> NESeq Value -> V2NodeId b
[_ni2Source] :: V2NodeId b -> SourceName
[_ni2Table] :: V2NodeId b -> TableName b
[_ni2Columns] :: V2NodeId b -> NESeq Value

-- | Enum representing the supported versions of the API.
data NodeIdVersion
nodeIdVersionInt :: NodeIdVersion -> Int
currentNodeIdVersion :: NodeIdVersion
type NodeMap = HashMap SourceName (AnyBackend TableMap)

-- | All the information required to craft a query to a row pointed to by a
--   <a>NodeId</a>.
data NodeInfo b
NodeInfo :: SourceInfo b -> SelPermInfo b -> PrimaryKeyColumns b -> AnnFieldsG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> NodeInfo b
[nvSourceInfo] :: NodeInfo b -> SourceInfo b
[nvSelectPermissions] :: NodeInfo b -> SelPermInfo b
[nvPrimaryKeys] :: NodeInfo b -> PrimaryKeyColumns b
[nvAnnotatedFields] :: NodeInfo b -> AnnFieldsG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
newtype TableMap b
TableMap :: HashMap (TableName b) (NodeInfo b) -> TableMap b

-- | Given a source name and table name, peform the double lookup within a
--   <a>NodeMap</a>.
findNode :: forall b. Backend b => SourceName -> TableName b -> NodeMap -> Maybe (NodeInfo b)
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Node.NodeIdVersion
instance GHC.Show.Show Hasura.GraphQL.Schema.Node.NodeIdVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Schema.Node.NodeId

module Hasura.GraphQL.Context

-- | For storing both a normal GQLContext and one for the backend variant.
--   Currently, this is to enable the backend variant to have certain
--   insert<i>update</i>delete permissions which the frontend variant does
--   not.
data RoleContext a
RoleContext :: !a -> !Maybe a -> RoleContext a

-- | The default context for normal sessions
[_rctxDefault] :: RoleContext a -> !a

-- | The context for sessions with backend privilege.
[_rctxBackend] :: RoleContext a -> !Maybe a
data GQLContext
GQLContext :: ParserFn (RootFieldMap (QueryRootField UnpreparedValue)) -> Maybe (ParserFn (RootFieldMap (MutationRootField UnpreparedValue))) -> Maybe (ParserFn (RootFieldMap (QueryRootField UnpreparedValue))) -> GQLContext
[gqlQueryParser] :: GQLContext -> ParserFn (RootFieldMap (QueryRootField UnpreparedValue))
[gqlMutationParser] :: GQLContext -> Maybe (ParserFn (RootFieldMap (MutationRootField UnpreparedValue)))
[gqlSubscriptionParser] :: GQLContext -> Maybe (ParserFn (RootFieldMap (QueryRootField UnpreparedValue)))
type ParserFn a = SelectionSet NoFragments Variable -> Either QErr a
instance GHC.Generics.Generic (Hasura.GraphQL.Context.RoleContext a)
instance Data.Traversable.Traversable Hasura.GraphQL.Context.RoleContext
instance Data.Foldable.Foldable Hasura.GraphQL.Context.RoleContext
instance GHC.Base.Functor Hasura.GraphQL.Context.RoleContext
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Context.RoleContext a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Context.RoleContext a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Context.GQLContext
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Context.RoleContext a)


-- | The modules in the <tt>Hasura.Backends.MSSQL.FromIr</tt> namespace
--   translates the RQL IR into TSQL, the SQL dialect of MSSQL, as defined
--   in abstract syntax in <a>Hasura.Backends.MSSQL.Types</a>.
--   
--   The translation happens in the <tt>FromIr</tt> monad, which manages
--   identifier scoping and error collection.
--   
--   The actual rendering of this AST into TSQL text happens in
--   <a>Hasura.Backends.MSSQL.ToQuery</a>.
module Hasura.Backends.MSSQL.FromIr

-- | add a step to be run before the main query
tellBefore :: TempTableDDL -> FromIr ()

-- | add a step to be run after the main query
tellAfter :: TempTableDDL -> FromIr ()
tellCTE :: NativeQueryName -> InterpolatedQuery Expression -> FromIr Text

-- | The central Monad used throughout for all conversion functions.
--   
--   It has the following features:
--   
--   <ul>
--   <li>It's a <a>MonadValidate</a>, so it'll continue going when it
--   encounters <a>Error</a>s to accumulate as many as possible.</li>
--   <li>It has a facility for generating fresh, unique aliases, which lets
--   the translation output retain a resemblance with source names without
--   the translation process needing to be bothered about potential name
--   shadowing. See <a>generateAlias</a>.</li>
--   <li>It has a writer part for reporting native queries that need to be
--   wrapped in a CTE</li>
--   </ul>
--   
--   The Inner part <a>FromIrInner</a> containing the state and validate
--   are extracted to a different type so we can peel the writer for
--   queries and report errors in the process if needed.
data FromIr a

-- | Run a <a>FromIr</a> action, throwing errors that have been collected
--   using the supplied action, and attach CTEs created from native queries
--   to the select query.
runFromIrUseCTEs :: MonadError QErr m => FromIr Select -> m (QueryWithDDL Select)

-- | Run a <a>FromIr</a> action, throwing errors that have been collected
--   using the supplied action, and attach CTEs created from native queries
--   to the select query.
runFromIrUseCTEsT :: (Traversable t, MonadError QErr m) => t (FromIr Select) -> m (t (QueryWithDDL Select))

-- | Run a <a>FromIr</a> action, throwing errors that have been collected
--   using the supplied action, and discard CTEs created from native
--   queries to the select query.
--   
--   If CTEs were reported, we throw an error, since we don't support
--   native queries in this context yet.
runFromIrErrorOnCTEs :: MonadError QErr m => FromIr a -> m (QueryWithDDL a)

-- | Errors that may happen during translation.
data Error
UnsupportedOpExpG :: OpExpG 'MSSQL Expression -> Error
FunctionNotSupported :: Error
NativeQueriesNotSupported :: Error

-- | Hints about the type of entity that <a>generateAlias</a> is producing
--   an alias for.
data NameTemplate
ArrayRelationTemplate :: Text -> NameTemplate
ArrayAggregateTemplate :: Text -> NameTemplate
ObjectRelationTemplate :: Text -> NameTemplate
TableTemplate :: Text -> NameTemplate
ForOrderAlias :: Text -> NameTemplate

-- | Generate a fresh alias for a given entity to remove ambiguity and
--   naming conflicts between scopes at the TSQL level.
--   
--   Names are generated in the form <tt>type_name_occurrence</tt>, where:
--   
--   <ul>
--   <li><tt>type</tt> hints at the type of entity,</li>
--   <li><tt>name</tt> refers to the source name being aliased, and</li>
--   <li><tt>occurrence</tt> is an integer counter that distinguishes each
--   occurrence of <tt>type_name</tt>.</li>
--   </ul>
--   
--   Example outputs:
--   
--   <pre>
--   do
--     "ar_articles_1" &lt;- generateAlias (ArrayRelationTemplate "articles")
--     "ar_articles_2" &lt;- generateAlias (ArrayRelationTemplate "articles")
--     "t_users_1"     &lt;- generateAlias (TableTemplate "users")
--   </pre>
generateAlias :: NameTemplate -> FromIr Text
instance GHC.Classes.Eq Hasura.Backends.MSSQL.FromIr.Error
instance GHC.Show.Show Hasura.Backends.MSSQL.FromIr.Error
instance Control.Monad.State.Class.MonadState Hasura.Backends.MSSQL.FromIr.IRState Hasura.Backends.MSSQL.FromIr.FromIr
instance Control.Monad.Writer.Class.MonadWriter Hasura.Backends.MSSQL.FromIr.IRWriter Hasura.Backends.MSSQL.FromIr.FromIr
instance Control.Monad.Validate.Class.MonadValidate (GHC.Base.NonEmpty Hasura.Backends.MSSQL.FromIr.Error) Hasura.Backends.MSSQL.FromIr.FromIr
instance GHC.Base.Monad Hasura.Backends.MSSQL.FromIr.FromIr
instance GHC.Base.Applicative Hasura.Backends.MSSQL.FromIr.FromIr
instance GHC.Base.Functor Hasura.Backends.MSSQL.FromIr.FromIr
instance GHC.Base.Semigroup Hasura.Backends.MSSQL.FromIr.IRWriter
instance GHC.Base.Monoid Hasura.Backends.MSSQL.FromIr.IRWriter


-- | This module translates the IR of boolean expressions into TSQL boolean
--   expressions.
--   
--   Boolean expressions typically arise from permissions and where-clause
--   filters.
module Hasura.Backends.MSSQL.FromIr.Expression

-- | Translate boolean expressions into TSQL <a>Expression</a>s.
--   
--   The <a>AnnBoolExpFld</a> references fields and columns. The entity
--   (e.g. table) that binds these columns is supplied in the `ReaderT
--   EntityAlias` environment, such that the columns can be referred to
--   unambiguously.
fromGBoolExp :: GBoolExp 'MSSQL (AnnBoolExpFld 'MSSQL Expression) -> ReaderT EntityAlias FromIr Expression


-- | This module defines the translation functions for update mutations.
module Hasura.Backends.MSSQL.FromIr.Update
fromUpdate :: AnnotatedUpdate 'MSSQL -> FromIr Update


-- | This module defines the translation functions for insert and upsert
--   mutations.
module Hasura.Backends.MSSQL.FromIr.Insert
fromInsert :: AnnotatedInsert 'MSSQL Void Expression -> Insert

-- | Construct a MERGE statement from AnnotatedInsert information. A MERGE
--   statement is responsible for actually inserting and/or updating the
--   data in the table.
toMerge :: TableName -> [AnnotatedInsertRow 'MSSQL Expression] -> [ColumnInfo 'MSSQL] -> IfMatched Expression -> FromIr Merge

-- | As part of an INSERT/UPSERT process, insert VALUES into a temporary
--   table. The content of the temporary table will later be inserted into
--   the original table using a MERGE statement.
--   
--   We insert the values into a temporary table first in order to replace
--   the missing fields with <tt>DEFAULT</tt> in
--   <tt>normalizeInsertRows</tt>, and we can't do that in a MERGE
--   statement directly.
toInsertValuesIntoTempTable :: TempTableName -> AnnotatedInsert 'MSSQL Void Expression -> InsertValuesIntoTempTable


-- | This module defines the translation function for delete mutations.
module Hasura.Backends.MSSQL.FromIr.Delete
fromDelete :: AnnDel 'MSSQL -> FromIr Delete


-- | Translate from the DML to the BigQuery dialect.
module Hasura.Backends.BigQuery.FromIr

-- | Most of these errors should be checked for legitimacy.
data Error
FromTypeUnsupported :: SelectFromG 'BigQuery Expression -> Error
NoOrderSpecifiedInOrderBy :: Error
MalformedAgg :: Error
FieldTypeUnsupportedForNow :: AnnFieldG 'BigQuery Void Expression -> Error
AggTypeUnsupportedForNow :: TableAggregateFieldG 'BigQuery Void Expression -> Error
NodesUnsupportedForNow :: TableAggregateFieldG 'BigQuery Void Expression -> Error
NoProjectionFields :: Error
NoAggregatesMustBeABug :: Error
UnsupportedArraySelect :: ArraySelectG 'BigQuery Void Expression -> Error
UnsupportedOpExpG :: OpExpG 'BigQuery Expression -> Error
UnsupportedSQLExp :: Expression -> Error
UnsupportedDistinctOn :: Error
UnexpectedEmptyList :: Error
InvalidIntegerishSql :: Expression -> Error
ConnectionsNotSupported :: Error
ActionsNotSupported :: Error

-- | <a>https://github.com/hasura/graphql-engine/issues/8526</a>
ComputedFieldsBooleanExpressionNotSupported :: Error

-- | <a>https://github.com/hasura/graphql-engine/issues/8526</a>
ComputedFieldsOrderByNotSupported :: Error

-- | <a>https://github.com/hasura/graphql-engine/issues/8521</a>
ScalarComputedFieldsNotSupported :: Error
NoParentEntityInternalError :: Error

-- | The base monad used throughout this module for all conversion
--   functions.
--   
--   It's a Validate, so it'll continue going when it encounters errors to
--   accumulate as many as possible.
--   
--   It also contains a mapping from entity prefixes to counters. So if my
--   prefix is "table" then there'll be a counter that lets me generate
--   table1, table2, etc. Same for any other prefix needed (e.g. names for
--   joins).
--   
--   A ReaderT is used around this in most of the module too, for setting
--   the current entity that a given field name refers to. See
--   <tt>fromColumn</tt>.
data FromIr a

-- | Collected from using a native query in a query. Each entry here
--   because a CTE to be prepended to the query.
newtype FromIrWriter
FromIrWriter :: Map (Aliased NativeQueryName) (InterpolatedQuery Expression) -> FromIrWriter
[fromIrWriterNativeQueries] :: FromIrWriter -> Map (Aliased NativeQueryName) (InterpolatedQuery Expression)

-- | Config values for the from-IR translator.
data FromIrConfig
FromIrConfig :: Top -> FromIrConfig

-- | Applies globally to all selects, and may be reduced to something even
--   smaller by permission/user args.
[globalSelectLimit] :: FromIrConfig -> Top

-- | A default config.
defaultFromIrConfig :: FromIrConfig
runFromIr :: FromIrConfig -> FromIr a -> Validate (NonEmpty Error) (a, FromIrWriter)
bigQuerySourceConfigToFromIrConfig :: BigQuerySourceConfig -> FromIrConfig

-- | Here is where we apply a top-level annotation to the select to
--   indicate to the data loader that this select ought to produce a single
--   object or an array.
mkSQLSelect :: JsonAggSelect -> AnnSelectG 'BigQuery (AnnFieldG 'BigQuery Void) Expression -> FromIr Select

-- | Convert from the IR database query into a select.
fromRootField :: QueryDB 'BigQuery Void Expression -> FromIr Select
fromSelectAggregate :: Maybe (EntityAlias, HashMap ColumnName ColumnName) -> AnnSelectG 'BigQuery (TableAggregateFieldG 'BigQuery Void) Expression -> FromIr Select
instance GHC.Base.Monoid Hasura.Backends.BigQuery.FromIr.FromIrWriter
instance GHC.Base.Semigroup Hasura.Backends.BigQuery.FromIr.FromIrWriter
instance Control.Monad.Writer.Class.MonadWriter Hasura.Backends.BigQuery.FromIr.FromIrWriter Hasura.Backends.BigQuery.FromIr.FromIr
instance Control.Monad.Validate.Class.MonadValidate (GHC.Base.NonEmpty Hasura.Backends.BigQuery.FromIr.Error) Hasura.Backends.BigQuery.FromIr.FromIr
instance GHC.Base.Monad Hasura.Backends.BigQuery.FromIr.FromIr
instance GHC.Base.Applicative Hasura.Backends.BigQuery.FromIr.FromIr
instance GHC.Base.Functor Hasura.Backends.BigQuery.FromIr.FromIr
instance GHC.Show.Show Hasura.Backends.BigQuery.FromIr.Args
instance GHC.Show.Show Hasura.Backends.BigQuery.FromIr.UnfurledJoin
instance GHC.Show.Show Hasura.Backends.BigQuery.FromIr.FieldSource
instance GHC.Classes.Eq Hasura.Backends.BigQuery.FromIr.FieldSource
instance GHC.Show.Show Hasura.Backends.BigQuery.FromIr.Error

module Hasura.Metadata.DTO.MetadataV3

-- | Revision 3 of the Metadata export format. Note that values of the
--   types, <tt>PlaceholderArray</tt> and <tt>PlaceholderObject</tt> will
--   eventually be expanded to represent more detail.
data MetadataV3
MetadataV3 :: Sources -> RemoteSchemas -> QueryCollections -> MetadataAllowlist -> Actions -> CustomTypes -> CronTriggers -> Endpoints -> ApiLimit -> MetricsConfig -> InheritedRoles -> SetGraphqlIntrospectionOptions -> Network -> BackendMap BackendConfigWrapper -> OpenTelemetryConfig -> MetadataV3
[metaV3Sources] :: MetadataV3 -> Sources
[metaV3RemoteSchemas] :: MetadataV3 -> RemoteSchemas
[metaV3QueryCollections] :: MetadataV3 -> QueryCollections
[metaV3Allowlist] :: MetadataV3 -> MetadataAllowlist
[metaV3Actions] :: MetadataV3 -> Actions
[metaV3CustomTypes] :: MetadataV3 -> CustomTypes
[metaV3CronTriggers] :: MetadataV3 -> CronTriggers
[metaV3RestEndpoints] :: MetadataV3 -> Endpoints
[metaV3ApiLimits] :: MetadataV3 -> ApiLimit
[metaV3MetricsConfig] :: MetadataV3 -> MetricsConfig
[metaV3InheritedRoles] :: MetadataV3 -> InheritedRoles
[metaV3GraphqlSchemaIntrospection] :: MetadataV3 -> SetGraphqlIntrospectionOptions
[metaV3Network] :: MetadataV3 -> Network
[metaV3BackendConfigs] :: MetadataV3 -> BackendMap BackendConfigWrapper
[metaV3OpenTelemetryConfig] :: MetadataV3 -> OpenTelemetryConfig
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance GHC.Generics.Generic Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance GHC.Classes.Eq Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance GHC.Show.Show Hasura.Metadata.DTO.MetadataV3.MetadataV3
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.MetadataV3.MetadataV3

module Hasura.RQL.Types.Metadata

-- | Versioning the <tt><a>Metadata</a> JSON structure to track backwards
--   incompatible changes. This value is included in the metadata JSON
--   object at top level <tt>version</tt> key. Always metadata is emitted
--   in the latest version via export metadata API
--   (</tt><tt>runExportMetadata</tt> handler). Adding a new value
--   constructor to @<a>MetadataVersion</a> type bumps the metadata
--   version.
--   
--   NOTE: When metadata version is bumped: 1. The Hasura CLI and Console
--   actively use export metadata API to read metadata. Hence, it is
--   necessary to update CLI and Console to read latest metadata. All
--   changes SHOULD be released hand in hand (preferebly in one pull
--   request) 2. There might be other third party services (developed by
--   Hasura users) which use the export metadata API. Apart from changelog,
--   we need to establish the metadata version update by bumping up the
--   minor version of the GraphQL Engine.
data MetadataVersion
MVVersion1 :: MetadataVersion
MVVersion2 :: MetadataVersion
MVVersion3 :: MetadataVersion
currentMetadataVersion :: MetadataVersion

-- | A complete GraphQL Engine metadata representation to be stored,
--   exported/replaced via metadata queries.
data Metadata
Metadata :: Sources -> RemoteSchemas -> QueryCollections -> MetadataAllowlist -> CustomTypes -> Actions -> CronTriggers -> Endpoints -> ApiLimit -> MetricsConfig -> InheritedRoles -> SetGraphqlIntrospectionOptions -> Network -> BackendMap BackendConfigWrapper -> OpenTelemetryConfig -> Metadata
[_metaSources] :: Metadata -> Sources
[_metaRemoteSchemas] :: Metadata -> RemoteSchemas
[_metaQueryCollections] :: Metadata -> QueryCollections
[_metaAllowlist] :: Metadata -> MetadataAllowlist
[_metaCustomTypes] :: Metadata -> CustomTypes
[_metaActions] :: Metadata -> Actions
[_metaCronTriggers] :: Metadata -> CronTriggers
[_metaRestEndpoints] :: Metadata -> Endpoints
[_metaApiLimits] :: Metadata -> ApiLimit
[_metaMetricsConfig] :: Metadata -> MetricsConfig
[_metaInheritedRoles] :: Metadata -> InheritedRoles
[_metaSetGraphqlIntrospectionOptions] :: Metadata -> SetGraphqlIntrospectionOptions
[_metaNetwork] :: Metadata -> Network
[_metaBackendConfigs] :: Metadata -> BackendMap BackendConfigWrapper
[_metaOpenTelemetryConfig] :: Metadata -> OpenTelemetryConfig
metaSources :: Lens' Metadata Sources
metaSetGraphqlIntrospectionOptions :: Lens' Metadata SetGraphqlIntrospectionOptions
metaRestEndpoints :: Lens' Metadata Endpoints
metaRemoteSchemas :: Lens' Metadata RemoteSchemas
metaQueryCollections :: Lens' Metadata QueryCollections
metaOpenTelemetryConfig :: Lens' Metadata OpenTelemetryConfig
metaNetwork :: Lens' Metadata Network
metaMetricsConfig :: Lens' Metadata MetricsConfig
metaInheritedRoles :: Lens' Metadata InheritedRoles
metaCustomTypes :: Lens' Metadata CustomTypes
metaCronTriggers :: Lens' Metadata CronTriggers
metaBackendConfigs :: Lens' Metadata (BackendMap BackendConfigWrapper)
metaApiLimits :: Lens' Metadata ApiLimit
metaAllowlist :: Lens' Metadata MetadataAllowlist
metaActions :: Lens' Metadata Actions
emptyMetadata :: Metadata

-- | This type serves to allow Metadata arguments to be distinguished
newtype MetadataDefaults
MetadataDefaults :: Metadata -> MetadataDefaults
emptyMetadataDefaults :: MetadataDefaults

-- | This acts like a Semigroup instance for Metadata, favouring the
--   non-default Metadata
overrideMetadataDefaults :: Metadata -> MetadataDefaults -> Metadata
tableMetadataSetter :: Backend b => SourceName -> TableName b -> ASetter' Metadata (TableMetadata b)

-- | A lens setter for the metadata of a specific function as identified by
--   the source name and function name.
functionMetadataSetter :: Backend b => SourceName -> FunctionName b -> ASetter' Metadata (FunctionMetadata b)

-- | A lens setter for the metadata of a logical model as identified by the
--   source name and root field name.
logicalModelMetadataSetter :: Backend b => SourceName -> LogicalModelName -> ASetter' Metadata (LogicalModelMetadata b)

-- | A lens setter for the metadata of a native query as identified by the
--   source name and root field name.
nativeQueryMetadataSetter :: Backend b => SourceName -> NativeQueryName -> ASetter' Metadata (NativeQueryMetadata b)

-- | A lens setter for the metadata of a stored procedure as identified by
--   the source name and root field name.
storedProcedureMetadataSetter :: Backend b => SourceName -> FunctionName b -> ASetter' Metadata (StoredProcedureMetadata b)

-- | A simple monad class which enables fetching and setting
--   @<a>Metadata</a> in the state.
class (Monad m) => MetadataM m
getMetadata :: MetadataM m => m Metadata
putMetadata :: MetadataM m => Metadata -> m ()
data MetadataNoSources
MetadataNoSources :: Tables ('Postgres 'Vanilla) -> Functions ('Postgres 'Vanilla) -> RemoteSchemas -> QueryCollections -> MetadataAllowlist -> CustomTypes -> Actions -> CronTriggers -> MetadataNoSources
[_mnsTables] :: MetadataNoSources -> Tables ('Postgres 'Vanilla)
[_mnsFunctions] :: MetadataNoSources -> Functions ('Postgres 'Vanilla)
[_mnsRemoteSchemas] :: MetadataNoSources -> RemoteSchemas
[_mnsQueryCollections] :: MetadataNoSources -> QueryCollections
[_mnsAllowlist] :: MetadataNoSources -> MetadataAllowlist
[_mnsCustomTypes] :: MetadataNoSources -> CustomTypes
[_mnsActions] :: MetadataNoSources -> Actions
[_mnsCronTriggers] :: MetadataNoSources -> CronTriggers
newtype MetadataModifier
MetadataModifier :: (Metadata -> Metadata) -> MetadataModifier
[runMetadataModifier] :: MetadataModifier -> Metadata -> Metadata
dropTableInMetadata :: forall b. Backend b => SourceName -> TableName b -> MetadataModifier
dropRelationshipInMetadata :: RelName -> TableMetadata b -> TableMetadata b
dropNativeQueryRelationshipInMetadata :: RelName -> NativeQueryMetadata b -> NativeQueryMetadata b
dropPermissionInMetadata :: RoleName -> PermType -> TableMetadata b -> TableMetadata b
dropLogicalModelPermissionInMetadata :: RoleName -> PermType -> LogicalModelMetadata b -> LogicalModelMetadata b
dropInlineLogicalModelPermissionInMetadata :: RoleName -> PermType -> InlineLogicalModelMetadata b -> InlineLogicalModelMetadata b
dropComputedFieldInMetadata :: ComputedFieldName -> TableMetadata b -> TableMetadata b
dropEventTriggerInMetadata :: TriggerName -> TableMetadata b -> TableMetadata b
dropRemoteRelationshipInMetadata :: RelName -> TableMetadata b -> TableMetadata b
dropFunctionInMetadata :: forall b. Backend b => SourceName -> FunctionName b -> MetadataModifier
dropRemoteSchemaInMetadata :: RemoteSchemaName -> MetadataModifier
dropRemoteSchemaPermissionInMetadata :: RemoteSchemaName -> RoleName -> MetadataModifier
dropRemoteSchemaRemoteRelationshipInMetadata :: RemoteSchemaName -> Name -> RelName -> MetadataModifier

-- | Encode <a>Metadata</a> to JSON with deterministic ordering (e.g.
--   "version" being at the top). The CLI system stores metadata in files
--   and has option to show changes in git diff style. The diff shouldn't
--   appear different for no metadata changes. So, the ordering of object
--   keys and array elements should remain consistent across versions of
--   graphql-engine if possible.
--   
--   Note: While modifying any part of the code below, make sure the
--   encoded JSON of each type is parsable via its <a>FromJSON</a>
--   instance.
--   
--   TODO: we can use 'aeson-pretty' to serialize in a consistent way, and
--   to specify a (partial) order of keys, while getting the benefits of
--   auto-generated To/FromJSON instances. `FromJSON TableMetadata`
--   complicates this though...
--   
--   See: <a>https://github.com/hasura/graphql-engine/issues/6348</a>
metadataToOrdJSON :: Metadata -> Value

-- | Convert <a>Metadata</a> to a DTO for serialization. In the near future
--   the plan is to use this function instead of the <a>ToJSON</a> instance
--   of <a>Metadata</a>. For the time being DTO serialization does not
--   match the same order of object keys as the <a>ToJSON</a> instance - we
--   can't switch to using this function until that issue is resolved. See
--   <a>https://hasurahq.atlassian.net/browse/MM-29</a>
metadataToDTO :: Metadata -> MetadataV3
instance GHC.Show.Show Hasura.RQL.Types.Metadata.MetadataDefaults
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.MetadataDefaults
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.MetadataNoSources
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.MetadataNoSources
instance GHC.Base.Monoid Hasura.RQL.Types.Metadata.MetadataModifier
instance GHC.Base.Semigroup Hasura.RQL.Types.Metadata.MetadataModifier
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.MetadataNoSources
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.MetadataNoSources
instance Hasura.RQL.Types.Metadata.MetadataM m => Hasura.RQL.Types.Metadata.MetadataM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.Metadata.MetadataM m => Hasura.RQL.Types.Metadata.MetadataM (Control.Monad.Trans.State.Strict.StateT r m)
instance Hasura.RQL.Types.Metadata.MetadataM m => Hasura.RQL.Types.Metadata.MetadataM (Hasura.Tracing.Monad.TraceT m)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.MetadataDefaults
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.MetadataDefaults
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.Metadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.Metadata
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.MetadataVersion
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.MetadataVersion
instance GHC.Show.Show Hasura.RQL.Types.Metadata.MetadataVersion
instance GHC.Generics.Generic Hasura.RQL.Types.Metadata.Metadata
instance GHC.Classes.Eq Hasura.RQL.Types.Metadata.Metadata
instance GHC.Show.Show Hasura.RQL.Types.Metadata.Metadata
instance Hasura.Incremental.Select.Select Hasura.RQL.Types.Metadata.Metadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.Metadata.MetadataVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.Metadata.MetadataVersion


-- | Types and classes related to configuration when the server is
--   initialised
module Hasura.Server.Init.Config

-- | The collected default value, env var, and help message for an option.
--   If there should be no default value then use 'Option ()'.
data Option def
Option :: def -> String -> String -> Option def
[_default] :: Option def -> def
[_envVar] :: Option def -> String
[_helpMessage] :: Option def -> String

-- | Helper function for pretty printing <tt>Option a</tt>.
optionPP :: Option a -> (String, String)

-- | Raw HGE Options from the arg parser and the env.
data HGEOptionsRaw impl
HGEOptionsRaw :: PostgresConnInfo (Maybe PostgresConnInfoRaw) -> Maybe String -> HGECommand impl -> HGEOptionsRaw impl
[_horDatabaseUrl] :: HGEOptionsRaw impl -> PostgresConnInfo (Maybe PostgresConnInfoRaw)
[_horMetadataDbUrl] :: HGEOptionsRaw impl -> Maybe String
[_horCommand] :: HGEOptionsRaw impl -> HGECommand impl
horDatabaseUrl :: Lens' (HGEOptionsRaw impl) (PostgresConnInfo (Maybe PostgresConnInfoRaw))
horMetadataDbUrl :: Lens' (HGEOptionsRaw impl) (Maybe String)
horCommand :: Lens' (HGEOptionsRaw impl) (HGECommand impl)

-- | The final processed HGE options.
data HGEOptions impl
HGEOptions :: PostgresConnInfo (Maybe UrlConf) -> Maybe String -> HGECommand impl -> HGEOptions impl
[_hoDatabaseUrl] :: HGEOptions impl -> PostgresConnInfo (Maybe UrlConf)
[_hoMetadataDbUrl] :: HGEOptions impl -> Maybe String
[_hoCommand] :: HGEOptions impl -> HGECommand impl
hoCommand :: Lens' (HGEOptions impl) (HGECommand impl)

-- | Postgres connection info tupled with a retry count.
--   
--   In practice, the <tt>a</tt> here is one of the following: 1. 'Maybe
--   PostgresConnInfoRaw' 2. 'Maybe UrlConf' 3. 'Maybe Text' 4. 'Maybe
--   DatabaseUrl' where <tt>DatabaseUrl</tt> is an alias for <a>Text</a>
--   
--   If it contains a 'Maybe PostgresConnInfoRaw' then you have not yet
--   processed your arg parser results.
data PostgresConnInfo a
PostgresConnInfo :: a -> Maybe Int -> PostgresConnInfo a
[_pciDatabaseConn] :: PostgresConnInfo a -> a
[_pciRetries] :: PostgresConnInfo a -> Maybe Int
pciDatabaseConn :: Lens' (PostgresConnInfo a) a
pciRetries :: Lens' (PostgresConnInfo a) (Maybe Int)

-- | Postgres Connection info in the form of a templated URI string or
--   structured data.
data PostgresConnInfoRaw
PGConnDatabaseUrl :: Template -> PostgresConnInfoRaw
PGConnDetails :: PostgresConnDetailsRaw -> PostgresConnInfoRaw
mkUrlConnInfo :: String -> PostgresConnInfoRaw
_PGConnDatabaseUrl :: Prism' PostgresConnInfoRaw Template
_PGConnDetails :: Prism' PostgresConnInfoRaw PostgresConnDetailsRaw
rawConnDetailsToUrl :: PostgresConnDetailsRaw -> Template

-- | Structured Postgres connection information as provided by the arg
--   parser or env vars.
data PostgresConnDetailsRaw
PostgresConnDetailsRaw :: String -> Int -> String -> String -> String -> Maybe String -> PostgresConnDetailsRaw
[connHost] :: PostgresConnDetailsRaw -> String
[connPort] :: PostgresConnDetailsRaw -> Int
[connUser] :: PostgresConnDetailsRaw -> String
[connPassword] :: PostgresConnDetailsRaw -> String
[connDatabase] :: PostgresConnDetailsRaw -> String
[connOptions] :: PostgresConnDetailsRaw -> Maybe String
rawConnDetailsToUrlText :: PostgresConnDetailsRaw -> Text

-- | The HGE Arg parser Command choices.
--   
--   This is polymorphic so that we can pack either <a>ServeOptionsRaw</a>
--   or <tt>ProServeOptionsRaw</tt> in it.
data HGECommand a
HCServe :: a -> HGECommand a
HCExport :: HGECommand a
HCClean :: HGECommand a
HCVersion :: HGECommand a
HCDowngrade :: !DowngradeOptions -> HGECommand a
_HCServe :: Prism' (HGECommand a) a

-- | The Serve Command options accumulated from the Arg and Env parsers.
--   
--   NOTE: A <a>Nothing</a> value indicates the absence of a particular
--   flag. Hence types such as 'Maybe (HashSet X)' or 'Maybe Bool'.
data ServeOptionsRaw impl
ServeOptionsRaw :: Maybe Port -> Maybe HostPreference -> ConnParamsRaw -> Maybe TxIsolation -> Maybe AdminSecretHash -> AuthHookRaw -> Maybe JWTConfig -> Maybe RoleName -> Maybe CorsConfig -> ConsoleStatus -> Maybe Text -> Maybe Text -> Maybe TelemetryStatus -> WsReadCookieStatus -> StringifyNumbers -> Maybe DangerouslyCollapseBooleans -> Maybe RemoteNullForwardingPolicy -> Maybe (HashSet API) -> Maybe RefetchInterval -> Maybe BatchSize -> Maybe RefetchInterval -> Maybe BatchSize -> AllowListStatus -> Maybe (HashSet (EngineLogType impl)) -> Maybe LogLevel -> DevModeStatus -> Maybe AdminInternalErrorsStatus -> Maybe (Refined Positive Int) -> Maybe (Refined NonNegative Milliseconds) -> Maybe OptionalInterval -> RemoteSchemaPermissions -> CompressionOptions -> Maybe KeepAliveDelay -> Maybe InferFunctionPermissions -> MaintenanceMode () -> Maybe OptionalInterval -> Maybe (HashSet ExperimentalFeature) -> Maybe (Refined NonNegative Int) -> Maybe (Refined NonNegative Seconds) -> Maybe WSConnectionInitTimeout -> MetadataQueryLoggingMode -> Maybe NamingCase -> Maybe ExtensionsSchema -> Maybe MetadataDefaults -> Maybe ApolloFederationStatus -> Maybe CloseWebsocketsOnMetadataChangeStatus -> Maybe Int -> Maybe TriggersErrorLogLevelStatus -> ServeOptionsRaw impl
[rsoPort] :: ServeOptionsRaw impl -> Maybe Port
[rsoHost] :: ServeOptionsRaw impl -> Maybe HostPreference
[rsoConnParams] :: ServeOptionsRaw impl -> ConnParamsRaw
[rsoTxIso] :: ServeOptionsRaw impl -> Maybe TxIsolation
[rsoAdminSecret] :: ServeOptionsRaw impl -> Maybe AdminSecretHash
[rsoAuthHook] :: ServeOptionsRaw impl -> AuthHookRaw
[rsoJwtSecret] :: ServeOptionsRaw impl -> Maybe JWTConfig
[rsoUnAuthRole] :: ServeOptionsRaw impl -> Maybe RoleName
[rsoCorsConfig] :: ServeOptionsRaw impl -> Maybe CorsConfig
[rsoConsoleStatus] :: ServeOptionsRaw impl -> ConsoleStatus
[rsoConsoleAssetsDir] :: ServeOptionsRaw impl -> Maybe Text
[rsoConsoleSentryDsn] :: ServeOptionsRaw impl -> Maybe Text
[rsoEnableTelemetry] :: ServeOptionsRaw impl -> Maybe TelemetryStatus
[rsoWsReadCookie] :: ServeOptionsRaw impl -> WsReadCookieStatus
[rsoStringifyNum] :: ServeOptionsRaw impl -> StringifyNumbers
[rsoDangerousBooleanCollapse] :: ServeOptionsRaw impl -> Maybe DangerouslyCollapseBooleans
[rsoRemoteNullForwardingPolicy] :: ServeOptionsRaw impl -> Maybe RemoteNullForwardingPolicy
[rsoEnabledAPIs] :: ServeOptionsRaw impl -> Maybe (HashSet API)
[rsoMxRefetchInt] :: ServeOptionsRaw impl -> Maybe RefetchInterval
[rsoMxBatchSize] :: ServeOptionsRaw impl -> Maybe BatchSize
[rsoStreamingMxRefetchInt] :: ServeOptionsRaw impl -> Maybe RefetchInterval
[rsoStreamingMxBatchSize] :: ServeOptionsRaw impl -> Maybe BatchSize
[rsoEnableAllowList] :: ServeOptionsRaw impl -> AllowListStatus
[rsoEnabledLogTypes] :: ServeOptionsRaw impl -> Maybe (HashSet (EngineLogType impl))
[rsoLogLevel] :: ServeOptionsRaw impl -> Maybe LogLevel
[rsoDevMode] :: ServeOptionsRaw impl -> DevModeStatus
[rsoAdminInternalErrors] :: ServeOptionsRaw impl -> Maybe AdminInternalErrorsStatus
[rsoEventsHttpPoolSize] :: ServeOptionsRaw impl -> Maybe (Refined Positive Int)
[rsoEventsFetchInterval] :: ServeOptionsRaw impl -> Maybe (Refined NonNegative Milliseconds)
[rsoAsyncActionsFetchInterval] :: ServeOptionsRaw impl -> Maybe OptionalInterval
[rsoEnableRemoteSchemaPermissions] :: ServeOptionsRaw impl -> RemoteSchemaPermissions
[rsoWebSocketCompression] :: ServeOptionsRaw impl -> CompressionOptions
[rsoWebSocketKeepAlive] :: ServeOptionsRaw impl -> Maybe KeepAliveDelay
[rsoInferFunctionPermissions] :: ServeOptionsRaw impl -> Maybe InferFunctionPermissions
[rsoEnableMaintenanceMode] :: ServeOptionsRaw impl -> MaintenanceMode ()
[rsoSchemaPollInterval] :: ServeOptionsRaw impl -> Maybe OptionalInterval

-- | See Note '$experimentalFeatures' at bottom of module
[rsoExperimentalFeatures] :: ServeOptionsRaw impl -> Maybe (HashSet ExperimentalFeature)
[rsoEventsFetchBatchSize] :: ServeOptionsRaw impl -> Maybe (Refined NonNegative Int)
[rsoGracefulShutdownTimeout] :: ServeOptionsRaw impl -> Maybe (Refined NonNegative Seconds)
[rsoWebSocketConnectionInitTimeout] :: ServeOptionsRaw impl -> Maybe WSConnectionInitTimeout
[rsoEnableMetadataQueryLoggingEnv] :: ServeOptionsRaw impl -> MetadataQueryLoggingMode

-- | stores global default naming convention
[rsoDefaultNamingConvention] :: ServeOptionsRaw impl -> Maybe NamingCase
[rsoExtensionsSchema] :: ServeOptionsRaw impl -> Maybe ExtensionsSchema
[rsoMetadataDefaults] :: ServeOptionsRaw impl -> Maybe MetadataDefaults
[rsoApolloFederationStatus] :: ServeOptionsRaw impl -> Maybe ApolloFederationStatus
[rsoCloseWebsocketsOnMetadataChangeStatus] :: ServeOptionsRaw impl -> Maybe CloseWebsocketsOnMetadataChangeStatus
[rsoMaxTotalHeaderLength] :: ServeOptionsRaw impl -> Maybe Int
[rsoTriggersErrorLogLevelStatus] :: ServeOptionsRaw impl -> Maybe TriggersErrorLogLevelStatus

-- | Whether or not to serve Console assets.
data ConsoleStatus
ConsoleEnabled :: ConsoleStatus
ConsoleDisabled :: ConsoleStatus
isConsoleEnabled :: ConsoleStatus -> Bool

-- | Whether or not internal errors will be sent in response to admin.
data AdminInternalErrorsStatus
AdminInternalErrorsEnabled :: AdminInternalErrorsStatus
AdminInternalErrorsDisabled :: AdminInternalErrorsStatus
isAdminInternalErrorsEnabled :: AdminInternalErrorsStatus -> Bool
isWebSocketCompressionEnabled :: CompressionOptions -> Bool

-- | A representation of whether or not to enable the GraphQL Query
--   AllowList.
--   
--   See:
--   <a>https://hasura.io/docs/latest/security/allow-list/#enable-allow-list</a>
data AllowListStatus
AllowListEnabled :: AllowListStatus
AllowListDisabled :: AllowListStatus
isAllowListEnabled :: AllowListStatus -> Bool

-- | A representation of whether or not to enable Hasura Dev Mode.
--   
--   See:
--   <a>https://hasura.io/docs/latest/deployment/graphql-engine-flags/config-examples/#dev-mode</a>
data DevModeStatus
DevModeEnabled :: DevModeStatus
DevModeDisabled :: DevModeStatus
isDevModeEnabled :: DevModeStatus -> Bool

-- | A representation of whether or not to enable telemetry that is
--   isomorphic to <a>Bool</a>.
data TelemetryStatus
TelemetryEnabled :: TelemetryStatus
TelemetryDisabled :: TelemetryStatus
isTelemetryEnabled :: TelemetryStatus -> Bool

-- | A representation of whether or not to read the websocket cookie on
--   initial handshake that is isomorphic to <a>Bool</a>. See
--   <tt>wsReadCookieOption</tt> for more details.
data WsReadCookieStatus
WsReadCookieEnabled :: WsReadCookieStatus
WsReadCookieDisabled :: WsReadCookieStatus
isWsReadCookieEnabled :: WsReadCookieStatus -> Bool

-- | An <a>Int</a> representing a Port number in the range 0 to 65536.
data Port
mkPort :: Int -> Maybe Port
unsafePort :: Int -> Port
data API
METADATA :: API
GRAPHQL :: API
PGDUMP :: API
DEVELOPER :: API
CONFIG :: API
METRICS :: API
data AuthHookRaw
AuthHookRaw :: Maybe Text -> Maybe AuthHookType -> Maybe Bool -> AuthHookRaw
[ahrUrl] :: AuthHookRaw -> Maybe Text
[ahrType] :: AuthHookRaw -> Maybe AuthHookType
[ahrSendRequestBody] :: AuthHookRaw -> Maybe Bool

-- | Sleep time interval for recurring activities such as
--   (@<tt>asyncActionsProcessor</tt>) Presently
--   <a>msToOptionalInterval</a> interprets `0` as Skip.
data OptionalInterval

-- | No polling
Skip :: OptionalInterval

-- | Interval time
Interval :: Refined NonNegative Milliseconds -> OptionalInterval
msToOptionalInterval :: Refined NonNegative Milliseconds -> OptionalInterval

-- | The Raw configuration data from the Arg and Env parsers needed to
--   construct a <tt>ConnParams</tt>
data ConnParamsRaw
ConnParamsRaw :: Maybe (Refined NonNegative Int) -> Maybe (Refined NonNegative Int) -> Maybe (Refined NonNegative Int) -> Maybe (Refined NonNegative NominalDiffTime) -> Maybe Bool -> Maybe (Refined NonNegative NominalDiffTime) -> ConnParamsRaw
[rcpStripes] :: ConnParamsRaw -> Maybe (Refined NonNegative Int)
[rcpConns] :: ConnParamsRaw -> Maybe (Refined NonNegative Int)
[rcpIdleTime] :: ConnParamsRaw -> Maybe (Refined NonNegative Int)

-- | Time from connection creation after which to destroy a connection and
--   choose a different/new one.
[rcpConnLifetime] :: ConnParamsRaw -> Maybe (Refined NonNegative NominalDiffTime)
[rcpAllowPrepare] :: ConnParamsRaw -> Maybe Bool

-- | See <tt>HASURA_GRAPHQL_PG_POOL_TIMEOUT</tt>
[rcpPoolTimeout] :: ConnParamsRaw -> Maybe (Refined NonNegative NominalDiffTime)
newtype KeepAliveDelay
KeepAliveDelay :: Refined NonNegative Seconds -> KeepAliveDelay
[unKeepAliveDelay] :: KeepAliveDelay -> Refined NonNegative Seconds

-- | The timeout duration in <a>Seconds</a> for a WebSocket connection.
newtype WSConnectionInitTimeout
WSConnectionInitTimeout :: Refined NonNegative Seconds -> WSConnectionInitTimeout
[unWSConnectionInitTimeout] :: WSConnectionInitTimeout -> Refined NonNegative Seconds

-- | The final Serve Command options accummulated from the Arg Parser and
--   the Environment, fully processed and ready to apply when running the
--   server.
data ServeOptions impl
ServeOptions :: Port -> HostPreference -> ConnParams -> TxIsolation -> HashSet AdminSecretHash -> Maybe AuthHook -> [JWTConfig] -> Maybe RoleName -> CorsConfig -> ConsoleStatus -> Maybe Text -> Maybe Text -> TelemetryStatus -> StringifyNumbers -> DangerouslyCollapseBooleans -> RemoteNullForwardingPolicy -> HashSet API -> LiveQueriesOptions -> StreamQueriesOptions -> AllowListStatus -> HashSet (EngineLogType impl) -> LogLevel -> Refined Positive Int -> Refined NonNegative Milliseconds -> OptionalInterval -> RemoteSchemaPermissions -> ConnectionOptions -> KeepAliveDelay -> InferFunctionPermissions -> MaintenanceMode () -> OptionalInterval -> HashSet ExperimentalFeature -> Refined NonNegative Int -> DevModeStatus -> AdminInternalErrorsStatus -> Refined NonNegative Seconds -> WSConnectionInitTimeout -> EventingMode -> ReadOnlyMode -> MetadataQueryLoggingMode -> NamingCase -> ExtensionsSchema -> MetadataDefaults -> ApolloFederationStatus -> CloseWebsocketsOnMetadataChangeStatus -> Int -> TriggersErrorLogLevelStatus -> ServeOptions impl
[soPort] :: ServeOptions impl -> Port
[soHost] :: ServeOptions impl -> HostPreference
[soConnParams] :: ServeOptions impl -> ConnParams
[soTxIso] :: ServeOptions impl -> TxIsolation
[soAdminSecret] :: ServeOptions impl -> HashSet AdminSecretHash
[soAuthHook] :: ServeOptions impl -> Maybe AuthHook
[soJwtSecret] :: ServeOptions impl -> [JWTConfig]
[soUnAuthRole] :: ServeOptions impl -> Maybe RoleName
[soCorsConfig] :: ServeOptions impl -> CorsConfig
[soConsoleStatus] :: ServeOptions impl -> ConsoleStatus
[soConsoleAssetsDir] :: ServeOptions impl -> Maybe Text
[soConsoleSentryDsn] :: ServeOptions impl -> Maybe Text
[soEnableTelemetry] :: ServeOptions impl -> TelemetryStatus
[soStringifyNum] :: ServeOptions impl -> StringifyNumbers
[soDangerousBooleanCollapse] :: ServeOptions impl -> DangerouslyCollapseBooleans
[soRemoteNullForwardingPolicy] :: ServeOptions impl -> RemoteNullForwardingPolicy
[soEnabledAPIs] :: ServeOptions impl -> HashSet API
[soLiveQueryOpts] :: ServeOptions impl -> LiveQueriesOptions
[soStreamingQueryOpts] :: ServeOptions impl -> StreamQueriesOptions
[soEnableAllowList] :: ServeOptions impl -> AllowListStatus
[soEnabledLogTypes] :: ServeOptions impl -> HashSet (EngineLogType impl)
[soLogLevel] :: ServeOptions impl -> LogLevel
[soEventsHttpPoolSize] :: ServeOptions impl -> Refined Positive Int
[soEventsFetchInterval] :: ServeOptions impl -> Refined NonNegative Milliseconds
[soAsyncActionsFetchInterval] :: ServeOptions impl -> OptionalInterval
[soEnableRemoteSchemaPermissions] :: ServeOptions impl -> RemoteSchemaPermissions
[soConnectionOptions] :: ServeOptions impl -> ConnectionOptions
[soWebSocketKeepAlive] :: ServeOptions impl -> KeepAliveDelay
[soInferFunctionPermissions] :: ServeOptions impl -> InferFunctionPermissions
[soEnableMaintenanceMode] :: ServeOptions impl -> MaintenanceMode ()
[soSchemaPollInterval] :: ServeOptions impl -> OptionalInterval

-- | See note '$experimentalFeatures'
[soExperimentalFeatures] :: ServeOptions impl -> HashSet ExperimentalFeature
[soEventsFetchBatchSize] :: ServeOptions impl -> Refined NonNegative Int
[soDevMode] :: ServeOptions impl -> DevModeStatus
[soAdminInternalErrors] :: ServeOptions impl -> AdminInternalErrorsStatus
[soGracefulShutdownTimeout] :: ServeOptions impl -> Refined NonNegative Seconds
[soWebSocketConnectionInitTimeout] :: ServeOptions impl -> WSConnectionInitTimeout
[soEventingMode] :: ServeOptions impl -> EventingMode

-- | See note '$readOnlyMode'
[soReadOnlyMode] :: ServeOptions impl -> ReadOnlyMode
[soEnableMetadataQueryLogging] :: ServeOptions impl -> MetadataQueryLoggingMode
[soDefaultNamingConvention] :: ServeOptions impl -> NamingCase
[soExtensionsSchema] :: ServeOptions impl -> ExtensionsSchema
[soMetadataDefaults] :: ServeOptions impl -> MetadataDefaults
[soApolloFederationStatus] :: ServeOptions impl -> ApolloFederationStatus
[soCloseWebsocketsOnMetadataChangeStatus] :: ServeOptions impl -> CloseWebsocketsOnMetadataChangeStatus
[soMaxTotalHeaderLength] :: ServeOptions impl -> Int
[soTriggersErrorLogLevelStatus] :: ServeOptions impl -> TriggersErrorLogLevelStatus

-- | <a>ResponseInternalErrorsConfig</a> represents the encoding of the
--   internal errors in the response to the client.
--   
--   For more details, see this github comment:
--   <a>https://github.com/hasura/graphql-engine/issues/4031#issuecomment-609747705</a>
data ResponseInternalErrorsConfig
InternalErrorsAllRequests :: ResponseInternalErrorsConfig
InternalErrorsAdminOnly :: ResponseInternalErrorsConfig
InternalErrorsDisabled :: ResponseInternalErrorsConfig
shouldIncludeInternal :: RoleName -> ResponseInternalErrorsConfig -> Bool

-- | The Downgrade Command options. These are only sourced from the Arg
--   Parser and are used directly in <a>Migrate</a>.
data DowngradeOptions
DowngradeOptions :: Text -> Bool -> DowngradeOptions
[dgoTargetVersion] :: DowngradeOptions -> Text
[dgoDryRun] :: DowngradeOptions -> Bool
instance GHC.Base.Functor Hasura.Server.Init.Config.Option
instance Data.Traversable.Traversable Hasura.Server.Init.Config.PostgresConnInfo
instance Data.Foldable.Foldable Hasura.Server.Init.Config.PostgresConnInfo
instance GHC.Base.Functor Hasura.Server.Init.Config.PostgresConnInfo
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Server.Init.Config.PostgresConnInfo a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Server.Init.Config.PostgresConnInfo a)
instance GHC.Show.Show Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance GHC.Read.Read Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance GHC.Classes.Eq Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance GHC.Classes.Eq Hasura.Server.Init.Config.PostgresConnInfoRaw
instance GHC.Show.Show Hasura.Server.Init.Config.PostgresConnInfoRaw
instance GHC.Generics.Generic Hasura.Server.Init.Config.ConsoleStatus
instance GHC.Classes.Ord Hasura.Server.Init.Config.ConsoleStatus
instance GHC.Classes.Eq Hasura.Server.Init.Config.ConsoleStatus
instance GHC.Show.Show Hasura.Server.Init.Config.ConsoleStatus
instance GHC.Generics.Generic Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance GHC.Classes.Ord Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance GHC.Classes.Eq Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance GHC.Show.Show Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance GHC.Generics.Generic Hasura.Server.Init.Config.AllowListStatus
instance GHC.Classes.Ord Hasura.Server.Init.Config.AllowListStatus
instance GHC.Classes.Eq Hasura.Server.Init.Config.AllowListStatus
instance GHC.Show.Show Hasura.Server.Init.Config.AllowListStatus
instance GHC.Generics.Generic Hasura.Server.Init.Config.DevModeStatus
instance GHC.Classes.Ord Hasura.Server.Init.Config.DevModeStatus
instance GHC.Classes.Eq Hasura.Server.Init.Config.DevModeStatus
instance GHC.Show.Show Hasura.Server.Init.Config.DevModeStatus
instance GHC.Generics.Generic Hasura.Server.Init.Config.TelemetryStatus
instance GHC.Classes.Ord Hasura.Server.Init.Config.TelemetryStatus
instance GHC.Classes.Eq Hasura.Server.Init.Config.TelemetryStatus
instance GHC.Show.Show Hasura.Server.Init.Config.TelemetryStatus
instance GHC.Generics.Generic Hasura.Server.Init.Config.WsReadCookieStatus
instance GHC.Classes.Eq Hasura.Server.Init.Config.WsReadCookieStatus
instance GHC.Show.Show Hasura.Server.Init.Config.WsReadCookieStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.Port
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.Port
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.Port
instance GHC.Generics.Generic Hasura.Server.Init.Config.Port
instance GHC.Classes.Ord Hasura.Server.Init.Config.Port
instance GHC.Classes.Eq Hasura.Server.Init.Config.Port
instance GHC.Show.Show Hasura.Server.Init.Config.Port
instance GHC.Generics.Generic Hasura.Server.Init.Config.API
instance GHC.Read.Read Hasura.Server.Init.Config.API
instance GHC.Classes.Eq Hasura.Server.Init.Config.API
instance GHC.Show.Show Hasura.Server.Init.Config.API
instance GHC.Classes.Eq Hasura.Server.Init.Config.OptionalInterval
instance GHC.Show.Show Hasura.Server.Init.Config.OptionalInterval
instance GHC.Classes.Eq Hasura.Server.Init.Config.ConnParamsRaw
instance GHC.Show.Show Hasura.Server.Init.Config.ConnParamsRaw
instance GHC.Show.Show Hasura.Server.Init.Config.KeepAliveDelay
instance GHC.Classes.Eq Hasura.Server.Init.Config.KeepAliveDelay
instance GHC.Classes.Ord Hasura.Server.Init.Config.WSConnectionInitTimeout
instance GHC.Classes.Eq Hasura.Server.Init.Config.WSConnectionInitTimeout
instance GHC.Show.Show Hasura.Server.Init.Config.WSConnectionInitTimeout
instance GHC.Classes.Eq Hasura.Server.Init.Config.ResponseInternalErrorsConfig
instance GHC.Show.Show Hasura.Server.Init.Config.ResponseInternalErrorsConfig
instance GHC.Classes.Eq Hasura.Server.Init.Config.DowngradeOptions
instance GHC.Show.Show Hasura.Server.Init.Config.DowngradeOptions
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.Server.Init.Config.HGECommand a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.Server.Init.Config.HGECommand a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.WSConnectionInitTimeout
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.WSConnectionInitTimeout
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.KeepAliveDelay
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.KeepAliveDelay
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.OptionalInterval
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.OptionalInterval
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.API
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.API
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.API
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.Port
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.WsReadCookieStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.WsReadCookieStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.WsReadCookieStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.WsReadCookieStatus
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.TelemetryStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.TelemetryStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.TelemetryStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.TelemetryStatus
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.DevModeStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.DevModeStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.DevModeStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.DevModeStatus
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.AllowListStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.AllowListStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.AllowListStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.AllowListStatus
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance Control.DeepSeq.NFData Hasura.Server.Init.Config.ConsoleStatus
instance Data.Hashable.Class.Hashable Hasura.Server.Init.Config.ConsoleStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.ConsoleStatus
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.ConsoleStatus
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Config.PostgresConnDetailsRaw
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Config.PostgresConnDetailsRaw


-- | Helpful functions and types for generating log statements and URIs
--   during Options fetching and merging.
module Hasura.Server.Init.Logging
censorQuery :: Text -> Query -> Query
updateQuery :: (Query -> Query) -> URI -> URI
censorURI :: Text -> URI -> URI

-- | Generate a <tt>StartupLog</tt> from the Postgres <tt>ConnInfo</tt>.
connInfoToLog :: ConnInfo -> StartupLog

-- | Generate a <tt>StartupLog</tt> from the final <tt>ServeOptions</tt>.
serveOptsToLog :: ToJSON (EngineLogType impl) => ServeOptions impl -> StartupLog
mkGenericLog :: ToJSON a => LogLevel -> Text -> a -> StartupLog
data StartupTimeInfo
StartupTimeInfo :: !Text -> !Double -> StartupTimeInfo
[_stiMessage] :: StartupTimeInfo -> !Text
[_stiTimeTaken] :: StartupTimeInfo -> !Double
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Init.Logging.StartupTimeInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Init.Logging.StartupTimeInfo

module Hasura.Server.Init.Env

-- | Lookup a key in the application environment then parse the value with
--   a <a>FromEnv</a> instance'
considerEnv :: (Monad m, FromEnv a) => String -> WithEnvT m (Maybe a)

-- | Lookup a list of keys with <a>considerEnv</a> and return the first
--   value to parse successfully.
considerEnvs :: (Monad m, FromEnv a) => [String] -> WithEnvT m (Maybe a)

-- | Lookup a list of keys with <a>withOption</a> and return the first
--   value to parse successfully.
withOptions :: (Monad m, FromEnv option) => Maybe option -> [Option ()] -> WithEnvT m (Maybe option)

-- | Given the parse result for an option and the <tt>Option</tt> record
--   for that option, query the environment, and then merge the results
--   from the parser and environment.
withOption :: (Monad m, FromEnv option) => Maybe option -> Option () -> WithEnvT m (Maybe option)

-- | Given the parse result for an option and the <tt>Option</tt> record
--   for that option, query the environment, and then merge the results
--   from the parser, environment, and the default.
withOptionDefault :: (Monad m, FromEnv option) => Maybe option -> Option option -> WithEnvT m option

-- | Switches in 'optparse-applicative' have different semantics then
--   ordinary flags. They are always optional and produce a <a>False</a>
--   when absent rather then a <a>Nothing</a>.
--   
--   In HGE we give Env Vars a higher precedence then an absent Switch but
--   the ordinary <tt>withEnv</tt> operation expects a <a>Nothing</a> for
--   an absent arg parser result.
--   
--   This function executes with 'withOption Nothing' when the Switch is
--   absent, otherwise it returns <a>True</a>.
--   
--   NOTE: An alternative solution might be to make Switches return 'Maybe
--   _', where '_' is an option specific sum type. This would allow us to
--   use <a>withOptionDefault</a> directly. Additionally, all fields of
--   <tt>ServeOptionsRaw</tt> would become <a>Maybe</a> or <tt>First</tt>
--   values which would allow us to write a 'Monoid ServeOptionsRaw'
--   instance for combing different option sources.
--   
--   A <a>Monoid</a> instance would be super valuable to cleanup arg/env
--   parsing but this solution feels somewhat unsatisfying.
withOptionSwitch :: Monad m => Bool -> Option Bool -> WithEnvT m Bool

-- | Given an 'Iso a Bool' we can apply the same boolean env merging
--   semantics as we do for <a>Bool</a> in <tt>withOptionsSwitch</tt> to
--   <tt>a</tt>.
withOptionSwitch' :: Monad m => a -> (a -> Bool, Bool -> a) -> Option a -> WithEnvT m a

-- | A <a>Read</a> style parser used for consuming Env Vars and building
--   <tt>ReadM</tt> parsers for 'optparse-applicative'.
class FromEnv a
fromEnv :: FromEnv a => String -> Either String a
type WithEnv = WithEnvT Identity

-- | The monadic context for querying Env Vars.
newtype WithEnvT m a
WithEnvT :: ReaderT [(String, String)] (ExceptT String m) a -> WithEnvT m a
[unWithEnvT] :: WithEnvT m a -> ReaderT [(String, String)] (ExceptT String m) a

-- | Given an environment run a <a>WithEnv</a> action producing either a
--   parse error or an <tt>a</tt>.
runWithEnv :: [(String, String)] -> WithEnv a -> Either String a

-- | Given an environment run a <a>WithEnvT</a> action producing either a
--   parse error or an <tt>a</tt>.
runWithEnvT :: [(String, String)] -> WithEnvT m a -> m (Either String a)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Server.Init.Env.WithEnvT m)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError GHC.Base.String (Hasura.Server.Init.Env.WithEnvT m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader [(GHC.Base.String, GHC.Base.String)] (Hasura.Server.Init.Env.WithEnvT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.Server.Init.Env.WithEnvT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.Server.Init.Env.WithEnvT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.Server.Init.Env.WithEnvT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.Server.Init.Env.WithEnvT
instance Control.Monad.Morph.MFunctor Hasura.Server.Init.Env.WithEnvT
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Internal.NominalDiffTime.NominalDiffTime
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Internal.DiffTime.DiffTime
instance Hasura.Server.Init.Env.FromEnv GHC.Base.String
instance Hasura.Server.Init.Env.FromEnv Data.Streaming.Network.Internal.HostPreference
instance Hasura.Server.Init.Env.FromEnv Data.Text.Internal.Text
instance Hasura.Server.Init.Env.FromEnv a => Hasura.Server.Init.Env.FromEnv (GHC.Maybe.Maybe a)
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Auth.WebHook.AuthHookType
instance Hasura.Server.Init.Env.FromEnv GHC.Types.Int
instance Hasura.Server.Init.Env.FromEnv GHC.Num.Integer.Integer
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Auth.AdminSecretHash
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Roles.RoleName
instance Hasura.Server.Init.Env.FromEnv GHC.Types.Bool
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.TelemetryStatus
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.AdminInternalErrorsStatus
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.WsReadCookieStatus
instance Hasura.Server.Init.Env.FromEnv Data.Aeson.Types.Internal.Value
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Metadata.MetadataDefaults
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Metadata.Metadata
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Schema.Options.StringifyNumbers
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Schema.Options.RemoteSchemaPermissions
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Schema.Options.DangerouslyCollapseBooleans
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Schema.Options.RemoteNullForwardingPolicy
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.Schema.Options.InferFunctionPermissions
instance Hasura.Server.Init.Env.FromEnv (Hasura.Server.Types.MaintenanceMode ())
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Logging.MetadataQueryLoggingMode
instance Hasura.Server.Init.Env.FromEnv Database.PG.Query.Transaction.TxIsolation
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Cors.CorsConfig
instance Hasura.Server.Init.Env.FromEnv (Data.HashSet.Internal.HashSet Hasura.Server.Init.Config.API)
instance Hasura.Server.Init.Env.FromEnv Hasura.RQL.Types.NamingCase.NamingCase
instance Hasura.Server.Init.Env.FromEnv (Data.HashSet.Internal.HashSet Hasura.Server.Types.ExperimentalFeature)
instance Hasura.Server.Init.Env.FromEnv Hasura.GraphQL.Execute.Subscription.Options.BatchSize
instance Hasura.Server.Init.Env.FromEnv Hasura.GraphQL.Execute.Subscription.Options.RefetchInterval
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Units.Milliseconds
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.OptionalInterval
instance Hasura.Server.Init.Env.FromEnv Data.Time.Clock.Units.Seconds
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.WSConnectionInitTimeout
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.KeepAliveDelay
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Auth.JWT.JWTConfig
instance Hasura.Server.Init.Env.FromEnv [Hasura.Server.Auth.JWT.JWTConfig]
instance Hasura.Logging.EnabledLogTypes impl => Hasura.Server.Init.Env.FromEnv (Data.HashSet.Internal.HashSet (Hasura.Logging.EngineLogType impl))
instance Hasura.Server.Init.Env.FromEnv Hasura.Logging.LogLevel
instance Hasura.Server.Init.Env.FromEnv Data.URL.Template.Template
instance (GHC.Num.Num a, GHC.Classes.Ord a, Hasura.Server.Init.Env.FromEnv a) => Hasura.Server.Init.Env.FromEnv (Refined.Unsafe.Type.Refined Refined.NonNegative a)
instance Hasura.Server.Init.Env.FromEnv (Refined.Unsafe.Type.Refined Refined.Positive GHC.Types.Int)
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Init.Config.Port
instance Hasura.Server.Init.Env.FromEnv Hasura.Cache.Bounded.CacheSize
instance Hasura.Server.Init.Env.FromEnv Hasura.SQL.Types.ExtensionsSchema
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Types.ApolloFederationStatus
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Types.GranularPrometheusMetricsState
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Types.CloseWebsocketsOnMetadataChangeStatus
instance Hasura.Server.Init.Env.FromEnv Hasura.Server.Types.TriggersErrorLogLevelStatus


-- | The Downgrade Command Parser
module Hasura.Server.Init.Arg.Command.Downgrade
downgradeCommandParser :: Parser DowngradeOptions


-- | API related to server configuration
module Hasura.Server.API.Config
data ServerConfig
ServerConfig :: !Version -> !InferFunctionPermissions -> !RemoteSchemaPermissions -> !Bool -> !Bool -> !Bool -> ![JWTInfo] -> !AllowListStatus -> !LiveQueriesOptions -> !SubscriptionsOptions -> !Maybe Text -> !HashSet ExperimentalFeature -> !Bool -> !NamingCase -> !HashSet FeatureFlagInfo -> !ApolloFederationStatus -> ServerConfig
[scfgVersion] :: ServerConfig -> !Version
[scfgIsFunctionPermissionsInferred] :: ServerConfig -> !InferFunctionPermissions
[scfgIsRemoteSchemaPermissionsEnabled] :: ServerConfig -> !RemoteSchemaPermissions
[scfgIsAdminSecretSet] :: ServerConfig -> !Bool
[scfgIsAuthHookSet] :: ServerConfig -> !Bool
[scfgIsJwtSet] :: ServerConfig -> !Bool
[scfgJwt] :: ServerConfig -> ![JWTInfo]
[scfgIsAllowListEnabled] :: ServerConfig -> !AllowListStatus
[scfgLiveQueries] :: ServerConfig -> !LiveQueriesOptions
[scfgStreamingQueries] :: ServerConfig -> !SubscriptionsOptions
[scfgConsoleAssetsDir] :: ServerConfig -> !Maybe Text
[scfgExperimentalFeatures] :: ServerConfig -> !HashSet ExperimentalFeature
[scfgIsPrometheusMetricsEnabled] :: ServerConfig -> !Bool
[scfgDefaultNamingConvention] :: ServerConfig -> !NamingCase
[scfgFeatureFlags] :: ServerConfig -> !HashSet FeatureFlagInfo
[scfgIsApolloFederationEnabled] :: ServerConfig -> !ApolloFederationStatus
runGetConfig :: InferFunctionPermissions -> RemoteSchemaPermissions -> AuthMode -> AllowListStatus -> LiveQueriesOptions -> SubscriptionsOptions -> Maybe Text -> HashSet ExperimentalFeature -> HashSet API -> NamingCase -> [(FeatureFlag, Text, Bool)] -> ApolloFederationStatus -> ServerConfig
instance Data.Hashable.Class.Hashable Hasura.Server.API.Config.FeatureFlagInfo
instance GHC.Generics.Generic Hasura.Server.API.Config.FeatureFlagInfo
instance GHC.Classes.Eq Hasura.Server.API.Config.FeatureFlagInfo
instance GHC.Show.Show Hasura.Server.API.Config.FeatureFlagInfo
instance GHC.Generics.Generic Hasura.Server.API.Config.JWTInfo
instance GHC.Classes.Eq Hasura.Server.API.Config.JWTInfo
instance GHC.Show.Show Hasura.Server.API.Config.JWTInfo
instance GHC.Generics.Generic Hasura.Server.API.Config.ServerConfig
instance GHC.Classes.Eq Hasura.Server.API.Config.ServerConfig
instance GHC.Show.Show Hasura.Server.API.Config.ServerConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.API.Config.ServerConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.API.Config.JWTInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.API.Config.FeatureFlagInfo


-- | The Arg Opt.Parser for the <tt>serve</tt> subcommand.
module Hasura.Server.Init.Arg.Command.Serve
serveCommandParser :: EnabledLogTypes impl => Parser (ServeOptionsRaw impl)
servePortOption :: Option Port
serveHostOption :: Option HostPreference
pgStripesOption :: Option (Refined NonNegative Int)
pgConnsOption :: Option (Refined NonNegative Int)
pgTimeoutOption :: Option (Refined NonNegative Int)
pgConnLifetimeOption :: Option (Refined NonNegative NominalDiffTime)
pgUsePreparedStatementsOption :: Option Bool
pgPoolTimeoutOption :: Option ()
txIsolationOption :: Option TxIsolation
adminSecretOption :: Option ()
accessKeyOption :: Option ()
authHookOption :: Option ()
authHookModeOption :: Option AuthHookType
authHookSendRequestBodyOption :: Option Bool
jwtSecretOption :: Option ()
unAuthRoleOption :: Option ()
corsDomainOption :: Option CorsConfig
disableCorsOption :: Option Bool
enableConsoleOption :: Option ConsoleStatus
consoleAssetsDirOption :: Option ()
consoleSentryDsnOption :: Option ()
enableTelemetryOption :: Option TelemetryStatus
wsReadCookieOption :: Option WsReadCookieStatus
stringifyNumOption :: Option StringifyNumbers
dangerousBooleanCollapseOption :: Option DangerouslyCollapseBooleans
remoteNullForwardingPolicyOption :: Option RemoteNullForwardingPolicy
enabledAPIsOption :: Option (HashSet API)
mxRefetchDelayOption :: Option RefetchInterval
mxBatchSizeOption :: Option BatchSize
streamingMxRefetchDelayOption :: Option RefetchInterval
streamingMxBatchSizeOption :: Option BatchSize
enableAllowlistOption :: Option AllowListStatus
enabledLogsOption :: EnabledLogTypes impl => Option (HashSet (EngineLogType impl))
logLevelOption :: Option LogLevel
graphqlDevModeOption :: Option DevModeStatus
graphqlAdminInternalErrorsOption :: Option AdminInternalErrorsStatus
graphqlEventsHttpPoolSizeOption :: Option (Refined Positive Int)
graphqlEventsFetchIntervalOption :: Option (Refined NonNegative Milliseconds)
asyncActionsFetchIntervalOption :: Option OptionalInterval
enableRemoteSchemaPermsOption :: Option RemoteSchemaPermissions
webSocketCompressionOption :: Option CompressionOptions
webSocketKeepAliveOption :: Option KeepAliveDelay
inferFunctionPermsOption :: Option InferFunctionPermissions
enableMaintenanceModeOption :: Option (MaintenanceMode ())
schemaPollIntervalOption :: Option OptionalInterval
experimentalFeaturesOption :: Option (HashSet ExperimentalFeature)
eventsFetchBatchSizeOption :: Option (Refined NonNegative Int)
gracefulShutdownOption :: Option (Refined NonNegative Seconds)
webSocketConnectionInitTimeoutOption :: Option WSConnectionInitTimeout
enableMetadataQueryLoggingOption :: Option MetadataQueryLoggingMode
defaultNamingConventionOption :: Option NamingCase
metadataDefaultsOption :: Option MetadataDefaults
parseMetadataDefaults :: Parser (Maybe MetadataDefaults)
metadataDBExtensionsSchemaOption :: Option ExtensionsSchema
apolloFederationStatusOption :: Option (Maybe ApolloFederationStatus)
closeWebsocketsOnMetadataChangeOption :: Option CloseWebsocketsOnMetadataChangeStatus
maxTotalHeaderLengthOption :: Option Int
triggersErrorLogLevelStatusOption :: Option TriggersErrorLogLevelStatus
serveCmdFooter :: Doc

module Hasura.Server.Init.Arg

-- | The Main Arg <a>Parser</a>. It constructs a <a>HGEOptionsRaw</a> term:
--   
--   <ol>
--   <li>'(Config.PostgresConnInfo (Maybe PostgresConnInfoRaw))' - The DB
--   connection. 2: 'Maybe String' - Representing the metadata connection.
--   3: <a>HGECommand</a> <tt>a</tt> - The result of the supplied
--   Subcommand.</li>
--   </ol>
parseHgeOpts :: EnabledLogTypes impl => Parser (HGEOptionsRaw (ServeOptionsRaw impl))
parsePostgresConnInfo :: Parser (PostgresConnInfo (Maybe PostgresConnInfoRaw))
retriesNumOption :: Option ()
databaseUrlOption :: Option ()
parseMetadataDbUrl :: Parser (Maybe String)
metadataDbUrlOption :: Option ()
mainCmdFooter :: Doc

module Hasura.RQL.Types.SchemaCacheTypes
data TableObjId (b :: BackendType)
TOCol :: Column b -> TableObjId (b :: BackendType)
TORel :: RelName -> TableObjId (b :: BackendType)
TOComputedField :: ComputedFieldName -> TableObjId (b :: BackendType)
TORemoteRel :: RelName -> TableObjId (b :: BackendType)
TOForeignKey :: ConstraintName b -> TableObjId (b :: BackendType)
TOPerm :: RoleName -> PermType -> TableObjId (b :: BackendType)
TOTrigger :: TriggerName -> TableObjId (b :: BackendType)

-- | Identifiers for components of logical models within the metadata.
--   These are used to track dependencies within the resolved schema (see
--   <tt>SourceInfo</tt>).
data LogicalModelObjId (b :: BackendType)
LMOPerm :: RoleName -> PermType -> LogicalModelObjId (b :: BackendType)
LMOCol :: Column b -> LogicalModelObjId (b :: BackendType)
LMOReferencedLogicalModel :: LogicalModelName -> LogicalModelObjId (b :: BackendType)

-- | Identifier for component of Native Queries within the metadata. These
--   are used to track dependencies between items in the resolved schema.
--   For instance, we use <a>NQOCol</a> along with <a>TOCol</a> from
--   <a>TableObjId</a> to ensure that the two columns that join an array
--   relationship actually exist.
data NativeQueryObjId (b :: BackendType)
NQOCol :: Column b -> NativeQueryObjId (b :: BackendType)

-- | Identifier for component of Stored Procedures within the metadata.
--   These are used to track dependencies between items in the resolved
--   schema. For instance, we use <a>SPOCol</a> along with <a>TOCol</a>
--   from <a>TableObjId</a> to ensure that the two columns that join an
--   array relationship actually exist.
newtype StoredProcedureObjId (b :: BackendType)
SPOCol :: Column b -> StoredProcedureObjId (b :: BackendType)
data SourceObjId (b :: BackendType)
SOITable :: TableName b -> SourceObjId (b :: BackendType)
SOITableObj :: TableName b -> TableObjId b -> SourceObjId (b :: BackendType)
SOIFunction :: FunctionName b -> SourceObjId (b :: BackendType)
SOINativeQuery :: NativeQueryName -> SourceObjId (b :: BackendType)
SOINativeQueryObj :: NativeQueryName -> NativeQueryObjId b -> SourceObjId (b :: BackendType)
SOIStoredProcedure :: FunctionName b -> SourceObjId (b :: BackendType)
SOIStoredProcedureObj :: FunctionName b -> StoredProcedureObjId b -> SourceObjId (b :: BackendType)
SOILogicalModel :: LogicalModelName -> SourceObjId (b :: BackendType)
SOILogicalModelObj :: LogicalModelLocation -> LogicalModelObjId b -> SourceObjId (b :: BackendType)
data SchemaObjId
SOSource :: SourceName -> SchemaObjId
SOSourceObj :: SourceName -> AnyBackend SourceObjId -> SchemaObjId
SORemoteSchema :: RemoteSchemaName -> SchemaObjId
SORemoteSchemaPermission :: RemoteSchemaName -> RoleName -> SchemaObjId

-- | A remote relationship on a remote schema type, identified by 1. remote
--   schema name 2. remote schema type on which the relationship is defined
--   3. name of the relationship
SORemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> SchemaObjId
SORole :: RoleName -> SchemaObjId
reportSchemaObj :: SchemaObjId -> Text
reportSchemaObjs :: [SchemaObjId] -> Text
data DependencyReason
DRTable :: DependencyReason
DRColumn :: DependencyReason
DRRemoteTable :: DependencyReason
DRLeftColumn :: DependencyReason
DRRightColumn :: DependencyReason
DRUsingColumn :: DependencyReason
DRFkey :: DependencyReason
DRRemoteFkey :: DependencyReason
DRUntyped :: DependencyReason
DROnType :: DependencyReason
DRSessionVariable :: DependencyReason
DRPayload :: DependencyReason
DRParent :: DependencyReason
DRRemoteSchema :: DependencyReason
DRRemoteRelationship :: DependencyReason
DRParentRole :: DependencyReason
DRLogicalModel :: DependencyReason
DRReferencedLogicalModel :: DependencyReason
reasonToTxt :: DependencyReason -> Text
data SchemaDependency
SchemaDependency :: SchemaObjId -> DependencyReason -> SchemaDependency
[sdObjId] :: SchemaDependency -> SchemaObjId
[sdReason] :: SchemaDependency -> DependencyReason
reportDependentObjectsExist :: MonadError QErr m => [SchemaObjId] -> m ()
purgeSourceAndSchemaDependencies :: MonadError QErr m => SchemaObjId -> WriterT MetadataModifier m ()
purgeDependentObject :: forall b m. (MonadError QErr m, Backend b) => SourceName -> SourceObjId b -> m MetadataModifier

-- | Type class to collect schema dependencies from backend-specific
--   aggregation predicates.
class (Backend b) => GetAggregationPredicatesDeps b
getAggregationPredicateDeps :: GetAggregationPredicatesDeps b => AggregationPredicates b (PartialSQLExp b) -> BoolExpM b [SchemaDependency]
getAggregationPredicateDeps :: (GetAggregationPredicatesDeps b, AggregationPredicates b ~ Const Void) => AggregationPredicates b (PartialSQLExp b) -> BoolExpM b [SchemaDependency]

-- | The monad for doing schema dependency discovery for boolean
--   expressions. maintains the table context of the expressions being
--   translated.
newtype BoolExpM b a
BoolExpM :: Reader (BoolExpCtx b) a -> BoolExpM b a
[unBoolExpM] :: BoolExpM b a -> Reader (BoolExpCtx b) a

-- | The table type context of schema dependency discovery. Boolean
--   expressions may refer to a so-called 'root table' (identified by a
--   <a>$</a>-sign in the expression input syntax) or the <tt>current</tt>
--   table.
data BoolExpCtx b
BoolExpCtx :: SourceName -> TableName b -> TableName b -> BoolExpCtx b
[source] :: BoolExpCtx b -> SourceName

-- | Reference to the <tt>current</tt> table type.
[currTable] :: BoolExpCtx b -> TableName b

-- | Reference to the <tt>root</tt> table type.
[rootTable] :: BoolExpCtx b -> TableName b
runBoolExpM :: BoolExpCtx b -> BoolExpM b a -> a
instance GHC.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.TableObjId b)
instance GHC.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.LogicalModelObjId b)
instance GHC.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.NativeQueryObjId b)
instance GHC.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.StoredProcedureObjId b)
instance GHC.Generics.Generic (Hasura.RQL.Types.SchemaCacheTypes.SourceObjId b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.SourceObjId b)
instance GHC.Generics.Generic Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance GHC.Generics.Generic Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance GHC.Show.Show Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance GHC.Generics.Generic Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance GHC.Show.Show Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance Control.Monad.Reader.Class.MonadReader (Hasura.RQL.Types.SchemaCacheTypes.BoolExpCtx b) (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance GHC.Base.Monad (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance GHC.Base.Applicative (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance GHC.Base.Functor (Hasura.RQL.Types.SchemaCacheTypes.BoolExpM b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.TableObjId b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.LogicalModelObjId b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.NativeQueryObjId b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.Types.SchemaCacheTypes.StoredProcedureObjId b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.SchemaCacheTypes.SchemaDependency
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCacheTypes.DependencyReason
instance Data.Hashable.Class.Hashable Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance GHC.Show.Show Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance Data.Aeson.Types.ToJSON.ToJSONKey Hasura.RQL.Types.SchemaCacheTypes.SchemaObjId
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.SourceObjId b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.StoredProcedureObjId b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.NativeQueryObjId b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.LogicalModelObjId b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.RQL.Types.SchemaCacheTypes.TableObjId b)

module Hasura.Backends.MSSQL.Instances.SchemaCache
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.MSSQL => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps 'Hasura.RQL.Types.BackendType.MSSQL

module Hasura.Backends.DataConnector.Adapter.SchemaCache
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.DataConnector => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.Backends.BigQuery.Instances.SchemaCache
instance Hasura.RQL.Types.Backend.Backend 'Hasura.RQL.Types.BackendType.BigQuery => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps 'Hasura.RQL.Types.BackendType.BigQuery

module Hasura.RQL.Types.SchemaCache
newtype MetadataResourceVersion
MetadataResourceVersion :: Int64 -> MetadataResourceVersion
[getMetadataResourceVersion] :: MetadataResourceVersion -> Int64
initialResourceVersion :: MetadataResourceVersion
showMetadataResourceVersion :: MetadataResourceVersion -> Text
data MetadataWithResourceVersion
MetadataWithResourceVersion :: Metadata -> MetadataResourceVersion -> MetadataWithResourceVersion
[_mwrvMetadata] :: MetadataWithResourceVersion -> Metadata
[_mwrvResourceVersion] :: MetadataWithResourceVersion -> MetadataResourceVersion
mkParentDep :: forall b. Backend b => SourceName -> TableName b -> SchemaDependency

-- | When we depend on anything to do with logical models, we also declare
--   that we depend on the logical model as a whole. This is the "parent"
--   dependency in the dependency tree for a given logical model.
mkLogicalModelParentDep :: forall b. Backend b => SourceName -> LogicalModelLocation -> SchemaDependency
mkColDep :: forall b. Backend b => DependencyReason -> SourceName -> TableName b -> Column b -> SchemaDependency

-- | Declare a dependency on a particular column of a logical model
mkLogicalModelColDep :: forall b. Backend b => DependencyReason -> SourceName -> LogicalModelLocation -> Column b -> SchemaDependency
mkComputedFieldDep :: forall b. Backend b => DependencyReason -> SourceName -> TableName b -> ComputedFieldName -> SchemaDependency
type WithDeps a = (a, Seq SchemaDependency)
type RemoteSchemaRelationships = RemoteSchemaRelationshipsG (RemoteFieldInfo Name)
type RemoteSchemaCtx = RemoteSchemaCtxG (RemoteFieldInfo Name)
type RemoteSchemaMap = HashMap RemoteSchemaName RemoteSchemaCtx
type PartiallyResolvedRemoteSchemaCtx = RemoteSchemaCtxG (PartiallyResolvedRemoteRelationship RemoteRelationshipDefinition)
type PartiallyResolvedRemoteSchemaMap = HashMap RemoteSchemaName PartiallyResolvedRemoteSchemaCtx
type DepMap = HashMap SchemaObjId (HashSet SchemaDependency)
data CronTriggerInfo
CronTriggerInfo :: TriggerName -> CronSchedule -> Maybe Value -> STRetryConf -> EnvRecord ResolvedWebhook -> [EventHeaderInfo] -> Maybe Text -> Maybe RequestTransform -> Maybe MetadataResponseTransform -> CronTriggerInfo
[ctiName] :: CronTriggerInfo -> TriggerName
[ctiSchedule] :: CronTriggerInfo -> CronSchedule
[ctiPayload] :: CronTriggerInfo -> Maybe Value
[ctiRetryConf] :: CronTriggerInfo -> STRetryConf
[ctiWebhookInfo] :: CronTriggerInfo -> EnvRecord ResolvedWebhook
[ctiHeaders] :: CronTriggerInfo -> [EventHeaderInfo]
[ctiComment] :: CronTriggerInfo -> Maybe Text
[ctiRequestTransform] :: CronTriggerInfo -> Maybe RequestTransform
[ctiResponseTransform] :: CronTriggerInfo -> Maybe MetadataResponseTransform
type ActionCache = HashMap ActionName ActionInfo
type InheritedRolesCache = HashMap RoleName (HashSet RoleName)

-- | Retrieves the source info for a given source name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. This
--   function must be used with a _type annotation_, such as `askSourceInfo
--   @('Postgres 'Vanilla)`. It throws an error if: 1. The function fails
--   to find the named source at all 2. The named source exists but does
--   not match the expected type 3. The named source exists, and is of the
--   expected type, but is inconsistent
askSourceInfo :: forall b m. (CacheRM m, MetadataM m, MonadError QErr m, Backend b) => SourceName -> m (SourceInfo b)
askSourceInfoMaybe :: forall b m. (CacheRM m, Backend b) => SourceName -> m (Maybe (SourceInfo b))

-- | Retrieves the source config for a given source name.
--   
--   This function relies on <a>askSourceInfo</a> and similarly throws an
--   error if the source isn't found.
askSourceConfig :: forall b m. (CacheRM m, MonadError QErr m, Backend b, MetadataM m) => SourceName -> m (SourceConfig b)
askSourceConfigMaybe :: forall b m. (CacheRM m, Backend b) => SourceName -> m (Maybe (SourceConfig b))

-- | Retrieves the table cache for a given source cache and source name.
--   
--   This function must be used with a _type annotation_, such as
--   `unsafeTableCache <tt>('Postgres 'Vanilla)`. It returns </tt>Nothing@
--   if it fails to find that source or if the kind of the source does not
--   match the type annotation, and does not distinguish between the two
--   cases.
unsafeTableCache :: forall b. Backend b => SourceName -> SourceCache -> Maybe (TableCache b)

-- | Retrieves the table cache for a given source name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. It
--   must be used with a _type annotation_, such as `unsafeTableCache
--   <tt>('Postgres 'Vanilla)`. It returns </tt>Nothing@ if it fails to
--   find that source or if the kind of the source does not match the type
--   annotation, and does not distinguish between the two cases.
askTableCache :: forall b m. (Backend b, CacheRM m) => SourceName -> m (Maybe (TableCache b))

-- | Retrieves the information about a table from the source cache, the
--   source name, and the table name.
--   
--   This function returns <tt>Nothing</tt> if it fails to find that source
--   or if the kind of the source does not match the type annotation, and
--   does not distinguish between the two cases.
unsafeTableInfo :: forall b. Backend b => SourceName -> TableName b -> SourceCache -> Maybe (TableInfo b)

-- | Retrieves the information about a table for a given source name and
--   table name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. it
--   throws an error if it fails to find that source, in which case it
--   looks that source up in the metadata, to differentiate between the
--   source not existing or the type of the source not matching.
askTableInfo :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> TableName b -> m (TableInfo b)

-- | Similar to <a>askTableInfo</a>, but drills further down to extract the
--   underlying core info.
askTableCoreInfo :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> TableName b -> m (TableCoreInfo b)

-- | Similar to <a>askTableCoreInfo</a>, but drills further down to extract
--   the underlying field info map.
askTableFieldInfoMap :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> TableName b -> m (FieldInfoMap (FieldInfo b))
askLogicalModelCache :: forall b m. (Backend b, CacheRM m) => SourceName -> m (Maybe (LogicalModelCache b))

-- | Retrieves the metadata information about a table for a given source
--   name and table name.
--   
--   Unlike most other <tt>ask</tt> functions in this module, this function
--   does not drill through the schema cache, and instead inspects the
--   metadata. Like most others, it throws an error if it fails to find
--   that source, in which case it looks that source up in the metadata, to
--   differentiate between the source not existing or the type of the
--   source not matching.
askTableMetadata :: forall b m. (QErrM m, MetadataM m, Backend b) => SourceName -> TableName b -> m (TableMetadata b)

-- | Retrieves the function cache for a given source cache and source name.
--   
--   This function must be used with a _type annotation_, such as
--   `unsafeFunctionCache <tt>('Postgres 'Vanilla)`. It returns
--   </tt>Nothing@ if it fails to find that source or if the kind of the
--   source does not match the type annotation, and does not distinguish
--   between the two cases.
unsafeFunctionCache :: forall b. Backend b => SourceName -> SourceCache -> Maybe (FunctionCache b)

-- | Retrieves the information about a function from the source cache, the
--   source name, and the function name.
--   
--   This function returns <tt>Nothing</tt> if it fails to find that source
--   or if the kind of the source does not match the type annotation, and
--   does not distinguish between the two cases.
unsafeFunctionInfo :: forall b. Backend b => SourceName -> FunctionName b -> SourceCache -> Maybe (FunctionInfo b)

-- | Retrieves the information about a function cache for a given source
--   name and function name.
--   
--   This function retrieves the schema cache from the monadic context, and
--   attempts to look the corresponding source up in the source cache. It
--   throws an error if it fails to find that source, in which case it
--   looks that source up in the metadata, to differentiate between the
--   source not existing or the type of the source not matching.
askFunctionInfo :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> FunctionName b -> m (FunctionInfo b)
newtype BackendInfoWrapper (b :: BackendType)
BackendInfoWrapper :: BackendInfo b -> BackendInfoWrapper (b :: BackendType)
[unBackendInfoWrapper] :: BackendInfoWrapper (b :: BackendType) -> BackendInfo b
type BackendCache = BackendMap BackendInfoWrapper
getBackendInfo :: forall b m. (CacheRM m, HasTag b) => m (Maybe (BackendInfo b))
data SchemaCache
SchemaCache :: SourceCache -> ActionCache -> RemoteSchemaMap -> InlinedAllowlist -> SchemaIntrospection -> HashMap RoleName (RoleContext GQLContext) -> GQLContext -> HashMap RoleName (RoleContext GQLContext) -> GQLContext -> DepMap -> [InconsistentMetadata] -> HashMap TriggerName CronTriggerInfo -> EndpointTrie GQLQueryWithText -> ApiLimit -> MetricsConfig -> MetadataResourceVersion -> SetGraphqlIntrospectionOptions -> [TlsAllow] -> QueryCollections -> BackendCache -> SourceHealthCheckCache -> SourcePingCache -> OpenTelemetryInfo -> SchemaCache
[scSources] :: SchemaCache -> SourceCache
[scActions] :: SchemaCache -> ActionCache
[scRemoteSchemas] :: SchemaCache -> RemoteSchemaMap
[scAllowlist] :: SchemaCache -> InlinedAllowlist
[scAdminIntrospection] :: SchemaCache -> SchemaIntrospection
[scGQLContext] :: SchemaCache -> HashMap RoleName (RoleContext GQLContext)
[scUnauthenticatedGQLContext] :: SchemaCache -> GQLContext
[scRelayContext] :: SchemaCache -> HashMap RoleName (RoleContext GQLContext)
[scUnauthenticatedRelayContext] :: SchemaCache -> GQLContext
[scDepMap] :: SchemaCache -> DepMap
[scInconsistentObjs] :: SchemaCache -> [InconsistentMetadata]
[scCronTriggers] :: SchemaCache -> HashMap TriggerName CronTriggerInfo
[scEndpoints] :: SchemaCache -> EndpointTrie GQLQueryWithText
[scApiLimits] :: SchemaCache -> ApiLimit
[scMetricsConfig] :: SchemaCache -> MetricsConfig
[scMetadataResourceVersion] :: SchemaCache -> MetadataResourceVersion
[scSetGraphqlIntrospectionOptions] :: SchemaCache -> SetGraphqlIntrospectionOptions
[scTlsAllowlist] :: SchemaCache -> [TlsAllow]
[scQueryCollections] :: SchemaCache -> QueryCollections
[scBackendCache] :: SchemaCache -> BackendCache
[scSourceHealthChecks] :: SchemaCache -> SourceHealthCheckCache
[scSourcePingConfig] :: SchemaCache -> SourcePingCache
[scOpenTelemetryConfig] :: SchemaCache -> OpenTelemetryInfo
getAllRemoteSchemas :: SchemaCache -> [RemoteSchemaName]

-- | A more limited version of <a>CacheRM</a> that is used when building
--   the schema cache, since the entire schema cache has not been built
--   yet.
class (Monad m) => TableCoreInfoRM b m
lookupTableCoreInfo :: TableCoreInfoRM b m => TableName b -> m (Maybe (TableCoreInfo b))
newtype TableCoreCacheRT b m a
TableCoreCacheRT :: (TableCoreCache b -> m a) -> TableCoreCacheRT b m a
[runTableCoreCacheRT] :: TableCoreCacheRT b m a -> TableCoreCache b -> m a

-- | All our RQL DML queries operate over a single source. This typeclass
--   facilitates that.
class (TableCoreInfoRM b m) => TableInfoRM b m
lookupTableInfo :: TableInfoRM b m => TableName b -> m (Maybe (TableInfo b))
newtype TableCacheRT b m a
TableCacheRT :: (TableCache b -> m a) -> TableCacheRT b m a
[runTableCacheRT] :: TableCacheRT b m a -> TableCache b -> m a
class (Monad m) => CacheRM m
askSchemaCache :: CacheRM m => m SchemaCache
getDependentObjs :: SchemaCache -> SchemaObjId -> [SchemaObjId]
getDependentObjsWith :: (DependencyReason -> Bool) -> SchemaCache -> SchemaObjId -> [SchemaObjId]

-- | Compute all remote dependencies on a source.
--   
--   Given a source name, this function computes all of its dependencies,
--   direct or indirect, and returns all of the dependencies that are not
--   "local" to the source, i.e. that belong to another source or to a
--   remote schema, here dubbed "remote dependencies".
--   
--   This functions returns a <a>SchemaObjId</a> for each such dependency,
--   but makes no attempt at extracting the underlying <a>SourceObjId</a>
--   (if any), for two reasons: 1. a <a>SourceObjId</a> no longer contains
--   the source name, which most callers need to identify where the
--   corresponding dependency is 2. this would prevent us from returning
--   remote schema dependencies, which by definition do not have a
--   corresponding <a>SourceObjId</a>
getRemoteDependencies :: SchemaCache -> SourceName -> [SchemaObjId]

-- | What schema dependencies does a given row permission for a logical
--   model have? This will almost certainly involve some number of
--   dependencies on logical models, but may also involve dependencies on
--   tables. Although we can't relate tables and logical models yet, we can
--   still declare permissions like, "you can only see this logical model
--   if your user ID exists in this table".
getLogicalModelBoolExpDeps :: forall b. GetAggregationPredicatesDeps b => SourceName -> LogicalModelLocation -> AnnBoolExpPartialSQL b -> [SchemaDependency]

-- | Discover the schema dependencies of an <tt>AnnBoolExpPartialSQL</tt>.
getBoolExpDeps :: forall b. GetAggregationPredicatesDeps b => SourceName -> TableName b -> AnnBoolExpPartialSQL b -> [SchemaDependency]
getOpExpDeps :: forall b. Backend b => [OpExpG b (PartialSQLExp b)] -> BoolExpM b [SchemaDependency]

-- | Asking for a table's fields info without explicit
--   <tt><a>SourceName</a> argument. The source name is implicitly inferred
--   from </tt><tt>SourceM</tt> via @<a>TableCoreInfoRM</a>.
askFieldInfoMapSource :: (QErrM m, Backend b, TableCoreInfoRM b m) => TableName b -> m (FieldInfoMap (FieldInfo b))
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance GHC.Num.Num Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.MetadataResourceVersion
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.MetadataWithResourceVersion
instance GHC.Generics.Generic Hasura.RQL.Types.SchemaCache.CronTriggerInfo
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.CronTriggerInfo
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.CronTriggerInfo
instance Control.Monad.Trans.Class.MonadTrans (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Control.Monad.Trans.Class.MonadTrans (Hasura.RQL.Types.SchemaCache.TableCacheRT b)
instance Hasura.RQL.Types.Session.UserInfoM m => Hasura.RQL.Types.Session.UserInfoM (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.Backend.BackendInfo b) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.Types.SchemaCache.BackendInfoWrapper b)
instance GHC.Base.Semigroup (Hasura.RQL.Types.Backend.BackendInfo b) => GHC.Base.Semigroup (Hasura.RQL.Types.SchemaCache.BackendInfoWrapper b)
instance GHC.Base.Monoid (Hasura.RQL.Types.Backend.BackendInfo b) => GHC.Base.Monoid (Hasura.RQL.Types.SchemaCache.BackendInfoWrapper b)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Hasura.RQL.Types.SchemaCache.CacheRM m) => Hasura.RQL.Types.SchemaCache.CacheRM (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.Tracing.Monad.TraceT m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Database.MSSQL.Transaction.TxET e m)
instance (GHC.Base.Monad m, Hasura.RQL.Types.Backend.Backend b) => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance (GHC.Base.Monad m, Hasura.RQL.Types.Backend.Backend b) => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Hasura.RQL.Types.SchemaCache.TableCacheRT b m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Hasura.RQL.Types.SchemaCache.TableInfoRM b m) => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Hasura.Tracing.Monad.TraceT m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance (GHC.Base.Monad m, Hasura.RQL.Types.Backend.Backend b) => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.Types.SchemaCache.TableCoreCacheRT b m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m) => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.Tracing.Monad.TraceT m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.LogicalModel.Fields.LogicalModelFieldsLookupRT b m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.SchemaCache
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.CronTriggerInfo
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.MetadataResourceVersion

module Hasura.Server.OpenAPI
buildOpenAPI :: (MonadError QErr m, MonadFix m) => SchemaCache -> m OpenApi


-- | Types and functions used in the process of building the schema cache
--   from metadata information stored in the <tt>hdb_catalog</tt> schema in
--   Postgres.
module Hasura.RQL.Types.SchemaCache.Build
recordInconsistencies :: (ArrowWriter (Seq CollectItem) arr, Functor f, Foldable f) => ((Maybe Value, f MetadataObject), Text) `arr` ()
recordInconsistencyM :: MonadWriter (Seq CollectItem) m => Maybe Value -> MetadataObject -> Text -> m ()
recordInconsistenciesM :: MonadWriter (Seq CollectItem) m => [MetadataObject] -> Text -> m ()
data MetadataDependency
MetadataDependency :: MetadataObject -> SchemaObjId -> SchemaDependency -> MetadataDependency
recordDependencies :: ArrowWriter (Seq CollectItem) arr => (MetadataObject, SchemaObjId, Seq SchemaDependency) `arr` ()
recordDependenciesM :: MonadWriter (Seq CollectItem) m => MetadataObject -> SchemaObjId -> Seq SchemaDependency -> m ()

-- | Monadic version of <a>withRecordInconsistency</a>
withRecordInconsistencyM :: MonadWriter (Seq CollectItem) m => MetadataObject -> ExceptT QErr m a -> m (Maybe a)

-- | Record any errors resulting from a computation as inconsistencies
withRecordInconsistency :: (ArrowChoice arr, ArrowWriter (Seq CollectItem) arr) => ErrorA QErr arr (e, s) a -> arr (e, (MetadataObject, s)) (Maybe a)
withRecordInconsistencies :: (ArrowChoice arr, ArrowWriter (Seq CollectItem) arr) => ErrorA QErr arr (e, s) a -> arr (e, ([MetadataObject], s)) (Maybe a)
class (CacheRM m) => CacheRWM m
tryBuildSchemaCacheWithOptions :: CacheRWM m => BuildReason -> CacheInvalidations -> Metadata -> Maybe MetadataResourceVersion -> ValidateNewSchemaCache a -> m a
setMetadataResourceVersionInSchemaCache :: CacheRWM m => MetadataResourceVersion -> m ()
buildSchemaCacheWithOptions :: CacheRWM m => BuildReason -> CacheInvalidations -> Metadata -> Maybe MetadataResourceVersion -> m ()
data BuildReason

-- | The build was triggered by an update this instance made to the catalog
--   (in the currently-active transaction), so information in Postgres that
--   needs to be kept in sync with the catalog (i.e. table event triggers
--   in <tt>hdb_catalog</tt> schema) should be updated.
CatalogUpdate :: Maybe (HashSet SourceName) -> BuildReason

-- | The build was triggered by a notification that some other
--   currently-running Hasura instance updated the catalog. Since that
--   instance already updated table event triggers in <tt>hdb_catalog</tt>,
--   this build should be read-only.
CatalogSync :: BuildReason
data CacheInvalidations
CacheInvalidations :: Bool -> HashSet RemoteSchemaName -> HashSet SourceName -> HashSet DataConnectorName -> CacheInvalidations

-- | Force reloading of all database information, including information not
--   technically stored in metadata (currently just enum values). Set by
--   the <tt>reload_metadata</tt> API.
[ciMetadata] :: CacheInvalidations -> Bool

-- | Force refetching of the given remote schemas, even if their definition
--   has not changed. Set by the <tt>reload_remote_schema</tt> API.
[ciRemoteSchemas] :: CacheInvalidations -> HashSet RemoteSchemaName

-- | Force re-establishing connections of the given data sources, even if
--   their configuration has not changed. Set by the
--   <tt>pg_reload_source</tt> API.
[ciSources] :: CacheInvalidations -> HashSet SourceName

-- | Force re-fetching of <tt>DataConnectorInfo</tt> from the named data
--   connectors.
[ciDataConnectors] :: CacheInvalidations -> HashSet DataConnectorName

-- | Function that validates the new schema cache (usually involves
--   checking for any metadata inconsistencies) and can decide whether or
--   not to keep or discard the new schema cache
--   (<a>ValidateNewSchemaCacheResult</a>). It can also return some
--   arbitrary extra information that will be returned from
--   <a>tryBuildSchemaCacheWithOptions</a>.
--   
--   First parameter is the old schema cache, the second is the new schema
--   cache.
type ValidateNewSchemaCache a = SchemaCache -> SchemaCache -> (ValidateNewSchemaCacheResult, a)
data ValidateNewSchemaCacheResult
KeepNewSchemaCache :: ValidateNewSchemaCacheResult
DiscardNewSchemaCache :: ValidateNewSchemaCacheResult
newtype MetadataT m a
MetadataT :: StateT Metadata m a -> MetadataT m a
[unMetadataT] :: MetadataT m a -> StateT Metadata m a

-- | <tt>runMetadataT</tt> puts a stateful metadata in scope.
--   <tt>MetadataDefaults</tt> is provided so that it can be considered
--   from the --metadataDefaults arguments.
runMetadataT :: Metadata -> MetadataDefaults -> MetadataT m a -> m (a, Metadata)
buildSchemaCacheWithInvalidations :: (MetadataM m, CacheRWM m) => CacheInvalidations -> MetadataModifier -> m ()
buildSchemaCache :: (MetadataM m, CacheRWM m) => MetadataModifier -> m ()

-- | Rebuilds the schema cache after modifying metadata and returns any
--   _new_ metadata inconsistencies. If there are any new inconsistencies,
--   the changes to the metadata and the schema cache are abandoned.
tryBuildSchemaCache :: (CacheRWM m, MetadataM m) => MetadataModifier -> m (HashMap MetadataObjId (NonEmpty InconsistentMetadata))

-- | Rebuilds the schema cache after modifying metadata sequentially and
--   returns any _new_ metadata inconsistencies. If there are any new
--   inconsistencies, the changes to the metadata and the schema cache are
--   abandoned. If the metadata modifiers run into validation issues (e.g.
--   a native query is already tracked in the metadata), we throw these
--   errors back without changing the metadata and schema cache.
tryBuildSchemaCacheWithModifiers :: (CacheRWM m, MetadataM m) => [Metadata -> m Metadata] -> m (HashMap MetadataObjId (NonEmpty InconsistentMetadata))

-- | Tries to modify the metadata for all the specified metadata objects.
--   If the modification fails, any objects that directly caused a new
--   metadata inconsistency are removed and the modification is attempted
--   again without those failing objects. The failing objects are raised as
--   warnings in <a>MonadWarnings</a> and the successful objects are
--   returned. If there are metadata inconsistencies that are not directly
--   related to the specified metadata objects, an error is thrown.
tryBuildSchemaCacheAndWarnOnFailingObjects :: forall m a. (CacheRWM m, MonadWarnings m, QErrM m, MetadataM m) => (a -> m MetadataModifier) -> WarningCode -> HashMap MetadataObjId a -> m (HashMap MetadataObjId a)

-- | Rebuilds the schema cache after modifying metadata. If an object with
--   the given object id became newly inconsistent, raises an error about
--   it specifically. Otherwise, raises a generic metadata inconsistency
--   error.
buildSchemaCacheFor :: (QErrM m, CacheRWM m, MetadataM m) => MetadataObjId -> MetadataModifier -> m ()

-- | Requests the schema cache, and fails if there is any inconsistent
--   metadata.
throwOnInconsistencies :: (QErrM m, CacheRWM m) => m ()

-- | Executes the given action, and if any new <a>InconsistentMetadata</a>s
--   are added to the schema cache as a result of its execution, raises an
--   error.
withNewInconsistentObjsCheck :: (QErrM m, CacheRM m) => m a -> m a

-- | getInconsistentQueryCollections is a helper function that runs the
--   static analysis over the saved queries and reports any inconsistenties
--   with the current schema.
getInconsistentQueryCollections :: SchemaIntrospection -> QueryCollections -> ((CollectionName, ListedQuery) -> MetadataObject) -> EndpointTrie GQLQueryWithText -> [NormalizedQuery] -> [InconsistentMetadata]
data StoredIntrospection
StoredIntrospection :: HashMap SourceName EncJSON -> HashMap RemoteSchemaName EncJSON -> StoredIntrospection
[siBackendIntrospection] :: StoredIntrospection -> HashMap SourceName EncJSON
[siRemotes] :: StoredIntrospection -> HashMap RemoteSchemaName EncJSON

-- | Represents remote schema or source introspection data to be persisted
--   in a storage (database).
data StoredIntrospectionItem
SourceIntrospectionItem :: SourceName -> EncJSON -> StoredIntrospectionItem
RemoteSchemaIntrospectionItem :: RemoteSchemaName -> EncJSON -> StoredIntrospectionItem

-- | Items to be collected while building schema cache See
--   @<tt>buildSchemaCacheRule</tt> for more details.
data CollectItem
CollectInconsistentMetadata :: InconsistentMetadata -> CollectItem
CollectMetadataDependency :: MetadataDependency -> CollectItem
CollectStoredIntrospection :: StoredIntrospectionItem -> CollectItem
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.Build.MetadataDependency
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.MetadataDependency
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.Build.BuildReason
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.BuildReason
instance GHC.Generics.Generic Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance GHC.Classes.Ord Hasura.RQL.Types.SchemaCache.Build.ValidateNewSchemaCacheResult
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.Build.ValidateNewSchemaCacheResult
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.ValidateNewSchemaCacheResult
instance Hasura.QueryTags.MonadQueryTags m => Hasura.QueryTags.MonadQueryTags (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Morph.MFunctor Hasura.RQL.Types.SchemaCache.Build.MetadataT
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Backends.Postgres.Connection.MonadTx.MonadTx m => Hasura.Backends.Postgres.Connection.MonadTx.MonadTx (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.RQL.Types.SchemaCache.Build.MetadataT
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance GHC.Generics.Generic Hasura.RQL.Types.SchemaCache.Build.StoredIntrospection
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.CollectItem
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.Build.CollectItem
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.StoredIntrospectionItem
instance GHC.Show.Show Hasura.RQL.Types.SchemaCache.Build.StoredIntrospectionItem
instance GHC.Classes.Eq Hasura.RQL.Types.SchemaCache.Build.StoredIntrospection
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SchemaCache.Build.StoredIntrospection
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.Build.StoredIntrospection
instance GHC.Base.Monad m => Hasura.RQL.Types.Metadata.MetadataM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.Types.Session.UserInfoM m => Hasura.RQL.Types.Session.UserInfoM (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Hasura.Tracing.Monad.TraceT m)
instance Hasura.RQL.Types.SchemaCache.Build.CacheRWM m => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Database.PG.Query.Transaction.TxET Hasura.Base.Error.QErr m)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance GHC.Base.Semigroup Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations
instance GHC.Base.Monoid Hasura.RQL.Types.SchemaCache.Build.CacheInvalidations


-- | This module defines the schema dependency gathering aspect of the
--   default implementation of aggregation predicates.
module Hasura.RQL.Types.SchemaCache.AggregationPredicates
defaultGetAggregationPredicateDeps :: forall b. GetAggregationPredicatesDeps b => AggregationPredicatesImplementation b (PartialSQLExp b) -> BoolExpM b [SchemaDependency]

module Hasura.Backends.Postgres.Instances.SchemaCache
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Hasura.RQL.Types.SchemaCacheTypes.GetAggregationPredicatesDeps ('Hasura.RQL.Types.BackendType.Postgres pgKind)

module Hasura.RQL.Types.SchemaCache.Instances

module Hasura.RQL.Types.Roles.Internal

-- | <a>CheckPermission</a> is a type which can be used to combine multiple
--   permissions when the permission type implements the
--   <tt>OnlyRelevantEq</tt> instance
data CheckPermission permissionType
CPUndefined :: CheckPermission permissionType
CPInconsistent :: CheckPermission permissionType
CPDefined :: permissionType -> CheckPermission permissionType

-- | CombineRolePermInfo acts as an intermediate type to be able to combine
--   multiple role permissions into one, using the <a>Monoid</a> instance.
--   Multiple role permissions are combined for inherited role permissions
--   where this is used.
data CombineRolePermInfo (b :: BackendType)
CombineRolePermInfo :: CheckPermission (InsPermInfo b) -> Maybe (CombinedSelPermInfo b) -> CheckPermission (UpdPermInfo b) -> CheckPermission (DelPermInfo b) -> CombineRolePermInfo (b :: BackendType)
[crpiInsPerm] :: CombineRolePermInfo (b :: BackendType) -> CheckPermission (InsPermInfo b)
[crpiSelPerm] :: CombineRolePermInfo (b :: BackendType) -> Maybe (CombinedSelPermInfo b)
[crpiUpdPerm] :: CombineRolePermInfo (b :: BackendType) -> CheckPermission (UpdPermInfo b)
[crpiDelPerm] :: CombineRolePermInfo (b :: BackendType) -> CheckPermission (DelPermInfo b)
rolePermInfoToCombineRolePermInfo :: RolePermInfo b -> CombineRolePermInfo b
maybeToCheckPermission :: Maybe a -> CheckPermission a
instance GHC.Classes.Eq permissionType => GHC.Classes.Eq (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)
instance GHC.Show.Show permissionType => GHC.Show.Show (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq permissionType => GHC.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq permissionType => GHC.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission permissionType)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.GBoolExp b a)
instance GHC.Classes.Eq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Hashable.Class.Hashable (Hasura.RQL.IR.BoolExp.OpExpG b a), Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExp b a), Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnComputedFieldBoolExp b a)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b a)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.Table.Cache.InsPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.Table.Cache.UpdPermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnBoolExpPartialSQL b)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.Table.Cache.DelPermInfo b)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaInputValueDefinition
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Hasura.RemoteSchema.SchemaCache.Types.RemoteSchemaIntrospection
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Hasura.RemoteSchema.SchemaCache.Types.IntrospectionResult
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (GHC.Maybe.Maybe a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.Name.Name
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq [a]
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.ScalarTypeDefinition
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.FieldDefinition a)
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.ObjectTypeDefinition a)
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.InterfaceTypeDefinition [Language.GraphQL.Draft.Syntax.Name.Name] a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.UnionTypeDefinition
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.InputObjectTypeDefinition a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.EnumValueDefinition
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.EnumTypeDefinition
instance (Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq a, GHC.Classes.Ord a) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Language.GraphQL.Draft.Syntax.TypeDefinition [Language.GraphQL.Draft.Syntax.Name.Name] a)
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq Language.GraphQL.Draft.Syntax.InputValueDefinition
instance Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.GBoolExp b (Hasura.RQL.IR.BoolExp.AnnBoolExpFld b v)) => Hasura.RQL.Types.Roles.Internal.OnlyRelevantEq (Hasura.RQL.IR.BoolExp.AnnRedactionExp b v)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.DelPermInfo b)), GHC.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.InsPermInfo b)), GHC.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.UpdPermInfo b)), GHC.Base.Semigroup (Hasura.Table.Cache.CombinedSelPermInfo b)) => GHC.Base.Semigroup (Hasura.RQL.Types.Roles.Internal.CombineRolePermInfo b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.DelPermInfo b)), GHC.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.InsPermInfo b)), GHC.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CheckPermission (Hasura.Table.Cache.UpdPermInfo b)), GHC.Base.Monoid (GHC.Maybe.Maybe (Hasura.Table.Cache.CombinedSelPermInfo b))) => GHC.Base.Monoid (Hasura.RQL.Types.Roles.Internal.CombineRolePermInfo b)

module Hasura.GraphQL.Transport.WebSocket.Server
data WSId
mkUnsafeWSId :: UUID -> WSId

-- | Websocket message and other details
data MessageDetails
MessageDetails :: !SerializableBlob -> !Int64 -> MessageDetails
data WSEvent
EMessageSent :: !MessageDetails -> WSEvent
data WSEventInfo
WSEventInfo :: !Maybe ServerMsgType -> !Maybe OperationId -> !Maybe OperationName -> !Maybe Double -> !Maybe Int64 -> !Maybe ParameterizedQueryHash -> WSEventInfo
[_wseiEventType] :: WSEventInfo -> !Maybe ServerMsgType
[_wseiOperationId] :: WSEventInfo -> !Maybe OperationId
[_wseiOperationName] :: WSEventInfo -> !Maybe OperationName
[_wseiQueryExecutionTime] :: WSEventInfo -> !Maybe Double
[_wseiResponseSize] :: WSEventInfo -> !Maybe Int64
[_wseiParameterizedQueryHash] :: WSEventInfo -> !Maybe ParameterizedQueryHash
data WSLog
WSLog :: !WSId -> !WSEvent -> !Maybe WSEventInfo -> WSLog
class (Monad m) => MonadWSLog m

-- | Takes WS server log data and logs it logWSServer
logWSLog :: MonadWSLog m => Logger Hasura -> WSLog -> m ()
data WSQueueResponse
WSQueueResponse :: ByteString -> Maybe WSEventInfo -> IO DiffTime -> WSQueueResponse
data WSConn a
getRawWebSocketConnection :: WSConn a -> Connection
getData :: WSConn a -> a
getWSId :: WSConn a -> WSId
closeConn :: WSConn a -> ByteString -> IO ()
sendMsgAndCloseConn :: WSConn a -> Word16 -> ByteString -> ServerMsg -> IO ()
sendMsg :: WSConn a -> WSQueueResponse -> IO ()
data WSServer a
WSServer :: Logger Hasura -> TVar SecuritySensitiveUserConfig -> TVar (ServerStatus a) -> WSServer a
[_wssLogger] :: WSServer a -> Logger Hasura

-- | Keep track of the security sensitive user configuration to perform
--   maintenance actions
[_wssSecuritySensitiveUserConfig] :: WSServer a -> TVar SecuritySensitiveUserConfig

-- | See e.g. createServerApp.onAccept for how we use STM to preserve
--   consistency
[_wssStatus] :: WSServer a -> TVar (ServerStatus a)
createWSServer :: AuthMode -> AllowListStatus -> InlinedAllowlist -> CorsPolicy -> SQLGenCtx -> HashSet ExperimentalFeature -> NamingCase -> Logger Hasura -> STM (WSServer a)
closeAllConnectionsWithReason :: WSServer a -> String -> ByteString -> (SecuritySensitiveUserConfig -> SecuritySensitiveUserConfig) -> IO ()
data AcceptWith a
AcceptWith :: !a -> !AcceptRequest -> !WSConn a -> IO () -> !WSConn a -> IO () -> AcceptWith a

-- | These set of functions or message handlers is used by the server while
--   communicating with the client. They are particularly useful for the
--   case when the messages being sent to the client are different for each
--   of the sub-protocol(s) supported by the server.
type WSKeepAliveMessageAction a = WSConn a -> IO ()
type WSOnErrorMessageAction a = WSConn a -> ConnErrMsg -> WSErrorMessage -> IO ()

-- | Used for specific actions within the <tt>onConn</tt> and
--   <tt>onMessage</tt> handlers
data WSActions a
WSActions :: !WSPostExecErrMessageAction a -> !WSOnErrorMessageAction a -> !WSCloseConnAction a -> !WSKeepAliveMessageAction a -> !DataMsg -> ServerMsg -> !AcceptRequest -> ![Encoding] -> Encoding -> WSActions a
[_wsaPostExecErrMessageAction] :: WSActions a -> !WSPostExecErrMessageAction a
[_wsaOnErrorMessageAction] :: WSActions a -> !WSOnErrorMessageAction a
[_wsaConnectionCloseAction] :: WSActions a -> !WSCloseConnAction a

-- | NOTE: keep alive action was made redundant because we need to send
--   this message after the connection has been successfully established
--   after <tt>connection_init</tt>
[_wsaKeepAliveAction] :: WSActions a -> !WSKeepAliveMessageAction a
[_wsaGetDataMessageType] :: WSActions a -> !DataMsg -> ServerMsg
[_wsaAcceptRequest] :: WSActions a -> !AcceptRequest
[_wsaErrorMsgFormat] :: WSActions a -> ![Encoding] -> Encoding
data WSErrorMessage
ClientMessageParseFailed :: WSErrorMessage
ConnInitFailed :: WSErrorMessage
mkWSServerErrorCode :: WSSubProtocol -> WSErrorMessage -> ConnErrMsg -> ServerErrorCode
type OnConnH m a = WSId -> RequestHead -> IpAddress -> WSActions a -> m (Either RejectRequest (AcceptWith a))

-- | aka generalized <a>ServerApp</a> over <tt>m</tt>, which takes an
--   IPAddress
type HasuraServerApp m = IpAddress -> PendingConnection -> m ()

-- | NOTE: The types of <a>_hOnConn</a> and <a>_hOnMessage</a> were updated
--   from <a>OnConnH</a> and <tt>OnMessageH</tt> because we needed to pass
--   the subprotcol here to these methods to eventually get to
--   <a>OnConnH</a> and <tt>OnMessageH</tt>. Please see
--   <a>createServerApp</a> to get a better understanding of how these
--   handlers are used.
data WSHandlers m a
WSHandlers :: (WSId -> RequestHead -> IpAddress -> WSSubProtocol -> m (Either RejectRequest (AcceptWith a))) -> (WSConn a -> ByteString -> WSSubProtocol -> m ()) -> OnCloseH m a -> WSHandlers m a

-- | The background thread responsible for closing all websocket
--   connections when security sensitive user configuration changes. It
--   checks for changes in the auth mode, allowlist, cors config, stringify
--   num, dangerous boolean collapse, stringify big query numeric,
--   experimental features and invalidates/closes all connections if there
--   are any changes.
websocketConnectionReaper :: IO (AuthMode, AllowListStatus, CorsPolicy, SQLGenCtx, HashSet ExperimentalFeature, NamingCase) -> IO SchemaCache -> WSServer a -> IO Void
createServerApp :: (MonadIO m, MonadBaseControl IO m, Forall (Pure m), MonadWSLog m, MonadGetPolicies m) => IO MetricsConfig -> WSConnectionInitTimeout -> WSServer a -> PrometheusMetrics -> WSHandlers m a -> HasuraServerApp m
shutdown :: WSServer a -> IO ()
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSReaperThreadLog
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Transport.WebSocket.Server.WSReaperThreadLog Hasura.Logging.Hasura
instance Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog m => Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog m => Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog (Control.Monad.Trans.Reader.ReaderT r m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSLog
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Transport.WebSocket.Server.WSLog Hasura.Logging.Hasura
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSEventInfo
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Server.WSEventInfo
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSEventInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSEvent
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.MessageDetails
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Transport.WebSocket.Server.WSId
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Server.WSId
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.WSId
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Server.MessageDetails
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.Server.WSId


-- | Multiplexed subscription poller threads; see
--   <a>Hasura.GraphQL.Execute.Subscription</a> for details.
module Hasura.GraphQL.Execute.Subscription.Poll.Common
data SubscriberId
newSubscriberId :: IO SubscriberId

-- | Allows a user of the live query subsystem (currently websocket
--   transport) to attach arbitrary metadata about a subscriber. This
--   information is available as part of Subscriber in
--   CohortExecutionDetails and can be logged by customizing in pollerlog
data SubscriberMetadata
mkSubscriberMetadata :: WSId -> OperationId -> Maybe OperationName -> RequestId -> SubscriberMetadata
data Subscriber
Subscriber :: !SubscriberId -> !SubscriberMetadata -> !RequestId -> !Maybe OperationName -> !OnChange -> Subscriber
[_sId] :: Subscriber -> !SubscriberId
[_sMetadata] :: Subscriber -> !SubscriberMetadata
[_sRequestId] :: Subscriber -> !RequestId
[_sOperationName] :: Subscriber -> !Maybe OperationName
[_sOnChangeCallback] :: Subscriber -> !OnChange

-- | Subscription onChange metadata, used for adding more extra analytics
--   data
data SubscriptionMetadata
SubscriptionMetadata :: !DiffTime -> SubscriptionMetadata
[_sqmExecutionTime] :: SubscriptionMetadata -> !DiffTime
data SubscriptionResponse
SubscriptionResponse :: !ByteString -> !DiffTime -> SubscriptionResponse
[_lqrPayload] :: SubscriptionResponse -> !ByteString
[_lqrExecutionTime] :: SubscriptionResponse -> !DiffTime
type SubscriptionGQResponse = GQResult SubscriptionResponse
type OnChange = SubscriptionGQResponse -> IO ()
type SubscriberMap = TMap SubscriberId Subscriber
data PollerResponseState
PRSSuccess :: PollerResponseState
PRSError :: PollerResponseState

-- | A batched group of <a>Subscriber</a>s who are not only listening to
--   the same query but also have identical session and query variables.
--   Each result pushed to a <a>Cohort</a> is forwarded along to each of
--   its <a>Subscriber</a>s.
--   
--   In SQL, each <a>Cohort</a> corresponds to a single row in the
--   laterally-joined <tt>_subs</tt> table (and therefore a single row in
--   the query result).
--   
--   See also <a>CohortMap</a>.
data Cohort streamCursorVars
Cohort :: CohortId -> TVar (Maybe ResponseHash) -> SubscriberMap -> SubscriberMap -> streamCursorVars -> Cohort streamCursorVars

-- | a unique identifier used to identify the cohort in the generated query
[_cCohortId] :: Cohort streamCursorVars -> CohortId

-- | Contains a hash of the previous poll's DB query result, if any, used
--   to determine if we need to push an updated result to the subscribers
--   or not.
[_cPreviousResponse] :: Cohort streamCursorVars -> TVar (Maybe ResponseHash)

-- | the subscribers weâ€™ve already pushed a result to; we push new results
--   to them if the response changes
[_cExistingSubscribers] :: Cohort streamCursorVars -> SubscriberMap

-- | subscribers we havenâ€™t yet pushed any results to; we push results to
--   them regardless if the result changed, then merge them in the map of
--   existing subscribers
[_cNewSubscribers] :: Cohort streamCursorVars -> SubscriberMap

-- | a mutable type which holds the latest value of the subscription stream
--   cursor. In case of live query subscription, this field is ignored by
--   setting <tt>streamCursorVars</tt> to <tt>()</tt>
[_cStreamCursorVariables] :: Cohort streamCursorVars -> streamCursorVars

-- | The <tt>BatchId</tt> is a number based ID to uniquely identify a batch
--   in a single poll and it's used to identify the batch to which a cohort
--   belongs to.
newtype BatchId
BatchId :: Int -> BatchId
[_unBatchId] :: BatchId -> Int

-- | A hash used to determine if the result changed without having to keep
--   the entire result in memory. Using a cryptographic hash ensures that a
--   hash collision is almost impossible: with 256 bits, even if a
--   subscription changes once per second for an entire year, the
--   probability of a hash collision is ~4.294417Ã—10-63. See Note [Blake2b
--   faster than SHA-256].
newtype ResponseHash
ResponseHash :: Digest Blake2b_256 -> ResponseHash
[unResponseHash] :: ResponseHash -> Digest Blake2b_256
mkRespHash :: ByteString -> ResponseHash

-- | A key we use to determine if two <a>Subscriber</a>s belong in the same
--   <a>Cohort</a> (assuming they already meet the criteria to be in the
--   same <a>Poller</a>). Note the distinction between this and
--   <a>CohortId</a>; the latter is a completely synthetic key used only to
--   identify the cohort in the generated SQL query.
type CohortKey = CohortVariables

-- | This has the invariant, maintained in <tt>removeLiveQuery</tt>, that
--   it contains no <a>Cohort</a> with zero total (existing + new)
--   subscribers.
type CohortMap streamCursor = TMap CohortKey (Cohort streamCursor)
data CohortSnapshot
CohortSnapshot :: CohortVariables -> TVar (Maybe ResponseHash) -> [Subscriber] -> [Subscriber] -> CohortSnapshot
[_csVariables] :: CohortSnapshot -> CohortVariables
[_csPreviousResponse] :: CohortSnapshot -> TVar (Maybe ResponseHash)
[_csExistingSubscribers] :: CohortSnapshot -> [Subscriber]
[_csNewSubscribers] :: CohortSnapshot -> [Subscriber]

-- | A unique, multiplexed query. Each <a>Poller</a> has its own polling
--   thread that periodically polls Postgres and pushes results to each of
--   its listening <a>Cohort</a>s.
--   
--   In SQL, an <a>Poller</a> corresponds to a single, multiplexed query,
--   though in practice, <a>Poller</a>s with large numbers of
--   <a>Cohort</a>s are batched into multiple concurrent queries for
--   performance reasons.
data Poller streamCursor
Poller :: CohortMap streamCursor -> TVar PollerResponseState -> TMVar PollerIOState -> ParameterizedQueryHash -> TMap (Maybe OperationName) Int -> Poller streamCursor
[_pCohorts] :: Poller streamCursor -> CohortMap streamCursor
[_pPollerState] :: Poller streamCursor -> TVar PollerResponseState

-- | This is in a separate <a>TMVar</a> because itâ€™s important that we are
--   able to construct <a>Poller</a> values in <a>STM</a> --- we need the
--   insertion into the <a>PollerMap</a> to be atomic to ensure that we
--   donâ€™t accidentally create two for the same query due to a race.
--   However, we canâ€™t spawn the worker thread or create the metrics store
--   in <a>STM</a>, so we insert it into the <a>Poller</a> only after weâ€™re
--   certain we wonâ€™t create any duplicates.
--   
--   This var is "write once", moving monotonically from empty to full.
--   TODO this could probably be tightened up to something like 'STM
--   PollerIOState'
[_pIOState] :: Poller streamCursor -> TMVar PollerIOState
[_pParameterizedQueryHash] :: Poller streamCursor -> ParameterizedQueryHash
[_pOperationNamesMap] :: Poller streamCursor -> TMap (Maybe OperationName) Int
data PollerIOState
PollerIOState :: !Thread -> !PollerId -> PollerIOState

-- | a handle on the pollerâ€™s worker thread that can be used to <a>stop</a>
--   it if all its cohorts stop listening
[_pThread] :: PollerIOState -> !Thread
[_pId] :: PollerIOState -> !PollerId
data PollerKey b
PollerKey :: SourceName -> RoleName -> Text -> ResolvedConnectionTemplate b -> ParameterizedQueryHash -> PollerKey b
[_lgSource] :: PollerKey b -> SourceName
[_lgRole] :: PollerKey b -> RoleName
[_lgQuery] :: PollerKey b -> Text
[_lgConnectionKey] :: PollerKey b -> ResolvedConnectionTemplate b
[_lgParameterizedQueryHash] :: PollerKey b -> ParameterizedQueryHash
newtype BackendPollerKey
BackendPollerKey :: AnyBackend PollerKey -> BackendPollerKey
[unBackendPollerKey] :: BackendPollerKey -> AnyBackend PollerKey
type PollerMap streamCursor = Map BackendPollerKey (Poller streamCursor)

-- | For dev debugging, output subject to change.
dumpPollerMap :: Bool -> PollerMap streamCursor -> IO Value

-- | An ID to track unique <a>Poller</a>s, so that we can gather metrics
--   about each poller
newtype PollerId
PollerId :: UUID -> PollerId
[unPollerId] :: PollerId -> UUID
data SubscriberExecutionDetails
SubscriberExecutionDetails :: !SubscriberId -> !SubscriberMetadata -> SubscriberExecutionDetails
[_sedSubscriberId] :: SubscriberExecutionDetails -> !SubscriberId
[_sedSubscriberMetadata] :: SubscriberExecutionDetails -> !SubscriberMetadata

-- | Execution information related to a cohort on a poll cycle
data CohortExecutionDetails
CohortExecutionDetails :: !CohortId -> !CohortVariables -> !Maybe Int -> ![SubscriberExecutionDetails] -> ![SubscriberExecutionDetails] -> !BatchId -> CohortExecutionDetails
[_cedCohortId] :: CohortExecutionDetails -> !CohortId
[_cedVariables] :: CohortExecutionDetails -> !CohortVariables

-- | Nothing in case of an error
[_cedResponseSize] :: CohortExecutionDetails -> !Maybe Int

-- | The response on this cycle has been pushed to these above subscribers
--   New subscribers (those which haven't been around during the previous
--   poll cycle) will always be part of this
[_cedPushedTo] :: CohortExecutionDetails -> ![SubscriberExecutionDetails]

-- | The response on this cycle has *not* been pushed to these above
--   subscribers. This would when the response hasn't changed from the
--   previous polled cycle
[_cedIgnored] :: CohortExecutionDetails -> ![SubscriberExecutionDetails]
[_cedBatchId] :: CohortExecutionDetails -> !BatchId

-- | Execution information related to a single batched execution
data BatchExecutionDetails
BatchExecutionDetails :: Maybe DiffTime -> DiffTime -> DiffTime -> BatchId -> [CohortExecutionDetails] -> Maybe Int -> BatchExecutionDetails

-- | postgres execution time of each batch (<a>Nothing</a> in case of
--   non-PG dbs)
[_bedPgExecutionTime] :: BatchExecutionDetails -> Maybe DiffTime

-- | database execution time of each batch
[_bedDbExecutionTime] :: BatchExecutionDetails -> DiffTime

-- | time to taken to push to all cohorts belonging to this batch
[_bedPushTime] :: BatchExecutionDetails -> DiffTime

-- | id of the batch
[_bedBatchId] :: BatchExecutionDetails -> BatchId

-- | execution details of the cohorts belonging to this batch
[_bedCohorts] :: BatchExecutionDetails -> [CohortExecutionDetails]
[_bedBatchResponseSizeBytes] :: BatchExecutionDetails -> Maybe Int
data PollDetailsError
PollDetailsError :: BatchId -> QErr -> PollDetailsError
[_pdeBatchId] :: PollDetailsError -> BatchId
[_pdeErrorDetails] :: PollDetailsError -> QErr
data PollDetails
PollDetails :: PollerId -> SubscriptionType -> Text -> DiffTime -> [BatchExecutionDetails] -> DiffTime -> SubscriptionsOptions -> SourceName -> RoleName -> ParameterizedQueryHash -> LogLevel -> Maybe [PollDetailsError] -> PollDetails

-- | the unique ID (basically a thread that run as a <a>Poller</a>) for the
--   <a>Poller</a>
[_pdPollerId] :: PollDetails -> PollerId

-- | distinguish between the subscription type (i.e. live-query or
--   streaming subscription)
[_pdKind] :: PollDetails -> SubscriptionType

-- | the multiplexed SQL query to be run against the database with all the
--   variables together
[_pdGeneratedSql] :: PollDetails -> Text

-- | the time taken to get a snapshot of cohorts from our
--   <tt>SubscriptionsState</tt> data structure
[_pdSnapshotTime] :: PollDetails -> DiffTime

-- | list of execution batches and their details
[_pdBatches] :: PollDetails -> [BatchExecutionDetails]

-- | total time spent on a poll cycle
[_pdTotalTime] :: PollDetails -> DiffTime
[_pdLiveQueryOptions] :: PollDetails -> SubscriptionsOptions
[_pdSource] :: PollDetails -> SourceName
[_pdRole] :: PollDetails -> RoleName
[_pdParameterizedQueryHash] :: PollDetails -> ParameterizedQueryHash
[_pdLogLevel] :: PollDetails -> LogLevel
[_pdErrors] :: PollDetails -> Maybe [PollDetailsError]
type SubscriptionPostPollHook = PollDetails -> IO ()
defaultSubscriptionPostPollHook :: Logger Hasura -> SubscriptionPostPollHook
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberMetadata
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberMetadata
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberMetadata
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerResponseState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchId
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.ResponseHash
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.ResponseHash
instance GHC.Generics.Generic (Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey b)
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Subscription.Poll.Common.BackendPollerKey
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.BackendPollerKey
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.BackendPollerKey
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerId
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberExecutionDetails
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.SubscriberExecutionDetails
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.CohortExecutionDetails
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.CohortExecutionDetails
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchExecutionDetails
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.BatchExecutionDetails
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetailsError
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetails
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetails
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey b)
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetails Hasura.Logging.Hasura
instance GHC.Show.Show Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetailsError
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.PollDetailsError
instance Hasura.RQL.Types.Backend.Backend b => Data.Hashable.Class.Hashable (Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey b)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Execute.Subscription.Poll.Common.PollerKey b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Subscription.Poll.Common.ResponseHash

module Hasura.GraphQL.Execute.Subscription.Types
class SubscriptionTypes (s :: SubscriptionType) where {
    type Cohort s :: Type;
    type CohortSnapshot s :: Type;
    type CohortMap s :: Type;
    type Poller s :: Type;
    type PollerMap s :: Type;
}
instance Hasura.GraphQL.Execute.Subscription.Types.SubscriptionTypes 'Hasura.RQL.Types.Subscription.LiveQuery
instance Hasura.GraphQL.Execute.Subscription.Types.SubscriptionTypes 'Hasura.RQL.Types.Subscription.Streaming

module Hasura.GraphQL.Schema.Common

-- | Aggregation of contextual information required to build the schema.
data SchemaContext
SchemaContext :: SchemaKind -> RemoteRelationshipParserBuilder -> RoleName -> SchemaContext

-- | the kind of schema being built
[scSchemaKind] :: SchemaContext -> SchemaKind

-- | how to process remote relationships
[scRemoteRelationshipParserBuilder] :: SchemaContext -> RemoteRelationshipParserBuilder

-- | the role for which the schema is being built
[scRole] :: SchemaContext -> RoleName

-- | The kind of schema we're building, and its associated options.
data SchemaKind
HasuraSchema :: SchemaKind
RelaySchema :: NodeInterfaceParserBuilder -> SchemaKind
isHasuraSchema :: SchemaKind -> Bool

-- | The set of common constraints required to build the schema.
type MonadBuildSchemaBase m n = (MonadError QErr m, MonadMemoize m, MonadParse n)

-- | How a remote relationship field should be processed when building a
--   schema. Injecting this function from the top level avoids having to
--   know how to do top-level dispatch from deep within the schema code.
--   
--   Note: the inner function type uses an existential qualifier: it is
--   expected that the given function will work for _any_ monad <tt>m</tt>
--   that has the relevant constraints. This prevents us from passing a
--   function that is specfic to the monad in which the schema construction
--   will run, but avoids having to propagate type annotations to each call
--   site.
newtype RemoteRelationshipParserBuilder
RemoteRelationshipParserBuilder :: (forall lhsJoinField r n m. MonadBuildSchemaBase m n => RemoteFieldInfo lhsJoinField -> SchemaT r m (Maybe [FieldParser n (RemoteRelationshipField UnpreparedValue)])) -> RemoteRelationshipParserBuilder

-- | A <a>RemoteRelationshipParserBuilder</a> that ignores the field
--   altogether, that can be used in tests or to build a source or remote
--   schema in isolation.
ignoreRemoteRelationship :: RemoteRelationshipParserBuilder

-- | How to build the <tt>Relay</tt> node.
--   
--   Similarly to what we do for remote relationships, we pass in the
--   context the builder function required to build the <tt>Node</tt>
--   interface, in order to avoid the cross-sources cycles it creates
--   otherwise.
newtype NodeInterfaceParserBuilder
NodeInterfaceParserBuilder :: (forall m n. MonadBuildSchemaBase m n => SchemaContext -> SchemaOptions -> m (Parser 'Output n NodeMap)) -> NodeInterfaceParserBuilder
[runNodeBuilder] :: NodeInterfaceParserBuilder -> forall m n. MonadBuildSchemaBase m n => SchemaContext -> SchemaOptions -> m (Parser 'Output n NodeMap)
retrieve :: (MonadReader r m, Has a r) => (a -> b) -> m b

-- | The monad in which the schema is built.
--   
--   The implementation of <a>SchemaT</a> is intended to be opaque: running
--   a computation in <a>SchemaT</a> is intended to be done via calls to
--   <a>runSourceSchema</a> and <a>runRemoteSchema</a>, which also enforce
--   what the <tt>r</tt> parameter should be in each case.
--   
--   The reason why we want to enforce that the schema is built in a reader
--   on top of an arbitrary base monad is for performance: see Note
--   [SchemaT and stacking] for more information.
--   
--   In the future, we might monomorphize this further to make
--   <tt>MemoizeT</tt> explicit.
newtype SchemaT r m a
SchemaT :: ReaderT r m a -> SchemaT r m a
[runSchemaT] :: SchemaT r m a -> ReaderT r m a
type MonadBuildSourceSchema b r m n = (MonadBuildSchemaBase m n, Has SchemaContext r, Has SchemaOptions r, Has (SourceInfo b) r)

-- | Runs a schema-building computation with all the context required to
--   build a source.
runSourceSchema :: forall b m a. SchemaContext -> SchemaOptions -> SourceInfo b -> SchemaT (SchemaContext, SchemaOptions, SourceInfo b) m a -> m a
type MonadBuildRemoteSchema r m n = (MonadBuildSchemaBase m n, Has SchemaContext r, Has RemoteNullForwardingPolicy r, Has CustomizeRemoteFieldName r, Has MkTypename r)

-- | Runs a schema-building computation with all the context required to
--   build a remote schema.
runRemoteSchema :: SchemaContext -> RemoteNullForwardingPolicy -> SchemaT (SchemaContext, RemoteNullForwardingPolicy, MkTypename, CustomizeRemoteFieldName) m a -> m a
type MonadBuildActionSchema r m n = (MonadBuildSchemaBase m n, Has SchemaContext r, Has SchemaOptions r)

-- | Runs a schema-building computation with all the context required to
--   build actions.
runActionSchema :: SchemaContext -> SchemaOptions -> SchemaT (SchemaContext, SchemaOptions) m a -> m a
type SelectExp b = AnnSimpleSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type StreamSelectExp b = AnnSimpleStreamSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type AggSelectExp b = AnnAggregateSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type ConnectionSelectExp b = ConnectionSelect b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type SelectArgs b = SelectArgsG b (UnpreparedValue b)
type SelectStreamArgs b = SelectStreamArgsG b (UnpreparedValue b)
type TablePerms b = TablePermG b (UnpreparedValue b)
type AnnotatedFields b = AnnFieldsG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type AnnotatedField b = AnnFieldG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type ConnectionFields b = ConnectionFields b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type EdgeFields b = EdgeFields b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type AnnotatedActionFields = ActionFieldsG (RemoteRelationshipField UnpreparedValue)
type AnnotatedActionField = ActionFieldG (RemoteRelationshipField UnpreparedValue)
type AnnotatedNestedObjectSelect b = AnnNestedObjectSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
type AnnotatedNestedArraySelect b = AnnNestedArraySelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)
data RemoteSchemaParser n
RemoteSchemaParser :: [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))] -> RemoteSchemaParser n
[piQuery] :: RemoteSchemaParser n -> [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))]
[piMutation] :: RemoteSchemaParser n -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))]
[piSubscription] :: RemoteSchemaParser n -> Maybe [FieldParser n (NamespacedField (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))]
getTableRoles :: BackendSourceInfo -> [RoleName]
getLogicalModelRoles :: BackendSourceInfo -> [RoleName]
askScalarTypeParsingContext :: forall b r m. (MonadReader r m, Has (SourceInfo b) r, Has (ScalarTypeParsingContext b) (SourceConfig b)) => m (ScalarTypeParsingContext b)

-- | Looks up table information for the given table name. This function
--   should never fail, since the schema cache construction process is
--   supposed to ensure all dependencies are resolved. TODO: deduplicate
--   this with <a>CacheRM</a>.
askTableInfo :: forall b r m. (Backend b, MonadError QErr m, MonadReader r m, Has (SourceInfo b) r) => TableName b -> m (TableInfo b)

-- | Looks up logical model information for the given logical model name.
--   This function should never fail, since the schema cache construction
--   process is supposed to ensure all dependencies are resolved. TODO:
--   deduplicate this with <a>CacheRM</a>.
askLogicalModelInfo :: forall b r m. (MonadError QErr m, MonadReader r m, Has (SourceInfo b) r) => LogicalModelName -> m (LogicalModelInfo b)

-- | Looks up native query information for the given native query name.
--   This function should never fail, since the schema cache construction
--   process is supposed to ensure all dependencies are resolved. TODO:
--   deduplicate this with <a>CacheRM</a>.
askNativeQueryInfo :: forall b r m. (MonadError QErr m, MonadReader r m, Has (SourceInfo b) r) => NativeQueryName -> m (NativeQueryInfo b)

-- | Whether the request is sent with
--   `x-hasura-use-backend-only-permissions` set to <tt>true</tt>.
data Scenario
Backend :: Scenario
Frontend :: Scenario
textToName :: MonadError QErr m => Text -> m Name
textToGQLIdentifier :: MonadError QErr m => Text -> m GQLNameIdentifier
partialSQLExpToUnpreparedValue :: PartialSQLExp b -> UnpreparedValue b
getRedactionExprForColumn :: Backend b => SelPermInfo b -> Column b -> Maybe (AnnRedactionExpUnpreparedValue b)
getRedactionExprForComputedField :: Backend b => SelPermInfo b -> ComputedFieldName -> Maybe (AnnRedactionExpUnpreparedValue b)
mapField :: Functor m => InputFieldsParser m (Maybe a) -> (a -> b) -> InputFieldsParser m (Maybe b)
parsedSelectionsToFields :: (Text -> a) -> InsOrdHashMap Name (ParsedSelection a) -> Fields a
numericAggOperators :: [GQLNameIdentifier]
comparisonAggOperators :: [GQLNameIdentifier]
mkDescriptionWith :: Maybe PGDescription -> Text -> Description
takeValidTables :: forall b. Backend b => TableCache b -> TableCache b
takeValidFunctions :: forall b. FunctionCache b -> FunctionCache b

-- | @TODO: Currently we do no validation on native queries in schema.
--   Should we?
takeValidNativeQueries :: forall b. NativeQueryCache b -> NativeQueryCache b

-- | @TODO: Currently we do no validation on stored procedures in schema.
--   Should we?
takeValidStoredProcedures :: forall b. StoredProcedureCache b -> StoredProcedureCache b
requiredFieldParser :: (Functor n, Functor m) => (a -> b) -> m (FieldParser n a) -> m (Maybe (FieldParser n b))
optionalFieldParser :: (Functor n, Functor m) => (a -> b) -> m (Maybe (FieldParser n a)) -> m (Maybe (FieldParser n b))

-- | Builds the type name for referenced enum tables.
mkEnumTypeName :: forall b r m. (Backend b, MonadError QErr m, Has (SourceInfo b) r) => TableName b -> Maybe Name -> SchemaT r m Name
addEnumSuffix :: ResolvedSourceCustomization -> GQLNameIdentifier -> Maybe Name -> Name
peelWithOrigin :: MonadParse m => Parser 'Both m a -> Parser 'Both m (ValueWithOrigin a)
getIntrospectionResult :: RemoteSchemaPermissions -> RoleName -> RemoteSchemaCtxG remoteFieldInfo -> Maybe IntrospectionResult
tablePermissionsInfo :: Backend b => SelPermInfo b -> TablePerms b
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance Control.Monad.Trans.Class.MonadTrans (Hasura.GraphQL.Schema.Common.SchemaT r)
instance Control.Monad.Memoize.MonadMemoize m => Control.Monad.Memoize.MonadMemoize (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader r (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.GraphQL.Schema.Common.SchemaT r m)
instance GHC.Classes.Eq Hasura.GraphQL.Schema.Common.Scenario
instance GHC.Show.Show Hasura.GraphQL.Schema.Common.Scenario
instance GHC.Enum.Enum Hasura.GraphQL.Schema.Common.Scenario

module Hasura.LogicalModel.Common

-- | build select permissions for logical model
logicalModelPermissions :: Backend b => LogicalModelInfo b -> RoleName -> Maybe (TablePermG b (UnpreparedValue b))
columnsFromFields :: InsOrdHashMap k (LogicalModelField b) -> InsOrdHashMap k (NullableScalarType b)
logicalModelFieldsToFieldInfo :: forall b. Backend b => InsOrdHashMap (Column b) (LogicalModelField b) -> FieldInfoMap (FieldInfo b)
getSelPermInfoForLogicalModel :: Backend b => RoleName -> LogicalModelInfo b -> Maybe (SelPermInfo b)


-- | This module defines translation functions for queries which select
--   data. Principally this includes translating the <tt>query</tt> root
--   field, but parts are also reused for serving the responses for
--   mutations.
module Hasura.Backends.MSSQL.FromIr.Query

-- | This is the top-level entry point for translation of Query root
--   fields.
fromQueryRootField :: QueryDB 'MSSQL Void Expression -> FromIr Select
fromSelect :: JsonAggSelect -> AnnSelectG 'MSSQL (AnnFieldG 'MSSQL Void) Expression -> FromIr Select

-- | Used in <a>planSourceRelationship</a>, which is in turn used by to
--   implement <tt>mkDBRemoteRelationship</tt> for <tt>BackendExecute</tt>.
--   For more information, see the module/documentation of <a>Source</a>.
fromSourceRelationship :: NonEmpty Object -> HashMap FieldName (ColumnName, ScalarType) -> FieldName -> (FieldName, SourceRelationshipSelection 'MSSQL Void (Const Expression)) -> FromIr Select
instance GHC.Show.Show Hasura.Backends.MSSQL.FromIr.Query.Args
instance GHC.Show.Show Hasura.Backends.MSSQL.FromIr.Query.FieldSource
instance GHC.Classes.Eq Hasura.Backends.MSSQL.FromIr.Query.FieldSource
instance GHC.Show.Show Hasura.Backends.MSSQL.FromIr.Query.UnfurledJoin


-- | MSSQL Plan
--   
--   Planning T-SQL queries and subscription by translating IR to
--   MSSQL-specific SQL query types.
module Hasura.Backends.MSSQL.Plan
planQuery :: MonadError QErr m => SessionVariables -> QueryDB 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (QueryWithDDL Select)

-- | For more information, see the module/documentation of <a>Source</a>.
planSourceRelationship :: MonadError QErr m => SessionVariables -> NonEmpty Object -> HashMap FieldName (ColumnName, ScalarType) -> FieldName -> (FieldName, SourceRelationshipSelection 'MSSQL Void UnpreparedValue) -> m Select

-- | Prepare a value without any query planning; we just execute the query
--   with the values embedded.
prepareValueQuery :: MonadError QErr m => SessionVariables -> UnpreparedValue 'MSSQL -> m Expression
planSubscription :: MonadError QErr m => InsOrdHashMap Name (QueryDB 'MSSQL Void (UnpreparedValue 'MSSQL)) -> SessionVariables -> m (Reselect, PrepareState)
data PrepareState
PrepareState :: [ColumnValue 'MSSQL] -> HashMap Name (ColumnValue 'MSSQL) -> HashSet SessionVariable -> PrepareState
[positionalArguments] :: PrepareState -> [ColumnValue 'MSSQL]
[namedArguments] :: PrepareState -> HashMap Name (ColumnValue 'MSSQL)
[sessionVariables] :: PrepareState -> HashSet SessionVariable
resultIdAlias :: Text
resultVarsAlias :: Text
resultAlias :: Text
rowAlias :: Text


-- | This module defines translation functions that yield the results of
--   mutation requests that return the data of rows that were affected.
module Hasura.Backends.MSSQL.FromIr.MutationResponse

-- | Generate a SQL SELECT statement which outputs the mutation response
--   
--   For multi row inserts:
--   
--   SELECT (SELECT COUNT(*) FROM [with_alias]) AS [affected_rows],
--   (select_from_returning) AS [returning] FOR JSON PATH,
--   INCLUDE_NULL_VALUES, WITHOUT_ARRAY_WRAPPER
--   
--   For single row insert: the selection set is translated to SQL query
--   using @<a>fromSelect</a>
mkMutationOutputSelect :: StringifyNumbers -> Text -> MutationOutputG 'MSSQL Void Expression -> FromIr Select

-- | Generate a SQL SELECT statement which outputs both mutation response
--   and check constraint result.
--   
--   A <tt>check constraint</tt> applies to the data that has been changed,
--   while <tt>permissions</tt> filter the data that is made available.
--   
--   This function applies to <tt>insert</tt> and <tt>update</tt>
--   mutations.
--   
--   The check constraint boolean expression is evaluated on mutated rows
--   in a CASE expression so that the int value "0" is returned when check
--   constraint is true otherwise the int value "1" is returned. We use
--   <a>SUM</a> aggregation on the returned value and if check constraint
--   on any row is not met, the summed value will not equal to "0" (always
--   &gt; 1).
--   
--   <pre>
--   &lt;check_constraint_select&gt; :=
--     SELECT SUM([check_sub_query].[check_evaluation])
--     FROM
--       ( SELECT
--           (CASE WHEN &lt;check_boolean_expression&gt; THEN 0 ELSE 1 END) AS [check_evaluation]
--         FROM
--           [with_alias]
--       ) AS [check_sub_query]
--   
--   &lt;mutation_output_select&gt; :=
--     SELECT
--       (SELECT COUNT(*) FROM [with_alias]) AS [affected_rows],
--       (select_from_returning) AS [returning]
--     FOR JSON PATH, INCLUDE_NULL_VALUES, WITHOUT_ARRAY_WRAPPER
--   
--   SELECT
--     (&lt;mutation_output_select&gt;) AS [mutation_response],
--     (&lt;check_constraint_select&gt;) AS [check_constraint_select]
--   </pre>
selectMutationOutputAndCheckCondition :: Text -> Select -> Expression -> Select

module Hasura.GraphQL.Schema.Remote
buildRemoteParser :: forall r m n. MonadBuildRemoteSchema r m n => IntrospectionResult -> RemoteSchemaRelationships -> RemoteSchemaInfo -> SchemaT r m (RemoteSchemaParser n)
makeResultCustomizer :: RemoteSchemaCustomizer -> GraphQLField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable -> ResultCustomizer

-- | <a>remoteField</a> accepts a <a>TypeDefinition</a> and will returns a
--   <a>FieldParser</a> for it. Note that the <a>TypeDefinition</a> should
--   be of the GraphQL <a>Output</a> kind, when an GraphQL <a>Input</a>
--   kind is provided, then error will be thrown.
remoteField :: forall r m n. MonadBuildRemoteSchema r m n => RemoteSchemaIntrospection -> RemoteSchemaRelationships -> Name -> Name -> Maybe Description -> ArgumentsDefinition RemoteSchemaInputValueDefinition -> TypeDefinition [Name] RemoteSchemaInputValueDefinition -> SchemaT r m (FieldParser n (GraphQLField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable))
withRemoteSchemaCustomization :: forall m r a. (MonadReader r m, Has MkTypename r, Has CustomizeRemoteFieldName r) => RemoteSchemaCustomizer -> m a -> m a
instance GHC.Base.Monoid Hasura.GraphQL.Schema.Remote.Altered
instance GHC.Base.Semigroup Hasura.GraphQL.Schema.Remote.Altered
instance GHC.Show.Show Hasura.GraphQL.Schema.Remote.Altered

module Hasura.GraphQL.RemoteServer

-- | Make an introspection query to the remote graphql server for the data
--   we need to present and stitch the remote schema. This powers
--   add_remote_schema, and also is called by schema cache rebuilding code
--   in <a>Hasura.RQL.DDL.Schema.Cache</a>.
fetchRemoteSchema :: forall m. (MonadIO m, MonadError QErr m, MonadTrace m, ProvidesNetwork m) => Environment -> ValidatedRemoteSchemaDef -> m (IntrospectionResult, ByteString, RemoteSchemaInfo)

-- | Parses the remote schema introspection result, and check whether it
--   looks like it's a valid GraphQL endpoint even under the configured
--   customization.
stitchRemoteSchema :: (MonadIO m, MonadError QErr m) => ByteString -> ValidatedRemoteSchemaDef -> m (IntrospectionResult, RemoteSchemaInfo)

-- | Sends a GraphQL query to the given server.
execRemoteGQ :: (MonadIO m, MonadError QErr m, MonadTrace m, ProvidesNetwork m) => Environment -> UserInfo -> [Header] -> ValidatedRemoteSchemaDef -> GQLReqOutgoing -> m (DiffTime, [Header], ByteString)

-- | Parsing the introspection query result. We use this newtype wrapper to
--   avoid orphan instances and parse JSON in the way that we need for
--   GraphQL introspection results.
newtype FromIntrospection a
FromIntrospection :: a -> FromIntrospection a
[fromIntrospection] :: FromIntrospection a -> a
instance GHC.Base.Functor Hasura.GraphQL.RemoteServer.FromIntrospection
instance GHC.Generics.Generic (Hasura.GraphQL.RemoteServer.FromIntrospection a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.RemoteServer.FromIntrospection a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.RemoteServer.FromIntrospection a)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.Description)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.FieldDefinition a))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.GType)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.InputValueDefinition)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.Value Data.Void.Void))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Language.GraphQL.Draft.Syntax.EnumValueDefinition)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection (Language.GraphQL.Draft.Syntax.TypeDefinition [Language.GraphQL.Draft.Syntax.Name.Name] Language.GraphQL.Draft.Syntax.InputValueDefinition))
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.GraphQL.RemoteServer.FromIntrospection Hasura.RemoteSchema.SchemaCache.Types.IntrospectionResult)


-- | Tools for generating fields for Apollo federation
module Hasura.GraphQL.ApolloFederation

-- | Internal parser function for entities field
data ApolloFederationParserFunction n
ApolloFederationParserFunction :: (ApolloFederationAnyType -> n (QueryRootField UnpreparedValue)) -> ApolloFederationParserFunction n
[aafuGetRootField] :: ApolloFederationParserFunction n -> ApolloFederationAnyType -> n (QueryRootField UnpreparedValue)
convertToApolloFedParserFunc :: (MonadParse n, Backend b) => SourceInfo b -> TableInfo b -> SelPermInfo b -> StringifyNumbers -> Maybe NamingCase -> NESeq (ColumnInfo b) -> Parser 'Output n (AnnotatedFields b) -> Parser 'Output n (ApolloFederationParserFunction n)
apolloRootFields :: ApolloFederationStatus -> [(Name, Parser 'Output Parse (ApolloFederationParserFunction Parse))] -> [FieldParser Parse (SchemaIntrospection -> QueryRootField UnpreparedValue)]

-- | Check if the Apollo Federation feature is enabled or not. If the user
--   has explicitly set the Apollo Federation status, then we use that else
--   we fallback to the experimental feature flag
getApolloFederationStatus :: HashSet ExperimentalFeature -> Maybe ApolloFederationStatus -> ApolloFederationStatus
generateSDLWithAllTypes :: SchemaIntrospection -> Text
generateSDL :: SchemaIntrospection -> Text
instance GHC.Show.Show Hasura.GraphQL.ApolloFederation.ApolloFederationAnyType
instance GHC.Classes.Eq Hasura.GraphQL.ApolloFederation.GenerateSDLType


-- | Arg and Env Parsing for initialisation of the engine along with
--   corresponding logging and other helper functionality.
--   
--   This module is intended as the interface for options parsing and its
--   submodules should not need to be imported directly.
module Hasura.Server.Init

-- | Query the Metadata DB for the Metadata DB UUID. TODO: Move into a
--   dedicated Metadata module (ala Pro).
getDbId :: TxE QErr MetadataDbId
getPgVersion :: TxE QErr PGVersion

-- | Given the <a>ServeOptionsRaw</a> parsed from the arg parser,
--   postprocess the db url and fetch env vars associated with the main
--   command parser, then process the subcommand raw values if necessary.
mkHGEOptions :: EnabledLogTypes impl => HGEOptionsRaw (ServeOptionsRaw impl) -> WithEnv (HGEOptions (ServeOptions impl))

-- | <tt>PostressConnInfo</tt> is a a tuple of some <tt>a</tt> with a
--   'Maybe Int' representing the retries setting. This function thus takes
--   a retries setting and a <a>PostgresConnInfoRaw</a> from the arg parser
--   and merges those results with the contents of their corresponding env
--   vars.
processPostgresConnInfo :: PostgresConnInfo (Maybe PostgresConnInfoRaw) -> WithEnv (PostgresConnInfo (Maybe UrlConf))

-- | Merge the results of the serve subcommmand arg parser with
--   corresponding values from the <a>WithEnv</a> context.
mkServeOptions :: forall impl. EnabledLogTypes impl => ServeOptionsRaw impl -> WithEnv (ServeOptions impl)


-- | This module defines the type class <a>BackendSchema</a> and auxiliary
--   types.
--   
--   <a>BackendSchema</a> represents the part of the interface that a
--   backend driver presents to the GraphQL Engine core that is responsible
--   for generating the backend's Schema Parsers.
--   
--   The Schema Parsers recognise (and reflect) the schema that a backend
--   exposes.
--   
--   The <a>BackendSchema</a> methods are used by <a>buildGQLContext</a>,
--   which is the core's entrypoint to schema generation.
--   
--   Many of the <a>BackendSchema</a> methods will have default
--   implementations that a backend driver may use. These may be found
--   (chiefly) in the modules:
--   
--   <ul>
--   <li>The module <a>Hasura.GraphQL.Schema.Build</a>, commonly qualified
--   <tt>GSB</tt></li>
--   <li><a>Hasura.GraphQL.Schema.Select</a>, commonly qualified
--   <tt>GSS</tt></li>
--   <li><a>Hasura.GraphQL.Schema.BoolExp</a></li>
--   </ul>
--   
--   For more information see:
--   
--   <ul>
--   <li><a>Technical overview of Schema Generation</a></li>
--   <li>The type <a>Parser</a>, and associated source code notes in the
--   same folder (not exposed with Haddock unfortunately)</li>
--   </ul>
module Hasura.GraphQL.Schema.Backend

-- | Bag of constraints available to the methods of <tt>BackendSchema</tt>.
--   
--   Note that <tt>BackendSchema b</tt> is itself part of this, so a
--   methods may also call other methods. This might seem trivial, but it
--   can be easy to miss when the functions used to implement a class
--   instance are defined in multiple modules.
type MonadBuildSchema b r m n = (BackendSchema b, MonadBuildSourceSchema b r m n)

-- | This type class is responsible for generating the schema of a backend.
--   Its methods are called by the common core that orchestrates the
--   various backend drivers.
--   
--   Its purpose in life is to make it convenient to express the GraphQL
--   schema we want to expose for the backends that we support. This means
--   balancing the desire to have consistency with the desire to
--   differentiate the schema of a backend.
--   
--   This means that it is expected to evolve over time as we add new
--   backends, and that you have the license to change it: Whatever form it
--   currently takes only reflects status quo current implementation.
--   
--   The module <a>Hasura.GraphQL.Schema.Build</a> (commonly qualified as
--   <tt>GSB</tt>) provides standard building blocks for implementing many
--   methods of this class. And as such, these two modules are very much
--   expected to evolve in tandem.
--   
--   See <a>Note BackendSchema modelling principles</a>.
class (Backend b) => BackendSchema (b :: BackendType)
buildTableQueryAndSubscriptionFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m ([FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], Maybe (Name, Parser 'Output n (ApolloFederationParserFunction n)))
buildTableStreamingSubscriptionFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableRelayQueryFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> TableName b -> TableInfo b -> GQLNameIdentifier -> NESeq (ColumnInfo b) -> SchemaT r m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableInsertMutationFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> Scenario -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]

-- | This method is responsible for building the GraphQL Schema for
--   mutations backed by <tt>UPDATE</tt> statements on some table, as
--   described in
--   <tt><a>https://hasura.io/docs/latest/graphql/core/databases/postgres/mutations/update.html</a></tt>.
--   
--   The suggested way to implement this is using building blocks in GSB,
--   c.f. its namesake <tt>GSB.</tt><a>buildTableUpdateMutationFields</a>.
buildTableUpdateMutationFields :: (BackendSchema b, MonadBuildSchema b r m n) => Scenario -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableDeleteMutationFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> Scenario -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildFunctionQueryFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> FunctionName b -> FunctionInfo b -> TableName b -> SchemaT r m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildFunctionRelayQueryFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> FunctionName b -> FunctionInfo b -> TableName b -> NESeq (ColumnInfo b) -> SchemaT r m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildFunctionMutationFields :: (BackendSchema b, MonadBuildSchema b r m n) => MkRootFieldName -> FunctionName b -> FunctionInfo b -> TableName b -> SchemaT r m [FieldParser n (MutationDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildNativeQueryRootFields :: (BackendSchema b, MonadBuildSchema b r m n) => NativeQueryInfo b -> SchemaT r m (Maybe (FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
buildStoredProcedureRootFields :: (BackendSchema b, MonadBuildSchema b r m n) => StoredProcedureInfo b -> SchemaT r m (Maybe (FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Make a parser for relationships. Default implementaton elides
--   relationships altogether.
mkRelationshipParser :: (BackendSchema b, MonadBuildSchema b r m n) => RelInfo b -> SchemaT r m (Maybe (InputFieldsParser n (Maybe (AnnotatedInsertField b (UnpreparedValue b)))))
relayExtension :: BackendSchema b => Maybe (XRelay b)
nodesAggExtension :: BackendSchema b => Maybe (XNodesAgg b)
streamSubscriptionExtension :: BackendSchema b => Maybe (XStreamingSubscription b)
groupByExtension :: BackendSchema b => Maybe (XGroupBy b)
columnParser :: (BackendSchema b, MonadBuildSchema b r m n) => ColumnType b -> Nullability -> SchemaT r m (Parser 'Both n (ValueWithOrigin (ColumnValue b)))
enumParser :: (BackendSchema b, MonadBuildSchema b r m n) => TableName b -> NonEmpty (EnumValue, EnumValueInfo) -> Maybe Name -> Nullability -> SchemaT r m (Parser 'Both n (ScalarValue b))
possiblyNullable :: (BackendSchema b, MonadParse m) => ScalarType b -> Nullability -> Parser 'Both m (ScalarValue b) -> Parser 'Both m (ScalarValue b)

-- | Parser for arguments on scalar fields in a selection set
scalarSelectionArgumentsParser :: (BackendSchema b, MonadParse n) => ColumnType b -> InputFieldsParser n (Maybe (ScalarSelectionArguments b))
orderByOperators :: BackendSchema b => SourceInfo b -> NamingCase -> (Name, NonEmpty (Definition EnumValueInfo, (BasicOrderType b, NullsOrderType b)))
comparisonExps :: (BackendSchema b, MonadBuildSchema b r m n) => ColumnType b -> SchemaT r m (Parser 'Input n [ComparisonExp b])

-- | The input fields parser, for "count" aggregate field, yielding a
--   function which generates @'CountType b' from optional "distinct" field
--   value
countTypeInput :: (BackendSchema b, MonadParse n) => Maybe (Parser 'Both n (Column b, AnnRedactionExpUnpreparedValue b)) -> InputFieldsParser n (CountDistinct -> CountType b (UnpreparedValue b))
aggregateOrderByCountType :: BackendSchema b => ScalarType b

-- | Computed field parser
computedField :: (BackendSchema b, MonadBuildSchema b r m n) => ComputedFieldInfo b -> TableName b -> TableInfo b -> SchemaT r m (Maybe (FieldParser n (AnnotatedField b)))

-- | The public interface for the schema of table queries exposed by a
--   backend.
--   
--   Remote Schemas and the Relay schema are the chief backend-agnostic
--   clients of this typeclass.
--   
--   Some of schema building components in the <a>Hasura.GraphQL.Schema</a>
--   namespace also make use of these methods, ensuring backends expose a
--   consistent schema regardless of the mode it's referenced.
--   
--   Default implementations exist for all of these in <a>Select</a>.
class (Backend b) => BackendTableSelectSchema (b :: BackendType)
tableArguments :: (BackendTableSelectSchema b, MonadBuildSourceSchema b r m n) => TableInfo b -> SchemaT r m (InputFieldsParser n (SelectArgsG b (UnpreparedValue b)))
tableSelectionSet :: (BackendTableSelectSchema b, MonadBuildSourceSchema b r m n) => TableInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))
selectTable :: (BackendTableSelectSchema b, MonadBuildSourceSchema b r m n) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (SelectExp b)))
selectTableAggregate :: (BackendTableSelectSchema b, MonadBuildSourceSchema b r m n) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AggSelectExp b)))
type ComparisonExp b = OpExpG b (UnpreparedValue b)
class (Backend b) => BackendLogicalModelSelectSchema (b :: BackendType)
logicalModelArguments :: (BackendLogicalModelSelectSchema b, MonadBuildSourceSchema b r m n) => LogicalModelInfo b -> SchemaT r m (InputFieldsParser n (SelectArgsG b (UnpreparedValue b)))
logicalModelSelectionSet :: (BackendLogicalModelSelectSchema b, MonadBuildSourceSchema b r m n) => LogicalModelInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))
class (BackendLogicalModelSelectSchema b) => BackendNativeQuerySelectSchema (b :: BackendType)
selectNativeQuery :: (BackendNativeQuerySelectSchema b, MonadBuildSourceSchema b r m n) => NativeQueryInfo b -> Name -> Nullable -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnSimpleSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
selectNativeQueryObject :: (BackendNativeQuerySelectSchema b, MonadBuildSchema b r m n) => NativeQueryInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnObjectSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
class (Backend b) => BackendUpdateOperatorsSchema (b :: BackendType) where {
    
    -- | Intermediate Representation of the set of update operators that act
    --   upon table fields during an update mutation. (For example, _set and
    --   _inc)
    --   
    --   It is parameterised over the type of fields, which changes during the
    --   IR translation phases.
    type UpdateOperators b :: Type -> Type;
}
parseUpdateOperators :: forall m n r. (BackendUpdateOperatorsSchema b, MonadBuildSchema b r m n) => TableInfo b -> UpdPermInfo b -> SchemaT r m (InputFieldsParser n (HashMap (Column b) (UpdateOperators b (UnpreparedValue b))))


-- | Schema parsers for common functionality of logical model resolvers.
module Hasura.LogicalModelResolver.Schema

-- | Schema parser for native query or stored procedure arguments.
argumentsSchema :: forall b r m n. MonadBuildSchema b r m n => Text -> Name -> HashMap ArgumentName (NullableScalarType b) -> MaybeT (SchemaT r m) (InputFieldsParser n (HashMap ArgumentName (ColumnValue b)))


-- | Helper functions for generating the schema of database tables
module Hasura.GraphQL.Schema.Table

-- | Helper function to get the table GraphQL name. A table may have a
--   custom name configured with it. When the custom name exists, the
--   GraphQL nodes that are generated according to the custom name. For
--   example: Let's say, we have a table called `users address`, the name
--   of the table is not GraphQL compliant so we configure the table with a
--   GraphQL compliant name, say <tt>users_address</tt> The generated
--   top-level nodes of this table will be like <tt>users_address</tt>,
--   <tt>insert_users_address</tt> etc
getTableGQLName :: forall b m. (Backend b, MonadError QErr m) => TableInfo b -> m Name

-- | similar to <tt>getTableGQLName</tt> but returns table name as a list
--   with name pieces instead of concatenating schema and table name
--   together.
getTableIdentifierName :: forall b m. (Backend b, MonadError QErr m) => TableInfo b -> m GQLNameIdentifier

-- | Table select columns enum
--   
--   Parser for an enum type that matches the columns of the given table.
--   Used as a parameter for "distinct", among others. Maps to the
--   table_select_column object.
--   
--   Return Nothing if there's no column the current user has "select"
--   permissions for.
tableSelectColumnsEnum :: forall b r m n. MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Maybe (Parser 'Both n (Column b, AnnRedactionExpUnpreparedValue b)))

-- | Table select columns enum of a certain type.
--   
--   Parser for an enum type that matches, of a given table, certain
--   columns which satisfy a predicate. Used as a parameter for aggregation
--   predicate arguments, among others. Maps to the table_select_column
--   object.
--   
--   Return Nothing if there's no column the current user has "select"
--   permissions for.
tableSelectColumnsPredEnum :: forall b r m n. MonadBuildSchema b r m n => (ColumnType b -> Bool) -> GQLNameIdentifier -> TableInfo b -> SchemaT r m (Maybe (Parser 'Both n (Column b, AnnRedactionExpUnpreparedValue b)))

-- | Table update columns enum
--   
--   Parser for an enum type that matches the columns of the given table.
--   Used for conflict resolution in "insert" mutations, among others. Maps
--   to the table_update_column object.
tableUpdateColumnsEnum :: forall b r m n. MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Maybe (Parser 'Both n (Column b)))
updateColumnsPlaceholderParser :: forall b r m n. MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Parser 'Both n (Maybe (Column b)))
tableSelectPermissions :: RoleName -> TableInfo b -> Maybe (SelPermInfo b)
tableSelectFields :: forall b r m. (Backend b, MonadError QErr m, MonadReader r m, Has SchemaContext r, Has (SourceInfo b) r) => TableInfo b -> m [FieldInfo b]
tableColumns :: forall b. TableInfo b -> [ColumnInfo b]

-- | Get the columns of a table that may be selected under the given select
--   permissions.
tableSelectColumns :: forall b r m. (Backend b, MonadError QErr m, MonadReader r m, Has SchemaContext r, Has (SourceInfo b) r) => TableInfo b -> m [(StructuredColumnInfo b, AnnRedactionExpUnpreparedValue b)]

-- | Get the computed fields of a table that may be selected under the
--   given select permissions.
tableSelectComputedFields :: forall b r m. (Backend b, MonadError QErr m, MonadReader r m, Has SchemaContext r, Has (SourceInfo b) r) => TableInfo b -> m [ComputedFieldInfo b]

-- | Get the columns of a table that my be updated under the given update
--   permissions.
tableUpdateColumns :: forall b. Backend b => RoleName -> TableInfo b -> [ColumnInfo b]


-- | This module provides common building blocks for composing Schema
--   Parsers used in the schema of Update Mutations.
module Hasura.GraphQL.Schema.Update

-- | <tt>UpdateOperator b m n op</tt> represents one single update operator
--   for a backend <tt>b</tt>.
--   
--   The type variable <tt>op</tt> is the backend-specific data type that
--   represents update operators, typically in the form of a sum-type with
--   an <tt>UnpreparedValue b</tt> in each constructor.
--   
--   The <tt>UpdateOperator b m n</tt> is a <tt>Functor</tt>. There exist
--   building blocks of common update operators (such as <a>setOp</a>,
--   etc.) which have <tt>op ~ UnpreparedValue b</tt>. The Functor instance
--   lets you wrap the generic update operators in backend-specific tags.
data UpdateOperator b r m n op
UpdateOperator :: (ColumnInfo b -> Bool) -> (GQLNameIdentifier -> TableName b -> NonEmpty (ColumnInfo b) -> SchemaT r m (InputFieldsParser n (HashMap (Column b) op))) -> UpdateOperator b r m n op
[updateOperatorApplicableColumn] :: UpdateOperator b r m n op -> ColumnInfo b -> Bool
[updateOperatorParser] :: UpdateOperator b r m n op -> GQLNameIdentifier -> TableName b -> NonEmpty (ColumnInfo b) -> SchemaT r m (InputFieldsParser n (HashMap (Column b) op))

-- | The top-level component for building update operators parsers.
--   
--   <ul>
--   <li>It implements the <tt>preset</tt> functionality from Update
--   Permissions (see
--   &lt;<a>https://hasura.io/docs/latest/graphql/core/auth/authorization/permission-rules.html#column-presets</a>
--   Permissions user docs&gt;). Use the <a>presetColumns</a> function to
--   extract those from the update permissions.</li>
--   <li>It validates that that the update fields parsed are sound when
--   taken as a whole, i.e. that some changes are actually specified
--   (either in the mutation query text or in update preset columns) and
--   that each column is only used in one operator.</li>
--   </ul>
buildUpdateOperators :: forall b r m n op. MonadBuildSchema b r m n => HashMap (Column b) op -> [UpdateOperator b r m n op] -> TableInfo b -> SchemaT r m (InputFieldsParser n (HashMap (Column b) op))

-- | The columns that have <tt>preset</tt> definitions applied to them.
--   (see
--   &lt;<a>https://hasura.io/docs/latest/graphql/core/auth/authorization/permission-rules.html#column-presets</a>
--   Permissions user docs&gt;)
presetColumns :: UpdPermInfo b -> HashMap (Column b) (UnpreparedValue b)

-- | Construct a parser for a single update operator.
--   
--   <tt>updateOperator _ "op" fp MkOp ["col1","col2"]</tt> gives a parser
--   that accepts objects in the shape of:
--   
--   <pre>
--   op: {
--     col1: "x",
--     col2: "y"
--   }
--   </pre>
--   
--   And (morally) parses into values:
--   
--   <pre>
--   HashMap.fromList [("col1", MkOp (fp "x")), ("col2", MkOp (fp "y"))]
--   </pre>
updateOperator :: forall n r m b a. MonadBuildSchema b r m n => GQLNameIdentifier -> GQLNameIdentifier -> GQLNameIdentifier -> (ColumnInfo b -> SchemaT r m (Parser 'Both n a)) -> NonEmpty (ColumnInfo b) -> Description -> Description -> SchemaT r m (InputFieldsParser n (HashMap (Column b) a))
setOp :: forall b n r m. MonadBuildSchema b r m n => UpdateOperator b r m n (UnpreparedValue b)
incOp :: forall b m n r. MonadBuildSchema b r m n => UpdateOperator b r m n (UnpreparedValue b)
instance (GHC.Base.Functor m, GHC.Base.Functor n) => GHC.Base.Functor (Hasura.GraphQL.Schema.Update.UpdateOperator b r m n)

module Hasura.GraphQL.Schema.OrderBy

-- | Corresponds to an object type for an order by.
--   
--   <pre>
--   input table_order_by {
--     col1: order_by
--     col2: order_by
--     .     .
--     .     .
--     coln: order_by
--     obj-rel: &lt;remote-table&gt;_order_by
--   }
--   </pre>
--   
--   TODO: When there are no columns accessible to a role, the
--   `<a>table</a>_order_by` will be an empty input object. In such a case,
--   we can avoid exposing the <tt>order_by</tt> argument.
logicalModelOrderByExp :: forall b r m n. MonadBuildSchema b r m n => LogicalModelInfo b -> SchemaT r m (Parser 'Input n [AnnotatedOrderByItemG b (UnpreparedValue b)])

-- | Corresponds to an object type for an order by.
--   
--   <pre>
--   input table_order_by {
--     col1: order_by
--     col2: order_by
--     .     .
--     .     .
--     coln: order_by
--     obj-rel: &lt;remote-table&gt;_order_by
--   }
--   </pre>
tableOrderByExp :: forall b r m n. MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Parser 'Input n [AnnotatedOrderByItemG b (UnpreparedValue b)])

module Hasura.GraphQL.Schema.BoolExp

-- | Backends implement this type class to specify the schema of
--   aggregation predicates.
--   
--   The default implementation results in a parser that does not parse
--   anything.
--   
--   The scope of this class is local to the function <tt>boolExp</tt>. In
--   particular, methods in `class BackendSchema` and `type
--   MonadBuildSchema` should *NOT* include this class as a constraint.
class AggregationPredicatesSchema (b :: BackendType)
aggregationPredicatesParser :: forall r m n. (AggregationPredicatesSchema b, MonadBuildSourceSchema b r m n) => TableInfo b -> SchemaT r m (Maybe (InputFieldsParser n [AggregationPredicates b (UnpreparedValue b)]))

-- | <pre>
--   input type_bool_exp {
--     _or: [type_bool_exp!]
--     _and: [type_bool_exp!]
--     _not: type_bool_exp
--     column: type_comparison_exp
--     ...
--   }
--   </pre>
--   
--   | Boolean expression for logical models
logicalModelBoolExp :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => LogicalModelInfo b -> SchemaT r m (Parser 'Input n (AnnBoolExp b (UnpreparedValue b)))

-- | <pre>
--   input type_bool_exp {
--     _or: [type_bool_exp!]
--     _and: [type_bool_exp!]
--     _not: type_bool_exp
--     column: type_comparison_exp
--     ...
--   }
--   </pre>
--   
--   | Booleans expressions for tables
tableBoolExp :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => TableInfo b -> SchemaT r m (Parser 'Input n (AnnBoolExp b (UnpreparedValue b)))
mkBoolOperator :: (MonadParse n, 'Input <: k) => NamingCase -> DangerouslyCollapseBooleans -> GQLNameIdentifier -> Maybe Description -> Parser k n a -> InputFieldsParser n (Maybe a)
equalityOperators :: (MonadParse n, 'Input <: k) => NamingCase -> DangerouslyCollapseBooleans -> Parser k n (UnpreparedValue b) -> Parser k n (UnpreparedValue b) -> [InputFieldsParser n (Maybe (OpExpG b (UnpreparedValue b)))]
comparisonOperators :: (MonadParse n, 'Input <: k) => NamingCase -> DangerouslyCollapseBooleans -> Parser k n (UnpreparedValue b) -> [InputFieldsParser n (Maybe (OpExpG b (UnpreparedValue b)))]
instance (Hasura.RQL.Types.Backend.AggregationPredicates b GHC.Types.~ Data.Functor.Const.Const Data.Void.Void) => Hasura.GraphQL.Schema.BoolExp.AggregationPredicatesSchema b


-- | Generate table selection schema both for ordinary Hasura-type and
--   relay-type queries. All schema with "relay" or "connection" in the
--   name is used exclusively by relay.
module Hasura.GraphQL.Schema.Select

-- | Simple table selection.
--   
--   The field for the table accepts table selection arguments, and expects
--   a selection of fields
--   
--   <pre>
--   table_name(limit: 10) {
--     col1: col1_type
--     col2: col2_type
--   }: [table!]!
--   </pre>
defaultSelectTable :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (SelectExp b)))

-- | Simple table connection selection.
--   
--   The field for the table accepts table connection selection argument,
--   and expects a selection of connection fields
--   
--   <pre>
--   table_name_connection(first: 1) {
--     pageInfo: {
--       hasNextPage: Boolean!
--       endCursor: String!
--     }
--     edges: {
--       cursor: String!
--       node: {
--         id: ID!
--         col1: col1_type
--         col2: col2_type
--       }
--     }
--   }: table_nameConnection!
--   </pre>
selectTableConnection :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b, AggregationPredicatesSchema b) => TableInfo b -> Name -> Maybe Description -> PrimaryKeyColumns b -> SchemaT r m (Maybe (FieldParser n (ConnectionSelectExp b)))

-- | Table selection by primary key.
--   
--   <pre>
--   table_name(id: 42) {
--     col1: col1_type
--     col2: col2_type
--   }: table
--   </pre>
--   
--   Returns Nothing if there's nothing that can be selected with current
--   permissions or if there are primary keys the user doesn't have select
--   permissions for.
selectTableByPk :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (SelectExp b)))

-- | Table aggregation selection
--   
--   Parser for an aggregation selection of a table. &gt;
--   table_aggregate(limit: 10) { &gt; aggregate: table_aggregate_fields
--   &gt; group_by(...): table_group_by &gt; nodes: [table!]! &gt; } ::
--   table_aggregate!
--   
--   Returns Nothing if there's nothing that can be selected with current
--   permissions.
defaultSelectTableAggregate :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AggSelectExp b)))

-- | Fields of a table
--   
--   <pre>
--   type table{
--     # table columns
--     column_1: column1_type
--     .
--     column_n: columnn_type
--   
--     # table relationships
--     object_relationship: remote_table
--     array_relationship: [remote_table!]!
--   
--     # computed fields
--     computed_field: field_type
--   
--     # remote relationships
--     remote_field: field_type
--   }
--   </pre>
defaultTableSelectionSet :: forall b r m n. (AggregationPredicatesSchema b, BackendTableSelectSchema b, BackendNativeQuerySelectSchema b, Eq (AnnBoolExp b (UnpreparedValue b)), MonadBuildSchema b r m n) => TableInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))

-- | List of table fields object. Just a <tt><a>nonNullableObjectList</a>
--   wrapper over </tt><a>tableSelectionSet</a>. &gt; table_name: [table!]!
tableSelectionList :: (MonadBuildSchema b r m n, BackendTableSelectSchema b) => TableInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))

-- | Connection fields of a table
--   
--   <pre>
--   type tableConnection{
--     pageInfo: PageInfo!
--     edges: [tableEdge!]!
--   }
--   </pre>
--   
--   <pre>
--   type PageInfo{
--     startCursor: String!
--     endCursor: String!
--     hasNextPage: Boolean!
--     hasPreviousPage: Boolean!
--   }
--   </pre>
--   
--   <pre>
--   type tableEdge{
--     cursor: String!
--     node: table!
--   }
--   </pre>
tableConnectionSelectionSet :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b) => TableInfo b -> SchemaT r m (Maybe (Parser 'Output n (ConnectionFields b)))

-- | Arguments for a table selection. Default implementation for
--   BackendSchema.
--   
--   <pre>
--   distinct_on: [table_select_column!]
--   limit: Int
--   offset: Int
--   order_by: [table_order_by!]
--   where: table_bool_exp
--   </pre>
defaultTableArgs :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => TableInfo b -> SchemaT r m (InputFieldsParser n (SelectArgs b))

-- | Argument to filter rows returned from table selection &gt; where:
--   table_bool_exp
tableWhereArg :: forall b r m n. (AggregationPredicatesSchema b, MonadBuildSchema b r m n) => TableInfo b -> SchemaT r m (InputFieldsParser n (Maybe (AnnBoolExp b (UnpreparedValue b))))

-- | Argument to sort rows returned from table selection &gt; order_by:
--   [table_order_by!]
tableOrderByArg :: forall b r m n. MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (InputFieldsParser n (Maybe (NonEmpty (AnnotatedOrderByItemG b (UnpreparedValue b)))))

-- | Argument to distinct select on columns returned from table selection
--   &gt; distinct_on: [table_select_column!]
tableDistinctArg :: forall b r m n. MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (InputFieldsParser n (Maybe (NonEmpty (AnnDistinctColumn b (UnpreparedValue b)))))

-- | Argument to limit rows returned from table selection &gt; limit:
--   NonNegativeInt
tableLimitArg :: forall n. MonadParse n => InputFieldsParser n (Maybe Int)

-- | Argument to skip some rows, in conjunction with order_by &gt; offset:
--   BigInt
tableOffsetArg :: forall n. MonadParse n => InputFieldsParser n (Maybe Int64)

-- | Arguments for a table connection selection
--   
--   <pre>
--   distinct_on: [table_select_column!]
--   order_by: [table_order_by!]
--   where: table_bool_exp
--   first: Int
--   last: Int
--   before: String
--   after: String
--   </pre>
tableConnectionArgs :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => PrimaryKeyColumns b -> TableInfo b -> SelPermInfo b -> SchemaT r m (InputFieldsParser n (SelectArgs b, Maybe (NonEmpty (ConnectionSplit b (UnpreparedValue b))), Maybe ConnectionSlice))

-- | Aggregation fields
--   
--   <pre>
--   type table_aggregate_fields{
--     count(distinct: Boolean, columns: [table_select_column!]): Int!
--     sum: table_sum_fields
--     avg: table_avg_fields
--     stddev: table_stddev_fields
--     stddev_pop: table_stddev_pop_fields
--     variance: table_variance_fields
--     var_pop: table_var_pop_fields
--     max: table_max_fields
--     min: table_min_fields
--   }
--   </pre>
tableAggregationFields :: forall b r m n. MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Parser 'Output n (AggregateFields b (UnpreparedValue b)))

-- | shared implementation between tables and logical models
defaultArgsParser :: forall b r m n. MonadBuildSchema b r m n => InputFieldsParser n (Maybe (AnnBoolExp b (UnpreparedValue b))) -> InputFieldsParser n (Maybe (NonEmpty (AnnotatedOrderByItemG b (UnpreparedValue b)))) -> InputFieldsParser n (Maybe (NonEmpty (AnnDistinctColumn b (UnpreparedValue b)))) -> SchemaT r m (InputFieldsParser n (SelectArgs b))


-- | Schema parsers for logical models
module Hasura.LogicalModel.Schema

-- | turn post-schema cache LogicalModelInfo into IR
buildLogicalModelIR :: LogicalModelInfo b -> LogicalModel b

-- | top-level select permissions for a logical model
buildLogicalModelPermissions :: forall b r m n. MonadBuildSchema b r m n => LogicalModelInfo b -> SchemaT r m (Maybe (TablePermG b (UnpreparedValue b)))
logicalModelFieldParsers :: forall b r m n. MonadBuildSchema b r m n => Set RelName -> LogicalModelInfo b -> SchemaT r m [FieldParser MetadataObjId n (AnnotatedField b)]
defaultLogicalModelSelectionSet :: forall b r m n. MonadBuildSchema b r m n => LogicalModelInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))
logicalModelSelectionList :: (MonadBuildSchema b r m n, BackendLogicalModelSelectSchema b) => Nullable -> LogicalModelInfo b -> SchemaT r m (Maybe (Parser 'Output n (AnnotatedFields b)))

-- | Argument to filter rows returned from table selection &gt; where:
--   table_bool_exp
logicalModelWhereArg :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => LogicalModelInfo b -> SchemaT r m (InputFieldsParser n (Maybe (AnnBoolExp b (UnpreparedValue b))))

-- | Argument to sort rows returned from table selection &gt; order_by:
--   [table_order_by!]
logicalModelOrderByArg :: forall b r m n. MonadBuildSchema b r m n => LogicalModelInfo b -> SchemaT r m (InputFieldsParser n (Maybe (NonEmpty (AnnotatedOrderByItemG b (UnpreparedValue b)))))
defaultLogicalModelArgs :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => LogicalModelInfo b -> SchemaT r m (InputFieldsParser n (SelectArgs b))


-- | Schema parsers for stored procedures.
module Hasura.StoredProcedure.Schema
defaultBuildStoredProcedureRootFields :: forall b r m n. (MonadBuildSchema b r m n, BackendLogicalModelSelectSchema b) => StoredProcedureInfo b -> SchemaT r m (Maybe (FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))


-- | Schema parsers for native queries.
module Hasura.NativeQuery.Schema
defaultSelectNativeQueryObject :: forall b r m n. (MonadBuildSchema b r m n, BackendNativeQuerySelectSchema b, BackendTableSelectSchema b) => NativeQueryInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnObjectSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | select a native query - implementation is the same for root fields and
--   array relationships
defaultSelectNativeQuery :: forall b r m n. (MonadBuildSchema b r m n, BackendNativeQuerySelectSchema b, BackendTableSelectSchema b) => NativeQueryInfo b -> Name -> Nullable -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnSimpleSelectG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
defaultBuildNativeQueryRootFields :: forall b r m n. (MonadBuildSchema b r m n, BackendNativeQuerySelectSchema b, BackendTableSelectSchema b) => NativeQueryInfo b -> SchemaT r m (Maybe (FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))


-- | Generate the GraphQL schema types related to streaming subscriptions.
module Hasura.GraphQL.Schema.SubscriptionStream

-- | Field parser for a streaming subscription for a table.
selectStreamTable :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (StreamSelectExp b)))

module Hasura.GraphQL.Schema.Mutation

-- | Construct the parser for a field that can be used to add several rows
--   to a DB table.
--   
--   This function is used to create the insert_tablename root field. The
--   field accepts the following arguments: - objects: the list of objects
--   to insert into the table (see <a>tableFieldsInput</a>) - parser for
--   backend-specific fields, e.g. upsert fields on_conflict or if_matched
insertIntoTable :: forall b r m n. MonadBuildSchema b r m n => BackendTableSelectSchema b => (TableInfo b -> SchemaT r m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> Scenario -> TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Variant of <a>insertIntoTable</a> that inserts a single row.
--   
--   Instead of expecting a list of rows to insert in a <tt>objects</tt>
--   argument, this field instead expects a single <tt>object</tt>. Its
--   selection set is also slightly different: it only allows selecting
--   columns from the row being inserted.
insertOneIntoTable :: forall b r m n. MonadBuildSchema b r m n => BackendTableSelectSchema b => (TableInfo b -> SchemaT r m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> Scenario -> TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
mkDefaultRelationshipParser :: forall b r m n. MonadBuildSchema b r m n => (TableInfo b -> SchemaT r m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> XNestedInserts b -> RelInfo b -> SchemaT r m (Maybe (InputFieldsParser n (Maybe (AnnotatedInsertField b (UnpreparedValue b)))))

-- | Construct a root field, normally called delete_tablename, that can be
--   used to delete several rows from a DB table
deleteFromTable :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => Scenario -> TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Construct a root field, normally called delete_tablename_by_pk, that
--   can be used to delete an individual rows from a DB table, specified by
--   primary key. Select permissions are required, as the user must be
--   allowed to access all the primary keys of the table.
deleteFromTableByPk :: forall b r m n. MonadBuildSchema b r m n => BackendTableSelectSchema b => Scenario -> TableInfo b -> Name -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | All mutations allow returning results, such as what the updated
--   database rows look like. This parser allows a query to specify what
--   data to fetch.
mutationSelectionSet :: forall b r m n. MonadBuildSchema b r m n => BackendTableSelectSchema b => TableInfo b -> SchemaT r m (Parser 'Output n (MutFldsG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b)))

-- | How to specify a database row by primary key.
--   
--   This will give <tt>Nothing</tt> when either there are no primary keys
--   defined for the table or when the given permissions do not permit
--   selecting from all the columns that make up the key.
primaryKeysArguments :: forall b r m n. MonadBuildSchema b r m n => TableInfo b -> SchemaT r m (Maybe (InputFieldsParser n (AnnBoolExp b (UnpreparedValue b))))

module Hasura.GraphQL.Schema.Update.Batch

-- | Construct a root field, normally called update_tablename, that can be
--   used to update rows in a DB table specified by filters. Only returns a
--   parser if there are columns the user is allowed to update; otherwise
--   returns Nothing.
updateTable :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b, BackendUpdateOperatorsSchema b) => (UpdateBatch b (UpdateOperators b) (UnpreparedValue b) -> UpdateVariant b (UnpreparedValue b)) -> Scenario -> TableInfo b -> GQLNameIdentifier -> SchemaT r m (Maybe (FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))
updateTableMany :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b, BackendUpdateOperatorsSchema b) => ([UpdateBatch b (UpdateOperators b) (UnpreparedValue b)] -> UpdateVariant b (UnpreparedValue b)) -> Scenario -> TableInfo b -> GQLNameIdentifier -> SchemaT r m (Maybe (FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))

-- | Construct a root field, normally called
--   <tt>update_tablename_by_pk</tt>, that can be used to update a single
--   in a DB table, specified by primary key. Only returns a parser if
--   there are columns the user is allowed to update and if the user has
--   select permissions on all primary keys; otherwise returns Nothing.
updateTableByPk :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b, BackendUpdateOperatorsSchema b) => (UpdateBatch b (UpdateOperators b) (UnpreparedValue b) -> UpdateVariant b (UnpreparedValue b)) -> Scenario -> TableInfo b -> GQLNameIdentifier -> SchemaT r m (Maybe (FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))))


-- | This module provides building blocks for the GraphQL Schema that the
--   GraphQL Engine presents.
--   
--   The functions defined here are used to serve as default
--   implementations for their namesakes in the <tt>BackendSchema</tt> type
--   class.
--   
--   When, for some backend, you want to implement a new feature that
--   manifests itself visibly in the schema (e.g., if you're developing
--   support for update mutations), this module is likely where your
--   efforts should start.
--   
--   Using these functions help us present a consistent GraphQL schema
--   across different backends.
--   
--   There is a bit of tension however, as sometimes we intentionally do
--   want the GraphQL Schema relating to some backend to be different in
--   some way.
--   
--   It could be that a backend only has limited support for some common
--   feature, or, more interestingly, that some backend just does things
--   differently (c.f. MSSQL's <tt>MERGE</tt> statement with PostgreSQL's
--   <tt>INSERT .. ON CONFLICT</tt>, which are similar enough that we want
--   to use the same overall upsert schema but different enough that we
--   want to use different field names)
--   
--   When you want to implement new schema for a backend, there is overall
--   three different ways do deal with this tension:
--   
--   <ol>
--   <li>You can duplicate existing code and implement the new behavior in
--   the duplicate.</li>
--   <li>You can infuse the new behavior into existing code and switch
--   dynamically at runtime (or via type class instance dispatch, which is
--   the same for our purposes)</li>
--   <li>You can refactor the existing building blocks and compose them
--   differently at use sites to get the desired behavior nuances.</li>
--   </ol>
--   
--   Of these three, steps 1. and 2. are by far the easiest to execute,
--   while 3. requires some critical thought. However, both 1. and 2.
--   produce legacy code that is difficult to maintain and understand.
--   
--   As a guideline, if you find yourself wanting add new behavior to some
--   of these functions it's very likely that you should consider
--   refactoring them instead, thus shifting the responsibility deciding on
--   the correct behavior to use sites.
--   
--   It an ongoing effort to adapt and refactor these building blocks such
--   that they have the sizes and shapes that result in the most elegant
--   uses of them that we can manage.
module Hasura.GraphQL.Schema.Build

-- | buildTableQueryAndSubscriptionFields builds the field parsers of a
--   table. It returns a tuple with array of field parsers that correspond
--   to the field parsers of the query root and the field parsers of the
--   subscription root
buildTableQueryAndSubscriptionFields :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => MkRootFieldName -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m ([FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))], Maybe (Name, Parser 'Output n (ApolloFederationParserFunction n)))
buildTableStreamingSubscriptionFields :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => MkRootFieldName -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableInsertMutationFields :: forall b r m n. (MonadBuildSchema b r m n, BackendTableSelectSchema b) => (TableInfo b -> SchemaT r m (InputFieldsParser n (BackendInsert b (UnpreparedValue b)))) -> MkRootFieldName -> Scenario -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnotatedInsert b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]

-- | This function implements the parsers for the basic, single batch,
--   update mutations. It implements the mutation schema in the general
--   shape described in
--   <tt><a>https://hasura.io/docs/latest/graphql/core/databases/postgres/mutations/update.html</a></tt>.
--   (ie. update_<a>table</a> and update_<a>table</a>_by_pk root fields)
--   
--   Different backends can have different update types (single batch,
--   multiple batches, etc), and so the parsed UpdateBatch needs to be
--   embedded in the custom UpdateVariant defined by the backend, which is
--   done by passing a function to this function.
buildSingleBatchTableUpdateMutationFields :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b, BackendUpdateOperatorsSchema b) => (UpdateBatch b (UpdateOperators b) (UnpreparedValue b) -> UpdateVariant b (UnpreparedValue b)) -> Scenario -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnotatedUpdateG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildTableDeleteMutationFields :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b, BackendTableSelectSchema b) => MkRootFieldName -> Scenario -> TableName b -> TableInfo b -> GQLNameIdentifier -> SchemaT r m [FieldParser n (AnnDelG b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b))]
buildFieldDescription :: Text -> Comment -> Maybe Description


-- | This module defines the schema aspect of the default implementation of
--   aggregation predicates.
module Hasura.GraphQL.Schema.BoolExp.AggregationPredicates

-- | This function is meant to serve as the default schema for Aggregation
--   Predicates represented in the IR by the type
--   <a>AggregationPredicates</a>.
defaultAggregationPredicatesParser :: forall b r m n. (MonadBuildSchema b r m n, AggregationPredicatesSchema b) => [FunctionSignature b] -> TableInfo b -> SchemaT r m (Maybe (InputFieldsParser n [AggregationPredicatesImplementation b (UnpreparedValue b)]))
data FunctionSignature (b :: BackendType)
FunctionSignature :: Text -> Name -> ArgumentsSignature b -> ScalarType b -> FunctionSignature (b :: BackendType)
[fnName] :: FunctionSignature (b :: BackendType) -> Text
[fnGQLName] :: FunctionSignature (b :: BackendType) -> Name
[fnArguments] :: FunctionSignature (b :: BackendType) -> ArgumentsSignature b
[fnReturnType] :: FunctionSignature (b :: BackendType) -> ScalarType b
data ArgumentsSignature (b :: BackendType)
ArgumentsStar :: ArgumentsSignature (b :: BackendType)
SingleArgument :: ScalarType b -> ArgumentsSignature (b :: BackendType)
Arguments :: NonEmpty (ArgumentSignature b) -> ArgumentsSignature (b :: BackendType)
data ArgumentSignature (b :: BackendType)
ArgumentSignature :: ScalarType b -> Name -> ArgumentSignature (b :: BackendType)
[argType] :: ArgumentSignature (b :: BackendType) -> ScalarType b
[argName] :: ArgumentSignature (b :: BackendType) -> Name

module Hasura.Backends.DataConnector.Adapter.Schema
instance Hasura.GraphQL.Schema.Backend.BackendSchema 'Hasura.RQL.Types.BackendType.DataConnector
instance Hasura.GraphQL.Schema.Backend.BackendLogicalModelSelectSchema 'Hasura.RQL.Types.BackendType.DataConnector
instance Hasura.GraphQL.Schema.Backend.BackendNativeQuerySelectSchema 'Hasura.RQL.Types.BackendType.DataConnector
instance Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema 'Hasura.RQL.Types.BackendType.DataConnector
instance Hasura.GraphQL.Schema.Backend.BackendUpdateOperatorsSchema 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.Backends.Postgres.Schema.Select

-- | User-defined function (AKA custom function)
selectFunction :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> FunctionInfo ('Postgres pgKind) -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (SelectExp ('Postgres pgKind))))
selectFunctionAggregate :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> FunctionInfo ('Postgres pgKind) -> Maybe Description -> SchemaT r m (Maybe (FieldParser n (AggSelectExp ('Postgres pgKind))))
selectFunctionConnection :: forall pgKind r m n. (MonadBuildSchema ('Postgres pgKind) r m n, AggregationPredicatesSchema ('Postgres pgKind), BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> FunctionInfo ('Postgres pgKind) -> Maybe Description -> PrimaryKeyColumns ('Postgres pgKind) -> SchemaT r m (Maybe (FieldParser n (ConnectionSelectExp ('Postgres pgKind))))

-- | Computed field parser
computedFieldPG :: forall pgKind r m n. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => ComputedFieldInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> TableInfo ('Postgres pgKind) -> SchemaT r m (Maybe (FieldParser n (AnnotatedField ('Postgres pgKind))))
buildFunctionQueryFieldsPG :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> FunctionName ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> SchemaT r m [FieldParser n (QueryDB ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))]
buildFunctionMutationFieldsPG :: forall r m n pgKind. (MonadBuildSchema ('Postgres pgKind) r m n, BackendTableSelectSchema ('Postgres pgKind)) => MkRootFieldName -> FunctionName ('Postgres pgKind) -> FunctionInfo ('Postgres pgKind) -> TableName ('Postgres pgKind) -> SchemaT r m [FieldParser n (MutationDB ('Postgres pgKind) (RemoteRelationshipField UnpreparedValue) (UnpreparedValue ('Postgres pgKind)))]


-- | Postgres Schema OnConflict
--   
--   This module contains the building blocks for parsing
--   <tt>on_conflict</tt> clauses, which in the Postgres backend are used
--   to implement upsert functionality. These are used by
--   <a>backendInsertParser</a> to construct a postgres-specific schema
--   parser for insert (and upsert) mutations.
module Hasura.Backends.Postgres.Schema.OnConflict

-- | Parser for a field name <tt>on_conflict</tt> of type
--   <tt>tablename_on_conflict</tt>.
--   
--   The <tt>tablename_on_conflict</tt> object is used to generate the
--   <tt>ON CONFLICT</tt> SQL clause, indicating what should be done if an
--   insert raises a conflict.
--   
--   The types ordinarily produced by this parser are only created if the
--   table has unique or primary keys constraints.
--   
--   If there are no columns for which the current role has update
--   permissions, we must still accept an empty list for
--   <tt>update_columns</tt> to support the "ON CONFLICT DO NOTHING" case.
--   We do this by adding a placeholder value to the enum. See
--   <a>https://github.com/hasura/graphql-engine/issues/6804</a>.
onConflictFieldParser :: forall pgKind r m n. (MonadBuildSchema ('Postgres pgKind) r m n, AggregationPredicatesSchema ('Postgres pgKind)) => TableInfo ('Postgres pgKind) -> SchemaT r m (InputFieldsParser n (Maybe (OnConflictClause ('Postgres pgKind) (UnpreparedValue ('Postgres pgKind)))))


-- | Postgres DDL Function
--   
--   This module describes building information about Postgres functions by
--   validating the passed raw information.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.Function
mkFunctionArgs :: Int -> [QualifiedPGType] -> [FunctionArgName] -> [FunctionArg]
buildFunctionInfo :: forall pgKind m. (Backend ('Postgres pgKind), QErrM m) => SourceName -> QualifiedFunction -> SystemDefined -> FunctionConfig ('Postgres pgKind) -> FunctionPermissionsMap -> RawFunctionInfo ('Postgres pgKind) -> Maybe Text -> NamingCase -> m (FunctionInfo ('Postgres pgKind), SchemaDependency)
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.Function.FunctionIntegrityError
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.Function.FunctionIntegrityError


-- | Postgres DDL ComputedField
--   
--   How to build the <a>ComputedFieldInfo</a> for a field.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.ComputedField
buildComputedFieldInfo :: forall pgKind m. QErrM m => HashSet QualifiedTable -> QualifiedTable -> HashSet PGCol -> ComputedFieldName -> ComputedFieldDefinition -> PGRawFunctionInfo -> Comment -> m (ComputedFieldInfo ('Postgres pgKind))
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.ComputedField.InvalidTableArgument
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.ComputedField.InvalidTableArgument
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.ComputedField.InvalidSessionArgument
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.ComputedField.InvalidSessionArgument
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.ComputedField.ComputedFieldValidateError
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.ComputedField.ComputedFieldValidateError


-- | Postgres DDL BoolExp
--   
--   How to parse the boolean expressions, specifically for Postgres.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.BoolExp
parseBoolExpOperations :: forall pgKind m v. (Backend ('Postgres pgKind), MonadError QErr m) => ValueParser ('Postgres pgKind) m v -> FieldInfoMap (FieldInfo ('Postgres pgKind)) -> FieldInfoMap (FieldInfo ('Postgres pgKind)) -> ColumnReference ('Postgres pgKind) -> Value -> m [OpExpG ('Postgres pgKind) v]
buildComputedFieldBooleanExp :: forall pgKind m v. (MonadError QErr m, Backend ('Postgres pgKind), TableCoreInfoRM ('Postgres pgKind) m) => BoolExpResolver ('Postgres pgKind) m v -> BoolExpRHSParser ('Postgres pgKind) m v -> FieldInfoMap (FieldInfo ('Postgres pgKind)) -> FieldInfoMap (FieldInfo ('Postgres pgKind)) -> ComputedFieldInfo ('Postgres pgKind) -> Value -> m (AnnComputedFieldBoolExp ('Postgres pgKind) v)


-- | MSSQL Schema IfMatched
--   
--   This module contains the building blocks for parsing
--   <tt>if_matched</tt> clauses (represented as <a>IfMatched</a>), which
--   in the MSSQL backend are used to implement upsert functionality.
--   
--   These are used by <a>backendInsertParser</a> to construct a
--   mssql-specific schema parser for insert (and upsert) mutations.
module Hasura.Backends.MSSQL.Schema.IfMatched

-- | Field-parser for:
--   
--   <pre>
--   if_matched: tablename_if_matched
--   
--   input tablename_if_matched {
--     match_columns: [tablename_select_column!]
--     update_columns: [tablename_update_columns!]
--     where: tablename_bool_exp
--   }
--   </pre>
--   
--   Note that the types ordinarily produced by this parser are only
--   created if the active role has <i>both</i> select and update
--   permissions to the table <tt>tablename</tt> defined <i>and</i> these
--   grant non-empty column permissions.
ifMatchedFieldParser :: forall r m n. (MonadBuildSchema 'MSSQL r m n, AggregationPredicatesSchema 'MSSQL) => TableInfo 'MSSQL -> SchemaT r m (InputFieldsParser n (Maybe (IfMatched (UnpreparedValue 'MSSQL))))


-- | MSSQL Instances Schema
--   
--   Defines a <a>BackendSchema</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.Schema
instance Hasura.GraphQL.Schema.Backend.BackendSchema 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.GraphQL.Schema.Backend.BackendLogicalModelSelectSchema 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.GraphQL.Schema.Backend.BackendNativeQuerySelectSchema 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.GraphQL.Schema.Backend.BackendUpdateOperatorsSchema 'Hasura.RQL.Types.BackendType.MSSQL


-- | MSSQL DDL BoolExp
--   
--   How to parse the boolean expressions and operations relevant for
--   MSSQL.
module Hasura.Backends.MSSQL.DDL.BoolExp
parseBoolExpOperations :: forall m v. MonadError QErr m => ValueParser 'MSSQL m v -> FieldInfoMap (FieldInfo 'MSSQL) -> FieldInfoMap (FieldInfo 'MSSQL) -> ColumnReference 'MSSQL -> Value -> m [OpExpG 'MSSQL v]

module Hasura.Backends.BigQuery.DDL.BoolExp
parseBoolExpOperations :: forall m v. MonadError QErr m => ValueParser 'BigQuery m v -> FieldInfoMap (FieldInfo 'BigQuery) -> FieldInfoMap (FieldInfo 'BigQuery) -> ColumnReference 'BigQuery -> Value -> m [OpExpG 'BigQuery v]

module Hasura.Backends.BigQuery.DDL
fetchAndValidateEnumValues :: Monad m => SourceConfig 'BigQuery -> TableName 'BigQuery -> Maybe (PrimaryKey 'BigQuery (RawColumnInfo 'BigQuery)) -> [RawColumnInfo 'BigQuery] -> m (Either QErr EnumValues)
buildFunctionInfo :: MonadError QErr m => SourceName -> FunctionName 'BigQuery -> SystemDefined -> FunctionConfig 'BigQuery -> FunctionPermissionsMap -> RawFunctionInfo 'BigQuery -> Maybe Text -> NamingCase -> m (FunctionInfo 'BigQuery, SchemaDependency)
updateColumnInEventTrigger :: TableName 'BigQuery -> Column 'BigQuery -> Column 'BigQuery -> TableName 'BigQuery -> EventTriggerConf 'BigQuery -> EventTriggerConf 'BigQuery
parseCollectableType :: MonadError QErr m => CollectableType (ColumnType 'BigQuery) -> Value -> m (PartialSQLExp 'BigQuery)
scalarTypeFromColumnType :: ColumnType 'BigQuery -> ScalarType


-- | Planning T-SQL queries and subscriptions.
module Hasura.Backends.BigQuery.Plan
planNoPlan :: MonadError QErr m => FromIrConfig -> UserInfo -> QueryDB 'BigQuery Void (UnpreparedValue 'BigQuery) -> m Select

module Hasura.Backends.BigQuery.Instances.Schema
instance Hasura.GraphQL.Schema.Backend.BackendSchema 'Hasura.RQL.Types.BackendType.BigQuery
instance Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema 'Hasura.RQL.Types.BackendType.BigQuery
instance Hasura.GraphQL.Schema.Backend.BackendNativeQuerySelectSchema 'Hasura.RQL.Types.BackendType.BigQuery
instance Hasura.GraphQL.Schema.Backend.BackendLogicalModelSelectSchema 'Hasura.RQL.Types.BackendType.BigQuery

module Hasura.RQL.Types.Metadata.Backend
class (Backend b, Eq (AggregationPredicates b (PartialSQLExp b)), Eq (BooleanOperators b (PartialSQLExp b)), Eq (FunctionArgumentExp b (PartialSQLExp b)), Ord (BackendInvalidationKeys b), Hashable (AggregationPredicates b (PartialSQLExp b)), Hashable (BooleanOperators b (PartialSQLExp b)), Hashable (FunctionArgumentExp b (PartialSQLExp b)), Monoid (BackendInvalidationKeys b)) => BackendMetadata (b :: BackendType) where {
    type BackendInvalidationKeys b;
    type BackendInvalidationKeys b = ();
}
buildComputedFieldInfo :: (BackendMetadata b, MonadError QErr m) => HashSet (TableName b) -> TableName b -> HashSet (Column b) -> ComputedFieldName -> ComputedFieldDefinition b -> RawFunctionInfo b -> Comment -> m (ComputedFieldInfo b)
fetchAndValidateEnumValues :: (BackendMetadata b, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> TableName b -> Maybe (PrimaryKey b (RawColumnInfo b)) -> [RawColumnInfo b] -> m (Either QErr EnumValues)
resolveBackendInfo :: (BackendMetadata b, ArrowChoice arr, ArrowCache m arr, ArrowDistribute arr, ArrowWriter (Seq CollectItem) arr, MonadIO m, MonadBaseControl IO m, ProvidesNetwork m) => Logger Hasura -> (Dependency (Maybe (BackendInvalidationKeys b)), BackendConfig b) `arr` BackendInfo b
resolveBackendInfo :: (BackendMetadata b, Arrow arr, BackendInfo b ~ ()) => Logger Hasura -> (Dependency (Maybe (BackendInvalidationKeys b)), BackendConfig b) `arr` BackendInfo b

-- | Function that resolves the connection related source configuration,
--   and creates a connection pool (and other related parameters) in the
--   process
resolveSourceConfig :: (BackendMetadata b, MonadIO m, MonadBaseControl IO m, MonadResolveSource m) => SourceName -> SourceConnConfiguration b -> BackendSourceKind b -> BackendInfo b -> Environment -> Manager -> m (Either QErr (SourceConfig b))

-- | Function that introspects a database for tables, columns, functions
--   etc.
resolveDatabaseMetadata :: (BackendMetadata b, MonadIO m, MonadBaseControl IO m, MonadResolveSource m) => Logger Hasura -> SourceMetadata b -> SourceConfig b -> m (Either QErr (DBObjectsIntrospection b))
parseBoolExpOperations :: (BackendMetadata b, MonadError QErr m) => ValueParser b m v -> FieldInfoMap (FieldInfo b) -> FieldInfoMap (FieldInfo b) -> ColumnReference b -> Value -> m [OpExpG b v]
buildObjectRelationshipInfo :: (BackendMetadata b, MonadError QErr m) => SourceConfig b -> SourceName -> HashMap (TableName b) (HashSet (ForeignKey b)) -> TableName b -> ObjRelDef b -> m (RelInfo b, Seq SchemaDependency)
buildArrayRelationshipInfo :: (BackendMetadata b, MonadError QErr m) => SourceConfig b -> SourceName -> HashMap (TableName b) (HashSet (ForeignKey b)) -> TableName b -> ArrRelDef b -> m (RelInfo b, Seq SchemaDependency)
buildFunctionInfo :: (BackendMetadata b, MonadError QErr m) => SourceName -> FunctionName b -> SystemDefined -> FunctionConfig b -> FunctionPermissionsMap -> RawFunctionInfo b -> Maybe Text -> NamingCase -> m (FunctionInfo b, SchemaDependency)
updateColumnInEventTrigger :: BackendMetadata b => TableName b -> Column b -> Column b -> TableName b -> EventTriggerConf b -> EventTriggerConf b
parseCollectableType :: (BackendMetadata b, MonadError QErr m, MonadReader r m, Has (ScalarTypeParsingContext b) r) => CollectableType (ColumnType b) -> Value -> m (PartialSQLExp b)
postDropSourceHook :: (BackendMetadata b, MonadError QErr m, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> TableEventTriggers b -> m ()
validateRelationship :: (BackendMetadata b, MonadError QErr m) => TableCache b -> TableName b -> Either (ObjRelDef b) (ArrRelDef b) -> m ()
validateRelationship :: (BackendMetadata b, MonadError QErr m) => TableCache b -> TableName b -> Either (ObjRelDef b) (ArrRelDef b) -> m ()

-- | Function that that builds a boolean expression field out of a computed
--   field
buildComputedFieldBooleanExp :: (BackendMetadata b, MonadError QErr m, TableCoreInfoRM b m) => BoolExpResolver b m v -> BoolExpRHSParser b m v -> FieldInfoMap (FieldInfo b) -> FieldInfoMap (FieldInfo b) -> ComputedFieldInfo b -> Value -> m (AnnComputedFieldBoolExp b v)

-- | Run all operations required to create, update, or migrate the internal
--   catalog used by the backend for internal bookkeeping, if any. The
--   return type indicates whether the performed operations subsequently
--   require re-creating event trigers.
prepareCatalog :: (BackendMetadata b, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> ExceptT QErr m (RecreateEventTriggers, SourceCatalogMigrationState)

-- | List all the tables on a given data source, including those not
--   tracked by Hasura. Primarily useful for user interfaces to allow
--   untracked tables to be tracked.
listAllTables :: (BackendMetadata b, CacheRM m, MonadBaseControl IO m, MetadataM m, MonadError QErr m, MonadIO m, MonadReader r m, Has (Logger Hasura) r, ProvidesNetwork m) => SourceName -> m [TableName b]

-- | List all the functions on a given data source, including those not
--   tracked by Hasura. Primarily useful for user interfaces to allow
--   untracked functions to be tracked.
listAllTrackables :: (BackendMetadata b, CacheRM m, MonadBaseControl IO m, MetadataM m, MonadError QErr m, MonadIO m, MonadReader r m, Has (Logger Hasura) r, ProvidesNetwork m) => SourceName -> m (TrackableInfo b)

-- | Get information about a given table on a given source, whether tracked
--   or not. Primarily useful for user interfaces.
getTableInfo :: (BackendMetadata b, CacheRM m, MetadataM m, MonadError QErr m, MonadBaseControl IO m, MonadIO m) => SourceName -> TableName b -> m (Maybe (SourceTableInfo b))
validateNativeQuery :: (BackendMetadata b, MonadIO m, MonadError QErr m) => Environment -> SourceName -> SourceConnConfiguration b -> SourceConfig b -> LogicalModelInfo b -> NativeQueryMetadata b -> m (InterpolatedQuery ArgumentName)
validateStoredProcedure :: (BackendMetadata b, MonadIO m, MonadError QErr m) => Environment -> SourceConnConfiguration b -> LogicalModelInfo b -> StoredProcedureMetadata b -> m ()
getStoredProcedureGraphqlName :: (BackendMetadata b, MonadError QErr m) => FunctionName b -> StoredProcedureConfig -> m Name

-- | Allows the backend to control whether or not a particular source
--   supports being the target of remote relationships or not
supportsBeingRemoteRelationshipTarget :: BackendMetadata b => SourceConfig b -> Bool


-- | Define and handle v1/metadata API operations to track, untrack, and
--   get stored procedures.
module Hasura.StoredProcedure.API

-- | Default implementation of the <tt>track_stored_procedure_query</tt>
--   request payload.
data TrackStoredProcedure (b :: BackendType)
TrackStoredProcedure :: SourceName -> FunctionName b -> StoredProcedureConfig -> HashMap ArgumentName (NullableScalarType b) -> Maybe Text -> LogicalModelName -> TrackStoredProcedure (b :: BackendType)
[tspSource] :: TrackStoredProcedure (b :: BackendType) -> SourceName
[tspStoredProcedure] :: TrackStoredProcedure (b :: BackendType) -> FunctionName b
[tspConfig] :: TrackStoredProcedure (b :: BackendType) -> StoredProcedureConfig
[tspArguments] :: TrackStoredProcedure (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[tspDescription] :: TrackStoredProcedure (b :: BackendType) -> Maybe Text
[tspReturns] :: TrackStoredProcedure (b :: BackendType) -> LogicalModelName

-- | API payload for the <tt>get_stored_procedure</tt> endpoint.
data GetStoredProcedure (b :: BackendType)
GetStoredProcedure :: SourceName -> GetStoredProcedure (b :: BackendType)
[gspSource] :: GetStoredProcedure (b :: BackendType) -> SourceName

-- | Handler for the <tt>get_stored_procedure</tt> endpoint.
runGetStoredProcedure :: forall b m. (BackendMetadata b, MetadataM m) => GetStoredProcedure b -> m EncJSON

-- | Handler for the <tt>track_stored_procedure</tt> endpoint. The type
--   'TrackStoredProcedure b' (appearing here in wrapped as
--   'BackendTrackStoredProcedure b' for <tt>AnyBackend</tt> compatibility)
--   is defined in 'class StoredProcedureMetadata'.
execTrackStoredProcedure :: forall b m. (BackendMetadata b, MonadError QErr m) => TrackStoredProcedure b -> Metadata -> m (MetadataObjId, MetadataModifier)

-- | API payload for the <tt>untrack_stored_procedure</tt> endpoint.
data UntrackStoredProcedure (b :: BackendType)
UntrackStoredProcedure :: SourceName -> FunctionName b -> UntrackStoredProcedure (b :: BackendType)
[utspSource] :: UntrackStoredProcedure (b :: BackendType) -> SourceName
[utspStoredProcedure] :: UntrackStoredProcedure (b :: BackendType) -> FunctionName b

-- | Handler for the <tt>untrack_stored_procedure</tt> endpoint.
execUntrackStoredProcedure :: forall b m. (BackendMetadata b, MonadError QErr m) => UntrackStoredProcedure b -> Metadata -> m (MetadataObjId, MetadataModifier)
dropStoredProcedureInMetadata :: forall b. BackendMetadata b => SourceName -> FunctionName b -> MetadataModifier
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.StoredProcedure.API.TrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.API.TrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.StoredProcedure.API.GetStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.StoredProcedure.API.GetStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.StoredProcedure.API.UntrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.StoredProcedure.API.UntrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.StoredProcedure.API.UntrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.API.UntrackStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.StoredProcedure.API.GetStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.StoredProcedure.API.GetStoredProcedure b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.StoredProcedure.API.TrackStoredProcedure b)


-- | This module provides an API for suggesting relationships so that the
--   console (or client) does not need to construct and submit relationship
--   queries itself.
--   
--   This suggests reciprocal object relationships A -&gt; object -&gt; B
--   -&gt; object -&gt; A if there is a unique constraint on the column(s)
--   in A mapping A-&gt;B, and if not then a reciprocal array relationship
--   A -&gt; object -&gt; B -&gt; array -&gt; A is suggested.
--   
--   All JSON fields to the main exported function <a>runSuggestRels</a>
--   are optional and behave as follows:
--   
--   <ul>
--   <li>_srsSource: The source to suggest relationships for - Defaults to
--   <a>defaultSource</a></li>
--   <li>_srsTables: The tables to suggest relationships between - Defaults
--   to all tables</li>
--   <li>_srsOmitTracked: Only suggest untracked relationships - Defaults
--   to False</li>
--   </ul>
--   
--   Autodocodec Codecs instances are implemented for these datatypes.
module Hasura.RQL.DDL.Relationship.Suggest

-- | Datatype used by Metadata API to represent Request for Suggested
--   Relationships
data SuggestRels b

-- | The method invoked when dispatching on metadata calls in POST
--   <i>v1</i>metadata
runSuggestRels :: forall b m. (MonadError QErr m, CacheRWM m, BackendMetadata b) => SuggestRels b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.DDL.Relationship.Suggest.SuggestRels b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Relationship.Suggest.SuggestRels b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.Suggest.SuggestRels b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Relationship.Suggest.SuggestRels b)
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.DDL.Relationship.Suggest.Mapping b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Relationship.Suggest.Mapping b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.Suggest.Mapping b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Relationship.Suggest.Mapping b)
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.DDL.Relationship.Suggest.Relationship b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Relationship.Suggest.Relationship b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.Suggest.Relationship b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Relationship.Suggest.Relationship b)
instance Hasura.RQL.Types.Backend.Backend b => Data.OpenApi.Internal.Schema.ToSchema (Hasura.RQL.DDL.Relationship.Suggest.SuggestedRelationships b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Relationship.Suggest.SuggestedRelationships b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.Suggest.SuggestedRelationships b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Relationship.Suggest.SuggestedRelationships b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.DDL.Relationship.Suggest.SuggestedRelationships b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.DDL.Relationship.Suggest.Relationship b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.DDL.Relationship.Suggest.Mapping b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.RQL.DDL.Relationship.Suggest.SuggestRels b)

module Hasura.RQL.DDL.Permission.Internal

-- | Intrepet a <a>PermColSpec</a> column specification, which can either
--   refer to a list of named columns or all columns.
interpColSpec :: [Column b] -> PermColSpec b -> [Column b]
permissionIsDefined :: PermType -> RolePermInfo backend -> Bool
assertPermDefined :: (Backend backend, MonadError QErr m) => RoleName -> PermType -> TableInfo backend -> m ()
newtype CreatePerm a b
CreatePerm :: WithTable b (PermDef b a) -> CreatePerm a b
procBoolExp :: (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> BoolExp b -> m (AnnBoolExpPartialSQL b, Seq SchemaDependency)

-- | Interpret a <a>BoolExp</a> into an <a>AnnBoolExp</a>, collecting any
--   dependencies as we go. At the moment, the only dependencies we're
--   likely to encounter are independent dependencies on other tables. For
--   example, "this user can only select from this logical model if their
--   ID is in the <tt>allowed_users</tt> table".
procLogicalModelBoolExp :: forall b m r. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => SourceName -> LogicalModelLocation -> FieldInfoMap (FieldInfo b) -> BoolExp b -> m (AnnBoolExpPartialSQL b, Seq SchemaDependency)
annBoolExp :: (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b) => BoolExpRHSParser b m v -> FieldInfoMap (FieldInfo b) -> FieldInfoMap (FieldInfo b) -> GBoolExp b ColExp -> m (AnnBoolExp b v)
getDepHeadersFromVal :: Value -> [Text]
getDependentHeaders :: BoolExp b -> HashSet Text
data DropPerm b
DropPerm :: SourceName -> TableName b -> RoleName -> DropPerm b
[dipSource] :: DropPerm b -> SourceName
[dipTable] :: DropPerm b -> TableName b
[dipRole] :: DropPerm b -> RoleName
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.DDL.Permission.Internal.CreatePermP1Res a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.DDL.Permission.Internal.CreatePermP1Res a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b a)) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Permission.Internal.CreatePerm a b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Permission.Internal.DropPerm b)


-- | Metadata API Actions relating to Source Kinds
module Hasura.RQL.DDL.SourceKinds
data ListSourceKinds
ListSourceKinds :: ListSourceKinds
data SourceKindInfo
SourceKindInfo :: Text -> Maybe Text -> Maybe Text -> SourceType -> Bool -> SourceKindInfo
[_skiSourceKind] :: SourceKindInfo -> Text
[_skiDisplayName] :: SourceKindInfo -> Maybe Text
[_skiReleaseName] :: SourceKindInfo -> Maybe Text
[_skiBuiltin] :: SourceKindInfo -> SourceType
[_skiAvailable] :: SourceKindInfo -> Bool
data SourceType
Builtin :: SourceType
Agent :: SourceType
newtype SourceKinds
SourceKinds :: [SourceKindInfo] -> SourceKinds
[unSourceKinds] :: SourceKinds -> [SourceKindInfo]
agentSourceKinds :: MetadataM m => m SourceKinds
runListSourceKinds :: forall m. (MetadataM m, MonadError QErr m, CacheRM m) => ListSourceKinds -> m EncJSON
newtype GetSourceKindCapabilities
GetSourceKindCapabilities :: NonEmptyText -> GetSourceKindCapabilities
[_gskcKind] :: GetSourceKindCapabilities -> NonEmptyText

-- | List Backend Capabilities. Currently this only supports Data Connector
--   Backends.
runGetSourceKindCapabilities :: (MonadError QErr m, CacheRM m) => GetSourceKindCapabilities -> m EncJSON
instance GHC.Base.Monoid Hasura.RQL.DDL.SourceKinds.SourceKinds
instance GHC.Base.Semigroup Hasura.RQL.DDL.SourceKinds.SourceKinds
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SourceKinds.GetSourceKindCapabilities
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SourceKinds.SourceKinds
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SourceKinds.SourceKindInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SourceKinds.SourceKindInfo
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SourceKinds.SourceType
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SourceKinds.SourceType
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SourceKinds.ListSourceKinds
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SourceKinds.ListSourceKinds

module Hasura.RQL.DDL.SchemaRegistry
newtype SchemaProjectId
SchemaProjectId :: Text -> SchemaProjectId
[_spiProjectId] :: SchemaProjectId -> Text
newtype IsMetadataInconsistent
IsMetadataInconsistent :: Bool -> IsMetadataInconsistent
[_isMdInconsistent] :: IsMetadataInconsistent -> Bool
newtype SchemaSDL
SchemaSDL :: Text -> SchemaSDL
[_sdl] :: SchemaSDL -> Text
newtype SchemaHash
SchemaHash :: Text -> SchemaHash
[_schemaHash] :: SchemaHash -> Text
type SchemaRegistryMap = HashMap RoleName GQLSchemaInformation
type SchemaRegistryAction = Maybe (MetadataResourceVersion -> [InconsistentMetadata] -> Metadata -> IO ())
data GQLSchemaInformation
GQLSchemaInformation :: SchemaSDL -> SchemaHash -> GQLSchemaInformation
[_gsiSchemaSDL] :: GQLSchemaInformation -> SchemaSDL
[_gsiSchemaHash] :: GQLSchemaInformation -> SchemaHash
data ProjectGQLSchemaInformation
ProjectGQLSchemaInformation :: SchemaRegistryMap -> IsMetadataInconsistent -> SchemaHash -> MetadataResourceVersion -> UTCTime -> Metadata -> ProjectGQLSchemaInformation
[_pgsiSchemaRegistryMap] :: ProjectGQLSchemaInformation -> SchemaRegistryMap
[_pgsiIsMetadataInconsistent] :: ProjectGQLSchemaInformation -> IsMetadataInconsistent
[_pgsiAdminSchemaHash] :: ProjectGQLSchemaInformation -> SchemaHash
[_pgsiMetadataResourceVersion] :: ProjectGQLSchemaInformation -> MetadataResourceVersion
[_pgsiChangeRecordedAt] :: ProjectGQLSchemaInformation -> UTCTime
[_pgsiMetadata] :: ProjectGQLSchemaInformation -> Metadata
data SchemaRegistryConfig
SchemaRegistryConfig :: Text -> Maybe Text -> SchemaRegistryConfig
[_srcSchemaRegistryWebhook] :: SchemaRegistryConfig -> Text
[_srcSchemaRegistryAccessKey] :: SchemaRegistryConfig -> Maybe Text
data SchemaRegistryConfigRaw
SchemaRegistryConfigRaw :: Maybe Text -> Maybe Text -> SchemaRegistryConfigRaw
[_srcrSchemaRegistryWebhook] :: SchemaRegistryConfigRaw -> Maybe Text
[_srcrSchemaRegistryAccessKey] :: SchemaRegistryConfigRaw -> Maybe Text
data SchemaRegistryDetails
SchemaRegistryDetails :: RoleName -> GQLSchemaInformation -> SchemaRegistryDetails
[_srdlSchemaRole] :: SchemaRegistryDetails -> RoleName
[_srdlSchemaInfo] :: SchemaRegistryDetails -> GQLSchemaInformation
type SchemaRegistryDetailsList = [SchemaRegistryDetails]

-- | Context required to upate schema registry everytime the schema is
--   updated
data SchemaRegistryContext
SchemaRegistryContext :: TQueue ProjectGQLSchemaInformation -> PGPool -> SchemaRegistryContext
[_srpaSchemaRegistryTQueueRef] :: SchemaRegistryContext -> TQueue ProjectGQLSchemaInformation
[_srpaMetadataDbPoolRef] :: SchemaRegistryContext -> PGPool
newtype SchemaRegistryControlRole
SchemaRegistryControlRole :: Text -> SchemaRegistryControlRole
[unSchemaRegistryControlRole] :: SchemaRegistryControlRole -> Text
selectNowQuery :: TxE QErr UTCTime
calculateSchemaSDLHash :: Text -> RoleName -> SchemaHash
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.SchemaProjectId
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.SchemaProjectId
instance GHC.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.SchemaProjectId
instance GHC.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaProjectId
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaProjectId
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.IsMetadataInconsistent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.IsMetadataInconsistent
instance GHC.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.IsMetadataInconsistent
instance GHC.Show.Show Hasura.RQL.DDL.SchemaRegistry.IsMetadataInconsistent
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.IsMetadataInconsistent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.SchemaSDL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.SchemaSDL
instance GHC.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.SchemaSDL
instance GHC.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaSDL
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaSDL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.SchemaHash
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.SchemaHash
instance GHC.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.SchemaHash
instance GHC.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaHash
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaHash
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.GQLSchemaInformation
instance GHC.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.GQLSchemaInformation
instance GHC.Show.Show Hasura.RQL.DDL.SchemaRegistry.GQLSchemaInformation
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.GQLSchemaInformation
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.ProjectGQLSchemaInformation
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.ProjectGQLSchemaInformation
instance GHC.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.ProjectGQLSchemaInformation
instance GHC.Show.Show Hasura.RQL.DDL.SchemaRegistry.ProjectGQLSchemaInformation
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.ProjectGQLSchemaInformation
instance GHC.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryConfig
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryConfig
instance GHC.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryConfigRaw
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryConfigRaw
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryDetails
instance GHC.Generics.Generic Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryDetails
instance GHC.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryDetails
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryDetails
instance GHC.Show.Show Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryControlRole
instance GHC.Classes.Eq Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryControlRole
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.SchemaRegistryDetails
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.SchemaRegistry.GQLSchemaInformation


-- | Functions for fetching and updating @<a>Metadata</a> in the catalog.
module Hasura.RQL.DDL.Schema.Catalog
fetchMetadataFromCatalog :: TxE QErr Metadata
fetchMetadataAndResourceVersionFromCatalog :: TxE QErr MetadataWithResourceVersion
fetchMetadataResourceVersionFromCatalog :: TxE QErr MetadataResourceVersion
fetchMetadataNotificationsFromCatalog :: MetadataResourceVersion -> InstanceId -> TxE QErr [(MetadataResourceVersion, CacheInvalidations)]
bumpMetadataVersionInCatalog :: TxE QErr ()
insertMetadataInCatalog :: Metadata -> TxE QErr ()

-- | Check that the specified resource version matches the currently stored
--   one, and...
--   
--   <ul>
--   <li>If so: Update the metadata and bump the version</li>
--   <li>If not: Throw a 409 error</li>
--   </ul>
setMetadataInCatalog :: MetadataResourceVersion -> Metadata -> TxE QErr MetadataResourceVersion

module Hasura.RQL.DDL.Schema.Cache.Config

-- | This type aggregates all of the "static" configuration of the cache
--   build.
--   
--   Static arguments are the ones that will not change during the
--   execution of the engine. They are a subset of the environment of the
--   engine (see <tt>AppEnv</tt> and Note [Hasura Application State] for
--   more information).
--   
--   While <tt>AppEnv</tt> has access to the union of *all* the static
--   configuration of the engine, more specific parts of the code should
--   avoid relying directly on it to avoid being tied to unrelated parts of
--   the codebase. (See FIXME).
data CacheStaticConfig
CacheStaticConfig :: MaintenanceMode () -> EventingMode -> ReadOnlyMode -> Logger Hasura -> (BackendType -> Bool) -> Bool -> CacheStaticConfig
[_cscMaintenanceMode] :: CacheStaticConfig -> MaintenanceMode ()
[_cscEventingMode] :: CacheStaticConfig -> EventingMode
[_cscReadOnlyMode] :: CacheStaticConfig -> ReadOnlyMode
[_cscLogger] :: CacheStaticConfig -> Logger Hasura

-- | Native queries can be enabled or disabled on the fly via a feature
--   flag, however we only recognise a change on a restart
[_cscAreNativeQueriesEnabled] :: CacheStaticConfig -> BackendType -> Bool

-- | Stored procedures can be enabled or disabled on the fly via a feature
--   flag, however we only recognise a change on a restart
[_cscAreStoredProceduresEnabled] :: CacheStaticConfig -> Bool
class (Monad m) => HasCacheStaticConfig m
askCacheStaticConfig :: HasCacheStaticConfig m => m CacheStaticConfig

-- | This type aggregates all of the "dynamic" configuration of the cache
--   build.
--   
--   Dynamic arguments are the ones that might change during the execution
--   of the engine. They are a subset of the <tt>AppContext</tt> (see Note
--   [Hasura Application State] for more information).
--   
--   While <tt>AppContext</tt> has access to the union of *all* the dynamic
--   configuration of the engine, more specific parts of the code should
--   avoid relying directly on it to avoid being tied to unrelated parts of
--   the codebase. (See FIXME).
data CacheDynamicConfig
CacheDynamicConfig :: InferFunctionPermissions -> RemoteSchemaPermissions -> SQLGenCtx -> HashSet ExperimentalFeature -> NamingCase -> MetadataDefaults -> ApolloFederationStatus -> CloseWebsocketsOnMetadataChangeStatus -> CacheDynamicConfig
[_cdcFunctionPermsCtx] :: CacheDynamicConfig -> InferFunctionPermissions
[_cdcRemoteSchemaPermsCtx] :: CacheDynamicConfig -> RemoteSchemaPermissions
[_cdcSQLGenCtx] :: CacheDynamicConfig -> SQLGenCtx
[_cdcExperimentalFeatures] :: CacheDynamicConfig -> HashSet ExperimentalFeature
[_cdcDefaultNamingConvention] :: CacheDynamicConfig -> NamingCase
[_cdcMetadataDefaults] :: CacheDynamicConfig -> MetadataDefaults
[_cdcApolloFederationStatus] :: CacheDynamicConfig -> ApolloFederationStatus
[_cdcCloseWebsocketsOnMetadataChangeStatus] :: CacheDynamicConfig -> CloseWebsocketsOnMetadataChangeStatus
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Cache.Config.CacheDynamicConfig
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig m => Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig m => Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig m => Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig (Control.Monad.Trans.State.Strict.StateT s m)

module Hasura.RQL.DDL.QueryTags
data SetQueryTagsConfig
runSetQueryTagsConfig :: (MonadError QErr m, MetadataM m, CacheRWM m) => SetQueryTagsConfig -> m EncJSON
instance GHC.Generics.Generic Hasura.RQL.DDL.QueryTags.SetQueryTagsConfig
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.QueryTags.SetQueryTagsConfig
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.QueryTags.SetQueryTagsConfig

module Hasura.RQL.DDL.QueryCollection
runCreateCollection :: (QErrM m, CacheRWM m, MetadataM m) => CreateCollection -> m EncJSON
runRenameCollection :: (QErrM m, CacheRWM m, MetadataM m) => RenameCollection -> m EncJSON
runAddQueryToCollection :: (CacheRWM m, MonadError QErr m, MetadataM m) => AddQueryToCollection -> m EncJSON
runDropCollection :: (MonadError QErr m, MetadataM m, CacheRWM m) => DropCollection -> m EncJSON
runDropQueryFromCollection :: (CacheRWM m, MonadError QErr m, MetadataM m) => DropQueryFromCollection -> m EncJSON
runAddCollectionToAllowlist :: (MonadError QErr m, MetadataM m, CacheRWM m) => AllowlistEntry -> m EncJSON
runDropCollectionFromAllowlist :: (MonadError QErr m, MetadataM m, CacheRWM m) => DropCollectionFromAllowlist -> m EncJSON
runUpdateScopeOfCollectionInAllowlist :: (MonadError QErr m, MetadataM m, CacheRWM m) => UpdateScopeOfCollectionInAllowlist -> m EncJSON

module Hasura.RQL.DDL.Permission
type family PermInfo perm
addPermissionToMetadata :: PermDef b a -> TableMetadata b -> TableMetadata b
buildPermInfo :: (BackendMetadata b, QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => Environment -> SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> RoleName -> PermDefPermission b perm -> m (WithDeps (PermInfo perm b))

-- | Given the logical model's definition and the permissions as defined in
--   the logical model's metadata, try to construct the permission
--   definition.
buildLogicalModelPermInfo :: (BackendMetadata b, QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => SourceName -> LogicalModelLocation -> InsOrdHashMap (Column b) (LogicalModelField b) -> PermDefPermission b perm -> m (WithDeps (PermInfo perm b))
runCreatePerm :: forall m b a. (UserInfoM m, CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => CreatePerm a b -> m EncJSON
runDropPerm :: forall b m. (UserInfoM m, CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => PermType -> DropPerm b -> m EncJSON
buildInsPermInfo :: forall b m r. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => Environment -> SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> InsPerm b -> m (WithDeps (InsPermInfo b))
buildSelPermInfo :: forall b m r. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> RoleName -> SelPerm b -> m (WithDeps (SelPermInfo b))
buildUpdPermInfo :: forall b m r. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => Environment -> SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> UpdPerm b -> m (WithDeps (UpdPermInfo b))
buildDelPermInfo :: forall b m r. (QErrM m, TableCoreInfoRM b m, LogicalModelFieldsRM b m, BackendMetadata b, GetAggregationPredicatesDeps b, MonadReader r m, Has (ScalarTypeParsingContext b) r) => Environment -> SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> DelPerm b -> m (WithDeps (DelPermInfo b))
data SetPermComment b
SetPermComment :: SourceName -> TableName b -> RoleName -> PermType -> Maybe Text -> SetPermComment b
[apSource] :: SetPermComment b -> SourceName
[apTable] :: SetPermComment b -> TableName b
[apRole] :: SetPermComment b -> RoleName
[apPermission] :: SetPermComment b -> PermType
[apComment] :: SetPermComment b -> Maybe Text
runSetPermComment :: forall b m. (QErrM m, CacheRWM m, MetadataM m, BackendMetadata b) => SetPermComment b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Permission.SetPermComment b)


-- | Functions for updating the metadata (with integrity checking) to
--   incorporate schema changes discovered after applying a user-supplied
--   SQL query. None of these functions modify the schema cache, so it must
--   be reloaded after the metadata is updated.
module Hasura.RQL.DDL.Schema.Rename

-- | Replace all references to a given table name by its new name across
--   the entire metadata.
--   
--   This function will make use of the metadata dependency graph (see
--   <a>getDependentObjs</a>) to identify all places that refer to the old
--   table name, and replace it accordingly. Most operations will occur
--   within the same source, such as table references in relationships and
--   permissions. Dependencies across sources can happen in the case of
--   cross-source relationships.
--   
--   This function will fail if it encounters a nonsensical dependency; for
--   instance, if there's a dependency from that table to a source.
--   
--   For more information about the dependency graph, see
--   <a>SchemaObjId</a>.
renameTableInMetadata :: forall b m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableName b -> TableName b -> m ()

-- | Replace all references to a given column name by its new name across
--   the entire metadata.
--   
--   This function will make use of the metadata dependency graph (see
--   <a>getDependentObjs</a>) to identify all places that refer to the old
--   column name, and replace it accordingly. Most operations will occur
--   within the same source, such as column references in relationships and
--   permissions. Dependencies across sources can happen in the case of
--   cross-source relationships.
--   
--   This function will fail if it encounters a nonsensical dependency; for
--   instance, if there's a dependency from that table to a source.
--   
--   For more information about the dependency graph, see
--   <a>SchemaObjId</a>.
renameColumnInMetadata :: forall b m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => Column b -> Column b -> SourceName -> TableName b -> FieldInfoMap (FieldInfo b) -> m ()
renameRelationshipInMetadata :: forall b m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableName b -> RelName -> RelType -> RelName -> m ()

module Hasura.RQL.DDL.Relationship
newtype CreateArrRel b
CreateArrRel :: WithTable b (ArrRelDef b) -> CreateArrRel b
[unCreateArrRel] :: CreateArrRel b -> WithTable b (ArrRelDef b)
newtype CreateObjRel b
CreateObjRel :: WithTable b (ObjRelDef b) -> CreateObjRel b
[unCreateObjRel] :: CreateObjRel b -> WithTable b (ObjRelDef b)
execCreateRelationship :: forall b m a. (BackendMetadata b, CacheRM m, MonadError QErr m, ToJSON a) => RelType -> WithTable b (RelDef a) -> Metadata -> m (MetadataObjId, MetadataModifier)
runCreateRelationship :: forall m b a. (MonadError QErr m, CacheRWM m, ToJSON a, MetadataM m, BackendMetadata b) => RelType -> WithTable b (RelDef a) -> m EncJSON
defaultBuildObjectRelationshipInfo :: forall b m. (QErrM m, Backend b) => SourceName -> HashMap (TableName b) (HashSet (ForeignKey b)) -> TableName b -> ObjRelDef b -> m (RelInfo b, Seq SchemaDependency)

-- | set up a relationship from a Native Query onto another data source
nativeQueryRelationshipSetup :: forall b m. (QErrM m, Backend b) => SourceName -> NativeQueryName -> RelType -> RelDef (RelManualConfig b) -> m (RelInfo b, Seq SchemaDependency)
defaultBuildArrayRelationshipInfo :: forall b m. (QErrM m, Backend b) => SourceName -> HashMap (TableName b) (HashSet (ForeignKey b)) -> TableName b -> ArrRelDef b -> m (RelInfo b, Seq SchemaDependency)
data DropRel b
execDropRel :: forall b m. (MonadError QErr m, CacheRWM m, BackendMetadata b) => DropRel b -> m MetadataModifier
runDropRel :: forall m b. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => DropRel b -> m EncJSON
data SetRelComment b
runSetRelComment :: forall m b. (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => SetRelComment b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.CreateArrRel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.CreateObjRel b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Relationship.SetRelComment b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Relationship.SetRelComment b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Relationship.SetRelComment b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.SetRelComment b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.DropRel b)


-- | Types related to metadata management API
module Hasura.RQL.DDL.Metadata.Types

-- | <a>ClearMetadata</a> can be used to reset the state of Hasura -- clean
--   the current state by forgetting the tables tracked, relationships,
--   permissions, event triggers etc.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-clear-metadata</a>
data ClearMetadata
ClearMetadata :: ClearMetadata

-- | <a>ExportMetadata</a> is used to export the current metadata from the
--   server as a JSON file.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-export-metadata</a>
data ExportMetadata
ExportMetadata :: ExportMetadata
data ReloadSpec a
RSReloadAll :: ReloadSpec a
RSReloadList :: HashSet a -> ReloadSpec a

-- | <a>ReloadMetadata</a> should be used when there is a change in
--   underlying Postgres database that Hasura should be aware of. Example:
--   a new column is added to a table using psql and this column should now
--   be added to the GraphQL schema.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-reload-metadata</a>
data ReloadMetadata
ReloadMetadata :: ReloadRemoteSchemas -> ReloadSources -> ReloadSources -> ReloadDataConnectors -> ReloadMetadata
[_rmReloadRemoteSchemas] :: ReloadMetadata -> ReloadRemoteSchemas
[_rmReloadSources] :: ReloadMetadata -> ReloadSources

-- | Provides a way for the user to allow to explicitly recreate event
--   triggers for some or all the sources. This is useful when a user may
--   have fiddled with the SQL trigger in the source and they'd simply want
--   the event trigger to be recreated without deleting and creating the
--   event trigger. By default, no source's event triggers will be
--   recreated.
[_rmRecreateEventTriggers] :: ReloadMetadata -> ReloadSources
[_rmReloadDataConnectors] :: ReloadMetadata -> ReloadDataConnectors

-- | Undocumented Metadata API action which serializes the entire
--   <tt>SchemaCache</tt>.
data DumpInternalState
DumpInternalState :: DumpInternalState

-- | <a>GetInconsistentMetadata</a> can be used to fetch all inconsistent
--   metadata objects.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/schema-metadata-api/manage-metadata/#schema-metadata-get-inconsistent-metadata</a>
data GetInconsistentMetadata
GetInconsistentMetadata :: GetInconsistentMetadata

-- | <a>DropInconsistentMetadata</a> can be used to purge all inconsistent
--   objects from the metadata.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-drop-inconsistent-metadata</a>
data DropInconsistentMetadata
DropInconsistentMetadata :: DropInconsistentMetadata
data AllowInconsistentMetadata
AllowInconsistentMetadata :: AllowInconsistentMetadata
NoAllowInconsistentMetadata :: AllowInconsistentMetadata

-- | Replace metadata either with or without metadata sources.
data ReplaceMetadataV1
RMWithSources :: Metadata -> ReplaceMetadataV1
RMWithoutSources :: MetadataNoSources -> ReplaceMetadataV1

-- | Replace metadata while allowing for inconsitency in the metadata
--   object.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-replace-metadata-syntax</a>
data ReplaceMetadataV2
ReplaceMetadataV2 :: AllowInconsistentMetadata -> AllowWarnings -> ReplaceMetadataV1 -> ReplaceMetadataV2
[_rmv2AllowInconsistentMetadata] :: ReplaceMetadataV2 -> AllowInconsistentMetadata
[_rmv2AllowWarningss] :: ReplaceMetadataV2 -> AllowWarnings
[_rmv2Metadata] :: ReplaceMetadataV2 -> ReplaceMetadataV1

-- | <a>ReplaceMetadata</a> is used to replace/import metadata into Hasura.
--   Existing metadata will be replaced with the new one.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#metadata-replace-metadata</a>
--   TODO: If additional API versions are supported in future it would be
--   ideal to include a version field Rather than differentiating on the
--   "metadata" field.
data ReplaceMetadata
RMReplaceMetadataV1 :: ReplaceMetadataV1 -> ReplaceMetadata
RMReplaceMetadataV2 :: ReplaceMetadataV2 -> ReplaceMetadata
data WebHookUrl
EnvVar :: String -> WebHookUrl
URL :: Text -> WebHookUrl

-- | <a>TestWebhookTransform</a> can be used to test out request
--   transformations using mock data.
--   
--   
--   <a>https://hasura.io/docs/latest/api-reference/metadata-api/manage-metadata/#test-webhook-transform</a>
data TestWebhookTransform
TestWebhookTransform :: Environment -> [Header] -> WebHookUrl -> Value -> RequestTransform -> Maybe MetadataResponseTransform -> Maybe SessionVariables -> TestWebhookTransform
[_twtEnv] :: TestWebhookTransform -> Environment
[_twtHeaders] :: TestWebhookTransform -> [Header]
[_twtWebhookUrl] :: TestWebhookTransform -> WebHookUrl
[_twtPayload] :: TestWebhookTransform -> Value
[_twtTransformer] :: TestWebhookTransform -> RequestTransform
[_twtResponseTransformer] :: TestWebhookTransform -> Maybe MetadataResponseTransform
[_twtSessionVariables] :: TestWebhookTransform -> Maybe SessionVariables
twtRequestTransformer :: Lens' TestWebhookTransform RequestTransform
twtResponseTransformer :: Lens' TestWebhookTransform (Maybe MetadataResponseTransform)
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance GHC.Generics.Generic Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance GHC.Generics.Generic Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance GHC.Generics.Generic Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance GHC.Generics.Generic Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance GHC.Generics.Generic Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance GHC.Show.Show Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV1
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV2
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.ReplaceMetadata
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.WebHookUrl
instance GHC.Classes.Eq Hasura.RQL.DDL.Metadata.Types.TestWebhookTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.TestWebhookTransform
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.TestWebhookTransform
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.WebHookUrl
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.WebHookUrl
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV2
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV2
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV1
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReplaceMetadataV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.AllowInconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.DropInconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.GetInconsistentMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.DumpInternalState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ReloadMetadata
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance (Data.Aeson.Types.FromJSON.FromJSON a, Data.Hashable.Class.Hashable a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Metadata.Types.ReloadSpec a)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ExportMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Metadata.Types.ClearMetadata
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Metadata.Types.ClearMetadata

module Hasura.RQL.DDL.InheritedRoles
runAddInheritedRole :: (MonadError QErr m, CacheRWM m, MetadataM m) => InheritedRole -> m EncJSON
dropInheritedRoleInMetadata :: RoleName -> MetadataModifier
runDropInheritedRole :: (MonadError QErr m, CacheRWM m, MetadataM m) => DropInheritedRole -> m EncJSON

-- | <a>resolveInheritedRole</a> resolves an inherited role by checking if
--   all the parent roles of an inherited role exists and report the
--   dependencies of the inherited role which will be the list of the
--   parent roles
resolveInheritedRole :: MonadError QErr m => HashSet RoleName -> InheritedRole -> m (Role, Seq SchemaDependency)

module Hasura.RQL.DDL.Endpoint
runCreateEndpoint :: (MonadError QErr m, CacheRWM m, MetadataM m) => CreateEndpoint -> m EncJSON
runDropEndpoint :: (MonadError QErr m, CacheRWM m, MetadataM m) => DropEndpoint -> m EncJSON
dropEndpointInMetadata :: EndpointName -> MetadataModifier

module Hasura.RQL.DDL.CustomTypes
runSetCustomTypes :: (MonadError QErr m, CacheRWM m, MetadataM m) => CustomTypes -> m EncJSON
clearCustomTypesInMetadata :: MetadataModifier

-- | A map from GraphQL name to equivalent scalar type for a given backend.
newtype ScalarParsingMap b
ScalarParsingMap :: HashMap Name (ScalarWrapper b) -> ScalarParsingMap b
resolveCustomTypes :: MonadError QErr m => SourceCache -> CustomTypes -> BackendMap ScalarParsingMap -> m AnnotatedCustomTypes
lookupBackendScalar :: BackendMap ScalarParsingMap -> Name -> Maybe AnnotatedScalarType
instance GHC.Base.Monoid (Hasura.RQL.DDL.CustomTypes.ScalarParsingMap b)
instance GHC.Base.Semigroup (Hasura.RQL.DDL.CustomTypes.ScalarParsingMap b)
instance GHC.Classes.Eq Hasura.RQL.DDL.CustomTypes.CustomTypeValidationError
instance GHC.Show.Show Hasura.RQL.DDL.CustomTypes.CustomTypeValidationError
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.CustomTypes.ScalarParsingMap b)


-- | ConnectionTemplate
--   
--   This module defines the needed types/functions for implementing the
--   metadata API `<a>backend</a>_test_connection_template`.
module Hasura.RQL.DDL.ConnectionTemplate

-- | The input type for the metadata API
--   `<a>backend</a>_test_connection_template`
data TestConnectionTemplate b
TestConnectionTemplate :: SourceName -> ConnectionTemplateRequestContext b -> Maybe ConnectionTemplate -> TestConnectionTemplate b
[_tctSourceName] :: TestConnectionTemplate b -> SourceName
[_tctRequestContext] :: TestConnectionTemplate b -> ConnectionTemplateRequestContext b
[_tctConnectionTemplate] :: TestConnectionTemplate b -> Maybe ConnectionTemplate

-- | Resolver for the metadata API
--   `<a>backend</a>_test_connection_template`
runTestConnectionTemplate :: forall b m. (MonadError QErr m, CacheRM m, Backend b, MetadataM m) => TestConnectionTemplate b -> m EncJSON
newtype ResolvedConnectionTemplateWrapper b
ResolvedConnectionTemplateWrapper :: ResolvedConnectionTemplate b -> ResolvedConnectionTemplateWrapper b
[getResolvedConnectionTemplateWrapper] :: ResolvedConnectionTemplateWrapper b -> ResolvedConnectionTemplate b
newtype BackendResolvedConnectionTemplate
BackendResolvedConnectionTemplate :: AnyBackend ResolvedConnectionTemplateWrapper -> BackendResolvedConnectionTemplate
[getBackendResolvedConnectionTemplate] :: BackendResolvedConnectionTemplate -> AnyBackend ResolvedConnectionTemplateWrapper
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.ConnectionTemplate.BackendResolvedConnectionTemplate
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.ConnectionTemplate.TestConnectionTemplate b)


-- | This module holds functions and data types used for logging at the
--   GraphQL layer. In contrast with, logging at the HTTP server layer.
module Hasura.GraphQL.Logging.QueryLog

-- | A GraphQL query, optionally generated SQL, and the request id makes up
--   the | <a>QueryLog</a>
data QueryLog
QueryLog :: !GQLReqUnparsed -> !Maybe (RootFieldAlias, GeneratedQuery) -> !RequestId -> !QueryLogKind -> QueryLog
[_qlQuery] :: QueryLog -> !GQLReqUnparsed
[_qlGeneratedSql] :: QueryLog -> !Maybe (RootFieldAlias, GeneratedQuery)
[_qlRequestId] :: QueryLog -> !RequestId
[_qlKind] :: QueryLog -> !QueryLogKind
data QueryLogKind
QueryLogKindDatabase :: Maybe BackendResolvedConnectionTemplate -> QueryLogKind
QueryLogKindAction :: QueryLogKind
QueryLogKindRemoteSchema :: QueryLogKind
QueryLogKindCached :: QueryLogKind
QueryLogKindIntrospection :: QueryLogKind
data GeneratedQuery
GeneratedQuery :: Text -> Value -> GeneratedQuery
[_gqQueryString] :: GeneratedQuery -> Text
[_gqPreparedArgs] :: GeneratedQuery -> Value
class (Monad m) => MonadQueryLog m
logQueryLog :: MonadQueryLog m => Logger Hasura -> QueryLog -> m ()
instance Hasura.GraphQL.Logging.QueryLog.MonadQueryLog m => Hasura.GraphQL.Logging.QueryLog.MonadQueryLog (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Logging.QueryLog.MonadQueryLog m => Hasura.GraphQL.Logging.QueryLog.MonadQueryLog (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.GraphQL.Logging.QueryLog.MonadQueryLog m => Hasura.GraphQL.Logging.QueryLog.MonadQueryLog (Hasura.Tracing.Monad.TraceT m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Logging.QueryLog.QueryLog
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Logging.QueryLog.QueryLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Logging.QueryLog.GeneratedQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Logging.QueryLog.QueryLogKind


module Hasura.RQL.DDL.ComputedField
data AddComputedField b
AddComputedField :: SourceName -> TableName b -> ComputedFieldName -> ComputedFieldDefinition b -> Comment -> AddComputedField b
[_afcSource] :: AddComputedField b -> SourceName
[_afcTable] :: AddComputedField b -> TableName b
[_afcName] :: AddComputedField b -> ComputedFieldName
[_afcDefinition] :: AddComputedField b -> ComputedFieldDefinition b
[_afcComment] :: AddComputedField b -> Comment
runAddComputedField :: forall b m. (BackendMetadata b, MonadError QErr m, CacheRWM m, MetadataM m) => AddComputedField b -> m EncJSON
data DropComputedField b
runDropComputedField :: forall b m. (QErrM m, CacheRWM m, MetadataM m, BackendMetadata b) => DropComputedField b -> m EncJSON
instance GHC.Generics.Generic (Hasura.RQL.DDL.ComputedField.AddComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.ComputedField.DropComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.ComputedField.AddComputedField b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.ComputedField.AddComputedField b)

module Hasura.RQL.DDL.ApiLimit
runSetApiLimits :: (MonadError QErr m, MetadataM m, CacheRWM m, MonadGetPolicies m) => ApiLimit -> m EncJSON
compareTimeLimitWith :: MonadGetPolicies m => Maybe MaxTime -> m (Either MetadataWarning ())
warningMessage :: MaxTime -> MaxTime -> MetadataWarning
runRemoveApiLimits :: (MonadError QErr m, MetadataM m, CacheRWM m) => m EncJSON


-- | Define and handle v1/metadata API operations to track, untrack, and
--   get native queries.
module Hasura.NativeQuery.API

-- | Default implementation of the <tt>track_native_query</tt> request
--   payload.
data TrackNativeQuery (b :: BackendType)
TrackNativeQuery :: SourceName -> NativeQueryName -> Text -> HashMap ArgumentName (NullableScalarType b) -> InsOrdHashMap RelName (RelDef (RelManualConfig b)) -> InsOrdHashMap RelName (RelDef (RelManualConfig b)) -> Maybe Text -> LogicalModelIdentifier b -> TrackNativeQuery (b :: BackendType)
[tnqSource] :: TrackNativeQuery (b :: BackendType) -> SourceName
[tnqRootFieldName] :: TrackNativeQuery (b :: BackendType) -> NativeQueryName
[tnqCode] :: TrackNativeQuery (b :: BackendType) -> Text
[tnqArguments] :: TrackNativeQuery (b :: BackendType) -> HashMap ArgumentName (NullableScalarType b)
[tnqArrayRelationships] :: TrackNativeQuery (b :: BackendType) -> InsOrdHashMap RelName (RelDef (RelManualConfig b))
[tnqObjectRelationships] :: TrackNativeQuery (b :: BackendType) -> InsOrdHashMap RelName (RelDef (RelManualConfig b))
[tnqDescription] :: TrackNativeQuery (b :: BackendType) -> Maybe Text
[tnqReturns] :: TrackNativeQuery (b :: BackendType) -> LogicalModelIdentifier b

-- | API payload for the <tt>get_native_query</tt> endpoint.
data GetNativeQuery (b :: BackendType)
GetNativeQuery :: SourceName -> GetNativeQuery (b :: BackendType)
[gnqSource] :: GetNativeQuery (b :: BackendType) -> SourceName

-- | Handler for the <tt>get_native_query</tt> endpoint.
runGetNativeQuery :: forall b m. (BackendMetadata b, MetadataM m, MonadError QErr m) => GetNativeQuery b -> m EncJSON

-- | Handler for the <tt>track_native_query</tt> endpoint. The type
--   'TrackNativeQuery b' (appearing here in wrapped as
--   'BackendTrackNativeQuery b' for <tt>AnyBackend</tt> compatibility) is
--   defined in 'class NativeQueryMetadata'.
execTrackNativeQuery :: forall b m. (BackendMetadata b, MonadError QErr m) => TrackNativeQuery b -> Metadata -> m (MetadataObjId, MetadataModifier)

-- | API payload for the <tt>untrack_native_query</tt> endpoint.
data UntrackNativeQuery (b :: BackendType)
UntrackNativeQuery :: SourceName -> NativeQueryName -> UntrackNativeQuery (b :: BackendType)
[utnqSource] :: UntrackNativeQuery (b :: BackendType) -> SourceName
[utnqRootFieldName] :: UntrackNativeQuery (b :: BackendType) -> NativeQueryName

-- | Handler for the <tt>untrack_native_query</tt> endpoint.
execUntrackNativeQuery :: forall b m. (BackendMetadata b, MonadError QErr m) => UntrackNativeQuery b -> Metadata -> m (MetadataObjId, MetadataModifier)
dropNativeQueryInMetadata :: forall b. BackendMetadata b => SourceName -> NativeQueryName -> MetadataModifier

-- | Check whether a native query with the given root field name exists for
--   the given source.
assertNativeQueryExists :: forall b m. (Backend b, MonadError QErr m) => SourceName -> NativeQueryName -> Metadata -> m ()
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.NativeQuery.API.TrackNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.API.TrackNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.NativeQuery.API.GetNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.NativeQuery.API.GetNativeQuery b)
instance GHC.Show.Show (Hasura.NativeQuery.API.UntrackNativeQuery b)
instance GHC.Classes.Eq (Hasura.NativeQuery.API.UntrackNativeQuery b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.NativeQuery.API.UntrackNativeQuery b)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.API.UntrackNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.NativeQuery.API.GetNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.NativeQuery.API.GetNativeQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.NativeQuery.API.TrackNativeQuery b)


-- | This module has type class and types which implements the Metadata
--   Storage Abstraction
module Hasura.Metadata.Class
data SchemaSyncEventProcessResult
SchemaSyncEventProcessResult :: !Bool -> !CacheInvalidations -> SchemaSyncEventProcessResult
[_sseprShouldReload] :: SchemaSyncEventProcessResult -> !Bool
[_sseprCacheInvalidations] :: SchemaSyncEventProcessResult -> !CacheInvalidations

-- | Metadata storage abstraction via a type class.
--   
--   This type class enables storing and managing Hasura metadata in an
--   isolated database which will not interfere with user's database where
--   tables/functions are defined. Hence, it'll enable support for
--   databases of multiple backends like MSSQL etc.
--   
--   Error-handling is handled explicitly, with every function returning an
--   `Either QErr`. This is inelegant, but is required: we want the caller
--   to explictly deal with errors, rather than letting them surface to a
--   "lower" monad, because we want to implement this as a <a>Service</a>,
--   on the base monad, so that different implementations of the engine can
--   choose how to implement it; and those base monads do not include error
--   handling, all error handling must be done at the endpoint level. As a
--   result, we choose to make the errors explicit in the return type
--   rather than making assumptions about the stack.
--   
--   This class has functions broadly related to:
--   
--   <ol>
--   <li>Metadata Management ---------------------- Basic metadata
--   management functions such as retrieving metadata from storage database
--   and replacing the given metadata. TODO: Console specific
--   operations</li>
--   <li>Scheduled Triggers --------------------- Eventing sub-system for
--   scheduled triggers is implemented via metadata storage. For more
--   details, refer description in <a>ScheduledTrigger</a> module.</li>
--   </ol>
--   
--   TODO: Functions need to be added to the type class - Retrieving
--   invocation logs from storage (console requirement) - Deleting an
--   scheduled event - Creating an one-off scheduled event
--   
--   <ol>
--   <li>Async Actions ---------------- Operations to implement async
--   actions sub-system. This includes recording an async action event and
--   retreiving the details of action delivery to the webhook. For more
--   details see Note [Async action architecture] in <a>Action</a>
--   module.</li>
--   </ol>
--   
--   It is believed that all the above three are implemented in a single
--   storage system (ex: a Postgres database). We can split the functions
--   into appropriate and specific type classes in future iterations if
--   required.
class (Monad m) => MonadMetadataStorage m
fetchMetadataResourceVersion :: MonadMetadataStorage m => m (Either QErr MetadataResourceVersion)
fetchMetadata :: MonadMetadataStorage m => m (Either QErr MetadataWithResourceVersion)
fetchMetadataNotifications :: MonadMetadataStorage m => MetadataResourceVersion -> InstanceId -> m (Either QErr [(MetadataResourceVersion, CacheInvalidations)])
setMetadata :: MonadMetadataStorage m => MetadataResourceVersion -> Metadata -> m (Either QErr MetadataResourceVersion)
notifySchemaCacheSync :: MonadMetadataStorage m => MetadataResourceVersion -> InstanceId -> CacheInvalidations -> m (Either QErr ())
getCatalogState :: MonadMetadataStorage m => m (Either QErr CatalogState)
setCatalogState :: MonadMetadataStorage m => CatalogStateType -> Value -> m (Either QErr ())
fetchSourceIntrospection :: MonadMetadataStorage m => MetadataResourceVersion -> m (Either QErr (Maybe StoredIntrospection))
storeSourceIntrospection :: MonadMetadataStorage m => StoredIntrospection -> MetadataResourceVersion -> m (Either QErr ())
getMetadataDbUid :: MonadMetadataStorage m => m (Either QErr MetadataDbId)
checkMetadataStorageHealth :: MonadMetadataStorage m => m (Either QErr ())
getDeprivedCronTriggerStats :: MonadMetadataStorage m => [TriggerName] -> m (Either QErr [CronTriggerStats])
getScheduledEventsForDelivery :: MonadMetadataStorage m => [TriggerName] -> m (Either QErr ([CronEvent], [OneOffScheduledEvent]))
insertCronEvents :: MonadMetadataStorage m => [CronEventSeed] -> m (Either QErr ())
insertOneOffScheduledEvent :: MonadMetadataStorage m => OneOffEvent -> m (Either QErr EventId)
insertScheduledEventInvocation :: MonadMetadataStorage m => Invocation 'ScheduledType -> ScheduledEventType -> m (Either QErr ())
setScheduledEventOp :: MonadMetadataStorage m => ScheduledEventId -> ScheduledEventOp -> ScheduledEventType -> m (Either QErr ())
unlockScheduledEvents :: MonadMetadataStorage m => ScheduledEventType -> [ScheduledEventId] -> m (Either QErr Int)
unlockAllLockedScheduledEvents :: MonadMetadataStorage m => m (Either QErr ())
clearFutureCronEvents :: MonadMetadataStorage m => ClearCronEvents -> m (Either QErr ())
getOneOffScheduledEvents :: MonadMetadataStorage m => ScheduledEventPagination -> [ScheduledEventStatus] -> RowsCountOption -> m (Either QErr (WithOptionalTotalCount [OneOffScheduledEvent]))
getCronEvents :: MonadMetadataStorage m => TriggerName -> ScheduledEventPagination -> [ScheduledEventStatus] -> RowsCountOption -> m (Either QErr (WithOptionalTotalCount [CronEvent]))
getScheduledEventInvocations :: MonadMetadataStorage m => GetScheduledEventInvocations -> m (Either QErr (WithOptionalTotalCount [ScheduledEventInvocation]))
deleteScheduledEvent :: MonadMetadataStorage m => ScheduledEventId -> ScheduledEventType -> m (Either QErr ())
insertAction :: MonadMetadataStorage m => ActionName -> SessionVariables -> [Header] -> Value -> m (Either QErr ActionId)
fetchUndeliveredActionEvents :: MonadMetadataStorage m => m (Either QErr [ActionLogItem])
setActionStatus :: MonadMetadataStorage m => ActionId -> AsyncActionStatus -> m (Either QErr ())
fetchActionResponse :: MonadMetadataStorage m => ActionId -> m (Either QErr ActionLogResponse)
clearActionData :: MonadMetadataStorage m => ActionName -> m (Either QErr ())
setProcessingActionLogsToPending :: MonadMetadataStorage m => LockedActionIdArray -> m (Either QErr ())

-- | Record a one-off event
createOneOffScheduledEvent :: MonadMetadataStorage m => OneOffEvent -> m (Either QErr EventId)

-- | Record a cron event
createCronEvents :: MonadMetadataStorage m => [CronEventSeed] -> m (Either QErr ())

-- | Clear cron events
dropFutureCronEvents :: MonadMetadataStorage m => ClearCronEvents -> m (Either QErr ())

-- | Delete async action logs
deleteActionData :: MonadMetadataStorage m => ActionName -> m (Either QErr ())

-- | Fetch cron/oneoff scheduled event invocations
fetchScheduledEventInvocations :: MonadMetadataStorage m => GetScheduledEventInvocations -> m (Either QErr (WithOptionalTotalCount [ScheduledEventInvocation]))

-- | Fetch cron/oneoff scheduled events
fetchScheduledEvents :: MonadMetadataStorage m => GetScheduledEvents -> m (Either QErr Value)

-- | Drop a cron/oneoff scheduled event
dropEvent :: MonadMetadataStorage m => ScheduledEventId -> ScheduledEventType -> m (Either QErr ())

-- | Retrieve the state from metadata storage catalog
fetchCatalogState :: MonadMetadataStorage m => m (Either QErr CatalogState)

-- | Update the state from metadata storage catalog
updateCatalogState :: MonadMetadataStorage m => CatalogStateType -> Value -> m (Either QErr ())

-- | Metadata database operations for EE credentials storage.
--   
--   This class is only necessary because we haven't written an
--   implementation for storing EE credentials in Cloud.
class (Monad m) => MonadEECredentialsStorage m
getEEClientCredentials :: MonadEECredentialsStorage m => m (Either QErr (Maybe EEClientCredentials))
setEEClientCredentials :: MonadEECredentialsStorage m => EEClientCredentials -> m (Either QErr ())
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.Managed.ManagedT m)
instance Hasura.Metadata.Class.MonadEECredentialsStorage m => Hasura.Metadata.Class.MonadEECredentialsStorage (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Metadata.Class.MonadEECredentialsStorage m => Hasura.Metadata.Class.MonadEECredentialsStorage (Control.Monad.Trans.State.Strict.StateT s m)
instance Hasura.Metadata.Class.MonadEECredentialsStorage m => Hasura.Metadata.Class.MonadEECredentialsStorage (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Metadata.Class.MonadEECredentialsStorage m => Hasura.Metadata.Class.MonadEECredentialsStorage (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.Metadata.Class.MonadEECredentialsStorage m => Hasura.Metadata.Class.MonadEECredentialsStorage (Control.Monad.Trans.Managed.ManagedT m)
instance (Hasura.Metadata.Class.MonadEECredentialsStorage m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => Hasura.Metadata.Class.MonadEECredentialsStorage (Control.Monad.Trans.Extended.TransT t m)
instance (Hasura.Metadata.Class.MonadMetadataStorage m, Control.Monad.Trans.Class.MonadTrans t, GHC.Base.Monad (t m)) => Hasura.Metadata.Class.MonadMetadataStorage (Control.Monad.Trans.Extended.TransT t m)

module Hasura.RQL.DDL.OpenTelemetry

-- | Set the OpenTelemetry configuration to the provided value.
runSetOpenTelemetryConfig :: (MonadError QErr m, MetadataM m, CacheRWM m) => OpenTelemetryConfig -> m EncJSON

-- | Set just the "status" field of the OpenTelemetry configuration.
runSetOpenTelemetryStatus :: (MonadError QErr m, MetadataM m, CacheRWM m) => OtelStatus -> m EncJSON

-- | Smart constructor for <a>OtelExporterInfo</a>.
--   
--   Returns a <tt>Left qErr</tt> to signal a validation error. Returns
--   <tt>Right Nothing</tt> to signal that the exporter should be disabled
--   without raising an error.
--   
--   If this is called we assume <a>OtelEnabled</a>
parseOtelExporterConfig :: Environment -> Set OtelDataType -> OtelExporterConfig -> Either QErr OtelExporterInfo
parseOtelBatchSpanProcessorConfig :: OtelBatchSpanProcessorConfig -> Either QErr OtelBatchSpanProcessorInfo

module Hasura.RQL.DDL.Network
runAddHostToTLSAllowlist :: (QErrM m, CacheRWM m, MetadataM m) => TlsAllow -> m EncJSON
runDropHostFromTLSAllowlist :: (QErrM m, CacheRWM m, MetadataM m) => DropHostFromTLSAllowlist -> m EncJSON
dropHostFromAllowList :: String -> Maybe String -> MetadataModifier
checkForHostnameWithSuffixInAllowlistObject :: String -> Maybe String -> TlsAllow -> Bool

module Hasura.RQL.DDL.Action
data CreateAction
CreateAction :: ActionName -> ActionDefinitionInput -> Maybe Text -> CreateAction
[_caName] :: CreateAction -> ActionName
[_caDefinition] :: CreateAction -> ActionDefinitionInput
[_caComment] :: CreateAction -> Maybe Text
runCreateAction :: (QErrM m, CacheRWM m, MetadataM m) => CreateAction -> m EncJSON
resolveAction :: QErrM m => Environment -> AnnotatedCustomTypes -> ActionDefinitionInput -> BackendMap ScalarParsingMap -> m (ResolvedActionDefinition, AnnotatedOutputType)
data UpdateAction
runUpdateAction :: forall m. (QErrM m, CacheRWM m, MetadataM m) => UpdateAction -> m EncJSON
data DropAction
runDropAction :: (MonadError QErr m, CacheRWM m, MetadataM m, MonadMetadataStorage m) => DropAction -> m EncJSON
dropActionInMetadata :: ActionName -> MetadataModifier
data CreateActionPermission
CreateActionPermission :: ActionName -> RoleName -> Maybe Value -> Maybe Text -> CreateActionPermission
[_capAction] :: CreateActionPermission -> ActionName
[_capRole] :: CreateActionPermission -> RoleName
[_capDefinition] :: CreateActionPermission -> Maybe Value
[_capComment] :: CreateActionPermission -> Maybe Text
runCreateActionPermission :: (QErrM m, CacheRWM m, MetadataM m) => CreateActionPermission -> m EncJSON
data DropActionPermission
runDropActionPermission :: (QErrM m, CacheRWM m, MetadataM m) => DropActionPermission -> m EncJSON
dropActionPermissionInMetadata :: ActionName -> RoleName -> MetadataModifier
instance GHC.Generics.Generic Hasura.RQL.DDL.Action.CreateAction
instance GHC.Generics.Generic Hasura.RQL.DDL.Action.UpdateAction
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.ClearActionData
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.ClearActionData
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.ClearActionData
instance GHC.Show.Show Hasura.RQL.DDL.Action.ClearActionData
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.DropAction
instance GHC.Generics.Generic Hasura.RQL.DDL.Action.DropAction
instance GHC.Show.Show Hasura.RQL.DDL.Action.DropAction
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.ActionMetadataField
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.ActionMetadataField
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.ActionMetadataField
instance GHC.Show.Show Hasura.RQL.DDL.Action.ActionMetadataField
instance GHC.Generics.Generic Hasura.RQL.DDL.Action.CreateActionPermission
instance GHC.Classes.Eq Hasura.RQL.DDL.Action.DropActionPermission
instance GHC.Generics.Generic Hasura.RQL.DDL.Action.DropActionPermission
instance GHC.Show.Show Hasura.RQL.DDL.Action.DropActionPermission
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.DropActionPermission
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.DropActionPermission
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.CreateActionPermission
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.DropAction
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.DropAction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.UpdateAction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Action.CreateAction
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Action.CreateAction

module Hasura.RQL.DDL.Action.Lenses
caName :: Lens' CreateAction ActionName
caDefinition :: Lens' CreateAction ActionDefinitionInput
caComment :: Lens' CreateAction (Maybe Text)
uaName :: Lens' UpdateAction ActionName
uaDefinition :: Lens' UpdateAction ActionDefinitionInput
uaComment :: Lens' UpdateAction (Maybe Text)


-- | Define and handle v1/metadata API operations to track, untrack, and
--   get logical models.
module Hasura.LogicalModel.API

-- | Default implementation of the <tt>track_logical_model</tt> request
--   payload.
data TrackLogicalModel (b :: BackendType)
TrackLogicalModel :: SourceName -> LogicalModelName -> Maybe Text -> InsOrdHashMap (Column b) (LogicalModelField b) -> TrackLogicalModel (b :: BackendType)
[tlmSource] :: TrackLogicalModel (b :: BackendType) -> SourceName
[tlmName] :: TrackLogicalModel (b :: BackendType) -> LogicalModelName
[tlmDescription] :: TrackLogicalModel (b :: BackendType) -> Maybe Text
[tlmFields] :: TrackLogicalModel (b :: BackendType) -> InsOrdHashMap (Column b) (LogicalModelField b)

-- | API payload for the <tt>get_logical_model</tt> endpoint.
data GetLogicalModel (b :: BackendType)
GetLogicalModel :: SourceName -> GetLogicalModel (b :: BackendType)
[glmSource] :: GetLogicalModel (b :: BackendType) -> SourceName

-- | Handler for the <tt>get_logical_model</tt> endpoint.
runGetLogicalModel :: forall b m. (BackendMetadata b, MonadError QErr m, MetadataM m) => GetLogicalModel b -> m EncJSON

-- | Handler for the <tt>track_logical_model</tt> endpoint. The type
--   'TrackLogicalModel b' (appearing here in wrapped as
--   'BackendTrackLogicalModel b' for <tt>AnyBackend</tt> compatibility) is
--   defined in 'class LogicalModelMetadata'.
execTrackLogicalModel :: forall b m. (BackendMetadata b, MonadError QErr m) => TrackLogicalModel b -> Metadata -> m (MetadataObjId, MetadataModifier)

-- | API payload for the <tt>untrack_logical_model</tt> endpoint.
data UntrackLogicalModel (b :: BackendType)
UntrackLogicalModel :: SourceName -> LogicalModelName -> UntrackLogicalModel (b :: BackendType)
[utlmSource] :: UntrackLogicalModel (b :: BackendType) -> SourceName
[utlmName] :: UntrackLogicalModel (b :: BackendType) -> LogicalModelName

-- | Handler for the <tt>untrack_logical_model</tt> endpoint.
execUntrackLogicalModel :: forall b m. (BackendMetadata b, MonadError QErr m) => UntrackLogicalModel b -> Metadata -> m (MetadataObjId, MetadataModifier)

-- | A permission for logical models is tied to a specific name and source.
--   This wrapper adds both of those things to the JSON object that
--   describes the permission.
data CreateLogicalModelPermission a (b :: BackendType)
CreateLogicalModelPermission :: SourceName -> LogicalModelLocation -> PermDef b a -> CreateLogicalModelPermission a (b :: BackendType)
[clmpSource] :: CreateLogicalModelPermission a (b :: BackendType) -> SourceName
[clmpLocation] :: CreateLogicalModelPermission a (b :: BackendType) -> LogicalModelLocation
[clmpInfo] :: CreateLogicalModelPermission a (b :: BackendType) -> PermDef b a
runCreateSelectLogicalModelPermission :: forall b m. (Backend b, CacheRWM m, MetadataM m, MonadError QErr m) => CreateLogicalModelPermission SelPerm b -> m EncJSON

-- | To drop a permission, we need to know the source and name of the
--   logical model, as well as the role whose permission we want to drop.
data DropLogicalModelPermission (b :: BackendType)
DropLogicalModelPermission :: SourceName -> LogicalModelLocation -> RoleName -> DropLogicalModelPermission (b :: BackendType)
[dlmpSource] :: DropLogicalModelPermission (b :: BackendType) -> SourceName
[dlmpLocation] :: DropLogicalModelPermission (b :: BackendType) -> LogicalModelLocation
[dlmpRole] :: DropLogicalModelPermission (b :: BackendType) -> RoleName
runDropSelectLogicalModelPermission :: forall b m. (Backend b, CacheRWM m, MetadataM m, MonadError QErr m) => DropLogicalModelPermission b -> m EncJSON

-- | TODO: should this cascade and also delete associated permissions?
dropLogicalModelInMetadata :: forall b. BackendMetadata b => SourceName -> LogicalModelName -> MetadataModifier
instance GHC.Generics.Generic (Hasura.LogicalModel.API.CreateLogicalModelPermission a b)
instance GHC.Generics.Generic (Hasura.LogicalModel.API.DropLogicalModelPermission b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.API.TrackLogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.API.TrackLogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.LogicalModel.API.GetLogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.LogicalModel.API.GetLogicalModel b)
instance GHC.Show.Show (Hasura.LogicalModel.API.UntrackLogicalModel b)
instance GHC.Classes.Eq (Hasura.LogicalModel.API.UntrackLogicalModel b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.API.DropLogicalModelPermission b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.Types.Permission.PermDef b a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.API.CreateLogicalModelPermission a b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.LogicalModel.API.LogicalModelSource
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.API.UntrackLogicalModel b)
instance Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.API.UntrackLogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.LogicalModel.API.GetLogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.LogicalModel.API.GetLogicalModel b)
instance Hasura.RQL.Types.Backend.Backend b => Autodocodec.Class.HasCodec (Hasura.LogicalModel.API.TrackLogicalModel b)

module Hasura.Backends.MSSQL.Schema.Introspection

-- | List all tables, tracked or untracked, on a given data source.
listAllTables :: (CacheRM m, MetadataM m, MonadBaseControl IO m, MonadError QErr m, MonadIO m) => SourceName -> m [TableName]

module Hasura.Backends.BigQuery.Schema.Introspection

-- | List all tables, tracked or untracked, on a given BigQuery source. All
--   given datasets' tables will be included.
listAllTables :: (CacheRM m, MetadataM m, MonadError QErr m, MonadIO m) => SourceName -> m [TableName]

module Hasura.Backends.BigQuery.Instances.Metadata
instance Hasura.RQL.Types.Metadata.Backend.BackendMetadata 'Hasura.RQL.Types.BackendType.BigQuery

module Hasura.Metadata.DTO.Metadata

-- | Exported representation of the GraphQL Engine metadata configuration
--   format.
--   
--   The OpenAPI specification for metadata is experimental and incomplete.
--   Please do not incorporate it into essential workflows at this time.
data MetadataDTO
V1 :: MetadataV1 -> MetadataDTO
V2 :: MetadataV2 -> MetadataDTO
V3 :: MetadataV3 -> MetadataDTO
instance Data.OpenApi.Internal.Schema.ToSchema Hasura.Metadata.DTO.Metadata.MetadataDTO
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Metadata.DTO.Metadata.MetadataDTO
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Metadata.DTO.Metadata.MetadataDTO
instance GHC.Generics.Generic Hasura.Metadata.DTO.Metadata.MetadataDTO
instance GHC.Classes.Eq Hasura.Metadata.DTO.Metadata.MetadataDTO
instance GHC.Show.Show Hasura.Metadata.DTO.Metadata.MetadataDTO
instance Autodocodec.Class.HasCodec Hasura.Metadata.DTO.Metadata.MetadataDTO


-- | This module exports an OpenAPI specification for the GraphQL Engine
--   metadata API.
--   
--   The OpenAPI specification for metadata is experimental and incomplete.
--   Please do not incorporate it into essential workflows at this time.
module Hasura.Server.MetadataOpenAPI

-- | An OpenApi document includes "schemas" that describe the data that may
--   be produced or consumed by an API. It can also include "paths" which
--   describe REST endpoints, and the document can include other API
--   metadata. This example only includes schemas.
--   
--   The OpenAPI specification for metadata is experimental and incomplete.
--   Please do not incorporate it into essential workflows at this time.
metadataOpenAPI :: OpenApi

module Hasura.RQL.DML.Types
newtype OrderByExp
OrderByExp :: [OrderByItem ('Postgres 'Vanilla)] -> OrderByExp
[getOrderByItems] :: OrderByExp -> [OrderByItem ('Postgres 'Vanilla)]
data DMLQuery a
DMLQuery :: SourceName -> QualifiedTable -> a -> DMLQuery a
getSourceDMLQuery :: forall a. DMLQuery a -> SourceName
data SelectG a b c
SelectG :: [a] -> Maybe b -> Maybe OrderByExp -> Maybe c -> Maybe c -> SelectG a b c
[sqColumns] :: SelectG a b c -> [a]
[sqWhere] :: SelectG a b c -> Maybe b
[sqOrderBy] :: SelectG a b c -> Maybe OrderByExp
[sqLimit] :: SelectG a b c -> Maybe c
[sqOffset] :: SelectG a b c -> Maybe c
data Wildcard
Star :: Wildcard
StarDot :: Wildcard -> Wildcard
data SelCol
SCStar :: Wildcard -> SelCol
SCExtSimple :: PGCol -> SelCol
SCExtRel :: RelName -> Maybe RelName -> SelectQ -> SelCol
type SelectQ = SelectG SelCol (BoolExp ('Postgres 'Vanilla)) Int
type SelectQT = SelectG SelCol (BoolExp ('Postgres 'Vanilla)) Value
type SelectQuery = DMLQuery SelectQ
type SelectQueryT = DMLQuery SelectQT
type InsObj b = ColumnValues b Value
data ConflictAction
CAIgnore :: ConflictAction
CAUpdate :: ConflictAction
newtype ConstraintOn
ConstraintOn :: [PGCol] -> ConstraintOn
[getPGCols] :: ConstraintOn -> [PGCol]
data OnConflict
OnConflict :: Maybe ConstraintOn -> Maybe ConstraintName -> ConflictAction -> OnConflict
[ocConstraintOn] :: OnConflict -> Maybe ConstraintOn
[ocConstraint] :: OnConflict -> Maybe ConstraintName
[ocAction] :: OnConflict -> ConflictAction
data InsertQuery
InsertQuery :: QualifiedTable -> SourceName -> Value -> Maybe OnConflict -> Maybe [PGCol] -> InsertQuery
[iqTable] :: InsertQuery -> QualifiedTable
[iqSource] :: InsertQuery -> SourceName
[iqObjects] :: InsertQuery -> Value
[iqOnConflict] :: InsertQuery -> Maybe OnConflict
[iqReturning] :: InsertQuery -> Maybe [PGCol]
type UpdVals b = ColumnValues b Value
data UpdateQuery
UpdateQuery :: QualifiedTable -> SourceName -> BoolExp ('Postgres 'Vanilla) -> UpdVals ('Postgres 'Vanilla) -> UpdVals ('Postgres 'Vanilla) -> UpdVals ('Postgres 'Vanilla) -> [PGCol] -> Maybe [PGCol] -> UpdateQuery
[uqTable] :: UpdateQuery -> QualifiedTable
[uqSource] :: UpdateQuery -> SourceName
[uqWhere] :: UpdateQuery -> BoolExp ('Postgres 'Vanilla)
[uqSet] :: UpdateQuery -> UpdVals ('Postgres 'Vanilla)
[uqInc] :: UpdateQuery -> UpdVals ('Postgres 'Vanilla)
[uqMul] :: UpdateQuery -> UpdVals ('Postgres 'Vanilla)
[uqDefault] :: UpdateQuery -> [PGCol]
[uqReturning] :: UpdateQuery -> Maybe [PGCol]
data DeleteQuery
DeleteQuery :: QualifiedTable -> SourceName -> BoolExp ('Postgres 'Vanilla) -> Maybe [PGCol] -> DeleteQuery
[doTable] :: DeleteQuery -> QualifiedTable
[doSource] :: DeleteQuery -> SourceName
[doWhere] :: DeleteQuery -> BoolExp ('Postgres 'Vanilla)
[doReturning] :: DeleteQuery -> Maybe [PGCol]
data CountQuery
CountQuery :: QualifiedTable -> SourceName -> Maybe [PGCol] -> Maybe (BoolExp ('Postgres 'Vanilla)) -> CountQuery
[cqTable] :: CountQuery -> QualifiedTable
[cqSource] :: CountQuery -> SourceName
[cqDistinct] :: CountQuery -> Maybe [PGCol]
[cqWhere] :: CountQuery -> Maybe (BoolExp ('Postgres 'Vanilla))
data QueryT
QTInsert :: InsertQuery -> QueryT
QTSelect :: SelectQueryT -> QueryT
QTUpdate :: UpdateQuery -> QueryT
QTDelete :: DeleteQuery -> QueryT
QTCount :: CountQuery -> QueryT
QTBulk :: [QueryT] -> QueryT
instance GHC.Classes.Eq Hasura.RQL.DML.Types.OrderByExp
instance GHC.Show.Show Hasura.RQL.DML.Types.OrderByExp
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.RQL.DML.Types.DMLQuery a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.RQL.DML.Types.DMLQuery a)
instance (GHC.Classes.Eq a, GHC.Classes.Eq b, GHC.Classes.Eq c) => GHC.Classes.Eq (Hasura.RQL.DML.Types.SelectG a b c)
instance GHC.Generics.Generic (Hasura.RQL.DML.Types.SelectG a b c)
instance (GHC.Show.Show a, GHC.Show.Show b, GHC.Show.Show c) => GHC.Show.Show (Hasura.RQL.DML.Types.SelectG a b c)
instance GHC.Classes.Ord Hasura.RQL.DML.Types.Wildcard
instance GHC.Classes.Eq Hasura.RQL.DML.Types.Wildcard
instance GHC.Show.Show Hasura.RQL.DML.Types.Wildcard
instance GHC.Classes.Eq Hasura.RQL.DML.Types.SelCol
instance GHC.Show.Show Hasura.RQL.DML.Types.SelCol
instance GHC.Classes.Eq Hasura.RQL.DML.Types.ConflictAction
instance GHC.Show.Show Hasura.RQL.DML.Types.ConflictAction
instance GHC.Classes.Eq Hasura.RQL.DML.Types.ConstraintOn
instance GHC.Show.Show Hasura.RQL.DML.Types.ConstraintOn
instance GHC.Classes.Eq Hasura.RQL.DML.Types.OnConflict
instance GHC.Generics.Generic Hasura.RQL.DML.Types.OnConflict
instance GHC.Show.Show Hasura.RQL.DML.Types.OnConflict
instance GHC.Classes.Eq Hasura.RQL.DML.Types.InsertQuery
instance GHC.Show.Show Hasura.RQL.DML.Types.InsertQuery
instance GHC.Classes.Eq Hasura.RQL.DML.Types.UpdateQuery
instance GHC.Show.Show Hasura.RQL.DML.Types.UpdateQuery
instance GHC.Classes.Eq Hasura.RQL.DML.Types.DeleteQuery
instance GHC.Show.Show Hasura.RQL.DML.Types.DeleteQuery
instance GHC.Classes.Eq Hasura.RQL.DML.Types.CountQuery
instance GHC.Show.Show Hasura.RQL.DML.Types.CountQuery
instance GHC.Classes.Eq Hasura.RQL.DML.Types.QueryT
instance GHC.Generics.Generic Hasura.RQL.DML.Types.QueryT
instance GHC.Show.Show Hasura.RQL.DML.Types.QueryT
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.QueryT
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.CountQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.DeleteQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.UpdateQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.InsertQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.OnConflict
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.ConstraintOn
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.ConflictAction
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.SelCol
instance (Data.Aeson.Types.FromJSON.FromJSON a, Data.Aeson.Types.FromJSON.FromJSON b, Data.Aeson.Types.FromJSON.FromJSON c) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DML.Types.SelectG a b c)
instance Data.Aeson.Types.FromJSON.FromJSON a => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DML.Types.DMLQuery a)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DML.Types.OrderByExp


-- | Postgres Types Column
--   
--   Gets the Postgres type used to represent a column, defaulting to Text
--   when unsure.
module Hasura.Backends.Postgres.Types.Column

-- | Gets the representation type associated with a <a>ColumnType</a>.
--   Avoid using this if possible. Prefer <tt>parsePGScalarValue</tt>,
--   <tt>parsePGScalarValues</tt>, or <a>mkTypedSessionVar</a>.
unsafePGColumnToBackend :: ColumnType ('Postgres pgKind) -> PGScalarType


-- | Postgres Translate Mutation
--   
--   Provide a combinator for generating a Postgres SQL SELECT statement
--   for the selected columns in mutation queries.
--   
--   See <a>Mutation</a> and note [Prepared statements in Mutations]
module Hasura.Backends.Postgres.Translate.Mutation

-- | Note:- Using sorted columns is necessary to enable casting the rows
--   returned by VALUES expression to table type. For example, let's
--   consider the table, `CREATE TABLE test (id serial primary key, name
--   text not null, age int)`. The generated values expression should be in
--   order of columns; `SELECT ("row"::table).* VALUES (1, <tt>Robert</tt>,
--   23) AS "row"`.
mkSelectExpFromColumnValues :: forall pgKind m. MonadError QErr m => QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> [ColumnValues ('Postgres pgKind) TxtEncodedVal] -> m Select


-- | Postgres Translate Column
--   
--   Translate column values to Postgres-specific SQL expressions.
module Hasura.Backends.Postgres.Translate.Column
toTxtValue :: ColumnValue ('Postgres pgKind) -> SQLExp

-- | Formats each columns to appropriate SQL expression
toJSONableExp :: StringifyNumbers -> ColumnType ('Postgres pgKind) -> Bool -> Maybe NamingCase -> SQLExp -> SQLExp


-- | This module defines functions that translate from the Postgres IR into
--   Postgres SQL AST.
--   
--   NOTE: These functions <a>processAnnAggregateSelect</a>,
--   <a>processAnnSimpleSelect</a>, <a>processConnectionSelect</a>, are all
--   mutually recursive.
--   
--   These functions are generally called from the top level functions in
--   Translate.Select, and the call stack looks like:
--   
--   <ul>
--   <li><tt>selectQuerySQL</tt> -&gt; <tt>mkSQLSelect</tt> -&gt;
--   <a>processAnnSimpleSelect</a> -&gt;
--   <a>processSelectParams</a>/<a>processAnnFields</a></li>
--   <li><tt>selectAggregateQuerySQL</tt> -&gt; <tt>mkAggregateSelect</tt>
--   -&gt; <a>processAnnAggregateSelect</a> -&gt;
--   <a>processSelectParams</a>/<a>processAnnFields</a></li>
--   <li><tt>connetionSelectQuerySQL</tt> -&gt; <tt>mkConnectionSelect</tt>
--   -&gt; <tt>processConnectionSelection</tt> -&gt;
--   <a>processSelectParams</a></li>
--   </ul>
--   
--   <a>SelectSource</a> consists of a prefix, a source, a boolean
--   conditional expression, and info on whether sorting or slicing is done
--   (needed to handle the LIMIT optimisation)
module Hasura.Backends.Postgres.Translate.Select.Internal.Process
processAnnAggregateSelect :: forall pgKind m. (MonadReader StringifyNumbers m, MonadWriter SelectWriter m, MonadState NativeQueryFreshIdStore m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => SourcePrefixes -> FieldName -> AnnAggregateSelect ('Postgres pgKind) -> m (SelectSource, InsOrdHashMap ColumnAlias SQLExp, Extractor)
processAnnSimpleSelect :: forall pgKind m. (MonadReader StringifyNumbers m, MonadState NativeQueryFreshIdStore m, MonadWriter SelectWriter m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => SourcePrefixes -> FieldName -> PermissionLimitSubQuery -> AnnSimpleSelect ('Postgres pgKind) -> m (SelectSource, InsOrdHashMap ColumnAlias SQLExp)
processConnectionSelect :: forall pgKind m. (MonadReader StringifyNumbers m, MonadWriter SelectWriter m, MonadState NativeQueryFreshIdStore m, Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind) => SourcePrefixes -> FieldName -> TableAlias -> HashMap PGCol PGCol -> ConnectionSelect ('Postgres pgKind) Void SQLExp -> m (ArrayConnectionSource, Extractor, InsOrdHashMap ColumnAlias SQLExp)


-- | This module defines the top-level translation functions pertaining to
--   streaming selects into Postgres AST.
--   
--   Streaming subscriptions are subscriptions based on a user-provided
--   cursor column. Unlike live queries, streaming subscriptions can be
--   used to only get the part that has changed in the query's response,
--   although this will be dependent on the user's choice of the cursor
--   column. The streaming starts from the initial value provided by the
--   user.
module Hasura.Backends.Postgres.Translate.Select.Streaming
selectStreamQuerySQL :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind) => AnnSimpleStreamSelect ('Postgres pgKind) -> Query
mkStreamSQLSelect :: forall pgKind m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadWriter CustomSQLCTEs m) => AnnSimpleStreamSelect ('Postgres pgKind) -> m Select


-- | This module defines the top-level translation functions pertaining to
--   queries that are not aggregation queries, i.e. so-called "simple"
--   selects into Postgres AST.
module Hasura.Backends.Postgres.Translate.Select.Simple

-- | Translates IR to Postgres queries for simple SELECTs (select queries
--   that are not aggregations, including subscriptions).
--   
--   See <a>mkSQLSelect</a> for the Postgres AST.
selectQuerySQL :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind) => JsonAggSelect -> AnnSimpleSelect ('Postgres pgKind) -> Query
mkSQLSelect :: forall pgKind m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadWriter CustomSQLCTEs m) => JsonAggSelect -> AnnSimpleSelect ('Postgres pgKind) -> m Select


-- | This module defines the top-level translation functions pertaining to
--   translating Connection (i.e. Relay) queries into Postgres AST.
module Hasura.Backends.Postgres.Translate.Select.Connection

-- | Translates IR to Postgres queries for "connection" queries (used for
--   Relay).
--   
--   See <a>mkConnectionSelect</a> for the Postgres AST.
connectionSelectQuerySQL :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind) => ConnectionSelect ('Postgres pgKind) Void SQLExp -> Query
mkConnectionSelect :: forall pgKind m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadWriter CustomSQLCTEs m) => ConnectionSelect ('Postgres pgKind) Void SQLExp -> m (SelectWithG Select)


-- | This module defines the top-level translation functions pertaining to
--   queries that use aggregation (i.e., <i>not</i> so-called "simple"
--   selects) into Postgres AST.
module Hasura.Backends.Postgres.Translate.Select.Aggregate

-- | Translates IR to Postgres queries for aggregated SELECTs.
--   
--   See <a>mkAggregateSelect</a> for the Postgres AST.
selectAggregateQuerySQL :: forall pgKind. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind) => AnnAggregateSelect ('Postgres pgKind) -> Query

-- | We process aggregate queries differently because the types of
--   aggregate queries are different. In the <tt>_asnFields</tt> field of
--   an <a>AnnSelectG</a>, we will have a <tt>TableAggregateFieldG</tt>
--   instead of an <tt>AnnFieldG</tt>.
mkAggregateSelect :: forall pgKind m. (Backend ('Postgres pgKind), PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind, MonadWriter CustomSQLCTEs m) => AnnAggregateSelect ('Postgres pgKind) -> m Select


-- | Postgres Translate Select
--   
--   This module is a translation layer between IR and postgres-specific
--   select queries.
--   
--   There are four main types of selects (as distinguished from the IR):
--   
--   <ul>
--   <li>"simple" selects</li>
--   <li>aggregate selects</li>
--   <li>connection selects (used for relay)</li>
--   <li>streaming selects (see
--   Hasura.Backends.Postgres.Translate.Select.Streaming for details)</li>
--   </ul>
module Hasura.Backends.Postgres.Translate.Select
type PostgresTranslateSelect pgKind = (PostgresAnnotatedFieldJSON pgKind, PostgresGenerateSQLSelect pgKind)


-- | Postgres Translate Returning
--   
--   Combinators and helpers for dealing with GraphQL returning statements.
module Hasura.Backends.Postgres.Translate.Returning

-- | The postgres common table expression (CTE) for mutation queries. This
--   CTE expression is used to generate mutation field output expression,
--   see Note [Mutation output expression].
data MutationCTE

-- | A Mutation with check constraint validation (Insert or Update)
MCCheckConstraint :: TopLevelCTE -> MutationCTE

-- | A Select statement which emits mutated table rows
MCSelectValues :: Select -> MutationCTE

-- | A Delete statement
MCDelete :: SQLDelete -> MutationCTE
getMutationCTE :: MutationCTE -> TopLevelCTE
checkPermissionRequired :: MutationCTE -> Bool
mkDefaultMutFlds :: Backend ('Postgres pgKind) => Maybe [ColumnInfo ('Postgres pgKind)] -> MutationOutput ('Postgres pgKind)
mkMutFldExp :: (Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadWriter CustomSQLCTEs m) => TableIdentifier -> Maybe Int -> StringifyNumbers -> Maybe NamingCase -> MutFld ('Postgres pgKind) -> m SQLExp

-- | Generate mutation output expression with given mutation CTE statement.
--   See Note [Mutation output expression].
mkMutationOutputExp :: (Backend ('Postgres pgKind), PostgresTranslateSelect pgKind) => QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> Maybe Int -> MutationCTE -> MutationOutput ('Postgres pgKind) -> StringifyNumbers -> Maybe NamingCase -> SelectWith
mkCheckErrorExp :: TableIdentifier -> SQLExp
checkConstraintIdentifier :: Identifier
asCheckErrorExtractor :: SQLExp -> Extractor
instance GHC.Classes.Eq Hasura.Backends.Postgres.Translate.Returning.MutationCTE
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Returning.MutationCTE


-- | Postgres Translate Insert
--   
--   Translates IR inserts to Postgres-specific SQL INSERT statements.
module Hasura.Backends.Postgres.Translate.Insert
mkInsertCTE :: Backend ('Postgres pgKind) => InsertQueryP1 ('Postgres pgKind) -> TopLevelCTE
toSQLConflict :: Backend ('Postgres pgKind) => QualifiedTable -> OnConflictClause ('Postgres pgKind) SQLExp -> SQLConflict

-- | Annotates the check constraint expression with <tt>boolean</tt>
--   (<a>check-condition</a>)::boolean
insertCheckConstraint :: BoolExp -> SQLExp

-- | When inserting data, we might need to also enforce the update check
--   condition, because we might fall back to an update via an <tt>ON
--   CONFLICT</tt> clause.
--   
--   We generate something which looks like
--   
--   <pre>
--   INSERT INTO
--     ...
--   ON CONFLICT DO UPDATE SET
--     ...
--   RETURNING
--     *,
--     CASE WHEN xmax = 0
--       THEN {insert_cond}
--       ELSE {update_cond}
--     END
--       AS "check__constraint"
--   </pre>
--   
--   See <tt><a>https://stackoverflow.com/q/34762732</a></tt> for more
--   information on the use of the <tt>xmax</tt> system column.
insertOrUpdateCheckExpr :: QualifiedTable -> Maybe (OnConflictClause ('Postgres pgKind) SQLExp) -> BoolExp -> Maybe BoolExp -> Extractor


-- | Postgres Translate Update
--   
--   Translates IR update to Postgres-specific SQL UPDATE statements.
module Hasura.Backends.Postgres.Translate.Update
data UpdateCTE

-- | Used for <i>update_table</i> and <i>update_table_by_pk</i>.
Update :: TopLevelCTE -> UpdateCTE

-- | Used for <i>update_table_many</i>.
MultiUpdate :: [TopLevelCTE] -> UpdateCTE

-- | Create the update CTE.
mkUpdateCTE :: forall pgKind. Backend ('Postgres pgKind) => AnnotatedUpdate ('Postgres pgKind) -> UpdateCTE
instance GHC.Show.Show Hasura.Backends.Postgres.Translate.Update.UpdateCTE


-- | Postgres Execute Mutation
--   
--   Generic combinators for translating and excecuting IR mutation
--   statements. Used by the specific mutation modules, e.g. <a>Insert</a>.
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Mutation
data MutateResp (b :: BackendType) a
MutateResp :: Int -> [ColumnValues b a] -> MutateResp (b :: BackendType) a
[_mrAffectedRows] :: MutateResp (b :: BackendType) a -> Int
[_mrReturningColumns] :: MutateResp (b :: BackendType) a -> [ColumnValues b a]
execUpdateQuery :: forall pgKind m. (MonadTx m, Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadReader QueryTagsComment m) => StringifyNumbers -> Maybe NamingCase -> UserInfo -> (AnnotatedUpdate ('Postgres pgKind), Seq PrepArg) -> m EncJSON
execDeleteQuery :: forall pgKind m. (MonadTx m, Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadReader QueryTagsComment m) => StringifyNumbers -> Maybe NamingCase -> UserInfo -> (AnnDel ('Postgres pgKind), Seq PrepArg) -> m EncJSON
execInsertQuery :: (MonadTx m, Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadReader QueryTagsComment m) => StringifyNumbers -> Maybe NamingCase -> UserInfo -> (InsertQueryP1 ('Postgres pgKind), Seq PrepArg) -> m EncJSON
executeMutationOutputQuery :: forall pgKind m. (MonadTx m, Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadReader QueryTagsComment m) => QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> Maybe Int -> MutationCTE -> MutationOutput ('Postgres pgKind) -> StringifyNumbers -> Maybe NamingCase -> [PrepArg] -> m EncJSON
mutateAndFetchCols :: forall pgKind. (Backend ('Postgres pgKind), PostgresTranslateSelect pgKind) => QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> (MutationCTE, Seq PrepArg) -> StringifyNumbers -> Maybe NamingCase -> TxE QErr (MutateResp ('Postgres pgKind) TxtEncodedVal)
type ValidateInputPayloadVersion = Int
validateInputPayloadVersion :: ValidateInputPayloadVersion
newtype ValidateInputErrorResponse
ValidateInputErrorResponse :: Text -> ValidateInputErrorResponse
[_vierMessage] :: ValidateInputErrorResponse -> Text
data HttpHandlerLog
HttpHandlerLog :: Text -> Value -> [HeaderConf] -> Value -> Int -> HttpHandlerLog
[_hhlUrl] :: HttpHandlerLog -> Text
[_hhlRequest] :: HttpHandlerLog -> Value
[_hhlRequestHeaders] :: HttpHandlerLog -> [HeaderConf]
[_hhlResponse] :: HttpHandlerLog -> Value
[_hhlResponseStatus] :: HttpHandlerLog -> Int
data ValidateInsertInputLog
VIILHttpHandler :: HttpHandlerLog -> ValidateInsertInputLog

-- | Map of table name and the value that is being inserted for that table
--   This map is helpful for collecting all the insert mutation arguments
--   for the nested tables and then sending them all at onve to the input
--   validation webhook.
type InsertValidationPayloadMap pgKind = InsOrdHashMap (TableName ('Postgres pgKind)) ([AnnotatedInsertRow ('Postgres pgKind) (UnpreparedValue ('Postgres pgKind))], (ValidateInput ResolvedWebhook))
validateUpdateMutation :: forall pgKind m. (MonadError QErr m, MonadIO m, MonadTrace m) => Environment -> Manager -> Logger Hasura -> UserInfo -> ResolvedWebhook -> [HeaderConf] -> Timeout -> Bool -> [Header] -> AnnotatedUpdateG ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind)) -> Maybe (HashMap Name (Value Variable)) -> m ()
validateDeleteMutation :: forall m pgKind. (MonadError QErr m, MonadIO m, MonadTrace m) => Environment -> Manager -> Logger Hasura -> UserInfo -> ResolvedWebhook -> [HeaderConf] -> Timeout -> Bool -> [Header] -> AnnDelG ('Postgres pgKind) Void (UnpreparedValue ('Postgres pgKind)) -> Maybe (HashMap Name (Value Variable)) -> m ()
validateMutation :: forall m. (MonadError QErr m, MonadIO m, MonadTrace m) => Environment -> Manager -> Logger Hasura -> UserInfo -> ResolvedWebhook -> [HeaderConf] -> Timeout -> Bool -> [Header] -> Value -> m ()
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.Mutation.ValidateInsertInputLog
instance Hasura.Logging.ToEngineLog Hasura.Backends.Postgres.Execute.Mutation.ValidateInsertInputLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.Mutation.HttpHandlerLog
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.Mutation.HttpHandlerLog
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.Execute.Mutation.ValidateInputErrorResponse
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.Execute.Mutation.ValidateInputErrorResponse
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Mutation.ValidateInputErrorResponse
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.Mutation.ValidateInputErrorResponse
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show a) => GHC.Show.Show (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq a) => GHC.Classes.Eq (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.ToJSON.ToJSON a) => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)
instance (Hasura.RQL.Types.Backend.Backend b, Data.Aeson.Types.FromJSON.FromJSON a) => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Backends.Postgres.Execute.Mutation.MutateResp b a)


-- | Postgres Execute Insert
--   
--   Translates and executes IR to Postgres-specific SQL.
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Insert
convertToSQLTransaction :: forall pgKind m. (MonadTx m, MonadIO m, MonadTrace m, Backend ('Postgres pgKind), PostgresTranslateSelect pgKind, MonadReader QueryTagsComment m) => AnnotatedInsert ('Postgres pgKind) Void SQLExp -> UserInfo -> Seq PrepArg -> StringifyNumbers -> Maybe NamingCase -> m EncJSON
validateInsertInput :: forall m pgKind. (MonadError QErr m, MonadIO m, MonadTrace m, MonadState (InsertValidationPayloadMap pgKind) m) => Environment -> Manager -> Logger Hasura -> UserInfo -> MultiObjectInsert ('Postgres pgKind) (UnpreparedValue ('Postgres pgKind)) -> [Header] -> m ()
validateInsertRows :: forall m pgKind. (MonadError QErr m, MonadIO m, MonadTrace m) => Environment -> Manager -> Logger Hasura -> UserInfo -> ResolvedWebhook -> [HeaderConf] -> Timeout -> Bool -> [Header] -> [AnnotatedInsertRow ('Postgres pgKind) (UnpreparedValue ('Postgres pgKind))] -> m ()


-- | Postgres DDL EventTrigger
--   
--   Used for creating event triggers for metadata changes.
--   
--   See <a>Backend</a>.
module Hasura.Backends.Postgres.DDL.EventTrigger
fetchUndeliveredEvents :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> SourceName -> [TriggerName] -> MaintenanceMode () -> FetchBatchSize -> m [Event ('Postgres pgKind)]
setRetry :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> UTCTime -> MaintenanceMode MaintenanceModeVersion -> m ()
insertManualEvent :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> TableName ('Postgres pgKind) -> TriggerName -> Value -> UserInfo -> Maybe TraceContext -> m EventId
getMaintenanceModeVersion :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> m MaintenanceModeVersion
recordSuccess :: MonadIO m => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> Invocation 'EventType -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError :: MonadIO m => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> Invocation 'EventType -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError' :: MonadIO m => SourceConfig ('Postgres pgKind) -> Event ('Postgres pgKind) -> Maybe (Invocation 'EventType) -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
redeliverEvent :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> EventId -> m ()
dropTriggerAndArchiveEvents :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> TriggerName -> QualifiedTable -> m ()
createMissingSQLTriggers :: (MonadIO m, MonadError QErr m, MonadBaseControl IO m, Backend ('Postgres pgKind)) => SQLGenCtx -> PGSourceConfig -> TableName ('Postgres pgKind) -> ([ColumnInfo ('Postgres pgKind)], Maybe (PrimaryKey ('Postgres pgKind) (ColumnInfo ('Postgres pgKind)))) -> TriggerName -> TriggerOnReplication -> TriggerOpsDef ('Postgres pgKind) -> m ()
createTableEventTrigger :: (Backend ('Postgres pgKind), MonadIO m, MonadBaseControl IO m) => SQLGenCtx -> PGSourceConfig -> QualifiedTable -> [ColumnInfo ('Postgres pgKind)] -> TriggerName -> TriggerOnReplication -> TriggerOpsDef ('Postgres pgKind) -> Maybe (PrimaryKey ('Postgres pgKind) (ColumnInfo ('Postgres pgKind))) -> m (Either QErr ())
dropDanglingSQLTrigger :: (MonadIO m, MonadError QErr m) => SourceConfig ('Postgres pgKind) -> TriggerName -> QualifiedTable -> HashSet Ops -> m ()
updateColumnInEventTrigger :: QualifiedTable -> PGCol -> PGCol -> QualifiedTable -> EventTriggerConf ('Postgres pgKind) -> EventTriggerConf ('Postgres pgKind)
unlockEventsInSource :: MonadIO m => SourceConfig ('Postgres pgKind) -> NESet EventId -> m (Either QErr Int)
checkIfTriggerExists :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> TriggerName -> HashSet Ops -> m Bool
dropTriggerQ :: TriggerName -> TxE QErr ()
mkAllTriggersQ :: forall pgKind m. (Backend ('Postgres pgKind), MonadTx m, MonadReader SQLGenCtx m) => TriggerName -> QualifiedTable -> TriggerOnReplication -> [ColumnInfo ('Postgres pgKind)] -> TriggerOpsDef ('Postgres pgKind) -> m ()

-- | Add cleanup logs for given trigger names and cleanup configs. This
--   will perform the following steps:
--   
--   <ol>
--   <li>Get last scheduled cleanup event and count.</li>
--   <li>If count is less than 5, then add add more cleanup logs, else do
--   nothing</li>
--   </ol>
addCleanupSchedules :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> [(TriggerName, AutoTriggerLogCleanupConfig)] -> m ()

-- | <tt>deleteAllScheduledCleanups</tt> deletes all scheduled cleanup logs
--   for a given event trigger
deleteAllScheduledCleanups :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> TriggerName -> m ()

-- | <tt>getCleanupEventsForDeletion</tt> returns the cleanup logs that are
--   to be deleted. This will perform the following steps:
--   
--   <ol>
--   <li>Get the scheduled cleanup events that were scheduled before
--   current time.</li>
--   <li>If there are multiple entries for the same trigger name with
--   different scheduled time, then fetch the latest entry and mark others
--   as dead.</li>
--   </ol>
getCleanupEventsForDeletion :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> m [(Text, TriggerName)]
updateCleanupEventStatusToDead :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> [Text] -> m ()

-- | <tt>updateCleanupEventStatusToPaused</tt> updates the cleanup log
--   status to <tt>paused</tt> if the event trigger configuration is
--   paused.
updateCleanupEventStatusToPaused :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> Text -> m ()

-- | <tt>updateCleanupEventStatusToCompleted</tt> updates the cleanup log
--   status after the event logs are deleted. This will perform the
--   following steps:
--   
--   <ol>
--   <li>Updates the cleanup config status to <tt>completed</tt>.</li>
--   <li>Updates the number of event logs and event invocation logs that
--   were deleted for a trigger name</li>
--   </ol>
updateCleanupEventStatusToCompleted :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> Text -> DeletedEventLogStats -> m ()

-- | <tt>deleteEventTriggerLogs</tt> deletes the event logs (and event
--   invocation logs) based on the cleanup configuration given This will
--   perform the following steps:
--   
--   <ol>
--   <li>Select all the dead events based on criteria set in the cleanup
--   config.</li>
--   <li>Lock the events in the database so that other HGE instances don't
--   pick them up for deletion.</li>
--   <li>Based on the config, perform the delete action.</li>
--   </ol>
deleteEventTriggerLogs :: (MonadIO m, MonadError QErr m) => PGSourceConfig -> TriggerLogCleanupConfig -> IO (Maybe (TriggerLogCleanupConfig, EventTriggerCleanupStatus)) -> m DeletedEventLogStats
fetchEventLogs :: (MonadError QErr m, MonadIO m) => PGSourceConfig -> GetEventLogs b -> m [EventLog]
fetchEventInvocationLogs :: (MonadError QErr m, MonadIO m) => PGSourceConfig -> GetEventInvocations b -> m [EventInvocationLog]
fetchEventById :: (MonadError QErr m, MonadIO m) => PGSourceConfig -> GetEventById b -> m EventLogWithInvocations
instance Database.PG.Query.Class.ToPrepArg Hasura.Backends.Postgres.DDL.EventTrigger.QualifiedTriggerName
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.EventTrigger.QualifiedTriggerName
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.EventTrigger.QualifiedTriggerName


-- | Postgres DDL Source
--   
--   A Source is a connected database. One can have multiple sources of the
--   same kind (e.g. Postgres).
--   
--   This module provides ways to fetch, update, and deal with table and
--   function metadata and hdb_catalog migrations for a Postgres Source.
--   
--   NOTE: Please have a look at the
--   `server<i>documentation</i>migration-guidelines.md` before adding any
--   new migration if you haven't already looked at it.
module Hasura.Backends.Postgres.DDL.Source

-- | We differentiate the handling of metadata between Citus, Cockroach and
--   Vanilla Postgres because Citus imposes limitations on the types of
--   joins that it permits, which then limits the types of relations that
--   we can track.
class ToMetadataFetchQuery (pgKind :: PostgresKind)
resolveSourceConfig :: (MonadIO m, MonadResolveSource m) => SourceName -> PostgresConnConfiguration -> BackendSourceKind ('Postgres pgKind) -> BackendConfig ('Postgres pgKind) -> Environment -> manager -> m (Either QErr (SourceConfig ('Postgres pgKind)))

-- | <a>logPGSourceCatalogMigrationLockedQueries</a> as the name suggests
--   logs the queries which are blocking in the database. This function is
--   called asynchronously from <tt>initCatalogIfNeeded</tt> while the
--   source catalog is being migrated. NOTE: When there are no locking
--   queries present in the database, nothing will be logged.
logPGSourceCatalogMigrationLockedQueries :: MonadIO m => Logger Hasura -> PGSourceConfig -> m Void
resolveDatabaseMetadata :: forall pgKind m. (Backend ('Postgres pgKind), ToMetadataFetchQuery pgKind, FetchFunctionMetadata pgKind, FetchTableMetadata pgKind, MonadIO m, MonadBaseControl IO m) => SourceMetadata ('Postgres pgKind) -> SourceConfig ('Postgres pgKind) -> m (Either QErr (DBObjectsIntrospection ('Postgres pgKind)))

-- | Initialise catalog tables for a source, including those required by
--   the event delivery subsystem.
prepareCatalog :: (MonadIO m, MonadBaseControl IO m) => SourceConfig ('Postgres pgKind) -> ExceptT QErr m (RecreateEventTriggers, SourceCatalogMigrationState)

-- | We differentiate for CockroachDB and other PG implementations as our
--   CockroachDB table fetching SQL does not require table information, and
--   fails if it receives unused prepared arguments this distinction should
--   no longer be necessary if this issue is resolved:
--   <a>https://github.com/cockroachdb/cockroach/issues/86375</a>
class FetchTableMetadata (pgKind :: PostgresKind)
fetchTableMetadata :: forall m. (FetchTableMetadata pgKind, Backend ('Postgres pgKind), ToMetadataFetchQuery pgKind, MonadTx m) => HashSet QualifiedTable -> m (DBTablesMetadata ('Postgres pgKind))

-- | Fetch Postgres metadata of all user tables
pgFetchTableMetadata :: forall pgKind m. (Backend ('Postgres pgKind), ToMetadataFetchQuery pgKind, MonadTx m) => HashSet QualifiedTable -> m (DBTablesMetadata ('Postgres pgKind))
class FetchFunctionMetadata (pgKind :: PostgresKind)
fetchFunctionMetadata :: (FetchFunctionMetadata pgKind, MonadTx m) => HashSet QualifiedFunction -> m (DBFunctionsMetadata ('Postgres pgKind))

-- | Clean source database after dropping in metadata
postDropSourceHook :: (MonadIO m, MonadError QErr m, MonadBaseControl IO m) => SourceConfig ('Postgres pgKind) -> TableEventTriggers ('Postgres pgKind) -> m ()
instance GHC.Generics.Generic Hasura.Backends.Postgres.DDL.Source.PGSourceLockQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.DDL.Source.PGSourceLockQueryError
instance Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata 'Hasura.RQL.Types.BackendType.Vanilla
instance Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata 'Hasura.RQL.Types.BackendType.Cockroach
instance Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata 'Hasura.RQL.Types.BackendType.Vanilla
instance Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata 'Hasura.RQL.Types.BackendType.Cockroach
instance Hasura.Logging.ToEngineLog Hasura.Backends.Postgres.DDL.Source.PGSourceLockQueryError Hasura.Logging.Hasura
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.DDL.Source.PGSourceLockQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.DDL.Source.PGSourceLockQuery
instance Hasura.Logging.ToEngineLog [Hasura.Backends.Postgres.DDL.Source.PGSourceLockQuery] Hasura.Logging.Hasura
instance Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery 'Hasura.RQL.Types.BackendType.Vanilla
instance Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery 'Hasura.RQL.Types.BackendType.Cockroach


-- | Postgres Instances Schema
--   
--   Defines a <a>BackendSchema</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.Schema
instance Hasura.Backends.Postgres.Instances.Schema.PostgresSchema 'Hasura.RQL.Types.BackendType.Vanilla
instance Hasura.Backends.Postgres.Instances.Schema.PostgresSchema 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.Instances.Schema.PostgresSchema 'Hasura.RQL.Types.BackendType.Cockroach
instance (Hasura.Backends.Postgres.Instances.Schema.PostgresSchema pgKind, Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind)) => Hasura.GraphQL.Schema.Backend.BackendTableSelectSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance (Hasura.Backends.Postgres.Instances.Schema.PostgresSchema pgKind, Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind)) => Hasura.GraphQL.Schema.Backend.BackendLogicalModelSelectSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance (Hasura.Backends.Postgres.Instances.Schema.PostgresSchema pgKind, Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind)) => Hasura.GraphQL.Schema.Backend.BackendNativeQuerySelectSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), Hasura.Backends.Postgres.Instances.Schema.PostgresSchema pgKind) => Hasura.GraphQL.Schema.Backend.BackendSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance Hasura.GraphQL.Schema.Backend.BackendSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Hasura.GraphQL.Schema.BoolExp.AggregationPredicatesSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)
instance Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind) => Hasura.GraphQL.Schema.Backend.BackendUpdateOperatorsSchema ('Hasura.RQL.Types.BackendType.Postgres pgKind)

module Hasura.GraphQL.Schema.Instances


-- | This module only exposes one function, <a>nodeField</a>, which is used
--   at the root level of the schema to create the <tt>node</tt> field in
--   the Relay API schema.
module Hasura.GraphQL.Schema.Relay

-- | Constructs the parser for the node interface.
--   
--   As mentioned in Note [Internal Relay HashMap], this function must
--   parse an incoming query for ANY potential matching table. Its
--   resulting parser returns a <a>NodeMap</a>: a container that, to a
--   source name and a table name, associates both the parsed fields and
--   all the relevant table information required to craft a request.
nodeInterface :: SourceCache -> NodeInterfaceParserBuilder

-- | Creates a field parser for the top-level "node" field in the
--   QueryRoot.
--   
--   It exepcts one argument, the node id. It looks for the targeted table
--   in the <a>NodeMap</a> returned by <a>nodeInterface</a>, and, if
--   successful, attempts to craft a corresponding <tt>QueryRootField</tt>
--   that will extract the requested row.
nodeField :: forall m n. (MonadError QErr m, MonadMemoize m, MonadParse n) => SourceCache -> SchemaContext -> SchemaOptions -> m (FieldParser n (QueryRootField UnpreparedValue))

module Hasura.GraphQL.Schema.Action

-- | actionExecute is used to execute either a query action or a
--   synchronous mutation action. A query action or a synchronous mutation
--   action accepts the field name and input arguments and a selectionset.
--   The input argument and selectionset types are defined by the user.
--   
--   <pre>
--   action_name(action_input_arguments) {
--     col1: col1_type
--     col2: col2_type
--   }
--   </pre>
actionExecute :: forall r m n. MonadBuildActionSchema r m n => AnnotatedCustomTypes -> ActionInfo -> SchemaT r m (Maybe (FieldParser n (AnnActionExecution (RemoteRelationshipField UnpreparedValue))))

-- | actionAsyncMutation is used to execute a asynchronous mutation action.
--   An asynchronous action expects the field name and the input arguments
--   to the action. A selectionset is *not* expected. An action ID (UUID)
--   will be returned after performing the action
--   
--   <pre>
--   action_name(action_input_arguments)
--   </pre>
actionAsyncMutation :: forall r m n. MonadBuildActionSchema r m n => HashMap Name AnnotatedInputType -> ActionInfo -> SchemaT r m (Maybe (FieldParser n AnnActionMutationAsync))

-- | actionAsyncQuery is used to query/subscribe to the result of an
--   asynchronous mutation action. The only input argument to an
--   asynchronous mutation action is the action ID (UUID) and a selection
--   set is expected, the selection set contains 4 fields namely <a>id</a>,
--   <tt>created_at</tt>,<tt>errors</tt> and <tt>output</tt>. The result of
--   the action can be queried through the <tt>output</tt> field.
--   
--   <pre>
--   action_name (id: UUID!) {
--     id: UUID!
--     created_at: timestampz!
--     errors: JSON
--     output: user_defined_type!
--   }
--   </pre>
actionAsyncQuery :: forall r m n. MonadBuildActionSchema r m n => HashMap Name AnnotatedObjectType -> ActionInfo -> SchemaT r m (Maybe (FieldParser n (AnnActionAsyncQuery ('Postgres 'Vanilla) (RemoteRelationshipField UnpreparedValue))))


-- | Postgres-specific schema combinators. Those should be moved to the
--   corresponding instance of <tt>BackendSchema</tt>, when actions are
--   generalized.
module Hasura.GraphQL.Schema.Postgres
buildActionQueryFields :: MonadBuildActionSchema r m n => AnnotatedCustomTypes -> ActionInfo -> SchemaT r m [FieldParser n (QueryRootField UnpreparedValue)]
buildActionMutationFields :: MonadBuildActionSchema r m n => AnnotatedCustomTypes -> ActionInfo -> SchemaT r m [FieldParser n (MutationRootField UnpreparedValue)]
buildActionSubscriptionFields :: MonadBuildActionSchema r m n => AnnotatedCustomTypes -> ActionInfo -> SchemaT r m [FieldParser n (QueryRootField UnpreparedValue)]


-- | Postgres Execute subscription
--   
--   Multiplex is an optimization which allows us to group similar queries
--   into a single query, and routing the response rows afterwards. See
--   <a>https://hasura.io/docs/latest/graphql/core/databases/postgres/subscriptions/execution-and-performance.html</a>
--   for more details
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Subscription

-- | Internal: Used to collect information about various parameters of a
--   subscription field's AST as we resolve them to SQL expressions.
data QueryParametersInfo (b :: BackendType)
QueryParametersInfo :: HashMap Name (ColumnValue b) -> Seq (ColumnValue b) -> HashSet SessionVariable -> QueryParametersInfo (b :: BackendType)
[_qpiReusableVariableValues] :: QueryParametersInfo (b :: BackendType) -> HashMap Name (ColumnValue b)
[_qpiSyntheticVariableValues] :: QueryParametersInfo (b :: BackendType) -> Seq (ColumnValue b)

-- | The session variables that are referenced in the query root fld's AST.
--   This information is used to determine a cohort's required session
--   variables
[_qpiReferencedSessionVariables] :: QueryParametersInfo (b :: BackendType) -> HashSet SessionVariable

-- | Checks if the provided arguments are valid values for their
--   corresponding types. | Generates SQL of the format "select
--   <tt>v1</tt>::t1, <tt>v2</tt>::t2 ..."
validateVariablesTx :: forall pgKind f m. (Traversable f, MonadTx m, MonadIO m) => f (ColumnValue ('Postgres pgKind)) -> m (ValidatedVariables f)
newtype MultiplexedQuery
MultiplexedQuery :: Query -> MultiplexedQuery
[unMultiplexedQuery] :: MultiplexedQuery -> Query
mkMultiplexedQuery :: (Backend ('Postgres pgKind), PostgresTranslateSelect pgKind) => InsOrdHashMap Name (QueryDB ('Postgres pgKind) Void SQLExp) -> MultiplexedQuery
mkStreamingMultiplexedQuery :: (Backend ('Postgres pgKind), PostgresTranslateSelect pgKind) => (Name, QueryDB ('Postgres pgKind) Void SQLExp) -> MultiplexedQuery

-- | Resolves an <a>UnresolvedVal</a> by converting <a>UVPG</a> values to
--   SQL expressions that refer to the <tt>result_vars</tt> input object,
--   collecting information about various parameters of the query along the
--   way.
resolveMultiplexedValue :: (MonadState (QueryParametersInfo ('Postgres pgKind)) m, MonadError QErr m) => SessionVariables -> UnpreparedValue ('Postgres pgKind) -> m SQLExp
executeMultiplexedQuery :: MonadTx m => MultiplexedQuery -> [(CohortId, CohortVariables)] -> m [(CohortId, ByteString)]
executeStreamingMultiplexedQuery :: MonadTx m => MultiplexedQuery -> [(CohortId, CohortVariables)] -> m [(CohortId, ByteString, ViaJSON CursorVariableValues)]

-- | Internal; used by both <a>executeMultiplexedQuery</a>,
--   <a>executeStreamingMultiplexedQuery</a> and
--   <tt>pgDBSubscriptionExplain</tt>.
executeQuery :: (MonadTx m, FromRes a) => Query -> [(CohortId, CohortVariables)] -> m a
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.Subscription.MultiplexedQuery
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Subscription.MultiplexedQuery
instance Data.Text.Extended.ToTxt Hasura.Backends.Postgres.Execute.Subscription.MultiplexedQuery
instance GHC.Base.Monoid (Hasura.Backends.Postgres.Execute.Subscription.QueryParametersInfo b)
instance GHC.Base.Semigroup (Hasura.Backends.Postgres.Execute.Subscription.QueryParametersInfo b)
instance GHC.Generics.Generic (Hasura.Backends.Postgres.Execute.Subscription.QueryParametersInfo b)


-- | Postgres DDL
--   
--   Implements the DDL related methods of the <a>BackendMetadata</a> type
--   class for the Postgres backend, which provides an interface for
--   fetching information about the objects in the database, such as
--   tables, relationships, etc.
module Hasura.Backends.Postgres.DDL
parseCollectableType :: forall pgKind m. (Backend ('Postgres pgKind), MonadError QErr m) => CollectableType (ColumnType ('Postgres pgKind)) -> Value -> m (PartialSQLExp ('Postgres pgKind))


-- | Validate native queries against postgres-like flavors.
module Hasura.Backends.Postgres.Instances.NativeQueries

-- | Prepare a native query query against a postgres-like database to
--   validate it.
validateNativeQuery :: forall m pgKind sourceConfig. (MonadIO m, MonadError QErr m) => InsOrdHashMap PGScalarType Oid -> Environment -> SourceName -> PostgresConnConfiguration -> sourceConfig -> LogicalModelInfo ('Postgres pgKind) -> NativeQueryMetadata ('Postgres pgKind) -> m (InterpolatedQuery ArgumentName)

-- | Convert a native query to a prepared statement to be validate.
--   
--   Used by <a>validateNativeQuery</a>. Exported for testing.
nativeQueryToPreparedStatement :: forall m pgKind. MonadError QErr m => LogicalModelInfo ('Postgres pgKind) -> NativeQueryMetadata ('Postgres pgKind) -> m (ByteString, Text)


-- | Postgres Instances Metadata
--   
--   Defines a <a>BackendMetadata</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.Metadata
instance Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata 'Hasura.RQL.Types.BackendType.Vanilla
instance Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata 'Hasura.RQL.Types.BackendType.Citus
instance Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata 'Hasura.RQL.Types.BackendType.Cockroach
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), Hasura.Backends.Postgres.Instances.Metadata.PostgresMetadata pgKind, Hasura.Backends.Postgres.DDL.Source.FetchTableMetadata pgKind, Hasura.Backends.Postgres.DDL.Source.FetchFunctionMetadata pgKind, Hasura.Backends.Postgres.DDL.Source.ToMetadataFetchQuery pgKind) => Hasura.RQL.Types.Metadata.Backend.BackendMetadata ('Hasura.RQL.Types.BackendType.Postgres pgKind)

module Hasura.RQL.DML.Internal
runDMLP1T :: DMLP1T m a -> m (a, Seq PrepArg)
askPermInfo :: UserInfoM m => Lens' (RolePermInfo ('Postgres 'Vanilla)) (Maybe c) -> TableInfo ('Postgres 'Vanilla) -> m (Maybe c)
isTabUpdatable :: RoleName -> TableInfo ('Postgres 'Vanilla) -> Bool
askInsPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (InsPermInfo ('Postgres 'Vanilla))
askSelPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (SelPermInfo ('Postgres 'Vanilla))
askUpdPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (UpdPermInfo ('Postgres 'Vanilla))
askDelPermInfo :: (UserInfoM m, QErrM m) => TableInfo ('Postgres 'Vanilla) -> m (DelPermInfo ('Postgres 'Vanilla))
verifyAsrns :: MonadError QErr m => [a -> m ()] -> [a] -> m ()
checkRetCols :: (UserInfoM m, QErrM m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> SelPermInfo ('Postgres 'Vanilla) -> [PGCol] -> m [ColumnInfo ('Postgres 'Vanilla)]
checkSelOnCol :: (UserInfoM m, QErrM m) => SelPermInfo ('Postgres 'Vanilla) -> Column ('Postgres 'Vanilla) -> m ()
checkPermOnCol :: (UserInfoM m, QErrM m) => PermType -> HashSet (Column ('Postgres 'Vanilla)) -> Column ('Postgres 'Vanilla) -> m ()
valueParserWithCollectableType :: MonadError QErr m => (ColumnType ('Postgres 'Vanilla) -> Value -> m SQLExp) -> CollectableType (ColumnType ('Postgres 'Vanilla)) -> Value -> m SQLExp
binRHSBuilder :: QErrM m => ColumnType ('Postgres 'Vanilla) -> Value -> DMLP1T m SQLExp
fetchRelTabInfo :: (QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => TableName ('Postgres 'Vanilla) -> m (TableInfo ('Postgres 'Vanilla))
askTableInfoSource :: (QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => TableName ('Postgres 'Vanilla) -> m (TableInfo ('Postgres 'Vanilla))
data SessionVariableBuilder m
fetchRelDet :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m) => RelName -> TableName ('Postgres 'Vanilla) -> m (FieldInfoMap (FieldInfo ('Postgres 'Vanilla)), SelPermInfo ('Postgres 'Vanilla))
convAnnBoolExpPartialSQL :: Applicative f => SessionVariableBuilder f -> AnnBoolExpPartialSQL ('Postgres 'Vanilla) -> f (AnnBoolExpSQL ('Postgres 'Vanilla))
convAnnRedactionExpPartialSQL :: Applicative f => SessionVariableBuilder f -> AnnRedactionExpPartialSQL ('Postgres 'Vanilla) -> f (AnnRedactionExp ('Postgres 'Vanilla) (SQLExpression ('Postgres 'Vanilla)))
convPartialSQLExp :: Applicative f => SessionVariableBuilder f -> PartialSQLExp ('Postgres 'Vanilla) -> f (SQLExpression ('Postgres 'Vanilla))
sessVarFromCurrentSetting :: Applicative f => SessionVariableBuilder f
convBoolExp :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m, LogicalModelFieldsRM ('Postgres 'Vanilla) m) => FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> SelPermInfo ('Postgres 'Vanilla) -> BoolExp ('Postgres 'Vanilla) -> SessionVariableBuilder m -> FieldInfoMap (FieldInfo ('Postgres 'Vanilla)) -> ValueParser ('Postgres 'Vanilla) m (SQLExpression ('Postgres 'Vanilla)) -> m (AnnBoolExpSQL ('Postgres 'Vanilla))
validateHeaders :: (UserInfoM m, QErrM m) => HashSet Text -> m ()
onlyPositiveInt :: MonadError QErr m => Int -> m ()
instance Hasura.RQL.Types.Session.UserInfoM m => Hasura.RQL.Types.Session.UserInfoM (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.RQL.Types.SchemaCache.CacheRM m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.LogicalModel.Fields.LogicalModelFieldsRM b m => Hasura.LogicalModel.Fields.LogicalModelFieldsRM b (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.RQL.Types.SchemaCache.TableInfoRM b m => Hasura.RQL.Types.SchemaCache.TableInfoRM b (Hasura.RQL.DML.Internal.DMLP1T m)
instance Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b m => Hasura.RQL.Types.SchemaCache.TableCoreInfoRM b (Hasura.RQL.DML.Internal.DMLP1T m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.DML.Internal.DMLP1T m)
instance GHC.Base.Monad m => Control.Monad.State.Class.MonadState (Data.Sequence.Internal.Seq Database.PG.Query.Connection.PrepArg) (Hasura.RQL.DML.Internal.DMLP1T m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.RQL.DML.Internal.DMLP1T
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.DML.Internal.DMLP1T m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.RQL.DML.Internal.DMLP1T m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.DML.Internal.DMLP1T m)

module Hasura.RQL.DML.Update
runUpdate :: forall m. (QErrM m, UserInfoM m, CacheRM m, MonadBaseControl IO m, MonadIO m, MonadTrace m, MetadataM m) => SQLGenCtx -> UpdateQuery -> m EncJSON

module Hasura.RQL.DML.Select
runSelect :: (QErrM m, UserInfoM m, CacheRM m, MonadIO m, MonadBaseControl IO m, MonadTrace m, MetadataM m) => SQLGenCtx -> SelectQuery -> m EncJSON

module Hasura.RQL.DML.Insert
runInsert :: forall m. (QErrM m, UserInfoM m, CacheRM m, MonadIO m, MonadTrace m, MonadBaseControl IO m, MetadataM m) => SQLGenCtx -> InsertQuery -> m EncJSON

module Hasura.RQL.DML.Delete
validateDeleteQWith :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m, LogicalModelFieldsRM ('Postgres 'Vanilla) m) => SessionVariableBuilder m -> (ColumnType ('Postgres 'Vanilla) -> Value -> m SQLExp) -> DeleteQuery -> m (AnnDel ('Postgres 'Vanilla))
validateDeleteQ :: (QErrM m, UserInfoM m, CacheRM m) => DeleteQuery -> m (AnnDel ('Postgres 'Vanilla), Seq PrepArg)
runDelete :: forall m. (QErrM m, UserInfoM m, CacheRM m, MonadIO m, MonadTrace m, MonadBaseControl IO m, MetadataM m) => SQLGenCtx -> DeleteQuery -> m EncJSON

module Hasura.RQL.DML.Count
data CountQueryP1
CountQueryP1 :: QualifiedTable -> (AnnBoolExpSQL ('Postgres 'Vanilla), Maybe (AnnBoolExpSQL ('Postgres 'Vanilla))) -> Maybe [PGCol] -> CountQueryP1
[cqp1Table] :: CountQueryP1 -> QualifiedTable
[cqp1Where] :: CountQueryP1 -> (AnnBoolExpSQL ('Postgres 'Vanilla), Maybe (AnnBoolExpSQL ('Postgres 'Vanilla)))
[cqp1Distinct] :: CountQueryP1 -> Maybe [PGCol]
validateCountQWith :: (UserInfoM m, QErrM m, TableInfoRM ('Postgres 'Vanilla) m, LogicalModelFieldsRM ('Postgres 'Vanilla) m) => SessionVariableBuilder m -> (ColumnType ('Postgres 'Vanilla) -> Value -> m SQLExp) -> CountQuery -> m CountQueryP1
validateCountQ :: (QErrM m, UserInfoM m, CacheRM m) => CountQuery -> m (CountQueryP1, Seq PrepArg)
countQToTx :: MonadTx m => (CountQueryP1, Seq PrepArg) -> m EncJSON
runCount :: (QErrM m, UserInfoM m, CacheRM m, MonadIO m, MonadBaseControl IO m, MonadTrace m, MetadataM m) => CountQuery -> m EncJSON
instance GHC.Classes.Eq Hasura.RQL.DML.Count.CountQueryP1

module Hasura.Backends.MSSQL.DDL.EventTrigger
fetchUndeliveredEvents :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> SourceName -> [TriggerName] -> MaintenanceMode () -> FetchBatchSize -> m [Event 'MSSQL]
setRetry :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> Event 'MSSQL -> UTCTime -> MaintenanceMode MaintenanceModeVersion -> m ()
insertManualEvent :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TableName -> TriggerName -> Value -> UserInfo -> Maybe TraceContext -> m EventId
getMaintenanceModeVersion :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> m MaintenanceModeVersion
recordSuccess :: MonadIO m => MSSQLSourceConfig -> Event 'MSSQL -> Invocation 'EventType -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError :: MonadIO m => MSSQLSourceConfig -> Event 'MSSQL -> Invocation 'EventType -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
recordError' :: MonadIO m => MSSQLSourceConfig -> Event 'MSSQL -> Maybe (Invocation 'EventType) -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())
redeliverEvent :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> EventId -> m ()
dropTriggerAndArchiveEvents :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerName -> TableName -> m ()
dropDanglingSQLTrigger :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerName -> TableName -> HashSet Ops -> m ()
createTableEventTrigger :: MonadIO m => SQLGenCtx -> MSSQLSourceConfig -> TableName -> [ColumnInfo 'MSSQL] -> TriggerName -> TriggerOnReplication -> TriggerOpsDef 'MSSQL -> Maybe (PrimaryKey 'MSSQL (ColumnInfo 'MSSQL)) -> m (Either QErr ())
createMissingSQLTriggers :: (MonadIO m, MonadError QErr m, MonadBaseControl IO m) => SQLGenCtx -> MSSQLSourceConfig -> TableName -> ([ColumnInfo 'MSSQL], Maybe (PrimaryKey 'MSSQL (ColumnInfo 'MSSQL))) -> TriggerName -> TriggerOnReplication -> TriggerOpsDef 'MSSQL -> m ()
unlockEventsInSource :: MonadIO m => MSSQLSourceConfig -> NESet EventId -> m (Either QErr Int)
checkIfTriggerExists :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerName -> HashSet Ops -> m Bool
dropTriggerQ :: TriggerName -> SchemaName -> TxE QErr ()
qualifyTableName :: TableName -> Text

-- | Add cleanup logs for given trigger names and cleanup configs. This
--   will perform the following steps:
--   
--   <ol>
--   <li>Get last scheduled cleanup event and count.</li>
--   <li>If count is less than 5, then add add more cleanup logs, else do
--   nothing</li>
--   </ol>
addCleanupSchedules :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> [(TriggerName, AutoTriggerLogCleanupConfig)] -> m ()

-- | <tt>deleteAllScheduledCleanups</tt> deletes all scheduled cleanup logs
--   for a given event trigger
deleteAllScheduledCleanups :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerName -> m ()

-- | <tt>getCleanupEventsForDeletion</tt> returns the cleanup logs that are
--   to be deleted. This will perform the following steps:
--   
--   <ol>
--   <li>Get the scheduled cleanup events that were scheduled before
--   current time.</li>
--   <li>If there are multiple entries for the same trigger name with
--   different scheduled time, then fetch the latest entry and mark others
--   as dead.</li>
--   </ol>
getCleanupEventsForDeletion :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> m [(Text, TriggerName)]
updateCleanupEventStatusToDead :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> [Text] -> m ()

-- | <tt>updateCleanupEventStatusToPaused</tt> updates the cleanup log
--   status to <tt>paused</tt> if the event trigger configuration is
--   paused.
updateCleanupEventStatusToPaused :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> Text -> m ()

-- | <tt>updateCleanupEventStatusToCompleted</tt> updates the cleanup log
--   status after the event logs are deleted. This will perform the
--   following steps:
--   
--   <ol>
--   <li>Updates the cleanup config status to <tt>completed</tt>.</li>
--   <li>Updates the number of event logs and event invocation logs that
--   were deleted for a trigger name</li>
--   </ol>
updateCleanupEventStatusToCompleted :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> Text -> DeletedEventLogStats -> m ()

-- | <tt>deleteEventTriggerLogs</tt> deletes the event logs (and event
--   invocation logs) based on the cleanup configuration given This will
--   perform the following steps:
--   
--   <ol>
--   <li>Select all the dead events based on criteria set in the cleanup
--   config.</li>
--   <li>Lock the events in the database so that other HGE instances don't
--   pick them up for deletion.</li>
--   <li>Based on the config, perform the delete action.</li>
--   </ol>
deleteEventTriggerLogs :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> TriggerLogCleanupConfig -> IO (Maybe (TriggerLogCleanupConfig, EventTriggerCleanupStatus)) -> m DeletedEventLogStats
fetchEventLogs :: (MonadIO m, MonadError QErr m) => MSSQLSourceConfig -> GetEventLogs b -> m [EventLog]
fetchEventInvocationLogs :: (MonadError QErr m, MonadIO m) => MSSQLSourceConfig -> GetEventInvocations b -> m [EventInvocationLog]
fetchEventById :: (MonadError QErr m, MonadIO m) => MSSQLSourceConfig -> GetEventById b -> m EventLogWithInvocations
instance Hasura.SQL.Types.ToSQL Hasura.Backends.MSSQL.DDL.EventTrigger.QualifiedTriggerName
instance Hasura.SQL.Types.ToSQL Hasura.Backends.MSSQL.DDL.EventTrigger.SQLTriggerName

module Hasura.Eventing.Backend

-- | The <tt>BackendEventTrigger</tt> type class contains functions which
--   interacts with the source database to perform event trigger related
--   operations like fetching pending events from the database or inserting
--   a new invocation log after processing an event.
class (Backend b) => BackendEventTrigger (b :: BackendType)

-- | insertManualEvent inserts the specified event in the event log table,
--   note that this method should also set the trace context and session
--   variables in the source database context (if available).
insertManualEvent :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TableName b -> TriggerName -> Value -> UserInfo -> Maybe TraceContext -> m EventId

-- | <tt>fetchUndeliveredEvents</tt> fetches the undelivered events from
--   the source and locks those events for processing. The locking is done
--   so that when there are multiple instances of graphql-engine connected
--   to the same source they don't end up processing the same events
--   concurrently.
--   
--   Also, it's crucial that the SQL query used to fetch events in this
--   function uses something like Postgres's `FOR UPDATE SKIP LOCKED`
--   mechanism so that it skips past the events which are locked by the
--   database and pick newer undelivered events to achieve maximum
--   throughput.
--   
--   The locking mechanism for event triggers is timestamp based i.e. when
--   an event is fetched from the database, the <tt>locked</tt> column will
--   contain the timestamp of when it was fetched from the database.
--   Undelivered events will have <tt>NULL</tt> value as their
--   <tt>locked</tt> column value.
--   
--   The idea behind having a timestamp based locking mechanism is that if
--   the graphql-engine is shutdown abruptly with events being fetched by
--   the events processor, it will be locked and after the shutdown it will
--   remain locked. Now with a timestamp based lock, when the
--   graphql-engine is started again it will also fetch events which have a
--   <tt>locked</tt> value of older than 30 mins along with the undelivered
--   events. So, this way no events remain in a <tt>locked</tt> state.
--   
--   When fetching the events from the event_log table we also include the
--   list of the triggers that exist in the metadata at that point of time,
--   because we have seen in some cases there are events that do not belong
--   to any of the event triggers present in the metadata and those are
--   fetched only to be failed saying the said event trigger doesn't exist.
--   So, to avoid this (atleast, as much as possible) we get only the
--   events of the event triggers we have in the metadata.
fetchUndeliveredEvents :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> SourceName -> [TriggerName] -> MaintenanceMode () -> FetchBatchSize -> m [Event b]

-- | Ad-hoc function to set a retry for an undelivered event
setRetry :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> Event b -> UTCTime -> MaintenanceMode MaintenanceModeVersion -> m ()

-- | <tt>getMaintenanceModeVersion</tt> gets the source catalog version
--   from the source
getMaintenanceModeVersion :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> m MaintenanceModeVersion

-- | <tt>recordSuccess</tt> records a successful event invocation, it does
--   a couple of things,
--   
--   <ol>
--   <li>Insert the invocation in the invocation logs table</li>
--   <li>Mark the event as <tt>delivered</tt> in the event_log table</li>
--   </ol>
recordSuccess :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> Event b -> Invocation 'EventType -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())

-- | <tt>recordError</tt> records an erronous event invocation, it does a
--   couple of things,
--   
--   <ol>
--   <li>Insert the invocation in the invocation logs table</li>
--   <li>Depending on the value of <a>ProcessEventError</a>, it will
--   either, - Set a retry for the given event - Mark the event as
--   <a>error</a></li>
--   </ol>
recordError :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> Event b -> Invocation 'EventType -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())

-- | <tt>recordError'</tt> records an erronous event invocation, it does a
--   couple of things,
--   
--   <ol>
--   <li>If present, insert the invocation in the invocation logs
--   table</li>
--   <li>Depending on the value of <a>ProcessEventError</a>, it will
--   either, - Set a retry for the given event - Mark the event as
--   <a>error</a></li>
--   </ol>
recordError' :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> Event b -> Maybe (Invocation 'EventType) -> ProcessEventError -> MaintenanceMode MaintenanceModeVersion -> m (Either QErr ())

-- | <tt>dropTriggerAndArchiveEvents</tt> drops the database trigger and
--   marks all the events related to the event trigger as archived. See
--   Note [Cleanup for dropped triggers]
dropTriggerAndArchiveEvents :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerName -> TableName b -> m ()

-- | <tt>dropDanglingSQLTriggger</tt> is used to delete the extraneous SQL
--   triggers created by an event trigger. The extraneous SQL triggers can
--   be created when an event trigger's definition is replaced to a new
--   definition. For example, an event trigger <tt>authors_all</tt> had an
--   INSERT and UPDATE trigger defined earlier and after it has UPDATE and
--   DELETE triggers. So, in this case, we need to drop the trigger created
--   by us earlier for the INSERT trigger.
dropDanglingSQLTrigger :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerName -> TableName b -> HashSet Ops -> m ()
redeliverEvent :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> EventId -> m ()

-- | <tt>unlockEventsInSource</tt> unlocks the cached locked events which
--   were captured when a graceful shutdown is initiated, so that when the
--   graphql-engine restarts these events can be fetched to process them
--   immediately.
unlockEventsInSource :: (BackendEventTrigger b, MonadIO m) => SourceConfig b -> NESet EventId -> m (Either QErr Int)

-- | <tt>createMissingSQLTriggers</tt> checks in the source whether all the
--   triggers exist according to the event trigger's specification. If any
--   SQL trigger doesn't exist then it will create it.
createMissingSQLTriggers :: (BackendEventTrigger b, MonadIO m, MonadError QErr m, MonadBaseControl IO m, Backend b) => SQLGenCtx -> SourceConfig b -> TableName b -> ([ColumnInfo b], Maybe (PrimaryKey b (ColumnInfo b))) -> TriggerName -> TriggerOnReplication -> TriggerOpsDef b -> m ()
createTableEventTrigger :: (BackendEventTrigger b, MonadBaseControl IO m, MonadIO m, MonadError QErr m) => SQLGenCtx -> SourceConfig b -> TableName b -> [ColumnInfo b] -> TriggerName -> TriggerOnReplication -> TriggerOpsDef b -> Maybe (PrimaryKey b (ColumnInfo b)) -> m (Either QErr ())
checkIfTriggerExists :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerName -> HashSet Ops -> m Bool

-- | <tt>addCleanupSchedules</tt> adds cleanup logs for given trigger names
--   and cleanup configs. This will perform the following steps:
--   
--   <ol>
--   <li>Get last scheduled cleanup event and count.</li>
--   <li>If count is less than 5, then add add more cleanup logs, else do
--   nothing</li>
--   </ol>
addCleanupSchedules :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> [(TriggerName, AutoTriggerLogCleanupConfig)] -> m ()

-- | <tt>deleteAllScheduledCleanups</tt> deletes all scheduled cleanup logs
--   for a given event trigger
deleteAllScheduledCleanups :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerName -> m ()

-- | <tt>getCleanupEventsForDeletion</tt> returns the cleanup logs that are
--   to be deleted. This will perform the following steps:
--   
--   <ol>
--   <li>Get the scheduled cleanup events that were scheduled before
--   current time.</li>
--   <li>If there are multiple entries for the same trigger name with
--   different scheduled time, then fetch the latest entry and mark others
--   as dead.</li>
--   </ol>
getCleanupEventsForDeletion :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> m [(Text, TriggerName)]

-- | <tt>updateCleanupEventStatusToDead</tt> updates the event trigger
--   cleanup logs as dead
updateCleanupEventStatusToDead :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> [Text] -> m ()

-- | <tt>updateCleanupEventStatusToPaused</tt> updates the cleanup log
--   status to <tt>paused</tt> if the event trigger configuration is
--   paused.
updateCleanupEventStatusToPaused :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> Text -> m ()

-- | <tt>updateCleanupEventStatusToCompleted</tt> updates the cleanup log
--   status after the event logs are deleted. This will perform the
--   following steps:
--   
--   <ol>
--   <li>Updates the cleanup config status to <tt>completed</tt>.</li>
--   <li>Updates the number of event logs and event invocation logs that
--   were deleted for a trigger name</li>
--   </ol>
updateCleanupEventStatusToCompleted :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> Text -> DeletedEventLogStats -> m ()

-- | <tt>deleteEventTriggerLogs</tt> deletes the event logs (and event
--   invocation logs) based on the cleanup configuration given This will
--   perform the following steps:
--   
--   <ol>
--   <li>Select all the dead events based on criteria set in the cleanup
--   config.</li>
--   <li>Lock the events in the database so that other HGE instances don't
--   pick them up for deletion.</li>
--   <li>Based on the config, perform the delete action.</li>
--   </ol>
deleteEventTriggerLogs :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> TriggerLogCleanupConfig -> IO (Maybe (TriggerLogCleanupConfig, EventTriggerCleanupStatus)) -> m DeletedEventLogStats

-- | @fetchEventLogs fetches event logs from the source for a given event
--   trigger.
fetchEventLogs :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> GetEventLogs b -> m [EventLog]

-- | @fetchEventInvocationLogs fetches invocation logs from the source for
--   a given event trigger.
fetchEventInvocationLogs :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> GetEventInvocations b -> m [EventInvocationLog]

-- | @fetchEventById fetches the event and it's invocation logs from the
--   source for a given EventId.
fetchEventById :: (BackendEventTrigger b, MonadIO m, MonadError QErr m) => SourceConfig b -> GetEventById b -> m EventLogWithInvocations
instance Hasura.Eventing.Backend.BackendEventTrigger ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Vanilla)
instance Hasura.Eventing.Backend.BackendEventTrigger ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Citus)
instance Hasura.Eventing.Backend.BackendEventTrigger ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Cockroach)
instance Hasura.Eventing.Backend.BackendEventTrigger 'Hasura.RQL.Types.BackendType.MSSQL
instance Hasura.Eventing.Backend.BackendEventTrigger 'Hasura.RQL.Types.BackendType.BigQuery
instance Hasura.Eventing.Backend.BackendEventTrigger 'Hasura.RQL.Types.BackendType.DataConnector


-- | <h1>Event Triggers</h1>
--   
--   Event triggers are like ordinary SQL triggers, except instead of
--   calling a SQL procedure, they call a webhook. The event delivery
--   mechanism involves coordination between both the database and
--   graphql-engine: only the SQL database knows when the events should
--   fire, but only graphql-engine know how to actually deliver them.
--   
--   Therefore, event triggers are implemented in two parts:
--   
--   <ol>
--   <li>Every event trigger is backed by a bona fide SQL trigger. When the
--   SQL trigger fires, it creates a new record in the
--   hdb_catalog.event_log table.</li>
--   <li>Concurrently, a thread in graphql-engine monitors the
--   hdb_catalog.event_log table for new events. When new event(s) are
--   found, it uses the information (URL,payload and headers) stored in the
--   event to deliver the event to the webhook.</li>
--   </ol>
--   
--   The creation and deletion of SQL trigger itself is managed by the
--   metadata DDL APIs (see Hasura.RQL.DDL.EventTrigger), so this module
--   focuses on event delivery.
--   
--   Most of the subtleties involve guaranteeing reliable delivery of
--   events: we guarantee that every event will be delivered at least once,
--   even if graphql-engine crashes. This means we have to record the state
--   of each event in the database, and we have to retry failed requests at
--   a regular (user-configurable) interval.
module Hasura.Eventing.EventTrigger

-- | See Note [Maintenance Mode]
data EventEngineCtx
EventEngineCtx :: TVar Int -> DiffTime -> Refined NonNegative Int -> EventEngineCtx
[_eeCtxEventThreadsCapacity] :: EventEngineCtx -> TVar Int
[_eeCtxFetchInterval] :: EventEngineCtx -> DiffTime
[_eeCtxFetchSize] :: EventEngineCtx -> Refined NonNegative Int
defaultMaxEventThreads :: Refined Positive Int
defaultFetchInterval :: DiffTime
initEventEngineCtx :: MonadIO m => Refined Positive Int -> Refined NonNegative Milliseconds -> Refined NonNegative Int -> m EventEngineCtx
saveLockedEventTriggerEvents :: MonadIO m => SourceName -> [EventId] -> TVar (HashMap SourceName (Set EventId)) -> m ()
removeEventTriggerEventFromLockedEvents :: MonadIO m => SourceName -> EventId -> TVar (HashMap SourceName (Set EventId)) -> m ()

-- | Logger to accumulate stats of fetched events over a period of time and
--   log once using <tt>'L.Logger L.Hasura'. See
--   </tt><tt>createStatsLogger</tt> for more details.
createFetchedEventsStatsLogger :: MonadIO m => Logger Hasura -> m FetchedEventsStatsLogger

-- | Close the fetched events stats logger.
closeFetchedEventsStatsLogger :: MonadIO m => Logger Hasura -> FetchedEventsStatsLogger -> m ()

-- | Service events from our in-DB queue.
--   
--   There are a few competing concerns and constraints here; we want to...
--   - fetch events in batches for lower DB pressure - don't fetch more
--   than N at a time (since that can mean: space leak, less effective
--   scale out, possible double sends for events we've checked out on exit
--   (TODO clean shutdown procedure)) - try not to cause webhook workers to
--   stall waiting on DB fetch - limit webhook HTTP concurrency per
--   HASURA_GRAPHQL_EVENTS_HTTP_POOL_SIZE
processEventQueue :: forall m. (MonadIO m, MonadBaseControl IO m, Forall (Pure m), MonadMask m, MonadTrace m, MonadGetPolicies m) => Logger Hasura -> FetchedEventsStatsLogger -> Manager -> IO SchemaCache -> IO EventEngineCtx -> TVar Int -> LockedEventsCtx -> ServerMetrics -> EventTriggerMetrics -> MaintenanceMode () -> TriggersErrorLogLevelStatus -> m (Forever m)
logQErr :: (MonadReader r m, Has (Logger Hasura) r, MonadIO m) => QErr -> m ()
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.EventInternalErr
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.DeliveryInfo
instance GHC.Generics.Generic Hasura.Eventing.EventTrigger.DeliveryInfo
instance GHC.Show.Show Hasura.Eventing.EventTrigger.DeliveryInfo
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.QualifiedTableStrict
instance GHC.Show.Show Hasura.Eventing.EventTrigger.QualifiedTableStrict
instance GHC.Generics.Generic (Hasura.Eventing.EventTrigger.EventPayload b)
instance GHC.Num.Num Hasura.Eventing.EventTrigger.EventsCount
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Eventing.EventTrigger.EventsCount
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.EventsCount
instance GHC.Show.Show Hasura.Eventing.EventTrigger.EventsCount
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.EventsCount
instance GHC.Show.Show Hasura.Eventing.EventTrigger.NumEventsFetchedPerSource
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.NumEventsFetchedPerSource
instance GHC.Show.Show Hasura.Eventing.EventTrigger.FetchedEventsStats
instance GHC.Generics.Generic Hasura.Eventing.EventTrigger.FetchedEventsStats
instance GHC.Classes.Eq Hasura.Eventing.EventTrigger.FetchedEventsStats
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Eventing.EventTrigger.EventPayload b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Eventing.EventTrigger.EventPayload b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.FetchedEventsStats
instance Hasura.Logging.ToEngineLog Hasura.Eventing.EventTrigger.FetchedEventsStats Hasura.Logging.Hasura
instance GHC.Base.Semigroup Hasura.Eventing.EventTrigger.FetchedEventsStats
instance GHC.Base.Monoid Hasura.Eventing.EventTrigger.FetchedEventsStats
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.NumEventsFetchedPerSource
instance GHC.Base.Semigroup Hasura.Eventing.EventTrigger.NumEventsFetchedPerSource
instance GHC.Base.Monoid Hasura.Eventing.EventTrigger.NumEventsFetchedPerSource
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Eventing.EventTrigger.EventPayload b)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.QualifiedTableStrict
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Eventing.EventTrigger.DeliveryInfo
instance Hasura.Logging.ToEngineLog Hasura.Eventing.EventTrigger.EventInternalErr Hasura.Logging.Hasura

module Hasura.RQL.DDL.EventTrigger
data CreateEventTriggerQuery (b :: BackendType)
cteqTriggerOnReplication :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) TriggerOnReplication
cteqCleanupConfig :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (Maybe AutoTriggerLogCleanupConfig)
cetqWebhookFromEnv :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (Maybe Text)
cetqWebhook :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (Maybe InputWebhook)
cetqUpdate :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (Maybe (SubscribeOpSpec b_atdit))
cetqTable :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (TableName b_atdit)
cetqSource :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) SourceName
cetqRetryConf :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (Maybe RetryConf)
cetqResponseTrasnform :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (Maybe MetadataResponseTransform)
cetqRequestTransform :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (Maybe RequestTransform)
cetqReplace :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) Bool
cetqName :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) TriggerName
cetqInsert :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (Maybe (SubscribeOpSpec b_atdit))
cetqHeaders :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (Maybe [HeaderConf])
cetqEnableManual :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (Maybe Bool)
cetqDelete :: forall b_atdit. Lens' (CreateEventTriggerQuery b_atdit) (Maybe (SubscribeOpSpec b_atdit))
data DeleteEventTriggerQuery (b :: BackendType)
data RedeliverEventQuery (b :: BackendType)
data InvokeEventTriggerQuery (b :: BackendType)

-- | This typeclass have the implementation logic for the event trigger log
--   cleanup.
--   
--   TODO: this doesn't belong here in the DDL folder, but should be part
--   of Hasura.Eventing. It could even be made a Service, since the whole
--   point of it is to implement features differently between OSS and Pro.
class (Monad m) => MonadEventLogCleanup m
runLogCleaner :: MonadEventLogCleanup m => SourceCache -> TriggerLogCleanupConfig -> m (Either QErr EncJSON)
generateCleanupSchedules :: MonadEventLogCleanup m => AnyBackend SourceInfo -> TriggerName -> AutoTriggerLogCleanupConfig -> m (Either QErr ())

-- | <a>updateTriggerCleanupSchedules</a> is primarily used to update the
--   cleanup schedules associated with an event trigger in case the cleanup
--   config has changed while replacing the metadata.
--   
--   In case, i. a source has been dropped - We don't need to clear the
--   cleanup schedules because the event log cleanup table is dropped as
--   part of the post drop source hook. ii. a table or an event trigger has
--   been dropped/updated - Older cleanup events will be deleted first and
--   in case of an update, new cleanup events will be generated and
--   inserted into the table. iii. a new event trigger with cleanup config
--   has been added - Generate the cleanup events and insert it. iv. a new
--   source has been added - Generate the cleanup events and insert it. v.
--   the cron schedule for event trigger cleanup config has changed -
--   Delete cleanup events with older cron schedule and generate cleanup
--   events with new cron schedule.
updateTriggerCleanupSchedules :: MonadEventLogCleanup m => Logger Hasura -> InsOrdHashMap SourceName BackendSourceMetadata -> InsOrdHashMap SourceName BackendSourceMetadata -> SchemaCache -> m (Either QErr ())
runCreateEventTriggerQuery :: forall b m r. (BackendMetadata b, BackendEventTrigger b, QErrM m, UserInfoM m, CacheRWM m, MetadataM m, MonadIO m, MonadEventLogCleanup m, MonadReader r m, Has (Logger Hasura) r) => CreateEventTriggerQuery b -> m EncJSON
runDeleteEventTriggerQuery :: forall b m. (BackendEventTrigger b, MonadError QErr m, CacheRWM m, MonadIO m, MetadataM m) => DeleteEventTriggerQuery b -> m EncJSON
runRedeliverEvent :: forall b m. (BackendEventTrigger b, MonadIO m, CacheRM m, QErrM m, MetadataM m) => RedeliverEventQuery b -> m EncJSON
runInvokeEventTrigger :: forall b m. (MonadIO m, QErrM m, CacheRM m, MetadataM m, MonadTrace m, UserInfoM m, BackendEventTrigger b) => InvokeEventTriggerQuery b -> m EncJSON
newtype ResolveHeaderError
ResolveHeaderError :: [Text] -> ResolveHeaderError
[unResolveHeaderError] :: ResolveHeaderError -> [Text]
getHeaderInfosFromConf :: QErrM m => Environment -> [HeaderConf] -> m [EventHeaderInfo]
getHeaderInfosFromConfEither :: Environment -> [HeaderConf] -> Either ResolveHeaderError [EventHeaderInfo]
getWebhookInfoFromConf :: QErrM m => Environment -> WebhookConf -> m WebhookConfInfo
buildEventTriggerInfo :: forall b m. (Backend b, QErrM m) => Environment -> SourceName -> TableName b -> EventTriggerConf b -> m (EventTriggerInfo b, Seq SchemaDependency)
getTriggersMap :: SourceMetadata b -> InsOrdHashMap TriggerName (EventTriggerConf b)
getSourceTableAndTriggers :: SourceMetadata b -> [(TableName b, TriggerName)]
getTriggerNames :: SourceMetadata b -> HashSet TriggerName
getTableNameFromTrigger :: forall b. Backend b => SchemaCache -> SourceName -> TriggerName -> Maybe (TableName b)
runCleanupEventTriggerLog :: (MonadEventLogCleanup m, MonadError QErr m, CacheRWM m) => TriggerLogCleanupConfig -> m EncJSON
runEventTriggerResumeCleanup :: forall m. (MonadIO m, QErrM m, CacheRWM m, MetadataM m) => TriggerLogCleanupToggleConfig -> m EncJSON
runEventTriggerPauseCleanup :: (MonadError QErr m, CacheRWM m, MonadIO m, MetadataM m) => TriggerLogCleanupToggleConfig -> m EncJSON

-- | Collects and returns all the event triggers with cleanup config
getAllEventTriggersWithCleanupConfig :: TableInfo b -> [(TriggerName, AutoTriggerLogCleanupConfig)]
getAllETWithCleanupConfigInTableMetadata :: TableMetadata b -> [(TriggerName, AutoTriggerLogCleanupConfig)]
runGetEventLogs :: forall b m. (MonadIO m, CacheRM m, MonadError QErr m, BackendEventTrigger b, MetadataM m) => GetEventLogs b -> m EncJSON
runGetEventInvocationLogs :: forall b m. (MonadIO m, CacheRM m, MonadError QErr m, BackendEventTrigger b, MetadataM m) => GetEventInvocations b -> m EncJSON
runGetEventById :: forall b m. (MonadIO m, CacheRM m, MonadError QErr m, BackendEventTrigger b, MetadataM m) => GetEventById b -> m EncJSON
instance GHC.Show.Show Hasura.RQL.DDL.EventTrigger.ResolveHeaderError
instance Data.Text.Extended.ToTxt Hasura.RQL.DDL.EventTrigger.ResolveHeaderError
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Hasura.RQL.Types.SchemaCache.Build.MetadataT m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Hasura.Tracing.Monad.TraceT m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Control.Monad.Trans.State.Strict.StateT w m)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.InvokeEventTriggerQuery b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.RedeliverEventQuery b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.DeleteEventTriggerQuery b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.EventTrigger.CreateEventTriggerQuery b)


-- | <h1>Scheduled Triggers</h1>
--   
--   This module implements the functionality of invoking webhooks during
--   specified time events aka scheduled events. The scheduled events are
--   the events generated by the graphql-engine using the cron triggers
--   or/and a scheduled event can be created by the user at a specified
--   time with the payload, webhook, headers and the retry configuration.
--   Scheduled events are modeled using rows in Postgres with a
--   <tt>timestamp</tt> column.
--   
--   This module implements scheduling and delivery of scheduled events:
--   
--   <ol>
--   <li>Scheduling a cron event involves creating new cron events. New
--   cron events are created based on the cron schedule and the number of
--   scheduled events that are already present in the scheduled events
--   buffer. The graphql-engine computes the new scheduled events and
--   writes them to the database.(Generator)</li>
--   <li>Delivering a scheduled event involves reading undelivered
--   scheduled events from the database and delivering them to the webhook
--   server. (Processor)</li>
--   </ol>
--   
--   The rationale behind separating the event scheduling and event
--   delivery mechanism into two different threads is that the scheduling
--   and delivering of the scheduled events are not directly dependent on
--   each other. The generator will almost always try to create scheduled
--   events which are supposed to be delivered in the future (timestamp
--   &gt; current_timestamp) and the processor will fetch scheduled events
--   of the past (timestamp &lt; current_timestamp). So, the set of the
--   scheduled events generated by the generator and the processor will
--   never be the same. The point here is that they're not correlated to
--   each other. They can be split into different threads for a better
--   performance.
--   
--   <h2>Implementation</h2>
--   
--   The scheduled triggers eventing is being implemented in the metadata
--   storage. All functions that make interaction to storage system are
--   abstracted in the @<a>MonadMetadataStorage</a> class.
--   
--   During the startup, two threads are started:
--   
--   <ol>
--   <li>Generator: Fetches the list of scheduled triggers from cache and
--   generates the scheduled events.<ul><li>Additional events will be
--   generated only if there are fewer than 100 scheduled
--   events.</li><li>The upcoming events timestamp will be generated
--   using:<ul><li>cron schedule of the scheduled trigger</li><li>max
--   timestamp of the scheduled events that already exist or
--   current_timestamp(when no scheduled events exist)</li><li>The
--   timestamp of the scheduled events is stored with timezone because
--   `SELECT NOW()` returns timestamp with timezone, so it's good to
--   compare two things of the same type.</li></ul></li></ul>This
--   effectively corresponds to doing an INSERT with values containing
--   specific timestamp.</li>
--   <li>Processor: Fetches the undelivered cron events and the scheduled
--   events from the database and which have timestamp lesser than the
--   current timestamp and then process them.</li>
--   </ol>
--   
--   TODO - Consider and document ordering guarantees - do we have any in
--   the presence of multiple hasura instances? - If we have nothing useful
--   to say about ordering, then consider processing events asynchronously,
--   so that a slow webhook doesn't cause everything subsequent to be
--   delayed
module Hasura.Eventing.ScheduledTrigger

-- | runCronEventsGenerator makes sure that all the cron triggers have an
--   adequate buffer of cron events.
runCronEventsGenerator :: (MonadIO m, MonadMetadataStorage m) => Logger Hasura -> FetchedCronTriggerStatsLogger -> IO SchemaCache -> m void
processScheduledTriggers :: (MonadIO m, MonadTrace m, MonadMetadataStorage m, MonadBaseControl IO m) => IO Environment -> Logger Hasura -> FetchedScheduledEventsStatsLogger -> Manager -> ScheduledTriggerMetrics -> IO SchemaCache -> LockedEventsCtx -> TriggersErrorLogLevelStatus -> m (Forever m)

-- | Get cron trigger stats for cron jobs with fewer than 100 future
--   reified events in the database
--   
--   The point here is to maintain a certain number of future events so the
--   user can kind of see what's coming up, and obviously to give
--   <a>processCronEvents</a> something to do.
getDeprivedCronTriggerStatsTx :: [TriggerName] -> TxE QErr [CronTriggerStats]
getScheduledEventsForDeliveryTx :: [TriggerName] -> TxE QErr ([CronEvent], [OneOffScheduledEvent])
insertInvocationTx :: Invocation 'ScheduledType -> ScheduledEventType -> TxE QErr ()
setScheduledEventOpTx :: ScheduledEventId -> ScheduledEventOp -> ScheduledEventType -> TxE QErr ()
unlockScheduledEventsTx :: ScheduledEventType -> [ScheduledEventId] -> TxE QErr Int
unlockAllLockedScheduledEventsTx :: TxE QErr ()
insertCronEventsTx :: [CronEventSeed] -> TxE QErr ()
insertOneOffScheduledEventTx :: OneOffEvent -> TxE QErr EventId
dropFutureCronEventsTx :: ClearCronEvents -> TxE QErr ()
mkScheduledEventStatusFilter :: [ScheduledEventStatus] -> BoolExp
scheduledTimeOrderBy :: OrderByExp

-- | Build a select expression which outputs total count and list of json
--   rows with pagination limit and offset applied
mkPaginationSelectExp :: Select -> ScheduledEventPagination -> RowsCountOption -> Select
withCount :: (Int, ViaJSON a) -> WithOptionalTotalCount a
executeWithOptionalTotalCount :: FromJSON a => Query -> RowsCountOption -> TxE QErr (WithOptionalTotalCount a)
getOneOffScheduledEventsTx :: ScheduledEventPagination -> [ScheduledEventStatus] -> RowsCountOption -> TxE QErr (WithOptionalTotalCount [OneOffScheduledEvent])
getCronEventsTx :: TriggerName -> ScheduledEventPagination -> [ScheduledEventStatus] -> RowsCountOption -> TxE QErr (WithOptionalTotalCount [CronEvent])
deleteScheduledEventTx :: ScheduledEventId -> ScheduledEventType -> TxE QErr ()
invocationFieldExtractors :: QualifiedTable -> [Extractor]
mkEventIdBoolExp :: QualifiedTable -> EventId -> BoolExp
getScheduledEventInvocationsTx :: GetScheduledEventInvocations -> TxE QErr (WithOptionalTotalCount [ScheduledEventInvocation])
data EventTables
EventTables :: QualifiedTable -> QualifiedTable -> QualifiedTable -> EventTables
[etOneOffInvocationsTable] :: EventTables -> QualifiedTable
[etCronInvocationsTable] :: EventTables -> QualifiedTable
[etCronEventsTable] :: EventTables -> QualifiedTable
getScheduledEventsInvocationsQueryNoPagination :: EventTables -> GetScheduledEventInvocationsBy -> Select
getScheduledEventsInvocationsQuery :: EventTables -> GetScheduledEventInvocations -> Select

-- | Logger to accumulate stats of fetched scheduled events over a period
--   of time and log once using <tt>'L.Logger L.Hasura'. See
--   </tt><tt>createStatsLogger</tt> for more details.
createFetchedScheduledEventsStatsLogger :: MonadIO m => Logger Hasura -> m FetchedScheduledEventsStatsLogger

-- | Close the fetched scheduled events stats logger.
closeFetchedScheduledEventsStatsLogger :: MonadIO m => Logger Hasura -> FetchedScheduledEventsStatsLogger -> m ()

-- | Logger to accumulate stats of fetched cron triggers, for generating
--   cron events, over a period of time and log once using <tt>'L.Logger
--   L.Hasura'. See </tt><tt>createStatsLogger</tt> for more details.
createFetchedCronTriggerStatsLogger :: MonadIO m => Logger Hasura -> m FetchedCronTriggerStatsLogger

-- | Close the fetched cron trigger stats logger.
closeFetchedCronTriggersStatsLogger :: MonadIO m => Logger Hasura -> FetchedCronTriggerStatsLogger -> m ()

module Hasura.RQL.DDL.ScheduledTrigger
populateInitialCronTriggerEvents :: (MonadIO m, MonadError QErr m, MonadMetadataStorage m) => CronSchedule -> TriggerName -> m ()

-- | runCreateCronTrigger will update a existing cron trigger when the
--   <tt>replace</tt> value is set to <tt>true</tt> and when replace is
--   <tt>false</tt> a new cron trigger will be created
runCreateCronTrigger :: (MonadError QErr m, CacheRWM m, MonadIO m, MetadataM m, MonadMetadataStorage m) => CreateCronTrigger -> m EncJSON
resolveCronTrigger :: QErrM m => Environment -> CronTriggerMetadata -> m CronTriggerInfo
runDeleteCronTrigger :: (MonadError QErr m, CacheRWM m, MetadataM m, MonadMetadataStorage m) => ScheduledTriggerName -> m EncJSON
dropCronTriggerInMetadata :: TriggerName -> MetadataModifier
runCreateScheduledEvent :: (MonadError QErr m, MonadMetadataStorage m) => CreateScheduledEvent -> m EncJSON
runDeleteScheduledEvent :: (MonadMetadataStorage m, MonadError QErr m) => DeleteScheduledEvent -> m EncJSON
runGetScheduledEvents :: (MonadError QErr m, CacheRM m, MonadMetadataStorage m) => GetScheduledEvents -> m EncJSON
runGetScheduledEventInvocations :: (MonadError QErr m, CacheRM m, MonadMetadataStorage m) => GetScheduledEventInvocations -> m EncJSON

-- | Metadata API handler to retrieve all the cron triggers from the
--   metadata
runGetCronTriggers :: MetadataM m => m EncJSON


-- | MSSQL Source
--   
--   Implements the Source related methods of the <a>BackendMetadata</a>
--   type class for the MSSQL backend, which provides an interface for
--   identifying the MSSQL database instance (source) and manipulate it.
--   
--   The actual instance is defined in
--   <a>Hasura.Backends.MSSQL.Instances.Metadata</a>.
module Hasura.Backends.MSSQL.DDL.Source
resolveSourceConfig :: (MonadIO m, MonadResolveSource m) => SourceName -> MSSQLConnConfiguration -> BackendSourceKind 'MSSQL -> BackendConfig 'MSSQL -> Environment -> manager -> m (Either QErr MSSQLSourceConfig)
resolveDatabaseMetadata :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> m (Either QErr (DBObjectsIntrospection 'MSSQL))
postDropSourceHook :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> TableEventTriggers 'MSSQL -> m ()

-- | Initialise catalog tables for a source, including those required by
--   the event delivery subsystem.
prepareCatalog :: (MonadIO m, MonadBaseControl IO m) => MSSQLSourceConfig -> ExceptT QErr m (RecreateEventTriggers, SourceCatalogMigrationState)


-- | MSSQL DDL
--   
--   Implements the DDL related methods of the <a>BackendMetadata</a> type
--   class for the MSSQL backend, which provides an interface for fetching
--   information about the objects in the database, such as tables,
--   relationships, etc.
--   
--   The actual instance is defined in
--   <a>Hasura.Backends.MSSQL.Instances.Metadata</a>.
module Hasura.Backends.MSSQL.DDL
buildComputedFieldInfo :: MonadError QErr m => HashSet (TableName 'MSSQL) -> TableName 'MSSQL -> HashSet (Column 'MSSQL) -> ComputedFieldName -> ComputedFieldDefinition 'MSSQL -> RawFunctionInfo 'MSSQL -> Comment -> m (ComputedFieldInfo 'MSSQL)
fetchAndValidateEnumValues :: Monad m => SourceConfig 'MSSQL -> TableName 'MSSQL -> Maybe (PrimaryKey 'MSSQL (RawColumnInfo 'MSSQL)) -> [RawColumnInfo 'MSSQL] -> m (Either QErr EnumValues)
buildFunctionInfo :: MonadError QErr m => SourceName -> FunctionName 'MSSQL -> SystemDefined -> FunctionConfig 'MSSQL -> FunctionPermissionsMap -> RawFunctionInfo 'MSSQL -> Maybe Text -> NamingCase -> m (FunctionInfo 'MSSQL, SchemaDependency)
updateColumnInEventTrigger :: TableName 'MSSQL -> Column 'MSSQL -> Column 'MSSQL -> TableName 'MSSQL -> EventTriggerConf 'MSSQL -> EventTriggerConf 'MSSQL
parseCollectableType :: MonadError QErr m => CollectableType (ColumnType 'MSSQL) -> Value -> m (PartialSQLExp 'MSSQL)
getStoredProcedureGraphqlName :: MonadError QErr m => FunctionName -> StoredProcedureConfig -> m Name


-- | MSSQL Instances Metadata
--   
--   Defines a <a>BackendMetadata</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.Metadata
instance Hasura.RQL.Types.Metadata.Backend.BackendMetadata 'Hasura.RQL.Types.BackendType.MSSQL

module Hasura.Backends.DataConnector.Logging
logAgentRequest :: (MonadIO m, MonadTrace m) => Logger Hasura -> Request -> Either HttpException (Response ByteString) -> m ()
logClientError :: (MonadIO m, MonadTrace m) => Logger Hasura -> ClientError -> m ()
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Logging.RequestLogInfo
instance GHC.Show.Show Hasura.Backends.DataConnector.Logging.RequestLogInfo
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Logging.AgentCommunicationLog
instance GHC.Show.Show Hasura.Backends.DataConnector.Logging.AgentCommunicationLog
instance Hasura.Logging.ToEngineLog Hasura.Backends.DataConnector.Logging.AgentCommunicationLog Hasura.Logging.Hasura

module Hasura.Backends.DataConnector.Agent.Client

-- | Auth Key provided to the GDC Agent in <a>Request</a> headers.
newtype AgentLicenseKey
AgentLicenseKey :: ByteString -> AgentLicenseKey
[unAgentLicenseKey] :: AgentLicenseKey -> ByteString
data AgentClientContext
AgentClientContext :: Logger Hasura -> BaseUrl -> Manager -> Maybe Int -> Maybe AgentLicenseKey -> AgentClientContext
[_accLogger] :: AgentClientContext -> Logger Hasura
[_accBaseUrl] :: AgentClientContext -> BaseUrl
[_accHttpManager] :: AgentClientContext -> Manager
[_accResponseTimeout] :: AgentClientContext -> Maybe Int
[_accAgentLicenseKey] :: AgentClientContext -> Maybe AgentLicenseKey
data AgentClientT m a
runAgentClientT :: AgentClientT m a -> AgentClientContext -> m a
capabilities :: (MonadIO m, MonadTrace m, MonadError QErr m) => AgentClientT m CapabilitiesResponse
schema :: (MonadIO m, MonadTrace m, MonadError QErr m) => SourceName -> Config -> SchemaRequest -> AgentClientT m SchemaResponse
query :: (MonadIO m, MonadTrace m, MonadError QErr m) => SourceName -> Config -> QueryRequest -> AgentClientT m QueryResponse
explain :: (MonadIO m, MonadTrace m, MonadError QErr m) => SourceName -> Config -> QueryRequest -> AgentClientT m ExplainResponse
mutation :: (MonadIO m, MonadTrace m, MonadError QErr m) => SourceName -> Config -> MutationRequest -> AgentClientT m MutationResponse
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)
instance (Control.Monad.IO.Class.MonadIO m, Hasura.Tracing.Class.MonadTrace m, Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr m) => Servant.Client.Core.RunClient.RunClient (Hasura.Backends.DataConnector.Agent.Client.AgentClientT m)


-- | This module provides operations to load and modify metadata relating
--   to GraphQL Data Connectors.
module Hasura.RQL.DDL.DataConnector
data DCAddAgent
DCAddAgent :: DataConnectorName -> BaseUrl -> Maybe Text -> SkipCheck -> DCAddAgent

-- | Source kind, ie., the backend type.
[_gdcaName] :: DCAddAgent -> DataConnectorName

-- | The Agent URL.
[_gdcaUrl] :: DCAddAgent -> BaseUrl

-- | Override the display name provided by the Agent.
[_gdcaDisplayName] :: DCAddAgent -> Maybe Text

-- | Optionally skip the Agent Validation step.
[_gdcaSkipCheck] :: DCAddAgent -> SkipCheck

-- | Insert a new Data Connector Agent into Metadata.
runAddDataConnectorAgent :: (MetadataM m, ProvidesNetwork m, CacheRWM m, Has (Logger Hasura) r, MonadReader r m, MonadError QErr m, MonadIO m, MonadBaseControl IO m) => DCAddAgent -> m EncJSON
newtype DCDeleteAgent
DCDeleteAgent :: DataConnectorName -> DCDeleteAgent
[_dcdaName] :: DCDeleteAgent -> DataConnectorName

-- | Delete a Data Connector Agent from the Metadata.
runDeleteDataConnectorAgent :: (CacheRWM m, MetadataM m, MonadError QErr m) => DCDeleteAgent -> m EncJSON
instance GHC.Base.Monoid Hasura.RQL.DDL.DataConnector.SkipCheck
instance GHC.Base.Semigroup Hasura.RQL.DDL.DataConnector.SkipCheck
instance GHC.Classes.Eq Hasura.RQL.DDL.DataConnector.SkipCheck
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.DataConnector.SkipCheck
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.DataConnector.SkipCheck
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.DataConnector.DCDeleteAgent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.DataConnector.DCDeleteAgent
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.DataConnector.DCAddAgent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.DataConnector.DCAddAgent

module Hasura.Backends.DataConnector.Adapter.Metadata
requestDatabaseSchema :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => Logger Hasura -> SourceName -> SourceConfig -> SchemaRequest -> m SchemaResponse
instance Hasura.RQL.Types.Metadata.Backend.BackendMetadata 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.RQL.Types.Metadata.Instances


-- | Telemetry types
--   
--   Define anonymized metrics regarding usage of various features of
--   Hasura.
module Hasura.Server.Telemetry.Types
data RelationshipMetric
RelationshipMetric :: Int -> Int -> RelationshipMetric
[_rmManual] :: RelationshipMetric -> Int
[_rmAuto] :: RelationshipMetric -> Int
data PermissionMetric
PermissionMetric :: Int -> Int -> Int -> Int -> Int -> PermissionMetric
[_pmSelect] :: PermissionMetric -> Int
[_pmInsert] :: PermissionMetric -> Int
[_pmUpdate] :: PermissionMetric -> Int
[_pmDelete] :: PermissionMetric -> Int
[_pmRoles] :: PermissionMetric -> Int
data ActionMetric
ActionMetric :: Int -> Int -> Int -> Int -> Int -> ActionMetric
[_amSynchronous] :: ActionMetric -> Int
[_amAsynchronous] :: ActionMetric -> Int
[_amQueryActions] :: ActionMetric -> Int
[_amTypeRelationships] :: ActionMetric -> Int
[_amCustomTypes] :: ActionMetric -> Int
data NativeQueriesMetrics
NativeQueriesMetrics :: Int -> Int -> NativeQueriesMetrics
[_nqmWithParameters] :: NativeQueriesMetrics -> Int
[_nqmWithoutParameters] :: NativeQueriesMetrics -> Int
data StoredProceduresMetrics
StoredProceduresMetrics :: Int -> Int -> StoredProceduresMetrics
[_spmWithParameters] :: StoredProceduresMetrics -> Int
[_spmWithoutParameters] :: StoredProceduresMetrics -> Int
newtype LogicalModelsMetrics
LogicalModelsMetrics :: Int -> LogicalModelsMetrics
[_lmmCount] :: LogicalModelsMetrics -> Int
data Metrics
Metrics :: Int -> Int -> Int -> RelationshipMetric -> PermissionMetric -> Int -> Int -> Maybe Int -> Maybe ServiceTimingMetrics -> Maybe ActionMetric -> NativeQueriesMetrics -> StoredProceduresMetrics -> LogicalModelsMetrics -> Metrics
[_mtTables] :: Metrics -> Int
[_mtViews] :: Metrics -> Int
[_mtEnumTables] :: Metrics -> Int
[_mtRelationships] :: Metrics -> RelationshipMetric
[_mtPermissions] :: Metrics -> PermissionMetric
[_mtEventTriggers] :: Metrics -> Int
[_mtFunctions] :: Metrics -> Int
[_mtRemoteSchemas] :: Metrics -> Maybe Int
[_mtServiceTimings] :: Metrics -> Maybe ServiceTimingMetrics
[_mtActions] :: Metrics -> Maybe ActionMetric
[_mtNativeQueries] :: Metrics -> NativeQueriesMetrics
[_mtStoredProcedures] :: Metrics -> StoredProceduresMetrics
[_mtLogicalModels] :: Metrics -> LogicalModelsMetrics
data SourceMetadata
SourceMetadata :: Maybe DbUid -> BackendType -> Text -> Maybe DbVersion -> SourceMetadata
[_smDbUid] :: SourceMetadata -> Maybe DbUid
[_smBackendType] :: SourceMetadata -> BackendType
[_smDbKind] :: SourceMetadata -> Text
[_smDbVersion] :: SourceMetadata -> Maybe DbVersion
data HasuraTelemetry
HasuraTelemetry :: MetadataDbId -> InstanceId -> Version -> Maybe CI -> SourceMetadata -> Metrics -> HashSet ExperimentalFeature -> HasuraTelemetry
[_htMetadataDbUid] :: HasuraTelemetry -> MetadataDbId
[_htInstanceUid] :: HasuraTelemetry -> InstanceId
[_htHasuraVersion] :: HasuraTelemetry -> Version
[_htCi] :: HasuraTelemetry -> Maybe CI
[_htSourceMetadata] :: HasuraTelemetry -> SourceMetadata
[_htMetrics] :: HasuraTelemetry -> Metrics
[_htExperimentalFeatures] :: HasuraTelemetry -> HashSet ExperimentalFeature

-- | The telemetry table to which we'll add telemetry.
newtype Topic
Topic :: Text -> Topic
[getTopic] :: Topic -> Text
data TelemetryPayload
TelemetryPayload :: Topic -> HasuraTelemetry -> TelemetryPayload
[_tpTopic] :: TelemetryPayload -> Topic
[_tpData] :: TelemetryPayload -> HasuraTelemetry
instance GHC.Generics.Generic Hasura.Server.Telemetry.Types.RelationshipMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.RelationshipMetric
instance GHC.Show.Show Hasura.Server.Telemetry.Types.RelationshipMetric
instance GHC.Generics.Generic Hasura.Server.Telemetry.Types.PermissionMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.PermissionMetric
instance GHC.Show.Show Hasura.Server.Telemetry.Types.PermissionMetric
instance GHC.Generics.Generic Hasura.Server.Telemetry.Types.ActionMetric
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.ActionMetric
instance GHC.Show.Show Hasura.Server.Telemetry.Types.ActionMetric
instance GHC.Generics.Generic Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance GHC.Show.Show Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance GHC.Generics.Generic Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance GHC.Show.Show Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance GHC.Base.Monoid Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance GHC.Base.Semigroup Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance GHC.Generics.Generic Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance GHC.Show.Show Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance GHC.Generics.Generic Hasura.Server.Telemetry.Types.Metrics
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.Metrics
instance GHC.Show.Show Hasura.Server.Telemetry.Types.Metrics
instance GHC.Generics.Generic Hasura.Server.Telemetry.Types.SourceMetadata
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.SourceMetadata
instance GHC.Show.Show Hasura.Server.Telemetry.Types.SourceMetadata
instance GHC.Generics.Generic Hasura.Server.Telemetry.Types.HasuraTelemetry
instance GHC.Show.Show Hasura.Server.Telemetry.Types.HasuraTelemetry
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.Telemetry.Types.Topic
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.Topic
instance GHC.Classes.Eq Hasura.Server.Telemetry.Types.Topic
instance GHC.Show.Show Hasura.Server.Telemetry.Types.Topic
instance GHC.Generics.Generic Hasura.Server.Telemetry.Types.TelemetryPayload
instance GHC.Show.Show Hasura.Server.Telemetry.Types.TelemetryPayload
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.TelemetryPayload
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.HasuraTelemetry
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.SourceMetadata
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.Metrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.LogicalModelsMetrics
instance GHC.Base.Semigroup Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance GHC.Base.Monoid Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.StoredProceduresMetrics
instance GHC.Base.Semigroup Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance GHC.Base.Monoid Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.NativeQueriesMetrics
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.ActionMetric
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.PermissionMetric
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.Types.RelationshipMetric


-- | <h1>Remote Schema Permissions Validation</h1>
--   
--   This module parses the GraphQL IDL (Schema Document) that's provided
--   by the user for configuring permissions for remote schemas to a schema
--   introspection object, which is then used to construct the remote
--   schema for the particular role.
--   
--   This module does two things essentially:
--   
--   <ol>
--   <li>Checks if the given schema document is a subset of the upstream
--   remote schema document. This is done by checking if all the objects,
--   interfaces, unions, enums, scalars and input objects provided in the
--   schema document exist in the upstream remote schema too. We validate
--   the fields, directives and arguments too, wherever applicable.</li>
--   <li>Parse the <tt>preset</tt> directives (if any) on input object
--   fields or argument fields. A <tt>preset</tt> directive is used to
--   specify any preset argument on a field, it can be either a static
--   value or session variable value. There is some validation done on
--   preset directives. For example: - Preset directives can only be
--   specified at <tt>ARGUMENT_DEFINITION</tt> or
--   <tt>INPUT_FIELD_DEFINITION</tt> - A field expecting object cannot have
--   a scalar/enum preset directive and vice versa.</li>
--   </ol>
--   
--   If a preset directive value is a session variable (like `x-hasura-*`),
--   then it's considered to be a session variable value. In the case, the
--   user wants to treat the session variable value literally, they can add
--   the <tt>static</tt> key to the preset directive to indicate that the
--   value provided should be considered literally. For example:
--   
--   `user(id: Int @preset(value: "x-hasura-user-id", static: true))
--   
--   In this case `x-hasura-user-id` will be considered literally.
--   
--   For validation, we use the <a>MonadValidate</a> monad transformer to
--   collect as many errors as possible and then report all those errors at
--   one go to the user.
module Hasura.RemoteSchema.SchemaCache.Permission
resolveRoleBasedRemoteSchema :: MonadError QErr m => RoleName -> RemoteSchemaName -> IntrospectionResult -> SchemaDocument -> m (IntrospectionResult, SchemaDependency)
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Permission.FieldDefinitionType
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Permission.FieldDefinitionType
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Permission.ArgumentDefinitionType
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Permission.ArgumentDefinitionType
instance GHC.Classes.Ord Hasura.RemoteSchema.SchemaCache.Permission.PresetInputTypeInfo
instance GHC.Generics.Generic Hasura.RemoteSchema.SchemaCache.Permission.PresetInputTypeInfo
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Permission.PresetInputTypeInfo
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Permission.PresetInputTypeInfo
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Permission.GraphQLType
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Permission.GraphQLType
instance GHC.Classes.Eq Hasura.RemoteSchema.SchemaCache.Permission.RoleBasedSchemaValidationError
instance GHC.Show.Show Hasura.RemoteSchema.SchemaCache.Permission.RoleBasedSchemaValidationError
instance Data.Text.Extended.ToTxt Hasura.RemoteSchema.SchemaCache.Permission.GraphQLType
instance Data.Text.Extended.ToTxt Hasura.RemoteSchema.SchemaCache.Permission.ArgumentDefinitionType
instance Data.Text.Extended.ToTxt Hasura.RemoteSchema.SchemaCache.Permission.FieldDefinitionType

module Hasura.RemoteSchema.MetadataAPI.Permission
data AddRemoteSchemaPermission
AddRemoteSchemaPermission :: RemoteSchemaName -> RoleName -> RemoteSchemaPermissionDefinition -> Maybe Text -> AddRemoteSchemaPermission
[_arspRemoteSchema] :: AddRemoteSchemaPermission -> RemoteSchemaName
[_arspRole] :: AddRemoteSchemaPermission -> RoleName
[_arspDefinition] :: AddRemoteSchemaPermission -> RemoteSchemaPermissionDefinition
[_arspComment] :: AddRemoteSchemaPermission -> Maybe Text
data DropRemoteSchemaPermissions
DropRemoteSchemaPermissions :: RemoteSchemaName -> RoleName -> DropRemoteSchemaPermissions
[_drspRemoteSchema] :: DropRemoteSchemaPermissions -> RemoteSchemaName
[_drspRole] :: DropRemoteSchemaPermissions -> RoleName
runAddRemoteSchemaPermissions :: (QErrM m, CacheRWM m, MetadataM m) => RemoteSchemaPermissions -> AddRemoteSchemaPermission -> m EncJSON
runDropRemoteSchemaPermissions :: (QErrM m, CacheRWM m, MetadataM m) => DropRemoteSchemaPermissions -> m EncJSON
instance GHC.Generics.Generic Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission
instance GHC.Classes.Eq Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission
instance GHC.Show.Show Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission
instance GHC.Generics.Generic Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions
instance GHC.Classes.Eq Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions
instance GHC.Show.Show Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions
instance Control.DeepSeq.NFData Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.MetadataAPI.Permission.DropRemoteSchemaPermissions
instance Control.DeepSeq.NFData Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.MetadataAPI.Permission.AddRemoteSchemaPermission

module Hasura.RQL.DDL.Schema.Source
data AddSource b
runAddSource :: forall m b. (MonadIO m, MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => Environment -> AddSource b -> m EncJSON
data RenameSource
runRenameSource :: forall m. (MonadError QErr m, CacheRWM m, MetadataM m) => RenameSource -> m EncJSON
data DropSource
DropSource :: SourceName -> Bool -> DropSource
[_dsName] :: DropSource -> SourceName
[_dsCascade] :: DropSource -> Bool
runDropSource :: forall m r. (MonadError QErr m, CacheRWM m, MonadIO m, MonadBaseControl IO m, MetadataM m, MonadReader r m, Has (Logger Hasura) r) => DropSource -> m EncJSON
runPostDropSourceHook :: forall m r b. (MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadReader r m, Has (Logger Hasura) r, BackendMetadata b) => SourceName -> SourceInfo b -> m ()
data UpdateSource b
runUpdateSource :: forall m b. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => UpdateSource b -> m EncJSON
newtype GetSourceTables (b :: BackendType)
GetSourceTables :: SourceName -> GetSourceTables (b :: BackendType)
[_gstSourceName] :: GetSourceTables (b :: BackendType) -> SourceName

-- | Fetch a list of tables for the request data source.
runGetSourceTrackables :: forall b m r. (BackendMetadata b, CacheRM m, MonadError QErr m, MetadataM m, MonadIO m, MonadBaseControl IO m, MonadReader r m, Has (Logger Hasura) r, ProvidesNetwork m) => GetSourceTrackables b -> m EncJSON
newtype GetSourceTrackables (b :: BackendType)
GetSourceTrackables :: SourceName -> GetSourceTrackables (b :: BackendType)
[_gstrSourceName] :: GetSourceTrackables (b :: BackendType) -> SourceName

-- | Fetch a list of tables for the request data source.
runGetSourceTables :: forall b m r. (BackendMetadata b, CacheRM m, MonadError QErr m, MetadataM m, MonadIO m, MonadBaseControl IO m, MonadReader r m, Has (Logger Hasura) r, ProvidesNetwork m) => GetSourceTables b -> m EncJSON
data GetTableInfo_
GetTableInfo_ :: SourceName -> TableName 'DataConnector -> GetTableInfo_
[_gtiSourceName_] :: GetTableInfo_ -> SourceName
[_gtiTableName_] :: GetTableInfo_ -> TableName 'DataConnector

-- | Legacy data connector command. This doesn't use the DataConnector
--   <a>ScalarType</a> to represent types.
runGetTableInfo_ :: (CacheRM m, MonadError QErr m, MetadataM m, MonadBaseControl IO m, MonadIO m) => GetTableInfo_ -> m EncJSON
data GetTableInfo (b :: BackendType)
GetTableInfo :: SourceName -> TableName b -> GetTableInfo (b :: BackendType)
[_gtiSourceName] :: GetTableInfo (b :: BackendType) -> SourceName
[_gtiTableName] :: GetTableInfo (b :: BackendType) -> TableName b

-- | Get information about the given table.
runGetTableInfo :: forall b m. (BackendMetadata b, CacheRM m, MonadError QErr m, MetadataM m, MonadBaseControl IO m, MonadIO m) => GetTableInfo b -> m EncJSON
instance GHC.Generics.Generic Hasura.RQL.DDL.Schema.Source.RenameSource
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Source.DropSource
instance GHC.Show.Show Hasura.RQL.DDL.Schema.Source.DropSource
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Source.GetTableInfo b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.Source.GetTableInfo_
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Source.GetSourceTrackables b)
instance Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Source.GetSourceTables b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Extended.FromJSONWithContext (Hasura.RQL.Types.BackendType.BackendSourceKind b) (Hasura.RQL.DDL.Schema.Source.UpdateSource b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.Source.DropSource
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.Source.RenameSource
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Extended.FromJSONWithContext (Hasura.RQL.Types.BackendType.BackendSourceKind b) (Hasura.RQL.DDL.Schema.Source.AddSource b)


-- | Types/functions shared between modules that implement
--   <a>Hasura.RQL.DDL.Schema.Cache</a>. Other modules should not import
--   this module directly.
module Hasura.RQL.DDL.Schema.Cache.Common
newtype BackendInvalidationKeysWrapper (b :: BackendType)
BackendInvalidationKeysWrapper :: BackendInvalidationKeys b -> BackendInvalidationKeysWrapper (b :: BackendType)
[unBackendInvalidationKeysWrapper] :: BackendInvalidationKeysWrapper (b :: BackendType) -> BackendInvalidationKeys b

-- | <a>InvalidationKeys</a> used to apply requested
--   <a>CacheInvalidations</a>.
data InvalidationKeys
InvalidationKeys :: InvalidationKey -> HashMap RemoteSchemaName InvalidationKey -> HashMap SourceName InvalidationKey -> BackendMap BackendInvalidationKeysWrapper -> InvalidationKeys
[_ikMetadata] :: InvalidationKeys -> InvalidationKey
[_ikRemoteSchemas] :: InvalidationKeys -> HashMap RemoteSchemaName InvalidationKey
[_ikSources] :: InvalidationKeys -> HashMap SourceName InvalidationKey
[_ikBackends] :: InvalidationKeys -> BackendMap BackendInvalidationKeysWrapper
ikSources :: Lens' InvalidationKeys (HashMap SourceName InvalidationKey)
ikRemoteSchemas :: Lens' InvalidationKeys (HashMap RemoteSchemaName InvalidationKey)
ikMetadata :: Lens' InvalidationKeys InvalidationKey
ikBackends :: Lens' InvalidationKeys (BackendMap BackendInvalidationKeysWrapper)
initialInvalidationKeys :: InvalidationKeys
invalidateKeys :: CacheInvalidations -> InvalidationKeys -> InvalidationKeys
data TableBuildInput b
TableBuildInput :: TableName b -> Bool -> TableConfig b -> Maybe ApolloFederationConfig -> Maybe LogicalModelName -> TableBuildInput b
data NonColumnTableInputs b
NonColumnTableInputs :: TableName b -> [ObjRelDef b] -> [ArrRelDef b] -> [ComputedFieldMetadata b] -> [RemoteRelationship] -> NonColumnTableInputs b
[_nctiTable] :: NonColumnTableInputs b -> TableName b
[_nctiObjectRelationships] :: NonColumnTableInputs b -> [ObjRelDef b]
[_nctiArrayRelationships] :: NonColumnTableInputs b -> [ArrRelDef b]
[_nctiComputedFields] :: NonColumnTableInputs b -> [ComputedFieldMetadata b]
[_nctiRemoteRelationships] :: NonColumnTableInputs b -> [RemoteRelationship]
data TablePermissionInputs b
TablePermissionInputs :: TableName b -> [InsPermDef b] -> [SelPermDef b] -> [UpdPermDef b] -> [DelPermDef b] -> TablePermissionInputs b
[_tpiTable] :: TablePermissionInputs b -> TableName b
[_tpiInsert] :: TablePermissionInputs b -> [InsPermDef b]
[_tpiSelect] :: TablePermissionInputs b -> [SelPermDef b]
[_tpiUpdate] :: TablePermissionInputs b -> [UpdPermDef b]
[_tpiDelete] :: TablePermissionInputs b -> [DelPermDef b]
mkTableInputs :: TableMetadata b -> (TableBuildInput b, NonColumnTableInputs b, TablePermissionInputs b)

-- | The direct output of <tt>buildSchemaCacheRule</tt>. Contains most of
--   the things necessary to build a schema cache, but dependencies and
--   inconsistent metadata objects are collected via a separate
--   <a>MonadWriter</a> side channel.
--   
--   See also Note [Avoiding GraphQL schema rebuilds when changing
--   irrelevant Metadata]
data BuildOutputs
BuildOutputs :: SourceCache -> ActionCache -> HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject) -> AnnotatedCustomTypes -> HashMap RoleName Role -> BackendCache -> BuildOutputs
[_boSources] :: BuildOutputs -> SourceCache
[_boActions] :: BuildOutputs -> ActionCache

-- | We preserve the <a>MetadataObject</a> from the original catalog
--   metadata in the output so we can reuse it later if we need to mark the
--   remote schema inconsistent during GraphQL schema generation (because
--   of field conflicts).
[_boRemoteSchemas] :: BuildOutputs -> HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject)
[_boCustomTypes] :: BuildOutputs -> AnnotatedCustomTypes
[_boRoles] :: BuildOutputs -> HashMap RoleName Role
[_boBackendCache] :: BuildOutputs -> BackendCache
boSources :: Lens' BuildOutputs SourceCache
boRoles :: Lens' BuildOutputs (HashMap RoleName Role)
boRemoteSchemas :: Lens' BuildOutputs (HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject))
boCustomTypes :: Lens' BuildOutputs AnnotatedCustomTypes
boBackendCache :: Lens' BuildOutputs BackendCache
boActions :: Lens' BuildOutputs ActionCache

-- | Parameters required for schema cache build
data CacheBuildParams
CacheBuildParams :: Manager -> SourceResolver ('Postgres 'Vanilla) -> SourceResolver 'MSSQL -> CacheStaticConfig -> CacheBuildParams

-- | The monad in which @<a>RebuildableSchemaCache</a> is being run
data CacheBuild a
runCacheBuild :: (MonadIO m, MonadError QErr m) => CacheBuildParams -> CacheBuild a -> m a
runCacheBuildM :: (MonadIO m, MonadError QErr m, MonadResolveSource m, ProvidesNetwork m, HasCacheStaticConfig m) => CacheBuild a -> m a

-- | The status of collection of stored introspections of remote schemas
--   and data sources.
data SourcesIntrospectionStatus

-- | A full introspection collection of all available remote schemas and
--   data sources.
SourcesIntrospectionChangedFull :: StoredIntrospection -> SourcesIntrospectionStatus

-- | A partial introspection collection. Does not include all configured
--   remote schemas and data sources, because they were not available.
SourcesIntrospectionChangedPartial :: StoredIntrospection -> SourcesIntrospectionStatus

-- | None of remote schemas or data sources introspection is refetched.
SourcesIntrospectionUnchanged :: SourcesIntrospectionStatus
data RebuildableSchemaCache
RebuildableSchemaCache :: SchemaCache -> InvalidationKeys -> Rule (ReaderT BuildReason CacheBuild) (MetadataWithResourceVersion, CacheDynamicConfig, InvalidationKeys, Maybe StoredIntrospection) (SchemaCache, (SourcesIntrospectionStatus, SchemaRegistryAction)) -> RebuildableSchemaCache
withRecordDependencies :: ArrowWriter (Seq CollectItem) arr => WriterA (Seq SchemaDependency) arr (e, s) a -> arr (e, (MetadataObject, (SchemaObjId, s))) a

-- | Processes a list of catalog metadata into a map of processed
--   information, marking any duplicate entries inconsistent.
buildInfoMap :: (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectItem) arr, Hashable k) => (a -> k) -> (a -> MetadataObject) -> ((e, a) `arr` Maybe b) -> (e, [a]) `arr` HashMap k b
buildInfoMapM :: (MonadWriter (Seq CollectItem) m, Hashable k) => (a -> k) -> (a -> MetadataObject) -> (a -> m (Maybe b)) -> [a] -> m (HashMap k b)

-- | Like <a>buildInfoMap</a>, but includes each processed infoâ€™s
--   associated <a>MetadataObject</a> in the result. This is useful if the
--   results will be further processed, and the <a>MetadataObject</a> is
--   still needed to mark the object inconsistent.
buildInfoMapPreservingMetadata :: (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectItem) arr, Hashable k) => (a -> k) -> (a -> MetadataObject) -> ((e, a) `arr` Maybe b) -> (e, [a]) `arr` HashMap k (b, MetadataObject)
buildInfoMapPreservingMetadataM :: (MonadWriter (Seq CollectItem) m, Hashable k) => (a -> k) -> (a -> MetadataObject) -> (a -> m (Maybe b)) -> [a] -> m (HashMap k (b, MetadataObject))
addTableContext :: Backend b => TableName b -> Text -> Text
addLogicalModelContext :: LogicalModelLocation -> Text -> Text
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.Base.MonadBase GHC.Types.IO Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.IO.Class.MonadIO Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.Reader.Class.MonadReader Hasura.RQL.DDL.Schema.Cache.Common.CacheBuildParams Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Base.Monad Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Base.Applicative Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Base.Functor Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Hasura.Services.Network.ProvidesNetwork Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance Hasura.RQL.Types.Source.MonadResolveSource Hasura.RQL.DDL.Schema.Cache.Common.CacheBuild
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.Common.NonColumnTableInputs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.Common.NonColumnTableInputs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Cache.Common.NonColumnTableInputs b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.Common.TablePermissionInputs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Cache.Common.TablePermissionInputs b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.Common.TablePermissionInputs b)
instance Hasura.RQL.Types.Backend.Backend b => Control.DeepSeq.NFData (Hasura.RQL.DDL.Schema.Cache.Common.TableBuildInput b)
instance GHC.Generics.Generic Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance GHC.Show.Show Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance GHC.Classes.Eq (Hasura.RQL.Types.Metadata.Backend.BackendInvalidationKeys b) => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)
instance GHC.Classes.Ord (Hasura.RQL.Types.Metadata.Backend.BackendInvalidationKeys b) => GHC.Classes.Ord (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)
instance GHC.Show.Show (Hasura.RQL.Types.Metadata.Backend.BackendInvalidationKeys b) => GHC.Show.Show (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)
instance GHC.Base.Semigroup (Hasura.RQL.Types.Metadata.Backend.BackendInvalidationKeys b) => GHC.Base.Semigroup (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)
instance GHC.Base.Monoid (Hasura.RQL.Types.Metadata.Backend.BackendInvalidationKeys b) => GHC.Base.Monoid (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)
instance Hasura.Incremental.Select.Select Hasura.RQL.DDL.Schema.Cache.Common.InvalidationKeys
instance Hasura.Incremental.Select.Select (Hasura.RQL.DDL.Schema.Cache.Common.BackendInvalidationKeysWrapper b)


module Hasura.Table.API
data TrackTable b
TrackTable :: SourceName -> TableName b -> Bool -> Maybe ApolloFederationConfig -> Maybe LogicalModelName -> TrackTable b
[tSource] :: TrackTable b -> SourceName
[tName] :: TrackTable b -> TableName b
[tIsEnum] :: TrackTable b -> Bool
[tApolloFedConfig] :: TrackTable b -> Maybe ApolloFederationConfig
[tLogicalModel] :: TrackTable b -> Maybe LogicalModelName
data SetTableIsEnum b
SetTableIsEnum :: SourceName -> TableName b -> Bool -> SetTableIsEnum b
[stieSource] :: SetTableIsEnum b -> SourceName
[stieTable] :: SetTableIsEnum b -> TableName b
[stieIsEnum] :: SetTableIsEnum b -> Bool
data UntrackTable b
UntrackTable :: SourceName -> TableName b -> Bool -> UntrackTable b
[utSource] :: UntrackTable b -> SourceName
[utTable] :: UntrackTable b -> TableName b
[utCascade] :: UntrackTable b -> Bool

-- | Check whether a given name would conflict with the current schema by
--   doing an internal introspection
checkConflictingNode :: forall m. MonadError QErr m => SchemaCache -> Text -> m ()
runTrackTableQ :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => TrackTable b -> m EncJSON
data TrackTableV2 b
TrackTableV2 :: TrackTable b -> TableConfig b -> TrackTableV2 b
[ttv2Table] :: TrackTableV2 b -> TrackTable b
[ttv2Configuration] :: TrackTableV2 b -> TableConfig b
runTrackTableV2Q :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => TrackTableV2 b -> m EncJSON
data TrackTables b
TrackTables :: [TrackTableV2 b] -> AllowWarnings -> TrackTables b
[_ttv2Tables] :: TrackTables b -> [TrackTableV2 b]
[_ttv2AllowWarnings] :: TrackTables b -> AllowWarnings
runTrackTablesQ :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => TrackTables b -> m EncJSON
data UntrackTables b
UntrackTables :: [UntrackTable b] -> AllowWarnings -> UntrackTables b
[_utTables] :: UntrackTables b -> [UntrackTable b]
[_utAllowWarnings] :: UntrackTables b -> AllowWarnings
runUntrackTablesQ :: forall b m. (CacheRWM m, QErrM m, MetadataM m, BackendMetadata b, BackendEventTrigger b, MonadIO m) => UntrackTables b -> m EncJSON
runSetExistingTableIsEnumQ :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => SetTableIsEnum b -> m EncJSON
data SetTableCustomization b
SetTableCustomization :: SourceName -> TableName b -> TableConfig b -> SetTableCustomization b
[_stcSource] :: SetTableCustomization b -> SourceName
[_stcTable] :: SetTableCustomization b -> TableName b
[_stcConfiguration] :: SetTableCustomization b -> TableConfig b
data SetTableCustomFields
SetTableCustomFields :: SourceName -> QualifiedTable -> TableCustomRootFields -> HashMap (Column ('Postgres 'Vanilla)) Name -> SetTableCustomFields
[_stcfSource] :: SetTableCustomFields -> SourceName
[_stcfTable] :: SetTableCustomFields -> QualifiedTable
[_stcfCustomRootFields] :: SetTableCustomFields -> TableCustomRootFields
[_stcfCustomColumnNames] :: SetTableCustomFields -> HashMap (Column ('Postgres 'Vanilla)) Name
runSetTableCustomFieldsQV2 :: (QErrM m, CacheRWM m, MetadataM m) => SetTableCustomFields -> m EncJSON
runSetTableCustomization :: forall b m. (QErrM m, CacheRWM m, MetadataM m, Backend b) => SetTableCustomization b -> m EncJSON
runUntrackTableQ :: forall b m. (CacheRWM m, QErrM m, MetadataM m, BackendMetadata b, BackendEventTrigger b, MonadIO m) => UntrackTable b -> m EncJSON

-- | Builds an initial table cache. Does not fill in permissions or event
--   triggers, and the returned <tt>FieldInfoMap</tt>s only contain
--   columns, not relationships; those pieces of information are filled in
--   later.
buildTableCache :: forall arr m b. (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectItem) arr, ArrowCache m arr, MonadIO m, MonadBaseControl IO m, BackendMetadata b) => (SourceName, SourceConfig b, DBTablesMetadata b, [TableBuildInput b], Dependency InvalidationKey, NamingCase, LogicalModels b) `arr` HashMap (TableName b) (TableCoreInfoG b (StructuredColumnInfo b) (ColumnInfo b))
data SetApolloFederationConfig b
SetApolloFederationConfig :: SourceName -> TableName b -> Maybe ApolloFederationConfig -> SetApolloFederationConfig b
[_safcSource] :: SetApolloFederationConfig b -> SourceName
[_safcTable] :: SetApolloFederationConfig b -> TableName b

-- | Apollo Federation config for the table, setting <a>Nothing</a> would
--   disable Apollo Federation support on the table.
[_safcApolloFederationConfig] :: SetApolloFederationConfig b -> Maybe ApolloFederationConfig
runSetApolloFederationConfig :: forall b m. (QErrM m, CacheRWM m, MetadataM m, Backend b) => SetApolloFederationConfig b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.API.TrackTableV2 b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.API.TrackTableV2 b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.API.SetTableCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.API.SetTableCustomization b)
instance GHC.Classes.Eq Hasura.Table.API.SetTableCustomFields
instance GHC.Show.Show Hasura.Table.API.SetTableCustomFields
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.API.TrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.API.TrackTable b)
instance GHC.Classes.Eq (Hasura.RQL.Types.Backend.TableName b) => GHC.Classes.Eq (Hasura.Table.API.SetTableIsEnum b)
instance GHC.Show.Show (Hasura.RQL.Types.Backend.TableName b) => GHC.Show.Show (Hasura.Table.API.SetTableIsEnum b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Table.API.UntrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Table.API.UntrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.SetApolloFederationConfig b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Table.API.SetTableCustomFields
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.SetTableCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.UntrackTables b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.TrackTables b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.TrackTableV2 b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.UntrackTable b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.SetTableIsEnum b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Table.API.TrackTable b)

module Hasura.RQL.DDL.Schema.Diff
data FunctionMeta b
FunctionMeta :: OID -> FunctionName b -> FunctionVolatility -> FunctionMeta b
[fmOid] :: FunctionMeta b -> OID
[fmFunction] :: FunctionMeta b -> FunctionName b
[fmType] :: FunctionMeta b -> FunctionVolatility
data ComputedFieldMeta b
ComputedFieldMeta :: ComputedFieldName -> FunctionMeta b -> ComputedFieldMeta b
[ccmName] :: ComputedFieldMeta b -> ComputedFieldName
[ccmFunctionMeta] :: ComputedFieldMeta b -> FunctionMeta b
data TableMeta (b :: BackendType)
TableMeta :: TableName b -> DBTableMetadata b -> [ComputedFieldMeta b] -> TableMeta (b :: BackendType)
[tmTable] :: TableMeta (b :: BackendType) -> TableName b
[tmInfo] :: TableMeta (b :: BackendType) -> DBTableMetadata b
[tmComputedFields] :: TableMeta (b :: BackendType) -> [ComputedFieldMeta b]
data TablesDiff (b :: BackendType)
TablesDiff :: [TableName b] -> [(TableName b, TableDiff b)] -> TablesDiff (b :: BackendType)
[_sdDroppedTables] :: TablesDiff (b :: BackendType) -> [TableName b]
[_sdAlteredTables] :: TablesDiff (b :: BackendType) -> [(TableName b, TableDiff b)]
getTablesDiff :: Backend b => [TableMeta b] -> [TableMeta b] -> TablesDiff b
getIndirectDependenciesFromTableDiff :: forall b m. (QErrM m, CacheRM m, Backend b) => SourceName -> TablesDiff b -> m [SchemaObjId]
data FunctionsDiff b
FunctionsDiff :: [FunctionName b] -> [(FunctionName b, FunctionVolatility)] -> FunctionsDiff b
[fdDropped] :: FunctionsDiff b -> [FunctionName b]
[fdAltered] :: FunctionsDiff b -> [(FunctionName b, FunctionVolatility)]
getFunctionsDiff :: [FunctionMeta b] -> [FunctionMeta b] -> FunctionsDiff b
getOverloadedFunctions :: Backend b => [FunctionName b] -> [FunctionMeta b] -> [FunctionName b]
processTablesDiff :: forall b m. (MonadError QErr m, CacheRM m, MonadWriter MetadataModifier m, BackendMetadata b) => SourceName -> TableCache b -> TablesDiff b -> m ()
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.TableMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Diff.TableMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Diff.ComputedFieldDiff b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.ComputedFieldDiff b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Diff.FunctionsDiff b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Diff.FunctionsDiff b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Schema.Diff.ComputedFieldMeta b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.Schema.Diff.FunctionMeta b)

module Hasura.RQL.DDL.Schema.Cache.Permission
mkBooleanPermissionMap :: (RoleName -> a) -> HashMap RoleName a -> OrderedRoles -> HashMap RoleName a

-- | <a>OrderedRoles</a> is a data type to hold topologically sorted roles
--   according to each role's parent roles, see <a>orderRoles</a> for more
--   details.
data OrderedRoles

-- | <a>orderRoles</a> is used to order the roles, in such a way that given
--   a role R with n parent roles - PR1, PR2 .. PRn, then the
--   <a>orderRoles</a> function will order the roles in such a way that all
--   the parent roles precede the role R. Note that the order of the parent
--   roles itself doesn't matter as long as they precede the roles on which
--   they are dependent on.
--   
--   For example, the orderRoles may return `[PR1, PR3, PR2, ... PRn, R]`
--   or `[PR5, PR3, PR1 ... R]`, both of them are correct because all the
--   parent roles precede the inherited role R, assuming the parent roles
--   themselves don't have any parents for the sake of this example.
orderRoles :: MonadError QErr m => [Role] -> m OrderedRoles

-- | <a>resolveCheckPermission</a> is a helper function which will convert
--   the indermediate type <a>CheckPermission</a> to its original type. It
--   will record any metadata inconsistencies, if exists.
resolveCheckPermission :: MonadWriter (Seq CollectItem) m => CheckPermission p -> RoleName -> InconsistentRoleEntity -> m (Maybe p)
buildTablePermissions :: forall b m. (MonadError QErr m, MonadWriter (Seq CollectItem) m, BackendMetadata b, GetAggregationPredicatesDeps b) => Environment -> SourceName -> SourceConfig b -> TableCoreCache b -> TableName b -> FieldInfoMap (FieldInfo b) -> TablePermissionInputs b -> OrderedRoles -> HashMap LogicalModelName (LogicalModelMetadata b) -> m (RolePermInfoMap b)

-- | Create the permission map for a native query based on the select
--   permissions given in metadata. Compare with
--   <a>buildTablePermissions</a>.
buildLogicalModelPermissions :: forall b m. (MonadError QErr m, MonadWriter (Seq CollectItem) m, BackendMetadata b, GetAggregationPredicatesDeps b, LogicalModelFieldsRM b m) => SourceName -> SourceConfig b -> TableCoreCache b -> LogicalModelLocation -> InsOrdHashMap (Column b) (LogicalModelField b) -> InsOrdHashMap RoleName (SelPermDef b) -> OrderedRoles -> m (RolePermInfoMap b)
instance GHC.Generics.Generic Hasura.RQL.DDL.Schema.Cache.Permission.OrderedRoles
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.Cache.Permission.OrderedRoles
instance Hasura.RQL.Types.Backend.Backend b => Data.Text.Extended.ToTxt (Hasura.RQL.DDL.Schema.Cache.Permission.SelectPermissionSource b)

module Hasura.RemoteSchema.SchemaCache.Build
buildRemoteSchemas :: (ArrowChoice arr, ArrowDistribute arr, ArrowWriter (Seq CollectItem) arr, ArrowCache m arr, MonadIO m, MonadBaseControl IO m, Eq remoteRelationshipDefinition, ToJSON remoteRelationshipDefinition, MonadError QErr m, ProvidesNetwork m) => Logger Hasura -> Environment -> ((Dependency (HashMap RemoteSchemaName InvalidationKey), OrderedRoles, Maybe (HashMap RemoteSchemaName ByteString)), [RemoteSchemaMetadataG remoteRelationshipDefinition]) `arr` HashMap RemoteSchemaName (PartiallyResolvedRemoteSchemaCtxG remoteRelationshipDefinition, MetadataObject)
addRemoteSchemaP2Setup :: (QErrM m, MonadIO m, ProvidesNetwork m, MonadTrace m) => Environment -> RemoteSchemaDef -> m (IntrospectionResult, ByteString, RemoteSchemaInfo)

module Hasura.RemoteSchema.SchemaCache

module Hasura.RQL.DDL.RemoteRelationship

-- | Argument to the <tt>_create_remote_relationship</tt> and
--   <tt>_update_remote_relationship</tt> families of metadata commands.
--   
--   For historical reason, this type is also used to represent a db-to-rs
--   schema in the metadata.
data CreateFromSourceRelationship (b :: BackendType)
CreateFromSourceRelationship :: SourceName -> TableName b -> RelName -> RemoteRelationshipDefinition -> CreateFromSourceRelationship (b :: BackendType)
[_crrSource] :: CreateFromSourceRelationship (b :: BackendType) -> SourceName
[_crrTable] :: CreateFromSourceRelationship (b :: BackendType) -> TableName b
[_crrName] :: CreateFromSourceRelationship (b :: BackendType) -> RelName
[_crrDefinition] :: CreateFromSourceRelationship (b :: BackendType) -> RemoteRelationshipDefinition
runCreateRemoteRelationship :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => CreateFromSourceRelationship b -> m EncJSON
runUpdateRemoteRelationship :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => CreateFromSourceRelationship b -> m EncJSON

-- | Argument to the <tt>_drop_remote_relationship</tt> family of metadata
--   commands.
data DeleteFromSourceRelationship (b :: BackendType)
DeleteFromSourceRelationship :: SourceName -> TableName b -> RelName -> DeleteFromSourceRelationship (b :: BackendType)
[_drrSource] :: DeleteFromSourceRelationship (b :: BackendType) -> SourceName
[_drrTable] :: DeleteFromSourceRelationship (b :: BackendType) -> TableName b
[_drrName] :: DeleteFromSourceRelationship (b :: BackendType) -> RelName
execDeleteRemoteRelationship :: forall b m. (BackendMetadata b, MonadError QErr m, CacheRWM m) => DeleteFromSourceRelationship b -> m (MetadataObjId, MetadataModifier)
runDeleteRemoteRelationship :: forall b m. (BackendMetadata b, MonadError QErr m, CacheRWM m, MetadataM m) => DeleteFromSourceRelationship b -> m EncJSON
data CreateRemoteSchemaRemoteRelationship
CreateRemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> RemoteRelationshipDefinition -> CreateRemoteSchemaRemoteRelationship
[_crsrrRemoteSchema] :: CreateRemoteSchemaRemoteRelationship -> RemoteSchemaName
[_crsrrType] :: CreateRemoteSchemaRemoteRelationship -> Name
[_crsrrName] :: CreateRemoteSchemaRemoteRelationship -> RelName
[_crsrrDefinition] :: CreateRemoteSchemaRemoteRelationship -> RemoteRelationshipDefinition
runCreateRemoteSchemaRemoteRelationship :: forall m. (MonadError QErr m, CacheRWM m, MetadataM m) => CreateRemoteSchemaRemoteRelationship -> m EncJSON
runUpdateRemoteSchemaRemoteRelationship :: forall m. (MonadError QErr m, CacheRWM m, MetadataM m) => CreateRemoteSchemaRemoteRelationship -> m EncJSON

-- | Argument to the <tt>_drop_remote_relationship</tt> family of metadata
--   commands.
data DeleteRemoteSchemaRemoteRelationship
DeleteRemoteSchemaRemoteRelationship :: RemoteSchemaName -> Name -> RelName -> DeleteRemoteSchemaRemoteRelationship
[_drsrrRemoteSchema] :: DeleteRemoteSchemaRemoteRelationship -> RemoteSchemaName
[_drsrrTypeName] :: DeleteRemoteSchemaRemoteRelationship -> Name
[_drsrrName] :: DeleteRemoteSchemaRemoteRelationship -> RelName
runDeleteRemoteSchemaRemoteRelationship :: forall m. (MonadError QErr m, CacheRWM m, MetadataM m) => DeleteRemoteSchemaRemoteRelationship -> m EncJSON

-- | Internal intermediary step.
--   
--   We build the output of sources in two steps: 1. we first resolve
--   sources, and collect the core info of their tables 2. we then build
--   the entire output from the collection of partially resolved sources
--   
--   We need this split to be able to resolve cross-source relationships:
--   to process one source's remote relationship, we need to know about the
--   target source's tables core info.
--   
--   This data structure is used as an argument to <tt>AnyBackend</tt> in
--   the backend-agnostic intermediary collection, and used here to build
--   remote field info.
data PartiallyResolvedSource b
PartiallyResolvedSource :: SourceMetadata b -> SourceConfig b -> DBObjectsIntrospection b -> HashMap (TableName b) (TableCoreInfoG b (StructuredColumnInfo b) (ColumnInfo b)) -> HashMap (TableName b) (EventTriggerInfoMap b) -> PartiallyResolvedSource b
[_prsSourceMetadata] :: PartiallyResolvedSource b -> SourceMetadata b
[_prsConfig] :: PartiallyResolvedSource b -> SourceConfig b
[_prsIntrospection] :: PartiallyResolvedSource b -> DBObjectsIntrospection b
[_tableCoreInfoMap] :: PartiallyResolvedSource b -> HashMap (TableName b) (TableCoreInfoG b (StructuredColumnInfo b) (ColumnInfo b))
[_eventTriggerInfoMap] :: PartiallyResolvedSource b -> HashMap (TableName b) (EventTriggerInfoMap b)

-- | Builds the schema cache representation of a remote relationship TODO:
--   this is not actually called by the remote relationship DDL API and is
--   only used as part of the schema cache process. Should this be moved
--   elsewhere?
buildRemoteFieldInfo :: QErrM m => LHSIdentifier -> HashMap FieldName lhsJoinField -> RemoteRelationship -> HashMap SourceName (AnyBackend PartiallyResolvedSource) -> PartiallyResolvedRemoteSchemaMap -> m (RemoteFieldInfo lhsJoinField, Seq SchemaDependency)
getRemoteSchemaEntityJoinColumns :: MonadError QErr m => RemoteSchemaName -> RemoteSchemaIntrospection -> Name -> m (HashMap FieldName Name)
instance GHC.Generics.Generic Hasura.RQL.DDL.RemoteRelationship.CreateRemoteSchemaRemoteRelationship
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.RemoteRelationship.PartiallyResolvedSource b)
instance GHC.Classes.Eq (Hasura.RQL.Types.Backend.TableName b) => GHC.Classes.Eq (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)
instance GHC.Show.Show (Hasura.RQL.Types.Backend.TableName b) => GHC.Show.Show (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.RemoteRelationship.DeleteRemoteSchemaRemoteRelationship
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.RemoteRelationship.CreateRemoteSchemaRemoteRelationship
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.RemoteRelationship.CreateRemoteSchemaRemoteRelationship
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.RemoteRelationship.DeleteFromSourceRelationship b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.RQL.DDL.RemoteRelationship.CreateFromSourceRelationship b)


-- | Funtions related to <tt>hdb_catalog</tt> schema prior to metadata
--   separation (catalog version &lt; 43).
module Hasura.RQL.DDL.Schema.LegacyCatalog
saveMetadataToHdbTables :: (MonadTx m, MonadReader SystemDefined m) => MetadataNoSources -> m ()
parseLegacyRemoteRelationshipDefinition :: MonadError QErr m => Value -> m RemoteRelationshipDefinition
fetchMetadataFromHdbTables :: MonadTx m => m MetadataNoSources
addCronTriggerForeignKeyConstraint :: MonadTx m => m ()

-- | Drops and recreates all â€œsystem-definedâ€ metadata, aka metadata for
--   tables and views in the <tt>information_schema</tt> and
--   <tt>hdb_catalog</tt> schemas. These tables and views are tracked to
--   expose them to the console, which allows us to reuse the same
--   functionality we use to implement user-defined APIs to expose the
--   catalog.
--   
--   This process has a long and storied history.
--   
--   In the past, we reused the same machinery we use for CLI migrations to
--   define our own internal metadata migrations. This caused trouble,
--   however, as weâ€™d have to run those migrations in lockstep with our SQL
--   migrations to ensure the two didnâ€™t get out of sync. This in turn
--   caused trouble because those migrations would hit code paths inside
--   <tt>graphql-engine</tt> to add or remove things from the
--   <tt>pg_catalog</tt> tables, and <i>that</i> in turn would fail because
--   we hadnâ€™t finished running the SQL migrations, so we were running a
--   new version of the code against an old version of the schema! That
--   caused #2826.
--   
--   To fix that, #2379 switched to the approach of just dropping and
--   recreating all system metadata every time we run any SQL migrations.
--   But <i>that</i> in turn caused trouble due to the way we were
--   constantly rebuilding the schema cache (#3354), causing us to switch
--   to incremental schema cache construction (#3394). However, although
--   that mostly resolved the problem, we still werenâ€™t totally out of the
--   woods, as the incremental construction was still too slow on slow
--   Postgres instances (#3654).
--   
--   To sidestep the whole issue, as of #3686 we now just create all the
--   system metadata in code here, and we only rebuild the schema cache
--   once, at the very end. This is a little unsatisfying, since it means
--   our internal migrations are â€œblessedâ€ compared to user-defined CLI
--   migrations. If we improve CLI migrations further in the future, maybe
--   we can switch back to using that approach, instead.
recreateSystemMetadata :: MonadTx m => m ()

module Hasura.GraphQL.Schema.RemoteRelationship

-- | Remote relationship field parsers
remoteRelationshipField :: SchemaContext -> SchemaOptions -> SourceCache -> RemoteSchemaMap -> RemoteSchemaPermissions -> RemoteSourceRelationshipBuilder -> RemoteRelationshipParserBuilder

module Hasura.GraphQL.Schema

-- | Builds the full GraphQL context for a given query type.
--   
--   A <a>GQLContext</a> stores how an incoming request should be
--   processed: how to translate each incoming field of a request into a
--   corresponding semantic representation. There is a different one per
--   <tt>Role</tt>, as each role might have different permissions, and
--   therefore not access to the same set of objects in the schema.
--   
--   This function takes all necessary information from the metadata, and
--   the <tt>GraphQLQueryType</tt>, and builds all relevant contexts: a
--   hash map from <a>RoleName</a> to their <a>GQLContext</a> and the
--   "default" context for unauthenticated users.
--   
--   When building the schema for each role, we treat the remote schemas as
--   "second-class citizens" compared to sources; more specifically, we
--   attempt to detect whether the inclusion of a given remote schema would
--   result in root fields conflict, and only keep schemas that don't
--   generate any. This results in a partial schema being available to the
--   users, and a better error message than would arise from
--   <a>safeSelectionSet</a>.
buildGQLContext :: forall m. (MonadError QErr m, MonadIO m) => InferFunctionPermissions -> RemoteSchemaPermissions -> HashSet ExperimentalFeature -> SQLGenCtx -> ApolloFederationStatus -> SourceCache -> HashMap RemoteSchemaName (RemoteSchemaCtx, MetadataObject) -> ActionCache -> AnnotatedCustomTypes -> Maybe SchemaRegistryContext -> Logger Hasura -> m ((SchemaIntrospection, HashMap RoleName (RoleContext GQLContext), GQLContext, HashSet InconsistentMetadata), (HashMap RoleName (RoleContext GQLContext), GQLContext), SchemaRegistryAction)

module Hasura.GraphQL.Execute.RemoteJoin.Types

-- | A JoinTree represents the set of operations that need to be executed
--   to enrich the response of a source with data from remote sources. A
--   tree structure is used to capture the locations in the response where
--   the join has to happpen as it offers an efficient traversal mechanism.
--   
--   For a query such as this:
--   
--   { city { name code # weather is a remote relationship weather {
--   forecast } state { # weather is a remote relationship weather {
--   forecast } } } }
--   
--   the join tree would look like [ , ("weather", Leaf
--   RemoteJoinInfoOfWeather), , ("state", [ ("weather", Leaf
--   RemoteJoinInfoOfWeather) ]) ]
--   
--   Note that the same join tree will be emitted even if <tt>city</tt> is
--   of type '[City]' and <a>state</a> is of type [State], we currently do
--   not capture any information if any of the fields in the path expect
--   json arrays. It is similar in spirit to a GraphQL selection set in
--   this regard.
--   
--   This structure is somewhat similar to a prefix tree such as
--   <a>Trie</a>, but has two additional guarantees: - a <a>JoinTree</a> is
--   never empty, - there cannot exist a pair of values for which one's
--   prefix key is a subset of the other: every value is effectively a
--   leaf.
newtype JoinTree a
JoinTree :: NEHashMap QualifiedFieldName (JoinNode a) -> JoinTree a
[unJoinTree] :: JoinTree a -> NEHashMap QualifiedFieldName (JoinNode a)

-- | A field name annotated with an optional type name.
--   
--   To deal with ambiguous join paths, such as those that emerge from
--   GraphQL interfaces or GraphQL unions, we do not just keep track of the
--   fields' name, but also, optionally, of their type. Whenever a
--   selection set is deemed ambiguous, we insert a reserved field in the
--   query to retrieve the typename, <tt>__hasura_internal_typename</tt>;
--   when traversing the join tree, if that key is present, then we use it
--   alongside the field name when querying the join tree (see
--   <tt>traverseObject</tt> in the <tt>Join</tt> module).
--   
--   We use <a>Text</a> for the representation of the field name instead of
--   <a>FieldName</a>, for simplicity: the join tree is only meant to be
--   queried using the values we get in the reponse, which will be
--   unrestricted text.
data QualifiedFieldName
QualifiedFieldName :: Maybe Text -> Text -> QualifiedFieldName
[_qfTypeName] :: QualifiedFieldName -> Maybe Text
[_qfFieldName] :: QualifiedFieldName -> Text

-- | Each leaf associates a mapping from typename to actual join info. This
--   allows to disambiguate between different remote joins with the same
--   name in a given selection set, which might happen with union or
--   interface fragments.
data JoinNode a
Leaf :: a -> JoinNode a
Tree :: JoinTree a -> JoinNode a
type RemoteJoins = JoinTree RemoteJoin

-- | Collect all the remote joins to a remote schema from a join tree.
getRemoteSchemaJoins :: RemoteJoins -> [RemoteSchemaJoin]

-- | An individual join entry point in a <a>JoinTree</a>.
--   
--   Either a join against a source, or against a remote schema. In either
--   case, the constructor will contain that particular join's information
--   (a <a>RemoteSourceJoin</a> or <a>RemoteSchemaJoin</a> respectively)
--   and, recursively, the set of follow-up <a>RemoteJoins</a> from that
--   target, if any.
data RemoteJoin
RemoteJoinSource :: AnyBackend RemoteSourceJoin -> Maybe RemoteJoins -> RemoteJoin
RemoteJoinRemoteSchema :: RemoteSchemaJoin -> Maybe RemoteJoins -> RemoteJoin

-- | A unique id that gets assigned to each <a>RemoteJoin</a> (this is to
--   avoid the requirement of Ord/Hashable implementation for RemoteJoin)
type JoinCallId = Int

-- | Disambiguates between <a>FieldName</a>s which are provided as part of
--   the GraphQL selection provided by the user (i.e. <a>JCSelected</a>)
--   and those which we need to retreive data but which are not expressly
--   requested (i.e. <a>JCPhantom</a>).
--   
--   After processing the remote join, we remove all phantom
--   <a>FieldName</a>s and only return those which fall under the
--   <a>JCSelected</a> branch of this type.
data JoinColumnAlias

-- | This fieldname is already part of the response.
JCSelected :: !FieldName -> JoinColumnAlias

-- | This is explicitly added for the join.
--   
--   Such keys will have to be removed from the response eventually.
JCPhantom :: !FieldName -> JoinColumnAlias

-- | Extracts the field name from the <a>JoinColumnAlias</a>, regardless of
--   whether the field is requested by the user of a "phantom" field.
getAliasFieldName :: JoinColumnAlias -> FieldName

-- | Extracts the list of phantom field names out of a given
--   <a>RemoteJoin</a>, i.e. the name of the fields that must be part of
--   the query but were not requested by the user.
getPhantomFields :: RemoteJoin -> [FieldName]

-- | Extracts an abstracted field mapping for a particular
--   <a>RemoteJoin</a>, using a common representation.
--   
--   The RHS of the mapping uses <a>JoinColumnAlias</a> instead of
--   <a>FieldName</a> to differentiate between selected fields and phantom
--   fields (see <a>JoinColumnAlias</a>).
getJoinColumnMapping :: RemoteJoin -> HashMap FieldName JoinColumnAlias

-- | A <a>RemoteSourceJoin</a> contains all the contextual information
--   required for the execution of a join against a source, translated from
--   the IR's representation of a selection (see <tt>AnnFieldG</tt>).
data RemoteSourceJoin b
RemoteSourceJoin :: !SourceName -> !SourceConfig b -> !SourceRelationshipSelection b Void UnpreparedValue -> !HashMap FieldName (JoinColumnAlias, (Column b, ScalarType b)) -> StringifyNumbers -> RemoteSourceJoin b
[_rsjSource] :: RemoteSourceJoin b -> !SourceName
[_rsjSourceConfig] :: RemoteSourceJoin b -> !SourceConfig b
[_rsjRelationship] :: RemoteSourceJoin b -> !SourceRelationshipSelection b Void UnpreparedValue
[_rsjJoinColumns] :: RemoteSourceJoin b -> !HashMap FieldName (JoinColumnAlias, (Column b, ScalarType b))
[_rsjStringifyNum] :: RemoteSourceJoin b -> StringifyNumbers

-- | A <a>RemoteSchemaJoin</a> contains all the contextual information
--   required for the execution of a join against a remote schema,
--   translated from the IR's representation of a selection (see
--   <tt>AnnFieldG</tt>).
data RemoteSchemaJoin
RemoteSchemaJoin :: !HashMap Name (InputValue RemoteSchemaVariable) -> !ResultCustomizer -> !SelectionSet Void RemoteSchemaVariable -> !HashMap FieldName JoinColumnAlias -> !NonEmpty FieldCall -> !RemoteSchemaInfo -> RemoteSchemaJoin

-- | User-provided arguments with variables.
[_rsjArgs] :: RemoteSchemaJoin -> !HashMap Name (InputValue RemoteSchemaVariable)

-- | Customizer for JSON result from the remote server.
[_rsjResultCustomizer] :: RemoteSchemaJoin -> !ResultCustomizer

-- | User-provided selection set of remote field.
[_rsjSelSet] :: RemoteSchemaJoin -> !SelectionSet Void RemoteSchemaVariable

-- | A map of the join column to its alias in the response
[_rsjJoinColumnAliases] :: RemoteSchemaJoin -> !HashMap FieldName JoinColumnAlias

-- | Remote server fields.
[_rsjFieldCall] :: RemoteSchemaJoin -> !NonEmpty FieldCall

-- | The remote schema server info.
[_rsjRemoteSchema] :: RemoteSchemaJoin -> !RemoteSchemaInfo

-- | A map of fieldname to values extracted from each LHS row/object
--   
--   For example, if a remote relationship <tt>weather</tt> on
--   <tt>city</tt> table is defined as follows: city.weather =
--   get_weather(city: city.code, cityState: city.state_code) a join
--   argument for this join would have the values of columns <tt>code</tt>
--   and <tt>state_code</tt> for each <tt>city</tt> row that participates
--   in the join
newtype JoinArgument
JoinArgument :: HashMap FieldName Value -> JoinArgument
[unJoinArgument] :: JoinArgument -> HashMap FieldName Value

-- | A unique id assigned to each join argument
type JoinArgumentId = Int
data JoinArguments
JoinArguments :: !RemoteJoin -> !HashMap JoinArgument JoinArgumentId -> !FieldName -> JoinArguments

-- | The <a>RemoteJoin</a> associated with the join arguments within this
--   structure.
[_jalJoin] :: JoinArguments -> !RemoteJoin

-- | Arguments for which we must fetch a response from the remote, along
--   with the identifiers that are used to stitch the final response
--   together.
--   
--   NOTE: <a>HashMap</a> is used to deduplicate multiple
--   <a>JoinArgument</a>s so that we avoid fetching more data from a remote
--   than is necessary (i.e. in the case of duplicate arguments).
[_jalArguments] :: JoinArguments -> !HashMap JoinArgument JoinArgumentId

-- | The <a>FieldName</a> associated with the "replacement token" for this
--   join argument.
--   
--   NOTE: We need this for query logging; ideally we would use the full
--   path for the GraphQL query associated with this remote join, but we
--   don't have access to that here so this is the next best thing to do.
[_jalFieldName] :: JoinArguments -> !FieldName
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance GHC.Show.Show Hasura.GraphQL.Execute.RemoteJoin.Types.QualifiedFieldName
instance GHC.Base.Semigroup (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance GHC.Generics.Generic (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance Data.Traversable.Traversable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree
instance Data.Foldable.Foldable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree
instance GHC.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinTree a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode a)
instance Data.Traversable.Traversable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode
instance GHC.Generics.Generic (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode a)
instance GHC.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode
instance Data.Foldable.Foldable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Types.JoinNode a)
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance GHC.Show.Show Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.JoinColumnAlias
instance GHC.Generics.Generic (Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSourceJoin b)
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSchemaJoin
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteJoin
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteJoin
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance GHC.Show.Show Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArgument
instance GHC.Generics.Generic Hasura.GraphQL.Execute.RemoteJoin.Types.JoinArguments
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Show.Show (Hasura.RQL.IR.Select.SourceRelationshipSelection b Data.Void.Void Hasura.RQL.IR.Value.UnpreparedValue), GHC.Show.Show (Hasura.RQL.Types.SourceConfiguration.SourceConfig b)) => GHC.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSourceJoin b)
instance (Hasura.RQL.Types.Backend.Backend b, GHC.Classes.Eq (Hasura.RQL.IR.Select.SourceRelationshipSelection b Data.Void.Void Hasura.RQL.IR.Value.UnpreparedValue)) => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSourceJoin b)
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteSchemaJoin

module Hasura.GraphQL.Execute.RemoteJoin.Collect

-- | Collects remote joins from the a <a>QueryDB</a> if any, and transforms
--   the selection to add new join fields where those occured.
--   
--   Returns the transformed selection set, in which remote fields have
--   been inserted, and for which the <tt>r</tt> type is now <a>Void</a>.
getRemoteJoinsQueryDB :: Backend b => QueryDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> (QueryDB b Void (UnpreparedValue b), Maybe RemoteJoins)

-- | Collects remote joins from the a <a>MutationDB</a> if any, and
--   transforms the selection to add new join fields where those occured.
--   
--   Returns the transformed selection set, in which remote fields have
--   been inserted, and for which the <tt>r</tt> type is now <a>Void</a>.
getRemoteJoinsMutationDB :: Backend b => MutationDB b (RemoteRelationshipField UnpreparedValue) (UnpreparedValue b) -> (MutationDB b Void (UnpreparedValue b), Maybe RemoteJoins)
getRemoteJoinsActionQuery :: ActionQuery (RemoteRelationshipField UnpreparedValue) -> (ActionQuery Void, Maybe RemoteJoins)
getRemoteJoinsActionMutation :: ActionMutation (RemoteRelationshipField UnpreparedValue) -> (ActionMutation Void, Maybe RemoteJoins)
getRemoteJoinsGraphQLField :: GraphQLField (RemoteRelationshipField UnpreparedValue) var -> (GraphQLField Void var, Maybe RemoteJoins)
instance Control.Monad.Writer.Class.MonadWriter (GHC.Maybe.Maybe Hasura.GraphQL.Execute.RemoteJoin.Types.RemoteJoins) Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector
instance GHC.Base.Monad Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector
instance GHC.Base.Applicative Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector
instance GHC.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Collect.Collector

module Hasura.GraphQL.Execute.Backend

-- | This typeclass enacapsulates how a given backend translates a root
--   field into an execution plan. For now, each root field maps to one
--   execution step, but in the future, when we have a client-side
--   dataloader, each root field might translate into a multi-step plan.
class (Backend b, ToTxt (MultiplexedQuery b), Show (ResolvedConnectionTemplate b), Eq (ResolvedConnectionTemplate b), Hashable (ResolvedConnectionTemplate b)) => BackendExecute (b :: BackendType) where {
    type PreparedQuery b :: Type;
    type MultiplexedQuery b :: Type;
    type ExecutionMonad b :: (Type -> Type) -> (Type -> Type);
}
mkDBQueryPlan :: forall m. (BackendExecute b, MonadError QErr m, MonadQueryTags m, MonadReader QueryTagsComment m) => UserInfo -> SourceName -> SourceConfig b -> QueryDB b Void (UnpreparedValue b) -> [Header] -> Maybe Name -> m (DBStepInfo b)
mkDBMutationPlan :: forall m. (BackendExecute b, MonadError QErr m, MonadIO m, MonadQueryTags m, MonadReader QueryTagsComment m, MonadTrace m) => Environment -> Manager -> Logger Hasura -> UserInfo -> StringifyNumbers -> SourceName -> SourceConfig b -> MutationDB b Void (UnpreparedValue b) -> [Header] -> Maybe Name -> Maybe (HashMap Name (Value Variable)) -> m (DBStepInfo b)
mkLiveQuerySubscriptionPlan :: forall m. (BackendExecute b, MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadReader QueryTagsComment m) => UserInfo -> SourceName -> SourceConfig b -> Maybe Name -> RootFieldMap (QueryDB b Void (UnpreparedValue b)) -> [Header] -> Maybe Name -> m (SubscriptionQueryPlan b (MultiplexedQuery b))
mkDBStreamingSubscriptionPlan :: forall m. (BackendExecute b, MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadReader QueryTagsComment m) => UserInfo -> SourceName -> SourceConfig b -> (RootFieldAlias, QueryDB b Void (UnpreparedValue b)) -> [Header] -> Maybe Name -> m (SubscriptionQueryPlan b (MultiplexedQuery b))
mkDBQueryExplain :: forall m. (BackendExecute b, MonadError QErr m) => RootFieldAlias -> UserInfo -> SourceName -> SourceConfig b -> QueryDB b Void (UnpreparedValue b) -> [Header] -> Maybe Name -> m (AnyBackend DBStepInfo)
mkSubscriptionExplain :: (BackendExecute b, MonadError QErr m, MonadIO m, MonadBaseControl IO m) => SubscriptionQueryPlan b (MultiplexedQuery b) -> m SubscriptionQueryPlanExplanation
mkDBRemoteRelationshipPlan :: forall m. (BackendExecute b, MonadError QErr m, MonadQueryTags m) => UserInfo -> SourceName -> SourceConfig b -> NonEmpty Object -> HashMap FieldName (Column b, ScalarType b) -> FieldName -> (FieldName, SourceRelationshipSelection b Void UnpreparedValue) -> [Header] -> Maybe Name -> StringifyNumbers -> m (DBStepInfo b)

-- | This is a helper function to convert a remote source's relationship to
--   a normal relationship to a temporary table. This function can be used
--   to implement executeRemoteRelationship function in databases which
--   support constructing a temporary table for a list of json objects.
convertRemoteSourceRelationship :: forall b. Backend b => HashMap (Column b) (Column b) -> SelectFromG b (UnpreparedValue b) -> Column b -> ColumnType b -> (FieldName, SourceRelationshipSelection b Void UnpreparedValue) -> StringifyNumbers -> QueryDB b Void (UnpreparedValue b)
data DBStepInfo b
DBStepInfo :: SourceName -> SourceConfig b -> Maybe (PreparedQuery b) -> OnBaseMonad (ExecutionMonad b) (ActionResult b) -> ResolvedConnectionTemplate b -> DBStepInfo b
[dbsiSourceName] :: DBStepInfo b -> SourceName
[dbsiSourceConfig] :: DBStepInfo b -> SourceConfig b
[dbsiPreparedQuery] :: DBStepInfo b -> Maybe (PreparedQuery b)
[dbsiAction] :: DBStepInfo b -> OnBaseMonad (ExecutionMonad b) (ActionResult b)
[dbsiResolvedConnectionTemplate] :: DBStepInfo b -> ResolvedConnectionTemplate b
data ActionResult b
ActionResult :: Maybe (ExecutionStatistics b) -> EncJSON -> ActionResult b
[arStatistics] :: ActionResult b -> Maybe (ExecutionStatistics b)
[arResult] :: ActionResult b -> EncJSON

-- | Lift a result from the database into an <a>ActionResult</a>.
withNoStatistics :: EncJSON -> ActionResult b

-- | Provides an abstraction over the base monad in which a computation
--   runs.
--   
--   Given a transformer <tt>t</tt> and a type <tt>a</tt>, <tt>OnBaseMonad
--   t a</tt> represents a computation of type <tt>t m a</tt>, for any base
--   monad <tt>m</tt>. This allows <a>DBStepInfo</a> to store a
--   backend-specific computation, using a backend-specific monad
--   transformer, on top of the base app monad, without <a>DBStepInfo</a>
--   needing to know about the base monad <tt>m</tt>.
--   
--   However, this kind of type erasure forces us to bundle all of the
--   constraints on the base monad <tt>m</tt> here. The constraints here
--   are the union of the constraints required across all backends. If it
--   were possible to express constraint functions of the form <tt>(Type
--   -&gt; Type) -&gt; Constraint</tt> at the type level, we could make the
--   list of constraints a type family in <a>BackendExecute</a>, allowing
--   each backend to specify its own specific constraints; and we could
--   then provide the list of constraints as an additional argument to
--   <tt>OnBaseMonad</tt>, pushing the requirement to implement the union
--   of all constraints to the base execution functions.
--   
--   All backends require <tt>MonadError QErr</tt> to report errors, and
--   <a>MonadIO</a> to be able to communicate over the network. Most of
--   them require <a>MonadTrace</a> to be able to create new spans as part
--   of the execution, and several use <tt>MonadBaseControl IO</tt> to use
--   <tt>try</tt> in their error handling.
newtype OnBaseMonad t a
OnBaseMonad :: (forall m. (Functor (t m), MonadIO m, MonadBaseControl IO m, MonadTrace m, MonadError QErr m) => t m a) -> OnBaseMonad t a
[runOnBaseMonad] :: OnBaseMonad t a -> forall m. (Functor (t m), MonadIO m, MonadBaseControl IO m, MonadTrace m, MonadError QErr m) => t m a

-- | The result of an explain query: for a given root field (denoted by its
--   name): the generated SQL query, and the detailed explanation obtained
--   from the database (if any). We mostly use this type as an intermediary
--   step, and immediately tranform any value we obtain into an equivalent
--   JSON representation.
data ExplainPlan
ExplainPlan :: !RootFieldAlias -> !Maybe Text -> !Maybe [Text] -> ExplainPlan
[_fpField] :: ExplainPlan -> !RootFieldAlias
[_fpSql] :: ExplainPlan -> !Maybe Text
[_fpPlan] :: ExplainPlan -> !Maybe [Text]

-- | One execution step to processing a GraphQL query (e.g. one root
--   field).
data ExecutionStep

-- | A query to execute against the database
[ExecStepDB] :: ResponseHeaders -> AnyBackend DBStepInfo -> Maybe RemoteJoins -> ExecutionStep

-- | Execute an action
[ExecStepAction] :: ActionExecutionPlan -> ActionsInfo -> Maybe RemoteJoins -> ExecutionStep

-- | A graphql query to execute against a remote schema
[ExecStepRemote] :: !RemoteSchemaInfo -> !ResultCustomizer -> !GQLReqOutgoing -> Maybe RemoteJoins -> ExecutionStep

-- | Output a plain JSON object
[ExecStepRaw] :: Value -> ExecutionStep
[ExecStepMulti] :: [ExecutionStep] -> ExecutionStep

-- | The series of steps that need to be executed for a given query. For
--   now, those steps are all independent. In the future, when we implement
--   a client-side dataloader and generalized joins, this will need to be
--   changed into an annotated tree.
type ExecutionPlan = RootFieldMap ExecutionStep
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Backend.ExplainPlan
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Backend.ExplainPlan
instance GHC.Show.Show Hasura.GraphQL.Execute.Backend.ExplainPlan
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Execute.Backend.ExplainPlan
instance GHC.Base.Functor (Hasura.GraphQL.Execute.Backend.OnBaseMonad t)


-- | This module holds functions and data types used for logging at the
--   GraphQL layer. Unlike QueryLog, these are fired after queries are
--   finished so could include things like execution time in future.
module Hasura.GraphQL.Logging.ExecutionLog

-- | A GraphQL query, optionally generated SQL, and the request id makes up
--   the | <a>ExecutionLog</a>
data ExecutionLog
ExecutionLog :: !RequestId -> !Maybe (AnyBackend ExecutionStats) -> ExecutionLog
[_elRequestId] :: ExecutionLog -> !RequestId
[_elStatistics] :: ExecutionLog -> !Maybe (AnyBackend ExecutionStats)

-- | <a>ExecutionStatistics</a> is a type family, which means we can't
--   partially apply it (in <a>AnyBackend</a>, for example). To get round
--   this, we have a newtype that really just wraps the type family.
newtype ExecutionStats b
ExecutionStats :: ExecutionStatistics b -> ExecutionStats b

-- | When we want to log anything from <tt>DBStepInfo</tt>, we first need
--   to transform the backend-specific execution statistics into
--   <a>AnyBackend</a> statistics. This is fine in practice because all we
--   do with it is log it as JSON.
statsToAnyBackend :: forall b. HasTag b => ActionResult b -> (Maybe (AnyBackend ExecutionStats), EncJSON)
class (Monad m) => MonadExecutionLog m
logExecutionLog :: MonadExecutionLog m => Logger Hasura -> ExecutionLog -> m ()
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.GraphQL.Logging.ExecutionLog.ExecutionStats b)
instance Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog m => Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog m => Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog m => Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog (Hasura.Tracing.Monad.TraceT m)
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Logging.ExecutionLog.ExecutionLog
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Logging.ExecutionLog.ExecutionLog Hasura.Logging.Hasura


-- | This module holds functions and data types used for logging at the
--   GraphQL layer. In contrast with, logging at the HTTP server layer.
module Hasura.GraphQL.Logging

module Hasura.GraphQL.Transport.Backend

-- | This typeclass enacapsulates how a given backend sends queries and
--   mutations over the network. Each backend is currently responsible for
--   both logging and tracing, for now.
class (BackendExecute b) => BackendTransport (b :: BackendType)
runDBQuery :: forall m. (BackendTransport b, MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadQueryLog m, MonadExecutionLog m, MonadTrace m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> SourceConfig b -> OnBaseMonad (ExecutionMonad b) (Maybe (AnyBackend ExecutionStats), EncJSON) -> Maybe (PreparedQuery b) -> ResolvedConnectionTemplate b -> m (DiffTime, EncJSON)
runDBMutation :: forall m. (BackendTransport b, MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadQueryLog m, MonadTrace m) => RequestId -> GQLReqUnparsed -> RootFieldAlias -> UserInfo -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> SourceConfig b -> OnBaseMonad (ExecutionMonad b) EncJSON -> Maybe (PreparedQuery b) -> ResolvedConnectionTemplate b -> m (DiffTime, EncJSON)
runDBSubscription :: forall m. (BackendTransport b, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> MultiplexedQuery b -> [(CohortId, CohortVariables)] -> ResolvedConnectionTemplate b -> m (DiffTime, Either QErr [(CohortId, ByteString)])
runDBStreamingSubscription :: forall m. (BackendTransport b, MonadIO m, MonadBaseControl IO m) => SourceConfig b -> MultiplexedQuery b -> [(CohortId, CohortVariables)] -> ResolvedConnectionTemplate b -> m (DiffTime, Either QErr [(CohortId, ByteString, CursorVariableValues)])
runDBQueryExplain :: forall m. (BackendTransport b, MonadIO m, MonadError QErr m, MonadBaseControl IO m, MonadTrace m) => Maybe (CredentialCache AgentLicenseKey) -> DBStepInfo b -> m EncJSON

module Hasura.GraphQL.Execute.Subscription.Poll.StreamingQuery

-- | A single iteration of the streaming query polling loop. Invocations on
--   the same mutable objects may race.
pollStreamingQuery :: forall b. BackendTransport b => PollerId -> TVar PollerResponseState -> SubscriptionsOptions -> (SourceName, SourceConfig b) -> RoleName -> ParameterizedQueryHash -> MultiplexedQuery b -> CohortMap 'Streaming -> Name -> SubscriptionPostPollHook -> Maybe (IO ()) -> PrometheusMetrics -> IO GranularPrometheusMetricsState -> TMap (Maybe OperationName) Int -> ResolvedConnectionTemplate b -> Maybe (Endo Value) -> IO ()


-- | Multiplexed subscription poller threads; see
--   <a>Hasura.GraphQL.Execute.Subscription</a> for details.
module Hasura.GraphQL.Execute.Subscription.Poll.LiveQuery

-- | Where the magic happens: the top-level action run periodically by each
--   active <a>SubscriptionTypes</a>. This needs to be async exception
--   safe.
pollLiveQuery :: forall b. BackendTransport b => PollerId -> TVar PollerResponseState -> SubscriptionsOptions -> (SourceName, SourceConfig b) -> RoleName -> ParameterizedQueryHash -> MultiplexedQuery b -> CohortMap 'LiveQuery -> SubscriptionPostPollHook -> PrometheusMetrics -> IO GranularPrometheusMetricsState -> TMap (Maybe OperationName) Int -> ResolvedConnectionTemplate b -> Maybe (Endo Value) -> IO ()


-- | Multiplexed subscription poller threads; see
--   <a>Hasura.GraphQL.Execute.Subscription</a> for details.
module Hasura.GraphQL.Execute.Subscription.Poll


-- | Top-level management of subscription poller threads. The
--   implementation of the polling itself is in
--   <a>Hasura.GraphQL.Execute.Subscription.Poll</a>. See
--   <a>Hasura.GraphQL.Execute.Subscription</a> for high-level details.
module Hasura.GraphQL.Execute.Subscription.State

-- | The top-level datatype that holds the state for all active
--   subscriptions.
--   
--   NOTE!: This must be kept consistent with a websocket connection's
--   <tt>OperationMap</tt>, in <tt>onClose</tt> and <tt>onStart</tt>.
data SubscriptionsState
SubscriptionsState :: PollerMap () -> PollerMap (TVar CursorVariableValues) -> SubscriptionPostPollHook -> AsyncActionSubscriptionState -> SubscriptionsState
[_ssLiveQueryMap] :: SubscriptionsState -> PollerMap ()
[_ssStreamQueryMap] :: SubscriptionsState -> PollerMap (TVar CursorVariableValues)

-- | A hook function which is run after each fetch cycle
[_ssPostPollHook] :: SubscriptionsState -> SubscriptionPostPollHook
[_ssAsyncActions] :: SubscriptionsState -> AsyncActionSubscriptionState
initSubscriptionsState :: SubscriptionPostPollHook -> IO SubscriptionsState

-- | For dev debugging, output subject to change.
dumpSubscriptionsState :: Bool -> LiveQueriesOptions -> StreamQueriesOptions -> SubscriptionsState -> IO Value

-- | SubscriberDetails contains the data required to locate a subscriber in
--   the correct cohort within the correct poller in the operation map.
data SubscriberDetails a
type LiveQuerySubscriberDetails = SubscriberDetails CohortKey

-- | The <a>CohortKey</a> contains the variables with which the
--   subscription was started and which will remain unchanged. The second
--   type contains the mutable reference through which we can get the
--   latest value of the cursor and using both the <a>CohortKey</a> and the
--   latest cursor value, we locate the subscriber in the operation map to
--   find its details and then stop it.
type StreamingSubscriberDetails = SubscriberDetails (CohortKey, TVar CursorVariableValues)

-- | Fork a thread handling a regular (live query) subscription
addLiveQuery :: forall b. BackendTransport b => Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriberMetadata -> SubscriptionsState -> IO (LiveQueriesOptions, StreamQueriesOptions) -> SourceName -> ParameterizedQueryHash -> Maybe OperationName -> RequestId -> SubscriptionQueryPlan b (MultiplexedQuery b) -> IO GranularPrometheusMetricsState -> OnChange -> Maybe (Endo Value) -> IO LiveQuerySubscriberDetails

-- | Fork a thread handling a streaming subscription
addStreamSubscriptionQuery :: forall b. BackendTransport b => Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriberMetadata -> SubscriptionsState -> IO (LiveQueriesOptions, StreamQueriesOptions) -> SourceName -> ParameterizedQueryHash -> Maybe OperationName -> RequestId -> Name -> SubscriptionQueryPlan b (MultiplexedQuery b) -> IO GranularPrometheusMetricsState -> OnChange -> Maybe (Endo Value) -> IO StreamingSubscriberDetails
removeLiveQuery :: Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriptionsState -> LiveQuerySubscriberDetails -> IO GranularPrometheusMetricsState -> Maybe OperationName -> IO ()
removeStreamingQuery :: Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriptionsState -> StreamingSubscriberDetails -> IO GranularPrometheusMetricsState -> Maybe OperationName -> IO ()

-- | An async action query whose relationships are referred to table in a
--   source. We need to generate an SQL statement with the action response
--   and execute it in the source database so as to fetch response joined
--   with relationship rows. For more details see Note [Resolving async
--   action query]
data LiveAsyncActionQueryOnSource
LiveAsyncActionQueryOnSource :: !LiveQuerySubscriberDetails -> !ActionLogResponseMap -> !LiveQuerySubscriberDetails -> ActionLogResponseMap -> IO (Maybe LiveQuerySubscriberDetails) -> LiveAsyncActionQueryOnSource
[_laaqpCurrentLqId] :: LiveAsyncActionQueryOnSource -> !LiveQuerySubscriberDetails
[_laaqpPrevActionLogMap] :: LiveAsyncActionQueryOnSource -> !ActionLogResponseMap

-- | An IO action to restart the live query poller with updated action log
--   responses fetched from metadata storage Restarting a live query
--   re-generates the SQL statement with new action log responses to send
--   latest action response to the client.
[_laaqpRestartLq] :: LiveAsyncActionQueryOnSource -> !LiveQuerySubscriberDetails -> ActionLogResponseMap -> IO (Maybe LiveQuerySubscriberDetails)
data LiveAsyncActionQueryWithNoRelationships
LiveAsyncActionQueryWithNoRelationships :: !ActionLogResponseMap -> IO () -> !IO () -> LiveAsyncActionQueryWithNoRelationships

-- | An IO action to send response to the websocket client
[_laaqwnrSendResponse] :: LiveAsyncActionQueryWithNoRelationships -> !ActionLogResponseMap -> IO ()

-- | An IO action to send "completed" message to the websocket client
[_laaqwnrSendCompleted] :: LiveAsyncActionQueryWithNoRelationships -> !IO ()
data LiveAsyncActionQuery
LAAQNoRelationships :: LiveAsyncActionQueryWithNoRelationships -> LiveAsyncActionQuery
LAAQOnSourceDB :: LiveAsyncActionQueryOnSource -> LiveAsyncActionQuery
data AsyncActionQueryLive
AsyncActionQueryLive :: NonEmpty ActionId -> (QErr -> IO ()) -> LiveAsyncActionQuery -> AsyncActionQueryLive
[_aaqlActionIds] :: AsyncActionQueryLive -> NonEmpty ActionId

-- | An IO action to send error message (in case of any exception) to the
--   websocket client
[_aaqlOnException] :: AsyncActionQueryLive -> QErr -> IO ()
[_aaqlLiveExecution] :: AsyncActionQueryLive -> LiveAsyncActionQuery

-- | A share-able state map which stores an async action live query with
--   it's subscription operation id
type AsyncActionSubscriptionState = TMap OperationId AsyncActionQueryLive
addAsyncActionLiveQuery :: AsyncActionSubscriptionState -> OperationId -> NonEmpty ActionId -> (QErr -> IO ()) -> LiveAsyncActionQuery -> IO ()
removeAsyncActionLiveQuery :: AsyncActionSubscriptionState -> OperationId -> IO ()
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Execute.Subscription.State.SubscriberDetails a)

module Hasura.GraphQL.Execute.Remote
getVariableDefinitionAndValue :: Variable -> (VariableDefinition, (Name, Value))
buildExecStepRemote :: RemoteSchemaInfo -> ResultCustomizer -> OperationType -> GraphQLField Void Variable -> Maybe RemoteJoins -> Maybe OperationName -> ExecutionStep

-- | Resolves a <a>RemoteSchemaVariable</a> into a GraphQL <a>Variable</a>.
--   
--   A <a>RemoteSchemaVariable</a> can either be a query variable (i.e. a
--   variable provided in the query) or it can be a
--   <a>SessionPresetVariable</a> (in which case we look up the value of
--   the session variable and coerce it into the appropriate type and then
--   construct the GraphQL <a>Variable</a>).
--   
--   NOTE: The session variable preset is a hard preset (i.e. if the
--   session variable doesn't exist, an error will be thrown).
--   
--   The name of the GraphQL variable generated will be a GraphQL-ized
--   version of the session variable (i.e. <a>-</a> will be replaced with
--   '_'), since session variables are not valid GraphQL names.
--   
--   Additionally, we need to handle partially traversed JSON values;
--   likewise, we create a new variable out of thin air.
--   
--   For example, considering the following schema for a role:
--   
--   input UserName { firstName : String! @preset(value:<a>Foo</a>)
--   lastName : String! }
--   
--   type Query { user( user_id: Int! @preset(value:"x-hasura-user-id")
--   user_name: UserName! ): User }
--   
--   and the incoming query to the graphql-engine is:
--   
--   query($foo: UserName!) { user(user_name: $foo) { id name } }
--   
--   with variables:
--   
--   { "foo": {"lastName": <a>Bar</a>} }
--   
--   After resolving the session argument presets, the query that will be
--   sent to the remote server will be:
--   
--   query ($x_hasura_user_id: Int!, $hasura_json_var_1: String!) { user
--   (user_id: $x_hasura_user_id, user_name: {firstName: <a>Foo</a>,
--   lastName: $hasura_json_var_1}) { id name } }
resolveRemoteVariable :: MonadError QErr m => UserInfo -> RemoteSchemaVariable -> StateT RemoteJSONVariableMap m Variable

-- | TODO: Documentation.
resolveRemoteField :: MonadError QErr m => UserInfo -> RemoteSchemaRootField r RemoteSchemaVariable -> StateT RemoteJSONVariableMap m (RemoteSchemaRootField r Variable)

-- | TODO: Documentation.
runVariableCache :: Monad m => StateT RemoteJSONVariableMap m a -> m a
instance Data.Hashable.Class.Hashable Hasura.GraphQL.Execute.Remote.RemoteJSONVariableKey
instance GHC.Generics.Generic Hasura.GraphQL.Execute.Remote.RemoteJSONVariableKey
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Remote.RemoteJSONVariableKey
instance GHC.Base.Semigroup Hasura.GraphQL.Execute.Remote.RemoteJSONVariableMap
instance GHC.Base.Monoid Hasura.GraphQL.Execute.Remote.RemoteJSONVariableMap
instance GHC.Classes.Eq Hasura.GraphQL.Execute.Remote.RemoteJSONVariableMap


-- | How to construct and execute a call to a remote schema for a remote
--   join.
--   
--   There are three steps required to do this: 1. construct the call:
--   given the requested fields, the phantom fields, the values extracted
--   by the LHS, construct a GraphQL query 2. execute that GraphQL query
--   over the network 3. build a index of the variables out of the response
--   
--   This can be done as one function, but we also export the individual
--   steps for debugging / test purposes. We congregate all intermediary
--   state in the opaque <a>RemoteSchemaCall</a> type.
module Hasura.GraphQL.Execute.RemoteJoin.RemoteSchema

-- | Construct and execute a call to a remote schema for a remote join.
makeRemoteSchemaJoinCall :: (MonadError QErr m, MonadTrace m, MonadIO m) => (GQLReqOutgoing -> m ByteString) -> UserInfo -> RemoteSchemaJoin -> FieldName -> IntMap JoinArgument -> m (Maybe (IntMap Value))

-- | Intermediate type containing all of the information required to
--   perform a remote schema call, constructed from the static join
--   information.
data RemoteSchemaCall

-- | Constructs a <a>RemoteSchemaCall</a> from some static information,
--   such as the definition of the join, and dynamic information such as
--   the user's information and the map of join arguments.
buildRemoteSchemaCall :: MonadError QErr m => RemoteSchemaJoin -> IntMap JoinArgument -> UserInfo -> m (Maybe RemoteSchemaCall)

-- | Sends the call over the network, and parse the resulting ByteString.
executeRemoteSchemaCall :: MonadError QErr m => (GQLReqOutgoing -> m ByteString) -> RemoteSchemaCall -> m Object

-- | Construct a join index from the remote source's <a>Value</a> response.
--   
--   This function extracts from the <tt>RemoteJoinCall</tt> a mapping from
--   <a>JoinArgumentId</a> to <a>ResponsePath</a>: from an integer that
--   uniquely identifies a join argument to the "path" at which we expect
--   that value in the response. With it, and with the actual reponse JSON
--   value obtained from the remote server, it constructs a corresponding
--   mapping of, for each argument, its extracted value.
--   
--   If the response does not have value at any of the provided
--   <a>ResponsePath</a>s, throw a generic <a>QErr</a>.
--   
--   NOTE(jkachmar): If we switch to an <a>Applicative</a> validator, we
--   can collect more than one missing <a>ResponsePath</a>s (rather than
--   short-circuiting on the first missing value).
buildJoinIndex :: forall m. MonadError QErr m => RemoteSchemaCall -> Object -> m (IntMap Value)
instance GHC.Show.Show Hasura.GraphQL.Execute.RemoteJoin.RemoteSchema.ResponsePath
instance GHC.Classes.Eq Hasura.GraphQL.Execute.RemoteJoin.RemoteSchema.ResponsePath

module Hasura.GraphQL.Execute.Common

-- | Typeclass representing safety checks (if any) that need to be
--   performed before a GraphQL query should be allowed to be executed. In
--   OSS, the safety check is to check in the query is in the allow list.
--   
--   the <a>executeIntrospection</a> function has different implementations
--   in OSS and Pro. In Pro, the GraphQL schema introspection can be
--   disabled for specified roles and in OSS there is no restrictions.
--   
--   | TODO (from master): Limitation: This parses the query, which is not
--   ideal if we already have the query cached. The parsing happens
--   unnecessary. But getting this to either return a plan or parse was
--   tricky and complicated.
class (Monad m) => MonadGQLExecutionCheck m
checkGQLExecution :: MonadGQLExecutionCheck m => UserInfo -> ([Header], IpAddress) -> AllowListStatus -> SchemaCache -> GQLReqUnparsed -> RequestId -> m (Either QErr GQLReqParsed)
executeIntrospection :: MonadGQLExecutionCheck m => UserInfo -> Value -> SetGraphqlIntrospectionOptions -> m (Either QErr ExecutionStep)
checkGQLBatchedReqs :: MonadGQLExecutionCheck m => UserInfo -> RequestId -> [GQLReq GQLQueryText] -> SchemaCache -> m (Either QErr ())
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Hasura.Tracing.Monad.TraceT m)


-- | Postgres Execute Prepare
--   
--   Deals with translating (session) variables to SQL expressions. Uses a
--   state monad to keep track of things like variables and generating
--   fresh variable names.
--   
--   See <a>Execute</a>.
module Hasura.Backends.Postgres.Execute.Prepare
type PlanVariables = HashMap PlanVariable Int

-- | The value is (PG.PrepArg, PGScalarValue) because we want to log the
--   human-readable value of the prepared argument and not the binary
--   encoding in PG format
type PrepArgMap = IntMap (PrepArg, PGScalarValue)
data PlanningSt
PlanningSt :: Int -> PlanVariables -> PrepArgMap -> PlanningSt
[_psArgNumber] :: PlanningSt -> Int
[_psVariables] :: PlanningSt -> PlanVariables
[_psPrepped] :: PlanningSt -> PrepArgMap
initPlanningSt :: PlanningSt

-- | If we're preparing a value with planning state, we favour referring to
--   values by their prepared argument index. If the value refers to a
--   session value, we look for it in prepared value (1) and access the
--   particular keys using the JSONB <tt>-&gt;&gt;</tt> accessor.
prepareWithPlan :: (MonadState PlanningSt m, MonadError QErr m) => UserInfo -> UnpreparedValue ('Postgres pgKind) -> m SQLExp

-- | If we're <i>not</i> using a prepared statement, substitution is pretty
--   naÃ¯ve: we resolve session variable names, ignore parameter names, and
--   substitute into the <a>SQLExp</a>.
prepareWithoutPlan :: MonadError QErr m => UserInfo -> UnpreparedValue ('Postgres pgKind) -> m SQLExp

-- | The map of user session variables is always given the number (1) as
--   its variable argument number (see <a>getVarArgNum</a>). If we want to
--   refer to a particular variable in this map, we use JSONB functions to
--   interrogate variable (1).
withUserVars :: SessionVariables -> PrepArgMap -> PrepArgMap
instance Data.Hashable.Class.Hashable Hasura.Backends.Postgres.Execute.Prepare.PlanVariable
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.Prepare.PlanVariable
instance GHC.Generics.Generic Hasura.Backends.Postgres.Execute.Prepare.PlanVariable
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Prepare.PlanVariable
instance GHC.Show.Show Hasura.Backends.Postgres.Execute.Prepare.PlanningSt
instance GHC.Classes.Eq Hasura.Backends.Postgres.Execute.Prepare.PlanningSt


-- | Postgres Instances Execute
--   
--   This module implements the needed functionality for implementing a
--   <a>BackendExecute</a> instance for Postgres, which defines an
--   interface for translating a root field into an execution plan and
--   interacting with a database.
--   
--   This module includes the Postgres implementation of queries,
--   mutations, and more.
module Hasura.Backends.Postgres.Instances.Execute
data PreparedSql
PreparedSql :: Query -> PrepArgMap -> PreparedSql
[_psQuery] :: PreparedSql -> Query
[_psPrepArgs] :: PreparedSql -> PrepArgMap

-- | Used by the @dc-postgres-agent to compile a query.
pgDBQueryPlanSimple :: MonadError QErr m => UserInfo -> QueryTagsComment -> QueryDB ('Postgres 'Vanilla) Void (UnpreparedValue ('Postgres 'Vanilla)) -> m (OnBaseMonad (TxET QErr) EncJSON, Maybe PreparedSql)
instance GHC.Show.Show Hasura.Backends.Postgres.Instances.Execute.PreparedSql
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), Hasura.Backends.Postgres.Translate.Select.PostgresTranslateSelect pgKind) => Hasura.GraphQL.Execute.Backend.BackendExecute ('Hasura.RQL.Types.BackendType.Postgres pgKind)


-- | Postgres Instances Transport
--   
--   Defines the MSSQL instance of <a>BackendTransport</a> and how to
--   interact with the database for running queries, mutations,
--   subscriptions, and so on.
module Hasura.Backends.Postgres.Instances.Transport
runPGMutationTransaction :: forall pgKind m. (HasTag ('Postgres pgKind), MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadQueryLog m, MonadTrace m) => RequestId -> GQLReqUnparsed -> UserInfo -> Logger Hasura -> SourceConfig ('Postgres pgKind) -> ResolvedConnectionTemplate ('Postgres pgKind) -> RootFieldMap (DBStepInfo ('Postgres pgKind)) -> m (DiffTime, RootFieldMap EncJSON)
instance (Hasura.RQL.Types.Backend.Backend ('Hasura.RQL.Types.BackendType.Postgres pgKind), Hasura.Backends.Postgres.Translate.Select.PostgresTranslateSelect pgKind) => Hasura.GraphQL.Transport.Backend.BackendTransport ('Hasura.RQL.Types.BackendType.Postgres pgKind)


-- | Responsible for translating and building an MSSQL execution plan for
--   update mutations.
--   
--   This module is used by <a>Hasura.Backends.MSSQL.Instances.Execute</a>.
module Hasura.Backends.MSSQL.Execute.Update

-- | Executes an Update IR AST and return results as JSON.
executeUpdate :: (MonadError QErr m, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceConfig 'MSSQL -> AnnotatedUpdateG 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (OnBaseMonad (ExceptT QErr) EncJSON)


-- | Responsible for translating and building an MSSQL execution plan for
--   delete mutations.
--   
--   This module is used by <a>Hasura.Backends.MSSQL.Instances.Execute</a>.
module Hasura.Backends.MSSQL.Execute.Insert

-- | Execute and insert/upsert mutation against MS SQL Server. See the
--   documentation for <a>buildInsertTx</a> to see how it's done.
executeInsert :: (MonadError QErr m, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceConfig 'MSSQL -> AnnotatedInsert 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (OnBaseMonad (ExceptT QErr) EncJSON)


-- | Responsible for translating and building an MSSQL execution plan for
--   delete mutations.
--   
--   This module is used by <a>Hasura.Backends.MSSQL.Instances.Execute</a>.
module Hasura.Backends.MSSQL.Execute.Delete

-- | Executes a Delete IR AST and return results as JSON.
executeDelete :: (MonadError QErr m, MonadReader QueryTagsComment m) => UserInfo -> StringifyNumbers -> SourceConfig 'MSSQL -> AnnDelG 'MSSQL Void (UnpreparedValue 'MSSQL) -> m (OnBaseMonad (ExceptT QErr) EncJSON)

module Hasura.Backends.BigQuery.Instances.Execute
instance Hasura.GraphQL.Execute.Backend.BackendExecute 'Hasura.RQL.Types.BackendType.BigQuery

module Hasura.RemoteSchema.MetadataAPI.Core

-- | The payload for <tt>add_remote_schema</tt>, and a component of
--   <a>Metadata</a>.
data AddRemoteSchemaQuery
AddRemoteSchemaQuery :: RemoteSchemaName -> RemoteSchemaDef -> Maybe Text -> AddRemoteSchemaQuery

-- | An internal identifier for this remote schema.
[_arsqName] :: AddRemoteSchemaQuery -> RemoteSchemaName
[_arsqDefinition] :: AddRemoteSchemaQuery -> RemoteSchemaDef

-- | An opaque description or comment. We might display this in the UI, for
--   instance.
[_arsqComment] :: AddRemoteSchemaQuery -> Maybe Text
newtype RemoteSchemaNameQuery
RemoteSchemaNameQuery :: RemoteSchemaName -> RemoteSchemaNameQuery
[_rsnqName] :: RemoteSchemaNameQuery -> RemoteSchemaName
runAddRemoteSchema :: (QErrM m, CacheRWM m, MonadIO m, ProvidesNetwork m, MetadataM m, MonadTrace m) => Environment -> AddRemoteSchemaQuery -> m EncJSON
runRemoveRemoteSchema :: (QErrM m, UserInfoM m, CacheRWM m, MetadataM m) => RemoteSchemaNameQuery -> m EncJSON
runReloadRemoteSchema :: (QErrM m, CacheRWM m, MetadataM m) => RemoteSchemaNameQuery -> m EncJSON
runIntrospectRemoteSchema :: (CacheRM m, QErrM m) => RemoteSchemaNameQuery -> m EncJSON
runUpdateRemoteSchema :: (QErrM m, CacheRWM m, MonadIO m, ProvidesNetwork m, MetadataM m, MonadTrace m) => Environment -> AddRemoteSchemaQuery -> m EncJSON
instance GHC.Generics.Generic Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery
instance GHC.Classes.Eq Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery
instance GHC.Show.Show Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery
instance GHC.Generics.Generic Hasura.RemoteSchema.MetadataAPI.Core.RemoteSchemaNameQuery
instance GHC.Classes.Eq Hasura.RemoteSchema.MetadataAPI.Core.RemoteSchemaNameQuery
instance GHC.Show.Show Hasura.RemoteSchema.MetadataAPI.Core.RemoteSchemaNameQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.MetadataAPI.Core.RemoteSchemaNameQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.MetadataAPI.Core.RemoteSchemaNameQuery
instance Control.DeepSeq.NFData Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RemoteSchema.MetadataAPI.Core.AddRemoteSchemaQuery

module Hasura.RemoteSchema.MetadataAPI

module Hasura.RQL.DDL.Schema.Cache.Dependencies

-- | Processes collected <tt>CIDependency</tt> values into a <a>DepMap</a>,
--   performing integrity checking to ensure the dependencies actually
--   exist. If a dependency is missing, its transitive dependents are
--   removed from the cache, and <a>InconsistentMetadata</a>s are returned.
resolveDependencies :: (ArrowKleisli m arr, QErrM m) => (BuildOutputs, [MetadataDependency]) `arr` (BuildOutputs, [InconsistentMetadata], DepMap)

module Hasura.RQL.DDL.GraphqlSchemaIntrospection
runSetGraphqlSchemaIntrospectionOptions :: (MonadError QErr m, MetadataM m, CacheRWM m) => SetGraphqlIntrospectionOptions -> m EncJSON


module Hasura.Function.API
newtype TrackFunction b
TrackFunction :: FunctionName b -> TrackFunction b
[tfName] :: TrackFunction b -> FunctionName b

-- | Track function, Phase 1: Validate function tracking operation. Fails
--   if function is already being tracked, or if a table with the same name
--   is being tracked.
trackFunctionP1 :: forall b m. (CacheRM m, QErrM m, Backend b) => SourceName -> FunctionName b -> m ()
trackFunctionP2 :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => SourceName -> FunctionName b -> FunctionConfig b -> Maybe Text -> m EncJSON
getSingleUniqueFunctionOverload :: forall b m. (QErrM m, Backend b) => FunctionName b -> FunctionOverloads b -> m (RawFunctionInfo b)
runTrackFunc :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => TrackFunction b -> m EncJSON

-- | JSON API payload for v2 of <tt>track_function</tt>:
--   
--   
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/schema-metadata-api/custom-functions.html#track-function-v2</a>
data TrackFunctionV2 (b :: BackendType)
TrackFunctionV2 :: SourceName -> FunctionName b -> FunctionConfig b -> Maybe Text -> TrackFunctionV2 (b :: BackendType)
[_tfv2Source] :: TrackFunctionV2 (b :: BackendType) -> SourceName
[_tfv2Function] :: TrackFunctionV2 (b :: BackendType) -> FunctionName b
[_tfv2Configuration] :: TrackFunctionV2 (b :: BackendType) -> FunctionConfig b
[_tfv2Comment] :: TrackFunctionV2 (b :: BackendType) -> Maybe Text
runTrackFunctionV2 :: forall b m. (BackendMetadata b, QErrM m, CacheRWM m, MetadataM m) => TrackFunctionV2 b -> m EncJSON

-- | JSON API payload for <tt>untrack_function</tt>:
--   
--   
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/schema-metadata-api/custom-functions.html#untrack-function</a>
data UnTrackFunction b
UnTrackFunction :: FunctionName b -> SourceName -> UnTrackFunction b
[_utfFunction] :: UnTrackFunction b -> FunctionName b
[_utfSource] :: UnTrackFunction b -> SourceName
runUntrackFunc :: forall b m. (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => UnTrackFunction b -> m EncJSON
data FunctionPermissionArgument b
FunctionPermissionArgument :: FunctionName b -> SourceName -> RoleName -> FunctionPermissionArgument b
[_afpFunction] :: FunctionPermissionArgument b -> FunctionName b
[_afpSource] :: FunctionPermissionArgument b -> SourceName
[_afpRole] :: FunctionPermissionArgument b -> RoleName
runCreateFunctionPermission :: forall b m. (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => FunctionPermissionArgument b -> m EncJSON
dropFunctionPermissionInMetadata :: forall b. BackendMetadata b => SourceName -> FunctionName b -> RoleName -> MetadataModifier
doesFunctionPermissionExist :: forall b. BackendMetadata b => Metadata -> SourceName -> FunctionName b -> RoleName -> Bool
runDropFunctionPermission :: forall m b. (CacheRWM m, MonadError QErr m, MetadataM m, BackendMetadata b) => FunctionPermissionArgument b -> m EncJSON

-- | Represents the payload of the API command
--   <tt>pg_set_function_customization</tt>.
--   
--   See the Hasura API reference for a detailed description.
data SetFunctionCustomization b
SetFunctionCustomization :: SourceName -> FunctionName b -> FunctionConfig b -> SetFunctionCustomization b
[_sfcSource] :: SetFunctionCustomization b -> SourceName
[_sfcFunction] :: SetFunctionCustomization b -> FunctionName b
[_sfcConfiguration] :: SetFunctionCustomization b -> FunctionConfig b

-- | Changes the custom names of a function. Used in the API command
--   <tt>pg_set_function_customization</tt>.
runSetFunctionCustomization :: forall b m. (QErrM m, CacheRWM m, MetadataM m, Backend b) => SetFunctionCustomization b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.API.TrackFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.ToJSON.ToJSON (Hasura.Function.API.TrackFunction b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.Function.API.SetFunctionCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.Function.API.SetFunctionCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.API.SetFunctionCustomization b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.API.FunctionPermissionArgument b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.API.UnTrackFunction b)
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.Function.API.TrackFunctionV2 b)

module Hasura.RQL.DDL.Schema.Cache.Fields
addNonColumnFields :: forall b m. (MonadWriter (Seq CollectItem) m, BackendMetadata b) => HashMap SourceName (AnyBackend PartiallyResolvedSource) -> SourceName -> SourceConfig b -> HashMap (TableName b) (TableCoreInfoG b (StructuredColumnInfo b) (ColumnInfo b)) -> FieldInfoMap (StructuredColumnInfo b) -> PartiallyResolvedRemoteSchemaMap -> DBFunctionsMetadata b -> NonColumnTableInputs b -> m (FieldInfoMap (FieldInfo b))


-- | Top-level functions concerned specifically with operations on the
--   schema cache, such as rebuilding it from the catalog and incorporating
--   schema changes. See the module documentation for
--   <a>Hasura.RQL.DDL.Schema</a> for more details.
--   
--   <b>Note</b>: this module is <b>mutually recursive</b> with other
--   <tt>Hasura.RQL.DDL.Schema.*</tt> modules, which both define pieces of
--   the implementation of building the schema cache and define handlers
--   that trigger schema cache rebuilds.
module Hasura.RQL.DDL.Schema.Cache
buildRebuildableSchemaCache :: Logger Hasura -> Environment -> MetadataWithResourceVersion -> CacheDynamicConfig -> Maybe SchemaRegistryContext -> CacheBuild RebuildableSchemaCache
data CacheRWT m a
runCacheRWT :: Monad m => CacheDynamicConfig -> RebuildableSchemaCache -> CacheRWT m a -> m (a, RebuildableSchemaCache, CacheInvalidations, SourcesIntrospectionStatus, SchemaRegistryAction)
saveSourcesIntrospection :: (MonadIO m, MonadMetadataStorage m) => Logger Hasura -> SourcesIntrospectionStatus -> MetadataResourceVersion -> m ()
instance Hasura.QueryTags.MonadQueryTags m => Hasura.QueryTags.MonadQueryTags (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.RQL.Types.Session.UserInfoM m => Hasura.RQL.Types.Session.UserInfoM (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance GHC.Generics.Generic (Hasura.RQL.DDL.Schema.Cache.BackendInfoAndSourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Show.Show (Hasura.RQL.DDL.Schema.Cache.BackendInfoAndSourceMetadata b)
instance Hasura.RQL.Types.Backend.Backend b => GHC.Classes.Eq (Hasura.RQL.DDL.Schema.Cache.BackendInfoAndSourceMetadata b)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.RQL.DDL.Schema.Cache.CacheRWT
instance GHC.Base.Monad m => Hasura.RQL.Types.SchemaCache.CacheRM (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)
instance (Control.Monad.IO.Class.MonadIO m, Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr m, Hasura.Services.Network.ProvidesNetwork m, Hasura.RQL.Types.Source.MonadResolveSource m, Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig m, Hasura.Metadata.Class.MonadMetadataStorage m) => Hasura.RQL.Types.SchemaCache.Build.CacheRWM (Hasura.RQL.DDL.Schema.Cache.CacheRWT m)


-- | This module (along with the various <tt>Hasura.RQL.DDL.Schema.*</tt>
--   modules) provides operations to load and modify the Hasura catalog and
--   schema cache.
--   
--   <ul>
--   <li>The <i>catalog</i> refers to the set of PostgreSQL tables and
--   views that store all schema information known by Hasura. This includes
--   any tracked Postgres tables, views, and functions, all remote schemas,
--   and any additionaly Hasura-specific information such as permissions
--   and relationships.</li>
--   </ul>
--   
--   Primitive functions for loading and modifying the catalog are defined
--   in <a>Hasura.RQL.DDL.Schema.Catalog</a>, but most uses are wrapped by
--   other functions to synchronize catalog information with the
--   information in the schema cache.
--   
--   <ul>
--   <li>The <i>schema cache</i> is a process-global value of type
--   <tt>SchemaCache</tt> that stores an in-memory representation of the
--   data stored in the catalog. The in-memory representation is not
--   identical to the data in the catalog, since it has some
--   post-processing applied to it in order to make it easier to consume
--   for other parts of the system, such as GraphQL schema generation. For
--   example, although column information is represented by
--   <tt>RawColumnInfo</tt>, the schema cache contains â€œprocessedâ€
--   <tt>ColumnInfo</tt> values, instead.</li>
--   </ul>
--   
--   Ultimately, the catalog is the source of truth for all information
--   contained in the schema cache, but to avoid rebuilding the entire
--   schema cache on every change to the catalog, various functions
--   incrementally update the cache when they modify the catalog.
module Hasura.RQL.DDL.Schema
data RunSQLRes
RunSQLRes :: Text -> Value -> RunSQLRes
[rrResultType] :: RunSQLRes -> Text
[rrResult] :: RunSQLRes -> Value
instance GHC.Classes.Eq Hasura.RQL.DDL.Schema.RunSQLRes
instance GHC.Generics.Generic Hasura.RQL.DDL.Schema.RunSQLRes
instance GHC.Show.Show Hasura.RQL.DDL.Schema.RunSQLRes
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.RQL.DDL.Schema.RunSQLRes
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.RQL.DDL.Schema.RunSQLRes
instance Database.PG.Query.Class.FromRes Hasura.RQL.DDL.Schema.RunSQLRes


-- | Migrations for the Hasura catalog.
--   
--   To add a new migration:
--   
--   <ol>
--   <li>Bump the catalog version number in
--   <tt>src-rsr/catalog_version.txt</tt>.</li>
--   <li>Add a migration script in the <tt>src-rsr<i>migrations</i></tt>
--   directory with the name
--   <tt><a>version</a>_to_<a>version</a>.sql</tt>.</li>
--   <li>Create a downgrade script in the <tt>src-rsr<i>migrations</i></tt>
--   directory with the name
--   <tt><a>version</a>_to_<a>version</a>.sql</tt>.</li>
--   <li>If making a new release, add the mapping from application version
--   to catalog schema version in
--   <tt>src-rsr/catalog_versions.txt</tt>.</li>
--   <li>If appropriate, add the change to
--   <tt>server<i>src-rsr</i>initialise.sql</tt> for fresh installations of
--   hasura.</li>
--   </ol>
--   
--   The Template Haskell code in this module will automatically compile
--   the new migration script into the <tt>graphql-engine</tt> executable.
--   
--   NOTE: Please have a look at the
--   `server<i>documentation</i>migration-guidelines.md` before adding any
--   new migration if you haven't already looked at it
module Hasura.Server.Migrate
data MigrationResult
MRNothingToDo :: MigrationResult
MRInitialized :: MigrationResult

-- | old catalog version
MRMigrated :: Text -> MigrationResult
MRMaintanenceMode :: MigrationResult
migrateCatalog :: forall m. (MonadTx m, MonadIO m, MonadBaseControl IO m) => Maybe (SourceConnConfiguration ('Postgres 'Vanilla)) -> ExtensionsSchema -> MaintenanceMode () -> UTCTime -> m (MigrationResult, MetadataWithResourceVersion)
downgradeCatalog :: forall m. (MonadIO m, MonadTx m) => Maybe (SourceConnConfiguration ('Postgres 'Vanilla)) -> DowngradeOptions -> UTCTime -> m MigrationResult
instance GHC.Classes.Eq Hasura.Server.Migrate.MigrationResult
instance GHC.Show.Show Hasura.Server.Migrate.MigrationResult
instance Hasura.Logging.ToEngineLog Hasura.Server.Migrate.MigrationResult Hasura.Logging.Hasura

module Hasura.RQL.DDL.Relationship.Rename
data RenameRel b
runRenameRel :: forall b m. (MonadError QErr m, CacheRWM m, MetadataM m, BackendMetadata b) => RenameRel b -> m EncJSON
instance Hasura.RQL.Types.Backend.Backend b => Data.Aeson.Types.FromJSON.FromJSON (Hasura.RQL.DDL.Relationship.Rename.RenameRel b)


-- | Postgres DDL RunSQL
--   
--   Escape hatch for running raw SQL against a postgres database.
--   
--   <a>runRunSQL</a> executes the provided raw SQL.
--   
--   <a>isSchemaCacheBuildRequiredRunSQL</a> checks for known
--   schema-mutating keywords in the raw SQL text.
--   
--   See <a>V2Query</a> and <a>Query</a>.
module Hasura.Backends.Postgres.DDL.RunSQL
data RunSQL
RunSQL :: Text -> SourceName -> Bool -> Maybe Bool -> TxAccess -> RunSQL
[rSql] :: RunSQL -> Text
[rSource] :: RunSQL -> SourceName
[rCascade] :: RunSQL -> Bool
[rCheckMetadataConsistency] :: RunSQL -> Maybe Bool
[rTxAccessMode] :: RunSQL -> TxAccess

-- | Check for known schema-mutating keywords in the raw SQL text.
--   
--   See Note [Checking metadata consistency in run_sql].
isSchemaCacheBuildRequiredRunSQL :: RunSQL -> Bool
isReadOnly :: RunSQL -> Bool

-- | Used as an escape hatch to run raw SQL against a database.
runRunSQL :: forall (pgKind :: PostgresKind) m. (BackendMetadata ('Postgres pgKind), ToMetadataFetchQuery pgKind, FetchTableMetadata pgKind, FetchFunctionMetadata pgKind, CacheRWM m, MetadataM m, MonadBaseControl IO m, MonadError QErr m, MonadIO m, MonadTrace m, UserInfoM m) => SQLGenCtx -> RunSQL -> m EncJSON
instance GHC.Classes.Eq Hasura.Backends.Postgres.DDL.RunSQL.RunSQL
instance GHC.Show.Show Hasura.Backends.Postgres.DDL.RunSQL.RunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.Postgres.DDL.RunSQL.RunSQL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.Postgres.DDL.RunSQL.RunSQL


-- | MSSQL DDL RunSQL
--   
--   Provides primitives for running raw text SQL on MSSQL backends.
module Hasura.Backends.MSSQL.DDL.RunSQL
data MSSQLRunSQL
MSSQLRunSQL :: Text -> SourceName -> Bool -> Maybe Bool -> MSSQLRunSQL
[_mrsSql] :: MSSQLRunSQL -> Text
[_mrsSource] :: MSSQLRunSQL -> SourceName
[_mrsCascade] :: MSSQLRunSQL -> Bool
[_mrsCheckMetadataConsistency] :: MSSQLRunSQL -> Maybe Bool
runSQL :: forall m. (MonadIO m, MonadBaseControl IO m, CacheRWM m, MonadError QErr m, MetadataM m) => MSSQLRunSQL -> m EncJSON
isSchemaCacheBuildRequiredRunSQL :: MSSQLRunSQL -> Bool
instance GHC.Classes.Eq Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL
instance GHC.Show.Show Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.MSSQL.DDL.RunSQL.MSSQLRunSQL

module Hasura.Backends.DataConnector.Adapter.RunSQL
data DataConnectorRunSQL
DataConnectorRunSQL :: SourceName -> Text -> DataConnectorRunSQL
[_dcSource] :: DataConnectorRunSQL -> SourceName
[_dcSql] :: DataConnectorRunSQL -> Text
runSQL :: forall m. (MonadIO m, CacheRWM m, MonadError QErr m, MetadataM m) => DataConnectorName -> DataConnectorRunSQL -> m EncJSON
instance GHC.Classes.Eq Hasura.Backends.DataConnector.Adapter.RunSQL.DataConnectorRunSQL
instance GHC.Show.Show Hasura.Backends.DataConnector.Adapter.RunSQL.DataConnectorRunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.DataConnector.Adapter.RunSQL.DataConnectorRunSQL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.DataConnector.Adapter.RunSQL.DataConnectorRunSQL


-- | Working example:
--   
--   $ curl -XPOST <a>http://localhost:8080/v2/query</a> -d @- &lt;&lt;EOF
--   { "type":"bigquery_run_sql", "args": { "sql":"select 3 * 4 as foo,
--   "Hello, World!" as bar", "source":"chinook" } } EOF
--   {"result_type":<a>TuplesOk</a>,"result":[["foo","bar"],["12","Hello,
--   World!"]]}
module Hasura.Backends.BigQuery.DDL.RunSQL
data BigQueryRunSQL
runSQL :: (MonadIO m, CacheRWM m, MonadError QErr m, MetadataM m) => BigQueryRunSQL -> m EncJSON

-- | The SQL query in the request is ignored
runDatabaseInspection :: (MonadIO m, CacheRWM m, MonadError QErr m, MetadataM m) => BigQueryRunSQL -> m EncJSON
instance GHC.Show.Show Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL
instance GHC.Generics.Generic Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL
instance GHC.Classes.Eq Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Backends.BigQuery.DDL.RunSQL.BigQueryRunSQL

module Hasura.RQL.DDL.Metadata
runClearMetadata :: forall m r. (MonadIO m, CacheRWM m, MetadataM m, MonadMetadataStorage m, MonadBaseControl IO m, MonadReader r m, MonadError QErr m, Has (Logger Hasura) r, MonadEventLogCleanup m, MonadGetPolicies m) => ClearMetadata -> m EncJSON

-- | Replace the 'current metadata' with the 'new metadata' The 'new
--   metadata' might come via the 'Import Metadata' in console
runReplaceMetadata :: (CacheRWM m, MetadataM m, MonadIO m, MonadBaseControl IO m, MonadMetadataStorage m, MonadReader r m, MonadError QErr m, Has (Logger Hasura) r, MonadEventLogCleanup m, MonadGetPolicies m) => ReplaceMetadata -> m EncJSON
runReplaceMetadataV2 :: forall m r. (CacheRWM m, MetadataM m, MonadIO m, MonadBaseControl IO m, MonadMetadataStorage m, MonadReader r m, MonadError QErr m, Has (Logger Hasura) r, MonadEventLogCleanup m, MonadGetPolicies m) => ReplaceMetadataV2 -> m EncJSON
runExportMetadata :: forall m. (QErrM m, MetadataM m) => ExportMetadata -> m EncJSON
runExportMetadataV2 :: forall m. (QErrM m, MetadataM m) => MetadataResourceVersion -> ExportMetadata -> m EncJSON
runReloadMetadata :: (QErrM m, CacheRWM m, MetadataM m) => ReloadMetadata -> m EncJSON
runDumpInternalState :: (QErrM m, CacheRM m) => DumpInternalState -> m EncJSON
runGetInconsistentMetadata :: (QErrM m, CacheRM m) => GetInconsistentMetadata -> m EncJSON
runDropInconsistentMetadata :: (QErrM m, CacheRWM m, MetadataM m) => DropInconsistentMetadata -> m EncJSON
runGetCatalogState :: (MonadMetadataStorage m, MonadError QErr m) => GetCatalogState -> m EncJSON
runSetCatalogState :: (MonadMetadataStorage m, MonadError QErr m) => SetCatalogState -> m EncJSON
runSetMetricsConfig :: (MonadIO m, CacheRWM m, MetadataM m, MonadError QErr m) => MetricsConfig -> m EncJSON
runRemoveMetricsConfig :: (MonadIO m, CacheRWM m, MetadataM m, MonadError QErr m) => m EncJSON
runTestWebhookTransform :: QErrM m => TestWebhookTransform -> m EncJSON


-- | The RQL metadata query ('<i>v1</i>metadata')
module Hasura.Server.API.Metadata.Types
data RQLMetadataV1
RMAddSource :: !AnyBackend AddSource -> RQLMetadataV1
RMDropSource :: DropSource -> RQLMetadataV1
RMRenameSource :: !RenameSource -> RQLMetadataV1
RMUpdateSource :: !AnyBackend UpdateSource -> RQLMetadataV1
RMListSourceKinds :: !ListSourceKinds -> RQLMetadataV1
RMGetSourceKindCapabilities :: !GetSourceKindCapabilities -> RQLMetadataV1
RMGetSourceTables :: !AnyBackend GetSourceTables -> RQLMetadataV1
RMGetSourceTrackables :: !AnyBackend GetSourceTrackables -> RQLMetadataV1
RMGetTableInfo :: !AnyBackend GetTableInfo -> RQLMetadataV1
RMGetTableInfo_ :: !GetTableInfo_ -> RQLMetadataV1
RMTrackTable :: !AnyBackend TrackTableV2 -> RQLMetadataV1
RMTrackTables :: !AnyBackend TrackTables -> RQLMetadataV1
RMUntrackTable :: !AnyBackend UntrackTable -> RQLMetadataV1
RMUntrackTables :: !AnyBackend UntrackTables -> RQLMetadataV1
RMSetTableCustomization :: !AnyBackend SetTableCustomization -> RQLMetadataV1
RMSetApolloFederationConfig :: AnyBackend SetApolloFederationConfig -> RQLMetadataV1
RMPgSetTableIsEnum :: !AnyBackend SetTableIsEnum -> RQLMetadataV1
RMCreateInsertPermission :: !AnyBackend (CreatePerm InsPerm) -> RQLMetadataV1
RMCreateSelectPermission :: !AnyBackend (CreatePerm SelPerm) -> RQLMetadataV1
RMCreateUpdatePermission :: !AnyBackend (CreatePerm UpdPerm) -> RQLMetadataV1
RMCreateDeletePermission :: !AnyBackend (CreatePerm DelPerm) -> RQLMetadataV1
RMDropInsertPermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropSelectPermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropUpdatePermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMDropDeletePermission :: !AnyBackend DropPerm -> RQLMetadataV1
RMSetPermissionComment :: !AnyBackend SetPermComment -> RQLMetadataV1
RMCreateObjectRelationship :: !AnyBackend CreateObjRel -> RQLMetadataV1
RMCreateArrayRelationship :: !AnyBackend CreateArrRel -> RQLMetadataV1
RMDropRelationship :: !AnyBackend DropRel -> RQLMetadataV1
RMSetRelationshipComment :: !AnyBackend SetRelComment -> RQLMetadataV1
RMRenameRelationship :: !AnyBackend RenameRel -> RQLMetadataV1
RMSuggestRelationships :: !AnyBackend SuggestRels -> RQLMetadataV1
RMCreateRemoteRelationship :: !AnyBackend CreateFromSourceRelationship -> RQLMetadataV1
RMUpdateRemoteRelationship :: !AnyBackend CreateFromSourceRelationship -> RQLMetadataV1
RMDeleteRemoteRelationship :: !AnyBackend DeleteFromSourceRelationship -> RQLMetadataV1
RMTrackFunction :: !AnyBackend TrackFunctionV2 -> RQLMetadataV1
RMUntrackFunction :: !AnyBackend UnTrackFunction -> RQLMetadataV1
RMSetFunctionCustomization :: AnyBackend SetFunctionCustomization -> RQLMetadataV1
RMCreateFunctionPermission :: !AnyBackend FunctionPermissionArgument -> RQLMetadataV1
RMDropFunctionPermission :: !AnyBackend FunctionPermissionArgument -> RQLMetadataV1
RMAddComputedField :: !AnyBackend AddComputedField -> RQLMetadataV1
RMDropComputedField :: !AnyBackend DropComputedField -> RQLMetadataV1
RMTestConnectionTemplate :: !AnyBackend TestConnectionTemplate -> RQLMetadataV1
RMGetNativeQuery :: !AnyBackend GetNativeQuery -> RQLMetadataV1
RMTrackNativeQuery :: !AnyBackend TrackNativeQuery -> RQLMetadataV1
RMUntrackNativeQuery :: !AnyBackend UntrackNativeQuery -> RQLMetadataV1
RMGetStoredProcedure :: !AnyBackend GetStoredProcedure -> RQLMetadataV1
RMTrackStoredProcedure :: !AnyBackend TrackStoredProcedure -> RQLMetadataV1
RMUntrackStoredProcedure :: !AnyBackend UntrackStoredProcedure -> RQLMetadataV1
RMGetLogicalModel :: !AnyBackend GetLogicalModel -> RQLMetadataV1
RMTrackLogicalModel :: !AnyBackend TrackLogicalModel -> RQLMetadataV1
RMUntrackLogicalModel :: !AnyBackend UntrackLogicalModel -> RQLMetadataV1
RMCreateSelectLogicalModelPermission :: !AnyBackend (CreateLogicalModelPermission SelPerm) -> RQLMetadataV1
RMDropSelectLogicalModelPermission :: !AnyBackend DropLogicalModelPermission -> RQLMetadataV1
RMCreateEventTrigger :: !AnyBackend (Unvalidated1 CreateEventTriggerQuery) -> RQLMetadataV1
RMDeleteEventTrigger :: !AnyBackend DeleteEventTriggerQuery -> RQLMetadataV1
RMRedeliverEvent :: !AnyBackend RedeliverEventQuery -> RQLMetadataV1
RMInvokeEventTrigger :: !AnyBackend InvokeEventTriggerQuery -> RQLMetadataV1
RMCleanupEventTriggerLog :: !TriggerLogCleanupConfig -> RQLMetadataV1
RMResumeEventTriggerCleanup :: !TriggerLogCleanupToggleConfig -> RQLMetadataV1
RMPauseEventTriggerCleanup :: !TriggerLogCleanupToggleConfig -> RQLMetadataV1
RMGetEventLogs :: !AnyBackend GetEventLogs -> RQLMetadataV1
RMGetEventInvocationLogs :: !AnyBackend GetEventInvocations -> RQLMetadataV1
RMGetEventById :: !AnyBackend GetEventById -> RQLMetadataV1
RMAddRemoteSchema :: !AddRemoteSchemaQuery -> RQLMetadataV1
RMUpdateRemoteSchema :: !AddRemoteSchemaQuery -> RQLMetadataV1
RMRemoveRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMReloadRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMIntrospectRemoteSchema :: !RemoteSchemaNameQuery -> RQLMetadataV1
RMAddRemoteSchemaPermissions :: !AddRemoteSchemaPermission -> RQLMetadataV1
RMDropRemoteSchemaPermissions :: !DropRemoteSchemaPermissions -> RQLMetadataV1
RMCreateRemoteSchemaRemoteRelationship :: CreateRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMUpdateRemoteSchemaRemoteRelationship :: CreateRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMDeleteRemoteSchemaRemoteRelationship :: DeleteRemoteSchemaRemoteRelationship -> RQLMetadataV1
RMCreateCronTrigger :: !Unvalidated CreateCronTrigger -> RQLMetadataV1
RMDeleteCronTrigger :: !ScheduledTriggerName -> RQLMetadataV1
RMCreateScheduledEvent :: !CreateScheduledEvent -> RQLMetadataV1
RMDeleteScheduledEvent :: !DeleteScheduledEvent -> RQLMetadataV1
RMGetScheduledEvents :: !GetScheduledEvents -> RQLMetadataV1
RMGetScheduledEventInvocations :: !GetScheduledEventInvocations -> RQLMetadataV1
RMGetCronTriggers :: RQLMetadataV1
RMCreateAction :: !Unvalidated CreateAction -> RQLMetadataV1
RMDropAction :: !DropAction -> RQLMetadataV1
RMUpdateAction :: !Unvalidated UpdateAction -> RQLMetadataV1
RMCreateActionPermission :: !CreateActionPermission -> RQLMetadataV1
RMDropActionPermission :: !DropActionPermission -> RQLMetadataV1
RMCreateQueryCollection :: !CreateCollection -> RQLMetadataV1
RMRenameQueryCollection :: !RenameCollection -> RQLMetadataV1
RMDropQueryCollection :: !DropCollection -> RQLMetadataV1
RMAddQueryToCollection :: !AddQueryToCollection -> RQLMetadataV1
RMDropQueryFromCollection :: !DropQueryFromCollection -> RQLMetadataV1
RMAddCollectionToAllowlist :: !AllowlistEntry -> RQLMetadataV1
RMDropCollectionFromAllowlist :: !DropCollectionFromAllowlist -> RQLMetadataV1
RMUpdateScopeOfCollectionInAllowlist :: !UpdateScopeOfCollectionInAllowlist -> RQLMetadataV1
RMCreateRestEndpoint :: !CreateEndpoint -> RQLMetadataV1
RMDropRestEndpoint :: !DropEndpoint -> RQLMetadataV1
RMDCAddAgent :: !DCAddAgent -> RQLMetadataV1
RMDCDeleteAgent :: !DCDeleteAgent -> RQLMetadataV1
RMSetCustomTypes :: !CustomTypes -> RQLMetadataV1
RMSetApiLimits :: !ApiLimit -> RQLMetadataV1
RMRemoveApiLimits :: RQLMetadataV1
RMSetMetricsConfig :: !MetricsConfig -> RQLMetadataV1
RMRemoveMetricsConfig :: RQLMetadataV1
RMAddInheritedRole :: !InheritedRole -> RQLMetadataV1
RMDropInheritedRole :: !DropInheritedRole -> RQLMetadataV1
RMReplaceMetadata :: !ReplaceMetadata -> RQLMetadataV1
RMExportMetadata :: !ExportMetadata -> RQLMetadataV1
RMClearMetadata :: !ClearMetadata -> RQLMetadataV1
RMReloadMetadata :: !ReloadMetadata -> RQLMetadataV1
RMGetInconsistentMetadata :: !GetInconsistentMetadata -> RQLMetadataV1
RMDropInconsistentMetadata :: !DropInconsistentMetadata -> RQLMetadataV1
RMSetGraphqlSchemaIntrospectionOptions :: !SetGraphqlIntrospectionOptions -> RQLMetadataV1
RMAddHostToTLSAllowlist :: !AddHostToTLSAllowlist -> RQLMetadataV1
RMDropHostFromTLSAllowlist :: !DropHostFromTLSAllowlist -> RQLMetadataV1
RMSetQueryTagsConfig :: !SetQueryTagsConfig -> RQLMetadataV1
RMSetOpenTelemetryConfig :: !OpenTelemetryConfig -> RQLMetadataV1
RMSetOpenTelemetryStatus :: !OtelStatus -> RQLMetadataV1
RMDumpInternalState :: !DumpInternalState -> RQLMetadataV1
RMGetCatalogState :: !GetCatalogState -> RQLMetadataV1
RMSetCatalogState :: !SetCatalogState -> RQLMetadataV1
RMTestWebhookTransform :: !Unvalidated TestWebhookTransform -> RQLMetadataV1
RMBulk :: [RQLMetadataRequest] -> RQLMetadataV1
RMBulkKeepGoing :: [RQLMetadataRequest] -> RQLMetadataV1

-- | Bulk metadata queries, running a single schema cache resolve at the
--   end. Only works for a subset of commands.
RMBulkAtomic :: [RQLMetadataRequest] -> RQLMetadataV1
data RQLMetadataV2
RMV2ReplaceMetadata :: !ReplaceMetadataV2 -> RQLMetadataV2
RMV2ExportMetadata :: !ExportMetadata -> RQLMetadataV2
data RQLMetadataRequest
RMV1 :: !RQLMetadataV1 -> RQLMetadataRequest
RMV2 :: !RQLMetadataV2 -> RQLMetadataRequest
instance GHC.Generics.Generic Hasura.Server.API.Metadata.Types.RQLMetadataV2
instance GHC.Generics.Generic Hasura.Server.API.Metadata.Types.RQLMetadataV1


-- | BackendAPI
--   
--   This module defines the <a>BackendAPI</a> class, alongside a few
--   helpers. Its goal is to delegate to backends the responsibility of
--   creating the parsers for the metadata API. Each backend is expected to
--   provide a list of <a>CommandParser</a>, which in turn is a simple
--   function from command name and command arguments to a corresponding
--   parser. Command parsers can easily be created using the
--   <a>commandParser</a> function.
--   
--   Furthermore, for each set of related features, such as table tracking
--   commands, or permission commands, a helper function is provided, that
--   allows a backend to write its instance by simply listing the set of
--   features it supports.
module Hasura.Server.API.Backend
class BackendAPI (b :: BackendType)
metadataV1CommandParsers :: BackendAPI b => [CommandParser b]
commandParser :: FromJSON a => Text -> (a -> RQLMetadataV1) -> CommandParser b
sourceCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
tableCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
tablePermissionsCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
functionCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
trackableCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
functionPermissionsCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
relationshipCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
remoteRelationshipCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
eventTriggerCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
computedFieldCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
connectionTemplateCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
nativeQueriesCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
storedProceduresCommands :: forall (b :: BackendType). Backend b => [CommandParser b]
logicalModelsCommands :: forall (b :: BackendType). Backend b => [CommandParser b]


-- | MSSQL Instances API
--   
--   Defines a <a>BackendAPI</a> type class instance for MSSQL.
module Hasura.Backends.MSSQL.Instances.API
instance Hasura.Server.API.Backend.BackendAPI 'Hasura.RQL.Types.BackendType.MSSQL

module Hasura.Backends.DataConnector.Adapter.API
instance Hasura.Server.API.Backend.BackendAPI 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.Backends.BigQuery.Instances.API
instance Hasura.Server.API.Backend.BackendAPI 'Hasura.RQL.Types.BackendType.BigQuery


-- | Postgres Instances API
--   
--   Defines a <a>BackendAPI</a> type class instance for Postgres.
module Hasura.Backends.Postgres.Instances.API
instance Hasura.Server.API.Backend.BackendAPI ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Vanilla)
instance Hasura.Server.API.Backend.BackendAPI ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Citus)
instance Hasura.Server.API.Backend.BackendAPI ('Hasura.RQL.Types.BackendType.Postgres 'Hasura.RQL.Types.BackendType.Cockroach)

module Hasura.Server.API.Instances


-- | <a>FromJSON</a> instances for API.Metadata. Kept separately to
--   discourage becoming a dumping ground for orphan instances
module Hasura.Server.API.Metadata.Instances
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.Types.RQLMetadataV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.Types.RQLMetadataV2
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.Types.RQLMetadataRequest


-- | MSSQL SQL Value
--   
--   Provide a function to translate from a column value to its literal
--   (textual) value specific to MSSQL. Used in the <tt>BackendExecute</tt>
--   instance.
module Hasura.Backends.MSSQL.SQL.Value
txtEncodedColVal :: ColumnValue 'MSSQL -> TxtEncodedVal


-- | MSSQL Instances Execute
--   
--   Defines a <a>BackendExecute</a> type class instance for MSSQL.
--   
--   This module implements the needed functionality for implementing a
--   <a>BackendExecute</a> instance for MSSQL, which defines an interface
--   for translating a root field into an execution plan and interacting
--   with a database.
--   
--   This module includes the MSSQL implementation of queries, mutations,
--   and more.
module Hasura.Backends.MSSQL.Instances.Execute
data MultiplexedQuery'
MultiplexedQuery' :: Reselect -> QueryTagsComment -> MultiplexedQuery'
[reselect] :: MultiplexedQuery' -> Reselect
[subscriptionQueryTagsComment] :: MultiplexedQuery' -> QueryTagsComment

-- | Producing the correct SQL-level list comprehension to multiplex a
--   query Problem description:
--   
--   Generate a query that repeats the same query N times but with certain
--   slots replaced:
--   
--   <ul>
--   <li><i> Select x y | (x,y) &lt;- [..</i> ]</li>
--   </ul>
--   
--   Caution: Be aware that this query has a <tt>FOR JSON</tt> clause at
--   the top-level and hence its results may be split up across multiple
--   rows. Use <a>forJsonQueryE</a> to handle this.
multiplexRootReselect :: [(CohortId, CohortVariables)] -> Reselect -> Select
instance Hasura.GraphQL.Execute.Backend.BackendExecute 'Hasura.RQL.Types.BackendType.MSSQL
instance Data.Text.Extended.ToTxt Hasura.Backends.MSSQL.Instances.Execute.MultiplexedQuery'


-- | MSSQL Instances Transport
--   
--   Defines the MSSQL instance of <a>BackendTransport</a> and how to
--   interact with the database for running queries, mutations,
--   subscriptions, and so on.
module Hasura.Backends.MSSQL.Instances.Transport
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Backends.MSSQL.Instances.Transport.CohortResult
instance Hasura.GraphQL.Transport.Backend.BackendTransport 'Hasura.RQL.Types.BackendType.MSSQL

module Hasura.Backends.DataConnector.Adapter.Execute
data DataConnectorPreparedQuery
QueryRequest :: QueryRequest -> DataConnectorPreparedQuery
MutationRequest :: MutationRequest -> DataConnectorPreparedQuery
encodePreparedQueryToJsonText :: DataConnectorPreparedQuery -> Text
instance Hasura.GraphQL.Execute.Backend.BackendExecute 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.GraphQL.Execute.Instances

module Hasura.Backends.DataConnector.Adapter.Transport
instance Hasura.GraphQL.Transport.Backend.BackendTransport 'Hasura.RQL.Types.BackendType.DataConnector

module Hasura.Backends.BigQuery.Instances.Transport
instance Hasura.GraphQL.Transport.Backend.BackendTransport 'Hasura.RQL.Types.BackendType.BigQuery

module Hasura.GraphQL.Transport.Instances


-- | How to construct and execute a call to a source for a remote join.
--   
--   There are three steps required to do this: - construct the execution
--   step for that source join - execute that GraphQL query over the
--   network - build a join index of the variables out of the response
--   
--   This can be done as one function, but we also export the individual
--   steps for debugging / test purposes. We congregate all intermediary
--   state in the opaque <a>SourceJoinCall</a> type.
module Hasura.GraphQL.Execute.RemoteJoin.Source

-- | Construct and execute a call to a source for a remote join.
makeSourceJoinCall :: (MonadQueryTags m, MonadError QErr m, MonadTrace m, MonadIO m) => (AnyBackend SourceJoinCall -> m ByteString) -> UserInfo -> AnyBackend RemoteSourceJoin -> FieldName -> IntMap JoinArgument -> [Header] -> Maybe Name -> m (Maybe (IntMap Value))

-- | Intermediate type that contains all the necessary information to
--   perform a call to a database to perform a join.
data SourceJoinCall b
SourceJoinCall :: RootFieldAlias -> SourceConfig b -> DBStepInfo b -> SourceJoinCall b
[_sjcRootFieldAlias] :: SourceJoinCall b -> RootFieldAlias
[_sjcSourceConfig] :: SourceJoinCall b -> SourceConfig b
[_sjcStepInfo] :: SourceJoinCall b -> DBStepInfo b
buildSourceJoinCall :: forall b m. (BackendExecute b, MonadQueryTags m, MonadError QErr m, MonadTrace m, MonadIO m) => UserInfo -> FieldName -> IntMap JoinArgument -> [Header] -> Maybe Name -> RemoteSourceJoin b -> m (Maybe (AnyBackend SourceJoinCall))

-- | Construct a join index from the <tt>EncJSON</tt> response from the
--   source.
--   
--   Unlike with remote schemas, we can make assumptions about the shape of
--   the result, instead of having to keep track of the path within the
--   answer. This function therefore enforces that the answer has the shape
--   we expect, and throws a <a>QErr</a> if it doesn't.
buildJoinIndex :: MonadError QErr m => ByteString -> m (IntMap Value)

module Hasura.GraphQL.Execute.RemoteJoin.Join

-- | Process all remote joins, recursively.
--   
--   Given the result of the first step of an execution and its associated
--   remote joins, process all joins recursively to build the resulting
--   JSON object.
--   
--   This function is a thin wrapper around
--   <tt>processRemoteJoinsWith</tt>, and starts the join tree traversal
--   process by re-parsing the <a>EncJSON</a> value into an introspectable
--   JSON <tt>Value</tt>, and "injects" the required functions to process
--   each join over the network.
processRemoteJoins :: forall m. (MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadQueryTags m, MonadQueryLog m, MonadExecutionLog m, MonadTrace m, ProvidesNetwork m) => RequestId -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> Environment -> [Header] -> UserInfo -> EncJSON -> Maybe RemoteJoins -> GQLReqUnparsed -> m EncJSON

-- | Fold the join tree.
--   
--   This function takes as an argument the functions that will be used to
--   do the actual network calls; this allows this function not to require
--   <a>MonadIO</a>, allowing it to be used in tests.
foldJoinTreeWith :: (MonadError QErr m, MonadQueryTags m, Traversable f, MonadTrace m, MonadIO m) => (AnyBackend SourceJoinCall -> m ByteString) -> (ValidatedRemoteSchemaDef -> GQLReqOutgoing -> m ByteString) -> UserInfo -> f Value -> RemoteJoins -> [Header] -> Maybe Name -> m (f Value)
instance Data.Traversable.Traversable Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue
instance Data.Foldable.Foldable Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue
instance GHC.Base.Functor Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue
instance GHC.Classes.Eq a => GHC.Classes.Eq (Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue a)
instance GHC.Show.Show a => GHC.Show.Show (Hasura.GraphQL.Execute.RemoteJoin.Join.CompositeValue a)

module Hasura.GraphQL.Execute.RemoteJoin

module Hasura.App.State
data RebuildableAppContext impl
RebuildableAppContext :: AppContext -> InvalidationKeys -> Rule (ReaderT (Logger Hasura, Manager) (ExceptT QErr IO)) (ServeOptions impl, Environment, InvalidationKeys) AppContext -> RebuildableAppContext impl
[lastBuiltAppContext] :: RebuildableAppContext impl -> AppContext
[_racInvalidationMap] :: RebuildableAppContext impl -> InvalidationKeys
[_racRebuild] :: RebuildableAppContext impl -> Rule (ReaderT (Logger Hasura, Manager) (ExceptT QErr IO)) (ServeOptions impl, Environment, InvalidationKeys) AppContext

-- | Represents the Read-Only Hasura State, these fields are immutable and
--   the state cannot be changed during runtime.
data AppEnv
AppEnv :: Port -> HostPreference -> PGPool -> Maybe PGPool -> Manager -> Loggers -> TMVar MetadataResourceVersion -> InstanceId -> MaintenanceMode () -> LoggingSettings -> EventingMode -> ReadOnlyMode -> ServerMetrics -> ShutdownLatch -> TMVar MetadataResourceVersion -> PrometheusMetrics -> SamplingPolicy -> SubscriptionsState -> LockedEventsCtx -> ConnParams -> TxIsolation -> Maybe Text -> Maybe Text -> ConnectionOptions -> KeepAliveDelay -> WSConnectionInitTimeout -> Refined NonNegative Seconds -> OptionalInterval -> CheckFeatureFlag -> Maybe (CredentialCache AgentLicenseKey) -> Int -> TriggersErrorLogLevelStatus -> AppEnv
[appEnvPort] :: AppEnv -> Port
[appEnvHost] :: AppEnv -> HostPreference
[appEnvMetadataDbPool] :: AppEnv -> PGPool
[appEnvIntrospectionDbPool] :: AppEnv -> Maybe PGPool
[appEnvManager] :: AppEnv -> Manager
[appEnvLoggers] :: AppEnv -> Loggers
[appEnvMetadataVersionRef] :: AppEnv -> TMVar MetadataResourceVersion
[appEnvInstanceId] :: AppEnv -> InstanceId
[appEnvEnableMaintenanceMode] :: AppEnv -> MaintenanceMode ()
[appEnvLoggingSettings] :: AppEnv -> LoggingSettings
[appEnvEventingMode] :: AppEnv -> EventingMode
[appEnvEnableReadOnlyMode] :: AppEnv -> ReadOnlyMode
[appEnvServerMetrics] :: AppEnv -> ServerMetrics
[appEnvShutdownLatch] :: AppEnv -> ShutdownLatch
[appEnvMetaVersionRef] :: AppEnv -> TMVar MetadataResourceVersion
[appEnvPrometheusMetrics] :: AppEnv -> PrometheusMetrics
[appEnvTraceSamplingPolicy] :: AppEnv -> SamplingPolicy
[appEnvSubscriptionState] :: AppEnv -> SubscriptionsState
[appEnvLockedEventsCtx] :: AppEnv -> LockedEventsCtx
[appEnvConnParams] :: AppEnv -> ConnParams
[appEnvTxIso] :: AppEnv -> TxIsolation
[appEnvConsoleAssetsDir] :: AppEnv -> Maybe Text
[appEnvConsoleSentryDsn] :: AppEnv -> Maybe Text
[appEnvConnectionOptions] :: AppEnv -> ConnectionOptions
[appEnvWebSocketKeepAlive] :: AppEnv -> KeepAliveDelay
[appEnvWebSocketConnectionInitTimeout] :: AppEnv -> WSConnectionInitTimeout
[appEnvGracefulShutdownTimeout] :: AppEnv -> Refined NonNegative Seconds
[appEnvSchemaPollInterval] :: AppEnv -> OptionalInterval
[appEnvCheckFeatureFlag] :: AppEnv -> CheckFeatureFlag
[appEnvLicenseKeyCache] :: AppEnv -> Maybe (CredentialCache AgentLicenseKey)
[appEnvMaxTotalHeaderLength] :: AppEnv -> Int
[appEnvTriggersErrorLogLevelStatus] :: AppEnv -> TriggersErrorLogLevelStatus

-- | Represents the Dynamic Hasura State, these field are mutable and can
--   be changed during runtime.
data AppContext
AppContext :: AuthMode -> SQLGenCtx -> HashSet API -> AllowListStatus -> ResponseInternalErrorsConfig -> Environment -> RemoteSchemaPermissions -> InferFunctionPermissions -> HashSet ExperimentalFeature -> NamingCase -> MetadataDefaults -> LiveQueriesOptions -> StreamQueriesOptions -> CorsPolicy -> ConsoleStatus -> TelemetryStatus -> EventEngineCtx -> OptionalInterval -> ApolloFederationStatus -> CloseWebsocketsOnMetadataChangeStatus -> AppContext
[acAuthMode] :: AppContext -> AuthMode
[acSQLGenCtx] :: AppContext -> SQLGenCtx
[acEnabledAPIs] :: AppContext -> HashSet API
[acEnableAllowlist] :: AppContext -> AllowListStatus
[acResponseInternalErrorsConfig] :: AppContext -> ResponseInternalErrorsConfig
[acEnvironment] :: AppContext -> Environment
[acRemoteSchemaPermsCtx] :: AppContext -> RemoteSchemaPermissions
[acFunctionPermsCtx] :: AppContext -> InferFunctionPermissions
[acExperimentalFeatures] :: AppContext -> HashSet ExperimentalFeature
[acDefaultNamingConvention] :: AppContext -> NamingCase
[acMetadataDefaults] :: AppContext -> MetadataDefaults
[acLiveQueryOptions] :: AppContext -> LiveQueriesOptions
[acStreamQueryOptions] :: AppContext -> StreamQueriesOptions
[acCorsPolicy] :: AppContext -> CorsPolicy
[acConsoleStatus] :: AppContext -> ConsoleStatus
[acEnableTelemetry] :: AppContext -> TelemetryStatus
[acEventEngineCtx] :: AppContext -> EventEngineCtx
[acAsyncActionsFetchInterval] :: AppContext -> OptionalInterval
[acApolloFederationStatus] :: AppContext -> ApolloFederationStatus
[acCloseWebsocketsOnMetadataChangeStatus] :: AppContext -> CloseWebsocketsOnMetadataChangeStatus

-- | Collection of the LoggerCtx, the regular Logger and the PGLogger
data Loggers
Loggers :: LoggerCtx Hasura -> Logger Hasura -> PGLogger -> Loggers
[_lsLoggerCtx] :: Loggers -> LoggerCtx Hasura
[_lsLogger] :: Loggers -> Logger Hasura
[_lsPgLogger] :: Loggers -> PGLogger

-- | Provides access to the <a>AppEnv</a>.
--   
--   This class is nothing more than an equivalent of <tt>MonadReader
--   AppEnv m</tt>, but it abstracts it, so that application code can be
--   written without explicitly relying on an explicit implementation of
--   the app monad. It allows for the app env to be passed implicitly
--   instead of explictly in all of the app init code.
--   
--   This class is not meant to be used across the entirety of the
--   codebase, as using it brings in scope the types of all fields,
--   creating dependencies between unrelated parts of the codebase. It is
--   only meant to be used at the top level; more specific parts of the
--   code should only rely on the relevant subset of the environment,
--   exposed by small, local typeclasses. For instance, at time of writing,
--   this can be used to implement <tt>HasServerConfigCtx</tt>, as a first
--   step towards breaking it down.
class (Monad m) => HasAppEnv m
askAppEnv :: HasAppEnv m => m AppEnv

-- | Function to build the <a>AppContext</a> (given the
--   <a>ServeOptions</a>) for the first time
buildRebuildableAppContext :: (Logger Hasura, Manager) -> ServeOptions impl -> Environment -> ExceptT QErr IO (RebuildableAppContext impl)

-- | Function to rebuild the <a>AppContext</a> from a given
--   <a>RebuildableAppContext</a> and a new <a>ServeOptions</a>
rebuildRebuildableAppContext :: (MonadIO m, MonadError QErr m) => (Logger Hasura, Manager) -> RebuildableAppContext impl -> ServeOptions impl -> Environment -> m (RebuildableAppContext impl)
initSQLGenCtx :: HashSet ExperimentalFeature -> StringifyNumbers -> DangerouslyCollapseBooleans -> RemoteNullForwardingPolicy -> SQLGenCtx
buildCacheStaticConfig :: AppEnv -> CacheStaticConfig
buildCacheDynamicConfig :: AppContext -> CacheDynamicConfig
instance Hasura.App.State.HasAppEnv m => Hasura.App.State.HasAppEnv (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.App.State.HasAppEnv m => Hasura.App.State.HasAppEnv (Control.Monad.Trans.Except.ExceptT e m)

module Hasura.Server.AppStateRef

-- | A mutable reference to a <a>AppState</a>, plus
--   
--   <ul>
--   <li>a write lock,</li>
--   <li>update version tracking, and</li>
--   <li>a gauge metric that tracks the metadata version of the
--   <a>SchemaCache</a>.</li>
--   </ul>
data AppStateRef impl

-- | Build a new <a>AppStateRef</a>.
--   
--   This function also updates the <a>TLSAllowListRef</a> to make it point
--   to the newly minted <tt>SchemaCacheRef</tt>.
initialiseAppStateRef :: MonadIO m => TLSAllowListRef -> Maybe MetricsConfigRef -> ServerMetrics -> RebuildableSchemaCache -> RebuildableAppContext impl -> m (AppStateRef impl)
withSchemaCacheUpdate :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => AppStateRef impl -> Logger Hasura -> Maybe (TVar Bool) -> m (a, RebuildableSchemaCache) -> m a

-- | Set the <a>AppStateRef</a> to the <a>RebuildableSchemaCache</a>
--   produced by the given action.
--   
--   An internal lock ensures that at most one update to the
--   <a>AppStateRef</a> may proceed at a time.
withSchemaCacheReadUpdate :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m) => AppStateRef impl -> Logger Hasura -> Maybe (TVar Bool) -> (RebuildableSchemaCache -> m (a, RebuildableSchemaCache)) -> m a

-- | Read the contents of the <a>AppStateRef</a> to get the latest
--   <a>RebuildableAppContext</a>
readAppContextRef :: AppStateRef impl -> IO (RebuildableAppContext impl)

-- | Read the contents of the <a>AppStateRef</a> to get the latest
--   <a>RebuildableSchemaCache</a> and <tt>SchemaCacheVer</tt>
getRebuildableSchemaCacheWithVersion :: AppStateRef impl -> IO RebuildableSchemaCache

-- | Reference to a TLS AllowList, used for dynamic TLS settings in the
--   app's HTTP Manager.
--   
--   This exists to break a chicken-and-egg problem in the initialisation
--   of the engine: the IO action that dynamically reads the TLS settings
--   reads it from the schema cache; but to build the schema cache we need
--   a HTTP manager that has access to the TLS settings... In the past, we
--   were using a temporary HTTP Manager to create the first schema cache,
--   to then create the *real* Manager that would refer to the list in the
--   schema cache. Now, instead, we only create one Manager, which uses a
--   <a>TLSAllowListRef</a> to dynamically access the Allow List.
data TLSAllowListRef

-- | Creates a new <a>TLSAllowListRef</a> that points to the given list.
createTLSAllowListRef :: [TlsAllow] -> IO TLSAllowListRef

-- | Reads the TLS AllowList by attempting to read from the schema cache,
--   and defaulting to the list given when the ref was created.
readTLSAllowList :: TLSAllowListRef -> IO [TlsAllow]

-- | Reference to the metadata's <a>MetricsConfig</a>.
--   
--   Similarly to the <a>TLSAllowListRef</a>, this exists to break a
--   chicken-and-egg problem in the initialisation of the engine: the
--   implementation of several behaviour classes requires access to said
--   config, but those classes are implemented on the app monad, that
--   doesn't have access to the schema cache. This small type allows the
--   app monad to have access to the config, even before we build the first
--   schema cache.
data MetricsConfigRef

-- | Creates a new <a>MetricsConfigRef</a> that points to the given config.
createMetricsConfigRef :: MetricsConfig -> IO MetricsConfigRef

-- | Reads the TLS AllowList by attempting to read from the schema cache,
--   and defaulting to the list given when the ref was created.
readMetricsConfig :: MetricsConfigRef -> IO MetricsConfig

-- | Read the latest <a>SchemaCache</a> from the <a>AppStateRef</a>.
getSchemaCache :: AppStateRef impl -> IO SchemaCache

-- | Read the latest <a>SchemaCache</a> and its version from the
--   <a>AppStateRef</a>.
getSchemaCacheWithVersion :: AppStateRef impl -> IO SchemaCache

-- | Read the latest <a>AppContext</a> from the <a>AppStateRef</a>.
getAppContext :: AppStateRef impl -> IO AppContext

-- | Formats and logs a list of inconsistent metadata objects.
logInconsistentMetadata :: Logger Hasura -> [InconsistentMetadata] -> IO ()

-- | Set the <a>RebuildableAppContext</a> to the <a>AppStateRef</a>
--   produced by the given action.
--   
--   An internal lock ensures that at most one update to the
--   <a>AppStateRef</a> may proceed at a time.
withAppContextUpdate :: (MonadIO m, MonadBaseControl IO m) => AppStateRef impl -> m (a, RebuildableAppContext impl) -> m a

-- | Set the <a>AppStateRef</a>, atomically, to the
--   (<a>RebuildableSchemaCache</a>, <a>RebuildableAppContext</a>) produced
--   by the given action.
--   
--   An internal lock ensures that at most one update to the
--   <a>AppStateRef</a> may proceed at a time.
updateAppStateRef :: (MonadIO m, MonadBaseControl IO m) => AppStateRef impl -> Logger Hasura -> (RebuildableAppContext impl -> m (RebuildableAppContext impl, RebuildableSchemaCache)) -> m ()


-- | Send anonymized metrics to the telemetry server regarding usage of
--   various features of Hasura.
--   
--   The general workflow for telemetry is as follows:
--   
--   <ol>
--   <li>We generate metrics for each backend in the graphql-engine code
--   and send it to <a>telemetryUrl</a>. The relevant types can be found in
--   <a>Hasura.Server.Telemetry.Types</a>.</li>
--   <li>The <a>telemetryUrl</a> endpoint is handled by code in:
--   <a>https://github.com/hasura/hasura-analytics/tree/hge-upgrade</a>,
--   specifically <a>manager/main.go</a> and <a>manager/analytics.go</a>.
--   This server endpoint receives the telemetry payload and sends it to
--   another graphql-engine which runs locally and is backed by a postgres
--   database. The database schema for the telemetry endpoint can also be
--   found in the same repo under <a>hge/migrations/</a>.</li>
--   <li>The information from the postgres db can be viewed in Metabase:
--   <a>https://metabase.telemetry.hasura.io/browse/2/schema/public</a>.</li>
--   </ol>
--   
--   For more information about telemetry in general, visit the user-facing
--   docs on the topic:
--   <a>https://hasura.io/docs/latest/graphql/core/guides/telemetry</a>.
module Hasura.Server.Telemetry
mkTelemetryLog :: Text -> Text -> Maybe TelemetryHttpError -> TelemetryLog

-- | An infinite loop that sends updated telemetry data (<a>Metrics</a>)
--   every 24 hours. The send time depends on when the server was started
--   and will naturally drift.
runTelemetry :: forall m impl. (MonadIO m, HasAppEnv m) => Logger Hasura -> AppStateRef impl -> MetadataDbId -> PGVersion -> ComputeResourcesResponse -> m Void
instance GHC.Show.Show Hasura.Server.Telemetry.TelemetryHttpError
instance GHC.Show.Show Hasura.Server.Telemetry.TelemetryLog
instance GHC.Generics.Generic Hasura.Server.Telemetry.ServerTelemetry
instance GHC.Generics.Generic Hasura.Server.Telemetry.ServerTelemetryRow
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.ServerTelemetryRow
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.ServerTelemetry
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.TelemetryLog
instance Hasura.Logging.ToEngineLog Hasura.Server.Telemetry.TelemetryLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.Telemetry.TelemetryHttpError

module Hasura.Server.SchemaUpdate

-- | An async thread which listen to Postgres notify to enable schema
--   syncing See Note [Schema Cache Sync]
startSchemaSyncListenerThread :: ForkableMonadIO m => Logger Hasura -> PGPool -> InstanceId -> Refined NonNegative Milliseconds -> TMVar MetadataResourceVersion -> ManagedT m Thread

-- | An async thread which processes the schema sync events See Note
--   [Schema Cache Sync]
startSchemaSyncProcessorThread :: (ForkableMonadIO m, HasAppEnv m, HasCacheStaticConfig m, MonadMetadataStorage m, MonadResolveSource m, ProvidesNetwork m) => AppStateRef impl -> TVar Bool -> ManagedT m Thread
instance GHC.Generics.Generic Hasura.Server.SchemaUpdate.ThreadError
instance GHC.Classes.Eq Hasura.Server.SchemaUpdate.ErrorState
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.Server.SchemaUpdate.ThreadError


-- | The RQL query ('<i>v2</i>query')
module Hasura.Server.API.V2Query
data RQLQuery
runQuery :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, HasAppEnv m, HasCacheStaticConfig m, MonadTrace m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m, ProvidesHasuraServices m, UserInfoM m) => AppContext -> RebuildableSchemaCache -> RQLQuery -> m (EncJSON, RebuildableSchemaCache)
queryModifiesSchema :: RQLQuery -> Bool
instance GHC.Generics.Generic Hasura.Server.API.V2Query.RQLQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.V2Query.RQLQuery


-- | The RQL query ('<i>v1</i>query')
module Hasura.Server.API.Query
data RQLQuery
runQuery :: (MonadIO m, MonadError QErr m, HasAppEnv m, HasCacheStaticConfig m, MonadTrace m, MonadBaseControl IO m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m, MonadEventLogCleanup m, ProvidesHasuraServices m, MonadGetPolicies m, UserInfoM m) => AppContext -> RebuildableSchemaCache -> RQLQuery -> m (EncJSON, RebuildableSchemaCache)

-- | A predicate that determines whether the given query might
--   modify/rebuild the schema cache. If so, it needs to acquire the global
--   lock on the schema cache so that other queries do not modify it
--   concurrently.
--   
--   Ideally, we would enforce this using the type system â€” queries for
--   which this function returns <a>False</a> should not be allowed to
--   modify the schema cache. But for now we just ensure consistency by
--   hand.
queryModifiesSchemaCache :: RQLQuery -> Bool
requiresAdmin :: RQLQuery -> Bool
instance GHC.Generics.Generic Hasura.Server.API.Query.RQLQueryV2
instance GHC.Generics.Generic Hasura.Server.API.Query.RQLQueryV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Query.RQLQuery
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Query.RQLQueryV1
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Query.RQLQueryV2

module Hasura.GraphQL.Execute.Action
fetchActionLogResponses :: (MonadError QErr m, MonadMetadataStorage m, Foldable t) => t ActionId -> m (ActionLogResponseMap, Bool)
runActionExecution :: (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadTrace m, MonadMetadataStorage m) => UserInfo -> ActionExecutionPlan -> m (DiffTime, (EncJSON, Maybe ResponseHeaders))

-- | Synchronously execute webhook handler and resolve response to action
--   "output"
resolveActionExecution :: Manager -> Environment -> Logger Hasura -> PrometheusMetrics -> AnnActionExecution Void -> ActionExecContext -> Maybe GQLQueryText -> ActionExecution

-- | Resolve asynchronous action mutation which returns only the action
--   uuid
resolveActionMutationAsync :: (MonadMetadataStorage m, MonadError QErr m) => AnnActionMutationAsync -> [Header] -> SessionVariables -> m ActionId

-- | See Note: [Resolving async action query]
resolveAsyncActionQuery :: UserInfo -> AnnActionAsyncQuery ('Postgres 'Vanilla) Void -> AsyncActionQueryExecution (UnpreparedValue ('Postgres 'Vanilla))

-- | Process async actions from hdb_catalog.hdb_action_log table. This
--   functions is executed in a background thread. See Note [Async action
--   architecture] above
asyncActionsProcessor :: forall m. (HasAppEnv m, MonadIO m, MonadBaseControl IO m, Forall (Pure m), MonadMetadataStorage m, MonadTrace m) => IO Environment -> Logger Hasura -> IO SchemaCache -> IO OptionalInterval -> TVar (Set LockedActionEventId) -> Maybe GQLQueryText -> m (Forever m)
insertActionTx :: ActionName -> SessionVariables -> [Header] -> Value -> TxE QErr ActionId
fetchUndeliveredActionEventsTx :: TxE QErr [ActionLogItem]
setActionStatusTx :: ActionId -> AsyncActionStatus -> TxE QErr ()
fetchActionResponseTx :: ActionId -> TxE QErr ActionLogResponse
clearActionDataTx :: ActionName -> TxE QErr ()
setProcessingActionLogsToPendingTx :: LockedActionIdArray -> TxE QErr ()

module Hasura.GraphQL.Execute.Query
parseGraphQLQuery :: MonadError QErr m => GQLContext -> [VariableDefinition] -> Maybe (HashMap Name Value) -> [Directive Name] -> SelectionSet NoFragments Name -> m (RootFieldMap (QueryRootField UnpreparedValue), [Directive Variable], SelectionSet NoFragments Variable)

-- | Construct an <a>ExecutionPlan</a> from a <a>SelectionSet</a>.
convertQuerySelSet :: forall m. (MonadError QErr m, MonadTrace m, MonadIO m, MonadGQLExecutionCheck m, MonadQueryTags m, ProvidesNetwork m) => Environment -> Logger Hasura -> PrometheusMetrics -> GQLContext -> UserInfo -> RequestHeaders -> [Directive Name] -> SelectionSet NoFragments Name -> [VariableDefinition] -> GQLReqUnparsed -> SetGraphqlIntrospectionOptions -> RequestId -> Maybe Name -> m (ExecutionPlan, [QueryRootField UnpreparedValue], DirectiveMap, ParameterizedQueryHash)

module Hasura.GraphQL.Execute.Mutation
convertMutationSelectionSet :: forall m. (MonadTrace m, MonadIO m, MonadError QErr m, MonadMetadataStorage m, MonadGQLExecutionCheck m, MonadQueryTags m, ProvidesNetwork m) => Environment -> Logger Hasura -> PrometheusMetrics -> GQLContext -> SQLGenCtx -> UserInfo -> RequestHeaders -> [Directive Name] -> SelectionSet NoFragments Name -> [VariableDefinition] -> GQLReqUnparsed -> SetGraphqlIntrospectionOptions -> RequestId -> Maybe Name -> m (ExecutionPlan, ParameterizedQueryHash)


-- | Module related to async action query subscriptions
module Hasura.GraphQL.Execute.Action.Subscription

-- | A forever running thread which processes async action subscriptions.
--   See Note [Async action subscriptions]
asyncActionSubscriptionsProcessor :: (MonadIO m, MonadMetadataStorage m) => AsyncActionSubscriptionState -> m void

module Hasura.GraphQL.Execute

-- | Construct a single step of an execution plan.
makeGQLContext :: UserInfo -> SchemaCache -> GraphQLQueryType -> GQLContext
data ResolvedExecutionPlan

-- | query execution; remote schemas and introspection possible
QueryExecutionPlan :: ExecutionPlan -> [QueryRootField UnpreparedValue] -> DirectiveMap -> ResolvedExecutionPlan

-- | mutation execution; only __typename introspection supported
MutationExecutionPlan :: ExecutionPlan -> ResolvedExecutionPlan

-- | either action query or live query execution; remote schemas and
--   introspection not supported
SubscriptionExecutionPlan :: (SubscriptionExecution, Maybe (Endo Value)) -> ResolvedExecutionPlan
newtype MultiplexedSubscriptionQueryPlan (b :: BackendType)
MultiplexedSubscriptionQueryPlan :: SubscriptionQueryPlan b (MultiplexedQuery b) -> MultiplexedSubscriptionQueryPlan (b :: BackendType)
newtype SubscriptionQueryPlan
SubscriptionQueryPlan :: AnyBackend MultiplexedSubscriptionQueryPlan -> SubscriptionQueryPlan
data SourceSubscription
SSLivequery :: !HashSet ActionId -> !ActionLogResponseMap -> ExceptT QErr IO (SourceName, SubscriptionQueryPlan) -> SourceSubscription
SSStreaming :: !RootFieldAlias -> !(SourceName, SubscriptionQueryPlan) -> SourceSubscription

-- | The comprehensive subscription plan. We only support either 1. Fields
--   with only async action queries with no associated relationships or 2.
--   Source database query fields from same source and also can be mixed
--   with async action query fields whose relationships are defined to
--   tables in the source
data SubscriptionExecution
SEAsyncActionsWithNoRelationships :: !RootFieldMap (ActionId, ActionLogResponse -> Either QErr EncJSON) -> SubscriptionExecution
SEOnSourceDB :: !SourceSubscription -> SubscriptionExecution
buildSubscriptionPlan :: forall m. (MonadError QErr m, MonadQueryTags m, MonadIO m, MonadBaseControl IO m) => UserInfo -> RootFieldMap (QueryRootField UnpreparedValue) -> ParameterizedQueryHash -> [Header] -> Maybe Name -> m (SubscriptionExecution, Maybe (Endo Value))
checkQueryInAllowlist :: MonadError QErr m => AllowListStatus -> AllowlistMode -> UserInfo -> GQLReqParsed -> SchemaCache -> m ()

-- | Construct a <a>ResolvedExecutionPlan</a> from a <a>GQLReqParsed</a>
--   and a bunch of metadata.
--   
--   Labelling it as inlineable fixed a performance regression on GHC
--   8.10.7.
getResolvedExecPlan :: forall m. (MonadError QErr m, MonadMetadataStorage m, MonadIO m, MonadBaseControl IO m, MonadTrace m, MonadGQLExecutionCheck m, MonadQueryTags m, ProvidesNetwork m) => Environment -> Logger Hasura -> PrometheusMetrics -> UserInfo -> SQLGenCtx -> ReadOnlyMode -> SchemaCache -> GraphQLQueryType -> [Header] -> GQLReqUnparsed -> SingleOperation -> Maybe Name -> RequestId -> m (ParameterizedQueryHash, ResolvedExecutionPlan)

module Hasura.GraphQL.Transport.WebSocket.Types
newtype WsHeaders
WsHeaders :: [Header] -> WsHeaders
[unWsHeaders] :: WsHeaders -> [Header]
data ErrRespType
ERTLegacy :: ErrRespType
ERTGraphqlCompliant :: ErrRespType
data WSConnState

-- | headers and IP address from the client for websockets
CSNotInitialised :: !WsHeaders -> !IpAddress -> WSConnState
CSInitError :: !Text -> WSConnState
CSInitialised :: !WsClientState -> WSConnState
data WsClientState
WsClientState :: !UserInfo -> !Maybe UTCTime -> ![Header] -> !IpAddress -> WsClientState

-- | the <a>UserInfo</a> required to execute the GraphQL query
[wscsUserInfo] :: WsClientState -> !UserInfo

-- | the JWT/token expiry time, if any
[wscsTokenExpTime] :: WsClientState -> !Maybe UTCTime

-- | headers from the client (in conn params) to forward to the remote
--   schema
[wscsReqHeaders] :: WsClientState -> ![Header]

-- | IP address required for <tt>MonadGQLAuthorization</tt>
[wscsIpAddress] :: WsClientState -> !IpAddress
data WSConnData
WSConnData :: !TVar WSConnState -> !OperationMap -> !ErrRespType -> !GraphQLQueryType -> WSConnData
data WSServerEnv impl
WSServerEnv :: !Logger Hasura -> !SubscriptionsState -> AppStateRef impl -> !Manager -> IO CorsPolicy -> ReadOnlyMode -> !WSServer -> !KeepAliveDelay -> !ServerMetrics -> !PrometheusMetrics -> !SamplingPolicy -> WSServerEnv impl
[_wseLogger] :: WSServerEnv impl -> !Logger Hasura
[_wseSubscriptionState] :: WSServerEnv impl -> !SubscriptionsState
[_wseAppStateRef] :: WSServerEnv impl -> AppStateRef impl
[_wseHManager] :: WSServerEnv impl -> !Manager
[_wseCorsPolicy] :: WSServerEnv impl -> IO CorsPolicy
[_wseReadOnlyMode] :: WSServerEnv impl -> ReadOnlyMode
[_wseServer] :: WSServerEnv impl -> !WSServer
[_wseKeepAliveDelay] :: WSServerEnv impl -> !KeepAliveDelay
[_wseServerMetrics] :: WSServerEnv impl -> !ServerMetrics
[_wsePrometheusMetrics] :: WSServerEnv impl -> !PrometheusMetrics
[_wseTraceSamplingPolicy] :: WSServerEnv impl -> !SamplingPolicy
data SubscriberType
LiveQuerySubscriber :: !LiveQuerySubscriberDetails -> SubscriberType
StreamingQuerySubscriber :: !StreamingSubscriberDetails -> SubscriberType
type WSConn = WSConn WSConnData
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.Types.WsHeaders
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.WsHeaders
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.ErrRespType
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.WsClientState
instance GHC.Show.Show Hasura.GraphQL.Transport.WebSocket.Types.WSConnState


-- | Execution of GraphQL queries over HTTP transport
module Hasura.GraphQL.Transport.HTTP

-- | Encapsulates a function that stores a query response in the cache.
--   <a>cacheLookup</a> decides when such an invitation to store is
--   generated.
newtype ResponseCacher
ResponseCacher :: (forall m. (MonadTrace m, MonadIO m) => EncJSON -> m (Either QErr CacheStoreResponse)) -> ResponseCacher
[runStoreResponse] :: ResponseCacher -> forall m. (MonadTrace m, MonadIO m) => EncJSON -> m (Either QErr CacheStoreResponse)
data CacheStoreResponse

-- | Cache storage is unconditional, just not always available.
CacheStoreSuccess :: CacheStoreResponse
CacheStoreLimitReached :: CacheStoreResponse
CacheStoreNotEnoughCapacity :: CacheStoreResponse
CacheStoreBackendError :: String -> CacheStoreResponse
data CacheResult

-- | We have a cached response for this query
ResponseCached :: EncJSON -> CacheResult

-- | We don't have a cached response. The <a>ResponseCacher</a> can be used
--   to store the response in the cache after a fresh execution.
ResponseUncached :: Maybe ResponseCacher -> CacheResult
class (Monad m) => MonadExecuteQuery m

-- | This method does two things: it looks up a query result in the
--   server-side cache, if a cache is used, and it additionally returns
--   HTTP headers that can instruct a client how long a response can be
--   cached locally (i.e. client-side).
cacheLookup :: MonadExecuteQuery m => ExecutionPlan -> [QueryRootField UnpreparedValue] -> Maybe CachedDirective -> GQLReqParsed -> UserInfo -> [Header] -> m (Either QErr (ResponseHeaders, CacheResult))

-- | This method does two things: it looks up a query result in the
--   server-side cache, if a cache is used, and it additionally returns
--   HTTP headers that can instruct a client how long a response can be
--   cached locally (i.e. client-side).
cacheLookup :: (MonadExecuteQuery m, m ~ t n, MonadTrans t, MonadExecuteQuery n) => ExecutionPlan -> [QueryRootField UnpreparedValue] -> Maybe CachedDirective -> GQLReqParsed -> UserInfo -> [Header] -> m (Either QErr (ResponseHeaders, CacheResult))

-- | A partial response, e.g. from a remote schema call or postgres
--   postgres query, which we'll assemble into the final response for the
--   client. It is annotated with timing metadata.
data AnnotatedResponsePart
AnnotatedResponsePart :: DiffTime -> Locality -> EncJSON -> ResponseHeaders -> AnnotatedResponsePart
[arpTimeIO] :: AnnotatedResponsePart -> DiffTime
[arpLocality] :: AnnotatedResponsePart -> Locality
[arpResponse] :: AnnotatedResponsePart -> EncJSON
[arpHeaders] :: AnnotatedResponsePart -> ResponseHeaders

-- | A predicate on session variables. The <a>Monoid</a> instance makes it
--   simple to combine several predicates disjunctively. | The definition
--   includes <a>Maybe</a> which allows us to short-circuit calls like
--   <tt>mempty &lt;&gt; m</tt> and <tt>m &lt;&gt; mempty</tt>, which
--   otherwise might build up long repeated chains of calls to <tt>_ _
--   -&gt; False</tt>.
data SessVarPred
runSessVarPred :: SessVarPred -> SessionVariables -> SessionVariables

-- | Filter out only those session variables used by the query AST provided
filterVariablesFromQuery :: [RootField (QueryDBRoot (RemoteRelationshipField UnpreparedValue) UnpreparedValue) (RemoteSchemaRootField (RemoteRelationshipField UnpreparedValue) RemoteSchemaVariable) (ActionQuery (RemoteRelationshipField UnpreparedValue)) d] -> SessVarPred

-- | Run (execute) a single GraphQL query
runGQ :: forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadExecutionLog m, MonadTrace m, MonadExecuteQuery m, MonadMetadataStorage m, MonadQueryTags m, HasResourceLimits m, ProvidesNetwork m) => Environment -> SQLGenCtx -> SchemaCache -> AllowListStatus -> ReadOnlyMode -> PrometheusMetrics -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> RequestId -> UserInfo -> IpAddress -> [Header] -> GraphQLQueryType -> GQLReqUnparsed -> m (GQLQueryOperationSuccessLog, HttpResponse (Maybe GQResponse, EncJSON))
coalescePostgresMutations :: ExecutionPlan -> Maybe (SourceConfig ('Postgres 'Vanilla), ResolvedConnectionTemplate ('Postgres 'Vanilla), InsOrdHashMap RootFieldAlias (DBStepInfo ('Postgres 'Vanilla)))
extractFieldFromResponse :: forall m. Monad m => RootFieldAlias -> ResultCustomizer -> ByteString -> ExceptT (Either GQExecError QErr) m Value
buildRaw :: Applicative m => Value -> m AnnotatedResponsePart
encodeAnnotatedResponseParts :: RootFieldMap AnnotatedResponsePart -> EncJSON
encodeEncJSONResults :: RootFieldMap EncJSON -> EncJSON

-- | Run (execute) a batched GraphQL query (see <a>GQLBatchedReqs</a>).
runGQBatched :: forall m. (MonadIO m, MonadBaseControl IO m, MonadError QErr m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadExecutionLog m, MonadTrace m, MonadExecuteQuery m, MonadMetadataStorage m, MonadQueryTags m, HasResourceLimits m, ProvidesNetwork m) => Environment -> SQLGenCtx -> SchemaCache -> AllowListStatus -> ReadOnlyMode -> PrometheusMetrics -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> RequestId -> ResponseInternalErrorsConfig -> UserInfo -> IpAddress -> [Header] -> GraphQLQueryType -> GQLBatchedReqs (GQLReq GQLQueryText) -> m (HttpLogGraphQLInfo, HttpResponse EncJSON)
instance GHC.Base.Monoid Hasura.GraphQL.Transport.HTTP.SessVarPred
instance GHC.Base.Semigroup Hasura.GraphQL.Transport.HTTP.SessVarPred
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery m => Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery m => Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery (Control.Monad.Trans.Except.ExceptT e m)

module Hasura.Server.Rest
data RestRequest method
RestRequest :: Text -> method -> [(Text, Either Text Value)] -> RestRequest method

-- | Remainder of the url path after `api/rest`
[reqPath] :: RestRequest method -> Text
[reqMethod] :: RestRequest method -> method

-- | URL Query/Request Body Arguments
[reqArgs] :: RestRequest method -> [(Text, Either Text Value)]

-- | Implements all the custom endpoints by looking up the path/methods in
--   the endpoint trie and delegating to the graphql handler.
runCustomEndpoint :: forall m. (MonadIO m, MonadError QErr m, MonadTrace m, MonadBaseControl IO m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadExecutionLog m, MonadExecuteQuery m, MonadMetadataStorage m, MonadQueryTags m, HasResourceLimits m, ProvidesNetwork m) => Environment -> SQLGenCtx -> SchemaCache -> AllowListStatus -> ReadOnlyMode -> PrometheusMetrics -> Logger Hasura -> Maybe (CredentialCache AgentLicenseKey) -> RequestId -> UserInfo -> [Header] -> IpAddress -> RestRequest EndpointMethod -> EndpointTrie GQLQueryWithText -> m (HttpLogGraphQLInfo, HttpResponse EncJSON)
instance Data.Traversable.Traversable Hasura.Server.Rest.RestRequest
instance Data.Foldable.Foldable Hasura.Server.Rest.RestRequest
instance GHC.Base.Functor Hasura.Server.Rest.RestRequest


-- | This file contains the handlers that are used within websocket server.
--   
--   This module export three main handlers for the websocket server
--   (<a>onConn</a>, <a>onMessage</a>, <a>onClose</a>), and two helpers for
--   sending messages to the client (<a>sendMsg</a>,
--   <a>sendCloseWithMsg</a>).
--   
--   NOTE! The handler functions <a>onClose</a>, <a>onMessage</a>, etc.
--   depend for correctness on two properties: - they run with async
--   exceptions masked - they do not race on the same connection
module Hasura.GraphQL.Transport.WebSocket
sendMsg :: MonadIO m => WSConn -> ServerMsg -> m ()
sendCloseWithMsg :: MonadIO m => Logger Hasura -> WSConn -> ServerErrorCode -> Maybe ServerMsg -> Maybe Word16 -> m ()
onConn :: (MonadFail m, MonadIO m, MonadReader (WSServerEnv impl) m) => OnConnH m WSConnData
onMessage :: (MonadIO m, UserAuthentication m, MonadGQLExecutionCheck m, MonadQueryLog m, MonadExecutionLog m, MonadExecuteQuery m, MonadBaseControl IO m, MonadMetadataStorage m, MonadQueryTags m, HasResourceLimits m, ProvidesNetwork m, MonadTrace m, MonadGetPolicies m) => HashSet (EngineLogType Hasura) -> IO AuthMode -> WSServerEnv impl -> WSConn -> ByteString -> WSActions WSConnData -> Maybe (CredentialCache AgentLicenseKey) -> m ()
onClose :: MonadIO m => Logger Hasura -> ServerMetrics -> PrometheusMetrics -> SubscriptionsState -> WSConn -> IO GranularPrometheusMetricsState -> m ()
data WebsocketCloseOnMetadataChangeAction

-- | By default, we close all the websocket connections when the metadata
--   changes. This function is used to create the action that will be run
--   when the metadata changes.
mkCloseWebsocketsOnMetadataChangeAction :: WSServer WSConnData -> WebsocketCloseOnMetadataChangeAction
instance Hasura.Logging.ToEngineLog Hasura.GraphQL.Transport.WebSocket.WSLog Hasura.Logging.Hasura
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.WSLogInfo
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.WSLogInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.WsConnInfo
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.WsConnInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.WSEvent
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.WSEvent
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.OperationDetails
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.OperationDetails
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Transport.WebSocket.OpDetail
instance GHC.Classes.Eq Hasura.GraphQL.Transport.WebSocket.OpDetail


-- | The RQL metadata query ('<i>v1</i>metadata')
module Hasura.Server.API.Metadata

-- | The payload for the <tt><i>v1</i>metadata</tt> endpoint. See:
--   
--   
--   <a>https://hasura.io/docs/latest/graphql/core/api-reference/metadata-api/index/</a>
data RQLMetadata
runMetadataQuery :: (MonadIO m, MonadError QErr m, MonadBaseControl IO m, HasAppEnv m, HasCacheStaticConfig m, HasFeatureFlagChecker m, MonadTrace m, MonadMetadataStorage m, MonadResolveSource m, MonadEventLogCleanup m, ProvidesHasuraServices m, MonadGetPolicies m, UserInfoM m) => AppContext -> RebuildableSchemaCache -> WebsocketCloseOnMetadataChangeAction -> RQLMetadata -> m (EncJSON, RebuildableSchemaCache)
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.Server.API.Metadata.RQLMetadata

module Hasura.GraphQL.Transport.WSServerApp
createWSServerApp :: (MonadIO m, MonadFail m, MonadBaseControl IO m, Forall (Pure m), UserAuthentication m, MonadGQLExecutionCheck m, MonadWSLog m, MonadQueryLog m, MonadExecutionLog m, MonadExecuteQuery m, MonadMetadataStorage m, MonadQueryTags m, HasResourceLimits m, ProvidesNetwork m, MonadTrace m, MonadGetPolicies m) => HashSet (EngineLogType Hasura) -> WSServerEnv impl -> WSConnectionInitTimeout -> Maybe (CredentialCache AgentLicenseKey) -> HasuraServerApp m
stopWSServerApp :: WSServerEnv impl -> IO ()
createWSServerEnv :: (HasAppEnv m, MonadIO m) => AppStateRef impl -> m (WSServerEnv impl)

module Hasura.GraphQL.Explain
data GQLExplain
explainGQLQuery :: forall m. (MonadError QErr m, MonadIO m, MonadBaseControl IO m, MonadMetadataStorage m, MonadQueryTags m, MonadTrace m) => SchemaCache -> Maybe (CredentialCache AgentLicenseKey) -> [Header] -> GQLExplain -> m EncJSON
instance GHC.Generics.Generic Hasura.GraphQL.Explain.GQLExplain
instance GHC.Classes.Eq Hasura.GraphQL.Explain.GQLExplain
instance GHC.Show.Show Hasura.GraphQL.Explain.GQLExplain
instance Data.Aeson.Types.FromJSON.FromJSON Hasura.GraphQL.Explain.GQLExplain
instance Data.Aeson.Types.ToJSON.ToJSON Hasura.GraphQL.Explain.GQLExplain

module Hasura.Server.App
data HandlerCtx
data Handler m a
data APIResp
JSONResp :: !HttpResponse EncJSON -> APIResp
RawResp :: !HttpResponse ByteString -> APIResp
boolToText :: Bool -> Text
isAdminSecretSet :: AuthMode -> Text
mkGetHandler :: Handler m (HttpLogGraphQLInfo, APIResp) -> APIHandler m ()
onlyAdmin :: (MonadError QErr m, MonadReader HandlerCtx m) => m ()

-- | Typeclass representing the metadata API authorization effect
class (Monad m) => MonadMetadataApiAuthorization m
authorizeV1QueryApi :: MonadMetadataApiAuthorization m => RQLQuery -> HandlerCtx -> m (Either QErr ())
authorizeV1MetadataApi :: MonadMetadataApiAuthorization m => RQLMetadata -> HandlerCtx -> m (Either QErr ())
authorizeV2QueryApi :: MonadMetadataApiAuthorization m => RQLQuery -> HandlerCtx -> m (Either QErr ())

-- | The config API (<i>v1alpha1</i>config) handler
class (Monad m) => MonadConfigApiHandler m
runConfigApiHandler :: MonadConfigApiHandler m => AppStateRef impl -> SpockCtxT () m ()
mkSpockAction :: forall m a impl. (MonadIO m, MonadBaseControl IO m, HasAppEnv m, FromJSON a, UserAuthentication m, HttpLog m, HasResourceLimits m, MonadTrace m) => AppStateRef impl -> (Bool -> QErr -> Encoding) -> (QErr -> QErr) -> APIHandler m a -> ActionT m ()
class (Monad m) => ConsoleRenderer m where {
    type ConsoleType m :: Type;
}
renderConsole :: ConsoleRenderer m => Text -> AuthMode -> TelemetryStatus -> Maybe Text -> Maybe Text -> ConsoleType m -> m (Either String Text)
data CEConsoleType
OSSConsole :: CEConsoleType
ProLiteConsole :: CEConsoleType
ceConsoleTypeIdentifier :: CEConsoleType -> String
class (Monad m) => MonadVersionAPIWithExtraData m
getExtraDataForVersionAPI :: MonadVersionAPIWithExtraData m => m [Pair]
renderHtmlTemplate :: Template -> Value -> Either String Text

-- | Default implementation of the <a>MonadConfigApiHandler</a>
configApiGetHandler :: forall m impl. (MonadIO m, MonadBaseControl IO m, HasAppEnv m, UserAuthentication m, HttpLog m, HasResourceLimits m, MonadTrace m) => AppStateRef impl -> SpockCtxT () m ()
data HasuraApp
HasuraApp :: !Application -> !AsyncActionSubscriptionState -> !IO () -> HasuraApp
mkWaiApp :: forall m impl. (MonadIO m, MonadFail m, MonadFix m, MonadStateless IO m, Forall (Pure m), ConsoleRenderer m, MonadVersionAPIWithExtraData m, HttpLog m, HasAppEnv m, HasCacheStaticConfig m, HasFeatureFlagChecker m, UserAuthentication m, MonadMetadataApiAuthorization m, MonadGQLExecutionCheck m, MonadConfigApiHandler m, MonadQueryLog m, MonadExecutionLog m, MonadWSLog m, MonadTrace m, MonadExecuteQuery m, HasResourceLimits m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m, MonadEventLogCleanup m, ProvidesNetwork m, MonadGetPolicies m) => (AppStateRef impl -> SpockT m ()) -> AppStateRef impl -> ConsoleType m -> Store EmptyMetrics -> WSServerEnv impl -> m HasuraApp
onlyWhenApiEnabled :: MonadIO m => (AppContext -> Bool) -> AppStateRef impl -> ActionCtxT ctx m b -> ActionCtxT ctx m b
instance Hasura.Server.Types.MonadGetPolicies m => Hasura.Server.Types.MonadGetPolicies (Hasura.Server.App.Handler m)
instance Hasura.Services.Network.ProvidesNetwork m => Hasura.Services.Network.ProvidesNetwork (Hasura.Server.App.Handler m)
instance Hasura.Metadata.Class.MonadMetadataStorage m => Hasura.Metadata.Class.MonadMetadataStorage (Hasura.Server.App.Handler m)
instance Hasura.Server.App.MonadMetadataApiAuthorization m => Hasura.Server.App.MonadMetadataApiAuthorization (Hasura.Server.App.Handler m)
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery m => Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery (Hasura.Server.App.Handler m)
instance Hasura.QueryTags.MonadQueryTags m => Hasura.QueryTags.MonadQueryTags (Hasura.Server.App.Handler m)
instance Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog m => Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog (Hasura.Server.App.Handler m)
instance Hasura.GraphQL.Logging.QueryLog.MonadQueryLog m => Hasura.GraphQL.Logging.QueryLog.MonadQueryLog (Hasura.Server.App.Handler m)
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup m => Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup (Hasura.Server.App.Handler m)
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck m => Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck (Hasura.Server.App.Handler m)
instance Hasura.RQL.Types.Source.MonadResolveSource m => Hasura.RQL.Types.Source.MonadResolveSource (Hasura.Server.App.Handler m)
instance Hasura.Server.Limits.HasResourceLimits m => Hasura.Server.Limits.HasResourceLimits (Hasura.Server.App.Handler m)
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker m => Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker (Hasura.Server.App.Handler m)
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig m => Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig (Hasura.Server.App.Handler m)
instance Hasura.App.State.HasAppEnv m => Hasura.App.State.HasAppEnv (Hasura.Server.App.Handler m)
instance Hasura.Tracing.Class.MonadTrace m => Hasura.Tracing.Class.MonadTrace (Hasura.Server.App.Handler m)
instance Hasura.Tracing.Class.MonadTraceContext m => Hasura.Tracing.Class.MonadTraceContext (Hasura.Server.App.Handler m)
instance GHC.Base.Monad m => Control.Monad.Error.Class.MonadError Hasura.Base.Error.QErr (Hasura.Server.App.Handler m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader Hasura.Server.App.HandlerCtx (Hasura.Server.App.Handler m)
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Hasura.Server.App.Handler m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Hasura.Server.App.Handler m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Hasura.Server.App.Handler m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Hasura.Server.App.Handler m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hasura.Server.App.Handler m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Hasura.Server.App.Handler m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hasura.Server.App.Handler m)
instance Hasura.Server.App.ConsoleRenderer m => Hasura.Server.App.ConsoleRenderer (Hasura.Tracing.Monad.TraceT m)
instance Control.Monad.Trans.Class.MonadTrans Hasura.Server.App.Handler
instance GHC.Base.Monad m => Hasura.RQL.Types.Session.UserInfoM (Hasura.Server.App.Handler m)
instance Hasura.Server.App.MonadMetadataApiAuthorization m => Hasura.Server.App.MonadMetadataApiAuthorization (Control.Monad.Trans.Reader.ReaderT r m)
instance Hasura.Server.App.MonadMetadataApiAuthorization m => Hasura.Server.App.MonadMetadataApiAuthorization (Control.Monad.Trans.Except.ExceptT e m)
instance Hasura.Server.App.MonadMetadataApiAuthorization m => Hasura.Server.App.MonadMetadataApiAuthorization (Hasura.Tracing.Monad.TraceT m)


-- | Defines the CE version of the engine.
--   
--   This module contains everything that is required to run the community
--   edition of the engine: the base application monad and the
--   implementation of all its behaviour classes.
module Hasura.App
data ExitCode
InvalidEnvironmentVariableOptionsError :: ExitCode
InvalidDatabaseConnectionParamsError :: ExitCode
AuthConfigurationError :: ExitCode
DatabaseMigrationError :: ExitCode

-- | used by MT because it initialises the schema cache only these are used
--   in app/Main.hs:
SchemaCacheInitError :: ExitCode
MetadataExportError :: ExitCode
MetadataCleanError :: ExitCode
DowngradeProcessError :: ExitCode
data ExitException
ExitException :: !ExitCode -> !ByteString -> ExitException
[eeCode] :: ExitException -> !ExitCode
[eeMessage] :: ExitException -> !ByteString
throwErrExit :: MonadIO m => forall a. ExitCode -> String -> m a
throwErrJExit :: (ToJSON a, MonadIO m) => forall b. ExitCode -> a -> m b
accessDeniedErrMsg :: Text
printJSON :: (ToJSON a, MonadIO m) => a -> m ()
mkPGLogger :: Logger Hasura -> PGLogger

-- | Create all loggers based on the set of enabled logs and chosen log
--   level.
mkLoggers :: (MonadIO m, MonadBaseControl IO m) => HashSet (EngineLogType Hasura) -> LogLevel -> ManagedT m Loggers

-- | Basic information required to connect to the metadata DB, and to the
--   default Postgres DB if any.
data BasicConnectionInfo
BasicConnectionInfo :: ConnInfo -> Maybe PostgresConnConfiguration -> BasicConnectionInfo

-- | metadata db connection info
[bciMetadataConnInfo] :: BasicConnectionInfo -> ConnInfo

-- | default postgres connection info, if any
[bciDefaultPostgres] :: BasicConnectionInfo -> Maybe PostgresConnConfiguration

-- | Only create the metadata connection info.
--   
--   Like <a>initBasicConnectionInfo</a>, it prioritizes
--   <tt>--metadata-database-url</tt>, and falls back to
--   <tt>--database-url</tt> otherwise.
--   
--   !!! This function throws a fatal error if the <tt>--database-url</tt>
--   cannot be !!! resolved.
initMetadataConnectionInfo :: MonadIO m => Environment -> Maybe String -> PostgresConnInfo (Maybe UrlConf) -> m ConnInfo

-- | Create a <a>BasicConnectionInfo</a> based on the given options.
--   
--   The default postgres connection is only created when the
--   <tt>--database-url</tt> option is given. If the
--   <tt>--metadata-database-url</tt> isn't given, the
--   <tt>--database-url</tt> will be used for the metadata connection.
--   
--   All arguments related to the default postgres connection are ignored
--   if the <tt>--database-url</tt> is missing.
--   
--   !!! This function throws a fatal error if the <tt>--database-url</tt>
--   cannot be !!! resolved.
initBasicConnectionInfo :: MonadIO m => Environment -> Maybe String -> PostgresConnInfo (Maybe UrlConf) -> Maybe PostgresPoolSettings -> Bool -> TxIsolation -> m BasicConnectionInfo

-- | Creates a <a>ConnInfo</a> from a <a>UrlConf</a> parameter.
--   
--   !!! throws a fatal error if the configuration is invalid
resolvePostgresConnInfo :: MonadIO m => Environment -> UrlConf -> Maybe Int -> m ConnInfo

-- | Initializes or migrates the catalog and creates the <a>AppEnv</a>
--   required to start the server, and also create the <a>AppInit</a> that
--   needs to be threaded along the init code.
--   
--   For historical reasons, this function performs a few additional
--   startup tasks that are not required to create the <a>AppEnv</a>, such
--   as starting background processes and logging startup information. All
--   of those are flagged with a comment marking them as a side-effect.
initialiseAppEnv :: ForkableMonadIO m => Environment -> BasicConnectionInfo -> ServeOptions Hasura -> Maybe SubscriptionPostPollHook -> ServerMetrics -> PrometheusMetrics -> SamplingPolicy -> ManagedT m (AppInit, AppEnv)

-- | Initializes the <a>AppContext</a> and returns a corresponding
--   <a>AppStateRef</a>.
--   
--   This function is meant to be run in the app monad, which provides the
--   <a>AppEnv</a>.
initialiseAppContext :: (ForkableMonadIO m, HasAppEnv m) => Environment -> ServeOptions Hasura -> AppInit -> m (AppStateRef Hasura)

-- | Runs catalogue migration, and returns the metadata that was fetched.
--   
--   On success, this function logs the result of the migration, on failure
--   it logs a <tt>catalog_migrate</tt> error and throws a fatal error.
migrateCatalogAndFetchMetadata :: (MonadIO m, MonadBaseControl IO m) => Logger Hasura -> PGPool -> Maybe (SourceConnConfiguration ('Postgres 'Vanilla)) -> MaintenanceMode () -> ExtensionsSchema -> m MetadataWithResourceVersion

-- | Build the original <a>RebuildableSchemaCache</a>.
--   
--   On error, it logs a <tt>catalog_migrate</tt> error and throws a fatal
--   error. This misnomer is intentional: it is to preserve a previous
--   behaviour of the code and avoid a breaking change.
buildFirstSchemaCache :: MonadIO m => Environment -> Logger Hasura -> SourceResolver ('Postgres 'Vanilla) -> SourceResolver 'MSSQL -> MetadataWithResourceVersion -> CacheStaticConfig -> CacheDynamicConfig -> Manager -> Maybe SchemaRegistryContext -> m RebuildableSchemaCache
initSubscriptionsState :: Logger Hasura -> Maybe SubscriptionPostPollHook -> IO SubscriptionsState
initLockedEventsCtx :: IO LockedEventsCtx

-- | The base app monad of the CE engine.
data AppM a
runAppM :: AppEnv -> AppM a -> IO a

-- | Parse cli arguments to graphql-engine executable.
parseArgs :: EnabledLogTypes impl => Environment -> IO (HGEOptions (ServeOptions impl))

-- | Core logic to fork a poller thread to update the JWK based on the
--   expiry time specified in <tt>Expires</tt> header or
--   <tt>Cache-Control</tt> header
updateJwkCtxThread :: ForkableMonadIO m => IO AppContext -> Manager -> Logger Hasura -> m Void

-- | This function acts as the entrypoint for the graphql-engine webserver.
--   
--   Note: at the exit of this function, or in case of a graceful server
--   shutdown (SIGTERM, or more generally, whenever the shutdown latch is
--   set), we need to make absolutely sure that we clean up any resources
--   which were allocated during server setup. In the case of a multitenant
--   process, failure to do so can lead to resource leaks.
--   
--   To track these resources, we use the ManagedT monad, and attach
--   finalizers at the same point in the code where we allocate resources.
--   If you fork a new long-lived thread, or create a connection pool, or
--   allocate any other long-lived resource, make sure to pair the
--   allocator with its finalizer. There are plenty of examples throughout
--   the code. For example, see <a>forkManagedT</a>.
--   
--   Note also: the order in which the finalizers run can be important.
--   Specifically, we want the finalizers for the logger threads to run
--   last, so that we retain as many "thread stopping" log messages as
--   possible. The order in which the finalizers is run is determined by
--   the order in which they are introduced in the code.
runHGEServer :: forall m impl. (MonadIO m, MonadFail m, MonadFix m, MonadMask m, MonadStateless IO m, Forall (Pure m), UserAuthentication m, HttpLog m, HasAppEnv m, HasCacheStaticConfig m, HasFeatureFlagChecker m, ConsoleRenderer m, MonadVersionAPIWithExtraData m, MonadMetadataApiAuthorization m, MonadGQLExecutionCheck m, MonadConfigApiHandler m, MonadQueryLog m, MonadExecutionLog m, MonadWSLog m, MonadExecuteQuery m, HasResourceLimits m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m, MonadEventLogCleanup m, ProvidesHasuraServices m, MonadTrace m, MonadGetPolicies m) => (AppStateRef impl -> SpockT m ()) -> AppStateRef impl -> UTCTime -> Maybe (IO ()) -> ConsoleType m -> Store EmptyMetrics -> ManagedT m ()

-- | Part of a factorization of <a>runHGEServer</a> to expose the
--   constructed WAI application for testing purposes. See
--   <a>runHGEServer</a> for documentation.
mkHGEServer :: forall m impl. (MonadIO m, MonadFail m, MonadFix m, MonadMask m, MonadStateless IO m, Forall (Pure m), UserAuthentication m, HttpLog m, HasAppEnv m, HasCacheStaticConfig m, HasFeatureFlagChecker m, ConsoleRenderer m, MonadVersionAPIWithExtraData m, MonadMetadataApiAuthorization m, MonadGQLExecutionCheck m, MonadConfigApiHandler m, MonadQueryLog m, MonadExecutionLog m, MonadWSLog m, MonadExecuteQuery m, HasResourceLimits m, MonadMetadataStorage m, MonadResolveSource m, MonadQueryTags m, MonadEventLogCleanup m, ProvidesHasuraServices m, MonadTrace m, MonadGetPolicies m) => (AppStateRef impl -> SpockT m ()) -> AppStateRef impl -> ConsoleType m -> Store EmptyMetrics -> ManagedT m Application
notifySchemaCacheSyncTx :: MetadataResourceVersion -> InstanceId -> CacheInvalidations -> TxE QErr ()
getCatalogStateTx :: TxE QErr CatalogState
setCatalogStateTx :: CatalogStateType -> Value -> TxE QErr ()
mkPgSourceResolver :: PGLogger -> SourceResolver ('Postgres 'Vanilla)
mkMSSQLSourceResolver :: SourceResolver 'MSSQL
instance GHC.Show.Show Hasura.App.ExitCode
instance GHC.Show.Show Hasura.App.ExitException
instance Control.Monad.Trans.Control.MonadBaseControl GHC.Types.IO Hasura.App.AppM
instance Control.Monad.Base.MonadBase GHC.Types.IO Hasura.App.AppM
instance Control.Monad.Reader.Class.MonadReader Hasura.App.State.AppEnv Hasura.App.AppM
instance Control.Monad.Catch.MonadMask Hasura.App.AppM
instance Control.Monad.Catch.MonadThrow Hasura.App.AppM
instance Control.Monad.Catch.MonadCatch Hasura.App.AppM
instance Control.Monad.Fix.MonadFix Hasura.App.AppM
instance Control.Monad.IO.Class.MonadIO Hasura.App.AppM
instance GHC.Base.Monad Hasura.App.AppM
instance GHC.Base.Applicative Hasura.App.AppM
instance Control.Monad.Fail.MonadFail Hasura.App.AppM
instance GHC.Base.Functor Hasura.App.AppM
instance Hasura.App.State.HasAppEnv Hasura.App.AppM
instance Hasura.Server.Init.FeatureFlag.HasFeatureFlagChecker Hasura.App.AppM
instance Hasura.RQL.DDL.Schema.Cache.Config.HasCacheStaticConfig Hasura.App.AppM
instance Hasura.Tracing.Class.MonadTrace Hasura.App.AppM
instance Hasura.Tracing.Class.MonadTraceContext Hasura.App.AppM
instance Hasura.Services.Network.ProvidesNetwork Hasura.App.AppM
instance Hasura.Server.Limits.HasResourceLimits Hasura.App.AppM
instance Hasura.Server.Logging.HttpLog Hasura.App.AppM
instance Hasura.GraphQL.Transport.HTTP.MonadExecuteQuery Hasura.App.AppM
instance Hasura.Server.Auth.UserAuthentication Hasura.App.AppM
instance Hasura.Server.App.MonadMetadataApiAuthorization Hasura.App.AppM
instance Hasura.Server.App.ConsoleRenderer Hasura.App.AppM
instance Hasura.Server.App.MonadVersionAPIWithExtraData Hasura.App.AppM
instance Hasura.GraphQL.Execute.Common.MonadGQLExecutionCheck Hasura.App.AppM
instance Hasura.Server.App.MonadConfigApiHandler Hasura.App.AppM
instance Hasura.GraphQL.Logging.QueryLog.MonadQueryLog Hasura.App.AppM
instance Hasura.GraphQL.Logging.ExecutionLog.MonadExecutionLog Hasura.App.AppM
instance Hasura.GraphQL.Transport.WebSocket.Server.MonadWSLog Hasura.App.AppM
instance Hasura.RQL.Types.Source.MonadResolveSource Hasura.App.AppM
instance Hasura.QueryTags.MonadQueryTags Hasura.App.AppM
instance Hasura.RQL.DDL.EventTrigger.MonadEventLogCleanup Hasura.App.AppM
instance Hasura.Server.Types.MonadGetPolicies Hasura.App.AppM
instance Hasura.Metadata.Class.MonadMetadataStorage Hasura.App.AppM
instance Hasura.Metadata.Class.MonadEECredentialsStorage Hasura.App.AppM
instance GHC.Exception.Type.Exception Hasura.App.ExitException
