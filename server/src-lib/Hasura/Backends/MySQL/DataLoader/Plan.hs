-- | Make a plan for the data loader to execute (.Execute).
--
-- It will produce a graph of actions, to be executed by .Execute.

{-# LANGUAGE DuplicateRecordFields #-}


module Hasura.Backends.MySQL.DataLoader.Plan
  ( Ref
  , PlannedAction(..)
  , Action(..)
  , Select(..)
  , Join(..)
  , Relationship(..)
  , FieldName(..)
  , HeadAndTail(..)
  , toFieldName
  ) where

import           Data.Aeson
import           Data.String
import qualified Hasura.Backends.MySQL.Types   as MySQL
import           Hasura.Prelude                hiding (head, second, tail, tell)

--------------------------------------------------------------------------------
-- Types

-- | A reference to a result of loading a recordset from the database.
data Ref = Ref
  { idx  :: !Int -- ^ This index will be generated by the planner.
  , text :: !Text  -- ^ A display name. The idx gives us uniqueness.
  } deriving (Show, Eq, Generic, Ord)
instance Hashable Ref

-- | A almost-the-same version of Select from Types.Internal, except
-- with some fields used for planning and executing.
data Select = Select
  { selectAggUnwrap    :: !(Maybe Text)
  , selectFrom         :: !(Maybe MySQL.From)
  , selectGroupBy      :: ![MySQL.FieldName]
  , selectHaskellJoins :: ![MySQL.Join]
  , selectSqlOffset    :: !(Maybe Int)
  , selectOrderBy      :: !(Maybe (NonEmpty MySQL.OrderBy))
  , selectProjections  :: ![MySQL.Projection]
  , selectRelationship :: !(Maybe Relationship)
  , selectSqlTop       :: !MySQL.Top
  , selectWhere        :: !MySQL.Where
  , selectWantedFields :: !(Maybe [Text])
  } deriving (Show)

-- | An join action.
data Join = Join
  { leftRecordSet   :: Ref -- ^ Join this side...
  , rightRecordSet  :: Ref -- ^ with this side.
  , joinRhsTop      :: !MySQL.Top
    -- ^ Join only the top N results. It's important that we do this
    -- IN HASKELL, therefore this is not part of the generated SQL.
  , joinRhsOffset   :: !(Maybe Int)
    -- ^ Offset applied to the right-hand-side table.
  , joinType        :: !MySQL.JoinType
    -- ^ Type of relational join to do.
  , joinFieldName   :: !Text
    -- ^ Field name to return the join result as; e.g. "albums" for an
    -- artist with an array relation of albums.
  , wantedFields    :: !(Maybe [Text])
    -- ^ The SQL queries may achieve the data using joining fields,
    -- but those fields aren't supposed to be returned back to the
    -- user. To avoid that, we explicitly specify which fields are
    -- wanted from this join. E.g. "title" and "year", but not
    -- artist_id which was used to Haskell-join the row with an
    -- album_artist_id, or whatever.
  } deriving (Show)

-- | An action that the executor will perform. Either pull data from
-- the database directly via a select, or join two other actions'
-- record sets together.
data Action
  = SelectAction Select
  | JoinAction Join
  deriving (Show)

-- | An action planned, with a unique reference. I.e. the @action@
-- performed yields a result stored at reference @ref@.
data PlannedAction = PlannedAction
  { ref    :: Ref
  , action :: Action
  } deriving (Show)

-- | A relationship lets the executor insert on-the-fly WHERE
-- fkey1=fkey2 for relationships. These can only be inserted
-- on-the-fly and aren't known at the time of planning, because the
-- keys come from the left-hand-side table for a join.
data Relationship = Relationship
  { leftRecordSet :: Ref
  , rightTable    :: MySQL.EntityAlias
  , joinType      :: MySQL.JoinType
  } deriving (Show)

-- | Just a wrapper to clarify some types. It's different from the
-- MySQL.FieldName because it doesn't care about schemas: schemas
-- aren't returned in recordsets from the database.
newtype FieldName =
  FieldName Text
  deriving (Show, Ord, Eq, Hashable, FromJSON, ToJSONKey, IsString)

-- | The reason for this is subtle. Read this documentation. For each
-- join on a select (see above, there is a list), we split that out
-- into three jobs:
--
-- 1. One job for the left hand side (i.e. the select).
-- 2. One job for the right hand side (i.e. the join).
-- 3. One job to join them (And in the darkness bind them...)
--
-- This is performed as a fold, like: @foldM planJoin head joins@. A
-- nice linked-list or tree-like structure arises. The planner code
-- produces a graph out of this; so it's possible that some
-- parallelism can be achieved by running multiple jobs at once.
--
-- The "head" is the first, original select. The "tail" is the
-- (indirectly) linked list of joins. That list may also be empty. In
-- that case, the tail is simply the same as the head.
--
-- If the tail is different to the head, then we choose the tail, as
-- it represents the joined up version of both. If they're the same,
-- we take whichever.
--
data HeadAndTail = HeadAndTail
  { head :: Ref
  , tail :: Ref
  }

--------------------------------------------------------------------------------
-- Conversions

-- | Note that we're intentionally discarding the table qualification.
toFieldName :: MySQL.FieldName -> FieldName
toFieldName (MySQL.FieldName {fName = t}) = FieldName t
