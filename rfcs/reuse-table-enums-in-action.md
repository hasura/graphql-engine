# Table Enums in Actions

### Table Of Contents

- [Summary](#summary)
- [Introduction](#introduction)
- [Motivation](#motivation)
- [Solution Design](#solution-design)
  * [1. Directly Use Typenames](#1-directly-use-typenames)
    + [Action Definition](#action-definition)
    + [Pros and Cons](#pros-and-cons)
  * [2. Extend Custom Types](#2-extend-custom-types)
    + [Custom Types](#custom-types)
    + [Action Definition](#action-definition-1)
    + [Pros and Cons](#pros-and-cons-1)
  * [3. Extending Custom Types and Using Typenames](#3-extending-custom-types-and-using-typenames)
    + [Additional explanation](#additional-explanation)
- [Dependencies](#dependencies)
- [Future Enhancements](#future-enhancements)
- [References](#references)

## Summary

This RFC presents a solution for leveraging existing table enum types in actions.

## Introduction

[Actions](https://hasura.io/docs/latest/actions/index/) are extension to Hasura's auto-generated schema with custom
business logic using queries and mutations. Users can define [custom GraphQL types](https://hasura.io/docs/latest/actions/types/index/)
to be used within actions for output and argument input types. Actions and custom types are part of Hasura metadata.

## Motivation

Users are [expecting to reuse](https://github.com/hasura/graphql-engine/issues/5001) types from
existing Hasura generated schema, such as [table enums](https://hasura.io/docs/latest/schema/postgres/enums/#pg-create-enum-table).
Currently it is not possible. As a workaround, users are duplicating those types in custom types.
It is impairing the ease of use and efficiency for developers.
Allowing actions to reuse existing table enum types provides an opportunity to improve developer experience.

## Solution Design

We will discuss a couple of approaches to solve the problem.

### 1. Directly Use Typenames

Directly use generated type names of table enums in arguments and output type of [action definition](https://hasura.io/docs/latest/api-reference/syntax-defs/#actiondefinition).
Server infers the type info from existing table enums.

#### Action Definition

Consider having enum tables with names `colors` and `dog_breeds`. By default, Hasura generates `colors_enum` and `dog_breeds_enum`
enum types from `colors` and `dog_breeds` tables respectively. Let's define an action `add_dog` using these enum types. The action
definition may look like as follows.

```yaml
name: add_dog
definition:
  kind: synchronous
  type: mutation
  arguments:
  - name: name
    type: String!
  - name: breed
    type: dog_breeds_enum!
  - name: color
    type: colors_enum
  output_type: String!
```
Schema generated for the above action mutation may look like:
```graphql
type MutationRoot {
  add_dog(name: String!, breed: dog_breeds_enum!, color: colors_enum): String!
}
```

#### Pros and Cons

Discussing the pros and cons of the above approach below.

Pros:-
- Minimal changes required in server code to implement the feature
- No updates to existing APIs
- Clean and simple developer experience

Cons:-
- Type names generated by Hasura are subject to change by several external factors
  * [`HASURA_GRAPHQL_DEFAULT_NAMING_CONVENTION`](https://hasura.io/docs/latest/schema/postgres/naming-convention/#pg-default-naming-convention) env variable option
  * [Customization](https://hasura.io/docs/latest/schema/postgres/naming-convention/#pg-source-naming-convention) through source metadata
- The action definition can be potentially invalidated and become inconsistent when the type names generated are updated

### 2. Extend Custom Types

Solution is to extend the custom types and actions metadata to refer existing table enums.
Discussing them individually below.

#### Custom Types

Extend the custom types metadata to define reusable table enums. Introduce an optional `reuse_existing_types` field.
It'll be an object containing only `enums` field. The `enums` field value will be a list of objects, where each object
declares an enum table with a `refer_by` name to be referred in action definition.

```yaml
enums: []
scalars: []
objects: []
input_objects: []
reuse_existing_types:
  enums:
  - refer_by: color
    from_table:
      source: default
      table:
        schema: public
        name: colors
  - refer_by: dog_breed
    from_table:
      source: default
      table:
        schema: public
        name: dog_breeds
```
**What is `refer_by`?**

The `refer_by` is a unique name that is used by actions to refer the reusable types in the their definitions.
All reusable types tracked in custom types should be associated with a `refer_by` name. It acts as a placeholder
for the generated type name of reusable table enums in [action definition](#action-definition).

#### Action Definition

Arguments and output type in [action definition](https://hasura.io/docs/latest/api-reference/syntax-defs/#actiondefinition) currently
accepts string value indicating the name of the custom types. Extend the JSON syntax to optionally accept object with
`reuse` field whose value will be a [type reference](https://spec.graphql.org/June2018/#sec-Type-References) string with
`refer_by` name as a placeholder for the generated type name of table enum.

Example: `<refer_by_name>!` for non-nullable enum type and `[<refer_by_name>]` for array of enum types.

```yaml
name: add_dog
definition:
  kind: synchronous
  type: mutation
  arguments:
  - name: name
    type: String!
  - name: breed
    type:
      reuse: dog_breed!
  - name: color
    type:
      reuse: color
  output_type: String!
```
In the final schema, Hasura replaces the `refer_by` name of reused enum types with corresponding generated table enum type name.
Schema for the above action definition may look like:
```graphql
type MutationRoot {
  add_dog(name: String!, breed: dog_breeds_enum!, color: colors_enum): String!
}
```
Where `dogs_breed_enum` is generated type name for `dogs_breed` enum table and likewise `colors_enum` is for `colors` enum table.

#### Pros and Cons

Discussing the pros and cons of the above approach below.

Pros:-
- Tackles the [approach 1](#1-directly-use-type-names) [con](#pros-and-cons)
  * As using generated type names is not in the picture, there's no chance of invalidating an action definition
- Hasura does the lifting of replacing the `refer_by` with appropriate generated table enum type name

Cons:-
- Need significant changes in server code to accommodate updated custom types and action definition metadata
- Developer experience of using this feature is not seamless:
  * User has to update custom types by adding reusable table enums with referrable `refer_by` name
  * Using table enums in action definitions is achieved by `reuse` field referring to the table enum's `refer_by`

### 3. Extending Custom Types and Using Typenames

Extend custom types (as outlined in approach 2):

```
reuse_existing_types:
  enums:
  -  from_table:
      source: default
      table:
        schema: public
        name: colors

```

Note that there is no `refer_by` here (as required in approach 2).

Now what the above does is that it explicitly populates `custom types` with the full definitions of the types reused.

So if we list `custom types` it will look like the below:

```
input Login {
  username: String
  password: String
}

enum colors_enum = Red | Green | Blue

```

1. `input Login` is a type defined explicitly defined by the user.
2. `colors_enum` is a type explicitly included from the `reuse_existing_types` metadata.

Now, we can create an action like so:

```
name: add_dog
definition:
  kind: synchronous
  type: mutation
  arguments:
  - name: name
    type: String!
  - name: color
    type: colors_enum
  output_type: String!
  ```

This combines the best of approach 1 and approach 2:

1. You do not have auto-generated type names referenced in the metadata like in approach 1 (which is fundamentally a flawed architecture)
2. You do not introduce lots of new metadata concepts like in approach 2.

We will still have one disadvantage from approach 1:

> The action definition can be potentially invalidated and become inconsistent when the type names generated are updated

But, maybe we can do cascading updates in the future or atleast throw a metadata dependency warning since we know exactly what types are reused.

#### Additional explanation

The difference between approach 1 and this is quite subtle.

Yes, we are not directly using the auto-generated types. We are indirectly using them via "reuse_existing_types" metadata which duplicates those types in custom_types.

But why even? Because this way we don't need to know the source of the type and track it for dependency management. We don't have that infra and it's possibly impossible to track the "source" of a type anyway - what if the same type comes from database as well as remote schema? With this approach, we will know when a table has changed so we can reload the custom types, which can then mark the Action either consistent or inconsistent (and block it if required). It keeps Actions as an independent entity with no directional coupling with databases e.g. like schema cache must build the database types before processing Actions and so on.

## Dependencies

Adding a table enum in custom types creates the dependency of the custom types and actions on the table.
Server will track this dependency in background and raise exception when the table is being dropped without setting cascade option.
When cascade option is enabled, dropping of table will result in removing of the enum reference in `reuse_existing_types` and
dropping of the action in metadata.

## Future Enhancements

Extend the solution to accept object and (insert) input types generated from tables.

## References

- [Feature request](https://github.com/hasura/graphql-engine/issues/5001) to reuse existing types in actions
- [Feature request](https://github.com/hasura/graphql-engine/issues/4513) to reuse enum types in actions
