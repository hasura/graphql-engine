/// This module is for generating schema in SDL (Schema Definition Language) format.
/// An example of schema in SDL format is:
/// ```graphql
/// schema {
///   query: Query
///   mutation: Mutation
///   subscription: Subscription
/// }
///
/// type Query {
///   allPersons(last: Int): [Person!]!
///   allPosts(last: Int): [Post!]!
/// }
///
/// type Mutation {
///   createPerson(name: String!, age: Int!): Person!
///   updatePerson(id: ID!, name: String!, age: Int!): Person!
///   deletePerson(id: ID!): Person!
/// }
///
/// type Subscription {
///   newPerson: Person!
/// }
///
/// type Person {
///   id: ID!
///   name: String!
///   age: Int!
///   posts: [Post!]!
/// }
///
/// type Post {
///   title: String!
///   author: Person!
/// }
/// ```
///
/// The schema can generated by calling `generate_sdl` method on the `Schema` struct.
///
use std::collections::BTreeMap;

use crate::{
    ast::common as ast,
    schema::{
        DeprecationStatus, Directive, Enum, Field, InputObject, Interface, Namespaced, Object,
        Scalar, Schema, SchemaContext, TypeInfo, Union,
    },
};

impl<S: SchemaContext> Object<S> {
    /// Generate SDL for the object type. An example of object type in SDL format is:
    /// ```graphql
    /// """Person Object Type"""
    /// type Person @key(fields: "id") {
    ///   id: ID!
    ///   name: String!
    ///   age: Int!
    ///   posts: [Post!]!
    /// }
    /// ```
    /// Please note that, if there are no fields in the object type, it will return `None`.
    fn generate_sdl(&self, namespace: &S::Namespace) -> Option<String> {
        let fields_sdl = generate_fields_sdl(&self.fields, namespace);
        if fields_sdl.is_empty() {
            None
        } else {
            Some(with_description(
                &self.description,
                format!(
                    "type {}{} {}",
                    &self.name,
                    generate_directives_sdl(&self.directives, None),
                    in_curly_braces(fields_sdl)
                ),
            ))
        }
    }
}

impl<S: SchemaContext> InputObject<S> {
    /// Generate SDL for the input object type. An example of input object type in SDL format is:
    /// ```graphql
    /// """Insert Person Input Object Type"""
    /// input InsertPersonInput @deprecated(reason: "Use `PersonInput` instead") {
    ///   name: String!
    ///   age: Int!
    /// }
    /// ```
    /// Please note that, if there are no fields in the input object type, it will return `None`.
    fn generate_sdl(&self, namespace: &S::Namespace) -> Option<String> {
        let fields_sdl = self
            .fields
            .iter()
            .filter_map(|(field_name, field)| {
                field.get(namespace).map(|(data, _)| {
                    with_description(
                        &data.description,
                        format_field_with_type(
                            field_name,
                            &data.field_type,
                            Some(&data.deprecation_status),
                        ),
                    )
                })
            })
            .collect::<Vec<String>>();
        if fields_sdl.is_empty() {
            None
        } else {
            Some(with_description(
                &self.description,
                format!(
                    "input {}{} {}",
                    &self.name,
                    generate_directives_sdl(&self.directives, None),
                    in_curly_braces(fields_sdl)
                ),
            ))
        }
    }
}

impl Scalar {
    /// Generate SDL for the scalar type. An example of scalar type in SDL format is:
    /// ```graphql
    /// """Custom Scalar Type for Date"""
    /// scalar Date
    /// ```
    fn generate_sdl(&self) -> String {
        with_description(
            &self.description,
            format!(
                "scalar {}{}",
                &self.name,
                generate_directives_sdl(&self.directives, None)
            ),
        )
    }
}

impl<S: SchemaContext> Enum<S> {
    /// Generate SDL for the enum type. An example of enum type in SDL format is:
    /// ```graphql
    /// """Custom Enum Type for application status"""
    /// enum ApplicationStatus {
    ///   DRAFT @deprecated(reason: "Use `PENDING` instead")
    ///   PENDING
    ///   APPROVED
    ///   REJECTED
    /// }
    /// ```
    /// Please note that, if there are no values in the enum type, it will return `None`.
    fn generate_sdl(&self, namespace: &S::Namespace) -> Option<String> {
        let fields_sdl = self
            .values
            .values()
            .filter_map(|enum_val| {
                enum_val.get(namespace).map(|(data, _)| {
                    with_description(
                        &data.description,
                        format!(
                            "{} {}",
                            data.value,
                            generate_directives_sdl(&[], Some(&data.deprecation_status))
                        ),
                    )
                })
            })
            .collect::<Vec<String>>();
        if fields_sdl.is_empty() {
            None
        } else {
            Some(with_description(
                &self.description,
                format!(
                    "enum {}{} {}",
                    self.name,
                    generate_directives_sdl(&self.directives, None),
                    in_curly_braces(fields_sdl)
                ),
            ))
        }
    }
}

impl<S: SchemaContext> Union<S> {
    /// Generate SDL for the union type. An example of union type in SDL format is:
    /// ```graphql
    /// """Union Type for search results"""
    /// union SearchResult = Human | Droid | Starship
    /// ```
    /// Please note that, if there are no members in the union type, it will return `None`.
    fn generate_sdl(&self, namespace: &S::Namespace) -> Option<String> {
        let members_sdl = &self
            .members
            .iter()
            .filter_map(|(union_member, member_value)| {
                if member_value.get(namespace).is_some() {
                    Some(union_member.to_string())
                } else {
                    None
                }
            })
            .collect::<Vec<String>>();
        if members_sdl.is_empty() {
            None
        } else {
            Some(with_description(
                &self.description,
                format!(
                    "union {}{} = {}",
                    self.name,
                    generate_directives_sdl(&self.directives, None),
                    members_sdl.join(" | ")
                ),
            ))
        }
    }
}

impl<S: SchemaContext> Interface<S> {
    /// Generate SDL for the interface type. An example of interface type in SDL format is:
    /// ```graphql
    /// """Interface for Node"""
    /// interface Node {
    ///   id: ID!
    /// }
    /// ```
    /// Please note that, if there are no fields in the interface type, it will return `None`.
    fn generate_sdl(&self, namespace: &S::Namespace) -> Option<String> {
        let fields_sdl = generate_fields_sdl(&self.fields, namespace);
        if fields_sdl.is_empty() {
            None
        } else {
            Some(with_description(
                &self.description,
                format!(
                    "interface {}{} {}",
                    &self.name,
                    generate_directives_sdl(&self.directives, None),
                    in_curly_braces(fields_sdl)
                ),
            ))
        }
    }
}

impl<S: SchemaContext> TypeInfo<S> {
    fn generate_sdl(&self, namespace: &S::Namespace) -> Option<String> {
        match self {
            TypeInfo::Scalar(scalar) => Some(scalar.generate_sdl()),
            TypeInfo::Enum(enm) => enm.generate_sdl(namespace),
            TypeInfo::Object(object) => object.generate_sdl(namespace),
            TypeInfo::Interface(interface) => interface.generate_sdl(namespace),
            TypeInfo::Union(union) => union.generate_sdl(namespace),
            TypeInfo::InputObject(input_object) => input_object.generate_sdl(namespace),
        }
    }
}

impl<S: SchemaContext> Schema<S> {
    pub fn generate_sdl(&self, namespace: &S::Namespace) -> String {
        let schema_sdl = get_schema_sdl(self, namespace);
        self.types
            .iter()
            .fold(schema_sdl, |mut acc, (type_name, type_info)| {
                // Ignore schema related types
                if !type_name.as_str().starts_with("__") {
                    if let Some(type_sdl) = type_info.generate_sdl(namespace) {
                        acc.push_str("\n\n");
                        acc.push_str(&type_sdl);
                    }
                };
                acc
            })
    }
}

/// Generate SDL for the schema. An example of schema in SDL format is:
/// ```graphql
/// schema {
///   query: Query
///   mutation: Mutation
///   subscription: Subscription
/// }
/// ```
///
/// Please note that query type will always be there in the schema.
///
/// If there is no mutation type, it will not include mutation in the schema. Also, if there is no
/// mutation field in the mutation type, it will not include mutation in the schema.
///
/// If there is no subscription type, it will not include subscription in the schema.
fn get_schema_sdl<S: SchemaContext>(schema: &Schema<S>, namespace: &S::Namespace) -> String {
    let query_field = format!("query: {} ", &schema.query_type);
    let mutation_field = schema.mutation_type.as_ref().and_then(|t| {
        schema.types.get(t).and_then(|type_info| match type_info {
            TypeInfo::Object(object) => {
                // If there is only __typename in the mutation fields, ignore the mutation altogether
                if object
                    .fields
                    .iter()
                    .all(|(k, v)| (k.as_str() == "__typename") || (v.get(namespace).is_none()))
                {
                    None
                } else {
                    Some(format!("mutation: {} ", t))
                }
            }
            _ => None,
        })
    });
    let subscription_field = schema
        .subscription_type
        .as_ref()
        .map(|t| format!("subscription: {} ", t));
    format!(
        "schema {}",
        in_curly_braces(
            vec![Some(query_field), mutation_field, subscription_field]
                .into_iter()
                .flatten()
                .collect()
        )
    )
}

/// Generate SDL for description. Descriptions are just wrapped in 3 double quotes.
fn generate_description_sdl(description: &Option<String>) -> String {
    description
        .as_ref()
        .map(|d| format!("\"\"\"{}\"\"\"", d))
        .unwrap_or_default()
}

/// Generate SDL for directives. An example of directives in SDL format is:
/// ```graphql
/// @deprecated(reason: "Use `PENDING` instead")
/// ```
fn generate_directives_sdl(
    directives: &[Directive],
    deprecation_status: Option<&DeprecationStatus>,
) -> String {
    let other_directives = directives
        .iter()
        .map(|d| {
            let args = d
                .arguments
                .iter()
                .map(|(k, v)| format!("{}: {}", k, v.to_json()))
                .collect::<Vec<String>>()
                .join(", ");
            format!(
                "@{}{}",
                d.name,
                if args.is_empty() {
                    String::default()
                } else {
                    format!("({})", args)
                }
            )
        })
        .collect::<Vec<String>>()
        .join(" ");
    match deprecation_status {
        Some(DeprecationStatus::Deprecated { reason }) => {
            let reason_arg = reason
                .as_ref()
                .map(|r| format!("(reason: {})", r))
                .unwrap_or_default();
            format!("@deprecated{} {}", reason_arg, other_directives)
        }
        _ => other_directives,
    }
}

/// Generate SDL for fields. This will not include schema related fields (fields starting with __).
fn generate_fields_sdl<S: SchemaContext>(
    fields: &BTreeMap<ast::Name, Namespaced<S, Field<S>>>,
    namespace: &S::Namespace,
) -> Vec<String> {
    let mut fields_sdl = Vec::new();
    for (field_name, field) in fields {
        // Ignore schema related fields
        if !field_name.as_str().starts_with("__") {
            if let Some((data, _)) = field.get(namespace) {
                fields_sdl.push(with_description(
                    &data.description,
                    format_field_with_type(
                        field_name,
                        &data.field_type,
                        Some(&data.deprecation_status),
                    ),
                ));
            }
        }
    }
    fields_sdl
}

fn format_field_with_type(
    field_name: &ast::Name,
    field_type: &ast::TypeContainer<ast::TypeName>,
    deprecation_status: Option<&DeprecationStatus>,
) -> String {
    let field_sdl = format!("{}: {}", field_name, field_type);
    match deprecation_status {
        Some(deprecation_status) => format!(
            "{} {}",
            field_sdl,
            generate_directives_sdl(&[], Some(deprecation_status))
        ),
        _ => field_sdl,
    }
}

fn with_description(description: &Option<String>, sdl: String) -> String {
    if description.is_some() {
        format!("{}\n{}", generate_description_sdl(description), sdl)
    } else {
        sdl
    }
}

fn in_curly_braces(strings: Vec<String>) -> String {
    format!(
        "{{\n{}\n}}",
        strings
            .into_iter()
            .map(|s| with_indent(&s))
            .collect::<Vec<String>>()
            .join("\n")
    )
}

fn with_indent(sdl: &str) -> String {
    sdl.lines()
        .map(|l| format!("  {}", l))
        .collect::<Vec<String>>()
        .join("\n")
}
