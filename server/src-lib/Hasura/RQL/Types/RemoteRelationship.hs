{-# LANGUAGE DisambiguateRecordFields #-}
{-# LANGUAGE NamedFieldPuns           #-}
{-# LANGUAGE RecordWildCards          #-}

module Hasura.RQL.Types.RemoteRelationship
  ( RemoteRelationship(..)
  , RemoteField(..)
  , RemoteRelationshipName(..)
  , FieldCall(..)
  , RemoteArguments(..)
  )
where

import           Data.Aeson.Casing
import           Data.Aeson.TH
import           Hasura.Prelude
import           Hasura.RQL.Instances          ()
import           Hasura.SQL.Types

import           Data.Aeson                    as A
import qualified Data.Aeson.Types              as AT
import           Data.HashMap.Strict           (HashMap)
import qualified Data.HashMap.Strict           as HM
import           Data.List.NonEmpty            (NonEmpty (..))
import           Data.Scientific

import qualified Data.Text                     as T
import qualified Database.PG.Query             as Q
import           Instances.TH.Lift             ()
import qualified Language.GraphQL.Draft.Syntax as G
import           Language.Haskell.TH.Syntax    (Lift)

import qualified Hasura.GraphQL.Validate.Types as VT
import           Hasura.RQL.Types.RemoteSchema

data RemoteField =
  RemoteField
    { rfRemoteRelationship :: !RemoteRelationship
    , rfGType              :: !G.GType
    , rfParamMap           :: !(HashMap G.Name VT.InpValInfo)
    , rfTypeMap            :: !VT.TypeMap -- additional types generated by stripping join args
    }
  deriving (Show, Eq, Lift)

data RemoteRelationship =
  RemoteRelationship
    { rrName         :: RemoteRelationshipName
    , rrTable        :: QualifiedTable
    , rrRemoteSchema :: RemoteSchemaName
    , rrRemoteFields :: NonEmpty FieldCall
    }  deriving (Show, Eq, Lift)

-- Parsing GraphQL input arguments from JSON

parseObjectFieldsToGValue :: HashMap Text A.Value -> AT.Parser [G.ObjectFieldG G.Value]
parseObjectFieldsToGValue hashMap =
  traverse
    (\(key, value) -> do
       name <- parseJSON (A.String key)
       parsedValue <- parseValueAsGValue value
       pure G.ObjectFieldG {_ofName = name, _ofValue = parsedValue})
    (HM.toList hashMap)

parseValueAsGValue :: A.Value -> AT.Parser G.Value
parseValueAsGValue =
  \case
    A.Object obj ->
      fmap (G.VObject . G.ObjectValueG) (parseObjectFieldsToGValue obj)
    A.Array array ->
      fmap (G.VList . G.ListValueG . toList) (traverse parseValueAsGValue array)
    A.String text ->
      case T.uncons text of
        Just ('$', rest)
          | T.null rest -> fail "Invalid variable name."
          | otherwise -> pure (G.VVariable (G.Variable (G.Name rest)))
        _ -> pure (G.VString (G.StringValue text))
    A.Number !scientificNum ->
      pure (either G.VFloat G.VInt (floatingOrInteger scientificNum))
    A.Bool !boolean -> pure (G.VBoolean boolean)
    A.Null -> pure G.VNull

fieldsToObject :: [G.ObjectFieldG G.Value] -> A.Value
fieldsToObject =
  A.Object .
  HM.fromList .
  map (\(G.ObjectFieldG {_ofName=G.Name name, _ofValue}) -> (name, gValueToValue _ofValue))

gValueToValue :: G.Value -> A.Value
gValueToValue =
  \case
    (G.VVariable (G.Variable v)) -> toJSON ("$" <> v)
    (G.VInt i) -> toJSON i
    (G.VFloat f) -> toJSON f
    (G.VString (G.StringValue s)) -> toJSON s
    (G.VBoolean b) -> toJSON b
    G.VNull -> A.Null
    (G.VEnum s) -> toJSON s
    (G.VList (G.ListValueG list)) -> toJSON (map gValueToValue list)
    (G.VObject (G.ObjectValueG xs)) -> fieldsToObject xs

parseRemoteArguments :: A.Value -> AT.Parser RemoteArguments
parseRemoteArguments j =
  case j of
    A.Object hashMap -> fmap RemoteArguments (parseObjectFieldsToGValue hashMap)
    _                -> fail "Remote arguments should be an object of keys."


-- G.ObjectField has the right representation but may not be the best name for this type as RemoteArgument might be scalar
newtype RemoteArguments =
  RemoteArguments
    { getRemoteArguments :: [G.ObjectField]
    } deriving (Show, Eq, Lift)

instance ToJSON RemoteArguments where
  toJSON (RemoteArguments fields) = fieldsToObject fields

instance FromJSON RemoteArguments where
  parseJSON = parseRemoteArguments

data FieldCall =
  FieldCall
    { fcName      :: !G.Name
    , fcArguments :: !RemoteArguments
    }
  deriving (Show, Eq, Lift, Generic)

newtype RemoteRelationshipName
  = RemoteRelationshipName
  { unRemoteRelationshipName :: Text}
  deriving (Show, Eq, Lift, Hashable, ToJSON, ToJSONKey, FromJSON, Q.ToPrepArg, Q.FromCol)

data DeleteRemoteRelationship =
  DeleteRemoteRelationship
    { drrTable :: QualifiedTable
    , drrName  :: RemoteRelationshipName
    }  deriving (Show, Eq, Lift)

$(deriveJSON (aesonDrop 3 snakeCase){omitNothingFields=True} ''DeleteRemoteRelationship)

instance ToJSON RemoteRelationship where
  toJSON RemoteRelationship {..} =
    object
      [ "name" .= rrName
      , "table" .= rrTable
      , "remote_schema" .= rrRemoteSchema
      , "remote_field" .= remoteFieldsJson rrRemoteFields
      ]

instance FromJSON RemoteRelationship where
  parseJSON value = do
    o <- parseJSON value
    rrName <- o .: "name"
    rrTable <- o .: "table"
    rrRemoteSchema <- o .: "remote_schema"
    rrRemoteFields <- o .: "remote_field" >>= parseRemoteFields
    pure RemoteRelationship {..}

parseRemoteFields :: Value -> AT.Parser (NonEmpty FieldCall)
parseRemoteFields v =
  case v of
    Object hashmap ->
      case HM.toList hashmap of
        [(fieldNameText, callValue)] -> do
          fieldName <- parseJSON (A.String fieldNameText)
          callObject <- parseJSON callValue
          arguments <- callObject .: "arguments"
          maybeSubField <- callObject .:? "field"
          subFields <-
            case maybeSubField of
              Nothing -> pure []
              Just fieldValue -> do
                remoteFields <- parseRemoteFields fieldValue
                pure (toList remoteFields)
          pure
            (FieldCall {fcName = fieldName, fcArguments = arguments} :|
             subFields)
        _ -> fail "Only one field allowed, not multiple."
    _ ->
      fail
        "Remote fields should be an object that starts\
              \ with the name of a field e.g. person: ..."

remoteFieldsJson :: NonEmpty FieldCall -> Value
remoteFieldsJson (field :| subfields) =
  object
    [ nameText (fcName field) .=
      object
        (concat
           [ ["arguments" .= fcArguments field]
           , case subfields of
               [] -> []
               subfield:subsubfields ->
                 ["field" .= remoteFieldsJson (subfield :| subsubfields)]
           ])
    ]
  where
    nameText (G.Name t) = t
