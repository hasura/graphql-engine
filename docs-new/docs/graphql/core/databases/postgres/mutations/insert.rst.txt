<div class="meta"
description="Insert an object into Postgres using a mutation"
keywords="hasura, docs, postgres, mutation, insert">

</div>

# Postgres: Insert mutation

<div class="contents" backlinks="none" depth="1" local="">

Table of contents

</div>

## Auto-generated insert mutation schema

**For example**, the auto-generated schema for the insert mutation field
for a table `article` looks like the following:

```graphql
insert_article (
  objects: [article_insert_input!]!
  on_conflict: article_on_conflict
): article_mutation_response

# response of any mutation on the table "article"
type article_mutation_response {
  # number of affected rows by the mutation
  affected_rows: Int!
  # data of the affected rows by the mutation
  returning: [article!]!
}

# single object insert (supported from v1.2.0)
insert_article_one (
  object: article_insert_input!
  on_conflict: article_on_conflict
): article
```

As you can see from the schema:

-   `objects` argument is necessary and you can pass multiple `objects`
    to the mutation.
-   You can pass an `on_conflict` argument to convert the mutation to an
    `upsert mutation <upsert>`.
-   You can return the number of affected rows and the affected objects
    (with nested objects) in the response.
-   You can use the single object insert to get the inserted object
    directly as the mutation response.

See the `insert mutation API reference <insert_upsert_syntax>` for the
full specifications.

<div class="note">

<div class="title">

Note

</div>

If a table is not in the `public` Postgres schema, the insert mutation
field will be of the format `insert_<schema_name>_<table_name>`.

</div>

## Insert a single object

**Example:** Insert a new `article` object and return the inserted
article object in the response:

<div class="graphiql" view_only=""
query="mutation insert_single_article {
  insert_article_one(
    object: {
      title: &quot;Article 1&quot;,
      content: &quot;Sample article content&quot;,
      author_id: 3
    }
  ) {
    id
    title
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_article_one&quot;: {
      &quot;id&quot;: 21,
      &quot;title&quot;: &quot;Article 1&quot;
    }
  }
}">

</div>

Using variables:

<div class="graphiql" view_only=""
query="mutation insert_single_article($object: article_insert_input! ) {
  insert_article_one(object: $object) {
    id
    title
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_article_one&quot;: {
      &quot;id&quot;: 21,
      &quot;title&quot;: &quot;Article 1&quot;
    }
  }
}
:variables:
{
  &quot;object&quot;: {
    &quot;title&quot;: &quot;Article 1&quot;,
    &quot;content&quot;: &quot;Sample article content&quot;,
    &quot;author_id&quot;: 3
  }
}">

</div>

<div class="note">

<div class="title">

Note

</div>

`insert_<object>_one` will **only** be available if you have select
permissions on the table, as it returns the inserted row.

</div>

<div class="admonition">

Supported from

The `insert_<object>_one` mutation is supported in versions `v1.2.0` and
above.

</div>

## Insert multiple objects of the same type in the same mutation

**Example:** Insert 2 new `article` objects and return both the article
objects in the response:

<div class="graphiql" view_only=""
query="mutation insert_multiple_articles {
  insert_article(
    objects: [
      {
        title: &quot;Article 2&quot;,
        content: &quot;Sample article content&quot;,
        author_id: 4
      },
      {
        title: &quot;Article 3&quot;,
        content: &quot;Sample article content&quot;,
        author_id: 5
      }
    ]
  ) {
    returning {
      id
      title
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_article&quot;: {
      &quot;affected_rows&quot;: 2,
      &quot;returning&quot;: [
        {
          &quot;id&quot;: 22,
          &quot;title&quot;: &quot;Article 2&quot;
        },
        {
          &quot;id&quot;: 23,
          &quot;title&quot;: &quot;Article 3&quot;
        }
      ]
    }
  }
}">

</div>

Using variables:

<div class="graphiql" view_only=""
query="mutation insert_multiple_articles($objects: [article_insert_input!]! ) {
  insert_article(objects: $objects) {
    returning {
      id
      title
    }
  }
}
:response:
{
    &quot;data&quot;: {
      &quot;insert_article&quot;: {
        &quot;affected_rows&quot;: 2,
        &quot;returning&quot;: [
          {
            &quot;id&quot;: 22,
            &quot;title&quot;: &quot;Article 2&quot;
          },
          {
            &quot;id&quot;: 23,
            &quot;title&quot;: &quot;Article 3&quot;
          }
        ]
      }
    }
  }
:variables:
{
  &quot;objects&quot;: [
    {
      &quot;title&quot;: &quot;Article 2&quot;,
      &quot;content&quot;: &quot;Sample article content&quot;,
      &quot;author_id&quot;: 4
    },
    {
      &quot;title&quot;: &quot;Article 3&quot;,
      &quot;content&quot;: &quot;Sample article content&quot;,
      &quot;author_id&quot;: 5
    }
  ]
}">

</div>

## Insert an object and get a nested object in response

**Example:** Insert a new `article` object and return the inserted
article object with its author in the response:

<div class="graphiql" view_only="" query="mutation insert_article {
  insert_article(
    objects: [
      {
        title: &quot;Article 1&quot;,
        content: &quot;Sample article content&quot;,
        author_id: 3
      }
    ]
  ) {
    returning {
      id
      title
      author {
        id
        name
      }
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_article&quot;: {
      &quot;affected_rows&quot;: 1,
      &quot;returning&quot;: [
        {
          &quot;id&quot;: 21,
          &quot;title&quot;: &quot;Article 1&quot;,
          &quot;author&quot;: {
            &quot;id&quot;: 3,
            &quot;name&quot;: &quot;Sidney&quot;
          }
        }
      ]
    }
  }
}">

</div>

## Insert an object along with its related objects through relationships

### One-to-one / One-to-many relationships

Let's say an `author` has an `object relationship` called `address` to
the `addresses` table and an `array relationship` called `articles` to
the `articles` table.

**Example:** Insert an `author` along with their `address` and a few
`articles`.

<div class="graphiql" view_only="" query="mutation insertData {
  insert_authors
    (objects: [
      {
        name: &quot;John&quot;,
        address: {
          data: {
            location: &quot;San Francisco&quot;
          }
        },
        articles: {
          data: [
            {
              title: &quot;GraphQL Guide&quot;,
              content: &quot;Let's see what we can do with GraphQL&quot;
            },
            {
              title: &quot;Authentication Guide&quot;,
              content: &quot;Let's look at best practices for authentication&quot;
            }
          ]
        }
      }
    ]
  ) {
    affected_rows
    returning {
      id
      name
      address_id
      address {
        id
        location
      }
      articles {
        id
        title
        author_id
      }
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_authors&quot;: {
      &quot;affected_rows&quot;: 4,
      &quot;returning&quot;: [
        {
          &quot;id&quot;: 26,
          &quot;name&quot;: &quot;John&quot;,
          &quot;address_id&quot;: 27,
          &quot;address&quot;: {
            &quot;id&quot;: 27,
            &quot;location&quot;: &quot;San Francisco&quot;
          },            
          &quot;articles&quot;: [
            {
              &quot;id&quot;: 28,
              &quot;title&quot;: &quot;GraphQL Guide&quot;,
              &quot;author_id&quot;: 26
            },
            {
              &quot;id&quot;: 29,
              &quot;title&quot;: &quot;Authentication Guide&quot;,
              &quot;author_id&quot;: 26,
            }
          ]
        }
      ]
    }
  }
}">

</div>

**How it works**

A nested insert mutation is processed as follows:

1.  The object relationship objects are inserted first, i.e. in this
    case, the `address` is inserted and its `id` is collected in this
    step.

2.  The parent object is inserted next. i.e. in this case, the `author`
    is now inserted with the `address_id` being set to the `id` of the
    address that was inserted. Because of this, it is not allowed to
    pass `address_id` in the author object if you are also providing
    data for the address relationship.

    The `id` of the author is collected in this step.

3.  The array relationship objects are inserted at the end. i.e. in this
    case, the `articles` are now inserted with their `author_id` set to
    the author's `id` collected in the step 2. Hence, it's not possible
    to specify `author_id` in the data for the articles relationship.

<div class="note">

<div class="title">

Note

</div>

The order of object insertion can be controlled using the
`insertion_order <ObjRelUsingManualMapping>` option while creating a
manual relationship. This is necessary to ensure
`nested inserts <one-to-one-insert>` in one-to-one relationships are
possible using either side as the parent which would otherwise error out
with a `Not-NULL violation` error in one of the cases.

</div>

### Many-to-many relationships

Let's say the `articles` has a
`many-to-many relationship <many_to_many_modelling>` with the `tags`
table via a bridge table `article_tags`.

**Example:** Insert an `article` along with a few `tags`.

<div class="graphiql" view_only="" query="mutation insertArticle {
  insert_articles(objects: [
    {
      title: &quot;How to make fajitas&quot;,
      content: &quot;Guide on making the best fajitas in the world&quot;,
      author_id: 3,
      article_tags: {
        data: [
          {
            tag: {
              data: {
                label: &quot;Recipes&quot;
              },
              on_conflict: {
                constraint: tags_label_key,
                update_columns: [label]
              }
            }
          },
          {
            tag: {
              data: {
                label: &quot;Cooking&quot;
              },
              on_conflict: {
                constraint: tags_label_key,
                update_columns: [label]
              }
            }
          }  
        ]
      }
    }
  ]) {
    affected_rows
    returning {
      id
      title
      content
      author_id
      article_tags {
        tag {
          label
        }
      }
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_articles&quot;: {
      &quot;affected_rows&quot;: 5,
      &quot;returning&quot;: [
        {
          &quot;author_id&quot;: 3,
          &quot;article_tags&quot;: [
            {
              &quot;tag&quot;: {
                &quot;label&quot;: &quot;Recipes&quot;
              }
            },
            {
              &quot;tag&quot;: {
                &quot;label&quot;: &quot;Cooking&quot;
              }
            }
          ],
          &quot;content&quot;: &quot;Guide on making the best fajitas in the world&quot;,
          &quot;id&quot;: 34,
          &quot;title&quot;: &quot;How to make fajitas&quot;
        }
      ]
    }
  }
}">

</div>

**How it works**

1.  The parent object (from the perspective of `article`) is inserted
    first i.e. the `article` is inserted.

    The `id` of the article is collected in this step.

2.  The array relationship objects (from the perspective of `article`)
    are inserted next i.e. the `article_tags` are inserted.

    1.  The object relationship objects (from the perspective of
        `article_tags`) are inserted now i.e. the `tags` are now
        inserted.

        The `ids` of the tags are collected in this step.

    2.  The parent object (from the perspective of `article_tags`) is
        inserted at the end i.e. the `article_tags` are now inserted
        with their `article_id` set to the article's `id` collected in
        step 1. The `tag_id` is set to the tag's `id` collected in step
        2.1. Hence, itâ€™s not possible to specify `article_id` and
        `tag_id` in the data for the <span
        class="title-ref">article_tags</span> relationship.

**on_conflict**

`on_conflict` can be passed as an argument in a nested insert statement.
In our example, we say that if the unique key (`label`) already exists
for a tag, we update the `label` of this respective tag (see
`nested upsert caveats <nested-upsert-caveats>`).

## Insert an object with a JSONB field

**Example:** Insert a new `author` object with a JSONB `address` field:

<div class="graphiql" view_only=""
query="mutation insert_author($address: jsonb) {
  insert_author (
    objects: [
      {
        name: &quot;Ash&quot;,
        address: $address
      }
    ]
  ) {
    affected_rows
    returning {
      id
      name
      address
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_author&quot;: {
      &quot;affected_rows&quot;: 1,
      &quot;returning&quot;: [
        {
          &quot;id&quot;: 1,
          &quot;name&quot;: &quot;Ash&quot;,
          &quot;address&quot;: {
            &quot;city&quot;: &quot;Bengaluru&quot;,
            &quot;phone&quot;: &quot;9090909090&quot;,
            &quot;state&quot;: &quot;Karnataka&quot;,
            &quot;pincode&quot;: 560095,
            &quot;street_address&quot;: &quot;161, 19th Main Road, Koramangala 6th Block&quot;
          }
        }
      ]
    }
  }
}
:variables:
{
  &quot;address&quot;: {
    &quot;street_address&quot;: &quot;161, 19th Main Road, Koramangala 6th Block&quot;,
    &quot;city&quot;: &quot;Bengaluru&quot;,
    &quot;phone&quot;: &quot;9090909090&quot;,
    &quot;state&quot;: &quot;Karnataka&quot;,
    &quot;pincode&quot;: 560095
  }
}">

</div>

## Insert an object with an ARRAY field

To insert fields of array types, you currently have to pass them as a
[Postgres array
literal](https://www.postgresql.org/docs/current/arrays.html#ARRAYS-INPUT).

**Example:** Insert a new `author` with a text array `emails` field:

<div class="graphiql" view_only="" query="mutation insert_author {
  insert_author (
    objects: [
      {
        name: &quot;Ash&quot;,
        emails: &quot;{ash@ash.com, ash123@ash.com}&quot;
      }
    ]
  ) {
    affected_rows
    returning {
      id
      name
      emails
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_author&quot;: {
      &quot;affected_rows&quot;: 1,
      &quot;returning&quot;: [
        {
          &quot;id&quot;: 1,
          &quot;name&quot;: &quot;Ash&quot;,
          &quot;emails&quot;: [&quot;ash@ash.com&quot;, &quot;ash123@ash.com&quot;]
        }
      ]
    }
  }
}">

</div>

Using variables:

<div class="graphiql" view_only=""
query="mutation insert_author($emails: _text) {
  insert_author (
    objects: [
      {
        name: &quot;Ash&quot;,
        emails: $emails
      }
    ]
  ) {
    affected_rows
    returning {
      id
      name
      emails
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_author&quot;: {
      &quot;affected_rows&quot;: 1,
      &quot;returning&quot;: [
        {
          &quot;id&quot;: 1,
          &quot;name&quot;: &quot;Ash&quot;,
          &quot;emails&quot;: [&quot;ash@ash.com&quot;, &quot;ash123@ash.com&quot;]
        }
      ]
    }
  }
}
:variables:
{
  &quot;emails&quot;: &quot;{ash@ash.com, ash123@ash.com}&quot;
}">

</div>

## Set a field to its default value during insert

To set a field to its `default` value, just omit it from the input
object, irrespective of the
`default value configuration <postgres_defaults>` i.e. via Postgres
defaults or using column presets.

**Example:** If the default value of `id` is set to auto-incrementing
integer, there's no need to pass the `id` field to the input object:

<div class="graphiql" view_only=""
query="mutation insert_article_with_def_id {
  insert_article(
    objects: [
      {
        title: &quot;Article 1&quot;,
        content: &quot;Sample article content&quot;,
        author_id: 3
      }
    ]
  ) {
    returning {
      id
      title
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_article&quot;: {
      &quot;affected_rows&quot;: 1,
      &quot;returning&quot;: [
        {
          &quot;id&quot;: 21,
          &quot;title&quot;: &quot;Article 1&quot;
        }
      ]
    }
  }
}">

</div>

## Set a field to NULL during insert

If a field is `nullable` in the database, to set its value to `null`,
either pass its value as `null` or just omit it from the input object.

**Example:** If `age` is a nullable field, to set it to `null`, either
don't pass the age field to the input object or pass it as `null`:

<div class="graphiql" view_only=""
query="mutation insert_author_with_null_age {
  insert_author(
    objects: [
      {
        name: &quot;Jeff&quot;
      }
    ]
  ) {
    returning {
      id
      name
      age
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_author&quot;: {
      &quot;returning&quot;: [
        {
            &quot;id&quot;: 11,
            &quot;name&quot;: &quot;Jeff&quot;,
            &quot;age&quot;: null
        }
      ]
    }
  }
}">

</div>

OR

<div class="graphiql" view_only=""
query="mutation insert_author_with_null_age {
  insert_author(
    objects: [
      {
        name: &quot;Jeff&quot;,
        age: null
      }
    ]
  ) {
    returning {
      id
      name
      age
    }
  }
}
:response:
{
  &quot;data&quot;: {
    &quot;insert_author&quot;: {
      &quot;returning&quot;: [
        {
            &quot;id&quot;: 11,
            &quot;name&quot;: &quot;Jeff&quot;,
            &quot;age&quot;: null
        }
      ]
    }
  }
}">

</div>
