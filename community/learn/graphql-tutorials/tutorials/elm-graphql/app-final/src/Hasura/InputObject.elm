-- Do not manually edit this file, it was auto-generated by dillonkearns/elm-graphql
-- https://github.com/dillonkearns/elm-graphql


module Hasura.InputObject exposing (Boolean_comparison_exp, Boolean_comparison_expOptionalFields, Integer_comparison_exp, Integer_comparison_expOptionalFields, Online_users_bool_exp(..), Online_users_bool_expOptionalFields, Online_users_bool_expRaw, Online_users_order_by, Online_users_order_byOptionalFields, Text_comparison_exp, Text_comparison_expOptionalFields, Timestamptz_comparison_exp, Timestamptz_comparison_expOptionalFields, Todos_arr_rel_insert_input, Todos_arr_rel_insert_inputOptionalFields, Todos_arr_rel_insert_inputRequiredFields, Todos_bool_exp(..), Todos_bool_expOptionalFields, Todos_bool_expRaw, Todos_insert_input, Todos_insert_inputOptionalFields, Todos_obj_rel_insert_input, Todos_obj_rel_insert_inputOptionalFields, Todos_obj_rel_insert_inputRequiredFields, Todos_on_conflict, Todos_on_conflictRequiredFields, Todos_order_by, Todos_order_byOptionalFields, Todos_set_input, Todos_set_inputOptionalFields, Users_bool_exp(..), Users_bool_expOptionalFields, Users_bool_expRaw, Users_on_conflict, Users_on_conflictRequiredFields, Users_order_by, Users_order_byOptionalFields, Users_set_input, Users_set_inputOptionalFields, buildBoolean_comparison_exp, buildInteger_comparison_exp, buildOnline_users_bool_exp, buildOnline_users_order_by, buildText_comparison_exp, buildTimestamptz_comparison_exp, buildTodos_arr_rel_insert_input, buildTodos_bool_exp, buildTodos_insert_input, buildTodos_obj_rel_insert_input, buildTodos_on_conflict, buildTodos_order_by, buildTodos_set_input, buildUsers_bool_exp, buildUsers_on_conflict, buildUsers_order_by, buildUsers_set_input, encodeBoolean_comparison_exp, encodeInteger_comparison_exp, encodeOnline_users_bool_exp, encodeOnline_users_order_by, encodeText_comparison_exp, encodeTimestamptz_comparison_exp, encodeTodos_arr_rel_insert_input, encodeTodos_bool_exp, encodeTodos_insert_input, encodeTodos_obj_rel_insert_input, encodeTodos_on_conflict, encodeTodos_order_by, encodeTodos_set_input, encodeUsers_bool_exp, encodeUsers_on_conflict, encodeUsers_order_by, encodeUsers_set_input)

import Graphql.Internal.Builder.Argument as Argument exposing (Argument)
import Graphql.Internal.Builder.Object as Object
import Graphql.Internal.Encode as Encode exposing (Value)
import Graphql.OptionalArgument exposing (OptionalArgument(..))
import Graphql.SelectionSet exposing (SelectionSet)
import Hasura.Enum.Order_by
import Hasura.Enum.Todos_constraint
import Hasura.Enum.Todos_update_column
import Hasura.Enum.Users_constraint
import Hasura.Enum.Users_update_column
import Hasura.Interface
import Hasura.Object
import Hasura.Scalar
import Hasura.ScalarCodecs
import Hasura.Union
import Json.Decode as Decode


buildBoolean_comparison_exp : (Boolean_comparison_expOptionalFields -> Boolean_comparison_expOptionalFields) -> Boolean_comparison_exp
buildBoolean_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Boolean_comparison_expOptionalFields =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List (Maybe Bool))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List (Maybe Bool))
    }


{-| Type for the Boolean\_comparison\_exp input object.
-}
type alias Boolean_comparison_exp =
    { eq_ : OptionalArgument Bool
    , gt_ : OptionalArgument Bool
    , gte_ : OptionalArgument Bool
    , in_ : OptionalArgument (List (Maybe Bool))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Bool
    , lte_ : OptionalArgument Bool
    , neq_ : OptionalArgument Bool
    , nin_ : OptionalArgument (List (Maybe Bool))
    }


{-| Encode a Boolean\_comparison\_exp into a value that can be used as an argument.
-}
encodeBoolean_comparison_exp : Boolean_comparison_exp -> Value
encodeBoolean_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.bool |> Encode.optional input.eq_ ), ( "_gt", Encode.bool |> Encode.optional input.gt_ ), ( "_gte", Encode.bool |> Encode.optional input.gte_ ), ( "_in", (Encode.bool |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.bool |> Encode.optional input.lt_ ), ( "_lte", Encode.bool |> Encode.optional input.lte_ ), ( "_neq", Encode.bool |> Encode.optional input.neq_ ), ( "_nin", (Encode.bool |> Encode.maybe |> Encode.list) |> Encode.optional input.nin_ ) ]


buildInteger_comparison_exp : (Integer_comparison_expOptionalFields -> Integer_comparison_expOptionalFields) -> Integer_comparison_exp
buildInteger_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Integer_comparison_expOptionalFields =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List (Maybe Int))
    }


{-| Type for the Integer\_comparison\_exp input object.
-}
type alias Integer_comparison_exp =
    { eq_ : OptionalArgument Int
    , gt_ : OptionalArgument Int
    , gte_ : OptionalArgument Int
    , in_ : OptionalArgument (List (Maybe Int))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Int
    , lte_ : OptionalArgument Int
    , neq_ : OptionalArgument Int
    , nin_ : OptionalArgument (List (Maybe Int))
    }


{-| Encode a Integer\_comparison\_exp into a value that can be used as an argument.
-}
encodeInteger_comparison_exp : Integer_comparison_exp -> Value
encodeInteger_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.int |> Encode.optional input.eq_ ), ( "_gt", Encode.int |> Encode.optional input.gt_ ), ( "_gte", Encode.int |> Encode.optional input.gte_ ), ( "_in", (Encode.int |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", Encode.int |> Encode.optional input.lt_ ), ( "_lte", Encode.int |> Encode.optional input.lte_ ), ( "_neq", Encode.int |> Encode.optional input.neq_ ), ( "_nin", (Encode.int |> Encode.maybe |> Encode.list) |> Encode.optional input.nin_ ) ]


buildOnline_users_bool_exp : (Online_users_bool_expOptionalFields -> Online_users_bool_expOptionalFields) -> Online_users_bool_exp
buildOnline_users_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, last_seen = Absent, user = Absent }
    in
    Online_users_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, id = optionals.id, last_seen = optionals.last_seen, user = optionals.user }


type alias Online_users_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , not_ : OptionalArgument Online_users_bool_exp
    , or_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , id : OptionalArgument Text_comparison_exp
    , last_seen : OptionalArgument Timestamptz_comparison_exp
    , user : OptionalArgument Users_bool_exp
    }


{-| Type alias for the `Online_users_bool_exp` attributes. Note that this type
needs to use the `Online_users_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Online_users_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , not_ : OptionalArgument Online_users_bool_exp
    , or_ : OptionalArgument (List (Maybe Online_users_bool_exp))
    , id : OptionalArgument Text_comparison_exp
    , last_seen : OptionalArgument Timestamptz_comparison_exp
    , user : OptionalArgument Users_bool_exp
    }


{-| Type for the Online\_users\_bool\_exp input object.
-}
type Online_users_bool_exp
    = Online_users_bool_exp Online_users_bool_expRaw


{-| Encode a Online\_users\_bool\_exp into a value that can be used as an argument.
-}
encodeOnline_users_bool_exp : Online_users_bool_exp -> Value
encodeOnline_users_bool_exp (Online_users_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeOnline_users_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeOnline_users_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeOnline_users_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "id", encodeText_comparison_exp |> Encode.optional input.id ), ( "last_seen", encodeTimestamptz_comparison_exp |> Encode.optional input.last_seen ), ( "user", encodeUsers_bool_exp |> Encode.optional input.user ) ]


buildOnline_users_order_by : (Online_users_order_byOptionalFields -> Online_users_order_byOptionalFields) -> Online_users_order_by
buildOnline_users_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, last_seen = Absent, user = Absent }
    in
    { id = optionals.id, last_seen = optionals.last_seen, user = optionals.user }


type alias Online_users_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    }


{-| Type for the Online\_users\_order\_by input object.
-}
type alias Online_users_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , last_seen : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    }


{-| Encode a Online\_users\_order\_by into a value that can be used as an argument.
-}
encodeOnline_users_order_by : Online_users_order_by -> Value
encodeOnline_users_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "last_seen", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.last_seen ), ( "user", encodeUsers_order_by |> Encode.optional input.user ) ]


buildText_comparison_exp : (Text_comparison_expOptionalFields -> Text_comparison_expOptionalFields) -> Text_comparison_exp
buildText_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, ilike_ = Absent, in_ = Absent, is_null_ = Absent, like_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nilike_ = Absent, nin_ = Absent, nlike_ = Absent, nsimilar_ = Absent, similar_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, ilike_ = optionals.ilike_, in_ = optionals.in_, is_null_ = optionals.is_null_, like_ = optionals.like_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nilike_ = optionals.nilike_, nin_ = optionals.nin_, nlike_ = optionals.nlike_, nsimilar_ = optionals.nsimilar_, similar_ = optionals.similar_ }


type alias Text_comparison_expOptionalFields =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List (Maybe String))
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Type for the Text\_comparison\_exp input object.
-}
type alias Text_comparison_exp =
    { eq_ : OptionalArgument String
    , gt_ : OptionalArgument String
    , gte_ : OptionalArgument String
    , ilike_ : OptionalArgument String
    , in_ : OptionalArgument (List (Maybe String))
    , is_null_ : OptionalArgument Bool
    , like_ : OptionalArgument String
    , lt_ : OptionalArgument String
    , lte_ : OptionalArgument String
    , neq_ : OptionalArgument String
    , nilike_ : OptionalArgument String
    , nin_ : OptionalArgument (List (Maybe String))
    , nlike_ : OptionalArgument String
    , nsimilar_ : OptionalArgument String
    , similar_ : OptionalArgument String
    }


{-| Encode a Text\_comparison\_exp into a value that can be used as an argument.
-}
encodeText_comparison_exp : Text_comparison_exp -> Value
encodeText_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", Encode.string |> Encode.optional input.eq_ ), ( "_gt", Encode.string |> Encode.optional input.gt_ ), ( "_gte", Encode.string |> Encode.optional input.gte_ ), ( "_ilike", Encode.string |> Encode.optional input.ilike_ ), ( "_in", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_like", Encode.string |> Encode.optional input.like_ ), ( "_lt", Encode.string |> Encode.optional input.lt_ ), ( "_lte", Encode.string |> Encode.optional input.lte_ ), ( "_neq", Encode.string |> Encode.optional input.neq_ ), ( "_nilike", Encode.string |> Encode.optional input.nilike_ ), ( "_nin", (Encode.string |> Encode.maybe |> Encode.list) |> Encode.optional input.nin_ ), ( "_nlike", Encode.string |> Encode.optional input.nlike_ ), ( "_nsimilar", Encode.string |> Encode.optional input.nsimilar_ ), ( "_similar", Encode.string |> Encode.optional input.similar_ ) ]


buildTimestamptz_comparison_exp : (Timestamptz_comparison_expOptionalFields -> Timestamptz_comparison_expOptionalFields) -> Timestamptz_comparison_exp
buildTimestamptz_comparison_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { eq_ = Absent, gt_ = Absent, gte_ = Absent, in_ = Absent, is_null_ = Absent, lt_ = Absent, lte_ = Absent, neq_ = Absent, nin_ = Absent }
    in
    { eq_ = optionals.eq_, gt_ = optionals.gt_, gte_ = optionals.gte_, in_ = optionals.in_, is_null_ = optionals.is_null_, lt_ = optionals.lt_, lte_ = optionals.lte_, neq_ = optionals.neq_, nin_ = optionals.nin_ }


type alias Timestamptz_comparison_expOptionalFields =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List (Maybe Hasura.ScalarCodecs.Timestamptz))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List (Maybe Hasura.ScalarCodecs.Timestamptz))
    }


{-| Type for the Timestamptz\_comparison\_exp input object.
-}
type alias Timestamptz_comparison_exp =
    { eq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , gte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , in_ : OptionalArgument (List (Maybe Hasura.ScalarCodecs.Timestamptz))
    , is_null_ : OptionalArgument Bool
    , lt_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , lte_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , neq_ : OptionalArgument Hasura.ScalarCodecs.Timestamptz
    , nin_ : OptionalArgument (List (Maybe Hasura.ScalarCodecs.Timestamptz))
    }


{-| Encode a Timestamptz\_comparison\_exp into a value that can be used as an argument.
-}
encodeTimestamptz_comparison_exp : Timestamptz_comparison_exp -> Value
encodeTimestamptz_comparison_exp input =
    Encode.maybeObject
        [ ( "_eq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.eq_ ), ( "_gt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gt_ ), ( "_gte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.gte_ ), ( "_in", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.maybe |> Encode.list) |> Encode.optional input.in_ ), ( "_is_null", Encode.bool |> Encode.optional input.is_null_ ), ( "_lt", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lt_ ), ( "_lte", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.lte_ ), ( "_neq", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.neq_ ), ( "_nin", ((Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.maybe |> Encode.list) |> Encode.optional input.nin_ ) ]


buildTodos_arr_rel_insert_input : Todos_arr_rel_insert_inputRequiredFields -> (Todos_arr_rel_insert_inputOptionalFields -> Todos_arr_rel_insert_inputOptionalFields) -> Todos_arr_rel_insert_input
buildTodos_arr_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    { data = required.data, on_conflict = optionals.on_conflict }


type alias Todos_arr_rel_insert_inputRequiredFields =
    { data : List Todos_insert_input }


type alias Todos_arr_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Todos_on_conflict }


{-| Type for the Todos\_arr\_rel\_insert\_input input object.
-}
type alias Todos_arr_rel_insert_input =
    { data : List Todos_insert_input
    , on_conflict : OptionalArgument Todos_on_conflict
    }


{-| Encode a Todos\_arr\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTodos_arr_rel_insert_input : Todos_arr_rel_insert_input -> Value
encodeTodos_arr_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", (encodeTodos_insert_input |> Encode.list) input.data |> Just ), ( "on_conflict", encodeTodos_on_conflict |> Encode.optional input.on_conflict ) ]


buildTodos_bool_exp : (Todos_bool_expOptionalFields -> Todos_bool_expOptionalFields) -> Todos_bool_exp
buildTodos_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, created_at = Absent, id = Absent, is_completed = Absent, is_public = Absent, title = Absent, user = Absent, user_id = Absent }
    in
    Todos_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, created_at = optionals.created_at, id = optionals.id, is_completed = optionals.is_completed, is_public = optionals.is_public, title = optionals.title, user = optionals.user, user_id = optionals.user_id }


type alias Todos_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Todos_bool_exp))
    , not_ : OptionalArgument Todos_bool_exp
    , or_ : OptionalArgument (List (Maybe Todos_bool_exp))
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Integer_comparison_exp
    , is_completed : OptionalArgument Boolean_comparison_exp
    , is_public : OptionalArgument Boolean_comparison_exp
    , title : OptionalArgument Text_comparison_exp
    , user : OptionalArgument Users_bool_exp
    , user_id : OptionalArgument Text_comparison_exp
    }


{-| Type alias for the `Todos_bool_exp` attributes. Note that this type
needs to use the `Todos_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Todos_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Todos_bool_exp))
    , not_ : OptionalArgument Todos_bool_exp
    , or_ : OptionalArgument (List (Maybe Todos_bool_exp))
    , created_at : OptionalArgument Timestamptz_comparison_exp
    , id : OptionalArgument Integer_comparison_exp
    , is_completed : OptionalArgument Boolean_comparison_exp
    , is_public : OptionalArgument Boolean_comparison_exp
    , title : OptionalArgument Text_comparison_exp
    , user : OptionalArgument Users_bool_exp
    , user_id : OptionalArgument Text_comparison_exp
    }


{-| Type for the Todos\_bool\_exp input object.
-}
type Todos_bool_exp
    = Todos_bool_exp Todos_bool_expRaw


{-| Encode a Todos\_bool\_exp into a value that can be used as an argument.
-}
encodeTodos_bool_exp : Todos_bool_exp -> Value
encodeTodos_bool_exp (Todos_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeTodos_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeTodos_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeTodos_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "created_at", encodeTimestamptz_comparison_exp |> Encode.optional input.created_at ), ( "id", encodeInteger_comparison_exp |> Encode.optional input.id ), ( "is_completed", encodeBoolean_comparison_exp |> Encode.optional input.is_completed ), ( "is_public", encodeBoolean_comparison_exp |> Encode.optional input.is_public ), ( "title", encodeText_comparison_exp |> Encode.optional input.title ), ( "user", encodeUsers_bool_exp |> Encode.optional input.user ), ( "user_id", encodeText_comparison_exp |> Encode.optional input.user_id ) ]


buildTodos_insert_input : (Todos_insert_inputOptionalFields -> Todos_insert_inputOptionalFields) -> Todos_insert_input
buildTodos_insert_input fillOptionals =
    let
        optionals =
            fillOptionals
                { is_public = Absent, title = Absent }
    in
    { is_public = optionals.is_public, title = optionals.title }


type alias Todos_insert_inputOptionalFields =
    { is_public : OptionalArgument Bool
    , title : OptionalArgument String
    }


{-| Type for the Todos\_insert\_input input object.
-}
type alias Todos_insert_input =
    { is_public : OptionalArgument Bool
    , title : OptionalArgument String
    }


{-| Encode a Todos\_insert\_input into a value that can be used as an argument.
-}
encodeTodos_insert_input : Todos_insert_input -> Value
encodeTodos_insert_input input =
    Encode.maybeObject
        [ ( "is_public", Encode.bool |> Encode.optional input.is_public ), ( "title", Encode.string |> Encode.optional input.title ) ]


buildTodos_obj_rel_insert_input : Todos_obj_rel_insert_inputRequiredFields -> (Todos_obj_rel_insert_inputOptionalFields -> Todos_obj_rel_insert_inputOptionalFields) -> Todos_obj_rel_insert_input
buildTodos_obj_rel_insert_input required fillOptionals =
    let
        optionals =
            fillOptionals
                { on_conflict = Absent }
    in
    { data = required.data, on_conflict = optionals.on_conflict }


type alias Todos_obj_rel_insert_inputRequiredFields =
    { data : Todos_insert_input }


type alias Todos_obj_rel_insert_inputOptionalFields =
    { on_conflict : OptionalArgument Todos_on_conflict }


{-| Type for the Todos\_obj\_rel\_insert\_input input object.
-}
type alias Todos_obj_rel_insert_input =
    { data : Todos_insert_input
    , on_conflict : OptionalArgument Todos_on_conflict
    }


{-| Encode a Todos\_obj\_rel\_insert\_input into a value that can be used as an argument.
-}
encodeTodos_obj_rel_insert_input : Todos_obj_rel_insert_input -> Value
encodeTodos_obj_rel_insert_input input =
    Encode.maybeObject
        [ ( "data", encodeTodos_insert_input input.data |> Just ), ( "on_conflict", encodeTodos_on_conflict |> Encode.optional input.on_conflict ) ]


buildTodos_on_conflict : Todos_on_conflictRequiredFields -> Todos_on_conflict
buildTodos_on_conflict required =
    { constraint = required.constraint, update_columns = required.update_columns }


type alias Todos_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Todos_constraint.Todos_constraint
    , update_columns : List Hasura.Enum.Todos_update_column.Todos_update_column
    }


{-| Type for the Todos\_on\_conflict input object.
-}
type alias Todos_on_conflict =
    { constraint : Hasura.Enum.Todos_constraint.Todos_constraint
    , update_columns : List Hasura.Enum.Todos_update_column.Todos_update_column
    }


{-| Encode a Todos\_on\_conflict into a value that can be used as an argument.
-}
encodeTodos_on_conflict : Todos_on_conflict -> Value
encodeTodos_on_conflict input =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Todos_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Todos_update_column.toString |> Encode.list) input.update_columns |> Just ) ]


buildTodos_order_by : (Todos_order_byOptionalFields -> Todos_order_byOptionalFields) -> Todos_order_by
buildTodos_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { created_at = Absent, id = Absent, is_completed = Absent, is_public = Absent, title = Absent, user = Absent, user_id = Absent }
    in
    { created_at = optionals.created_at, id = optionals.id, is_completed = optionals.is_completed, is_public = optionals.is_public, title = optionals.title, user = optionals.user, user_id = optionals.user_id }


type alias Todos_order_byOptionalFields =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_completed : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_public : OptionalArgument Hasura.Enum.Order_by.Order_by
    , title : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Todos\_order\_by input object.
-}
type alias Todos_order_by =
    { created_at : OptionalArgument Hasura.Enum.Order_by.Order_by
    , id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_completed : OptionalArgument Hasura.Enum.Order_by.Order_by
    , is_public : OptionalArgument Hasura.Enum.Order_by.Order_by
    , title : OptionalArgument Hasura.Enum.Order_by.Order_by
    , user : OptionalArgument Users_order_by
    , user_id : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Todos\_order\_by into a value that can be used as an argument.
-}
encodeTodos_order_by : Todos_order_by -> Value
encodeTodos_order_by input =
    Encode.maybeObject
        [ ( "created_at", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.created_at ), ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "is_completed", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.is_completed ), ( "is_public", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.is_public ), ( "title", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.title ), ( "user", encodeUsers_order_by |> Encode.optional input.user ), ( "user_id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.user_id ) ]


buildTodos_set_input : (Todos_set_inputOptionalFields -> Todos_set_inputOptionalFields) -> Todos_set_input
buildTodos_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { is_completed = Absent, title = Absent }
    in
    { is_completed = optionals.is_completed, title = optionals.title }


type alias Todos_set_inputOptionalFields =
    { is_completed : OptionalArgument Bool
    , title : OptionalArgument String
    }


{-| Type for the Todos\_set\_input input object.
-}
type alias Todos_set_input =
    { is_completed : OptionalArgument Bool
    , title : OptionalArgument String
    }


{-| Encode a Todos\_set\_input into a value that can be used as an argument.
-}
encodeTodos_set_input : Todos_set_input -> Value
encodeTodos_set_input input =
    Encode.maybeObject
        [ ( "is_completed", Encode.bool |> Encode.optional input.is_completed ), ( "title", Encode.string |> Encode.optional input.title ) ]


buildUsers_bool_exp : (Users_bool_expOptionalFields -> Users_bool_expOptionalFields) -> Users_bool_exp
buildUsers_bool_exp fillOptionals =
    let
        optionals =
            fillOptionals
                { and_ = Absent, not_ = Absent, or_ = Absent, id = Absent, name = Absent, todos = Absent }
    in
    Users_bool_exp { and_ = optionals.and_, not_ = optionals.not_, or_ = optionals.or_, id = optionals.id, name = optionals.name, todos = optionals.todos }


type alias Users_bool_expOptionalFields =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , id : OptionalArgument Text_comparison_exp
    , name : OptionalArgument Text_comparison_exp
    , todos : OptionalArgument Todos_bool_exp
    }


{-| Type alias for the `Users_bool_exp` attributes. Note that this type
needs to use the `Users_bool_exp` type (not just a plain type alias) because it has
references to itself either directly (recursive) or indirectly (circular). See
<https://github.com/dillonkearns/elm-graphql/issues/33>.
-}
type alias Users_bool_expRaw =
    { and_ : OptionalArgument (List (Maybe Users_bool_exp))
    , not_ : OptionalArgument Users_bool_exp
    , or_ : OptionalArgument (List (Maybe Users_bool_exp))
    , id : OptionalArgument Text_comparison_exp
    , name : OptionalArgument Text_comparison_exp
    , todos : OptionalArgument Todos_bool_exp
    }


{-| Type for the Users\_bool\_exp input object.
-}
type Users_bool_exp
    = Users_bool_exp Users_bool_expRaw


{-| Encode a Users\_bool\_exp into a value that can be used as an argument.
-}
encodeUsers_bool_exp : Users_bool_exp -> Value
encodeUsers_bool_exp (Users_bool_exp input) =
    Encode.maybeObject
        [ ( "_and", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.and_ ), ( "_not", encodeUsers_bool_exp |> Encode.optional input.not_ ), ( "_or", (encodeUsers_bool_exp |> Encode.maybe |> Encode.list) |> Encode.optional input.or_ ), ( "id", encodeText_comparison_exp |> Encode.optional input.id ), ( "name", encodeText_comparison_exp |> Encode.optional input.name ), ( "todos", encodeTodos_bool_exp |> Encode.optional input.todos ) ]


buildUsers_on_conflict : Users_on_conflictRequiredFields -> Users_on_conflict
buildUsers_on_conflict required =
    { constraint = required.constraint, update_columns = required.update_columns }


type alias Users_on_conflictRequiredFields =
    { constraint : Hasura.Enum.Users_constraint.Users_constraint
    , update_columns : List Hasura.Enum.Users_update_column.Users_update_column
    }


{-| Type for the Users\_on\_conflict input object.
-}
type alias Users_on_conflict =
    { constraint : Hasura.Enum.Users_constraint.Users_constraint
    , update_columns : List Hasura.Enum.Users_update_column.Users_update_column
    }


{-| Encode a Users\_on\_conflict into a value that can be used as an argument.
-}
encodeUsers_on_conflict : Users_on_conflict -> Value
encodeUsers_on_conflict input =
    Encode.maybeObject
        [ ( "constraint", Encode.enum Hasura.Enum.Users_constraint.toString input.constraint |> Just ), ( "update_columns", (Encode.enum Hasura.Enum.Users_update_column.toString |> Encode.list) input.update_columns |> Just ) ]


buildUsers_order_by : (Users_order_byOptionalFields -> Users_order_byOptionalFields) -> Users_order_by
buildUsers_order_by fillOptionals =
    let
        optionals =
            fillOptionals
                { id = Absent, name = Absent }
    in
    { id = optionals.id, name = optionals.name }


type alias Users_order_byOptionalFields =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Type for the Users\_order\_by input object.
-}
type alias Users_order_by =
    { id : OptionalArgument Hasura.Enum.Order_by.Order_by
    , name : OptionalArgument Hasura.Enum.Order_by.Order_by
    }


{-| Encode a Users\_order\_by into a value that can be used as an argument.
-}
encodeUsers_order_by : Users_order_by -> Value
encodeUsers_order_by input =
    Encode.maybeObject
        [ ( "id", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.id ), ( "name", Encode.enum Hasura.Enum.Order_by.toString |> Encode.optional input.name ) ]


buildUsers_set_input : (Users_set_inputOptionalFields -> Users_set_inputOptionalFields) -> Users_set_input
buildUsers_set_input fillOptionals =
    let
        optionals =
            fillOptionals
                { last_seen = Absent }
    in
    { last_seen = optionals.last_seen }


type alias Users_set_inputOptionalFields =
    { last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz }


{-| Type for the Users\_set\_input input object.
-}
type alias Users_set_input =
    { last_seen : OptionalArgument Hasura.ScalarCodecs.Timestamptz }


{-| Encode a Users\_set\_input into a value that can be used as an argument.
-}
encodeUsers_set_input : Users_set_input -> Value
encodeUsers_set_input input =
    Encode.maybeObject
        [ ( "last_seen", (Hasura.ScalarCodecs.codecs |> Hasura.Scalar.unwrapEncoder .codecTimestamptz) |> Encode.optional input.last_seen ) ]
