export type InputMaybe<T> = Maybe<T>;
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  timestamptz: any;
  json: any;
  uuid: any;
  jsonb: any;
  project_activity_status_enum: any;
  citext: any;
  bigint: any;
  numeric: any;
  float8: any;
  invoice_item_type: any;
  timestamp: any;
  timetz: any;
  _text: any;
  opentelemetry_connection_type_enum: any;
  date: any;
  _uuid: any;
  connector_timestamptz: any;
  connector_uuid: any;
  connector_deployment_status: any;
  bytea: any;
  _json: any;
  smallint: any;
  reminder_type_enum: any;
  _int4: any;
  user_action: any;
  Map: any;
  _date: any;
  _int8: any;
};

/** Boolean expression to compare columns of type "_json". All fields are combined with logical 'AND'. */
export type _Json_Comparison_Exp = {
  _eq?: Maybe<Scalars['_json']>;
  _gt?: Maybe<Scalars['_json']>;
  _gte?: Maybe<Scalars['_json']>;
  _in?: Maybe<Array<Scalars['_json']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['_json']>;
  _lte?: Maybe<Scalars['_json']>;
  _neq?: Maybe<Scalars['_json']>;
  _nin?: Maybe<Array<Scalars['_json']>>;
};

/** Boolean expression to compare columns of type "_text". All fields are combined with logical 'AND'. */
export type _Text_Comparison_Exp = {
  _eq?: Maybe<Scalars['_text']>;
  _gt?: Maybe<Scalars['_text']>;
  _gte?: Maybe<Scalars['_text']>;
  _in?: Maybe<Array<Scalars['_text']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['_text']>;
  _lte?: Maybe<Scalars['_text']>;
  _neq?: Maybe<Scalars['_text']>;
  _nin?: Maybe<Array<Scalars['_text']>>;
};

/** The agent through which the action is executed */
export enum ActionAgent {
  CloudDashboard = 'CloudDashboard',
  HasuraConsole = 'HasuraConsole',
  Unknown = 'Unknown',
}

export type AddCustomDomainOutput = {
  __typename?: 'AddCustomDomainOutput';
  cert?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['String']>;
  dns_validation?: Maybe<Scalars['String']>;
  fqdn: Scalars['String'];
  id: Scalars['uuid'];
  tenant_id: Scalars['uuid'];
  updated_at?: Maybe<Scalars['String']>;
};

export type AddProjectInput = {
  endpoint: Scalars['String'];
  name: Scalars['String'];
};

export type AddProjectResponse = {
  __typename?: 'AddProjectResponse';
  hasura_pro_key: Scalars['String'];
  id: Scalars['uuid'];
};

/** Alert configuration for Hasura Cloud projects */
export type Alert_Config = {
  __typename?: 'alert_config';
  /** An array relationship */
  alert_config_services: Array<Alert_Config_Service>;
  /** An aggregate relationship */
  alert_config_services_aggregate: Alert_Config_Service_Aggregate;
  /** An array relationship */
  alert_types: Array<Alert_Config_Alert_Type>;
  /** An aggregate relationship */
  alert_types_aggregate: Alert_Config_Alert_Type_Aggregate;
  created_at: Scalars['timestamptz'];
  enabled: Scalars['Boolean'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  /** An array relationship */
  slack_alert_configs: Array<Slack_Config>;
  /** An aggregate relationship */
  slack_alert_configs_aggregate: Slack_Config_Aggregate;
  /** An object relationship */
  tenant?: Maybe<Tenant>;
  updated_at: Scalars['timestamptz'];
};

/** Alert configuration for Hasura Cloud projects */
export type Alert_ConfigAlert_Config_ServicesArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Service_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Service_Order_By>>;
  where?: Maybe<Alert_Config_Service_Bool_Exp>;
};

/** Alert configuration for Hasura Cloud projects */
export type Alert_ConfigAlert_Config_Services_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Service_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Service_Order_By>>;
  where?: Maybe<Alert_Config_Service_Bool_Exp>;
};

/** Alert configuration for Hasura Cloud projects */
export type Alert_ConfigAlert_TypesArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Alert_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Alert_Type_Order_By>>;
  where?: Maybe<Alert_Config_Alert_Type_Bool_Exp>;
};

/** Alert configuration for Hasura Cloud projects */
export type Alert_ConfigAlert_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Alert_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Alert_Type_Order_By>>;
  where?: Maybe<Alert_Config_Alert_Type_Bool_Exp>;
};

/** Alert configuration for Hasura Cloud projects */
export type Alert_ConfigSlack_Alert_ConfigsArgs = {
  distinct_on?: Maybe<Array<Slack_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Slack_Config_Order_By>>;
  where?: Maybe<Slack_Config_Bool_Exp>;
};

/** Alert configuration for Hasura Cloud projects */
export type Alert_ConfigSlack_Alert_Configs_AggregateArgs = {
  distinct_on?: Maybe<Array<Slack_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Slack_Config_Order_By>>;
  where?: Maybe<Slack_Config_Bool_Exp>;
};

/** aggregated selection of "alert_config" */
export type Alert_Config_Aggregate = {
  __typename?: 'alert_config_aggregate';
  aggregate?: Maybe<Alert_Config_Aggregate_Fields>;
  nodes: Array<Alert_Config>;
};

/** aggregate fields of "alert_config" */
export type Alert_Config_Aggregate_Fields = {
  __typename?: 'alert_config_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Alert_Config_Max_Fields>;
  min?: Maybe<Alert_Config_Min_Fields>;
};

/** aggregate fields of "alert_config" */
export type Alert_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Alert_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Enabled alert types for Hasura Cloud projects */
export type Alert_Config_Alert_Type = {
  __typename?: 'alert_config_alert_type';
  /** An object relationship */
  alert_config: Alert_Config;
  /** An object relationship */
  alert_type: Alert_Type;
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id: Scalars['uuid'];
  rules?: Maybe<Scalars['json']>;
  /** An object relationship */
  slack_config?: Maybe<Slack_Config>;
  type: Scalars['String'];
};

/** Enabled alert types for Hasura Cloud projects */
export type Alert_Config_Alert_TypeRulesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "alert_config_alert_type" */
export type Alert_Config_Alert_Type_Aggregate = {
  __typename?: 'alert_config_alert_type_aggregate';
  aggregate?: Maybe<Alert_Config_Alert_Type_Aggregate_Fields>;
  nodes: Array<Alert_Config_Alert_Type>;
};

export type Alert_Config_Alert_Type_Aggregate_Bool_Exp = {
  count?: Maybe<Alert_Config_Alert_Type_Aggregate_Bool_Exp_Count>;
};

export type Alert_Config_Alert_Type_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Alert_Config_Alert_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Alert_Config_Alert_Type_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "alert_config_alert_type" */
export type Alert_Config_Alert_Type_Aggregate_Fields = {
  __typename?: 'alert_config_alert_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Alert_Config_Alert_Type_Max_Fields>;
  min?: Maybe<Alert_Config_Alert_Type_Min_Fields>;
};

/** aggregate fields of "alert_config_alert_type" */
export type Alert_Config_Alert_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Alert_Config_Alert_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "alert_config_alert_type" */
export type Alert_Config_Alert_Type_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Alert_Config_Alert_Type_Max_Order_By>;
  min?: Maybe<Alert_Config_Alert_Type_Min_Order_By>;
};

/** input type for inserting array relation for remote table "alert_config_alert_type" */
export type Alert_Config_Alert_Type_Arr_Rel_Insert_Input = {
  data: Array<Alert_Config_Alert_Type_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Alert_Config_Alert_Type_On_Conflict>;
};

/** Boolean expression to filter rows from the table "alert_config_alert_type". All fields are combined with a logical 'AND'. */
export type Alert_Config_Alert_Type_Bool_Exp = {
  _and?: Maybe<Array<Alert_Config_Alert_Type_Bool_Exp>>;
  _not?: Maybe<Alert_Config_Alert_Type_Bool_Exp>;
  _or?: Maybe<Array<Alert_Config_Alert_Type_Bool_Exp>>;
  alert_config?: Maybe<Alert_Config_Bool_Exp>;
  alert_type?: Maybe<Alert_Type_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  rules?: Maybe<Json_Comparison_Exp>;
  slack_config?: Maybe<Slack_Config_Bool_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "alert_config_alert_type" */
export enum Alert_Config_Alert_Type_Constraint {
  /** unique or primary key constraint on columns "type", "project_id" */
  AlertConfigAlertTypePkey = 'alert_config_alert_type_pkey',
}

/** input type for inserting data into table "alert_config_alert_type" */
export type Alert_Config_Alert_Type_Insert_Input = {
  alert_config?: Maybe<Alert_Config_Obj_Rel_Insert_Input>;
  alert_type?: Maybe<Alert_Type_Obj_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  rules?: Maybe<Scalars['json']>;
  slack_config?: Maybe<Slack_Config_Obj_Rel_Insert_Input>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Alert_Config_Alert_Type_Max_Fields = {
  __typename?: 'alert_config_alert_type_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "alert_config_alert_type" */
export type Alert_Config_Alert_Type_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Alert_Config_Alert_Type_Min_Fields = {
  __typename?: 'alert_config_alert_type_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "alert_config_alert_type" */
export type Alert_Config_Alert_Type_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** response of any mutation on the table "alert_config_alert_type" */
export type Alert_Config_Alert_Type_Mutation_Response = {
  __typename?: 'alert_config_alert_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Alert_Config_Alert_Type>;
};

/** on_conflict condition type for table "alert_config_alert_type" */
export type Alert_Config_Alert_Type_On_Conflict = {
  constraint: Alert_Config_Alert_Type_Constraint;
  update_columns?: Array<Alert_Config_Alert_Type_Update_Column>;
  where?: Maybe<Alert_Config_Alert_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "alert_config_alert_type". */
export type Alert_Config_Alert_Type_Order_By = {
  alert_config?: Maybe<Alert_Config_Order_By>;
  alert_type?: Maybe<Alert_Type_Order_By>;
  created_at?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  rules?: Maybe<Order_By>;
  slack_config?: Maybe<Slack_Config_Order_By>;
  type?: Maybe<Order_By>;
};

/** primary key columns input for table: alert_config_alert_type */
export type Alert_Config_Alert_Type_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
  type: Scalars['String'];
};

/** select columns of table "alert_config_alert_type" */
export enum Alert_Config_Alert_Type_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Rules = 'rules',
  /** column name */
  Type = 'type',
}

/** input type for updating data in table "alert_config_alert_type" */
export type Alert_Config_Alert_Type_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  rules?: Maybe<Scalars['json']>;
  type?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "alert_config_alert_type" */
export type Alert_Config_Alert_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Alert_Config_Alert_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Alert_Config_Alert_Type_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  rules?: Maybe<Scalars['json']>;
  type?: Maybe<Scalars['String']>;
};

/** update columns of table "alert_config_alert_type" */
export enum Alert_Config_Alert_Type_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Rules = 'rules',
  /** column name */
  Type = 'type',
}

export type Alert_Config_Alert_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Alert_Config_Alert_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Alert_Config_Alert_Type_Bool_Exp;
};

/** Boolean expression to filter rows from the table "alert_config". All fields are combined with a logical 'AND'. */
export type Alert_Config_Bool_Exp = {
  _and?: Maybe<Array<Alert_Config_Bool_Exp>>;
  _not?: Maybe<Alert_Config_Bool_Exp>;
  _or?: Maybe<Array<Alert_Config_Bool_Exp>>;
  alert_config_services?: Maybe<Alert_Config_Service_Bool_Exp>;
  alert_config_services_aggregate?: Maybe<Alert_Config_Service_Aggregate_Bool_Exp>;
  alert_types?: Maybe<Alert_Config_Alert_Type_Bool_Exp>;
  alert_types_aggregate?: Maybe<Alert_Config_Alert_Type_Aggregate_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  enabled?: Maybe<Boolean_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  slack_alert_configs?: Maybe<Slack_Config_Bool_Exp>;
  slack_alert_configs_aggregate?: Maybe<Slack_Config_Aggregate_Bool_Exp>;
  tenant?: Maybe<Tenant_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "alert_config" */
export enum Alert_Config_Constraint {
  /** unique or primary key constraint on columns "project_id" */
  AlertConfigPkey = 'alert_config_pkey',
}

/** input type for inserting data into table "alert_config" */
export type Alert_Config_Insert_Input = {
  alert_config_services?: Maybe<Alert_Config_Service_Arr_Rel_Insert_Input>;
  alert_types?: Maybe<Alert_Config_Alert_Type_Arr_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  enabled?: Maybe<Scalars['Boolean']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  slack_alert_configs?: Maybe<Slack_Config_Arr_Rel_Insert_Input>;
  tenant?: Maybe<Tenant_Obj_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Alert_Config_Max_Fields = {
  __typename?: 'alert_config_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Alert_Config_Min_Fields = {
  __typename?: 'alert_config_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "alert_config" */
export type Alert_Config_Mutation_Response = {
  __typename?: 'alert_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Alert_Config>;
};

/** input type for inserting object relation for remote table "alert_config" */
export type Alert_Config_Obj_Rel_Insert_Input = {
  data: Alert_Config_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Alert_Config_On_Conflict>;
};

/** on_conflict condition type for table "alert_config" */
export type Alert_Config_On_Conflict = {
  constraint: Alert_Config_Constraint;
  update_columns?: Array<Alert_Config_Update_Column>;
  where?: Maybe<Alert_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "alert_config". */
export type Alert_Config_Order_By = {
  alert_config_services_aggregate?: Maybe<Alert_Config_Service_Aggregate_Order_By>;
  alert_types_aggregate?: Maybe<Alert_Config_Alert_Type_Aggregate_Order_By>;
  created_at?: Maybe<Order_By>;
  enabled?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  slack_alert_configs_aggregate?: Maybe<Slack_Config_Aggregate_Order_By>;
  tenant?: Maybe<Tenant_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: alert_config */
export type Alert_Config_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
};

/** select columns of table "alert_config" */
export enum Alert_Config_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** Alert notification service configs for Hasura Cloud projects */
export type Alert_Config_Service = {
  __typename?: 'alert_config_service';
  /** An object relationship */
  alert_config: Alert_Config;
  created_at: Scalars['timestamptz'];
  enabled: Scalars['Boolean'];
  metadata?: Maybe<Scalars['json']>;
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id: Scalars['uuid'];
  rules?: Maybe<Scalars['jsonb']>;
  type: Alert_Service_Type_Enum;
  updated_at: Scalars['timestamptz'];
};

/** Alert notification service configs for Hasura Cloud projects */
export type Alert_Config_ServiceMetadataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Alert notification service configs for Hasura Cloud projects */
export type Alert_Config_ServiceRulesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "alert_config_service" */
export type Alert_Config_Service_Aggregate = {
  __typename?: 'alert_config_service_aggregate';
  aggregate?: Maybe<Alert_Config_Service_Aggregate_Fields>;
  nodes: Array<Alert_Config_Service>;
};

export type Alert_Config_Service_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Alert_Config_Service_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Alert_Config_Service_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Alert_Config_Service_Aggregate_Bool_Exp_Count>;
};

export type Alert_Config_Service_Aggregate_Bool_Exp_Bool_And = {
  arguments: Alert_Config_Service_Select_Column_Alert_Config_Service_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Alert_Config_Service_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Alert_Config_Service_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Alert_Config_Service_Select_Column_Alert_Config_Service_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Alert_Config_Service_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Alert_Config_Service_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Alert_Config_Service_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Alert_Config_Service_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "alert_config_service" */
export type Alert_Config_Service_Aggregate_Fields = {
  __typename?: 'alert_config_service_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Alert_Config_Service_Max_Fields>;
  min?: Maybe<Alert_Config_Service_Min_Fields>;
};

/** aggregate fields of "alert_config_service" */
export type Alert_Config_Service_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Alert_Config_Service_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "alert_config_service" */
export type Alert_Config_Service_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Alert_Config_Service_Max_Order_By>;
  min?: Maybe<Alert_Config_Service_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Alert_Config_Service_Append_Input = {
  rules?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "alert_config_service" */
export type Alert_Config_Service_Arr_Rel_Insert_Input = {
  data: Array<Alert_Config_Service_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Alert_Config_Service_On_Conflict>;
};

/** Boolean expression to filter rows from the table "alert_config_service". All fields are combined with a logical 'AND'. */
export type Alert_Config_Service_Bool_Exp = {
  _and?: Maybe<Array<Alert_Config_Service_Bool_Exp>>;
  _not?: Maybe<Alert_Config_Service_Bool_Exp>;
  _or?: Maybe<Array<Alert_Config_Service_Bool_Exp>>;
  alert_config?: Maybe<Alert_Config_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  enabled?: Maybe<Boolean_Comparison_Exp>;
  metadata?: Maybe<Json_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  rules?: Maybe<Jsonb_Comparison_Exp>;
  type?: Maybe<Alert_Service_Type_Enum_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "alert_config_service" */
export enum Alert_Config_Service_Constraint {
  /** unique or primary key constraint on columns "type", "project_id" */
  AlertConfigServicePkey = 'alert_config_service_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Alert_Config_Service_Delete_At_Path_Input = {
  rules?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Alert_Config_Service_Delete_Elem_Input = {
  rules?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Alert_Config_Service_Delete_Key_Input = {
  rules?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "alert_config_service" */
export type Alert_Config_Service_Insert_Input = {
  alert_config?: Maybe<Alert_Config_Obj_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  enabled?: Maybe<Scalars['Boolean']>;
  metadata?: Maybe<Scalars['json']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  rules?: Maybe<Scalars['jsonb']>;
  type?: Maybe<Alert_Service_Type_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Alert_Config_Service_Max_Fields = {
  __typename?: 'alert_config_service_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "alert_config_service" */
export type Alert_Config_Service_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Alert_Config_Service_Min_Fields = {
  __typename?: 'alert_config_service_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "alert_config_service" */
export type Alert_Config_Service_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "alert_config_service" */
export type Alert_Config_Service_Mutation_Response = {
  __typename?: 'alert_config_service_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Alert_Config_Service>;
};

/** on_conflict condition type for table "alert_config_service" */
export type Alert_Config_Service_On_Conflict = {
  constraint: Alert_Config_Service_Constraint;
  update_columns?: Array<Alert_Config_Service_Update_Column>;
  where?: Maybe<Alert_Config_Service_Bool_Exp>;
};

/** Ordering options when selecting data from "alert_config_service". */
export type Alert_Config_Service_Order_By = {
  alert_config?: Maybe<Alert_Config_Order_By>;
  created_at?: Maybe<Order_By>;
  enabled?: Maybe<Order_By>;
  metadata?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  rules?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: alert_config_service */
export type Alert_Config_Service_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
  type: Alert_Service_Type_Enum;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Alert_Config_Service_Prepend_Input = {
  rules?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "alert_config_service" */
export enum Alert_Config_Service_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Rules = 'rules',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** select "alert_config_service_aggregate_bool_exp_bool_and_arguments_columns" columns of table "alert_config_service" */
export enum Alert_Config_Service_Select_Column_Alert_Config_Service_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Enabled = 'enabled',
}

/** select "alert_config_service_aggregate_bool_exp_bool_or_arguments_columns" columns of table "alert_config_service" */
export enum Alert_Config_Service_Select_Column_Alert_Config_Service_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Enabled = 'enabled',
}

/** input type for updating data in table "alert_config_service" */
export type Alert_Config_Service_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  enabled?: Maybe<Scalars['Boolean']>;
  metadata?: Maybe<Scalars['json']>;
  project_id?: Maybe<Scalars['uuid']>;
  rules?: Maybe<Scalars['jsonb']>;
  type?: Maybe<Alert_Service_Type_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "alert_config_service" */
export type Alert_Config_Service_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Alert_Config_Service_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Alert_Config_Service_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  enabled?: Maybe<Scalars['Boolean']>;
  metadata?: Maybe<Scalars['json']>;
  project_id?: Maybe<Scalars['uuid']>;
  rules?: Maybe<Scalars['jsonb']>;
  type?: Maybe<Alert_Service_Type_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "alert_config_service" */
export enum Alert_Config_Service_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Rules = 'rules',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Alert_Config_Service_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Alert_Config_Service_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Alert_Config_Service_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Alert_Config_Service_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Alert_Config_Service_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Alert_Config_Service_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Alert_Config_Service_Set_Input>;
  /** filter the rows which have to be updated */
  where: Alert_Config_Service_Bool_Exp;
};

/** input type for updating data in table "alert_config" */
export type Alert_Config_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  enabled?: Maybe<Scalars['Boolean']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "alert_config" */
export type Alert_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Alert_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Alert_Config_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  enabled?: Maybe<Scalars['Boolean']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "alert_config" */
export enum Alert_Config_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Alert_Config_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Alert_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Alert_Config_Bool_Exp;
};

/** Alert notification service type enum */
export type Alert_Service_Type = {
  __typename?: 'alert_service_type';
  description: Scalars['String'];
  name: Scalars['String'];
};

/** aggregated selection of "alert_service_type" */
export type Alert_Service_Type_Aggregate = {
  __typename?: 'alert_service_type_aggregate';
  aggregate?: Maybe<Alert_Service_Type_Aggregate_Fields>;
  nodes: Array<Alert_Service_Type>;
};

/** aggregate fields of "alert_service_type" */
export type Alert_Service_Type_Aggregate_Fields = {
  __typename?: 'alert_service_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Alert_Service_Type_Max_Fields>;
  min?: Maybe<Alert_Service_Type_Min_Fields>;
};

/** aggregate fields of "alert_service_type" */
export type Alert_Service_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Alert_Service_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "alert_service_type". All fields are combined with a logical 'AND'. */
export type Alert_Service_Type_Bool_Exp = {
  _and?: Maybe<Array<Alert_Service_Type_Bool_Exp>>;
  _not?: Maybe<Alert_Service_Type_Bool_Exp>;
  _or?: Maybe<Array<Alert_Service_Type_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "alert_service_type" */
export enum Alert_Service_Type_Constraint {
  /** unique or primary key constraint on columns "name" */
  AlertServiceTypePkey = 'alert_service_type_pkey',
}

export enum Alert_Service_Type_Enum {
  /** Mail */
  Mail = 'mail',
  /** Slack Notifier */
  Slack = 'slack',
}

/** Boolean expression to compare columns of type "alert_service_type_enum". All fields are combined with logical 'AND'. */
export type Alert_Service_Type_Enum_Comparison_Exp = {
  _eq?: Maybe<Alert_Service_Type_Enum>;
  _in?: Maybe<Array<Alert_Service_Type_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Alert_Service_Type_Enum>;
  _nin?: Maybe<Array<Alert_Service_Type_Enum>>;
};

/** input type for inserting data into table "alert_service_type" */
export type Alert_Service_Type_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Alert_Service_Type_Max_Fields = {
  __typename?: 'alert_service_type_max_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Alert_Service_Type_Min_Fields = {
  __typename?: 'alert_service_type_min_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "alert_service_type" */
export type Alert_Service_Type_Mutation_Response = {
  __typename?: 'alert_service_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Alert_Service_Type>;
};

/** on_conflict condition type for table "alert_service_type" */
export type Alert_Service_Type_On_Conflict = {
  constraint: Alert_Service_Type_Constraint;
  update_columns?: Array<Alert_Service_Type_Update_Column>;
  where?: Maybe<Alert_Service_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "alert_service_type". */
export type Alert_Service_Type_Order_By = {
  description?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** primary key columns input for table: alert_service_type */
export type Alert_Service_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "alert_service_type" */
export enum Alert_Service_Type_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

/** input type for updating data in table "alert_service_type" */
export type Alert_Service_Type_Set_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "alert_service_type" */
export type Alert_Service_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Alert_Service_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Alert_Service_Type_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** update columns of table "alert_service_type" */
export enum Alert_Service_Type_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

export type Alert_Service_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Alert_Service_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Alert_Service_Type_Bool_Exp;
};

/** Alert type enum for alert configuration */
export type Alert_Type = {
  __typename?: 'alert_type';
  always_enabled: Scalars['Boolean'];
  description: Scalars['String'];
  hidden: Scalars['Boolean'];
  id: Scalars['String'];
  name: Scalars['String'];
  template?: Maybe<Scalars['String']>;
};

/** aggregated selection of "alert_type" */
export type Alert_Type_Aggregate = {
  __typename?: 'alert_type_aggregate';
  aggregate?: Maybe<Alert_Type_Aggregate_Fields>;
  nodes: Array<Alert_Type>;
};

/** aggregate fields of "alert_type" */
export type Alert_Type_Aggregate_Fields = {
  __typename?: 'alert_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Alert_Type_Max_Fields>;
  min?: Maybe<Alert_Type_Min_Fields>;
};

/** aggregate fields of "alert_type" */
export type Alert_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Alert_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "alert_type". All fields are combined with a logical 'AND'. */
export type Alert_Type_Bool_Exp = {
  _and?: Maybe<Array<Alert_Type_Bool_Exp>>;
  _not?: Maybe<Alert_Type_Bool_Exp>;
  _or?: Maybe<Array<Alert_Type_Bool_Exp>>;
  always_enabled?: Maybe<Boolean_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  hidden?: Maybe<Boolean_Comparison_Exp>;
  id?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  template?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "alert_type" */
export enum Alert_Type_Constraint {
  /** unique or primary key constraint on columns "id" */
  AlertTypePkey = 'alert_type_pkey',
}

/** input type for inserting data into table "alert_type" */
export type Alert_Type_Insert_Input = {
  always_enabled?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  hidden?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  template?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Alert_Type_Max_Fields = {
  __typename?: 'alert_type_max_fields';
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  template?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Alert_Type_Min_Fields = {
  __typename?: 'alert_type_min_fields';
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  template?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "alert_type" */
export type Alert_Type_Mutation_Response = {
  __typename?: 'alert_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Alert_Type>;
};

/** input type for inserting object relation for remote table "alert_type" */
export type Alert_Type_Obj_Rel_Insert_Input = {
  data: Alert_Type_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Alert_Type_On_Conflict>;
};

/** on_conflict condition type for table "alert_type" */
export type Alert_Type_On_Conflict = {
  constraint: Alert_Type_Constraint;
  update_columns?: Array<Alert_Type_Update_Column>;
  where?: Maybe<Alert_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "alert_type". */
export type Alert_Type_Order_By = {
  always_enabled?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  hidden?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  template?: Maybe<Order_By>;
};

/** primary key columns input for table: alert_type */
export type Alert_Type_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "alert_type" */
export enum Alert_Type_Select_Column {
  /** column name */
  AlwaysEnabled = 'always_enabled',
  /** column name */
  Description = 'description',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Template = 'template',
}

/** input type for updating data in table "alert_type" */
export type Alert_Type_Set_Input = {
  always_enabled?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  hidden?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  template?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "alert_type" */
export type Alert_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Alert_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Alert_Type_Stream_Cursor_Value_Input = {
  always_enabled?: Maybe<Scalars['Boolean']>;
  description?: Maybe<Scalars['String']>;
  hidden?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  template?: Maybe<Scalars['String']>;
};

/** update columns of table "alert_type" */
export enum Alert_Type_Update_Column {
  /** column name */
  AlwaysEnabled = 'always_enabled',
  /** column name */
  Description = 'description',
  /** column name */
  Hidden = 'hidden',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Template = 'template',
}

export type Alert_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Alert_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Alert_Type_Bool_Exp;
};

export type AllowedProjectResponse = {
  __typename?: 'AllowedProjectResponse';
  id: Scalars['uuid'];
  name: Scalars['String'];
};

/** Azure Monitor Config for Metrics Exporter */
export type Azuremonitor_Config = {
  __typename?: 'azuremonitor_config';
  activedirectory_client_id: Scalars['String'];
  activedirectory_client_secret: Scalars['String'];
  activedirectory_tenant_id: Scalars['String'];
  attributes: Scalars['jsonb'];
  azure_region: Scalars['String'];
  azuremonitor_workspace_id: Scalars['String'];
  created_at: Scalars['timestamptz'];
  instrumentation_key?: Maybe<Scalars['String']>;
  log_type: Scalars['String'];
  logs_last_logged: Scalars['timestamptz'];
  logs_response_code?: Maybe<Scalars['Int']>;
  metric_namespace: Scalars['String'];
  metrics_last_logged: Scalars['timestamptz'];
  metrics_response_code?: Maybe<Scalars['Int']>;
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  resource_id: Scalars['String'];
  shared_key: Scalars['String'];
  traces_last_logged: Scalars['timestamptz'];
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** Azure Monitor Config for Metrics Exporter */
export type Azuremonitor_ConfigAttributesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "azuremonitor_config" */
export type Azuremonitor_Config_Aggregate = {
  __typename?: 'azuremonitor_config_aggregate';
  aggregate?: Maybe<Azuremonitor_Config_Aggregate_Fields>;
  nodes: Array<Azuremonitor_Config>;
};

/** aggregate fields of "azuremonitor_config" */
export type Azuremonitor_Config_Aggregate_Fields = {
  __typename?: 'azuremonitor_config_aggregate_fields';
  avg?: Maybe<Azuremonitor_Config_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Azuremonitor_Config_Max_Fields>;
  min?: Maybe<Azuremonitor_Config_Min_Fields>;
  stddev?: Maybe<Azuremonitor_Config_Stddev_Fields>;
  stddev_pop?: Maybe<Azuremonitor_Config_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Azuremonitor_Config_Stddev_Samp_Fields>;
  sum?: Maybe<Azuremonitor_Config_Sum_Fields>;
  var_pop?: Maybe<Azuremonitor_Config_Var_Pop_Fields>;
  var_samp?: Maybe<Azuremonitor_Config_Var_Samp_Fields>;
  variance?: Maybe<Azuremonitor_Config_Variance_Fields>;
};

/** aggregate fields of "azuremonitor_config" */
export type Azuremonitor_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Azuremonitor_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Azuremonitor_Config_Append_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Azuremonitor_Config_Avg_Fields = {
  __typename?: 'azuremonitor_config_avg_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "azuremonitor_config". All fields are combined with a logical 'AND'. */
export type Azuremonitor_Config_Bool_Exp = {
  _and?: Maybe<Array<Azuremonitor_Config_Bool_Exp>>;
  _not?: Maybe<Azuremonitor_Config_Bool_Exp>;
  _or?: Maybe<Array<Azuremonitor_Config_Bool_Exp>>;
  activedirectory_client_id?: Maybe<String_Comparison_Exp>;
  activedirectory_client_secret?: Maybe<String_Comparison_Exp>;
  activedirectory_tenant_id?: Maybe<String_Comparison_Exp>;
  attributes?: Maybe<Jsonb_Comparison_Exp>;
  azure_region?: Maybe<String_Comparison_Exp>;
  azuremonitor_workspace_id?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  instrumentation_key?: Maybe<String_Comparison_Exp>;
  log_type?: Maybe<String_Comparison_Exp>;
  logs_last_logged?: Maybe<Timestamptz_Comparison_Exp>;
  logs_response_code?: Maybe<Int_Comparison_Exp>;
  metric_namespace?: Maybe<String_Comparison_Exp>;
  metrics_last_logged?: Maybe<Timestamptz_Comparison_Exp>;
  metrics_response_code?: Maybe<Int_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  resource_id?: Maybe<String_Comparison_Exp>;
  shared_key?: Maybe<String_Comparison_Exp>;
  traces_last_logged?: Maybe<Timestamptz_Comparison_Exp>;
  traces_response_code?: Maybe<Int_Comparison_Exp>;
  traces_response_message?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "azuremonitor_config" */
export enum Azuremonitor_Config_Constraint {
  /** unique or primary key constraint on columns "project_id" */
  AzuremonitorConfigPkey = 'azuremonitor_config_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Azuremonitor_Config_Delete_At_Path_Input = {
  attributes?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Azuremonitor_Config_Delete_Elem_Input = {
  attributes?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Azuremonitor_Config_Delete_Key_Input = {
  attributes?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "azuremonitor_config" */
export type Azuremonitor_Config_Inc_Input = {
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "azuremonitor_config" */
export type Azuremonitor_Config_Insert_Input = {
  activedirectory_client_id?: Maybe<Scalars['String']>;
  activedirectory_client_secret?: Maybe<Scalars['String']>;
  activedirectory_tenant_id?: Maybe<Scalars['String']>;
  attributes?: Maybe<Scalars['jsonb']>;
  azure_region?: Maybe<Scalars['String']>;
  azuremonitor_workspace_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  instrumentation_key?: Maybe<Scalars['String']>;
  log_type?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metric_namespace?: Maybe<Scalars['String']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  resource_id?: Maybe<Scalars['String']>;
  shared_key?: Maybe<Scalars['String']>;
  traces_last_logged?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Azuremonitor_Config_Max_Fields = {
  __typename?: 'azuremonitor_config_max_fields';
  activedirectory_client_id?: Maybe<Scalars['String']>;
  activedirectory_client_secret?: Maybe<Scalars['String']>;
  activedirectory_tenant_id?: Maybe<Scalars['String']>;
  azure_region?: Maybe<Scalars['String']>;
  azuremonitor_workspace_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  instrumentation_key?: Maybe<Scalars['String']>;
  log_type?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metric_namespace?: Maybe<Scalars['String']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  resource_id?: Maybe<Scalars['String']>;
  shared_key?: Maybe<Scalars['String']>;
  traces_last_logged?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Azuremonitor_Config_Min_Fields = {
  __typename?: 'azuremonitor_config_min_fields';
  activedirectory_client_id?: Maybe<Scalars['String']>;
  activedirectory_client_secret?: Maybe<Scalars['String']>;
  activedirectory_tenant_id?: Maybe<Scalars['String']>;
  azure_region?: Maybe<Scalars['String']>;
  azuremonitor_workspace_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  instrumentation_key?: Maybe<Scalars['String']>;
  log_type?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metric_namespace?: Maybe<Scalars['String']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  resource_id?: Maybe<Scalars['String']>;
  shared_key?: Maybe<Scalars['String']>;
  traces_last_logged?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "azuremonitor_config" */
export type Azuremonitor_Config_Mutation_Response = {
  __typename?: 'azuremonitor_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Azuremonitor_Config>;
};

/** input type for inserting object relation for remote table "azuremonitor_config" */
export type Azuremonitor_Config_Obj_Rel_Insert_Input = {
  data: Azuremonitor_Config_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Azuremonitor_Config_On_Conflict>;
};

/** on_conflict condition type for table "azuremonitor_config" */
export type Azuremonitor_Config_On_Conflict = {
  constraint: Azuremonitor_Config_Constraint;
  update_columns?: Array<Azuremonitor_Config_Update_Column>;
  where?: Maybe<Azuremonitor_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "azuremonitor_config". */
export type Azuremonitor_Config_Order_By = {
  activedirectory_client_id?: Maybe<Order_By>;
  activedirectory_client_secret?: Maybe<Order_By>;
  activedirectory_tenant_id?: Maybe<Order_By>;
  attributes?: Maybe<Order_By>;
  azure_region?: Maybe<Order_By>;
  azuremonitor_workspace_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  instrumentation_key?: Maybe<Order_By>;
  log_type?: Maybe<Order_By>;
  logs_last_logged?: Maybe<Order_By>;
  logs_response_code?: Maybe<Order_By>;
  metric_namespace?: Maybe<Order_By>;
  metrics_last_logged?: Maybe<Order_By>;
  metrics_response_code?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  resource_id?: Maybe<Order_By>;
  shared_key?: Maybe<Order_By>;
  traces_last_logged?: Maybe<Order_By>;
  traces_response_code?: Maybe<Order_By>;
  traces_response_message?: Maybe<Order_By>;
};

/** primary key columns input for table: azuremonitor_config */
export type Azuremonitor_Config_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Azuremonitor_Config_Prepend_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "azuremonitor_config" */
export enum Azuremonitor_Config_Select_Column {
  /** column name */
  ActivedirectoryClientId = 'activedirectory_client_id',
  /** column name */
  ActivedirectoryClientSecret = 'activedirectory_client_secret',
  /** column name */
  ActivedirectoryTenantId = 'activedirectory_tenant_id',
  /** column name */
  Attributes = 'attributes',
  /** column name */
  AzureRegion = 'azure_region',
  /** column name */
  AzuremonitorWorkspaceId = 'azuremonitor_workspace_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InstrumentationKey = 'instrumentation_key',
  /** column name */
  LogType = 'log_type',
  /** column name */
  LogsLastLogged = 'logs_last_logged',
  /** column name */
  LogsResponseCode = 'logs_response_code',
  /** column name */
  MetricNamespace = 'metric_namespace',
  /** column name */
  MetricsLastLogged = 'metrics_last_logged',
  /** column name */
  MetricsResponseCode = 'metrics_response_code',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  SharedKey = 'shared_key',
  /** column name */
  TracesLastLogged = 'traces_last_logged',
  /** column name */
  TracesResponseCode = 'traces_response_code',
  /** column name */
  TracesResponseMessage = 'traces_response_message',
}

/** input type for updating data in table "azuremonitor_config" */
export type Azuremonitor_Config_Set_Input = {
  activedirectory_client_id?: Maybe<Scalars['String']>;
  activedirectory_client_secret?: Maybe<Scalars['String']>;
  activedirectory_tenant_id?: Maybe<Scalars['String']>;
  attributes?: Maybe<Scalars['jsonb']>;
  azure_region?: Maybe<Scalars['String']>;
  azuremonitor_workspace_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  instrumentation_key?: Maybe<Scalars['String']>;
  log_type?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metric_namespace?: Maybe<Scalars['String']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  resource_id?: Maybe<Scalars['String']>;
  shared_key?: Maybe<Scalars['String']>;
  traces_last_logged?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Azuremonitor_Config_Stddev_Fields = {
  __typename?: 'azuremonitor_config_stddev_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Azuremonitor_Config_Stddev_Pop_Fields = {
  __typename?: 'azuremonitor_config_stddev_pop_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Azuremonitor_Config_Stddev_Samp_Fields = {
  __typename?: 'azuremonitor_config_stddev_samp_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "azuremonitor_config" */
export type Azuremonitor_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Azuremonitor_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Azuremonitor_Config_Stream_Cursor_Value_Input = {
  activedirectory_client_id?: Maybe<Scalars['String']>;
  activedirectory_client_secret?: Maybe<Scalars['String']>;
  activedirectory_tenant_id?: Maybe<Scalars['String']>;
  attributes?: Maybe<Scalars['jsonb']>;
  azure_region?: Maybe<Scalars['String']>;
  azuremonitor_workspace_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  instrumentation_key?: Maybe<Scalars['String']>;
  log_type?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metric_namespace?: Maybe<Scalars['String']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  resource_id?: Maybe<Scalars['String']>;
  shared_key?: Maybe<Scalars['String']>;
  traces_last_logged?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Azuremonitor_Config_Sum_Fields = {
  __typename?: 'azuremonitor_config_sum_fields';
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** update columns of table "azuremonitor_config" */
export enum Azuremonitor_Config_Update_Column {
  /** column name */
  ActivedirectoryClientId = 'activedirectory_client_id',
  /** column name */
  ActivedirectoryClientSecret = 'activedirectory_client_secret',
  /** column name */
  ActivedirectoryTenantId = 'activedirectory_tenant_id',
  /** column name */
  Attributes = 'attributes',
  /** column name */
  AzureRegion = 'azure_region',
  /** column name */
  AzuremonitorWorkspaceId = 'azuremonitor_workspace_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InstrumentationKey = 'instrumentation_key',
  /** column name */
  LogType = 'log_type',
  /** column name */
  LogsLastLogged = 'logs_last_logged',
  /** column name */
  LogsResponseCode = 'logs_response_code',
  /** column name */
  MetricNamespace = 'metric_namespace',
  /** column name */
  MetricsLastLogged = 'metrics_last_logged',
  /** column name */
  MetricsResponseCode = 'metrics_response_code',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ResourceId = 'resource_id',
  /** column name */
  SharedKey = 'shared_key',
  /** column name */
  TracesLastLogged = 'traces_last_logged',
  /** column name */
  TracesResponseCode = 'traces_response_code',
  /** column name */
  TracesResponseMessage = 'traces_response_message',
}

export type Azuremonitor_Config_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Azuremonitor_Config_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Azuremonitor_Config_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Azuremonitor_Config_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Azuremonitor_Config_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Azuremonitor_Config_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Azuremonitor_Config_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Azuremonitor_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Azuremonitor_Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Azuremonitor_Config_Var_Pop_Fields = {
  __typename?: 'azuremonitor_config_var_pop_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Azuremonitor_Config_Var_Samp_Fields = {
  __typename?: 'azuremonitor_config_var_samp_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Azuremonitor_Config_Variance_Fields = {
  __typename?: 'azuremonitor_config_variance_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

export type AzureMonitorConfigResponse = {
  __typename?: 'AzureMonitorConfigResponse';
  project_id: Scalars['uuid'];
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq?: Maybe<Scalars['bigint']>;
  _gt?: Maybe<Scalars['bigint']>;
  _gte?: Maybe<Scalars['bigint']>;
  _in?: Maybe<Array<Scalars['bigint']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['bigint']>;
  _lte?: Maybe<Scalars['bigint']>;
  _neq?: Maybe<Scalars['bigint']>;
  _nin?: Maybe<Array<Scalars['bigint']>>;
};

/** Address used for billing paid Hasura Cloud services */
export type Billing_Address = {
  __typename?: 'billing_address';
  address_line_1: Scalars['String'];
  address_line_2: Scalars['String'];
  city: Scalars['String'];
  country: Scalars['String'];
  created_at: Scalars['timestamptz'];
  customer_id: Scalars['String'];
  id: Scalars['uuid'];
  is_active: Scalars['Boolean'];
  last_updated_to_stripe: Scalars['timestamptz'];
  name: Scalars['String'];
  pin_code?: Maybe<Scalars['String']>;
  state: Scalars['String'];
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  user: Users;
};

/** aggregated selection of "billing_address" */
export type Billing_Address_Aggregate = {
  __typename?: 'billing_address_aggregate';
  aggregate?: Maybe<Billing_Address_Aggregate_Fields>;
  nodes: Array<Billing_Address>;
};

/** aggregate fields of "billing_address" */
export type Billing_Address_Aggregate_Fields = {
  __typename?: 'billing_address_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Billing_Address_Max_Fields>;
  min?: Maybe<Billing_Address_Min_Fields>;
};

/** aggregate fields of "billing_address" */
export type Billing_Address_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Billing_Address_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "billing_address". All fields are combined with a logical 'AND'. */
export type Billing_Address_Bool_Exp = {
  _and?: Maybe<Array<Billing_Address_Bool_Exp>>;
  _not?: Maybe<Billing_Address_Bool_Exp>;
  _or?: Maybe<Array<Billing_Address_Bool_Exp>>;
  address_line_1?: Maybe<String_Comparison_Exp>;
  address_line_2?: Maybe<String_Comparison_Exp>;
  city?: Maybe<String_Comparison_Exp>;
  country?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customer_id?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  last_updated_to_stripe?: Maybe<Timestamptz_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  pin_code?: Maybe<String_Comparison_Exp>;
  state?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
};

/** unique or primary key constraints on table "billing_address" */
export enum Billing_Address_Constraint {
  /** unique or primary key constraint on columns "customer_id" */
  BillingAddressCustomerIdKey = 'billing_address_customer_id_key',
  /** unique or primary key constraint on columns "id" */
  BillingAddressPkey = 'billing_address_pkey',
}

/** input type for inserting data into table "billing_address" */
export type Billing_Address_Insert_Input = {
  address_line_1?: Maybe<Scalars['String']>;
  address_line_2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  last_updated_to_stripe?: Maybe<Scalars['timestamptz']>;
  name?: Maybe<Scalars['String']>;
  pin_code?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Billing_Address_Max_Fields = {
  __typename?: 'billing_address_max_fields';
  address_line_1?: Maybe<Scalars['String']>;
  address_line_2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_updated_to_stripe?: Maybe<Scalars['timestamptz']>;
  name?: Maybe<Scalars['String']>;
  pin_code?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Billing_Address_Min_Fields = {
  __typename?: 'billing_address_min_fields';
  address_line_1?: Maybe<Scalars['String']>;
  address_line_2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_updated_to_stripe?: Maybe<Scalars['timestamptz']>;
  name?: Maybe<Scalars['String']>;
  pin_code?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "billing_address" */
export type Billing_Address_Mutation_Response = {
  __typename?: 'billing_address_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Billing_Address>;
};

/** input type for inserting object relation for remote table "billing_address" */
export type Billing_Address_Obj_Rel_Insert_Input = {
  data: Billing_Address_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Billing_Address_On_Conflict>;
};

/** on_conflict condition type for table "billing_address" */
export type Billing_Address_On_Conflict = {
  constraint: Billing_Address_Constraint;
  update_columns?: Array<Billing_Address_Update_Column>;
  where?: Maybe<Billing_Address_Bool_Exp>;
};

/** Ordering options when selecting data from "billing_address". */
export type Billing_Address_Order_By = {
  address_line_1?: Maybe<Order_By>;
  address_line_2?: Maybe<Order_By>;
  city?: Maybe<Order_By>;
  country?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  last_updated_to_stripe?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  pin_code?: Maybe<Order_By>;
  state?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
};

/** primary key columns input for table: billing_address */
export type Billing_Address_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "billing_address" */
export enum Billing_Address_Select_Column {
  /** column name */
  AddressLine_1 = 'address_line_1',
  /** column name */
  AddressLine_2 = 'address_line_2',
  /** column name */
  City = 'city',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  LastUpdatedToStripe = 'last_updated_to_stripe',
  /** column name */
  Name = 'name',
  /** column name */
  PinCode = 'pin_code',
  /** column name */
  State = 'state',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "billing_address" */
export type Billing_Address_Set_Input = {
  address_line_1?: Maybe<Scalars['String']>;
  address_line_2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  last_updated_to_stripe?: Maybe<Scalars['timestamptz']>;
  name?: Maybe<Scalars['String']>;
  pin_code?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "billing_address" */
export type Billing_Address_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Billing_Address_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Billing_Address_Stream_Cursor_Value_Input = {
  address_line_1?: Maybe<Scalars['String']>;
  address_line_2?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  last_updated_to_stripe?: Maybe<Scalars['timestamptz']>;
  name?: Maybe<Scalars['String']>;
  pin_code?: Maybe<Scalars['String']>;
  state?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "billing_address" */
export enum Billing_Address_Update_Column {
  /** column name */
  AddressLine_1 = 'address_line_1',
  /** column name */
  AddressLine_2 = 'address_line_2',
  /** column name */
  City = 'city',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  LastUpdatedToStripe = 'last_updated_to_stripe',
  /** column name */
  Name = 'name',
  /** column name */
  PinCode = 'pin_code',
  /** column name */
  State = 'state',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Billing_Address_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Billing_Address_Set_Input>;
  /** filter the rows which have to be updated */
  where: Billing_Address_Bool_Exp;
};

export type BillingManagerInvitation = {
  __typename?: 'BillingManagerInvitation';
  id: Scalars['uuid'];
  invited_at: Scalars['String'];
  invited_by: Scalars['uuid'];
  manager_email: Scalars['String'];
  project_id: Scalars['uuid'];
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: Maybe<Scalars['Boolean']>;
  _gt?: Maybe<Scalars['Boolean']>;
  _gte?: Maybe<Scalars['Boolean']>;
  _in?: Maybe<Array<Scalars['Boolean']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['Boolean']>;
  _lte?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Scalars['Boolean']>;
  _nin?: Maybe<Array<Scalars['Boolean']>>;
};

export type BuildKiteBuild = {
  __typename?: 'BuildKiteBuild';
  id: Scalars['String'];
  url: Scalars['String'];
};

export type BuildVersion = {
  __typename?: 'BuildVersion';
  GitCommit: Scalars['String'];
  Tag: Scalars['String'];
};

/** Boolean expression to compare columns of type "bytea". All fields are combined with logical 'AND'. */
export type Bytea_Comparison_Exp = {
  _eq?: Maybe<Scalars['bytea']>;
  _gt?: Maybe<Scalars['bytea']>;
  _gte?: Maybe<Scalars['bytea']>;
  _in?: Maybe<Array<Scalars['bytea']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['bytea']>;
  _lte?: Maybe<Scalars['bytea']>;
  _neq?: Maybe<Scalars['bytea']>;
  _nin?: Maybe<Array<Scalars['bytea']>>;
};

/** columns and relationships of "central_cloud" */
export type Central_Cloud = {
  __typename?: 'central_cloud';
  cloud: Cloud_Enum;
  created_at: Scalars['timestamptz'];
  infra_status: Infra_Status_Enum;
  input_variables: Scalars['jsonb'];
  metrics_fqdn?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "central_cloud" */
export type Central_CloudInput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "central_cloud" */
export type Central_CloudOutput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "central_cloud" */
export type Central_Cloud_Aggregate = {
  __typename?: 'central_cloud_aggregate';
  aggregate?: Maybe<Central_Cloud_Aggregate_Fields>;
  nodes: Array<Central_Cloud>;
};

/** aggregate fields of "central_cloud" */
export type Central_Cloud_Aggregate_Fields = {
  __typename?: 'central_cloud_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Central_Cloud_Max_Fields>;
  min?: Maybe<Central_Cloud_Min_Fields>;
};

/** aggregate fields of "central_cloud" */
export type Central_Cloud_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Central_Cloud_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Central_Cloud_Append_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "central_cloud". All fields are combined with a logical 'AND'. */
export type Central_Cloud_Bool_Exp = {
  _and?: Maybe<Array<Central_Cloud_Bool_Exp>>;
  _not?: Maybe<Central_Cloud_Bool_Exp>;
  _or?: Maybe<Array<Central_Cloud_Bool_Exp>>;
  cloud?: Maybe<Cloud_Enum_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  infra_status?: Maybe<Infra_Status_Enum_Comparison_Exp>;
  input_variables?: Maybe<Jsonb_Comparison_Exp>;
  metrics_fqdn?: Maybe<String_Comparison_Exp>;
  output_variables?: Maybe<Jsonb_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "central_cloud" */
export enum Central_Cloud_Constraint {
  /** unique or primary key constraint on columns "cloud" */
  CentralCloudPkey = 'central_cloud_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Central_Cloud_Delete_At_Path_Input = {
  input_variables?: Maybe<Array<Scalars['String']>>;
  output_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Central_Cloud_Delete_Elem_Input = {
  input_variables?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Central_Cloud_Delete_Key_Input = {
  input_variables?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "central_cloud" */
export type Central_Cloud_Insert_Input = {
  cloud?: Maybe<Cloud_Enum>;
  created_at?: Maybe<Scalars['timestamptz']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Central_Cloud_Max_Fields = {
  __typename?: 'central_cloud_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Central_Cloud_Min_Fields = {
  __typename?: 'central_cloud_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "central_cloud" */
export type Central_Cloud_Mutation_Response = {
  __typename?: 'central_cloud_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Central_Cloud>;
};

/** input type for inserting object relation for remote table "central_cloud" */
export type Central_Cloud_Obj_Rel_Insert_Input = {
  data: Central_Cloud_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Central_Cloud_On_Conflict>;
};

/** on_conflict condition type for table "central_cloud" */
export type Central_Cloud_On_Conflict = {
  constraint: Central_Cloud_Constraint;
  update_columns?: Array<Central_Cloud_Update_Column>;
  where?: Maybe<Central_Cloud_Bool_Exp>;
};

/** Ordering options when selecting data from "central_cloud". */
export type Central_Cloud_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  infra_status?: Maybe<Order_By>;
  input_variables?: Maybe<Order_By>;
  metrics_fqdn?: Maybe<Order_By>;
  output_variables?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: central_cloud */
export type Central_Cloud_Pk_Columns_Input = {
  cloud: Cloud_Enum;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Central_Cloud_Prepend_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "central_cloud" */
export enum Central_Cloud_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  MetricsFqdn = 'metrics_fqdn',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "central_cloud" */
export type Central_Cloud_Set_Input = {
  cloud?: Maybe<Cloud_Enum>;
  created_at?: Maybe<Scalars['timestamptz']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "central_cloud" */
export type Central_Cloud_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Central_Cloud_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Central_Cloud_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Cloud_Enum>;
  created_at?: Maybe<Scalars['timestamptz']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "central_cloud" */
export enum Central_Cloud_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  MetricsFqdn = 'metrics_fqdn',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Central_Cloud_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Central_Cloud_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Central_Cloud_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Central_Cloud_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Central_Cloud_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Central_Cloud_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Central_Cloud_Set_Input>;
  /** filter the rows which have to be updated */
  where: Central_Cloud_Bool_Exp;
};

/** Request to change user email */
export type Change_Email_Request = {
  __typename?: 'change_email_request';
  id: Scalars['uuid'];
  key: Scalars['String'];
  new_email: Scalars['String'];
  old_email: Scalars['String'];
  resend_count: Scalars['Int'];
  status: Scalars['String'];
  /** An object relationship */
  user?: Maybe<Users>;
  user_id: Scalars['uuid'];
  verified: Scalars['Boolean'];
};

/** aggregated selection of "change_email_request" */
export type Change_Email_Request_Aggregate = {
  __typename?: 'change_email_request_aggregate';
  aggregate?: Maybe<Change_Email_Request_Aggregate_Fields>;
  nodes: Array<Change_Email_Request>;
};

/** aggregate fields of "change_email_request" */
export type Change_Email_Request_Aggregate_Fields = {
  __typename?: 'change_email_request_aggregate_fields';
  avg?: Maybe<Change_Email_Request_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Change_Email_Request_Max_Fields>;
  min?: Maybe<Change_Email_Request_Min_Fields>;
  stddev?: Maybe<Change_Email_Request_Stddev_Fields>;
  stddev_pop?: Maybe<Change_Email_Request_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Change_Email_Request_Stddev_Samp_Fields>;
  sum?: Maybe<Change_Email_Request_Sum_Fields>;
  var_pop?: Maybe<Change_Email_Request_Var_Pop_Fields>;
  var_samp?: Maybe<Change_Email_Request_Var_Samp_Fields>;
  variance?: Maybe<Change_Email_Request_Variance_Fields>;
};

/** aggregate fields of "change_email_request" */
export type Change_Email_Request_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Change_Email_Request_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Change_Email_Request_Avg_Fields = {
  __typename?: 'change_email_request_avg_fields';
  resend_count?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "change_email_request". All fields are combined with a logical 'AND'. */
export type Change_Email_Request_Bool_Exp = {
  _and?: Maybe<Array<Change_Email_Request_Bool_Exp>>;
  _not?: Maybe<Change_Email_Request_Bool_Exp>;
  _or?: Maybe<Array<Change_Email_Request_Bool_Exp>>;
  id?: Maybe<Uuid_Comparison_Exp>;
  key?: Maybe<String_Comparison_Exp>;
  new_email?: Maybe<String_Comparison_Exp>;
  old_email?: Maybe<String_Comparison_Exp>;
  resend_count?: Maybe<Int_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
  verified?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "change_email_request" */
export enum Change_Email_Request_Constraint {
  /** unique or primary key constraint on columns "key" */
  ChangeEmailRequestKeyKey = 'change_email_request_key_key',
  /** unique or primary key constraint on columns "id" */
  ChangeEmailRequestPkey = 'change_email_request_pkey',
}

/** input type for incrementing numeric columns in table "change_email_request" */
export type Change_Email_Request_Inc_Input = {
  resend_count?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "change_email_request" */
export type Change_Email_Request_Insert_Input = {
  id?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  new_email?: Maybe<Scalars['String']>;
  old_email?: Maybe<Scalars['String']>;
  resend_count?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
  verified?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Change_Email_Request_Max_Fields = {
  __typename?: 'change_email_request_max_fields';
  id?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  new_email?: Maybe<Scalars['String']>;
  old_email?: Maybe<Scalars['String']>;
  resend_count?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Change_Email_Request_Min_Fields = {
  __typename?: 'change_email_request_min_fields';
  id?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  new_email?: Maybe<Scalars['String']>;
  old_email?: Maybe<Scalars['String']>;
  resend_count?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "change_email_request" */
export type Change_Email_Request_Mutation_Response = {
  __typename?: 'change_email_request_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Change_Email_Request>;
};

/** on_conflict condition type for table "change_email_request" */
export type Change_Email_Request_On_Conflict = {
  constraint: Change_Email_Request_Constraint;
  update_columns?: Array<Change_Email_Request_Update_Column>;
  where?: Maybe<Change_Email_Request_Bool_Exp>;
};

/** Ordering options when selecting data from "change_email_request". */
export type Change_Email_Request_Order_By = {
  id?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  new_email?: Maybe<Order_By>;
  old_email?: Maybe<Order_By>;
  resend_count?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
  verified?: Maybe<Order_By>;
};

/** primary key columns input for table: change_email_request */
export type Change_Email_Request_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "change_email_request" */
export enum Change_Email_Request_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  NewEmail = 'new_email',
  /** column name */
  OldEmail = 'old_email',
  /** column name */
  ResendCount = 'resend_count',
  /** column name */
  Status = 'status',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Verified = 'verified',
}

/** input type for updating data in table "change_email_request" */
export type Change_Email_Request_Set_Input = {
  id?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  new_email?: Maybe<Scalars['String']>;
  old_email?: Maybe<Scalars['String']>;
  resend_count?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
  verified?: Maybe<Scalars['Boolean']>;
};

/** aggregate stddev on columns */
export type Change_Email_Request_Stddev_Fields = {
  __typename?: 'change_email_request_stddev_fields';
  resend_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Change_Email_Request_Stddev_Pop_Fields = {
  __typename?: 'change_email_request_stddev_pop_fields';
  resend_count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Change_Email_Request_Stddev_Samp_Fields = {
  __typename?: 'change_email_request_stddev_samp_fields';
  resend_count?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "change_email_request" */
export type Change_Email_Request_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Change_Email_Request_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Change_Email_Request_Stream_Cursor_Value_Input = {
  id?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  new_email?: Maybe<Scalars['String']>;
  old_email?: Maybe<Scalars['String']>;
  resend_count?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
  verified?: Maybe<Scalars['Boolean']>;
};

/** aggregate sum on columns */
export type Change_Email_Request_Sum_Fields = {
  __typename?: 'change_email_request_sum_fields';
  resend_count?: Maybe<Scalars['Int']>;
};

/** update columns of table "change_email_request" */
export enum Change_Email_Request_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  NewEmail = 'new_email',
  /** column name */
  OldEmail = 'old_email',
  /** column name */
  ResendCount = 'resend_count',
  /** column name */
  Status = 'status',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Verified = 'verified',
}

export type Change_Email_Request_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Change_Email_Request_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Change_Email_Request_Set_Input>;
  /** filter the rows which have to be updated */
  where: Change_Email_Request_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Change_Email_Request_Var_Pop_Fields = {
  __typename?: 'change_email_request_var_pop_fields';
  resend_count?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Change_Email_Request_Var_Samp_Fields = {
  __typename?: 'change_email_request_var_samp_fields';
  resend_count?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Change_Email_Request_Variance_Fields = {
  __typename?: 'change_email_request_variance_fields';
  resend_count?: Maybe<Scalars['Float']>;
};

export type ChangeUserEmailRequest = {
  __typename?: 'ChangeUserEmailRequest';
  id: Scalars['uuid'];
  new_email: Scalars['String'];
  status: Scalars['String'];
  user_id: Scalars['uuid'];
  verified: Scalars['Boolean'];
};

export type ChangeUserEmailRequestInput = {
  new_email: Scalars['String'];
};

export type ChangeUserEmailRequestKeyInput = {
  key: Scalars['String'];
};

export type CheckDbLatencyOutput = {
  __typename?: 'CheckDBLatencyOutput';
  db_latency_job_id: Scalars['uuid'];
};

/** Connects branch(es)/PR to a particular deployment pool */
export type Cicd_Deployment_Pipeline_Config = {
  __typename?: 'cicd_deployment_pipeline_config';
  approval_required?: Maybe<Scalars['Boolean']>;
  branch_regexp?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  /** An object relationship */
  pool?: Maybe<Cicd_Deployment_Pool>;
  pool_name: Scalars['String'];
  pull_request_id?: Maybe<Scalars['String']>;
  tag_regexp?: Maybe<Scalars['String']>;
};

/** aggregated selection of "cicd.deployment_pipeline_config" */
export type Cicd_Deployment_Pipeline_Config_Aggregate = {
  __typename?: 'cicd_deployment_pipeline_config_aggregate';
  aggregate?: Maybe<Cicd_Deployment_Pipeline_Config_Aggregate_Fields>;
  nodes: Array<Cicd_Deployment_Pipeline_Config>;
};

/** aggregate fields of "cicd.deployment_pipeline_config" */
export type Cicd_Deployment_Pipeline_Config_Aggregate_Fields = {
  __typename?: 'cicd_deployment_pipeline_config_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Cicd_Deployment_Pipeline_Config_Max_Fields>;
  min?: Maybe<Cicd_Deployment_Pipeline_Config_Min_Fields>;
};

/** aggregate fields of "cicd.deployment_pipeline_config" */
export type Cicd_Deployment_Pipeline_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/**
 * Boolean expression to filter rows from the table
 * "cicd.deployment_pipeline_config". All fields are combined with a logical 'AND'.
 */
export type Cicd_Deployment_Pipeline_Config_Bool_Exp = {
  _and?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Bool_Exp>>;
  _not?: Maybe<Cicd_Deployment_Pipeline_Config_Bool_Exp>;
  _or?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Bool_Exp>>;
  approval_required?: Maybe<Boolean_Comparison_Exp>;
  branch_regexp?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  pool?: Maybe<Cicd_Deployment_Pool_Bool_Exp>;
  pool_name?: Maybe<String_Comparison_Exp>;
  pull_request_id?: Maybe<String_Comparison_Exp>;
  tag_regexp?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "cicd.deployment_pipeline_config" */
export enum Cicd_Deployment_Pipeline_Config_Constraint {
  /** unique or primary key constraint on columns "id" */
  DeploymentPipelineConfigPkey = 'deployment_pipeline_config_pkey',
}

/** input type for inserting data into table "cicd.deployment_pipeline_config" */
export type Cicd_Deployment_Pipeline_Config_Insert_Input = {
  approval_required?: Maybe<Scalars['Boolean']>;
  branch_regexp?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  pool?: Maybe<Cicd_Deployment_Pool_Obj_Rel_Insert_Input>;
  pool_name?: Maybe<Scalars['String']>;
  pull_request_id?: Maybe<Scalars['String']>;
  tag_regexp?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Cicd_Deployment_Pipeline_Config_Max_Fields = {
  __typename?: 'cicd_deployment_pipeline_config_max_fields';
  branch_regexp?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  pool_name?: Maybe<Scalars['String']>;
  pull_request_id?: Maybe<Scalars['String']>;
  tag_regexp?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Cicd_Deployment_Pipeline_Config_Min_Fields = {
  __typename?: 'cicd_deployment_pipeline_config_min_fields';
  branch_regexp?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  pool_name?: Maybe<Scalars['String']>;
  pull_request_id?: Maybe<Scalars['String']>;
  tag_regexp?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "cicd.deployment_pipeline_config" */
export type Cicd_Deployment_Pipeline_Config_Mutation_Response = {
  __typename?: 'cicd_deployment_pipeline_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Cicd_Deployment_Pipeline_Config>;
};

/** on_conflict condition type for table "cicd.deployment_pipeline_config" */
export type Cicd_Deployment_Pipeline_Config_On_Conflict = {
  constraint: Cicd_Deployment_Pipeline_Config_Constraint;
  update_columns?: Array<Cicd_Deployment_Pipeline_Config_Update_Column>;
  where?: Maybe<Cicd_Deployment_Pipeline_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "cicd.deployment_pipeline_config". */
export type Cicd_Deployment_Pipeline_Config_Order_By = {
  approval_required?: Maybe<Order_By>;
  branch_regexp?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  pool?: Maybe<Cicd_Deployment_Pool_Order_By>;
  pool_name?: Maybe<Order_By>;
  pull_request_id?: Maybe<Order_By>;
  tag_regexp?: Maybe<Order_By>;
};

/** primary key columns input for table: cicd.deployment_pipeline_config */
export type Cicd_Deployment_Pipeline_Config_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "cicd.deployment_pipeline_config" */
export enum Cicd_Deployment_Pipeline_Config_Select_Column {
  /** column name */
  ApprovalRequired = 'approval_required',
  /** column name */
  BranchRegexp = 'branch_regexp',
  /** column name */
  Id = 'id',
  /** column name */
  PoolName = 'pool_name',
  /** column name */
  PullRequestId = 'pull_request_id',
  /** column name */
  TagRegexp = 'tag_regexp',
}

/** input type for updating data in table "cicd.deployment_pipeline_config" */
export type Cicd_Deployment_Pipeline_Config_Set_Input = {
  approval_required?: Maybe<Scalars['Boolean']>;
  branch_regexp?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  pool_name?: Maybe<Scalars['String']>;
  pull_request_id?: Maybe<Scalars['String']>;
  tag_regexp?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "cicd_deployment_pipeline_config" */
export type Cicd_Deployment_Pipeline_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Cicd_Deployment_Pipeline_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Cicd_Deployment_Pipeline_Config_Stream_Cursor_Value_Input = {
  approval_required?: Maybe<Scalars['Boolean']>;
  branch_regexp?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  pool_name?: Maybe<Scalars['String']>;
  pull_request_id?: Maybe<Scalars['String']>;
  tag_regexp?: Maybe<Scalars['String']>;
};

/** update columns of table "cicd.deployment_pipeline_config" */
export enum Cicd_Deployment_Pipeline_Config_Update_Column {
  /** column name */
  ApprovalRequired = 'approval_required',
  /** column name */
  BranchRegexp = 'branch_regexp',
  /** column name */
  Id = 'id',
  /** column name */
  PoolName = 'pool_name',
  /** column name */
  PullRequestId = 'pull_request_id',
  /** column name */
  TagRegexp = 'tag_regexp',
}

export type Cicd_Deployment_Pipeline_Config_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Cicd_Deployment_Pipeline_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Cicd_Deployment_Pipeline_Config_Bool_Exp;
};

/** columns and relationships of "cicd.deployment_pool" */
export type Cicd_Deployment_Pool = {
  __typename?: 'cicd_deployment_pool';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  is_exclusive_pool?: Maybe<Scalars['Boolean']>;
  /** An array relationship */
  members: Array<Cicd_Deployment_Pool_Member>;
  /** An aggregate relationship */
  members_aggregate: Cicd_Deployment_Pool_Member_Aggregate;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "cicd.deployment_pool" */
export type Cicd_Deployment_PoolMembersArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Member_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
};

/** columns and relationships of "cicd.deployment_pool" */
export type Cicd_Deployment_PoolMembers_AggregateArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Member_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
};

/** aggregated selection of "cicd.deployment_pool" */
export type Cicd_Deployment_Pool_Aggregate = {
  __typename?: 'cicd_deployment_pool_aggregate';
  aggregate?: Maybe<Cicd_Deployment_Pool_Aggregate_Fields>;
  nodes: Array<Cicd_Deployment_Pool>;
};

/** aggregate fields of "cicd.deployment_pool" */
export type Cicd_Deployment_Pool_Aggregate_Fields = {
  __typename?: 'cicd_deployment_pool_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Cicd_Deployment_Pool_Max_Fields>;
  min?: Maybe<Cicd_Deployment_Pool_Min_Fields>;
};

/** aggregate fields of "cicd.deployment_pool" */
export type Cicd_Deployment_Pool_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Cicd_Deployment_Pool_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "cicd.deployment_pool". All fields are combined with a logical 'AND'. */
export type Cicd_Deployment_Pool_Bool_Exp = {
  _and?: Maybe<Array<Cicd_Deployment_Pool_Bool_Exp>>;
  _not?: Maybe<Cicd_Deployment_Pool_Bool_Exp>;
  _or?: Maybe<Array<Cicd_Deployment_Pool_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  is_exclusive_pool?: Maybe<Boolean_Comparison_Exp>;
  members?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
  members_aggregate?: Maybe<Cicd_Deployment_Pool_Member_Aggregate_Bool_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** input type for inserting data into table "cicd.deployment_pool" */
export type Cicd_Deployment_Pool_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  is_exclusive_pool?: Maybe<Scalars['Boolean']>;
  members?: Maybe<Cicd_Deployment_Pool_Member_Arr_Rel_Insert_Input>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Cicd_Deployment_Pool_Max_Fields = {
  __typename?: 'cicd_deployment_pool_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "cicd.deployment_pool_member" */
export type Cicd_Deployment_Pool_Member = {
  __typename?: 'cicd_deployment_pool_member';
  created_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  pool?: Maybe<Cicd_Deployment_Pool>;
  pool_name?: Maybe<Scalars['String']>;
  /** An object relationship */
  tenant_group?: Maybe<Tenant_Group>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregated selection of "cicd.deployment_pool_member" */
export type Cicd_Deployment_Pool_Member_Aggregate = {
  __typename?: 'cicd_deployment_pool_member_aggregate';
  aggregate?: Maybe<Cicd_Deployment_Pool_Member_Aggregate_Fields>;
  nodes: Array<Cicd_Deployment_Pool_Member>;
};

export type Cicd_Deployment_Pool_Member_Aggregate_Bool_Exp = {
  count?: Maybe<Cicd_Deployment_Pool_Member_Aggregate_Bool_Exp_Count>;
};

export type Cicd_Deployment_Pool_Member_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Cicd_Deployment_Pool_Member_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "cicd.deployment_pool_member" */
export type Cicd_Deployment_Pool_Member_Aggregate_Fields = {
  __typename?: 'cicd_deployment_pool_member_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Cicd_Deployment_Pool_Member_Max_Fields>;
  min?: Maybe<Cicd_Deployment_Pool_Member_Min_Fields>;
};

/** aggregate fields of "cicd.deployment_pool_member" */
export type Cicd_Deployment_Pool_Member_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Cicd_Deployment_Pool_Member_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "cicd.deployment_pool_member" */
export type Cicd_Deployment_Pool_Member_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Cicd_Deployment_Pool_Member_Max_Order_By>;
  min?: Maybe<Cicd_Deployment_Pool_Member_Min_Order_By>;
};

/** input type for inserting array relation for remote table "cicd.deployment_pool_member" */
export type Cicd_Deployment_Pool_Member_Arr_Rel_Insert_Input = {
  data: Array<Cicd_Deployment_Pool_Member_Insert_Input>;
};

/**
 * Boolean expression to filter rows from the table "cicd.deployment_pool_member".
 * All fields are combined with a logical 'AND'.
 */
export type Cicd_Deployment_Pool_Member_Bool_Exp = {
  _and?: Maybe<Array<Cicd_Deployment_Pool_Member_Bool_Exp>>;
  _not?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
  _or?: Maybe<Array<Cicd_Deployment_Pool_Member_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  pool?: Maybe<Cicd_Deployment_Pool_Bool_Exp>;
  pool_name?: Maybe<String_Comparison_Exp>;
  tenant_group?: Maybe<Tenant_Group_Bool_Exp>;
  tenant_group_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** input type for inserting data into table "cicd.deployment_pool_member" */
export type Cicd_Deployment_Pool_Member_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  pool?: Maybe<Cicd_Deployment_Pool_Obj_Rel_Insert_Input>;
  pool_name?: Maybe<Scalars['String']>;
  tenant_group?: Maybe<Tenant_Group_Obj_Rel_Insert_Input>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Cicd_Deployment_Pool_Member_Max_Fields = {
  __typename?: 'cicd_deployment_pool_member_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  pool_name?: Maybe<Scalars['String']>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "cicd.deployment_pool_member" */
export type Cicd_Deployment_Pool_Member_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  pool_name?: Maybe<Order_By>;
  tenant_group_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Cicd_Deployment_Pool_Member_Min_Fields = {
  __typename?: 'cicd_deployment_pool_member_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  pool_name?: Maybe<Scalars['String']>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "cicd.deployment_pool_member" */
export type Cicd_Deployment_Pool_Member_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  pool_name?: Maybe<Order_By>;
  tenant_group_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "cicd.deployment_pool_member" */
export type Cicd_Deployment_Pool_Member_Mutation_Response = {
  __typename?: 'cicd_deployment_pool_member_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Cicd_Deployment_Pool_Member>;
};

/** Ordering options when selecting data from "cicd.deployment_pool_member". */
export type Cicd_Deployment_Pool_Member_Order_By = {
  created_at?: Maybe<Order_By>;
  pool?: Maybe<Cicd_Deployment_Pool_Order_By>;
  pool_name?: Maybe<Order_By>;
  tenant_group?: Maybe<Tenant_Group_Order_By>;
  tenant_group_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "cicd.deployment_pool_member" */
export enum Cicd_Deployment_Pool_Member_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  PoolName = 'pool_name',
  /** column name */
  TenantGroupId = 'tenant_group_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "cicd.deployment_pool_member" */
export type Cicd_Deployment_Pool_Member_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  pool_name?: Maybe<Scalars['String']>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "cicd_deployment_pool_member" */
export type Cicd_Deployment_Pool_Member_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Cicd_Deployment_Pool_Member_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Cicd_Deployment_Pool_Member_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  pool_name?: Maybe<Scalars['String']>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

export type Cicd_Deployment_Pool_Member_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Cicd_Deployment_Pool_Member_Set_Input>;
  /** filter the rows which have to be updated */
  where: Cicd_Deployment_Pool_Member_Bool_Exp;
};

/** aggregate min on columns */
export type Cicd_Deployment_Pool_Min_Fields = {
  __typename?: 'cicd_deployment_pool_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "cicd.deployment_pool" */
export type Cicd_Deployment_Pool_Mutation_Response = {
  __typename?: 'cicd_deployment_pool_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Cicd_Deployment_Pool>;
};

/** input type for inserting object relation for remote table "cicd.deployment_pool" */
export type Cicd_Deployment_Pool_Obj_Rel_Insert_Input = {
  data: Cicd_Deployment_Pool_Insert_Input;
};

/** Ordering options when selecting data from "cicd.deployment_pool". */
export type Cicd_Deployment_Pool_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  is_exclusive_pool?: Maybe<Order_By>;
  members_aggregate?: Maybe<Cicd_Deployment_Pool_Member_Aggregate_Order_By>;
  name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** select columns of table "cicd.deployment_pool" */
export enum Cicd_Deployment_Pool_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  IsExclusivePool = 'is_exclusive_pool',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "cicd.deployment_pool" */
export type Cicd_Deployment_Pool_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  is_exclusive_pool?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "cicd_deployment_pool" */
export type Cicd_Deployment_Pool_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Cicd_Deployment_Pool_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Cicd_Deployment_Pool_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  is_exclusive_pool?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

export type Cicd_Deployment_Pool_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Cicd_Deployment_Pool_Set_Input>;
  /** filter the rows which have to be updated */
  where: Cicd_Deployment_Pool_Bool_Exp;
};

export type Cicd_Get_Matching_Pipeline_Config_Args = {
  branch?: Maybe<Scalars['String']>;
  pull_request?: Maybe<Scalars['String']>;
  tag?: Maybe<Scalars['String']>;
};

/** Boolean expression to compare columns of type "citext". All fields are combined with logical 'AND'. */
export type Citext_Comparison_Exp = {
  _eq?: Maybe<Scalars['citext']>;
  _gt?: Maybe<Scalars['citext']>;
  _gte?: Maybe<Scalars['citext']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: Maybe<Scalars['citext']>;
  _in?: Maybe<Array<Scalars['citext']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: Maybe<Scalars['citext']>;
  _is_null?: Maybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: Maybe<Scalars['citext']>;
  _lt?: Maybe<Scalars['citext']>;
  _lte?: Maybe<Scalars['citext']>;
  _neq?: Maybe<Scalars['citext']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: Maybe<Scalars['citext']>;
  _nin?: Maybe<Array<Scalars['citext']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: Maybe<Scalars['citext']>;
  /** does the column NOT match the given pattern */
  _nlike?: Maybe<Scalars['citext']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: Maybe<Scalars['citext']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: Maybe<Scalars['citext']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: Maybe<Scalars['citext']>;
  /** does the column match the given SQL regular expression */
  _similar?: Maybe<Scalars['citext']>;
};

export type ClientSecretInfo = {
  __typename?: 'clientSecretInfo';
  client_secret: Scalars['String'];
};

/** Hasura enum to define cloud provider. This enum is used in the tenant table. */
export type Cloud = {
  __typename?: 'cloud';
  description: Scalars['String'];
  name: Scalars['String'];
};

/** aggregated selection of "cloud" */
export type Cloud_Aggregate = {
  __typename?: 'cloud_aggregate';
  aggregate?: Maybe<Cloud_Aggregate_Fields>;
  nodes: Array<Cloud>;
};

/** aggregate fields of "cloud" */
export type Cloud_Aggregate_Fields = {
  __typename?: 'cloud_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Cloud_Max_Fields>;
  min?: Maybe<Cloud_Min_Fields>;
};

/** aggregate fields of "cloud" */
export type Cloud_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Cloud_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "cloud". All fields are combined with a logical 'AND'. */
export type Cloud_Bool_Exp = {
  _and?: Maybe<Array<Cloud_Bool_Exp>>;
  _not?: Maybe<Cloud_Bool_Exp>;
  _or?: Maybe<Array<Cloud_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "cloud" */
export enum Cloud_Constraint {
  /** unique or primary key constraint on columns "name" */
  CloudPkey = 'cloud_pkey',
}

export enum Cloud_Enum {
  /** Amazon Web Services */
  Aws = 'aws',
  /** Microsoft Azure */
  Azure = 'azure',
  /** Digital Ocean */
  Do = 'do',
  /** Google Cloud Platform */
  Gcp = 'gcp',
}

/** Boolean expression to compare columns of type "cloud_enum". All fields are combined with logical 'AND'. */
export type Cloud_Enum_Comparison_Exp = {
  _eq?: Maybe<Cloud_Enum>;
  _in?: Maybe<Array<Cloud_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Cloud_Enum>;
  _nin?: Maybe<Array<Cloud_Enum>>;
};

/** input type for inserting data into table "cloud" */
export type Cloud_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Cloud_Max_Fields = {
  __typename?: 'cloud_max_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** columns and relationships of "cloud_metadata" */
export type Cloud_Metadata = {
  __typename?: 'cloud_metadata';
  /** Get AWS Account ID for Hasura Cloud */
  aws_account_id?: Maybe<Scalars['String']>;
  cloud: Cloud_Enum;
  metadata: Scalars['jsonb'];
};

/** columns and relationships of "cloud_metadata" */
export type Cloud_MetadataMetadataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "cloud_metadata" */
export type Cloud_Metadata_Aggregate = {
  __typename?: 'cloud_metadata_aggregate';
  aggregate?: Maybe<Cloud_Metadata_Aggregate_Fields>;
  nodes: Array<Cloud_Metadata>;
};

/** aggregate fields of "cloud_metadata" */
export type Cloud_Metadata_Aggregate_Fields = {
  __typename?: 'cloud_metadata_aggregate_fields';
  count: Scalars['Int'];
};

/** aggregate fields of "cloud_metadata" */
export type Cloud_Metadata_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Cloud_Metadata_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Cloud_Metadata_Append_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "cloud_metadata". All fields are combined with a logical 'AND'. */
export type Cloud_Metadata_Bool_Exp = {
  _and?: Maybe<Array<Cloud_Metadata_Bool_Exp>>;
  _not?: Maybe<Cloud_Metadata_Bool_Exp>;
  _or?: Maybe<Array<Cloud_Metadata_Bool_Exp>>;
  aws_account_id?: Maybe<String_Comparison_Exp>;
  cloud?: Maybe<Cloud_Enum_Comparison_Exp>;
  metadata?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "cloud_metadata" */
export enum Cloud_Metadata_Constraint {
  /** unique or primary key constraint on columns "cloud" */
  CloudMetadataPkey = 'cloud_metadata_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Cloud_Metadata_Delete_At_Path_Input = {
  metadata?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Cloud_Metadata_Delete_Elem_Input = {
  metadata?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Cloud_Metadata_Delete_Key_Input = {
  metadata?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "cloud_metadata" */
export type Cloud_Metadata_Insert_Input = {
  cloud?: Maybe<Cloud_Enum>;
  metadata?: Maybe<Scalars['jsonb']>;
};

/** response of any mutation on the table "cloud_metadata" */
export type Cloud_Metadata_Mutation_Response = {
  __typename?: 'cloud_metadata_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Cloud_Metadata>;
};

/** on_conflict condition type for table "cloud_metadata" */
export type Cloud_Metadata_On_Conflict = {
  constraint: Cloud_Metadata_Constraint;
  update_columns?: Array<Cloud_Metadata_Update_Column>;
  where?: Maybe<Cloud_Metadata_Bool_Exp>;
};

/** Ordering options when selecting data from "cloud_metadata". */
export type Cloud_Metadata_Order_By = {
  aws_account_id?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  metadata?: Maybe<Order_By>;
};

/** primary key columns input for table: cloud_metadata */
export type Cloud_Metadata_Pk_Columns_Input = {
  cloud: Cloud_Enum;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Cloud_Metadata_Prepend_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "cloud_metadata" */
export enum Cloud_Metadata_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  Metadata = 'metadata',
}

/** input type for updating data in table "cloud_metadata" */
export type Cloud_Metadata_Set_Input = {
  cloud?: Maybe<Cloud_Enum>;
  metadata?: Maybe<Scalars['jsonb']>;
};

/** Streaming cursor of the table "cloud_metadata" */
export type Cloud_Metadata_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Cloud_Metadata_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Cloud_Metadata_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Cloud_Enum>;
  metadata?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "cloud_metadata" */
export enum Cloud_Metadata_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  Metadata = 'metadata',
}

export type Cloud_Metadata_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Cloud_Metadata_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Cloud_Metadata_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Cloud_Metadata_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Cloud_Metadata_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Cloud_Metadata_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Cloud_Metadata_Set_Input>;
  /** filter the rows which have to be updated */
  where: Cloud_Metadata_Bool_Exp;
};

/** aggregate min on columns */
export type Cloud_Min_Fields = {
  __typename?: 'cloud_min_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "cloud" */
export type Cloud_Mutation_Response = {
  __typename?: 'cloud_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Cloud>;
};

/** on_conflict condition type for table "cloud" */
export type Cloud_On_Conflict = {
  constraint: Cloud_Constraint;
  update_columns?: Array<Cloud_Update_Column>;
  where?: Maybe<Cloud_Bool_Exp>;
};

/** Ordering options when selecting data from "cloud". */
export type Cloud_Order_By = {
  description?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** primary key columns input for table: cloud */
export type Cloud_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** columns and relationships of "cloud_regions_by_plan" */
export type Cloud_Regions_By_Plan = {
  __typename?: 'cloud_regions_by_plan';
  cloud?: Maybe<Scalars['String']>;
  infra_status?: Maybe<Scalars['String']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  is_active?: Maybe<Scalars['Boolean']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  plan_name?: Maybe<Scalars['String']>;
  /** An object relationship */
  region?: Maybe<Region>;
};

/** columns and relationships of "cloud_regions_by_plan" */
export type Cloud_Regions_By_PlanInput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "cloud_regions_by_plan" */
export type Cloud_Regions_By_PlanOutput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "cloud_regions_by_plan" */
export type Cloud_Regions_By_Plan_Aggregate = {
  __typename?: 'cloud_regions_by_plan_aggregate';
  aggregate?: Maybe<Cloud_Regions_By_Plan_Aggregate_Fields>;
  nodes: Array<Cloud_Regions_By_Plan>;
};

/** aggregate fields of "cloud_regions_by_plan" */
export type Cloud_Regions_By_Plan_Aggregate_Fields = {
  __typename?: 'cloud_regions_by_plan_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Cloud_Regions_By_Plan_Max_Fields>;
  min?: Maybe<Cloud_Regions_By_Plan_Min_Fields>;
};

/** aggregate fields of "cloud_regions_by_plan" */
export type Cloud_Regions_By_Plan_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Cloud_Regions_By_Plan_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "cloud_regions_by_plan". All fields are combined with a logical 'AND'. */
export type Cloud_Regions_By_Plan_Bool_Exp = {
  _and?: Maybe<Array<Cloud_Regions_By_Plan_Bool_Exp>>;
  _not?: Maybe<Cloud_Regions_By_Plan_Bool_Exp>;
  _or?: Maybe<Array<Cloud_Regions_By_Plan_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  infra_status?: Maybe<String_Comparison_Exp>;
  input_variables?: Maybe<Jsonb_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  metrics_fqdn?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  nat_ip?: Maybe<String_Comparison_Exp>;
  output_variables?: Maybe<Jsonb_Comparison_Exp>;
  plan_name?: Maybe<String_Comparison_Exp>;
  region?: Maybe<Region_Bool_Exp>;
};

/** aggregate max on columns */
export type Cloud_Regions_By_Plan_Max_Fields = {
  __typename?: 'cloud_regions_by_plan_max_fields';
  cloud?: Maybe<Scalars['String']>;
  infra_status?: Maybe<Scalars['String']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  plan_name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Cloud_Regions_By_Plan_Min_Fields = {
  __typename?: 'cloud_regions_by_plan_min_fields';
  cloud?: Maybe<Scalars['String']>;
  infra_status?: Maybe<Scalars['String']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  plan_name?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "cloud_regions_by_plan". */
export type Cloud_Regions_By_Plan_Order_By = {
  cloud?: Maybe<Order_By>;
  infra_status?: Maybe<Order_By>;
  input_variables?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  metrics_fqdn?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  nat_ip?: Maybe<Order_By>;
  output_variables?: Maybe<Order_By>;
  plan_name?: Maybe<Order_By>;
  region?: Maybe<Region_Order_By>;
};

/** select columns of table "cloud_regions_by_plan" */
export enum Cloud_Regions_By_Plan_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  MetricsFqdn = 'metrics_fqdn',
  /** column name */
  Name = 'name',
  /** column name */
  NatIp = 'nat_ip',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  PlanName = 'plan_name',
}

/** Streaming cursor of the table "cloud_regions_by_plan" */
export type Cloud_Regions_By_Plan_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Cloud_Regions_By_Plan_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Cloud_Regions_By_Plan_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  infra_status?: Maybe<Scalars['String']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  is_active?: Maybe<Scalars['Boolean']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  plan_name?: Maybe<Scalars['String']>;
};

/** select columns of table "cloud" */
export enum Cloud_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

/** input type for updating data in table "cloud" */
export type Cloud_Set_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "cloud" */
export type Cloud_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Cloud_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Cloud_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** update columns of table "cloud" */
export enum Cloud_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

export type Cloud_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Cloud_Set_Input>;
  /** filter the rows which have to be updated */
  where: Cloud_Bool_Exp;
};

export enum CloudProvider {
  Aws = 'aws',
  Azure = 'azure',
  Gcp = 'gcp',
}

export type Compute_Project_Agg_Db_Usage_User_Args = {
  from_time?: Maybe<Scalars['timestamptz']>;
  to_time?: Maybe<Scalars['timestamptz']>;
  user_ids?: Maybe<Scalars['_uuid']>;
};

export type Compute_Project_Agg_Usage_Args = {
  from_time?: Maybe<Scalars['timestamptz']>;
  project_ids?: Maybe<Scalars['_uuid']>;
  to_time?: Maybe<Scalars['timestamptz']>;
};

export type Compute_Project_Agg_Usage_Prometheus_Args = {
  from_time?: Maybe<Scalars['timestamptz']>;
  project_ids?: Maybe<Scalars['_uuid']>;
  to_time?: Maybe<Scalars['timestamptz']>;
};

export type Compute_Project_Agg_Usage_Prometheus_User_Args = {
  from_time?: Maybe<Scalars['timestamptz']>;
  to_time?: Maybe<Scalars['timestamptz']>;
  user_ids?: Maybe<Scalars['_uuid']>;
};

export type Compute_Project_Agg_Usage_User_Args = {
  from_time?: Maybe<Scalars['timestamptz']>;
  to_time?: Maybe<Scalars['timestamptz']>;
  user_ids?: Maybe<Scalars['_uuid']>;
};

/**
 * capture compute unit configuration per cluster and allows for sharing between
 * cluster. Compute units are adhered to by the node pools or cluster autoscaling configuration
 */
export type Compute_Unit_Config = {
  __typename?: 'compute_unit_config';
  /** An object relationship */
  cluster?: Maybe<Hasura_Cluster>;
  config?: Maybe<Scalars['jsonb']>;
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An array relationship */
  usage: Array<Dedicated_Cloud_Bills>;
  /** An aggregate relationship */
  usage_aggregate: Dedicated_Cloud_Bills_Aggregate;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id: Scalars['uuid'];
};

/**
 * capture compute unit configuration per cluster and allows for sharing between
 * cluster. Compute units are adhered to by the node pools or cluster autoscaling configuration
 */
export type Compute_Unit_ConfigConfigArgs = {
  path?: Maybe<Scalars['String']>;
};

/**
 * capture compute unit configuration per cluster and allows for sharing between
 * cluster. Compute units are adhered to by the node pools or cluster autoscaling configuration
 */
export type Compute_Unit_ConfigUsageArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
};

/**
 * capture compute unit configuration per cluster and allows for sharing between
 * cluster. Compute units are adhered to by the node pools or cluster autoscaling configuration
 */
export type Compute_Unit_ConfigUsage_AggregateArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
};

/** aggregated selection of "compute_unit_config" */
export type Compute_Unit_Config_Aggregate = {
  __typename?: 'compute_unit_config_aggregate';
  aggregate?: Maybe<Compute_Unit_Config_Aggregate_Fields>;
  nodes: Array<Compute_Unit_Config>;
};

/** aggregate fields of "compute_unit_config" */
export type Compute_Unit_Config_Aggregate_Fields = {
  __typename?: 'compute_unit_config_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Compute_Unit_Config_Max_Fields>;
  min?: Maybe<Compute_Unit_Config_Min_Fields>;
};

/** aggregate fields of "compute_unit_config" */
export type Compute_Unit_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Compute_Unit_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Compute_Unit_Config_Append_Input = {
  config?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "compute_unit_config". All fields are combined with a logical 'AND'. */
export type Compute_Unit_Config_Bool_Exp = {
  _and?: Maybe<Array<Compute_Unit_Config_Bool_Exp>>;
  _not?: Maybe<Compute_Unit_Config_Bool_Exp>;
  _or?: Maybe<Array<Compute_Unit_Config_Bool_Exp>>;
  cluster?: Maybe<Hasura_Cluster_Bool_Exp>;
  config?: Maybe<Jsonb_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  usage?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
  usage_aggregate?: Maybe<Dedicated_Cloud_Bills_Aggregate_Bool_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "compute_unit_config" */
export enum Compute_Unit_Config_Constraint {
  /** unique or primary key constraint on columns "id" */
  ComputeUnitConfigPkey = 'compute_unit_config_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Compute_Unit_Config_Delete_At_Path_Input = {
  config?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Compute_Unit_Config_Delete_Elem_Input = {
  config?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Compute_Unit_Config_Delete_Key_Input = {
  config?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "compute_unit_config" */
export type Compute_Unit_Config_Insert_Input = {
  cluster?: Maybe<Hasura_Cluster_Obj_Rel_Insert_Input>;
  config?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  usage?: Maybe<Dedicated_Cloud_Bills_Arr_Rel_Insert_Input>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Compute_Unit_Config_Max_Fields = {
  __typename?: 'compute_unit_config_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Compute_Unit_Config_Min_Fields = {
  __typename?: 'compute_unit_config_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "compute_unit_config" */
export type Compute_Unit_Config_Mutation_Response = {
  __typename?: 'compute_unit_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Compute_Unit_Config>;
};

/** input type for inserting object relation for remote table "compute_unit_config" */
export type Compute_Unit_Config_Obj_Rel_Insert_Input = {
  data: Compute_Unit_Config_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Compute_Unit_Config_On_Conflict>;
};

/** on_conflict condition type for table "compute_unit_config" */
export type Compute_Unit_Config_On_Conflict = {
  constraint: Compute_Unit_Config_Constraint;
  update_columns?: Array<Compute_Unit_Config_Update_Column>;
  where?: Maybe<Compute_Unit_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "compute_unit_config". */
export type Compute_Unit_Config_Order_By = {
  cluster?: Maybe<Hasura_Cluster_Order_By>;
  config?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  usage_aggregate?: Maybe<Dedicated_Cloud_Bills_Aggregate_Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: compute_unit_config */
export type Compute_Unit_Config_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Compute_Unit_Config_Prepend_Input = {
  config?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "compute_unit_config" */
export enum Compute_Unit_Config_Select_Column {
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "compute_unit_config" */
export type Compute_Unit_Config_Set_Input = {
  config?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "compute_unit_config" */
export type Compute_Unit_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Compute_Unit_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Compute_Unit_Config_Stream_Cursor_Value_Input = {
  config?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "compute_unit_config" */
export enum Compute_Unit_Config_Update_Column {
  /** column name */
  Config = 'config',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  UserId = 'user_id',
}

export type Compute_Unit_Config_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Compute_Unit_Config_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Compute_Unit_Config_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Compute_Unit_Config_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Compute_Unit_Config_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Compute_Unit_Config_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Compute_Unit_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Compute_Unit_Config_Bool_Exp;
};

export type ComputeUnitCountResponse = {
  __typename?: 'ComputeUnitCountResponse';
  cloud: CloudProvider;
  cluster_id: Scalars['String'];
  values: Array<Maybe<GranularComputeUnitCount>>;
};

export type ComputeUnitUsageResponse = {
  __typename?: 'ComputeUnitUsageResponse';
  cloud: CloudProvider;
  cluster_id: Scalars['String'];
  values?: Maybe<Array<Maybe<GranularComputeUnitUsagePercentage>>>;
};

/** Metadata for tenant config in vault */
export type Config = {
  __typename?: 'config';
  hash: Scalars['String'];
  /** An array relationship */
  status: Array<Config_Status>;
  /** An aggregate relationship */
  status_aggregate: Config_Status_Aggregate;
  /** An object relationship */
  tenant: Tenant;
  tenant_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
  vault_path: Scalars['String'];
};

/** Metadata for tenant config in vault */
export type ConfigStatusArgs = {
  distinct_on?: Maybe<Array<Config_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Status_Order_By>>;
  where?: Maybe<Config_Status_Bool_Exp>;
};

/** Metadata for tenant config in vault */
export type ConfigStatus_AggregateArgs = {
  distinct_on?: Maybe<Array<Config_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Status_Order_By>>;
  where?: Maybe<Config_Status_Bool_Exp>;
};

/** aggregated selection of "config" */
export type Config_Aggregate = {
  __typename?: 'config_aggregate';
  aggregate?: Maybe<Config_Aggregate_Fields>;
  nodes: Array<Config>;
};

/** aggregate fields of "config" */
export type Config_Aggregate_Fields = {
  __typename?: 'config_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Config_Max_Fields>;
  min?: Maybe<Config_Min_Fields>;
};

/** aggregate fields of "config" */
export type Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "config". All fields are combined with a logical 'AND'. */
export type Config_Bool_Exp = {
  _and?: Maybe<Array<Config_Bool_Exp>>;
  _not?: Maybe<Config_Bool_Exp>;
  _or?: Maybe<Array<Config_Bool_Exp>>;
  hash?: Maybe<String_Comparison_Exp>;
  status?: Maybe<Config_Status_Bool_Exp>;
  status_aggregate?: Maybe<Config_Status_Aggregate_Bool_Exp>;
  tenant?: Maybe<Tenant_Bool_Exp>;
  tenant_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  vault_path?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "config" */
export enum Config_Constraint {
  /** unique or primary key constraint on columns "tenant_id" */
  ConfigPkey = 'config_pkey',
  /** unique or primary key constraint on columns "tenant_id" */
  ConfigTenantIdKey = 'config_tenant_id_key',
}

/** input type for inserting data into table "config" */
export type Config_Insert_Input = {
  hash?: Maybe<Scalars['String']>;
  status?: Maybe<Config_Status_Arr_Rel_Insert_Input>;
  tenant?: Maybe<Tenant_Obj_Rel_Insert_Input>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vault_path?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Config_Max_Fields = {
  __typename?: 'config_max_fields';
  hash?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vault_path?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Config_Min_Fields = {
  __typename?: 'config_min_fields';
  hash?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vault_path?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "config" */
export type Config_Mutation_Response = {
  __typename?: 'config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Config>;
};

/** input type for inserting object relation for remote table "config" */
export type Config_Obj_Rel_Insert_Input = {
  data: Config_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Config_On_Conflict>;
};

/** on_conflict condition type for table "config" */
export type Config_On_Conflict = {
  constraint: Config_Constraint;
  update_columns?: Array<Config_Update_Column>;
  where?: Maybe<Config_Bool_Exp>;
};

/** Ordering options when selecting data from "config". */
export type Config_Order_By = {
  hash?: Maybe<Order_By>;
  status_aggregate?: Maybe<Config_Status_Aggregate_Order_By>;
  tenant?: Maybe<Tenant_Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  vault_path?: Maybe<Order_By>;
};

/** primary key columns input for table: config */
export type Config_Pk_Columns_Input = {
  tenant_id: Scalars['uuid'];
};

/** select columns of table "config" */
export enum Config_Select_Column {
  /** column name */
  Hash = 'hash',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VaultPath = 'vault_path',
}

/** input type for updating data in table "config" */
export type Config_Set_Input = {
  hash?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vault_path?: Maybe<Scalars['String']>;
};

/** Status of a given tenant config by hasura worker */
export type Config_Status = {
  __typename?: 'config_status';
  hash: Scalars['String'];
  is_active: Scalars['Boolean'];
  message?: Maybe<Scalars['String']>;
  /** An object relationship */
  tenant: Tenant;
  tenant_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
  worker_id: Scalars['uuid'];
  /** A computed field, executes function "config_status_worker_state" */
  worker_state?: Maybe<Scalars['String']>;
};

/** aggregated selection of "config_status" */
export type Config_Status_Aggregate = {
  __typename?: 'config_status_aggregate';
  aggregate?: Maybe<Config_Status_Aggregate_Fields>;
  nodes: Array<Config_Status>;
};

export type Config_Status_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Config_Status_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Config_Status_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Config_Status_Aggregate_Bool_Exp_Count>;
};

export type Config_Status_Aggregate_Bool_Exp_Bool_And = {
  arguments: Config_Status_Select_Column_Config_Status_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Config_Status_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Config_Status_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Config_Status_Select_Column_Config_Status_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Config_Status_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Config_Status_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Config_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Config_Status_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "config_status" */
export type Config_Status_Aggregate_Fields = {
  __typename?: 'config_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Config_Status_Max_Fields>;
  min?: Maybe<Config_Status_Min_Fields>;
};

/** aggregate fields of "config_status" */
export type Config_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Config_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "config_status" */
export type Config_Status_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Config_Status_Max_Order_By>;
  min?: Maybe<Config_Status_Min_Order_By>;
};

/** input type for inserting array relation for remote table "config_status" */
export type Config_Status_Arr_Rel_Insert_Input = {
  data: Array<Config_Status_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Config_Status_On_Conflict>;
};

/** Boolean expression to filter rows from the table "config_status". All fields are combined with a logical 'AND'. */
export type Config_Status_Bool_Exp = {
  _and?: Maybe<Array<Config_Status_Bool_Exp>>;
  _not?: Maybe<Config_Status_Bool_Exp>;
  _or?: Maybe<Array<Config_Status_Bool_Exp>>;
  hash?: Maybe<String_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  message?: Maybe<String_Comparison_Exp>;
  tenant?: Maybe<Tenant_Bool_Exp>;
  tenant_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  worker_id?: Maybe<Uuid_Comparison_Exp>;
  worker_state?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "config_status" */
export enum Config_Status_Constraint {
  /** unique or primary key constraint on columns "tenant_id", "hash", "worker_id" */
  ConfigStatusPkey = 'config_status_pkey',
}

/** input type for inserting data into table "config_status" */
export type Config_Status_Insert_Input = {
  hash?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  tenant?: Maybe<Tenant_Obj_Rel_Insert_Input>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Config_Status_Max_Fields = {
  __typename?: 'config_status_max_fields';
  hash?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "config_status" */
export type Config_Status_Max_Order_By = {
  hash?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Config_Status_Min_Fields = {
  __typename?: 'config_status_min_fields';
  hash?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "config_status" */
export type Config_Status_Min_Order_By = {
  hash?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "config_status" */
export type Config_Status_Mutation_Response = {
  __typename?: 'config_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Config_Status>;
};

/** on_conflict condition type for table "config_status" */
export type Config_Status_On_Conflict = {
  constraint: Config_Status_Constraint;
  update_columns?: Array<Config_Status_Update_Column>;
  where?: Maybe<Config_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "config_status". */
export type Config_Status_Order_By = {
  hash?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  tenant?: Maybe<Tenant_Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
  worker_state?: Maybe<Order_By>;
};

/** primary key columns input for table: config_status */
export type Config_Status_Pk_Columns_Input = {
  hash: Scalars['String'];
  tenant_id: Scalars['uuid'];
  worker_id: Scalars['uuid'];
};

/** select columns of table "config_status" */
export enum Config_Status_Select_Column {
  /** column name */
  Hash = 'hash',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Message = 'message',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WorkerId = 'worker_id',
}

/** select "config_status_aggregate_bool_exp_bool_and_arguments_columns" columns of table "config_status" */
export enum Config_Status_Select_Column_Config_Status_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsActive = 'is_active',
}

/** select "config_status_aggregate_bool_exp_bool_or_arguments_columns" columns of table "config_status" */
export enum Config_Status_Select_Column_Config_Status_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsActive = 'is_active',
}

/** input type for updating data in table "config_status" */
export type Config_Status_Set_Input = {
  hash?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "config_status" */
export type Config_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Config_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Config_Status_Stream_Cursor_Value_Input = {
  hash?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "config_status" */
export enum Config_Status_Update_Column {
  /** column name */
  Hash = 'hash',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Message = 'message',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WorkerId = 'worker_id',
}

export type Config_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Config_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Config_Status_Bool_Exp;
};

/** Streaming cursor of the table "config" */
export type Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Config_Stream_Cursor_Value_Input = {
  hash?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vault_path?: Maybe<Scalars['String']>;
};

/** update columns of table "config" */
export enum Config_Update_Column {
  /** column name */
  Hash = 'hash',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VaultPath = 'vault_path',
}

export type Config_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Config_Bool_Exp;
};

/** This table contains configuration of custom connectors added by users.  */
export type Connector_Config = {
  __typename?: 'connector_config';
  created_at: Scalars['timestamptz'];
  created_by: Scalars['uuid'];
  deployment_url?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  is_deleted: Scalars['Boolean'];
  name: Scalars['String'];
  project_id: Scalars['uuid'];
  source_url: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "connector_config" */
export type Connector_Config_Aggregate = {
  __typename?: 'connector_config_aggregate';
  aggregate?: Maybe<Connector_Config_Aggregate_Fields>;
  nodes: Array<Connector_Config>;
};

/** aggregate fields of "connector_config" */
export type Connector_Config_Aggregate_Fields = {
  __typename?: 'connector_config_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Connector_Config_Max_Fields>;
  min?: Maybe<Connector_Config_Min_Fields>;
};

/** aggregate fields of "connector_config" */
export type Connector_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Connector_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "connector_config". All fields are combined with a logical 'AND'. */
export type Connector_Config_Bool_Exp = {
  _and?: Maybe<Array<Connector_Config_Bool_Exp>>;
  _not?: Maybe<Connector_Config_Bool_Exp>;
  _or?: Maybe<Array<Connector_Config_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  created_by?: Maybe<Uuid_Comparison_Exp>;
  deployment_url?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_deleted?: Maybe<Boolean_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  source_url?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "connector_config" */
export enum Connector_Config_Constraint {
  /** unique or primary key constraint on columns "name" */
  ConnectorConfigNameKey = 'connector_config_name_key',
  /** unique or primary key constraint on columns "id" */
  ConnectorConfigPkey = 'connector_config_pkey',
}

/** input type for inserting data into table "connector_config" */
export type Connector_Config_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  deployment_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_deleted?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  source_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Connector_Config_Max_Fields = {
  __typename?: 'connector_config_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  deployment_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  source_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Connector_Config_Min_Fields = {
  __typename?: 'connector_config_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  deployment_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  source_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "connector_config" */
export type Connector_Config_Mutation_Response = {
  __typename?: 'connector_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Connector_Config>;
};

/** on_conflict condition type for table "connector_config" */
export type Connector_Config_On_Conflict = {
  constraint: Connector_Config_Constraint;
  update_columns?: Array<Connector_Config_Update_Column>;
  where?: Maybe<Connector_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "connector_config". */
export type Connector_Config_Order_By = {
  created_at?: Maybe<Order_By>;
  created_by?: Maybe<Order_By>;
  deployment_url?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_deleted?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  source_url?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: connector_config */
export type Connector_Config_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "connector_config" */
export enum Connector_Config_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DeploymentUrl = 'deployment_url',
  /** column name */
  Id = 'id',
  /** column name */
  IsDeleted = 'is_deleted',
  /** column name */
  Name = 'name',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  SourceUrl = 'source_url',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "connector_config" */
export type Connector_Config_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  deployment_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_deleted?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  source_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "connector_config" */
export type Connector_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Connector_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Connector_Config_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  deployment_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_deleted?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  source_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "connector_config" */
export enum Connector_Config_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  DeploymentUrl = 'deployment_url',
  /** column name */
  Id = 'id',
  /** column name */
  IsDeleted = 'is_deleted',
  /** column name */
  Name = 'name',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  SourceUrl = 'source_url',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Connector_Config_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Connector_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Connector_Config_Bool_Exp;
};

/** This table contains configuration of custom connectors deployed by users.  */
export type Connector_Connector_Deployment = {
  __typename?: 'connector_connector_deployment';
  build_logs_url?: Maybe<Scalars['String']>;
  cloud_run_url?: Maybe<Scalars['String']>;
  config_file?: Maybe<Scalars['String']>;
  created_at: Scalars['connector_timestamptz'];
  created_by: Scalars['connector_uuid'];
  error?: Maybe<Scalars['String']>;
  gcs_url?: Maybe<Scalars['String']>;
  id: Scalars['connector_uuid'];
  image_url?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  source_url: Scalars['String'];
  status: Scalars['connector_deployment_status'];
  updated_at: Scalars['connector_timestamptz'];
  user_id: Scalars['connector_uuid'];
};

/** aggregated selection of "connector_deployment" */
export type Connector_Connector_Deployment_Aggregate = {
  __typename?: 'connector_connector_deployment_aggregate';
  aggregate?: Maybe<Connector_Connector_Deployment_Aggregate_Fields>;
  nodes: Array<Connector_Connector_Deployment>;
};

/** aggregate fields of "connector_deployment" */
export type Connector_Connector_Deployment_Aggregate_Fields = {
  __typename?: 'connector_connector_deployment_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Connector_Connector_Deployment_Max_Fields>;
  min?: Maybe<Connector_Connector_Deployment_Min_Fields>;
};

/** aggregate fields of "connector_deployment" */
export type Connector_Connector_Deployment_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Connector_Connector_Deployment_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "connector_deployment". All fields are combined with a logical 'AND'. */
export type Connector_Connector_Deployment_Bool_Exp = {
  _and?: Maybe<Array<Connector_Connector_Deployment_Bool_Exp>>;
  _not?: Maybe<Connector_Connector_Deployment_Bool_Exp>;
  _or?: Maybe<Array<Connector_Connector_Deployment_Bool_Exp>>;
  build_logs_url?: Maybe<Connector_String_Comparison_Exp>;
  cloud_run_url?: Maybe<Connector_String_Comparison_Exp>;
  config_file?: Maybe<Connector_String_Comparison_Exp>;
  created_at?: Maybe<Connector_Timestamptz_Comparison_Exp>;
  created_by?: Maybe<Connector_Uuid_Comparison_Exp>;
  error?: Maybe<Connector_String_Comparison_Exp>;
  gcs_url?: Maybe<Connector_String_Comparison_Exp>;
  id?: Maybe<Connector_Uuid_Comparison_Exp>;
  image_url?: Maybe<Connector_String_Comparison_Exp>;
  name?: Maybe<Connector_String_Comparison_Exp>;
  source_url?: Maybe<Connector_String_Comparison_Exp>;
  status?: Maybe<Connector_Deployment_Status_Comparison_Exp>;
  updated_at?: Maybe<Connector_Timestamptz_Comparison_Exp>;
  user_id?: Maybe<Connector_Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "connector_deployment" */
export enum Connector_Connector_Deployment_Constraint {
  /** unique or primary key constraint on columns "id" */
  ConnectorDeploymentPkey = 'connector_deployment_pkey',
  /** unique or primary key constraint on columns "user_id", "name" */
  UniqueNameWithinUser = 'unique_name_within_user',
}

/** input type for inserting data into table "connector_deployment" */
export type Connector_Connector_Deployment_Insert_Input = {
  build_logs_url?: Maybe<Scalars['String']>;
  cloud_run_url?: Maybe<Scalars['String']>;
  config_file?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['connector_timestamptz']>;
  created_by?: Maybe<Scalars['connector_uuid']>;
  error?: Maybe<Scalars['String']>;
  gcs_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['connector_uuid']>;
  image_url?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  source_url?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['connector_deployment_status']>;
  updated_at?: Maybe<Scalars['connector_timestamptz']>;
  user_id?: Maybe<Scalars['connector_uuid']>;
};

/** aggregate max on columns */
export type Connector_Connector_Deployment_Max_Fields = {
  __typename?: 'connector_connector_deployment_max_fields';
  build_logs_url?: Maybe<Scalars['String']>;
  cloud_run_url?: Maybe<Scalars['String']>;
  config_file?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['connector_timestamptz']>;
  created_by?: Maybe<Scalars['connector_uuid']>;
  error?: Maybe<Scalars['String']>;
  gcs_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['connector_uuid']>;
  image_url?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  source_url?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['connector_deployment_status']>;
  updated_at?: Maybe<Scalars['connector_timestamptz']>;
  user_id?: Maybe<Scalars['connector_uuid']>;
};

/** aggregate min on columns */
export type Connector_Connector_Deployment_Min_Fields = {
  __typename?: 'connector_connector_deployment_min_fields';
  build_logs_url?: Maybe<Scalars['String']>;
  cloud_run_url?: Maybe<Scalars['String']>;
  config_file?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['connector_timestamptz']>;
  created_by?: Maybe<Scalars['connector_uuid']>;
  error?: Maybe<Scalars['String']>;
  gcs_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['connector_uuid']>;
  image_url?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  source_url?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['connector_deployment_status']>;
  updated_at?: Maybe<Scalars['connector_timestamptz']>;
  user_id?: Maybe<Scalars['connector_uuid']>;
};

/** response of any mutation on the table "connector_deployment" */
export type Connector_Connector_Deployment_Mutation_Response = {
  __typename?: 'connector_connector_deployment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Connector_Connector_Deployment>;
};

/** on_conflict condition type for table "connector_deployment" */
export type Connector_Connector_Deployment_On_Conflict = {
  constraint: Connector_Connector_Deployment_Constraint;
  update_columns?: Array<Connector_Connector_Deployment_Update_Column>;
  where?: Maybe<Connector_Connector_Deployment_Bool_Exp>;
};

/** Ordering options when selecting data from "connector_deployment". */
export type Connector_Connector_Deployment_Order_By = {
  build_logs_url?: Maybe<Connector_Order_By>;
  cloud_run_url?: Maybe<Connector_Order_By>;
  config_file?: Maybe<Connector_Order_By>;
  created_at?: Maybe<Connector_Order_By>;
  created_by?: Maybe<Connector_Order_By>;
  error?: Maybe<Connector_Order_By>;
  gcs_url?: Maybe<Connector_Order_By>;
  id?: Maybe<Connector_Order_By>;
  image_url?: Maybe<Connector_Order_By>;
  name?: Maybe<Connector_Order_By>;
  source_url?: Maybe<Connector_Order_By>;
  status?: Maybe<Connector_Order_By>;
  updated_at?: Maybe<Connector_Order_By>;
  user_id?: Maybe<Connector_Order_By>;
};

/** primary key columns input for table: connector_deployment */
export type Connector_Connector_Deployment_Pk_Columns_Input = {
  id: Scalars['connector_uuid'];
};

/** select columns of table "connector_deployment" */
export enum Connector_Connector_Deployment_Select_Column {
  /** column name */
  BuildLogsUrl = 'build_logs_url',
  /** column name */
  CloudRunUrl = 'cloud_run_url',
  /** column name */
  ConfigFile = 'config_file',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Error = 'error',
  /** column name */
  GcsUrl = 'gcs_url',
  /** column name */
  Id = 'id',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  Name = 'name',
  /** column name */
  SourceUrl = 'source_url',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "connector_deployment" */
export type Connector_Connector_Deployment_Set_Input = {
  build_logs_url?: Maybe<Scalars['String']>;
  cloud_run_url?: Maybe<Scalars['String']>;
  config_file?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['connector_timestamptz']>;
  created_by?: Maybe<Scalars['connector_uuid']>;
  error?: Maybe<Scalars['String']>;
  gcs_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['connector_uuid']>;
  image_url?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  source_url?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['connector_deployment_status']>;
  updated_at?: Maybe<Scalars['connector_timestamptz']>;
  user_id?: Maybe<Scalars['connector_uuid']>;
};

/** Streaming cursor of the table "connector_deployment" */
export type Connector_Connector_Deployment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Connector_Connector_Deployment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Connector_Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Connector_Connector_Deployment_Stream_Cursor_Value_Input = {
  build_logs_url?: Maybe<Scalars['String']>;
  cloud_run_url?: Maybe<Scalars['String']>;
  config_file?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['connector_timestamptz']>;
  created_by?: Maybe<Scalars['connector_uuid']>;
  error?: Maybe<Scalars['String']>;
  gcs_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['connector_uuid']>;
  image_url?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  source_url?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['connector_deployment_status']>;
  updated_at?: Maybe<Scalars['connector_timestamptz']>;
  user_id?: Maybe<Scalars['connector_uuid']>;
};

/** update columns of table "connector_deployment" */
export enum Connector_Connector_Deployment_Update_Column {
  /** column name */
  BuildLogsUrl = 'build_logs_url',
  /** column name */
  CloudRunUrl = 'cloud_run_url',
  /** column name */
  ConfigFile = 'config_file',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Error = 'error',
  /** column name */
  GcsUrl = 'gcs_url',
  /** column name */
  Id = 'id',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  Name = 'name',
  /** column name */
  SourceUrl = 'source_url',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

export type Connector_Connector_Deployment_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Connector_Connector_Deployment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Connector_Connector_Deployment_Bool_Exp;
};

/** ordering argument of a cursor */
export enum Connector_Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC',
}

/** Boolean expression to compare columns of type "deployment_status". All fields are combined with logical 'AND'. */
export type Connector_Deployment_Status_Comparison_Exp = {
  _eq?: Maybe<Scalars['connector_deployment_status']>;
  _gt?: Maybe<Scalars['connector_deployment_status']>;
  _gte?: Maybe<Scalars['connector_deployment_status']>;
  _in?: Maybe<Array<Scalars['connector_deployment_status']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['connector_deployment_status']>;
  _lte?: Maybe<Scalars['connector_deployment_status']>;
  _neq?: Maybe<Scalars['connector_deployment_status']>;
  _nin?: Maybe<Array<Scalars['connector_deployment_status']>>;
};

/** Each entry in this table corresponds to a deployment made for a custom connector configure by the user. */
export type Connector_Deployments = {
  __typename?: 'connector_deployments';
  cloud_run_url?: Maybe<Scalars['String']>;
  connector_id: Scalars['uuid'];
  created_at: Scalars['timestamptz'];
  created_by: Scalars['uuid'];
  gcs_url?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  image_url?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "connector_deployments" */
export type Connector_Deployments_Aggregate = {
  __typename?: 'connector_deployments_aggregate';
  aggregate?: Maybe<Connector_Deployments_Aggregate_Fields>;
  nodes: Array<Connector_Deployments>;
};

/** aggregate fields of "connector_deployments" */
export type Connector_Deployments_Aggregate_Fields = {
  __typename?: 'connector_deployments_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Connector_Deployments_Max_Fields>;
  min?: Maybe<Connector_Deployments_Min_Fields>;
};

/** aggregate fields of "connector_deployments" */
export type Connector_Deployments_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Connector_Deployments_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "connector_deployments". All fields are combined with a logical 'AND'. */
export type Connector_Deployments_Bool_Exp = {
  _and?: Maybe<Array<Connector_Deployments_Bool_Exp>>;
  _not?: Maybe<Connector_Deployments_Bool_Exp>;
  _or?: Maybe<Array<Connector_Deployments_Bool_Exp>>;
  cloud_run_url?: Maybe<String_Comparison_Exp>;
  connector_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  created_by?: Maybe<Uuid_Comparison_Exp>;
  gcs_url?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  image_url?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "connector_deployments" */
export enum Connector_Deployments_Constraint {
  /** unique or primary key constraint on columns "id" */
  ConnectorDeploymentsPkey = 'connector_deployments_pkey',
}

/** input type for inserting data into table "connector_deployments" */
export type Connector_Deployments_Insert_Input = {
  cloud_run_url?: Maybe<Scalars['String']>;
  connector_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  gcs_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Connector_Deployments_Max_Fields = {
  __typename?: 'connector_deployments_max_fields';
  cloud_run_url?: Maybe<Scalars['String']>;
  connector_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  gcs_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Connector_Deployments_Min_Fields = {
  __typename?: 'connector_deployments_min_fields';
  cloud_run_url?: Maybe<Scalars['String']>;
  connector_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  gcs_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "connector_deployments" */
export type Connector_Deployments_Mutation_Response = {
  __typename?: 'connector_deployments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Connector_Deployments>;
};

/** on_conflict condition type for table "connector_deployments" */
export type Connector_Deployments_On_Conflict = {
  constraint: Connector_Deployments_Constraint;
  update_columns?: Array<Connector_Deployments_Update_Column>;
  where?: Maybe<Connector_Deployments_Bool_Exp>;
};

/** Ordering options when selecting data from "connector_deployments". */
export type Connector_Deployments_Order_By = {
  cloud_run_url?: Maybe<Order_By>;
  connector_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  created_by?: Maybe<Order_By>;
  gcs_url?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  image_url?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: connector_deployments */
export type Connector_Deployments_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "connector_deployments" */
export enum Connector_Deployments_Select_Column {
  /** column name */
  CloudRunUrl = 'cloud_run_url',
  /** column name */
  ConnectorId = 'connector_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  GcsUrl = 'gcs_url',
  /** column name */
  Id = 'id',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "connector_deployments" */
export type Connector_Deployments_Set_Input = {
  cloud_run_url?: Maybe<Scalars['String']>;
  connector_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  gcs_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "connector_deployments" */
export type Connector_Deployments_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Connector_Deployments_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Connector_Deployments_Stream_Cursor_Value_Input = {
  cloud_run_url?: Maybe<Scalars['String']>;
  connector_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  gcs_url?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image_url?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "connector_deployments" */
export enum Connector_Deployments_Update_Column {
  /** column name */
  CloudRunUrl = 'cloud_run_url',
  /** column name */
  ConnectorId = 'connector_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  GcsUrl = 'gcs_url',
  /** column name */
  Id = 'id',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Connector_Deployments_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Connector_Deployments_Set_Input>;
  /** filter the rows which have to be updated */
  where: Connector_Deployments_Bool_Exp;
};

/** column ordering options */
export enum Connector_Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last',
}

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type Connector_String_Comparison_Exp = {
  _eq?: Maybe<Scalars['String']>;
  _gt?: Maybe<Scalars['String']>;
  _gte?: Maybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: Maybe<Scalars['String']>;
  _in?: Maybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: Maybe<Scalars['String']>;
  _is_null?: Maybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: Maybe<Scalars['String']>;
  _lt?: Maybe<Scalars['String']>;
  _lte?: Maybe<Scalars['String']>;
  _neq?: Maybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: Maybe<Scalars['String']>;
  _nin?: Maybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: Maybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: Maybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: Maybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: Maybe<Scalars['String']>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Connector_Timestamptz_Comparison_Exp = {
  _eq?: Maybe<Scalars['connector_timestamptz']>;
  _gt?: Maybe<Scalars['connector_timestamptz']>;
  _gte?: Maybe<Scalars['connector_timestamptz']>;
  _in?: Maybe<Array<Scalars['connector_timestamptz']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['connector_timestamptz']>;
  _lte?: Maybe<Scalars['connector_timestamptz']>;
  _neq?: Maybe<Scalars['connector_timestamptz']>;
  _nin?: Maybe<Array<Scalars['connector_timestamptz']>>;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Connector_Uuid_Comparison_Exp = {
  _eq?: Maybe<Scalars['connector_uuid']>;
  _gt?: Maybe<Scalars['connector_uuid']>;
  _gte?: Maybe<Scalars['connector_uuid']>;
  _in?: Maybe<Array<Scalars['connector_uuid']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['connector_uuid']>;
  _lte?: Maybe<Scalars['connector_uuid']>;
  _neq?: Maybe<Scalars['connector_uuid']>;
  _nin?: Maybe<Array<Scalars['connector_uuid']>>;
};

export type ConvertPlanResponse = {
  __typename?: 'ConvertPlanResponse';
  status: Scalars['String'];
};

/** Coupon for Hasura Cloud discount */
export type Coupon = {
  __typename?: 'coupon';
  /** email of users which are allowed to use the coupon */
  allowed_customer?: Maybe<Scalars['jsonb']>;
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Int']>;
  /** case insensitive text that represents a unique customer facing code that will be used to get the benefit */
  code: Scalars['citext'];
  /** unique coupon id, represents coupon id at stripe. Internal column */
  coupon_id?: Maybe<Scalars['String']>;
  /** only USD is supported at the moment. Default to USD */
  currency?: Maybe<Scalars['String']>;
  /** represents the duration applicable for a particular coupon. Valid values `once`, `forever`, `repeating` */
  duration?: Maybe<Coupon_Duration_Enum>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Int']>;
  expires_at: Scalars['timestamptz'];
  /** randomly generated uuid */
  id: Scalars['uuid'];
  /**
   * represents the state of a particular coupon, whether it is active and can be
   * redeemed or not. This is a global flag to mark a particular coupon
   * active/inactive probably in the middle of a campaign etc. Defaults to true
   */
  is_active: Scalars['Boolean'];
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions: Scalars['Int'];
  /** represents human readable name for a particular coupon */
  name: Scalars['String'];
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption: Scalars['Int'];
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['numeric']>;
  /** unique id, represents promotion id at stripe. Internal column */
  promotional_code_id?: Maybe<Scalars['String']>;
  stripe_error?: Maybe<Scalars['String']>;
  /** represents the type of a coupon. Valid values are `credit` or `coupon` */
  type: Coupon_Type_Enum;
  /** An array relationship */
  user_coupons: Array<User_Coupon>;
  /** An aggregate relationship */
  user_coupons_aggregate: User_Coupon_Aggregate;
};

/** Coupon for Hasura Cloud discount */
export type CouponAllowed_CustomerArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Coupon for Hasura Cloud discount */
export type CouponUser_CouponsArgs = {
  distinct_on?: Maybe<Array<User_Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Coupon_Order_By>>;
  where?: Maybe<User_Coupon_Bool_Exp>;
};

/** Coupon for Hasura Cloud discount */
export type CouponUser_Coupons_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Coupon_Order_By>>;
  where?: Maybe<User_Coupon_Bool_Exp>;
};

/** aggregated selection of "coupon" */
export type Coupon_Aggregate = {
  __typename?: 'coupon_aggregate';
  aggregate?: Maybe<Coupon_Aggregate_Fields>;
  nodes: Array<Coupon>;
};

export type Coupon_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Coupon_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Coupon_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Coupon_Aggregate_Bool_Exp_Count>;
};

export type Coupon_Aggregate_Bool_Exp_Bool_And = {
  arguments: Coupon_Select_Column_Coupon_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Coupon_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Coupon_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Coupon_Select_Column_Coupon_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Coupon_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Coupon_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Coupon_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Coupon_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "coupon" */
export type Coupon_Aggregate_Fields = {
  __typename?: 'coupon_aggregate_fields';
  avg?: Maybe<Coupon_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Coupon_Max_Fields>;
  min?: Maybe<Coupon_Min_Fields>;
  stddev?: Maybe<Coupon_Stddev_Fields>;
  stddev_pop?: Maybe<Coupon_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Coupon_Stddev_Samp_Fields>;
  sum?: Maybe<Coupon_Sum_Fields>;
  var_pop?: Maybe<Coupon_Var_Pop_Fields>;
  var_samp?: Maybe<Coupon_Var_Samp_Fields>;
  variance?: Maybe<Coupon_Variance_Fields>;
};

/** aggregate fields of "coupon" */
export type Coupon_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Coupon_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "coupon" */
export type Coupon_Aggregate_Order_By = {
  avg?: Maybe<Coupon_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Coupon_Max_Order_By>;
  min?: Maybe<Coupon_Min_Order_By>;
  stddev?: Maybe<Coupon_Stddev_Order_By>;
  stddev_pop?: Maybe<Coupon_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Coupon_Stddev_Samp_Order_By>;
  sum?: Maybe<Coupon_Sum_Order_By>;
  var_pop?: Maybe<Coupon_Var_Pop_Order_By>;
  var_samp?: Maybe<Coupon_Var_Samp_Order_By>;
  variance?: Maybe<Coupon_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Coupon_Append_Input = {
  /** email of users which are allowed to use the coupon */
  allowed_customer?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "coupon" */
export type Coupon_Arr_Rel_Insert_Input = {
  data: Array<Coupon_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Coupon_On_Conflict>;
};

/** aggregate avg on columns */
export type Coupon_Avg_Fields = {
  __typename?: 'coupon_avg_fields';
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Float']>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Float']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Float']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Float']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "coupon" */
export type Coupon_Avg_Order_By = {
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Order_By>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Order_By>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Order_By>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Order_By>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "coupon". All fields are combined with a logical 'AND'. */
export type Coupon_Bool_Exp = {
  _and?: Maybe<Array<Coupon_Bool_Exp>>;
  _not?: Maybe<Coupon_Bool_Exp>;
  _or?: Maybe<Array<Coupon_Bool_Exp>>;
  allowed_customer?: Maybe<Jsonb_Comparison_Exp>;
  amount_off?: Maybe<Int_Comparison_Exp>;
  code?: Maybe<Citext_Comparison_Exp>;
  coupon_id?: Maybe<String_Comparison_Exp>;
  currency?: Maybe<String_Comparison_Exp>;
  duration?: Maybe<Coupon_Duration_Enum_Comparison_Exp>;
  duration_in_months?: Maybe<Int_Comparison_Exp>;
  expires_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  max_redemptions?: Maybe<Int_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  per_customer_max_redemption?: Maybe<Int_Comparison_Exp>;
  percentage_off?: Maybe<Numeric_Comparison_Exp>;
  promotional_code_id?: Maybe<String_Comparison_Exp>;
  stripe_error?: Maybe<String_Comparison_Exp>;
  type?: Maybe<Coupon_Type_Enum_Comparison_Exp>;
  user_coupons?: Maybe<User_Coupon_Bool_Exp>;
  user_coupons_aggregate?: Maybe<User_Coupon_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "coupon" */
export enum Coupon_Constraint {
  /** unique or primary key constraint on columns "code" */
  CouponCodeKey = 'coupon_code_key',
  /** unique or primary key constraint on columns "coupon_id" */
  CouponCouponIdKey = 'coupon_coupon_id_key',
  /** unique or primary key constraint on columns "id" */
  CouponPkey = 'coupon_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Coupon_Delete_At_Path_Input = {
  /** email of users which are allowed to use the coupon */
  allowed_customer?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Coupon_Delete_Elem_Input = {
  /** email of users which are allowed to use the coupon */
  allowed_customer?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Coupon_Delete_Key_Input = {
  /** email of users which are allowed to use the coupon */
  allowed_customer?: Maybe<Scalars['String']>;
};

/** Hasura enum to capture supported duration values. This enum is used in coupon table */
export type Coupon_Duration = {
  __typename?: 'coupon_duration';
  comment: Scalars['String'];
  /** fetch data from the table: "coupon" */
  coupon: Array<Coupon>;
  /** fetch aggregated fields from the table: "coupon" */
  coupon_aggregate: Coupon_Aggregate;
  duration: Scalars['String'];
};

/** Hasura enum to capture supported duration values. This enum is used in coupon table */
export type Coupon_DurationCouponArgs = {
  distinct_on?: Maybe<Array<Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Order_By>>;
  where?: Maybe<Coupon_Bool_Exp>;
};

/** Hasura enum to capture supported duration values. This enum is used in coupon table */
export type Coupon_DurationCoupon_AggregateArgs = {
  distinct_on?: Maybe<Array<Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Order_By>>;
  where?: Maybe<Coupon_Bool_Exp>;
};

/** aggregated selection of "coupon_duration" */
export type Coupon_Duration_Aggregate = {
  __typename?: 'coupon_duration_aggregate';
  aggregate?: Maybe<Coupon_Duration_Aggregate_Fields>;
  nodes: Array<Coupon_Duration>;
};

/** aggregate fields of "coupon_duration" */
export type Coupon_Duration_Aggregate_Fields = {
  __typename?: 'coupon_duration_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Coupon_Duration_Max_Fields>;
  min?: Maybe<Coupon_Duration_Min_Fields>;
};

/** aggregate fields of "coupon_duration" */
export type Coupon_Duration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Coupon_Duration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "coupon_duration". All fields are combined with a logical 'AND'. */
export type Coupon_Duration_Bool_Exp = {
  _and?: Maybe<Array<Coupon_Duration_Bool_Exp>>;
  _not?: Maybe<Coupon_Duration_Bool_Exp>;
  _or?: Maybe<Array<Coupon_Duration_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  coupon?: Maybe<Coupon_Bool_Exp>;
  coupon_aggregate?: Maybe<Coupon_Aggregate_Bool_Exp>;
  duration?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "coupon_duration" */
export enum Coupon_Duration_Constraint {
  /** unique or primary key constraint on columns "duration" */
  CouponDurationPkey = 'coupon_duration_pkey',
}

export enum Coupon_Duration_Enum {
  /** coupon will be applied forever */
  Forever = 'forever',
  /** coupon will be applied once */
  Once = 'once',
  /** coupon will be applied for mutiple times */
  Repeating = 'repeating',
}

/** Boolean expression to compare columns of type "coupon_duration_enum". All fields are combined with logical 'AND'. */
export type Coupon_Duration_Enum_Comparison_Exp = {
  _eq?: Maybe<Coupon_Duration_Enum>;
  _in?: Maybe<Array<Coupon_Duration_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Coupon_Duration_Enum>;
  _nin?: Maybe<Array<Coupon_Duration_Enum>>;
};

/** input type for inserting data into table "coupon_duration" */
export type Coupon_Duration_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  coupon?: Maybe<Coupon_Arr_Rel_Insert_Input>;
  duration?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Coupon_Duration_Max_Fields = {
  __typename?: 'coupon_duration_max_fields';
  comment?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Coupon_Duration_Min_Fields = {
  __typename?: 'coupon_duration_min_fields';
  comment?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "coupon_duration" */
export type Coupon_Duration_Mutation_Response = {
  __typename?: 'coupon_duration_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Coupon_Duration>;
};

/** on_conflict condition type for table "coupon_duration" */
export type Coupon_Duration_On_Conflict = {
  constraint: Coupon_Duration_Constraint;
  update_columns?: Array<Coupon_Duration_Update_Column>;
  where?: Maybe<Coupon_Duration_Bool_Exp>;
};

/** Ordering options when selecting data from "coupon_duration". */
export type Coupon_Duration_Order_By = {
  comment?: Maybe<Order_By>;
  coupon_aggregate?: Maybe<Coupon_Aggregate_Order_By>;
  duration?: Maybe<Order_By>;
};

/** primary key columns input for table: coupon_duration */
export type Coupon_Duration_Pk_Columns_Input = {
  duration: Scalars['String'];
};

/** select columns of table "coupon_duration" */
export enum Coupon_Duration_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Duration = 'duration',
}

/** input type for updating data in table "coupon_duration" */
export type Coupon_Duration_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "coupon_duration" */
export type Coupon_Duration_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Coupon_Duration_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Coupon_Duration_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  duration?: Maybe<Scalars['String']>;
};

/** update columns of table "coupon_duration" */
export enum Coupon_Duration_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Duration = 'duration',
}

export type Coupon_Duration_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Coupon_Duration_Set_Input>;
  /** filter the rows which have to be updated */
  where: Coupon_Duration_Bool_Exp;
};

/** input type for incrementing numeric columns in table "coupon" */
export type Coupon_Inc_Input = {
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Int']>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Int']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Int']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Int']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['numeric']>;
};

/** input type for inserting data into table "coupon" */
export type Coupon_Insert_Input = {
  /** email of users which are allowed to use the coupon */
  allowed_customer?: Maybe<Scalars['jsonb']>;
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Int']>;
  /** case insensitive text that represents a unique customer facing code that will be used to get the benefit */
  code?: Maybe<Scalars['citext']>;
  /** unique coupon id, represents coupon id at stripe. Internal column */
  coupon_id?: Maybe<Scalars['String']>;
  /** only USD is supported at the moment. Default to USD */
  currency?: Maybe<Scalars['String']>;
  /** represents the duration applicable for a particular coupon. Valid values `once`, `forever`, `repeating` */
  duration?: Maybe<Coupon_Duration_Enum>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Int']>;
  expires_at?: Maybe<Scalars['timestamptz']>;
  /** randomly generated uuid */
  id?: Maybe<Scalars['uuid']>;
  /**
   * represents the state of a particular coupon, whether it is active and can be
   * redeemed or not. This is a global flag to mark a particular coupon
   * active/inactive probably in the middle of a campaign etc. Defaults to true
   */
  is_active?: Maybe<Scalars['Boolean']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Int']>;
  /** represents human readable name for a particular coupon */
  name?: Maybe<Scalars['String']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Int']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['numeric']>;
  /** unique id, represents promotion id at stripe. Internal column */
  promotional_code_id?: Maybe<Scalars['String']>;
  stripe_error?: Maybe<Scalars['String']>;
  /** represents the type of a coupon. Valid values are `credit` or `coupon` */
  type?: Maybe<Coupon_Type_Enum>;
  user_coupons?: Maybe<User_Coupon_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Coupon_Max_Fields = {
  __typename?: 'coupon_max_fields';
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Int']>;
  /** case insensitive text that represents a unique customer facing code that will be used to get the benefit */
  code?: Maybe<Scalars['citext']>;
  /** unique coupon id, represents coupon id at stripe. Internal column */
  coupon_id?: Maybe<Scalars['String']>;
  /** only USD is supported at the moment. Default to USD */
  currency?: Maybe<Scalars['String']>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Int']>;
  expires_at?: Maybe<Scalars['timestamptz']>;
  /** randomly generated uuid */
  id?: Maybe<Scalars['uuid']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Int']>;
  /** represents human readable name for a particular coupon */
  name?: Maybe<Scalars['String']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Int']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['numeric']>;
  /** unique id, represents promotion id at stripe. Internal column */
  promotional_code_id?: Maybe<Scalars['String']>;
  stripe_error?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "coupon" */
export type Coupon_Max_Order_By = {
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Order_By>;
  /** case insensitive text that represents a unique customer facing code that will be used to get the benefit */
  code?: Maybe<Order_By>;
  /** unique coupon id, represents coupon id at stripe. Internal column */
  coupon_id?: Maybe<Order_By>;
  /** only USD is supported at the moment. Default to USD */
  currency?: Maybe<Order_By>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Order_By>;
  expires_at?: Maybe<Order_By>;
  /** randomly generated uuid */
  id?: Maybe<Order_By>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Order_By>;
  /** represents human readable name for a particular coupon */
  name?: Maybe<Order_By>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Order_By>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Order_By>;
  /** unique id, represents promotion id at stripe. Internal column */
  promotional_code_id?: Maybe<Order_By>;
  stripe_error?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Coupon_Min_Fields = {
  __typename?: 'coupon_min_fields';
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Int']>;
  /** case insensitive text that represents a unique customer facing code that will be used to get the benefit */
  code?: Maybe<Scalars['citext']>;
  /** unique coupon id, represents coupon id at stripe. Internal column */
  coupon_id?: Maybe<Scalars['String']>;
  /** only USD is supported at the moment. Default to USD */
  currency?: Maybe<Scalars['String']>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Int']>;
  expires_at?: Maybe<Scalars['timestamptz']>;
  /** randomly generated uuid */
  id?: Maybe<Scalars['uuid']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Int']>;
  /** represents human readable name for a particular coupon */
  name?: Maybe<Scalars['String']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Int']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['numeric']>;
  /** unique id, represents promotion id at stripe. Internal column */
  promotional_code_id?: Maybe<Scalars['String']>;
  stripe_error?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "coupon" */
export type Coupon_Min_Order_By = {
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Order_By>;
  /** case insensitive text that represents a unique customer facing code that will be used to get the benefit */
  code?: Maybe<Order_By>;
  /** unique coupon id, represents coupon id at stripe. Internal column */
  coupon_id?: Maybe<Order_By>;
  /** only USD is supported at the moment. Default to USD */
  currency?: Maybe<Order_By>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Order_By>;
  expires_at?: Maybe<Order_By>;
  /** randomly generated uuid */
  id?: Maybe<Order_By>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Order_By>;
  /** represents human readable name for a particular coupon */
  name?: Maybe<Order_By>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Order_By>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Order_By>;
  /** unique id, represents promotion id at stripe. Internal column */
  promotional_code_id?: Maybe<Order_By>;
  stripe_error?: Maybe<Order_By>;
};

/** response of any mutation on the table "coupon" */
export type Coupon_Mutation_Response = {
  __typename?: 'coupon_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Coupon>;
};

/** input type for inserting object relation for remote table "coupon" */
export type Coupon_Obj_Rel_Insert_Input = {
  data: Coupon_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Coupon_On_Conflict>;
};

/** on_conflict condition type for table "coupon" */
export type Coupon_On_Conflict = {
  constraint: Coupon_Constraint;
  update_columns?: Array<Coupon_Update_Column>;
  where?: Maybe<Coupon_Bool_Exp>;
};

/** Ordering options when selecting data from "coupon". */
export type Coupon_Order_By = {
  allowed_customer?: Maybe<Order_By>;
  amount_off?: Maybe<Order_By>;
  code?: Maybe<Order_By>;
  coupon_id?: Maybe<Order_By>;
  currency?: Maybe<Order_By>;
  duration?: Maybe<Order_By>;
  duration_in_months?: Maybe<Order_By>;
  expires_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  max_redemptions?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  per_customer_max_redemption?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
  promotional_code_id?: Maybe<Order_By>;
  stripe_error?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  user_coupons_aggregate?: Maybe<User_Coupon_Aggregate_Order_By>;
};

/** primary key columns input for table: coupon */
export type Coupon_Pk_Columns_Input = {
  /** randomly generated uuid */
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Coupon_Prepend_Input = {
  /** email of users which are allowed to use the coupon */
  allowed_customer?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "coupon" */
export enum Coupon_Select_Column {
  /** column name */
  AllowedCustomer = 'allowed_customer',
  /** column name */
  AmountOff = 'amount_off',
  /** column name */
  Code = 'code',
  /** column name */
  CouponId = 'coupon_id',
  /** column name */
  Currency = 'currency',
  /** column name */
  Duration = 'duration',
  /** column name */
  DurationInMonths = 'duration_in_months',
  /** column name */
  ExpiresAt = 'expires_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  MaxRedemptions = 'max_redemptions',
  /** column name */
  Name = 'name',
  /** column name */
  PerCustomerMaxRedemption = 'per_customer_max_redemption',
  /** column name */
  PercentageOff = 'percentage_off',
  /** column name */
  PromotionalCodeId = 'promotional_code_id',
  /** column name */
  StripeError = 'stripe_error',
  /** column name */
  Type = 'type',
}

/** select "coupon_aggregate_bool_exp_bool_and_arguments_columns" columns of table "coupon" */
export enum Coupon_Select_Column_Coupon_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsActive = 'is_active',
}

/** select "coupon_aggregate_bool_exp_bool_or_arguments_columns" columns of table "coupon" */
export enum Coupon_Select_Column_Coupon_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsActive = 'is_active',
}

/** input type for updating data in table "coupon" */
export type Coupon_Set_Input = {
  /** email of users which are allowed to use the coupon */
  allowed_customer?: Maybe<Scalars['jsonb']>;
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Int']>;
  /** case insensitive text that represents a unique customer facing code that will be used to get the benefit */
  code?: Maybe<Scalars['citext']>;
  /** unique coupon id, represents coupon id at stripe. Internal column */
  coupon_id?: Maybe<Scalars['String']>;
  /** only USD is supported at the moment. Default to USD */
  currency?: Maybe<Scalars['String']>;
  /** represents the duration applicable for a particular coupon. Valid values `once`, `forever`, `repeating` */
  duration?: Maybe<Coupon_Duration_Enum>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Int']>;
  expires_at?: Maybe<Scalars['timestamptz']>;
  /** randomly generated uuid */
  id?: Maybe<Scalars['uuid']>;
  /**
   * represents the state of a particular coupon, whether it is active and can be
   * redeemed or not. This is a global flag to mark a particular coupon
   * active/inactive probably in the middle of a campaign etc. Defaults to true
   */
  is_active?: Maybe<Scalars['Boolean']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Int']>;
  /** represents human readable name for a particular coupon */
  name?: Maybe<Scalars['String']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Int']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['numeric']>;
  /** unique id, represents promotion id at stripe. Internal column */
  promotional_code_id?: Maybe<Scalars['String']>;
  stripe_error?: Maybe<Scalars['String']>;
  /** represents the type of a coupon. Valid values are `credit` or `coupon` */
  type?: Maybe<Coupon_Type_Enum>;
};

/** aggregate stddev on columns */
export type Coupon_Stddev_Fields = {
  __typename?: 'coupon_stddev_fields';
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Float']>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Float']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Float']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Float']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "coupon" */
export type Coupon_Stddev_Order_By = {
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Order_By>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Order_By>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Order_By>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Order_By>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Coupon_Stddev_Pop_Fields = {
  __typename?: 'coupon_stddev_pop_fields';
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Float']>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Float']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Float']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Float']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "coupon" */
export type Coupon_Stddev_Pop_Order_By = {
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Order_By>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Order_By>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Order_By>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Order_By>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Coupon_Stddev_Samp_Fields = {
  __typename?: 'coupon_stddev_samp_fields';
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Float']>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Float']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Float']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Float']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "coupon" */
export type Coupon_Stddev_Samp_Order_By = {
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Order_By>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Order_By>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Order_By>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Order_By>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Order_By>;
};

/** Streaming cursor of the table "coupon" */
export type Coupon_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Coupon_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Coupon_Stream_Cursor_Value_Input = {
  /** email of users which are allowed to use the coupon */
  allowed_customer?: Maybe<Scalars['jsonb']>;
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Int']>;
  /** case insensitive text that represents a unique customer facing code that will be used to get the benefit */
  code?: Maybe<Scalars['citext']>;
  /** unique coupon id, represents coupon id at stripe. Internal column */
  coupon_id?: Maybe<Scalars['String']>;
  /** only USD is supported at the moment. Default to USD */
  currency?: Maybe<Scalars['String']>;
  /** represents the duration applicable for a particular coupon. Valid values `once`, `forever`, `repeating` */
  duration?: Maybe<Coupon_Duration_Enum>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Int']>;
  expires_at?: Maybe<Scalars['timestamptz']>;
  /** randomly generated uuid */
  id?: Maybe<Scalars['uuid']>;
  /**
   * represents the state of a particular coupon, whether it is active and can be
   * redeemed or not. This is a global flag to mark a particular coupon
   * active/inactive probably in the middle of a campaign etc. Defaults to true
   */
  is_active?: Maybe<Scalars['Boolean']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Int']>;
  /** represents human readable name for a particular coupon */
  name?: Maybe<Scalars['String']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Int']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['numeric']>;
  /** unique id, represents promotion id at stripe. Internal column */
  promotional_code_id?: Maybe<Scalars['String']>;
  stripe_error?: Maybe<Scalars['String']>;
  /** represents the type of a coupon. Valid values are `credit` or `coupon` */
  type?: Maybe<Coupon_Type_Enum>;
};

/** aggregate sum on columns */
export type Coupon_Sum_Fields = {
  __typename?: 'coupon_sum_fields';
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Int']>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Int']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Int']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Int']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "coupon" */
export type Coupon_Sum_Order_By = {
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Order_By>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Order_By>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Order_By>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Order_By>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Order_By>;
};

/** Hasura enum to capture supported coupon type values. This enum is used in coupon table */
export type Coupon_Type = {
  __typename?: 'coupon_type';
  comment: Scalars['String'];
  /** fetch data from the table: "coupon" */
  coupon: Array<Coupon>;
  /** fetch aggregated fields from the table: "coupon" */
  coupon_aggregate: Coupon_Aggregate;
  type: Scalars['String'];
};

/** Hasura enum to capture supported coupon type values. This enum is used in coupon table */
export type Coupon_TypeCouponArgs = {
  distinct_on?: Maybe<Array<Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Order_By>>;
  where?: Maybe<Coupon_Bool_Exp>;
};

/** Hasura enum to capture supported coupon type values. This enum is used in coupon table */
export type Coupon_TypeCoupon_AggregateArgs = {
  distinct_on?: Maybe<Array<Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Order_By>>;
  where?: Maybe<Coupon_Bool_Exp>;
};

/** aggregated selection of "coupon_type" */
export type Coupon_Type_Aggregate = {
  __typename?: 'coupon_type_aggregate';
  aggregate?: Maybe<Coupon_Type_Aggregate_Fields>;
  nodes: Array<Coupon_Type>;
};

/** aggregate fields of "coupon_type" */
export type Coupon_Type_Aggregate_Fields = {
  __typename?: 'coupon_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Coupon_Type_Max_Fields>;
  min?: Maybe<Coupon_Type_Min_Fields>;
};

/** aggregate fields of "coupon_type" */
export type Coupon_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Coupon_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "coupon_type". All fields are combined with a logical 'AND'. */
export type Coupon_Type_Bool_Exp = {
  _and?: Maybe<Array<Coupon_Type_Bool_Exp>>;
  _not?: Maybe<Coupon_Type_Bool_Exp>;
  _or?: Maybe<Array<Coupon_Type_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  coupon?: Maybe<Coupon_Bool_Exp>;
  coupon_aggregate?: Maybe<Coupon_Aggregate_Bool_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "coupon_type" */
export enum Coupon_Type_Constraint {
  /** unique or primary key constraint on columns "type" */
  CouponTypePkey = 'coupon_type_pkey',
}

export enum Coupon_Type_Enum {
  /** stripe coupon */
  Coupon = 'coupon',
  /** add balance to customers account */
  Credit = 'credit',
}

/** Boolean expression to compare columns of type "coupon_type_enum". All fields are combined with logical 'AND'. */
export type Coupon_Type_Enum_Comparison_Exp = {
  _eq?: Maybe<Coupon_Type_Enum>;
  _in?: Maybe<Array<Coupon_Type_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Coupon_Type_Enum>;
  _nin?: Maybe<Array<Coupon_Type_Enum>>;
};

/** input type for inserting data into table "coupon_type" */
export type Coupon_Type_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  coupon?: Maybe<Coupon_Arr_Rel_Insert_Input>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Coupon_Type_Max_Fields = {
  __typename?: 'coupon_type_max_fields';
  comment?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Coupon_Type_Min_Fields = {
  __typename?: 'coupon_type_min_fields';
  comment?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "coupon_type" */
export type Coupon_Type_Mutation_Response = {
  __typename?: 'coupon_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Coupon_Type>;
};

/** on_conflict condition type for table "coupon_type" */
export type Coupon_Type_On_Conflict = {
  constraint: Coupon_Type_Constraint;
  update_columns?: Array<Coupon_Type_Update_Column>;
  where?: Maybe<Coupon_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "coupon_type". */
export type Coupon_Type_Order_By = {
  comment?: Maybe<Order_By>;
  coupon_aggregate?: Maybe<Coupon_Aggregate_Order_By>;
  type?: Maybe<Order_By>;
};

/** primary key columns input for table: coupon_type */
export type Coupon_Type_Pk_Columns_Input = {
  type: Scalars['String'];
};

/** select columns of table "coupon_type" */
export enum Coupon_Type_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Type = 'type',
}

/** input type for updating data in table "coupon_type" */
export type Coupon_Type_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "coupon_type" */
export type Coupon_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Coupon_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Coupon_Type_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** update columns of table "coupon_type" */
export enum Coupon_Type_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Type = 'type',
}

export type Coupon_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Coupon_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Coupon_Type_Bool_Exp;
};

/** update columns of table "coupon" */
export enum Coupon_Update_Column {
  /** column name */
  AllowedCustomer = 'allowed_customer',
  /** column name */
  AmountOff = 'amount_off',
  /** column name */
  Code = 'code',
  /** column name */
  CouponId = 'coupon_id',
  /** column name */
  Currency = 'currency',
  /** column name */
  Duration = 'duration',
  /** column name */
  DurationInMonths = 'duration_in_months',
  /** column name */
  ExpiresAt = 'expires_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  MaxRedemptions = 'max_redemptions',
  /** column name */
  Name = 'name',
  /** column name */
  PerCustomerMaxRedemption = 'per_customer_max_redemption',
  /** column name */
  PercentageOff = 'percentage_off',
  /** column name */
  PromotionalCodeId = 'promotional_code_id',
  /** column name */
  StripeError = 'stripe_error',
  /** column name */
  Type = 'type',
}

export type Coupon_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Coupon_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Coupon_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Coupon_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Coupon_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Coupon_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Coupon_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Coupon_Set_Input>;
  /** filter the rows which have to be updated */
  where: Coupon_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Coupon_Var_Pop_Fields = {
  __typename?: 'coupon_var_pop_fields';
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Float']>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Float']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Float']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Float']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "coupon" */
export type Coupon_Var_Pop_Order_By = {
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Order_By>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Order_By>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Order_By>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Order_By>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Coupon_Var_Samp_Fields = {
  __typename?: 'coupon_var_samp_fields';
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Float']>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Float']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Float']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Float']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "coupon" */
export type Coupon_Var_Samp_Order_By = {
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Order_By>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Order_By>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Order_By>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Order_By>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Coupon_Variance_Fields = {
  __typename?: 'coupon_variance_fields';
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Scalars['Float']>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Scalars['Float']>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Scalars['Float']>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Scalars['Float']>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "coupon" */
export type Coupon_Variance_Order_By = {
  /** amount off in USD. Either amount_off or percentage_off will be there and they cannot exist together */
  amount_off?: Maybe<Order_By>;
  /**
   * when duration is set to `repeating`, this column will represent no of months
   * the discount should be applied on the invoice. Should be NULL for other type of coupon
   */
  duration_in_months?: Maybe<Order_By>;
  /** represents how many times this coupon can be redeemed. If a coupon needs to be used by 100 folks, set this to 100 */
  max_redemptions?: Maybe<Order_By>;
  /**
   * represents how many times a single coupon can be redeemed by a single
   * customer. Set it to 1 if a user can use this coupon only once
   */
  per_customer_max_redemption?: Maybe<Order_By>;
  /** percentage off on the entire invoice amount */
  percentage_off?: Maybe<Order_By>;
};

export type CouponStatus = {
  __typename?: 'CouponStatus';
  status: Scalars['String'];
};

export type CreateDedicatedVpcResponse = {
  __typename?: 'CreateDedicatedVPCResponse';
  id: Scalars['uuid'];
};

export type CreateGithubPreviewAppInputPayload = {
  githubPersonalAccessToken: Scalars['String'];
  githubRepoDetails: GithubRepoDetails;
  projectOptions: ProjectOptions;
};

export type CreateInvoiceInput = {
  collection_method: Scalars['String'];
  customer: Scalars['String'];
  invoice: Scalars['String'];
  month?: Maybe<Scalars['Int']>;
  subscription: Scalars['String'];
  year?: Maybe<Scalars['Int']>;
};

export type CreateInvoiceResponse = {
  __typename?: 'CreateInvoiceResponse';
  message: Scalars['String'];
  status: InvoiceCreateStatus;
};

export type CreateJobInput = {
  payload: Scalars['Map'];
  type: JobTypeEnum;
};

export type CreateJobResponse = {
  __typename?: 'CreateJobResponse';
  job_id: Scalars['uuid'];
};

export type CreateOneClickDeploymentInputPayload = {
  additional_info: Scalars['jsonb'];
  branch?: Maybe<Scalars['String']>;
  github_url: Scalars['String'];
  hasura_dir: Scalars['String'];
};

export type CreateOneClickDeploymentOutput = {
  __typename?: 'CreateOneClickDeploymentOutput';
  project?: Maybe<Projects>;
  project_id: Scalars['uuid'];
};

export type CreateTenantResponse = {
  __typename?: 'CreateTenantResponse';
  id: Scalars['uuid'];
  name: Scalars['String'];
  tenant?: Maybe<Tenant>;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC',
}

/** information about custom domains that are added for tenants */
export type Custom_Domain = {
  __typename?: 'custom_domain';
  /**
   * indicates how certificate is handled: 1) letsencrypt: gateway should use LE to
   * issue cert, 2) vault://<path>: cert is stored on Vault at this path, 3) none:
   * cert is not handled
   */
  cert: Scalars['String'];
  /** Get origin server DNS record created for custom domain */
  cloudflare_origin_dns_record?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  custom_domain_cloudflare?: Maybe<Custom_Domain_Cloudflare>;
  /** An object relationship */
  custom_domain_cloudflare_dns?: Maybe<Custom_Domain_Cloudflare_Dns>;
  /**
   * indicates if the dns resolves to <slug>.hasura.app: 1) pending: the validation
   * is peniding, 2) succeeded: dns is configured correctly, 3) failed: dns
   * validation failed
   */
  dns_validation: Scalars['String'];
  /** the custom domain being added */
  fqdn: Scalars['String'];
  id: Scalars['uuid'];
  /** An array relationship */
  letsencrypt_statuses: Array<Letsencrypt_Status>;
  /** An aggregate relationship */
  letsencrypt_statuses_aggregate: Letsencrypt_Status_Aggregate;
  /** Get the SSL info/error messages, if any */
  ssl_message?: Maybe<Scalars['String']>;
  /** Get the SSL status for custom domain */
  ssl_status?: Maybe<Scalars['String']>;
  /** An object relationship */
  tenant: Tenant;
  tenant_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** information about custom domains that are added for tenants */
export type Custom_DomainLetsencrypt_StatusesArgs = {
  distinct_on?: Maybe<Array<Letsencrypt_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Letsencrypt_Status_Order_By>>;
  where?: Maybe<Letsencrypt_Status_Bool_Exp>;
};

/** information about custom domains that are added for tenants */
export type Custom_DomainLetsencrypt_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Letsencrypt_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Letsencrypt_Status_Order_By>>;
  where?: Maybe<Letsencrypt_Status_Bool_Exp>;
};

/** aggregated selection of "custom_domain" */
export type Custom_Domain_Aggregate = {
  __typename?: 'custom_domain_aggregate';
  aggregate?: Maybe<Custom_Domain_Aggregate_Fields>;
  nodes: Array<Custom_Domain>;
};

export type Custom_Domain_Aggregate_Bool_Exp = {
  count?: Maybe<Custom_Domain_Aggregate_Bool_Exp_Count>;
};

export type Custom_Domain_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Custom_Domain_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Custom_Domain_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "custom_domain" */
export type Custom_Domain_Aggregate_Fields = {
  __typename?: 'custom_domain_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Custom_Domain_Max_Fields>;
  min?: Maybe<Custom_Domain_Min_Fields>;
};

/** aggregate fields of "custom_domain" */
export type Custom_Domain_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Custom_Domain_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "custom_domain" */
export type Custom_Domain_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Custom_Domain_Max_Order_By>;
  min?: Maybe<Custom_Domain_Min_Order_By>;
};

/** input type for inserting array relation for remote table "custom_domain" */
export type Custom_Domain_Arr_Rel_Insert_Input = {
  data: Array<Custom_Domain_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Custom_Domain_On_Conflict>;
};

/** Boolean expression to filter rows from the table "custom_domain". All fields are combined with a logical 'AND'. */
export type Custom_Domain_Bool_Exp = {
  _and?: Maybe<Array<Custom_Domain_Bool_Exp>>;
  _not?: Maybe<Custom_Domain_Bool_Exp>;
  _or?: Maybe<Array<Custom_Domain_Bool_Exp>>;
  cert?: Maybe<String_Comparison_Exp>;
  cloudflare_origin_dns_record?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  custom_domain_cloudflare?: Maybe<Custom_Domain_Cloudflare_Bool_Exp>;
  custom_domain_cloudflare_dns?: Maybe<Custom_Domain_Cloudflare_Dns_Bool_Exp>;
  dns_validation?: Maybe<String_Comparison_Exp>;
  fqdn?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  letsencrypt_statuses?: Maybe<Letsencrypt_Status_Bool_Exp>;
  letsencrypt_statuses_aggregate?: Maybe<Letsencrypt_Status_Aggregate_Bool_Exp>;
  ssl_message?: Maybe<String_Comparison_Exp>;
  ssl_status?: Maybe<String_Comparison_Exp>;
  tenant?: Maybe<Tenant_Bool_Exp>;
  tenant_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** Status of cloudflare custom domain setup */
export type Custom_Domain_Cloudflare = {
  __typename?: 'custom_domain_cloudflare';
  certificate_verification_path?: Maybe<Scalars['String']>;
  certificate_verification_value?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  custom_domain: Custom_Domain;
  custom_hostname_cloudflare?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  dns?: Maybe<Custom_Domain_Cloudflare_Dns>;
  force_update: Scalars['Boolean'];
  fqdn: Scalars['String'];
  id: Scalars['uuid'];
  message?: Maybe<Scalars['String']>;
  origin_server_cloudflare: Scalars['String'];
  ownership_verification_path?: Maybe<Scalars['String']>;
  ownership_verification_value?: Maybe<Scalars['String']>;
  status: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Status of cloudflare custom domain setup */
export type Custom_Domain_CloudflareCustom_Hostname_CloudflareArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "custom_domain_cloudflare" */
export type Custom_Domain_Cloudflare_Aggregate = {
  __typename?: 'custom_domain_cloudflare_aggregate';
  aggregate?: Maybe<Custom_Domain_Cloudflare_Aggregate_Fields>;
  nodes: Array<Custom_Domain_Cloudflare>;
};

/** aggregate fields of "custom_domain_cloudflare" */
export type Custom_Domain_Cloudflare_Aggregate_Fields = {
  __typename?: 'custom_domain_cloudflare_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Custom_Domain_Cloudflare_Max_Fields>;
  min?: Maybe<Custom_Domain_Cloudflare_Min_Fields>;
};

/** aggregate fields of "custom_domain_cloudflare" */
export type Custom_Domain_Cloudflare_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Custom_Domain_Cloudflare_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Custom_Domain_Cloudflare_Append_Input = {
  custom_hostname_cloudflare?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "custom_domain_cloudflare". All fields are combined with a logical 'AND'. */
export type Custom_Domain_Cloudflare_Bool_Exp = {
  _and?: Maybe<Array<Custom_Domain_Cloudflare_Bool_Exp>>;
  _not?: Maybe<Custom_Domain_Cloudflare_Bool_Exp>;
  _or?: Maybe<Array<Custom_Domain_Cloudflare_Bool_Exp>>;
  certificate_verification_path?: Maybe<String_Comparison_Exp>;
  certificate_verification_value?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  custom_domain?: Maybe<Custom_Domain_Bool_Exp>;
  custom_hostname_cloudflare?: Maybe<Jsonb_Comparison_Exp>;
  dns?: Maybe<Custom_Domain_Cloudflare_Dns_Bool_Exp>;
  force_update?: Maybe<Boolean_Comparison_Exp>;
  fqdn?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  message?: Maybe<String_Comparison_Exp>;
  origin_server_cloudflare?: Maybe<String_Comparison_Exp>;
  ownership_verification_path?: Maybe<String_Comparison_Exp>;
  ownership_verification_value?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "custom_domain_cloudflare" */
export enum Custom_Domain_Cloudflare_Constraint {
  /** unique or primary key constraint on columns "id" */
  CustomDomainCloudflarePkey = 'custom_domain_cloudflare_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Custom_Domain_Cloudflare_Delete_At_Path_Input = {
  custom_hostname_cloudflare?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Custom_Domain_Cloudflare_Delete_Elem_Input = {
  custom_hostname_cloudflare?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Custom_Domain_Cloudflare_Delete_Key_Input = {
  custom_hostname_cloudflare?: Maybe<Scalars['String']>;
};

/** DNS record required for cloudflare custom domain */
export type Custom_Domain_Cloudflare_Dns = {
  __typename?: 'custom_domain_cloudflare_dns';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  custom_domain: Custom_Domain;
  dns_name: Scalars['String'];
  force_update: Scalars['Boolean'];
  id: Scalars['uuid'];
  message?: Maybe<Scalars['String']>;
  status: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "custom_domain_cloudflare_dns" */
export type Custom_Domain_Cloudflare_Dns_Aggregate = {
  __typename?: 'custom_domain_cloudflare_dns_aggregate';
  aggregate?: Maybe<Custom_Domain_Cloudflare_Dns_Aggregate_Fields>;
  nodes: Array<Custom_Domain_Cloudflare_Dns>;
};

/** aggregate fields of "custom_domain_cloudflare_dns" */
export type Custom_Domain_Cloudflare_Dns_Aggregate_Fields = {
  __typename?: 'custom_domain_cloudflare_dns_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Custom_Domain_Cloudflare_Dns_Max_Fields>;
  min?: Maybe<Custom_Domain_Cloudflare_Dns_Min_Fields>;
};

/** aggregate fields of "custom_domain_cloudflare_dns" */
export type Custom_Domain_Cloudflare_Dns_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Custom_Domain_Cloudflare_Dns_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/**
 * Boolean expression to filter rows from the table "custom_domain_cloudflare_dns".
 * All fields are combined with a logical 'AND'.
 */
export type Custom_Domain_Cloudflare_Dns_Bool_Exp = {
  _and?: Maybe<Array<Custom_Domain_Cloudflare_Dns_Bool_Exp>>;
  _not?: Maybe<Custom_Domain_Cloudflare_Dns_Bool_Exp>;
  _or?: Maybe<Array<Custom_Domain_Cloudflare_Dns_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  custom_domain?: Maybe<Custom_Domain_Bool_Exp>;
  dns_name?: Maybe<String_Comparison_Exp>;
  force_update?: Maybe<Boolean_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  message?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "custom_domain_cloudflare_dns" */
export enum Custom_Domain_Cloudflare_Dns_Constraint {
  /** unique or primary key constraint on columns "dns_name" */
  CustomDomainCloudflareDnsDnsNameKey = 'custom_domain_cloudflare_dns_dns_name_key',
  /** unique or primary key constraint on columns "id", "dns_name" */
  CustomDomainCloudflareDnsIdDnsNameKey = 'custom_domain_cloudflare_dns_id_dns_name_key',
  /** unique or primary key constraint on columns "id" */
  CustomDomainCloudflareDnsPkey = 'custom_domain_cloudflare_dns_pkey',
}

/** input type for inserting data into table "custom_domain_cloudflare_dns" */
export type Custom_Domain_Cloudflare_Dns_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  custom_domain?: Maybe<Custom_Domain_Obj_Rel_Insert_Input>;
  dns_name?: Maybe<Scalars['String']>;
  force_update?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Custom_Domain_Cloudflare_Dns_Max_Fields = {
  __typename?: 'custom_domain_cloudflare_dns_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dns_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Custom_Domain_Cloudflare_Dns_Min_Fields = {
  __typename?: 'custom_domain_cloudflare_dns_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  dns_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "custom_domain_cloudflare_dns" */
export type Custom_Domain_Cloudflare_Dns_Mutation_Response = {
  __typename?: 'custom_domain_cloudflare_dns_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Custom_Domain_Cloudflare_Dns>;
};

/** input type for inserting object relation for remote table "custom_domain_cloudflare_dns" */
export type Custom_Domain_Cloudflare_Dns_Obj_Rel_Insert_Input = {
  data: Custom_Domain_Cloudflare_Dns_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Custom_Domain_Cloudflare_Dns_On_Conflict>;
};

/** on_conflict condition type for table "custom_domain_cloudflare_dns" */
export type Custom_Domain_Cloudflare_Dns_On_Conflict = {
  constraint: Custom_Domain_Cloudflare_Dns_Constraint;
  update_columns?: Array<Custom_Domain_Cloudflare_Dns_Update_Column>;
  where?: Maybe<Custom_Domain_Cloudflare_Dns_Bool_Exp>;
};

/** Ordering options when selecting data from "custom_domain_cloudflare_dns". */
export type Custom_Domain_Cloudflare_Dns_Order_By = {
  created_at?: Maybe<Order_By>;
  custom_domain?: Maybe<Custom_Domain_Order_By>;
  dns_name?: Maybe<Order_By>;
  force_update?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: custom_domain_cloudflare_dns */
export type Custom_Domain_Cloudflare_Dns_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "custom_domain_cloudflare_dns" */
export enum Custom_Domain_Cloudflare_Dns_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DnsName = 'dns_name',
  /** column name */
  ForceUpdate = 'force_update',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "custom_domain_cloudflare_dns" */
export type Custom_Domain_Cloudflare_Dns_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dns_name?: Maybe<Scalars['String']>;
  force_update?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "custom_domain_cloudflare_dns" */
export type Custom_Domain_Cloudflare_Dns_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Custom_Domain_Cloudflare_Dns_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Custom_Domain_Cloudflare_Dns_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  dns_name?: Maybe<Scalars['String']>;
  force_update?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "custom_domain_cloudflare_dns" */
export enum Custom_Domain_Cloudflare_Dns_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DnsName = 'dns_name',
  /** column name */
  ForceUpdate = 'force_update',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Custom_Domain_Cloudflare_Dns_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Custom_Domain_Cloudflare_Dns_Set_Input>;
  /** filter the rows which have to be updated */
  where: Custom_Domain_Cloudflare_Dns_Bool_Exp;
};

/** input type for inserting data into table "custom_domain_cloudflare" */
export type Custom_Domain_Cloudflare_Insert_Input = {
  certificate_verification_path?: Maybe<Scalars['String']>;
  certificate_verification_value?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  custom_domain?: Maybe<Custom_Domain_Obj_Rel_Insert_Input>;
  custom_hostname_cloudflare?: Maybe<Scalars['jsonb']>;
  dns?: Maybe<Custom_Domain_Cloudflare_Dns_Obj_Rel_Insert_Input>;
  force_update?: Maybe<Scalars['Boolean']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  origin_server_cloudflare?: Maybe<Scalars['String']>;
  ownership_verification_path?: Maybe<Scalars['String']>;
  ownership_verification_value?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Custom_Domain_Cloudflare_Max_Fields = {
  __typename?: 'custom_domain_cloudflare_max_fields';
  certificate_verification_path?: Maybe<Scalars['String']>;
  certificate_verification_value?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  origin_server_cloudflare?: Maybe<Scalars['String']>;
  ownership_verification_path?: Maybe<Scalars['String']>;
  ownership_verification_value?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Custom_Domain_Cloudflare_Min_Fields = {
  __typename?: 'custom_domain_cloudflare_min_fields';
  certificate_verification_path?: Maybe<Scalars['String']>;
  certificate_verification_value?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  origin_server_cloudflare?: Maybe<Scalars['String']>;
  ownership_verification_path?: Maybe<Scalars['String']>;
  ownership_verification_value?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "custom_domain_cloudflare" */
export type Custom_Domain_Cloudflare_Mutation_Response = {
  __typename?: 'custom_domain_cloudflare_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Custom_Domain_Cloudflare>;
};

/** input type for inserting object relation for remote table "custom_domain_cloudflare" */
export type Custom_Domain_Cloudflare_Obj_Rel_Insert_Input = {
  data: Custom_Domain_Cloudflare_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Custom_Domain_Cloudflare_On_Conflict>;
};

/** on_conflict condition type for table "custom_domain_cloudflare" */
export type Custom_Domain_Cloudflare_On_Conflict = {
  constraint: Custom_Domain_Cloudflare_Constraint;
  update_columns?: Array<Custom_Domain_Cloudflare_Update_Column>;
  where?: Maybe<Custom_Domain_Cloudflare_Bool_Exp>;
};

/** Ordering options when selecting data from "custom_domain_cloudflare". */
export type Custom_Domain_Cloudflare_Order_By = {
  certificate_verification_path?: Maybe<Order_By>;
  certificate_verification_value?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  custom_domain?: Maybe<Custom_Domain_Order_By>;
  custom_hostname_cloudflare?: Maybe<Order_By>;
  dns?: Maybe<Custom_Domain_Cloudflare_Dns_Order_By>;
  force_update?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  origin_server_cloudflare?: Maybe<Order_By>;
  ownership_verification_path?: Maybe<Order_By>;
  ownership_verification_value?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: custom_domain_cloudflare */
export type Custom_Domain_Cloudflare_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Custom_Domain_Cloudflare_Prepend_Input = {
  custom_hostname_cloudflare?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "custom_domain_cloudflare" */
export enum Custom_Domain_Cloudflare_Select_Column {
  /** column name */
  CertificateVerificationPath = 'certificate_verification_path',
  /** column name */
  CertificateVerificationValue = 'certificate_verification_value',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomHostnameCloudflare = 'custom_hostname_cloudflare',
  /** column name */
  ForceUpdate = 'force_update',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  OriginServerCloudflare = 'origin_server_cloudflare',
  /** column name */
  OwnershipVerificationPath = 'ownership_verification_path',
  /** column name */
  OwnershipVerificationValue = 'ownership_verification_value',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "custom_domain_cloudflare" */
export type Custom_Domain_Cloudflare_Set_Input = {
  certificate_verification_path?: Maybe<Scalars['String']>;
  certificate_verification_value?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  custom_hostname_cloudflare?: Maybe<Scalars['jsonb']>;
  force_update?: Maybe<Scalars['Boolean']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  origin_server_cloudflare?: Maybe<Scalars['String']>;
  ownership_verification_path?: Maybe<Scalars['String']>;
  ownership_verification_value?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "custom_domain_cloudflare" */
export type Custom_Domain_Cloudflare_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Custom_Domain_Cloudflare_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Custom_Domain_Cloudflare_Stream_Cursor_Value_Input = {
  certificate_verification_path?: Maybe<Scalars['String']>;
  certificate_verification_value?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  custom_hostname_cloudflare?: Maybe<Scalars['jsonb']>;
  force_update?: Maybe<Scalars['Boolean']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  origin_server_cloudflare?: Maybe<Scalars['String']>;
  ownership_verification_path?: Maybe<Scalars['String']>;
  ownership_verification_value?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "custom_domain_cloudflare" */
export enum Custom_Domain_Cloudflare_Update_Column {
  /** column name */
  CertificateVerificationPath = 'certificate_verification_path',
  /** column name */
  CertificateVerificationValue = 'certificate_verification_value',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomHostnameCloudflare = 'custom_hostname_cloudflare',
  /** column name */
  ForceUpdate = 'force_update',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  Message = 'message',
  /** column name */
  OriginServerCloudflare = 'origin_server_cloudflare',
  /** column name */
  OwnershipVerificationPath = 'ownership_verification_path',
  /** column name */
  OwnershipVerificationValue = 'ownership_verification_value',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Custom_Domain_Cloudflare_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Custom_Domain_Cloudflare_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Custom_Domain_Cloudflare_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Custom_Domain_Cloudflare_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Custom_Domain_Cloudflare_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Custom_Domain_Cloudflare_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Custom_Domain_Cloudflare_Set_Input>;
  /** filter the rows which have to be updated */
  where: Custom_Domain_Cloudflare_Bool_Exp;
};

/** unique or primary key constraints on table "custom_domain" */
export enum Custom_Domain_Constraint {
  /** unique or primary key constraint on columns "fqdn" */
  CustomDomainFqdnKey = 'custom_domain_fqdn_key',
  /** unique or primary key constraint on columns "fqdn", "id" */
  CustomDomainIdFqdnKey = 'custom_domain_id_fqdn_key',
  /** unique or primary key constraint on columns "id" */
  CustomDomainPkey = 'custom_domain_pkey',
}

/** input type for inserting data into table "custom_domain" */
export type Custom_Domain_Insert_Input = {
  /**
   * indicates how certificate is handled: 1) letsencrypt: gateway should use LE to
   * issue cert, 2) vault://<path>: cert is stored on Vault at this path, 3) none:
   * cert is not handled
   */
  cert?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  custom_domain_cloudflare?: Maybe<Custom_Domain_Cloudflare_Obj_Rel_Insert_Input>;
  custom_domain_cloudflare_dns?: Maybe<Custom_Domain_Cloudflare_Dns_Obj_Rel_Insert_Input>;
  /**
   * indicates if the dns resolves to <slug>.hasura.app: 1) pending: the validation
   * is peniding, 2) succeeded: dns is configured correctly, 3) failed: dns
   * validation failed
   */
  dns_validation?: Maybe<Scalars['String']>;
  /** the custom domain being added */
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  letsencrypt_statuses?: Maybe<Letsencrypt_Status_Arr_Rel_Insert_Input>;
  tenant?: Maybe<Tenant_Obj_Rel_Insert_Input>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Custom_Domain_Max_Fields = {
  __typename?: 'custom_domain_max_fields';
  /**
   * indicates how certificate is handled: 1) letsencrypt: gateway should use LE to
   * issue cert, 2) vault://<path>: cert is stored on Vault at this path, 3) none:
   * cert is not handled
   */
  cert?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /**
   * indicates if the dns resolves to <slug>.hasura.app: 1) pending: the validation
   * is peniding, 2) succeeded: dns is configured correctly, 3) failed: dns
   * validation failed
   */
  dns_validation?: Maybe<Scalars['String']>;
  /** the custom domain being added */
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "custom_domain" */
export type Custom_Domain_Max_Order_By = {
  /**
   * indicates how certificate is handled: 1) letsencrypt: gateway should use LE to
   * issue cert, 2) vault://<path>: cert is stored on Vault at this path, 3) none:
   * cert is not handled
   */
  cert?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  /**
   * indicates if the dns resolves to <slug>.hasura.app: 1) pending: the validation
   * is peniding, 2) succeeded: dns is configured correctly, 3) failed: dns
   * validation failed
   */
  dns_validation?: Maybe<Order_By>;
  /** the custom domain being added */
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Custom_Domain_Min_Fields = {
  __typename?: 'custom_domain_min_fields';
  /**
   * indicates how certificate is handled: 1) letsencrypt: gateway should use LE to
   * issue cert, 2) vault://<path>: cert is stored on Vault at this path, 3) none:
   * cert is not handled
   */
  cert?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /**
   * indicates if the dns resolves to <slug>.hasura.app: 1) pending: the validation
   * is peniding, 2) succeeded: dns is configured correctly, 3) failed: dns
   * validation failed
   */
  dns_validation?: Maybe<Scalars['String']>;
  /** the custom domain being added */
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "custom_domain" */
export type Custom_Domain_Min_Order_By = {
  /**
   * indicates how certificate is handled: 1) letsencrypt: gateway should use LE to
   * issue cert, 2) vault://<path>: cert is stored on Vault at this path, 3) none:
   * cert is not handled
   */
  cert?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  /**
   * indicates if the dns resolves to <slug>.hasura.app: 1) pending: the validation
   * is peniding, 2) succeeded: dns is configured correctly, 3) failed: dns
   * validation failed
   */
  dns_validation?: Maybe<Order_By>;
  /** the custom domain being added */
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "custom_domain" */
export type Custom_Domain_Mutation_Response = {
  __typename?: 'custom_domain_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Custom_Domain>;
};

/** input type for inserting object relation for remote table "custom_domain" */
export type Custom_Domain_Obj_Rel_Insert_Input = {
  data: Custom_Domain_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Custom_Domain_On_Conflict>;
};

/** on_conflict condition type for table "custom_domain" */
export type Custom_Domain_On_Conflict = {
  constraint: Custom_Domain_Constraint;
  update_columns?: Array<Custom_Domain_Update_Column>;
  where?: Maybe<Custom_Domain_Bool_Exp>;
};

/** Ordering options when selecting data from "custom_domain". */
export type Custom_Domain_Order_By = {
  cert?: Maybe<Order_By>;
  cloudflare_origin_dns_record?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  custom_domain_cloudflare?: Maybe<Custom_Domain_Cloudflare_Order_By>;
  custom_domain_cloudflare_dns?: Maybe<Custom_Domain_Cloudflare_Dns_Order_By>;
  dns_validation?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  letsencrypt_statuses_aggregate?: Maybe<Letsencrypt_Status_Aggregate_Order_By>;
  ssl_message?: Maybe<Order_By>;
  ssl_status?: Maybe<Order_By>;
  tenant?: Maybe<Tenant_Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: custom_domain */
export type Custom_Domain_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "custom_domain" */
export enum Custom_Domain_Select_Column {
  /** column name */
  Cert = 'cert',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DnsValidation = 'dns_validation',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "custom_domain" */
export type Custom_Domain_Set_Input = {
  /**
   * indicates how certificate is handled: 1) letsencrypt: gateway should use LE to
   * issue cert, 2) vault://<path>: cert is stored on Vault at this path, 3) none:
   * cert is not handled
   */
  cert?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /**
   * indicates if the dns resolves to <slug>.hasura.app: 1) pending: the validation
   * is peniding, 2) succeeded: dns is configured correctly, 3) failed: dns
   * validation failed
   */
  dns_validation?: Maybe<Scalars['String']>;
  /** the custom domain being added */
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "custom_domain" */
export type Custom_Domain_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Custom_Domain_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Custom_Domain_Stream_Cursor_Value_Input = {
  /**
   * indicates how certificate is handled: 1) letsencrypt: gateway should use LE to
   * issue cert, 2) vault://<path>: cert is stored on Vault at this path, 3) none:
   * cert is not handled
   */
  cert?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /**
   * indicates if the dns resolves to <slug>.hasura.app: 1) pending: the validation
   * is peniding, 2) succeeded: dns is configured correctly, 3) failed: dns
   * validation failed
   */
  dns_validation?: Maybe<Scalars['String']>;
  /** the custom domain being added */
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "custom_domain" */
export enum Custom_Domain_Update_Column {
  /** column name */
  Cert = 'cert',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DnsValidation = 'dns_validation',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Custom_Domain_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Custom_Domain_Set_Input>;
  /** filter the rows which have to be updated */
  where: Custom_Domain_Bool_Exp;
};

/** Price (amount) usage by a customer */
export type Customer_Usage = {
  __typename?: 'customer_usage';
  amount: Scalars['float8'];
  code?: Maybe<Scalars['citext']>;
  /** An object relationship */
  coupon?: Maybe<Coupon>;
  created_at: Scalars['timestamptz'];
  customer_id: Scalars['String'];
  id: Scalars['uuid'];
  invoice_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  user?: Maybe<Users>;
};

/** aggregated selection of "customer_usage" */
export type Customer_Usage_Aggregate = {
  __typename?: 'customer_usage_aggregate';
  aggregate?: Maybe<Customer_Usage_Aggregate_Fields>;
  nodes: Array<Customer_Usage>;
};

export type Customer_Usage_Aggregate_Bool_Exp = {
  avg?: Maybe<Customer_Usage_Aggregate_Bool_Exp_Avg>;
  corr?: Maybe<Customer_Usage_Aggregate_Bool_Exp_Corr>;
  count?: Maybe<Customer_Usage_Aggregate_Bool_Exp_Count>;
  covar_samp?: Maybe<Customer_Usage_Aggregate_Bool_Exp_Covar_Samp>;
  max?: Maybe<Customer_Usage_Aggregate_Bool_Exp_Max>;
  min?: Maybe<Customer_Usage_Aggregate_Bool_Exp_Min>;
  stddev_samp?: Maybe<Customer_Usage_Aggregate_Bool_Exp_Stddev_Samp>;
  sum?: Maybe<Customer_Usage_Aggregate_Bool_Exp_Sum>;
  var_samp?: Maybe<Customer_Usage_Aggregate_Bool_Exp_Var_Samp>;
};

export type Customer_Usage_Aggregate_Bool_Exp_Avg = {
  arguments: Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Avg_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Customer_Usage_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Customer_Usage_Aggregate_Bool_Exp_Corr = {
  arguments: Customer_Usage_Aggregate_Bool_Exp_Corr_Arguments;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Customer_Usage_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Customer_Usage_Aggregate_Bool_Exp_Corr_Arguments = {
  X: Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Corr_Arguments_Columns;
  Y: Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Corr_Arguments_Columns;
};

export type Customer_Usage_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Customer_Usage_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Customer_Usage_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

export type Customer_Usage_Aggregate_Bool_Exp_Covar_Samp = {
  arguments: Customer_Usage_Aggregate_Bool_Exp_Covar_Samp_Arguments;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Customer_Usage_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Customer_Usage_Aggregate_Bool_Exp_Covar_Samp_Arguments = {
  X: Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
  Y: Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns;
};

export type Customer_Usage_Aggregate_Bool_Exp_Max = {
  arguments: Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Max_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Customer_Usage_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Customer_Usage_Aggregate_Bool_Exp_Min = {
  arguments: Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Min_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Customer_Usage_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Customer_Usage_Aggregate_Bool_Exp_Stddev_Samp = {
  arguments: Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Customer_Usage_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Customer_Usage_Aggregate_Bool_Exp_Sum = {
  arguments: Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Sum_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Customer_Usage_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

export type Customer_Usage_Aggregate_Bool_Exp_Var_Samp = {
  arguments: Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Customer_Usage_Bool_Exp>;
  predicate: Float8_Comparison_Exp;
};

/** aggregate fields of "customer_usage" */
export type Customer_Usage_Aggregate_Fields = {
  __typename?: 'customer_usage_aggregate_fields';
  avg?: Maybe<Customer_Usage_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Customer_Usage_Max_Fields>;
  min?: Maybe<Customer_Usage_Min_Fields>;
  stddev?: Maybe<Customer_Usage_Stddev_Fields>;
  stddev_pop?: Maybe<Customer_Usage_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Customer_Usage_Stddev_Samp_Fields>;
  sum?: Maybe<Customer_Usage_Sum_Fields>;
  var_pop?: Maybe<Customer_Usage_Var_Pop_Fields>;
  var_samp?: Maybe<Customer_Usage_Var_Samp_Fields>;
  variance?: Maybe<Customer_Usage_Variance_Fields>;
};

/** aggregate fields of "customer_usage" */
export type Customer_Usage_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Customer_Usage_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "customer_usage" */
export type Customer_Usage_Aggregate_Order_By = {
  avg?: Maybe<Customer_Usage_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Customer_Usage_Max_Order_By>;
  min?: Maybe<Customer_Usage_Min_Order_By>;
  stddev?: Maybe<Customer_Usage_Stddev_Order_By>;
  stddev_pop?: Maybe<Customer_Usage_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Customer_Usage_Stddev_Samp_Order_By>;
  sum?: Maybe<Customer_Usage_Sum_Order_By>;
  var_pop?: Maybe<Customer_Usage_Var_Pop_Order_By>;
  var_samp?: Maybe<Customer_Usage_Var_Samp_Order_By>;
  variance?: Maybe<Customer_Usage_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "customer_usage" */
export type Customer_Usage_Arr_Rel_Insert_Input = {
  data: Array<Customer_Usage_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Customer_Usage_On_Conflict>;
};

/** aggregate avg on columns */
export type Customer_Usage_Avg_Fields = {
  __typename?: 'customer_usage_avg_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "customer_usage" */
export type Customer_Usage_Avg_Order_By = {
  amount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "customer_usage". All fields are combined with a logical 'AND'. */
export type Customer_Usage_Bool_Exp = {
  _and?: Maybe<Array<Customer_Usage_Bool_Exp>>;
  _not?: Maybe<Customer_Usage_Bool_Exp>;
  _or?: Maybe<Array<Customer_Usage_Bool_Exp>>;
  amount?: Maybe<Float8_Comparison_Exp>;
  code?: Maybe<Citext_Comparison_Exp>;
  coupon?: Maybe<Coupon_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customer_id?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  invoice_id?: Maybe<String_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
};

/** unique or primary key constraints on table "customer_usage" */
export enum Customer_Usage_Constraint {
  /** unique or primary key constraint on columns "id" */
  CustomerUsagePkey = 'customer_usage_pkey',
}

/** input type for incrementing numeric columns in table "customer_usage" */
export type Customer_Usage_Inc_Input = {
  amount?: Maybe<Scalars['float8']>;
};

/** input type for inserting data into table "customer_usage" */
export type Customer_Usage_Insert_Input = {
  amount?: Maybe<Scalars['float8']>;
  code?: Maybe<Scalars['citext']>;
  coupon?: Maybe<Coupon_Obj_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Customer_Usage_Max_Fields = {
  __typename?: 'customer_usage_max_fields';
  amount?: Maybe<Scalars['float8']>;
  code?: Maybe<Scalars['citext']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "customer_usage" */
export type Customer_Usage_Max_Order_By = {
  amount?: Maybe<Order_By>;
  code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invoice_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Customer_Usage_Min_Fields = {
  __typename?: 'customer_usage_min_fields';
  amount?: Maybe<Scalars['float8']>;
  code?: Maybe<Scalars['citext']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "customer_usage" */
export type Customer_Usage_Min_Order_By = {
  amount?: Maybe<Order_By>;
  code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invoice_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "customer_usage" */
export type Customer_Usage_Mutation_Response = {
  __typename?: 'customer_usage_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Customer_Usage>;
};

/** on_conflict condition type for table "customer_usage" */
export type Customer_Usage_On_Conflict = {
  constraint: Customer_Usage_Constraint;
  update_columns?: Array<Customer_Usage_Update_Column>;
  where?: Maybe<Customer_Usage_Bool_Exp>;
};

/** Ordering options when selecting data from "customer_usage". */
export type Customer_Usage_Order_By = {
  amount?: Maybe<Order_By>;
  code?: Maybe<Order_By>;
  coupon?: Maybe<Coupon_Order_By>;
  created_at?: Maybe<Order_By>;
  customer_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invoice_id?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
};

/** primary key columns input for table: customer_usage */
export type Customer_Usage_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "customer_usage" */
export enum Customer_Usage_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
}

/** select "customer_usage_aggregate_bool_exp_avg_arguments_columns" columns of table "customer_usage" */
export enum Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Avg_Arguments_Columns {
  /** column name */
  Amount = 'amount',
}

/** select "customer_usage_aggregate_bool_exp_corr_arguments_columns" columns of table "customer_usage" */
export enum Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Corr_Arguments_Columns {
  /** column name */
  Amount = 'amount',
}

/** select "customer_usage_aggregate_bool_exp_covar_samp_arguments_columns" columns of table "customer_usage" */
export enum Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Covar_Samp_Arguments_Columns {
  /** column name */
  Amount = 'amount',
}

/** select "customer_usage_aggregate_bool_exp_max_arguments_columns" columns of table "customer_usage" */
export enum Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Max_Arguments_Columns {
  /** column name */
  Amount = 'amount',
}

/** select "customer_usage_aggregate_bool_exp_min_arguments_columns" columns of table "customer_usage" */
export enum Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Min_Arguments_Columns {
  /** column name */
  Amount = 'amount',
}

/** select "customer_usage_aggregate_bool_exp_stddev_samp_arguments_columns" columns of table "customer_usage" */
export enum Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Stddev_Samp_Arguments_Columns {
  /** column name */
  Amount = 'amount',
}

/** select "customer_usage_aggregate_bool_exp_sum_arguments_columns" columns of table "customer_usage" */
export enum Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Sum_Arguments_Columns {
  /** column name */
  Amount = 'amount',
}

/** select "customer_usage_aggregate_bool_exp_var_samp_arguments_columns" columns of table "customer_usage" */
export enum Customer_Usage_Select_Column_Customer_Usage_Aggregate_Bool_Exp_Var_Samp_Arguments_Columns {
  /** column name */
  Amount = 'amount',
}

/** input type for updating data in table "customer_usage" */
export type Customer_Usage_Set_Input = {
  amount?: Maybe<Scalars['float8']>;
  code?: Maybe<Scalars['citext']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Customer_Usage_Stddev_Fields = {
  __typename?: 'customer_usage_stddev_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "customer_usage" */
export type Customer_Usage_Stddev_Order_By = {
  amount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Customer_Usage_Stddev_Pop_Fields = {
  __typename?: 'customer_usage_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "customer_usage" */
export type Customer_Usage_Stddev_Pop_Order_By = {
  amount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Customer_Usage_Stddev_Samp_Fields = {
  __typename?: 'customer_usage_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "customer_usage" */
export type Customer_Usage_Stddev_Samp_Order_By = {
  amount?: Maybe<Order_By>;
};

/** Streaming cursor of the table "customer_usage" */
export type Customer_Usage_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Customer_Usage_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Customer_Usage_Stream_Cursor_Value_Input = {
  amount?: Maybe<Scalars['float8']>;
  code?: Maybe<Scalars['citext']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Customer_Usage_Sum_Fields = {
  __typename?: 'customer_usage_sum_fields';
  amount?: Maybe<Scalars['float8']>;
};

/** order by sum() on columns of table "customer_usage" */
export type Customer_Usage_Sum_Order_By = {
  amount?: Maybe<Order_By>;
};

/** update columns of table "customer_usage" */
export enum Customer_Usage_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
}

export type Customer_Usage_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Customer_Usage_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Customer_Usage_Set_Input>;
  /** filter the rows which have to be updated */
  where: Customer_Usage_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Customer_Usage_Var_Pop_Fields = {
  __typename?: 'customer_usage_var_pop_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "customer_usage" */
export type Customer_Usage_Var_Pop_Order_By = {
  amount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Customer_Usage_Var_Samp_Fields = {
  __typename?: 'customer_usage_var_samp_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "customer_usage" */
export type Customer_Usage_Var_Samp_Order_By = {
  amount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Customer_Usage_Variance_Fields = {
  __typename?: 'customer_usage_variance_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "customer_usage" */
export type Customer_Usage_Variance_Order_By = {
  amount?: Maybe<Order_By>;
};

/** columns and relationships of "data_connector_type" */
export type Data_Connector_Type = {
  __typename?: 'data_connector_type';
  description?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** aggregated selection of "data_connector_type" */
export type Data_Connector_Type_Aggregate = {
  __typename?: 'data_connector_type_aggregate';
  aggregate?: Maybe<Data_Connector_Type_Aggregate_Fields>;
  nodes: Array<Data_Connector_Type>;
};

/** aggregate fields of "data_connector_type" */
export type Data_Connector_Type_Aggregate_Fields = {
  __typename?: 'data_connector_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Data_Connector_Type_Max_Fields>;
  min?: Maybe<Data_Connector_Type_Min_Fields>;
};

/** aggregate fields of "data_connector_type" */
export type Data_Connector_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Data_Connector_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "data_connector_type". All fields are combined with a logical 'AND'. */
export type Data_Connector_Type_Bool_Exp = {
  _and?: Maybe<Array<Data_Connector_Type_Bool_Exp>>;
  _not?: Maybe<Data_Connector_Type_Bool_Exp>;
  _or?: Maybe<Array<Data_Connector_Type_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "data_connector_type" */
export enum Data_Connector_Type_Constraint {
  /** unique or primary key constraint on columns "name" */
  DataConnectorTypePkey = 'data_connector_type_pkey',
}

export enum Data_Connector_Type_Enum {
  MongodbConnector = 'mongodb_connector',
  SuperConnector = 'super_connector',
}

/** Boolean expression to compare columns of type "data_connector_type_enum". All fields are combined with logical 'AND'. */
export type Data_Connector_Type_Enum_Comparison_Exp = {
  _eq?: Maybe<Data_Connector_Type_Enum>;
  _in?: Maybe<Array<Data_Connector_Type_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Data_Connector_Type_Enum>;
  _nin?: Maybe<Array<Data_Connector_Type_Enum>>;
};

/** input type for inserting data into table "data_connector_type" */
export type Data_Connector_Type_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Data_Connector_Type_Max_Fields = {
  __typename?: 'data_connector_type_max_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Data_Connector_Type_Min_Fields = {
  __typename?: 'data_connector_type_min_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "data_connector_type" */
export type Data_Connector_Type_Mutation_Response = {
  __typename?: 'data_connector_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Data_Connector_Type>;
};

/** on_conflict condition type for table "data_connector_type" */
export type Data_Connector_Type_On_Conflict = {
  constraint: Data_Connector_Type_Constraint;
  update_columns?: Array<Data_Connector_Type_Update_Column>;
  where?: Maybe<Data_Connector_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "data_connector_type". */
export type Data_Connector_Type_Order_By = {
  description?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** primary key columns input for table: data_connector_type */
export type Data_Connector_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "data_connector_type" */
export enum Data_Connector_Type_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

/** input type for updating data in table "data_connector_type" */
export type Data_Connector_Type_Set_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "data_connector_type" */
export type Data_Connector_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Data_Connector_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Data_Connector_Type_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** update columns of table "data_connector_type" */
export enum Data_Connector_Type_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

export type Data_Connector_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Data_Connector_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Data_Connector_Type_Bool_Exp;
};

/** Datadog exporter configuration by project */
export type Datadog_Config = {
  __typename?: 'datadog_config';
  created_at: Scalars['timestamptz'];
  /** region of the user's Datadog API key; this determines which Datadog API to use */
  datadog_region: Scalars['String'];
  host?: Maybe<Scalars['String']>;
  /** base64 encoded datadog api key */
  key: Scalars['String'];
  logs_last_logged: Scalars['timestamptz'];
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged: Scalars['timestamptz'];
  metrics_response_code?: Maybe<Scalars['Int']>;
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  service_name?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  traces_last_logged: Scalars['timestamptz'];
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "datadog_config" */
export type Datadog_Config_Aggregate = {
  __typename?: 'datadog_config_aggregate';
  aggregate?: Maybe<Datadog_Config_Aggregate_Fields>;
  nodes: Array<Datadog_Config>;
};

/** aggregate fields of "datadog_config" */
export type Datadog_Config_Aggregate_Fields = {
  __typename?: 'datadog_config_aggregate_fields';
  avg?: Maybe<Datadog_Config_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Datadog_Config_Max_Fields>;
  min?: Maybe<Datadog_Config_Min_Fields>;
  stddev?: Maybe<Datadog_Config_Stddev_Fields>;
  stddev_pop?: Maybe<Datadog_Config_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Datadog_Config_Stddev_Samp_Fields>;
  sum?: Maybe<Datadog_Config_Sum_Fields>;
  var_pop?: Maybe<Datadog_Config_Var_Pop_Fields>;
  var_samp?: Maybe<Datadog_Config_Var_Samp_Fields>;
  variance?: Maybe<Datadog_Config_Variance_Fields>;
};

/** aggregate fields of "datadog_config" */
export type Datadog_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Datadog_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Datadog_Config_Avg_Fields = {
  __typename?: 'datadog_config_avg_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "datadog_config". All fields are combined with a logical 'AND'. */
export type Datadog_Config_Bool_Exp = {
  _and?: Maybe<Array<Datadog_Config_Bool_Exp>>;
  _not?: Maybe<Datadog_Config_Bool_Exp>;
  _or?: Maybe<Array<Datadog_Config_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  datadog_region?: Maybe<String_Comparison_Exp>;
  host?: Maybe<String_Comparison_Exp>;
  key?: Maybe<String_Comparison_Exp>;
  logs_last_logged?: Maybe<Timestamptz_Comparison_Exp>;
  logs_response_code?: Maybe<Int_Comparison_Exp>;
  metrics_last_logged?: Maybe<Timestamptz_Comparison_Exp>;
  metrics_response_code?: Maybe<Int_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  service_name?: Maybe<String_Comparison_Exp>;
  tags?: Maybe<String_Comparison_Exp>;
  traces_last_logged?: Maybe<Timestamptz_Comparison_Exp>;
  traces_response_code?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "datadog_config" */
export enum Datadog_Config_Constraint {
  /** unique or primary key constraint on columns "project_id" */
  DatadogConfigPkey = 'datadog_config_pkey',
}

/** input type for incrementing numeric columns in table "datadog_config" */
export type Datadog_Config_Inc_Input = {
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "datadog_config" */
export type Datadog_Config_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  /** region of the user's Datadog API key; this determines which Datadog API to use */
  datadog_region?: Maybe<Scalars['String']>;
  host?: Maybe<Scalars['String']>;
  /** base64 encoded datadog api key */
  key?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  service_name?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  traces_last_logged?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Datadog_Config_Max_Fields = {
  __typename?: 'datadog_config_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  /** region of the user's Datadog API key; this determines which Datadog API to use */
  datadog_region?: Maybe<Scalars['String']>;
  host?: Maybe<Scalars['String']>;
  /** base64 encoded datadog api key */
  key?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  service_name?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  traces_last_logged?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Datadog_Config_Min_Fields = {
  __typename?: 'datadog_config_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  /** region of the user's Datadog API key; this determines which Datadog API to use */
  datadog_region?: Maybe<Scalars['String']>;
  host?: Maybe<Scalars['String']>;
  /** base64 encoded datadog api key */
  key?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  service_name?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  traces_last_logged?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "datadog_config" */
export type Datadog_Config_Mutation_Response = {
  __typename?: 'datadog_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Datadog_Config>;
};

/** input type for inserting object relation for remote table "datadog_config" */
export type Datadog_Config_Obj_Rel_Insert_Input = {
  data: Datadog_Config_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Datadog_Config_On_Conflict>;
};

/** on_conflict condition type for table "datadog_config" */
export type Datadog_Config_On_Conflict = {
  constraint: Datadog_Config_Constraint;
  update_columns?: Array<Datadog_Config_Update_Column>;
  where?: Maybe<Datadog_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "datadog_config". */
export type Datadog_Config_Order_By = {
  created_at?: Maybe<Order_By>;
  datadog_region?: Maybe<Order_By>;
  host?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  logs_last_logged?: Maybe<Order_By>;
  logs_response_code?: Maybe<Order_By>;
  metrics_last_logged?: Maybe<Order_By>;
  metrics_response_code?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  service_name?: Maybe<Order_By>;
  tags?: Maybe<Order_By>;
  traces_last_logged?: Maybe<Order_By>;
  traces_response_code?: Maybe<Order_By>;
};

/** primary key columns input for table: datadog_config */
export type Datadog_Config_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
};

/** select columns of table "datadog_config" */
export enum Datadog_Config_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DatadogRegion = 'datadog_region',
  /** column name */
  Host = 'host',
  /** column name */
  Key = 'key',
  /** column name */
  LogsLastLogged = 'logs_last_logged',
  /** column name */
  LogsResponseCode = 'logs_response_code',
  /** column name */
  MetricsLastLogged = 'metrics_last_logged',
  /** column name */
  MetricsResponseCode = 'metrics_response_code',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ServiceName = 'service_name',
  /** column name */
  Tags = 'tags',
  /** column name */
  TracesLastLogged = 'traces_last_logged',
  /** column name */
  TracesResponseCode = 'traces_response_code',
}

/** input type for updating data in table "datadog_config" */
export type Datadog_Config_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  /** region of the user's Datadog API key; this determines which Datadog API to use */
  datadog_region?: Maybe<Scalars['String']>;
  host?: Maybe<Scalars['String']>;
  /** base64 encoded datadog api key */
  key?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  service_name?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  traces_last_logged?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Datadog_Config_Stddev_Fields = {
  __typename?: 'datadog_config_stddev_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Datadog_Config_Stddev_Pop_Fields = {
  __typename?: 'datadog_config_stddev_pop_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Datadog_Config_Stddev_Samp_Fields = {
  __typename?: 'datadog_config_stddev_samp_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "datadog_config" */
export type Datadog_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Datadog_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Datadog_Config_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  /** region of the user's Datadog API key; this determines which Datadog API to use */
  datadog_region?: Maybe<Scalars['String']>;
  host?: Maybe<Scalars['String']>;
  /** base64 encoded datadog api key */
  key?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  service_name?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
  traces_last_logged?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Datadog_Config_Sum_Fields = {
  __typename?: 'datadog_config_sum_fields';
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** update columns of table "datadog_config" */
export enum Datadog_Config_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DatadogRegion = 'datadog_region',
  /** column name */
  Host = 'host',
  /** column name */
  Key = 'key',
  /** column name */
  LogsLastLogged = 'logs_last_logged',
  /** column name */
  LogsResponseCode = 'logs_response_code',
  /** column name */
  MetricsLastLogged = 'metrics_last_logged',
  /** column name */
  MetricsResponseCode = 'metrics_response_code',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ServiceName = 'service_name',
  /** column name */
  Tags = 'tags',
  /** column name */
  TracesLastLogged = 'traces_last_logged',
  /** column name */
  TracesResponseCode = 'traces_response_code',
}

export type Datadog_Config_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Datadog_Config_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Datadog_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Datadog_Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Datadog_Config_Var_Pop_Fields = {
  __typename?: 'datadog_config_var_pop_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Datadog_Config_Var_Samp_Fields = {
  __typename?: 'datadog_config_var_samp_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Datadog_Config_Variance_Fields = {
  __typename?: 'datadog_config_variance_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

export type DatadogConfigResponse = {
  __typename?: 'DatadogConfigResponse';
  project_id: Scalars['uuid'];
};

/** Boolean expression to compare columns of type "date". All fields are combined with logical 'AND'. */
export type Date_Comparison_Exp = {
  _eq?: Maybe<Scalars['date']>;
  _gt?: Maybe<Scalars['date']>;
  _gte?: Maybe<Scalars['date']>;
  _in?: Maybe<Array<Scalars['date']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['date']>;
  _lte?: Maybe<Scalars['date']>;
  _neq?: Maybe<Scalars['date']>;
  _nin?: Maybe<Array<Scalars['date']>>;
};

/** Table to store whether the calculated db latency was displayed to the user or not */
export type Db_Latency = {
  __typename?: 'db_latency';
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration: Scalars['Int'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  is_change_region_clicked: Scalars['Boolean'];
  is_latency_displayed: Scalars['Boolean'];
  job_id: Scalars['uuid'];
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id: Scalars['uuid'];
};

/** aggregated selection of "db_latency" */
export type Db_Latency_Aggregate = {
  __typename?: 'db_latency_aggregate';
  aggregate?: Maybe<Db_Latency_Aggregate_Fields>;
  nodes: Array<Db_Latency>;
};

/** aggregate fields of "db_latency" */
export type Db_Latency_Aggregate_Fields = {
  __typename?: 'db_latency_aggregate_fields';
  avg?: Maybe<Db_Latency_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Db_Latency_Max_Fields>;
  min?: Maybe<Db_Latency_Min_Fields>;
  stddev?: Maybe<Db_Latency_Stddev_Fields>;
  stddev_pop?: Maybe<Db_Latency_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Db_Latency_Stddev_Samp_Fields>;
  sum?: Maybe<Db_Latency_Sum_Fields>;
  var_pop?: Maybe<Db_Latency_Var_Pop_Fields>;
  var_samp?: Maybe<Db_Latency_Var_Samp_Fields>;
  variance?: Maybe<Db_Latency_Variance_Fields>;
};

/** aggregate fields of "db_latency" */
export type Db_Latency_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Db_Latency_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Db_Latency_Avg_Fields = {
  __typename?: 'db_latency_avg_fields';
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "db_latency". All fields are combined with a logical 'AND'. */
export type Db_Latency_Bool_Exp = {
  _and?: Maybe<Array<Db_Latency_Bool_Exp>>;
  _not?: Maybe<Db_Latency_Bool_Exp>;
  _or?: Maybe<Array<Db_Latency_Bool_Exp>>;
  console_check_duration?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_change_region_clicked?: Maybe<Boolean_Comparison_Exp>;
  is_latency_displayed?: Maybe<Boolean_Comparison_Exp>;
  job_id?: Maybe<Uuid_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "db_latency" */
export enum Db_Latency_Constraint {
  /** unique or primary key constraint on columns "id" */
  DbLatencyPkey = 'db_latency_pkey',
}

/** input type for incrementing numeric columns in table "db_latency" */
export type Db_Latency_Inc_Input = {
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "db_latency" */
export type Db_Latency_Insert_Input = {
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_change_region_clicked?: Maybe<Scalars['Boolean']>;
  is_latency_displayed?: Maybe<Scalars['Boolean']>;
  job_id?: Maybe<Scalars['uuid']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Db_Latency_Max_Fields = {
  __typename?: 'db_latency_max_fields';
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Db_Latency_Min_Fields = {
  __typename?: 'db_latency_min_fields';
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "db_latency" */
export type Db_Latency_Mutation_Response = {
  __typename?: 'db_latency_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Db_Latency>;
};

/** on_conflict condition type for table "db_latency" */
export type Db_Latency_On_Conflict = {
  constraint: Db_Latency_Constraint;
  update_columns?: Array<Db_Latency_Update_Column>;
  where?: Maybe<Db_Latency_Bool_Exp>;
};

/** Ordering options when selecting data from "db_latency". */
export type Db_Latency_Order_By = {
  console_check_duration?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_change_region_clicked?: Maybe<Order_By>;
  is_latency_displayed?: Maybe<Order_By>;
  job_id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
};

/** primary key columns input for table: db_latency */
export type Db_Latency_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "db_latency" */
export enum Db_Latency_Select_Column {
  /** column name */
  ConsoleCheckDuration = 'console_check_duration',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsChangeRegionClicked = 'is_change_region_clicked',
  /** column name */
  IsLatencyDisplayed = 'is_latency_displayed',
  /** column name */
  JobId = 'job_id',
  /** column name */
  ProjectId = 'project_id',
}

/** input type for updating data in table "db_latency" */
export type Db_Latency_Set_Input = {
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_change_region_clicked?: Maybe<Scalars['Boolean']>;
  is_latency_displayed?: Maybe<Scalars['Boolean']>;
  job_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Db_Latency_Stddev_Fields = {
  __typename?: 'db_latency_stddev_fields';
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Db_Latency_Stddev_Pop_Fields = {
  __typename?: 'db_latency_stddev_pop_fields';
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Db_Latency_Stddev_Samp_Fields = {
  __typename?: 'db_latency_stddev_samp_fields';
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "db_latency" */
export type Db_Latency_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Db_Latency_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Db_Latency_Stream_Cursor_Value_Input = {
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_change_region_clicked?: Maybe<Scalars['Boolean']>;
  is_latency_displayed?: Maybe<Scalars['Boolean']>;
  job_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Db_Latency_Sum_Fields = {
  __typename?: 'db_latency_sum_fields';
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Int']>;
};

/** update columns of table "db_latency" */
export enum Db_Latency_Update_Column {
  /** column name */
  ConsoleCheckDuration = 'console_check_duration',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsChangeRegionClicked = 'is_change_region_clicked',
  /** column name */
  IsLatencyDisplayed = 'is_latency_displayed',
  /** column name */
  JobId = 'job_id',
  /** column name */
  ProjectId = 'project_id',
}

export type Db_Latency_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Db_Latency_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Db_Latency_Set_Input>;
  /** filter the rows which have to be updated */
  where: Db_Latency_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Db_Latency_Var_Pop_Fields = {
  __typename?: 'db_latency_var_pop_fields';
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Db_Latency_Var_Samp_Fields = {
  __typename?: 'db_latency_var_samp_fields';
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Db_Latency_Variance_Fields = {
  __typename?: 'db_latency_variance_fields';
  /** duration it took for the console to send a request to API and wait for the result by polling jobs table in ms */
  console_check_duration?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "ddn.build" */
export type Ddn_Build = {
  __typename?: 'ddn_build';
  /** An array relationship */
  build_sync_statuses: Array<Ddn_Build_Sync_Status>;
  /** An aggregate relationship */
  build_sync_statuses_aggregate: Ddn_Build_Sync_Status_Aggregate;
  created_at: Scalars['timestamptz'];
  description?: Maybe<Scalars['String']>;
  /** An array relationship */
  environments: Array<Ddn_Environment>;
  /** An aggregate relationship */
  environments_aggregate: Ddn_Environment_Aggregate;
  fqdn: Scalars['String'];
  id: Scalars['uuid'];
  /** this will be later moved to a blob storage */
  metadata_binary?: Maybe<Scalars['bytea']>;
  metadata_raw: Scalars['String'];
  ndc_configs: Scalars['jsonb'];
  parent_span_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  project: Ddn_Projects;
  project_id: Scalars['uuid'];
  trace_id?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  version: Scalars['String'];
};

/** columns and relationships of "ddn.build" */
export type Ddn_BuildBuild_Sync_StatusesArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Status_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

/** columns and relationships of "ddn.build" */
export type Ddn_BuildBuild_Sync_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Status_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

/** columns and relationships of "ddn.build" */
export type Ddn_BuildEnvironmentsArgs = {
  distinct_on?: Maybe<Array<Ddn_Environment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Environment_Order_By>>;
  where?: Maybe<Ddn_Environment_Bool_Exp>;
};

/** columns and relationships of "ddn.build" */
export type Ddn_BuildEnvironments_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Environment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Environment_Order_By>>;
  where?: Maybe<Ddn_Environment_Bool_Exp>;
};

/** columns and relationships of "ddn.build" */
export type Ddn_BuildNdc_ConfigsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "ddn.build" */
export type Ddn_Build_Aggregate = {
  __typename?: 'ddn_build_aggregate';
  aggregate?: Maybe<Ddn_Build_Aggregate_Fields>;
  nodes: Array<Ddn_Build>;
};

export type Ddn_Build_Aggregate_Bool_Exp = {
  count?: Maybe<Ddn_Build_Aggregate_Bool_Exp_Count>;
};

export type Ddn_Build_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Ddn_Build_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Ddn_Build_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "ddn.build" */
export type Ddn_Build_Aggregate_Fields = {
  __typename?: 'ddn_build_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Ddn_Build_Max_Fields>;
  min?: Maybe<Ddn_Build_Min_Fields>;
};

/** aggregate fields of "ddn.build" */
export type Ddn_Build_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ddn_Build_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ddn.build" */
export type Ddn_Build_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Ddn_Build_Max_Order_By>;
  min?: Maybe<Ddn_Build_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Ddn_Build_Append_Input = {
  ndc_configs?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "ddn.build" */
export type Ddn_Build_Arr_Rel_Insert_Input = {
  data: Array<Ddn_Build_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Ddn_Build_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ddn.build". All fields are combined with a logical 'AND'. */
export type Ddn_Build_Bool_Exp = {
  _and?: Maybe<Array<Ddn_Build_Bool_Exp>>;
  _not?: Maybe<Ddn_Build_Bool_Exp>;
  _or?: Maybe<Array<Ddn_Build_Bool_Exp>>;
  build_sync_statuses?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
  build_sync_statuses_aggregate?: Maybe<Ddn_Build_Sync_Status_Aggregate_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  environments?: Maybe<Ddn_Environment_Bool_Exp>;
  environments_aggregate?: Maybe<Ddn_Environment_Aggregate_Bool_Exp>;
  fqdn?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  metadata_binary?: Maybe<Bytea_Comparison_Exp>;
  metadata_raw?: Maybe<String_Comparison_Exp>;
  ndc_configs?: Maybe<Jsonb_Comparison_Exp>;
  parent_span_id?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Ddn_Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  trace_id?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  version?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ddn.build" */
export enum Ddn_Build_Constraint {
  /** unique or primary key constraint on columns "fqdn" */
  BuildFqdnKey = 'build_fqdn_key',
  /** unique or primary key constraint on columns "id" */
  BuildPkey = 'build_pkey',
  /** unique or primary key constraint on columns "project_id", "id" */
  UniqueProjectAndBuild = 'unique_project_and_build',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Ddn_Build_Delete_At_Path_Input = {
  ndc_configs?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Ddn_Build_Delete_Elem_Input = {
  ndc_configs?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Ddn_Build_Delete_Key_Input = {
  ndc_configs?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "ddn.build" */
export type Ddn_Build_Insert_Input = {
  build_sync_statuses?: Maybe<Ddn_Build_Sync_Status_Arr_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  environments?: Maybe<Ddn_Environment_Arr_Rel_Insert_Input>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  /** this will be later moved to a blob storage */
  metadata_binary?: Maybe<Scalars['bytea']>;
  metadata_raw?: Maybe<Scalars['String']>;
  ndc_configs?: Maybe<Scalars['jsonb']>;
  parent_span_id?: Maybe<Scalars['String']>;
  project?: Maybe<Ddn_Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  trace_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  version?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Ddn_Build_Max_Fields = {
  __typename?: 'ddn_build_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  metadata_raw?: Maybe<Scalars['String']>;
  parent_span_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  trace_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  version?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "ddn.build" */
export type Ddn_Build_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  metadata_raw?: Maybe<Order_By>;
  parent_span_id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  trace_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Ddn_Build_Min_Fields = {
  __typename?: 'ddn_build_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  metadata_raw?: Maybe<Scalars['String']>;
  parent_span_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  trace_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  version?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "ddn.build" */
export type Ddn_Build_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  metadata_raw?: Maybe<Order_By>;
  parent_span_id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  trace_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** response of any mutation on the table "ddn.build" */
export type Ddn_Build_Mutation_Response = {
  __typename?: 'ddn_build_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ddn_Build>;
};

/** input type for inserting object relation for remote table "ddn.build" */
export type Ddn_Build_Obj_Rel_Insert_Input = {
  data: Ddn_Build_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Ddn_Build_On_Conflict>;
};

/** on_conflict condition type for table "ddn.build" */
export type Ddn_Build_On_Conflict = {
  constraint: Ddn_Build_Constraint;
  update_columns?: Array<Ddn_Build_Update_Column>;
  where?: Maybe<Ddn_Build_Bool_Exp>;
};

/** Ordering options when selecting data from "ddn.build". */
export type Ddn_Build_Order_By = {
  build_sync_statuses_aggregate?: Maybe<Ddn_Build_Sync_Status_Aggregate_Order_By>;
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  environments_aggregate?: Maybe<Ddn_Environment_Aggregate_Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  metadata_binary?: Maybe<Order_By>;
  metadata_raw?: Maybe<Order_By>;
  ndc_configs?: Maybe<Order_By>;
  parent_span_id?: Maybe<Order_By>;
  project?: Maybe<Ddn_Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  trace_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  version?: Maybe<Order_By>;
};

/** primary key columns input for table: ddn.build */
export type Ddn_Build_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Ddn_Build_Prepend_Input = {
  ndc_configs?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "ddn.build" */
export enum Ddn_Build_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  MetadataBinary = 'metadata_binary',
  /** column name */
  MetadataRaw = 'metadata_raw',
  /** column name */
  NdcConfigs = 'ndc_configs',
  /** column name */
  ParentSpanId = 'parent_span_id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  TraceId = 'trace_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Version = 'version',
}

/** input type for updating data in table "ddn.build" */
export type Ddn_Build_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  /** this will be later moved to a blob storage */
  metadata_binary?: Maybe<Scalars['bytea']>;
  metadata_raw?: Maybe<Scalars['String']>;
  ndc_configs?: Maybe<Scalars['jsonb']>;
  parent_span_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  trace_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  version?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "ddn_build" */
export type Ddn_Build_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ddn_Build_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ddn_Build_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  /** this will be later moved to a blob storage */
  metadata_binary?: Maybe<Scalars['bytea']>;
  metadata_raw?: Maybe<Scalars['String']>;
  ndc_configs?: Maybe<Scalars['jsonb']>;
  parent_span_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  trace_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  version?: Maybe<Scalars['String']>;
};

/** columns and relationships of "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status = {
  __typename?: 'ddn_build_sync_status';
  /** An object relationship */
  build: Ddn_Build;
  build_id: Scalars['uuid'];
  /** An object relationship */
  build_sync_worker: Ddn_Build_Sync_Worker;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  environment?: Maybe<Ddn_Environment>;
  environment_id?: Maybe<Scalars['uuid']>;
  id: Scalars['uuid'];
  status?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  worker_id: Scalars['uuid'];
};

/** aggregated selection of "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status_Aggregate = {
  __typename?: 'ddn_build_sync_status_aggregate';
  aggregate?: Maybe<Ddn_Build_Sync_Status_Aggregate_Fields>;
  nodes: Array<Ddn_Build_Sync_Status>;
};

export type Ddn_Build_Sync_Status_Aggregate_Bool_Exp = {
  count?: Maybe<Ddn_Build_Sync_Status_Aggregate_Bool_Exp_Count>;
};

export type Ddn_Build_Sync_Status_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status_Aggregate_Fields = {
  __typename?: 'ddn_build_sync_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Ddn_Build_Sync_Status_Max_Fields>;
  min?: Maybe<Ddn_Build_Sync_Status_Min_Fields>;
};

/** aggregate fields of "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Ddn_Build_Sync_Status_Max_Order_By>;
  min?: Maybe<Ddn_Build_Sync_Status_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status_Arr_Rel_Insert_Input = {
  data: Array<Ddn_Build_Sync_Status_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Ddn_Build_Sync_Status_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ddn.build_sync_status". All fields are combined with a logical 'AND'. */
export type Ddn_Build_Sync_Status_Bool_Exp = {
  _and?: Maybe<Array<Ddn_Build_Sync_Status_Bool_Exp>>;
  _not?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
  _or?: Maybe<Array<Ddn_Build_Sync_Status_Bool_Exp>>;
  build?: Maybe<Ddn_Build_Bool_Exp>;
  build_id?: Maybe<Uuid_Comparison_Exp>;
  build_sync_worker?: Maybe<Ddn_Build_Sync_Worker_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  environment?: Maybe<Ddn_Environment_Bool_Exp>;
  environment_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  worker_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "ddn.build_sync_status" */
export enum Ddn_Build_Sync_Status_Constraint {
  /** unique or primary key constraint on columns "environment_id", "worker_id", "build_id" */
  BuildSyncStatusBuildIdWorkerIdEnvironmentIdKey = 'build_sync_status_build_id_worker_id_environment_id_key',
  /** unique or primary key constraint on columns "id" */
  BuildSyncStatusPkey = 'build_sync_status_pkey',
}

/** input type for inserting data into table "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status_Insert_Input = {
  build?: Maybe<Ddn_Build_Obj_Rel_Insert_Input>;
  build_id?: Maybe<Scalars['uuid']>;
  build_sync_worker?: Maybe<Ddn_Build_Sync_Worker_Obj_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  environment?: Maybe<Ddn_Environment_Obj_Rel_Insert_Input>;
  environment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Ddn_Build_Sync_Status_Max_Fields = {
  __typename?: 'ddn_build_sync_status_max_fields';
  build_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  environment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status_Max_Order_By = {
  build_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  environment_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Ddn_Build_Sync_Status_Min_Fields = {
  __typename?: 'ddn_build_sync_status_min_fields';
  build_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  environment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status_Min_Order_By = {
  build_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  environment_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status_Mutation_Response = {
  __typename?: 'ddn_build_sync_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ddn_Build_Sync_Status>;
};

/** on_conflict condition type for table "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status_On_Conflict = {
  constraint: Ddn_Build_Sync_Status_Constraint;
  update_columns?: Array<Ddn_Build_Sync_Status_Update_Column>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "ddn.build_sync_status". */
export type Ddn_Build_Sync_Status_Order_By = {
  build?: Maybe<Ddn_Build_Order_By>;
  build_id?: Maybe<Order_By>;
  build_sync_worker?: Maybe<Ddn_Build_Sync_Worker_Order_By>;
  created_at?: Maybe<Order_By>;
  environment?: Maybe<Ddn_Environment_Order_By>;
  environment_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** primary key columns input for table: ddn.build_sync_status */
export type Ddn_Build_Sync_Status_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "ddn.build_sync_status" */
export enum Ddn_Build_Sync_Status_Select_Column {
  /** column name */
  BuildId = 'build_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EnvironmentId = 'environment_id',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WorkerId = 'worker_id',
}

/** input type for updating data in table "ddn.build_sync_status" */
export type Ddn_Build_Sync_Status_Set_Input = {
  build_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  environment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "ddn_build_sync_status" */
export type Ddn_Build_Sync_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ddn_Build_Sync_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ddn_Build_Sync_Status_Stream_Cursor_Value_Input = {
  build_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  environment_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "ddn.build_sync_status" */
export enum Ddn_Build_Sync_Status_Update_Column {
  /** column name */
  BuildId = 'build_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EnvironmentId = 'environment_id',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WorkerId = 'worker_id',
}

export type Ddn_Build_Sync_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Ddn_Build_Sync_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ddn_Build_Sync_Status_Bool_Exp;
};

/** columns and relationships of "ddn.build_sync_worker" */
export type Ddn_Build_Sync_Worker = {
  __typename?: 'ddn_build_sync_worker';
  /** An array relationship */
  build_sync_statuses: Array<Ddn_Build_Sync_Status>;
  /** An aggregate relationship */
  build_sync_statuses_aggregate: Ddn_Build_Sync_Status_Aggregate;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  is_active: Scalars['Boolean'];
  region?: Maybe<Scalars['String']>;
  /** An object relationship */
  regionByCloudRegion?: Maybe<Region>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "ddn.build_sync_worker" */
export type Ddn_Build_Sync_WorkerBuild_Sync_StatusesArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Status_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

/** columns and relationships of "ddn.build_sync_worker" */
export type Ddn_Build_Sync_WorkerBuild_Sync_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Status_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

/** aggregated selection of "ddn.build_sync_worker" */
export type Ddn_Build_Sync_Worker_Aggregate = {
  __typename?: 'ddn_build_sync_worker_aggregate';
  aggregate?: Maybe<Ddn_Build_Sync_Worker_Aggregate_Fields>;
  nodes: Array<Ddn_Build_Sync_Worker>;
};

/** aggregate fields of "ddn.build_sync_worker" */
export type Ddn_Build_Sync_Worker_Aggregate_Fields = {
  __typename?: 'ddn_build_sync_worker_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Ddn_Build_Sync_Worker_Max_Fields>;
  min?: Maybe<Ddn_Build_Sync_Worker_Min_Fields>;
};

/** aggregate fields of "ddn.build_sync_worker" */
export type Ddn_Build_Sync_Worker_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ddn_Build_Sync_Worker_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "ddn.build_sync_worker". All fields are combined with a logical 'AND'. */
export type Ddn_Build_Sync_Worker_Bool_Exp = {
  _and?: Maybe<Array<Ddn_Build_Sync_Worker_Bool_Exp>>;
  _not?: Maybe<Ddn_Build_Sync_Worker_Bool_Exp>;
  _or?: Maybe<Array<Ddn_Build_Sync_Worker_Bool_Exp>>;
  build_sync_statuses?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
  build_sync_statuses_aggregate?: Maybe<Ddn_Build_Sync_Status_Aggregate_Bool_Exp>;
  cloud?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  regionByCloudRegion?: Maybe<Region_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "ddn.build_sync_worker" */
export enum Ddn_Build_Sync_Worker_Constraint {
  /** unique or primary key constraint on columns "id" */
  BuildSyncWorkerPkey = 'build_sync_worker_pkey',
}

/** input type for inserting data into table "ddn.build_sync_worker" */
export type Ddn_Build_Sync_Worker_Insert_Input = {
  build_sync_statuses?: Maybe<Ddn_Build_Sync_Status_Arr_Rel_Insert_Input>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  region?: Maybe<Scalars['String']>;
  regionByCloudRegion?: Maybe<Region_Obj_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Ddn_Build_Sync_Worker_Max_Fields = {
  __typename?: 'ddn_build_sync_worker_max_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Ddn_Build_Sync_Worker_Min_Fields = {
  __typename?: 'ddn_build_sync_worker_min_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "ddn.build_sync_worker" */
export type Ddn_Build_Sync_Worker_Mutation_Response = {
  __typename?: 'ddn_build_sync_worker_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ddn_Build_Sync_Worker>;
};

/** input type for inserting object relation for remote table "ddn.build_sync_worker" */
export type Ddn_Build_Sync_Worker_Obj_Rel_Insert_Input = {
  data: Ddn_Build_Sync_Worker_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Ddn_Build_Sync_Worker_On_Conflict>;
};

/** on_conflict condition type for table "ddn.build_sync_worker" */
export type Ddn_Build_Sync_Worker_On_Conflict = {
  constraint: Ddn_Build_Sync_Worker_Constraint;
  update_columns?: Array<Ddn_Build_Sync_Worker_Update_Column>;
  where?: Maybe<Ddn_Build_Sync_Worker_Bool_Exp>;
};

/** Ordering options when selecting data from "ddn.build_sync_worker". */
export type Ddn_Build_Sync_Worker_Order_By = {
  build_sync_statuses_aggregate?: Maybe<Ddn_Build_Sync_Status_Aggregate_Order_By>;
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  regionByCloudRegion?: Maybe<Region_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: ddn.build_sync_worker */
export type Ddn_Build_Sync_Worker_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "ddn.build_sync_worker" */
export enum Ddn_Build_Sync_Worker_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "ddn.build_sync_worker" */
export type Ddn_Build_Sync_Worker_Set_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "ddn_build_sync_worker" */
export type Ddn_Build_Sync_Worker_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ddn_Build_Sync_Worker_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ddn_Build_Sync_Worker_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ddn.build_sync_worker" */
export enum Ddn_Build_Sync_Worker_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Ddn_Build_Sync_Worker_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Ddn_Build_Sync_Worker_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ddn_Build_Sync_Worker_Bool_Exp;
};

/** update columns of table "ddn.build" */
export enum Ddn_Build_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  MetadataBinary = 'metadata_binary',
  /** column name */
  MetadataRaw = 'metadata_raw',
  /** column name */
  NdcConfigs = 'ndc_configs',
  /** column name */
  ParentSpanId = 'parent_span_id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  TraceId = 'trace_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Version = 'version',
}

export type Ddn_Build_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Ddn_Build_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Ddn_Build_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Ddn_Build_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Ddn_Build_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Ddn_Build_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Ddn_Build_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ddn_Build_Bool_Exp;
};

/** columns and relationships of "ddn.environment" */
export type Ddn_Environment = {
  __typename?: 'ddn_environment';
  /** An object relationship */
  build?: Maybe<Ddn_Build>;
  /** An array relationship */
  build_sync_statuses: Array<Ddn_Build_Sync_Status>;
  /** An aggregate relationship */
  build_sync_statuses_aggregate: Ddn_Build_Sync_Status_Aggregate;
  created_at: Scalars['timestamptz'];
  current_build_id?: Maybe<Scalars['uuid']>;
  fqdn: Scalars['String'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  /** An object relationship */
  project: Ddn_Projects;
  project_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "ddn.environment" */
export type Ddn_EnvironmentBuild_Sync_StatusesArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Status_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

/** columns and relationships of "ddn.environment" */
export type Ddn_EnvironmentBuild_Sync_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Status_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

/** aggregated selection of "ddn.environment" */
export type Ddn_Environment_Aggregate = {
  __typename?: 'ddn_environment_aggregate';
  aggregate?: Maybe<Ddn_Environment_Aggregate_Fields>;
  nodes: Array<Ddn_Environment>;
};

export type Ddn_Environment_Aggregate_Bool_Exp = {
  count?: Maybe<Ddn_Environment_Aggregate_Bool_Exp_Count>;
};

export type Ddn_Environment_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Ddn_Environment_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Ddn_Environment_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "ddn.environment" */
export type Ddn_Environment_Aggregate_Fields = {
  __typename?: 'ddn_environment_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Ddn_Environment_Max_Fields>;
  min?: Maybe<Ddn_Environment_Min_Fields>;
};

/** aggregate fields of "ddn.environment" */
export type Ddn_Environment_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ddn_Environment_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ddn.environment" */
export type Ddn_Environment_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Ddn_Environment_Max_Order_By>;
  min?: Maybe<Ddn_Environment_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ddn.environment" */
export type Ddn_Environment_Arr_Rel_Insert_Input = {
  data: Array<Ddn_Environment_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Ddn_Environment_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ddn.environment". All fields are combined with a logical 'AND'. */
export type Ddn_Environment_Bool_Exp = {
  _and?: Maybe<Array<Ddn_Environment_Bool_Exp>>;
  _not?: Maybe<Ddn_Environment_Bool_Exp>;
  _or?: Maybe<Array<Ddn_Environment_Bool_Exp>>;
  build?: Maybe<Ddn_Build_Bool_Exp>;
  build_sync_statuses?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
  build_sync_statuses_aggregate?: Maybe<Ddn_Build_Sync_Status_Aggregate_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  current_build_id?: Maybe<Uuid_Comparison_Exp>;
  fqdn?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Ddn_Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "ddn.environment" */
export enum Ddn_Environment_Constraint {
  /** unique or primary key constraint on columns "id" */
  EnvironmentPkey = 'environment_pkey',
}

/** input type for inserting data into table "ddn.environment" */
export type Ddn_Environment_Insert_Input = {
  build?: Maybe<Ddn_Build_Obj_Rel_Insert_Input>;
  build_sync_statuses?: Maybe<Ddn_Build_Sync_Status_Arr_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  current_build_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  project?: Maybe<Ddn_Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Ddn_Environment_Max_Fields = {
  __typename?: 'ddn_environment_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  current_build_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "ddn.environment" */
export type Ddn_Environment_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  current_build_id?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Ddn_Environment_Min_Fields = {
  __typename?: 'ddn_environment_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  current_build_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "ddn.environment" */
export type Ddn_Environment_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  current_build_id?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "ddn.environment" */
export type Ddn_Environment_Mutation_Response = {
  __typename?: 'ddn_environment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ddn_Environment>;
};

/** input type for inserting object relation for remote table "ddn.environment" */
export type Ddn_Environment_Obj_Rel_Insert_Input = {
  data: Ddn_Environment_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Ddn_Environment_On_Conflict>;
};

/** on_conflict condition type for table "ddn.environment" */
export type Ddn_Environment_On_Conflict = {
  constraint: Ddn_Environment_Constraint;
  update_columns?: Array<Ddn_Environment_Update_Column>;
  where?: Maybe<Ddn_Environment_Bool_Exp>;
};

/** Ordering options when selecting data from "ddn.environment". */
export type Ddn_Environment_Order_By = {
  build?: Maybe<Ddn_Build_Order_By>;
  build_sync_statuses_aggregate?: Maybe<Ddn_Build_Sync_Status_Aggregate_Order_By>;
  created_at?: Maybe<Order_By>;
  current_build_id?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  project?: Maybe<Ddn_Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: ddn.environment */
export type Ddn_Environment_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "ddn.environment" */
export enum Ddn_Environment_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentBuildId = 'current_build_id',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "ddn.environment" */
export type Ddn_Environment_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  current_build_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "ddn_environment" */
export type Ddn_Environment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ddn_Environment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ddn_Environment_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  current_build_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ddn.environment" */
export enum Ddn_Environment_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentBuildId = 'current_build_id',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Ddn_Environment_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Ddn_Environment_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ddn_Environment_Bool_Exp;
};

/** columns and relationships of "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access = {
  __typename?: 'ddn_project_entitlement_access';
  created_at: Scalars['timestamp'];
  /** An object relationship */
  entitlement: Ddn_Project_Entitlement_Catalogue;
  entitlement_id: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  project: Ddn_Projects;
  project_id: Scalars['uuid'];
  updated_at: Scalars['timestamp'];
};

/** aggregated selection of "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_Aggregate = {
  __typename?: 'ddn_project_entitlement_access_aggregate';
  aggregate?: Maybe<Ddn_Project_Entitlement_Access_Aggregate_Fields>;
  nodes: Array<Ddn_Project_Entitlement_Access>;
};

export type Ddn_Project_Entitlement_Access_Aggregate_Bool_Exp = {
  count?: Maybe<Ddn_Project_Entitlement_Access_Aggregate_Bool_Exp_Count>;
};

export type Ddn_Project_Entitlement_Access_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Ddn_Project_Entitlement_Access_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Ddn_Project_Entitlement_Access_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_Aggregate_Fields = {
  __typename?: 'ddn_project_entitlement_access_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Ddn_Project_Entitlement_Access_Max_Fields>;
  min?: Maybe<Ddn_Project_Entitlement_Access_Min_Fields>;
};

/** aggregate fields of "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ddn_Project_Entitlement_Access_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Ddn_Project_Entitlement_Access_Max_Order_By>;
  min?: Maybe<Ddn_Project_Entitlement_Access_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_Arr_Rel_Insert_Input = {
  data: Array<Ddn_Project_Entitlement_Access_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Ddn_Project_Entitlement_Access_On_Conflict>;
};

/**
 * Boolean expression to filter rows from the table
 * "ddn.project_entitlement_access". All fields are combined with a logical 'AND'.
 */
export type Ddn_Project_Entitlement_Access_Bool_Exp = {
  _and?: Maybe<Array<Ddn_Project_Entitlement_Access_Bool_Exp>>;
  _not?: Maybe<Ddn_Project_Entitlement_Access_Bool_Exp>;
  _or?: Maybe<Array<Ddn_Project_Entitlement_Access_Bool_Exp>>;
  created_at?: Maybe<Timestamp_Comparison_Exp>;
  entitlement?: Maybe<Ddn_Project_Entitlement_Catalogue_Bool_Exp>;
  entitlement_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  project?: Maybe<Ddn_Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "ddn.project_entitlement_access" */
export enum Ddn_Project_Entitlement_Access_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectEntitlementAccessPkey = 'project_entitlement_access_pkey',
}

/** input type for inserting data into table "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_Insert_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement?: Maybe<Ddn_Project_Entitlement_Catalogue_Obj_Rel_Insert_Input>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project?: Maybe<Ddn_Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Ddn_Project_Entitlement_Access_Max_Fields = {
  __typename?: 'ddn_project_entitlement_access_max_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by max() on columns of table "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Ddn_Project_Entitlement_Access_Min_Fields = {
  __typename?: 'ddn_project_entitlement_access_min_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by min() on columns of table "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_Mutation_Response = {
  __typename?: 'ddn_project_entitlement_access_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ddn_Project_Entitlement_Access>;
};

/** on_conflict condition type for table "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_On_Conflict = {
  constraint: Ddn_Project_Entitlement_Access_Constraint;
  update_columns?: Array<Ddn_Project_Entitlement_Access_Update_Column>;
  where?: Maybe<Ddn_Project_Entitlement_Access_Bool_Exp>;
};

/** Ordering options when selecting data from "ddn.project_entitlement_access". */
export type Ddn_Project_Entitlement_Access_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement?: Maybe<Ddn_Project_Entitlement_Catalogue_Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project?: Maybe<Ddn_Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: ddn.project_entitlement_access */
export type Ddn_Project_Entitlement_Access_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "ddn.project_entitlement_access" */
export enum Ddn_Project_Entitlement_Access_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntitlementId = 'entitlement_id',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "ddn.project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_Set_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** Streaming cursor of the table "ddn_project_entitlement_access" */
export type Ddn_Project_Entitlement_Access_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ddn_Project_Entitlement_Access_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ddn_Project_Entitlement_Access_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** update columns of table "ddn.project_entitlement_access" */
export enum Ddn_Project_Entitlement_Access_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntitlementId = 'entitlement_id',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Ddn_Project_Entitlement_Access_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Ddn_Project_Entitlement_Access_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ddn_Project_Entitlement_Access_Bool_Exp;
};

/** Stores all versions of all types of v3 project entitlements. */
export type Ddn_Project_Entitlement_Catalogue = {
  __typename?: 'ddn_project_entitlement_catalogue';
  config_is_enabled: Scalars['Boolean'];
  config_limit?: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamp'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  type: Ddn_Project_Entitlement_Types_Enum;
  updated_at: Scalars['timestamp'];
};

/** aggregated selection of "ddn.project_entitlement_catalogue" */
export type Ddn_Project_Entitlement_Catalogue_Aggregate = {
  __typename?: 'ddn_project_entitlement_catalogue_aggregate';
  aggregate?: Maybe<Ddn_Project_Entitlement_Catalogue_Aggregate_Fields>;
  nodes: Array<Ddn_Project_Entitlement_Catalogue>;
};

/** aggregate fields of "ddn.project_entitlement_catalogue" */
export type Ddn_Project_Entitlement_Catalogue_Aggregate_Fields = {
  __typename?: 'ddn_project_entitlement_catalogue_aggregate_fields';
  avg?: Maybe<Ddn_Project_Entitlement_Catalogue_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Ddn_Project_Entitlement_Catalogue_Max_Fields>;
  min?: Maybe<Ddn_Project_Entitlement_Catalogue_Min_Fields>;
  stddev?: Maybe<Ddn_Project_Entitlement_Catalogue_Stddev_Fields>;
  stddev_pop?: Maybe<Ddn_Project_Entitlement_Catalogue_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ddn_Project_Entitlement_Catalogue_Stddev_Samp_Fields>;
  sum?: Maybe<Ddn_Project_Entitlement_Catalogue_Sum_Fields>;
  var_pop?: Maybe<Ddn_Project_Entitlement_Catalogue_Var_Pop_Fields>;
  var_samp?: Maybe<Ddn_Project_Entitlement_Catalogue_Var_Samp_Fields>;
  variance?: Maybe<Ddn_Project_Entitlement_Catalogue_Variance_Fields>;
};

/** aggregate fields of "ddn.project_entitlement_catalogue" */
export type Ddn_Project_Entitlement_Catalogue_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ddn_Project_Entitlement_Catalogue_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Ddn_Project_Entitlement_Catalogue_Avg_Fields = {
  __typename?: 'ddn_project_entitlement_catalogue_avg_fields';
  config_limit?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table
 * "ddn.project_entitlement_catalogue". All fields are combined with a logical 'AND'.
 */
export type Ddn_Project_Entitlement_Catalogue_Bool_Exp = {
  _and?: Maybe<Array<Ddn_Project_Entitlement_Catalogue_Bool_Exp>>;
  _not?: Maybe<Ddn_Project_Entitlement_Catalogue_Bool_Exp>;
  _or?: Maybe<Array<Ddn_Project_Entitlement_Catalogue_Bool_Exp>>;
  config_is_enabled?: Maybe<Boolean_Comparison_Exp>;
  config_limit?: Maybe<Int_Comparison_Exp>;
  created_at?: Maybe<Timestamp_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  type?: Maybe<Ddn_Project_Entitlement_Types_Enum_Comparison_Exp>;
  updated_at?: Maybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "ddn.project_entitlement_catalogue" */
export enum Ddn_Project_Entitlement_Catalogue_Constraint {
  /** unique or primary key constraint on columns "name" */
  ProjectEntitlementCatalogueNameKey = 'project_entitlement_catalogue_name_key',
  /** unique or primary key constraint on columns "id" */
  ProjectEntitlementCataloguePkey = 'project_entitlement_catalogue_pkey',
}

/** input type for incrementing numeric columns in table "ddn.project_entitlement_catalogue" */
export type Ddn_Project_Entitlement_Catalogue_Inc_Input = {
  config_limit?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "ddn.project_entitlement_catalogue" */
export type Ddn_Project_Entitlement_Catalogue_Insert_Input = {
  config_is_enabled?: Maybe<Scalars['Boolean']>;
  config_limit?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Ddn_Project_Entitlement_Types_Enum>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Ddn_Project_Entitlement_Catalogue_Max_Fields = {
  __typename?: 'ddn_project_entitlement_catalogue_max_fields';
  config_limit?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type Ddn_Project_Entitlement_Catalogue_Min_Fields = {
  __typename?: 'ddn_project_entitlement_catalogue_min_fields';
  config_limit?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "ddn.project_entitlement_catalogue" */
export type Ddn_Project_Entitlement_Catalogue_Mutation_Response = {
  __typename?: 'ddn_project_entitlement_catalogue_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ddn_Project_Entitlement_Catalogue>;
};

/** input type for inserting object relation for remote table "ddn.project_entitlement_catalogue" */
export type Ddn_Project_Entitlement_Catalogue_Obj_Rel_Insert_Input = {
  data: Ddn_Project_Entitlement_Catalogue_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Ddn_Project_Entitlement_Catalogue_On_Conflict>;
};

/** on_conflict condition type for table "ddn.project_entitlement_catalogue" */
export type Ddn_Project_Entitlement_Catalogue_On_Conflict = {
  constraint: Ddn_Project_Entitlement_Catalogue_Constraint;
  update_columns?: Array<Ddn_Project_Entitlement_Catalogue_Update_Column>;
  where?: Maybe<Ddn_Project_Entitlement_Catalogue_Bool_Exp>;
};

/** Ordering options when selecting data from "ddn.project_entitlement_catalogue". */
export type Ddn_Project_Entitlement_Catalogue_Order_By = {
  config_is_enabled?: Maybe<Order_By>;
  config_limit?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: ddn.project_entitlement_catalogue */
export type Ddn_Project_Entitlement_Catalogue_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "ddn.project_entitlement_catalogue" */
export enum Ddn_Project_Entitlement_Catalogue_Select_Column {
  /** column name */
  ConfigIsEnabled = 'config_is_enabled',
  /** column name */
  ConfigLimit = 'config_limit',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "ddn.project_entitlement_catalogue" */
export type Ddn_Project_Entitlement_Catalogue_Set_Input = {
  config_is_enabled?: Maybe<Scalars['Boolean']>;
  config_limit?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Ddn_Project_Entitlement_Types_Enum>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Ddn_Project_Entitlement_Catalogue_Stddev_Fields = {
  __typename?: 'ddn_project_entitlement_catalogue_stddev_fields';
  config_limit?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Ddn_Project_Entitlement_Catalogue_Stddev_Pop_Fields = {
  __typename?: 'ddn_project_entitlement_catalogue_stddev_pop_fields';
  config_limit?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Ddn_Project_Entitlement_Catalogue_Stddev_Samp_Fields = {
  __typename?: 'ddn_project_entitlement_catalogue_stddev_samp_fields';
  config_limit?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "ddn_project_entitlement_catalogue" */
export type Ddn_Project_Entitlement_Catalogue_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ddn_Project_Entitlement_Catalogue_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ddn_Project_Entitlement_Catalogue_Stream_Cursor_Value_Input = {
  config_is_enabled?: Maybe<Scalars['Boolean']>;
  config_limit?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Ddn_Project_Entitlement_Types_Enum>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate sum on columns */
export type Ddn_Project_Entitlement_Catalogue_Sum_Fields = {
  __typename?: 'ddn_project_entitlement_catalogue_sum_fields';
  config_limit?: Maybe<Scalars['Int']>;
};

/** update columns of table "ddn.project_entitlement_catalogue" */
export enum Ddn_Project_Entitlement_Catalogue_Update_Column {
  /** column name */
  ConfigIsEnabled = 'config_is_enabled',
  /** column name */
  ConfigLimit = 'config_limit',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Ddn_Project_Entitlement_Catalogue_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Ddn_Project_Entitlement_Catalogue_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Ddn_Project_Entitlement_Catalogue_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ddn_Project_Entitlement_Catalogue_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Ddn_Project_Entitlement_Catalogue_Var_Pop_Fields = {
  __typename?: 'ddn_project_entitlement_catalogue_var_pop_fields';
  config_limit?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Ddn_Project_Entitlement_Catalogue_Var_Samp_Fields = {
  __typename?: 'ddn_project_entitlement_catalogue_var_samp_fields';
  config_limit?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Ddn_Project_Entitlement_Catalogue_Variance_Fields = {
  __typename?: 'ddn_project_entitlement_catalogue_variance_fields';
  config_limit?: Maybe<Scalars['Float']>;
};

/** Enums representing types/categories of entitlements for a Hasura v3 project */
export type Ddn_Project_Entitlement_Types = {
  __typename?: 'ddn_project_entitlement_types';
  comment: Scalars['String'];
  value: Scalars['String'];
};

/** aggregated selection of "ddn.project_entitlement_types" */
export type Ddn_Project_Entitlement_Types_Aggregate = {
  __typename?: 'ddn_project_entitlement_types_aggregate';
  aggregate?: Maybe<Ddn_Project_Entitlement_Types_Aggregate_Fields>;
  nodes: Array<Ddn_Project_Entitlement_Types>;
};

/** aggregate fields of "ddn.project_entitlement_types" */
export type Ddn_Project_Entitlement_Types_Aggregate_Fields = {
  __typename?: 'ddn_project_entitlement_types_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Ddn_Project_Entitlement_Types_Max_Fields>;
  min?: Maybe<Ddn_Project_Entitlement_Types_Min_Fields>;
};

/** aggregate fields of "ddn.project_entitlement_types" */
export type Ddn_Project_Entitlement_Types_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ddn_Project_Entitlement_Types_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/**
 * Boolean expression to filter rows from the table
 * "ddn.project_entitlement_types". All fields are combined with a logical 'AND'.
 */
export type Ddn_Project_Entitlement_Types_Bool_Exp = {
  _and?: Maybe<Array<Ddn_Project_Entitlement_Types_Bool_Exp>>;
  _not?: Maybe<Ddn_Project_Entitlement_Types_Bool_Exp>;
  _or?: Maybe<Array<Ddn_Project_Entitlement_Types_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ddn.project_entitlement_types" */
export enum Ddn_Project_Entitlement_Types_Constraint {
  /** unique or primary key constraint on columns "value" */
  ProjectEntitlementTypesPkey = 'project_entitlement_types_pkey',
}

export enum Ddn_Project_Entitlement_Types_Enum {
  /** Maximum number of builds a v3 project can have at once */
  BuildLimit = 'build_limit',
  /** Maximum number of builds a v3 project can have at once */
  EnvironmentLimit = 'environment_limit',
  /** Maximum size in for a serialized metadata artifact */
  MetadataSizeLimit = 'metadata_size_limit',
}

/**
 * Boolean expression to compare columns of type
 * "ddn_project_entitlement_types_enum". All fields are combined with logical 'AND'.
 */
export type Ddn_Project_Entitlement_Types_Enum_Comparison_Exp = {
  _eq?: Maybe<Ddn_Project_Entitlement_Types_Enum>;
  _in?: Maybe<Array<Ddn_Project_Entitlement_Types_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Ddn_Project_Entitlement_Types_Enum>;
  _nin?: Maybe<Array<Ddn_Project_Entitlement_Types_Enum>>;
};

/** input type for inserting data into table "ddn.project_entitlement_types" */
export type Ddn_Project_Entitlement_Types_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Ddn_Project_Entitlement_Types_Max_Fields = {
  __typename?: 'ddn_project_entitlement_types_max_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Ddn_Project_Entitlement_Types_Min_Fields = {
  __typename?: 'ddn_project_entitlement_types_min_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "ddn.project_entitlement_types" */
export type Ddn_Project_Entitlement_Types_Mutation_Response = {
  __typename?: 'ddn_project_entitlement_types_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ddn_Project_Entitlement_Types>;
};

/** on_conflict condition type for table "ddn.project_entitlement_types" */
export type Ddn_Project_Entitlement_Types_On_Conflict = {
  constraint: Ddn_Project_Entitlement_Types_Constraint;
  update_columns?: Array<Ddn_Project_Entitlement_Types_Update_Column>;
  where?: Maybe<Ddn_Project_Entitlement_Types_Bool_Exp>;
};

/** Ordering options when selecting data from "ddn.project_entitlement_types". */
export type Ddn_Project_Entitlement_Types_Order_By = {
  comment?: Maybe<Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: ddn.project_entitlement_types */
export type Ddn_Project_Entitlement_Types_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "ddn.project_entitlement_types" */
export enum Ddn_Project_Entitlement_Types_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value',
}

/** input type for updating data in table "ddn.project_entitlement_types" */
export type Ddn_Project_Entitlement_Types_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "ddn_project_entitlement_types" */
export type Ddn_Project_Entitlement_Types_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ddn_Project_Entitlement_Types_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ddn_Project_Entitlement_Types_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "ddn.project_entitlement_types" */
export enum Ddn_Project_Entitlement_Types_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value',
}

export type Ddn_Project_Entitlement_Types_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Ddn_Project_Entitlement_Types_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ddn_Project_Entitlement_Types_Bool_Exp;
};

/** columns and relationships of "ddn.projects" */
export type Ddn_Projects = {
  __typename?: 'ddn_projects';
  /** An array relationship */
  builds: Array<Ddn_Build>;
  /** An aggregate relationship */
  builds_aggregate: Ddn_Build_Aggregate;
  created_at: Scalars['timestamptz'];
  /** An array relationship */
  entitlements: Array<Ddn_Project_Entitlement_Access>;
  /** An aggregate relationship */
  entitlements_aggregate: Ddn_Project_Entitlement_Access_Aggregate;
  /** An array relationship */
  environments: Array<Ddn_Environment>;
  /** An aggregate relationship */
  environments_aggregate: Ddn_Environment_Aggregate;
  id: Scalars['uuid'];
  name: Scalars['String'];
  owner_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
};

/** columns and relationships of "ddn.projects" */
export type Ddn_ProjectsBuildsArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Order_By>>;
  where?: Maybe<Ddn_Build_Bool_Exp>;
};

/** columns and relationships of "ddn.projects" */
export type Ddn_ProjectsBuilds_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Order_By>>;
  where?: Maybe<Ddn_Build_Bool_Exp>;
};

/** columns and relationships of "ddn.projects" */
export type Ddn_ProjectsEntitlementsArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Access_Bool_Exp>;
};

/** columns and relationships of "ddn.projects" */
export type Ddn_ProjectsEntitlements_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Access_Bool_Exp>;
};

/** columns and relationships of "ddn.projects" */
export type Ddn_ProjectsEnvironmentsArgs = {
  distinct_on?: Maybe<Array<Ddn_Environment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Environment_Order_By>>;
  where?: Maybe<Ddn_Environment_Bool_Exp>;
};

/** columns and relationships of "ddn.projects" */
export type Ddn_ProjectsEnvironments_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Environment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Environment_Order_By>>;
  where?: Maybe<Ddn_Environment_Bool_Exp>;
};

/** aggregated selection of "ddn.projects" */
export type Ddn_Projects_Aggregate = {
  __typename?: 'ddn_projects_aggregate';
  aggregate?: Maybe<Ddn_Projects_Aggregate_Fields>;
  nodes: Array<Ddn_Projects>;
};

/** aggregate fields of "ddn.projects" */
export type Ddn_Projects_Aggregate_Fields = {
  __typename?: 'ddn_projects_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Ddn_Projects_Max_Fields>;
  min?: Maybe<Ddn_Projects_Min_Fields>;
};

/** aggregate fields of "ddn.projects" */
export type Ddn_Projects_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ddn_Projects_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "ddn.projects". All fields are combined with a logical 'AND'. */
export type Ddn_Projects_Bool_Exp = {
  _and?: Maybe<Array<Ddn_Projects_Bool_Exp>>;
  _not?: Maybe<Ddn_Projects_Bool_Exp>;
  _or?: Maybe<Array<Ddn_Projects_Bool_Exp>>;
  builds?: Maybe<Ddn_Build_Bool_Exp>;
  builds_aggregate?: Maybe<Ddn_Build_Aggregate_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  entitlements?: Maybe<Ddn_Project_Entitlement_Access_Bool_Exp>;
  entitlements_aggregate?: Maybe<Ddn_Project_Entitlement_Access_Aggregate_Bool_Exp>;
  environments?: Maybe<Ddn_Environment_Bool_Exp>;
  environments_aggregate?: Maybe<Ddn_Environment_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  owner_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
};

/** unique or primary key constraints on table "ddn.projects" */
export enum Ddn_Projects_Constraint {
  /** unique or primary key constraint on columns "name" */
  ProjectsNameKey = 'projects_name_key',
  /** unique or primary key constraint on columns "id" */
  ProjectsPkey = 'projects_pkey',
}

/** input type for inserting data into table "ddn.projects" */
export type Ddn_Projects_Insert_Input = {
  builds?: Maybe<Ddn_Build_Arr_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  entitlements?: Maybe<Ddn_Project_Entitlement_Access_Arr_Rel_Insert_Input>;
  environments?: Maybe<Ddn_Environment_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  owner_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Ddn_Projects_Max_Fields = {
  __typename?: 'ddn_projects_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  owner_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Ddn_Projects_Min_Fields = {
  __typename?: 'ddn_projects_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  owner_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "ddn.projects" */
export type Ddn_Projects_Mutation_Response = {
  __typename?: 'ddn_projects_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ddn_Projects>;
};

/** input type for inserting object relation for remote table "ddn.projects" */
export type Ddn_Projects_Obj_Rel_Insert_Input = {
  data: Ddn_Projects_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Ddn_Projects_On_Conflict>;
};

/** on_conflict condition type for table "ddn.projects" */
export type Ddn_Projects_On_Conflict = {
  constraint: Ddn_Projects_Constraint;
  update_columns?: Array<Ddn_Projects_Update_Column>;
  where?: Maybe<Ddn_Projects_Bool_Exp>;
};

/** Ordering options when selecting data from "ddn.projects". */
export type Ddn_Projects_Order_By = {
  builds_aggregate?: Maybe<Ddn_Build_Aggregate_Order_By>;
  created_at?: Maybe<Order_By>;
  entitlements_aggregate?: Maybe<Ddn_Project_Entitlement_Access_Aggregate_Order_By>;
  environments_aggregate?: Maybe<Ddn_Environment_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  owner_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
};

/** primary key columns input for table: ddn.projects */
export type Ddn_Projects_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "ddn.projects" */
export enum Ddn_Projects_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "ddn.projects" */
export type Ddn_Projects_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  owner_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "ddn_projects" */
export type Ddn_Projects_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ddn_Projects_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ddn_Projects_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  owner_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ddn.projects" */
export enum Ddn_Projects_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Ddn_Projects_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Ddn_Projects_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ddn_Projects_Bool_Exp;
};

/** columns and relationships of "ddn.tunnel" */
export type Ddn_Tunnel = {
  __typename?: 'ddn_tunnel';
  created_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  last_connection_at: Scalars['timestamptz'];
  owner_id: Scalars['uuid'];
  reserved_cluster?: Maybe<Scalars['uuid']>;
  reserved_port?: Maybe<Scalars['Int']>;
  /** An object relationship */
  tunnel_cluster?: Maybe<Ddn_Tunnel_Cluster>;
  /** An object relationship */
  user: Users;
};

/** aggregated selection of "ddn.tunnel" */
export type Ddn_Tunnel_Aggregate = {
  __typename?: 'ddn_tunnel_aggregate';
  aggregate?: Maybe<Ddn_Tunnel_Aggregate_Fields>;
  nodes: Array<Ddn_Tunnel>;
};

export type Ddn_Tunnel_Aggregate_Bool_Exp = {
  count?: Maybe<Ddn_Tunnel_Aggregate_Bool_Exp_Count>;
};

export type Ddn_Tunnel_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Ddn_Tunnel_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Ddn_Tunnel_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "ddn.tunnel" */
export type Ddn_Tunnel_Aggregate_Fields = {
  __typename?: 'ddn_tunnel_aggregate_fields';
  avg?: Maybe<Ddn_Tunnel_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Ddn_Tunnel_Max_Fields>;
  min?: Maybe<Ddn_Tunnel_Min_Fields>;
  stddev?: Maybe<Ddn_Tunnel_Stddev_Fields>;
  stddev_pop?: Maybe<Ddn_Tunnel_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ddn_Tunnel_Stddev_Samp_Fields>;
  sum?: Maybe<Ddn_Tunnel_Sum_Fields>;
  var_pop?: Maybe<Ddn_Tunnel_Var_Pop_Fields>;
  var_samp?: Maybe<Ddn_Tunnel_Var_Samp_Fields>;
  variance?: Maybe<Ddn_Tunnel_Variance_Fields>;
};

/** aggregate fields of "ddn.tunnel" */
export type Ddn_Tunnel_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ddn_Tunnel_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ddn.tunnel" */
export type Ddn_Tunnel_Aggregate_Order_By = {
  avg?: Maybe<Ddn_Tunnel_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Ddn_Tunnel_Max_Order_By>;
  min?: Maybe<Ddn_Tunnel_Min_Order_By>;
  stddev?: Maybe<Ddn_Tunnel_Stddev_Order_By>;
  stddev_pop?: Maybe<Ddn_Tunnel_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Ddn_Tunnel_Stddev_Samp_Order_By>;
  sum?: Maybe<Ddn_Tunnel_Sum_Order_By>;
  var_pop?: Maybe<Ddn_Tunnel_Var_Pop_Order_By>;
  var_samp?: Maybe<Ddn_Tunnel_Var_Samp_Order_By>;
  variance?: Maybe<Ddn_Tunnel_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "ddn.tunnel" */
export type Ddn_Tunnel_Arr_Rel_Insert_Input = {
  data: Array<Ddn_Tunnel_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Ddn_Tunnel_On_Conflict>;
};

/** aggregate avg on columns */
export type Ddn_Tunnel_Avg_Fields = {
  __typename?: 'ddn_tunnel_avg_fields';
  reserved_port?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "ddn.tunnel" */
export type Ddn_Tunnel_Avg_Order_By = {
  reserved_port?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ddn.tunnel". All fields are combined with a logical 'AND'. */
export type Ddn_Tunnel_Bool_Exp = {
  _and?: Maybe<Array<Ddn_Tunnel_Bool_Exp>>;
  _not?: Maybe<Ddn_Tunnel_Bool_Exp>;
  _or?: Maybe<Array<Ddn_Tunnel_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  last_connection_at?: Maybe<Timestamptz_Comparison_Exp>;
  owner_id?: Maybe<Uuid_Comparison_Exp>;
  reserved_cluster?: Maybe<Uuid_Comparison_Exp>;
  reserved_port?: Maybe<Int_Comparison_Exp>;
  tunnel_cluster?: Maybe<Ddn_Tunnel_Cluster_Bool_Exp>;
  user?: Maybe<Users_Bool_Exp>;
};

/** columns and relationships of "ddn.tunnel_cluster" */
export type Ddn_Tunnel_Cluster = {
  __typename?: 'ddn_tunnel_cluster';
  cloud: Scalars['String'];
  created_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  internal_fqdn: Scalars['String'];
  machine_type: Scalars['String'];
  name: Scalars['String'];
  public_fqdn: Scalars['String'];
  region: Scalars['String'];
  /** An object relationship */
  regionByRegionCloud?: Maybe<Region>;
  /** An array relationship */
  tunnels: Array<Ddn_Tunnel>;
  /** An aggregate relationship */
  tunnels_aggregate: Ddn_Tunnel_Aggregate;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone: Scalars['String'];
};

/** columns and relationships of "ddn.tunnel_cluster" */
export type Ddn_Tunnel_ClusterTunnelsArgs = {
  distinct_on?: Maybe<Array<Ddn_Tunnel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Tunnel_Order_By>>;
  where?: Maybe<Ddn_Tunnel_Bool_Exp>;
};

/** columns and relationships of "ddn.tunnel_cluster" */
export type Ddn_Tunnel_ClusterTunnels_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Tunnel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Tunnel_Order_By>>;
  where?: Maybe<Ddn_Tunnel_Bool_Exp>;
};

/** aggregated selection of "ddn.tunnel_cluster" */
export type Ddn_Tunnel_Cluster_Aggregate = {
  __typename?: 'ddn_tunnel_cluster_aggregate';
  aggregate?: Maybe<Ddn_Tunnel_Cluster_Aggregate_Fields>;
  nodes: Array<Ddn_Tunnel_Cluster>;
};

/** aggregate fields of "ddn.tunnel_cluster" */
export type Ddn_Tunnel_Cluster_Aggregate_Fields = {
  __typename?: 'ddn_tunnel_cluster_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Ddn_Tunnel_Cluster_Max_Fields>;
  min?: Maybe<Ddn_Tunnel_Cluster_Min_Fields>;
};

/** aggregate fields of "ddn.tunnel_cluster" */
export type Ddn_Tunnel_Cluster_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ddn_Tunnel_Cluster_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "ddn.tunnel_cluster". All fields are combined with a logical 'AND'. */
export type Ddn_Tunnel_Cluster_Bool_Exp = {
  _and?: Maybe<Array<Ddn_Tunnel_Cluster_Bool_Exp>>;
  _not?: Maybe<Ddn_Tunnel_Cluster_Bool_Exp>;
  _or?: Maybe<Array<Ddn_Tunnel_Cluster_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  internal_fqdn?: Maybe<String_Comparison_Exp>;
  machine_type?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  public_fqdn?: Maybe<String_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  regionByRegionCloud?: Maybe<Region_Bool_Exp>;
  tunnels?: Maybe<Ddn_Tunnel_Bool_Exp>;
  tunnels_aggregate?: Maybe<Ddn_Tunnel_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  zone?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ddn.tunnel_cluster" */
export enum Ddn_Tunnel_Cluster_Constraint {
  /** unique or primary key constraint on columns "internal_fqdn" */
  TunnelClusterInternalFqdnKey = 'tunnel_cluster_internal_fqdn_key',
  /** unique or primary key constraint on columns "name" */
  TunnelClusterNameKey = 'tunnel_cluster_name_key',
  /** unique or primary key constraint on columns "id" */
  TunnelClusterPkey = 'tunnel_cluster_pkey',
  /** unique or primary key constraint on columns "public_fqdn" */
  TunnelClusterPublicFqdnKey = 'tunnel_cluster_public_fqdn_key',
}

/** input type for inserting data into table "ddn.tunnel_cluster" */
export type Ddn_Tunnel_Cluster_Insert_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  internal_fqdn?: Maybe<Scalars['String']>;
  machine_type?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  public_fqdn?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  regionByRegionCloud?: Maybe<Region_Obj_Rel_Insert_Input>;
  tunnels?: Maybe<Ddn_Tunnel_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Ddn_Tunnel_Cluster_Max_Fields = {
  __typename?: 'ddn_tunnel_cluster_max_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  internal_fqdn?: Maybe<Scalars['String']>;
  machine_type?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  public_fqdn?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Ddn_Tunnel_Cluster_Min_Fields = {
  __typename?: 'ddn_tunnel_cluster_min_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  internal_fqdn?: Maybe<Scalars['String']>;
  machine_type?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  public_fqdn?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "ddn.tunnel_cluster" */
export type Ddn_Tunnel_Cluster_Mutation_Response = {
  __typename?: 'ddn_tunnel_cluster_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ddn_Tunnel_Cluster>;
};

/** input type for inserting object relation for remote table "ddn.tunnel_cluster" */
export type Ddn_Tunnel_Cluster_Obj_Rel_Insert_Input = {
  data: Ddn_Tunnel_Cluster_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Ddn_Tunnel_Cluster_On_Conflict>;
};

/** on_conflict condition type for table "ddn.tunnel_cluster" */
export type Ddn_Tunnel_Cluster_On_Conflict = {
  constraint: Ddn_Tunnel_Cluster_Constraint;
  update_columns?: Array<Ddn_Tunnel_Cluster_Update_Column>;
  where?: Maybe<Ddn_Tunnel_Cluster_Bool_Exp>;
};

/** Ordering options when selecting data from "ddn.tunnel_cluster". */
export type Ddn_Tunnel_Cluster_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  internal_fqdn?: Maybe<Order_By>;
  machine_type?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  public_fqdn?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  regionByRegionCloud?: Maybe<Region_Order_By>;
  tunnels_aggregate?: Maybe<Ddn_Tunnel_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
  zone?: Maybe<Order_By>;
};

/** primary key columns input for table: ddn.tunnel_cluster */
export type Ddn_Tunnel_Cluster_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "ddn.tunnel_cluster" */
export enum Ddn_Tunnel_Cluster_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  InternalFqdn = 'internal_fqdn',
  /** column name */
  MachineType = 'machine_type',
  /** column name */
  Name = 'name',
  /** column name */
  PublicFqdn = 'public_fqdn',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Zone = 'zone',
}

/** input type for updating data in table "ddn.tunnel_cluster" */
export type Ddn_Tunnel_Cluster_Set_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  internal_fqdn?: Maybe<Scalars['String']>;
  machine_type?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  public_fqdn?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "ddn_tunnel_cluster" */
export type Ddn_Tunnel_Cluster_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ddn_Tunnel_Cluster_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ddn_Tunnel_Cluster_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  internal_fqdn?: Maybe<Scalars['String']>;
  machine_type?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  public_fqdn?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone?: Maybe<Scalars['String']>;
};

/** update columns of table "ddn.tunnel_cluster" */
export enum Ddn_Tunnel_Cluster_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  InternalFqdn = 'internal_fqdn',
  /** column name */
  MachineType = 'machine_type',
  /** column name */
  Name = 'name',
  /** column name */
  PublicFqdn = 'public_fqdn',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Zone = 'zone',
}

export type Ddn_Tunnel_Cluster_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Ddn_Tunnel_Cluster_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ddn_Tunnel_Cluster_Bool_Exp;
};

/** unique or primary key constraints on table "ddn.tunnel" */
export enum Ddn_Tunnel_Constraint {
  /** unique or primary key constraint on columns "id" */
  TunnelPkey = 'tunnel_pkey',
  /** unique or primary key constraint on columns "reserved_cluster", "reserved_port" */
  TunnelReservedPortReservedClusterKey = 'tunnel_reserved_port_reserved_cluster_key',
}

/** input type for incrementing numeric columns in table "ddn.tunnel" */
export type Ddn_Tunnel_Inc_Input = {
  reserved_port?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "ddn.tunnel" */
export type Ddn_Tunnel_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  last_connection_at?: Maybe<Scalars['timestamptz']>;
  owner_id?: Maybe<Scalars['uuid']>;
  reserved_cluster?: Maybe<Scalars['uuid']>;
  reserved_port?: Maybe<Scalars['Int']>;
  tunnel_cluster?: Maybe<Ddn_Tunnel_Cluster_Obj_Rel_Insert_Input>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Ddn_Tunnel_Max_Fields = {
  __typename?: 'ddn_tunnel_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  last_connection_at?: Maybe<Scalars['timestamptz']>;
  owner_id?: Maybe<Scalars['uuid']>;
  reserved_cluster?: Maybe<Scalars['uuid']>;
  reserved_port?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "ddn.tunnel" */
export type Ddn_Tunnel_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last_connection_at?: Maybe<Order_By>;
  owner_id?: Maybe<Order_By>;
  reserved_cluster?: Maybe<Order_By>;
  reserved_port?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Ddn_Tunnel_Min_Fields = {
  __typename?: 'ddn_tunnel_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  last_connection_at?: Maybe<Scalars['timestamptz']>;
  owner_id?: Maybe<Scalars['uuid']>;
  reserved_cluster?: Maybe<Scalars['uuid']>;
  reserved_port?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "ddn.tunnel" */
export type Ddn_Tunnel_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last_connection_at?: Maybe<Order_By>;
  owner_id?: Maybe<Order_By>;
  reserved_cluster?: Maybe<Order_By>;
  reserved_port?: Maybe<Order_By>;
};

/** response of any mutation on the table "ddn.tunnel" */
export type Ddn_Tunnel_Mutation_Response = {
  __typename?: 'ddn_tunnel_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ddn_Tunnel>;
};

/** on_conflict condition type for table "ddn.tunnel" */
export type Ddn_Tunnel_On_Conflict = {
  constraint: Ddn_Tunnel_Constraint;
  update_columns?: Array<Ddn_Tunnel_Update_Column>;
  where?: Maybe<Ddn_Tunnel_Bool_Exp>;
};

/** Ordering options when selecting data from "ddn.tunnel". */
export type Ddn_Tunnel_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last_connection_at?: Maybe<Order_By>;
  owner_id?: Maybe<Order_By>;
  reserved_cluster?: Maybe<Order_By>;
  reserved_port?: Maybe<Order_By>;
  tunnel_cluster?: Maybe<Ddn_Tunnel_Cluster_Order_By>;
  user?: Maybe<Users_Order_By>;
};

/** primary key columns input for table: ddn.tunnel */
export type Ddn_Tunnel_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "ddn.tunnel" */
export enum Ddn_Tunnel_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  LastConnectionAt = 'last_connection_at',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  ReservedCluster = 'reserved_cluster',
  /** column name */
  ReservedPort = 'reserved_port',
}

/** input type for updating data in table "ddn.tunnel" */
export type Ddn_Tunnel_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  last_connection_at?: Maybe<Scalars['timestamptz']>;
  owner_id?: Maybe<Scalars['uuid']>;
  reserved_cluster?: Maybe<Scalars['uuid']>;
  reserved_port?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Ddn_Tunnel_Stddev_Fields = {
  __typename?: 'ddn_tunnel_stddev_fields';
  reserved_port?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "ddn.tunnel" */
export type Ddn_Tunnel_Stddev_Order_By = {
  reserved_port?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Ddn_Tunnel_Stddev_Pop_Fields = {
  __typename?: 'ddn_tunnel_stddev_pop_fields';
  reserved_port?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "ddn.tunnel" */
export type Ddn_Tunnel_Stddev_Pop_Order_By = {
  reserved_port?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Ddn_Tunnel_Stddev_Samp_Fields = {
  __typename?: 'ddn_tunnel_stddev_samp_fields';
  reserved_port?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "ddn.tunnel" */
export type Ddn_Tunnel_Stddev_Samp_Order_By = {
  reserved_port?: Maybe<Order_By>;
};

/** Streaming cursor of the table "ddn_tunnel" */
export type Ddn_Tunnel_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ddn_Tunnel_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ddn_Tunnel_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  last_connection_at?: Maybe<Scalars['timestamptz']>;
  owner_id?: Maybe<Scalars['uuid']>;
  reserved_cluster?: Maybe<Scalars['uuid']>;
  reserved_port?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Ddn_Tunnel_Sum_Fields = {
  __typename?: 'ddn_tunnel_sum_fields';
  reserved_port?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "ddn.tunnel" */
export type Ddn_Tunnel_Sum_Order_By = {
  reserved_port?: Maybe<Order_By>;
};

/** update columns of table "ddn.tunnel" */
export enum Ddn_Tunnel_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  LastConnectionAt = 'last_connection_at',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  ReservedCluster = 'reserved_cluster',
  /** column name */
  ReservedPort = 'reserved_port',
}

export type Ddn_Tunnel_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Ddn_Tunnel_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Ddn_Tunnel_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ddn_Tunnel_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Ddn_Tunnel_Var_Pop_Fields = {
  __typename?: 'ddn_tunnel_var_pop_fields';
  reserved_port?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "ddn.tunnel" */
export type Ddn_Tunnel_Var_Pop_Order_By = {
  reserved_port?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Ddn_Tunnel_Var_Samp_Fields = {
  __typename?: 'ddn_tunnel_var_samp_fields';
  reserved_port?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "ddn.tunnel" */
export type Ddn_Tunnel_Var_Samp_Order_By = {
  reserved_port?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Ddn_Tunnel_Variance_Fields = {
  __typename?: 'ddn_tunnel_variance_fields';
  reserved_port?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "ddn.tunnel" */
export type Ddn_Tunnel_Variance_Order_By = {
  reserved_port?: Maybe<Order_By>;
};

/** Table to keep track of dedicated cloud bills. These are not part of automated Stripe invoicing.  */
export type Dedicated_Cloud_Bills = {
  __typename?: 'dedicated_cloud_bills';
  compute_unit_config_id: Scalars['uuid'];
  created_at: Scalars['timestamptz'];
  cu_cost: Scalars['Int'];
  data_passthrough_cost: Scalars['Int'];
  /** An array relationship */
  details: Array<Dedicated_Cloud_Bills_Details>;
  /** An aggregate relationship */
  details_aggregate: Dedicated_Cloud_Bills_Details_Aggregate;
  id: Scalars['uuid'];
  metadata?: Maybe<Scalars['jsonb']>;
  month: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
  user_id: Scalars['uuid'];
  year: Scalars['Int'];
};

/** Table to keep track of dedicated cloud bills. These are not part of automated Stripe invoicing.  */
export type Dedicated_Cloud_BillsDetailsArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Details_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Details_Bool_Exp>;
};

/** Table to keep track of dedicated cloud bills. These are not part of automated Stripe invoicing.  */
export type Dedicated_Cloud_BillsDetails_AggregateArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Details_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Details_Bool_Exp>;
};

/** Table to keep track of dedicated cloud bills. These are not part of automated Stripe invoicing.  */
export type Dedicated_Cloud_BillsMetadataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Aggregate = {
  __typename?: 'dedicated_cloud_bills_aggregate';
  aggregate?: Maybe<Dedicated_Cloud_Bills_Aggregate_Fields>;
  nodes: Array<Dedicated_Cloud_Bills>;
};

export type Dedicated_Cloud_Bills_Aggregate_Bool_Exp = {
  count?: Maybe<Dedicated_Cloud_Bills_Aggregate_Bool_Exp_Count>;
};

export type Dedicated_Cloud_Bills_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Dedicated_Cloud_Bills_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Aggregate_Fields = {
  __typename?: 'dedicated_cloud_bills_aggregate_fields';
  avg?: Maybe<Dedicated_Cloud_Bills_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dedicated_Cloud_Bills_Max_Fields>;
  min?: Maybe<Dedicated_Cloud_Bills_Min_Fields>;
  stddev?: Maybe<Dedicated_Cloud_Bills_Stddev_Fields>;
  stddev_pop?: Maybe<Dedicated_Cloud_Bills_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dedicated_Cloud_Bills_Stddev_Samp_Fields>;
  sum?: Maybe<Dedicated_Cloud_Bills_Sum_Fields>;
  var_pop?: Maybe<Dedicated_Cloud_Bills_Var_Pop_Fields>;
  var_samp?: Maybe<Dedicated_Cloud_Bills_Var_Samp_Fields>;
  variance?: Maybe<Dedicated_Cloud_Bills_Variance_Fields>;
};

/** aggregate fields of "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dedicated_Cloud_Bills_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Aggregate_Order_By = {
  avg?: Maybe<Dedicated_Cloud_Bills_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Dedicated_Cloud_Bills_Max_Order_By>;
  min?: Maybe<Dedicated_Cloud_Bills_Min_Order_By>;
  stddev?: Maybe<Dedicated_Cloud_Bills_Stddev_Order_By>;
  stddev_pop?: Maybe<Dedicated_Cloud_Bills_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Dedicated_Cloud_Bills_Stddev_Samp_Order_By>;
  sum?: Maybe<Dedicated_Cloud_Bills_Sum_Order_By>;
  var_pop?: Maybe<Dedicated_Cloud_Bills_Var_Pop_Order_By>;
  var_samp?: Maybe<Dedicated_Cloud_Bills_Var_Samp_Order_By>;
  variance?: Maybe<Dedicated_Cloud_Bills_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Dedicated_Cloud_Bills_Append_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Arr_Rel_Insert_Input = {
  data: Array<Dedicated_Cloud_Bills_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Dedicated_Cloud_Bills_On_Conflict>;
};

/** aggregate avg on columns */
export type Dedicated_Cloud_Bills_Avg_Fields = {
  __typename?: 'dedicated_cloud_bills_avg_fields';
  cu_cost?: Maybe<Scalars['Float']>;
  data_passthrough_cost?: Maybe<Scalars['Float']>;
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Avg_Order_By = {
  cu_cost?: Maybe<Order_By>;
  data_passthrough_cost?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "dedicated_cloud_bills". All fields are combined with a logical 'AND'. */
export type Dedicated_Cloud_Bills_Bool_Exp = {
  _and?: Maybe<Array<Dedicated_Cloud_Bills_Bool_Exp>>;
  _not?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
  _or?: Maybe<Array<Dedicated_Cloud_Bills_Bool_Exp>>;
  compute_unit_config_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  cu_cost?: Maybe<Int_Comparison_Exp>;
  data_passthrough_cost?: Maybe<Int_Comparison_Exp>;
  details?: Maybe<Dedicated_Cloud_Bills_Details_Bool_Exp>;
  details_aggregate?: Maybe<Dedicated_Cloud_Bills_Details_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  metadata?: Maybe<Jsonb_Comparison_Exp>;
  month?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
  year?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "dedicated_cloud_bills" */
export enum Dedicated_Cloud_Bills_Constraint {
  /** unique or primary key constraint on columns "year", "month", "compute_unit_config_id" */
  DedicatedCloudBillsComputeUnitConfigIdMonthYearKey = 'dedicated_cloud_bills_compute_unit_config_id_month_year_key',
  /** unique or primary key constraint on columns "id" */
  DedicatedCloudBillsPkey = 'dedicated_cloud_bills_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Dedicated_Cloud_Bills_Delete_At_Path_Input = {
  metadata?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Dedicated_Cloud_Bills_Delete_Elem_Input = {
  metadata?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Dedicated_Cloud_Bills_Delete_Key_Input = {
  metadata?: Maybe<Scalars['String']>;
};

/** Granular details about compute unit usage based bills  */
export type Dedicated_Cloud_Bills_Details = {
  __typename?: 'dedicated_cloud_bills_details';
  bill_id: Scalars['uuid'];
  created_at: Scalars['timestamptz'];
  details?: Maybe<Scalars['jsonb']>;
  id: Scalars['uuid'];
  month: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
  year: Scalars['Int'];
};

/** Granular details about compute unit usage based bills  */
export type Dedicated_Cloud_Bills_DetailsDetailsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Aggregate = {
  __typename?: 'dedicated_cloud_bills_details_aggregate';
  aggregate?: Maybe<Dedicated_Cloud_Bills_Details_Aggregate_Fields>;
  nodes: Array<Dedicated_Cloud_Bills_Details>;
};

export type Dedicated_Cloud_Bills_Details_Aggregate_Bool_Exp = {
  count?: Maybe<Dedicated_Cloud_Bills_Details_Aggregate_Bool_Exp_Count>;
};

export type Dedicated_Cloud_Bills_Details_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Dedicated_Cloud_Bills_Details_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Dedicated_Cloud_Bills_Details_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Aggregate_Fields = {
  __typename?: 'dedicated_cloud_bills_details_aggregate_fields';
  avg?: Maybe<Dedicated_Cloud_Bills_Details_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dedicated_Cloud_Bills_Details_Max_Fields>;
  min?: Maybe<Dedicated_Cloud_Bills_Details_Min_Fields>;
  stddev?: Maybe<Dedicated_Cloud_Bills_Details_Stddev_Fields>;
  stddev_pop?: Maybe<Dedicated_Cloud_Bills_Details_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dedicated_Cloud_Bills_Details_Stddev_Samp_Fields>;
  sum?: Maybe<Dedicated_Cloud_Bills_Details_Sum_Fields>;
  var_pop?: Maybe<Dedicated_Cloud_Bills_Details_Var_Pop_Fields>;
  var_samp?: Maybe<Dedicated_Cloud_Bills_Details_Var_Samp_Fields>;
  variance?: Maybe<Dedicated_Cloud_Bills_Details_Variance_Fields>;
};

/** aggregate fields of "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dedicated_Cloud_Bills_Details_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Aggregate_Order_By = {
  avg?: Maybe<Dedicated_Cloud_Bills_Details_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Dedicated_Cloud_Bills_Details_Max_Order_By>;
  min?: Maybe<Dedicated_Cloud_Bills_Details_Min_Order_By>;
  stddev?: Maybe<Dedicated_Cloud_Bills_Details_Stddev_Order_By>;
  stddev_pop?: Maybe<Dedicated_Cloud_Bills_Details_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Dedicated_Cloud_Bills_Details_Stddev_Samp_Order_By>;
  sum?: Maybe<Dedicated_Cloud_Bills_Details_Sum_Order_By>;
  var_pop?: Maybe<Dedicated_Cloud_Bills_Details_Var_Pop_Order_By>;
  var_samp?: Maybe<Dedicated_Cloud_Bills_Details_Var_Samp_Order_By>;
  variance?: Maybe<Dedicated_Cloud_Bills_Details_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Dedicated_Cloud_Bills_Details_Append_Input = {
  details?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Arr_Rel_Insert_Input = {
  data: Array<Dedicated_Cloud_Bills_Details_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Dedicated_Cloud_Bills_Details_On_Conflict>;
};

/** aggregate avg on columns */
export type Dedicated_Cloud_Bills_Details_Avg_Fields = {
  __typename?: 'dedicated_cloud_bills_details_avg_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Avg_Order_By = {
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/**
 * Boolean expression to filter rows from the table
 * "dedicated_cloud_bills_details". All fields are combined with a logical 'AND'.
 */
export type Dedicated_Cloud_Bills_Details_Bool_Exp = {
  _and?: Maybe<Array<Dedicated_Cloud_Bills_Details_Bool_Exp>>;
  _not?: Maybe<Dedicated_Cloud_Bills_Details_Bool_Exp>;
  _or?: Maybe<Array<Dedicated_Cloud_Bills_Details_Bool_Exp>>;
  bill_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  details?: Maybe<Jsonb_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  month?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  year?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "dedicated_cloud_bills_details" */
export enum Dedicated_Cloud_Bills_Details_Constraint {
  /** unique or primary key constraint on columns "id" */
  DedicatedCloudBillsDetailsPkey = 'dedicated_cloud_bills_details_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Dedicated_Cloud_Bills_Details_Delete_At_Path_Input = {
  details?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Dedicated_Cloud_Bills_Details_Delete_Elem_Input = {
  details?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Dedicated_Cloud_Bills_Details_Delete_Key_Input = {
  details?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Inc_Input = {
  month?: Maybe<Scalars['Int']>;
  year?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Insert_Input = {
  bill_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  details?: Maybe<Scalars['jsonb']>;
  id?: Maybe<Scalars['uuid']>;
  month?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  year?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Dedicated_Cloud_Bills_Details_Max_Fields = {
  __typename?: 'dedicated_cloud_bills_details_max_fields';
  bill_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  month?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  year?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Max_Order_By = {
  bill_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Dedicated_Cloud_Bills_Details_Min_Fields = {
  __typename?: 'dedicated_cloud_bills_details_min_fields';
  bill_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  month?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  year?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Min_Order_By = {
  bill_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** response of any mutation on the table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Mutation_Response = {
  __typename?: 'dedicated_cloud_bills_details_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dedicated_Cloud_Bills_Details>;
};

/** on_conflict condition type for table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_On_Conflict = {
  constraint: Dedicated_Cloud_Bills_Details_Constraint;
  update_columns?: Array<Dedicated_Cloud_Bills_Details_Update_Column>;
  where?: Maybe<Dedicated_Cloud_Bills_Details_Bool_Exp>;
};

/** Ordering options when selecting data from "dedicated_cloud_bills_details". */
export type Dedicated_Cloud_Bills_Details_Order_By = {
  bill_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  details?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** primary key columns input for table: dedicated_cloud_bills_details */
export type Dedicated_Cloud_Bills_Details_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Dedicated_Cloud_Bills_Details_Prepend_Input = {
  details?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "dedicated_cloud_bills_details" */
export enum Dedicated_Cloud_Bills_Details_Select_Column {
  /** column name */
  BillId = 'bill_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Details = 'details',
  /** column name */
  Id = 'id',
  /** column name */
  Month = 'month',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Year = 'year',
}

/** input type for updating data in table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Set_Input = {
  bill_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  details?: Maybe<Scalars['jsonb']>;
  id?: Maybe<Scalars['uuid']>;
  month?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  year?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Dedicated_Cloud_Bills_Details_Stddev_Fields = {
  __typename?: 'dedicated_cloud_bills_details_stddev_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Stddev_Order_By = {
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Dedicated_Cloud_Bills_Details_Stddev_Pop_Fields = {
  __typename?: 'dedicated_cloud_bills_details_stddev_pop_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Stddev_Pop_Order_By = {
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Dedicated_Cloud_Bills_Details_Stddev_Samp_Fields = {
  __typename?: 'dedicated_cloud_bills_details_stddev_samp_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Stddev_Samp_Order_By = {
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** Streaming cursor of the table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dedicated_Cloud_Bills_Details_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dedicated_Cloud_Bills_Details_Stream_Cursor_Value_Input = {
  bill_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  details?: Maybe<Scalars['jsonb']>;
  id?: Maybe<Scalars['uuid']>;
  month?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  year?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Dedicated_Cloud_Bills_Details_Sum_Fields = {
  __typename?: 'dedicated_cloud_bills_details_sum_fields';
  month?: Maybe<Scalars['Int']>;
  year?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Sum_Order_By = {
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** update columns of table "dedicated_cloud_bills_details" */
export enum Dedicated_Cloud_Bills_Details_Update_Column {
  /** column name */
  BillId = 'bill_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Details = 'details',
  /** column name */
  Id = 'id',
  /** column name */
  Month = 'month',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Year = 'year',
}

export type Dedicated_Cloud_Bills_Details_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Dedicated_Cloud_Bills_Details_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Dedicated_Cloud_Bills_Details_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Dedicated_Cloud_Bills_Details_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Dedicated_Cloud_Bills_Details_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Dedicated_Cloud_Bills_Details_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Dedicated_Cloud_Bills_Details_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Dedicated_Cloud_Bills_Details_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dedicated_Cloud_Bills_Details_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dedicated_Cloud_Bills_Details_Var_Pop_Fields = {
  __typename?: 'dedicated_cloud_bills_details_var_pop_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Var_Pop_Order_By = {
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Dedicated_Cloud_Bills_Details_Var_Samp_Fields = {
  __typename?: 'dedicated_cloud_bills_details_var_samp_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Var_Samp_Order_By = {
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Dedicated_Cloud_Bills_Details_Variance_Fields = {
  __typename?: 'dedicated_cloud_bills_details_variance_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "dedicated_cloud_bills_details" */
export type Dedicated_Cloud_Bills_Details_Variance_Order_By = {
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** input type for incrementing numeric columns in table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Inc_Input = {
  cu_cost?: Maybe<Scalars['Int']>;
  data_passthrough_cost?: Maybe<Scalars['Int']>;
  month?: Maybe<Scalars['Int']>;
  year?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Insert_Input = {
  compute_unit_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  cu_cost?: Maybe<Scalars['Int']>;
  data_passthrough_cost?: Maybe<Scalars['Int']>;
  details?: Maybe<Dedicated_Cloud_Bills_Details_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  metadata?: Maybe<Scalars['jsonb']>;
  month?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  year?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Dedicated_Cloud_Bills_Max_Fields = {
  __typename?: 'dedicated_cloud_bills_max_fields';
  compute_unit_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  cu_cost?: Maybe<Scalars['Int']>;
  data_passthrough_cost?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  month?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  year?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Max_Order_By = {
  compute_unit_config_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  cu_cost?: Maybe<Order_By>;
  data_passthrough_cost?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Dedicated_Cloud_Bills_Min_Fields = {
  __typename?: 'dedicated_cloud_bills_min_fields';
  compute_unit_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  cu_cost?: Maybe<Scalars['Int']>;
  data_passthrough_cost?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  month?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  year?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Min_Order_By = {
  compute_unit_config_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  cu_cost?: Maybe<Order_By>;
  data_passthrough_cost?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** response of any mutation on the table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Mutation_Response = {
  __typename?: 'dedicated_cloud_bills_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dedicated_Cloud_Bills>;
};

/** on_conflict condition type for table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_On_Conflict = {
  constraint: Dedicated_Cloud_Bills_Constraint;
  update_columns?: Array<Dedicated_Cloud_Bills_Update_Column>;
  where?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
};

/** Ordering options when selecting data from "dedicated_cloud_bills". */
export type Dedicated_Cloud_Bills_Order_By = {
  compute_unit_config_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  cu_cost?: Maybe<Order_By>;
  data_passthrough_cost?: Maybe<Order_By>;
  details_aggregate?: Maybe<Dedicated_Cloud_Bills_Details_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  metadata?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** primary key columns input for table: dedicated_cloud_bills */
export type Dedicated_Cloud_Bills_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Dedicated_Cloud_Bills_Prepend_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "dedicated_cloud_bills" */
export enum Dedicated_Cloud_Bills_Select_Column {
  /** column name */
  ComputeUnitConfigId = 'compute_unit_config_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CuCost = 'cu_cost',
  /** column name */
  DataPassthroughCost = 'data_passthrough_cost',
  /** column name */
  Id = 'id',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  Month = 'month',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Year = 'year',
}

/** input type for updating data in table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Set_Input = {
  compute_unit_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  cu_cost?: Maybe<Scalars['Int']>;
  data_passthrough_cost?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  metadata?: Maybe<Scalars['jsonb']>;
  month?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  year?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Dedicated_Cloud_Bills_Stddev_Fields = {
  __typename?: 'dedicated_cloud_bills_stddev_fields';
  cu_cost?: Maybe<Scalars['Float']>;
  data_passthrough_cost?: Maybe<Scalars['Float']>;
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Stddev_Order_By = {
  cu_cost?: Maybe<Order_By>;
  data_passthrough_cost?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Dedicated_Cloud_Bills_Stddev_Pop_Fields = {
  __typename?: 'dedicated_cloud_bills_stddev_pop_fields';
  cu_cost?: Maybe<Scalars['Float']>;
  data_passthrough_cost?: Maybe<Scalars['Float']>;
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Stddev_Pop_Order_By = {
  cu_cost?: Maybe<Order_By>;
  data_passthrough_cost?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Dedicated_Cloud_Bills_Stddev_Samp_Fields = {
  __typename?: 'dedicated_cloud_bills_stddev_samp_fields';
  cu_cost?: Maybe<Scalars['Float']>;
  data_passthrough_cost?: Maybe<Scalars['Float']>;
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Stddev_Samp_Order_By = {
  cu_cost?: Maybe<Order_By>;
  data_passthrough_cost?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** Streaming cursor of the table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dedicated_Cloud_Bills_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dedicated_Cloud_Bills_Stream_Cursor_Value_Input = {
  compute_unit_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  cu_cost?: Maybe<Scalars['Int']>;
  data_passthrough_cost?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  metadata?: Maybe<Scalars['jsonb']>;
  month?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  year?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Dedicated_Cloud_Bills_Sum_Fields = {
  __typename?: 'dedicated_cloud_bills_sum_fields';
  cu_cost?: Maybe<Scalars['Int']>;
  data_passthrough_cost?: Maybe<Scalars['Int']>;
  month?: Maybe<Scalars['Int']>;
  year?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Sum_Order_By = {
  cu_cost?: Maybe<Order_By>;
  data_passthrough_cost?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** update columns of table "dedicated_cloud_bills" */
export enum Dedicated_Cloud_Bills_Update_Column {
  /** column name */
  ComputeUnitConfigId = 'compute_unit_config_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CuCost = 'cu_cost',
  /** column name */
  DataPassthroughCost = 'data_passthrough_cost',
  /** column name */
  Id = 'id',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  Month = 'month',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
  /** column name */
  Year = 'year',
}

export type Dedicated_Cloud_Bills_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Dedicated_Cloud_Bills_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Dedicated_Cloud_Bills_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Dedicated_Cloud_Bills_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Dedicated_Cloud_Bills_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Dedicated_Cloud_Bills_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Dedicated_Cloud_Bills_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Dedicated_Cloud_Bills_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dedicated_Cloud_Bills_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dedicated_Cloud_Bills_Var_Pop_Fields = {
  __typename?: 'dedicated_cloud_bills_var_pop_fields';
  cu_cost?: Maybe<Scalars['Float']>;
  data_passthrough_cost?: Maybe<Scalars['Float']>;
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Var_Pop_Order_By = {
  cu_cost?: Maybe<Order_By>;
  data_passthrough_cost?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Dedicated_Cloud_Bills_Var_Samp_Fields = {
  __typename?: 'dedicated_cloud_bills_var_samp_fields';
  cu_cost?: Maybe<Scalars['Float']>;
  data_passthrough_cost?: Maybe<Scalars['Float']>;
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Var_Samp_Order_By = {
  cu_cost?: Maybe<Order_By>;
  data_passthrough_cost?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Dedicated_Cloud_Bills_Variance_Fields = {
  __typename?: 'dedicated_cloud_bills_variance_fields';
  cu_cost?: Maybe<Scalars['Float']>;
  data_passthrough_cost?: Maybe<Scalars['Float']>;
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "dedicated_cloud_bills" */
export type Dedicated_Cloud_Bills_Variance_Order_By = {
  cu_cost?: Maybe<Order_By>;
  data_passthrough_cost?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** This table records Dedicated Cloud Deals information (also available in Salesforce). */
export type Dedicated_Cloud_Commitments = {
  __typename?: 'dedicated_cloud_commitments';
  commitment_end?: Maybe<Scalars['date']>;
  commitment_start: Scalars['date'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An array relationship */
  monthly_usage: Array<Dedicated_Cloud_Bills>;
  /** An aggregate relationship */
  monthly_usage_aggregate: Dedicated_Cloud_Bills_Aggregate;
  support_plan: Support_Plan_Types_Enum;
  total_commitment: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
  user_id: Scalars['uuid'];
  yearly_commitment: Scalars['Int'];
};

/** This table records Dedicated Cloud Deals information (also available in Salesforce). */
export type Dedicated_Cloud_CommitmentsMonthly_UsageArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
};

/** This table records Dedicated Cloud Deals information (also available in Salesforce). */
export type Dedicated_Cloud_CommitmentsMonthly_Usage_AggregateArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
};

/** aggregated selection of "dedicated_cloud_commitments" */
export type Dedicated_Cloud_Commitments_Aggregate = {
  __typename?: 'dedicated_cloud_commitments_aggregate';
  aggregate?: Maybe<Dedicated_Cloud_Commitments_Aggregate_Fields>;
  nodes: Array<Dedicated_Cloud_Commitments>;
};

/** aggregate fields of "dedicated_cloud_commitments" */
export type Dedicated_Cloud_Commitments_Aggregate_Fields = {
  __typename?: 'dedicated_cloud_commitments_aggregate_fields';
  avg?: Maybe<Dedicated_Cloud_Commitments_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dedicated_Cloud_Commitments_Max_Fields>;
  min?: Maybe<Dedicated_Cloud_Commitments_Min_Fields>;
  stddev?: Maybe<Dedicated_Cloud_Commitments_Stddev_Fields>;
  stddev_pop?: Maybe<Dedicated_Cloud_Commitments_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dedicated_Cloud_Commitments_Stddev_Samp_Fields>;
  sum?: Maybe<Dedicated_Cloud_Commitments_Sum_Fields>;
  var_pop?: Maybe<Dedicated_Cloud_Commitments_Var_Pop_Fields>;
  var_samp?: Maybe<Dedicated_Cloud_Commitments_Var_Samp_Fields>;
  variance?: Maybe<Dedicated_Cloud_Commitments_Variance_Fields>;
};

/** aggregate fields of "dedicated_cloud_commitments" */
export type Dedicated_Cloud_Commitments_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dedicated_Cloud_Commitments_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Dedicated_Cloud_Commitments_Avg_Fields = {
  __typename?: 'dedicated_cloud_commitments_avg_fields';
  total_commitment?: Maybe<Scalars['Float']>;
  yearly_commitment?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table "dedicated_cloud_commitments".
 * All fields are combined with a logical 'AND'.
 */
export type Dedicated_Cloud_Commitments_Bool_Exp = {
  _and?: Maybe<Array<Dedicated_Cloud_Commitments_Bool_Exp>>;
  _not?: Maybe<Dedicated_Cloud_Commitments_Bool_Exp>;
  _or?: Maybe<Array<Dedicated_Cloud_Commitments_Bool_Exp>>;
  commitment_end?: Maybe<Date_Comparison_Exp>;
  commitment_start?: Maybe<Date_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  monthly_usage?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
  monthly_usage_aggregate?: Maybe<Dedicated_Cloud_Bills_Aggregate_Bool_Exp>;
  support_plan?: Maybe<Support_Plan_Types_Enum_Comparison_Exp>;
  total_commitment?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
  yearly_commitment?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "dedicated_cloud_commitments" */
export enum Dedicated_Cloud_Commitments_Constraint {
  /** unique or primary key constraint on columns "id" */
  DedicatedCloudCommitmentsPkey = 'dedicated_cloud_commitments_pkey',
}

/** input type for incrementing numeric columns in table "dedicated_cloud_commitments" */
export type Dedicated_Cloud_Commitments_Inc_Input = {
  total_commitment?: Maybe<Scalars['Int']>;
  yearly_commitment?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "dedicated_cloud_commitments" */
export type Dedicated_Cloud_Commitments_Insert_Input = {
  commitment_end?: Maybe<Scalars['date']>;
  commitment_start?: Maybe<Scalars['date']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  monthly_usage?: Maybe<Dedicated_Cloud_Bills_Arr_Rel_Insert_Input>;
  support_plan?: Maybe<Support_Plan_Types_Enum>;
  total_commitment?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  yearly_commitment?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Dedicated_Cloud_Commitments_Max_Fields = {
  __typename?: 'dedicated_cloud_commitments_max_fields';
  commitment_end?: Maybe<Scalars['date']>;
  commitment_start?: Maybe<Scalars['date']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  total_commitment?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  yearly_commitment?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Dedicated_Cloud_Commitments_Min_Fields = {
  __typename?: 'dedicated_cloud_commitments_min_fields';
  commitment_end?: Maybe<Scalars['date']>;
  commitment_start?: Maybe<Scalars['date']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  total_commitment?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  yearly_commitment?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "dedicated_cloud_commitments" */
export type Dedicated_Cloud_Commitments_Mutation_Response = {
  __typename?: 'dedicated_cloud_commitments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dedicated_Cloud_Commitments>;
};

/** on_conflict condition type for table "dedicated_cloud_commitments" */
export type Dedicated_Cloud_Commitments_On_Conflict = {
  constraint: Dedicated_Cloud_Commitments_Constraint;
  update_columns?: Array<Dedicated_Cloud_Commitments_Update_Column>;
  where?: Maybe<Dedicated_Cloud_Commitments_Bool_Exp>;
};

/** Ordering options when selecting data from "dedicated_cloud_commitments". */
export type Dedicated_Cloud_Commitments_Order_By = {
  commitment_end?: Maybe<Order_By>;
  commitment_start?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  monthly_usage_aggregate?: Maybe<Dedicated_Cloud_Bills_Aggregate_Order_By>;
  support_plan?: Maybe<Order_By>;
  total_commitment?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  yearly_commitment?: Maybe<Order_By>;
};

/** primary key columns input for table: dedicated_cloud_commitments */
export type Dedicated_Cloud_Commitments_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "dedicated_cloud_commitments" */
export enum Dedicated_Cloud_Commitments_Select_Column {
  /** column name */
  CommitmentEnd = 'commitment_end',
  /** column name */
  CommitmentStart = 'commitment_start',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  SupportPlan = 'support_plan',
  /** column name */
  TotalCommitment = 'total_commitment',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
  /** column name */
  YearlyCommitment = 'yearly_commitment',
}

/** input type for updating data in table "dedicated_cloud_commitments" */
export type Dedicated_Cloud_Commitments_Set_Input = {
  commitment_end?: Maybe<Scalars['date']>;
  commitment_start?: Maybe<Scalars['date']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  support_plan?: Maybe<Support_Plan_Types_Enum>;
  total_commitment?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  yearly_commitment?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Dedicated_Cloud_Commitments_Stddev_Fields = {
  __typename?: 'dedicated_cloud_commitments_stddev_fields';
  total_commitment?: Maybe<Scalars['Float']>;
  yearly_commitment?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dedicated_Cloud_Commitments_Stddev_Pop_Fields = {
  __typename?: 'dedicated_cloud_commitments_stddev_pop_fields';
  total_commitment?: Maybe<Scalars['Float']>;
  yearly_commitment?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dedicated_Cloud_Commitments_Stddev_Samp_Fields = {
  __typename?: 'dedicated_cloud_commitments_stddev_samp_fields';
  total_commitment?: Maybe<Scalars['Float']>;
  yearly_commitment?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dedicated_cloud_commitments" */
export type Dedicated_Cloud_Commitments_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dedicated_Cloud_Commitments_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dedicated_Cloud_Commitments_Stream_Cursor_Value_Input = {
  commitment_end?: Maybe<Scalars['date']>;
  commitment_start?: Maybe<Scalars['date']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  support_plan?: Maybe<Support_Plan_Types_Enum>;
  total_commitment?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  yearly_commitment?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Dedicated_Cloud_Commitments_Sum_Fields = {
  __typename?: 'dedicated_cloud_commitments_sum_fields';
  total_commitment?: Maybe<Scalars['Int']>;
  yearly_commitment?: Maybe<Scalars['Int']>;
};

/** update columns of table "dedicated_cloud_commitments" */
export enum Dedicated_Cloud_Commitments_Update_Column {
  /** column name */
  CommitmentEnd = 'commitment_end',
  /** column name */
  CommitmentStart = 'commitment_start',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  SupportPlan = 'support_plan',
  /** column name */
  TotalCommitment = 'total_commitment',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
  /** column name */
  YearlyCommitment = 'yearly_commitment',
}

export type Dedicated_Cloud_Commitments_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Dedicated_Cloud_Commitments_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Dedicated_Cloud_Commitments_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dedicated_Cloud_Commitments_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dedicated_Cloud_Commitments_Var_Pop_Fields = {
  __typename?: 'dedicated_cloud_commitments_var_pop_fields';
  total_commitment?: Maybe<Scalars['Float']>;
  yearly_commitment?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dedicated_Cloud_Commitments_Var_Samp_Fields = {
  __typename?: 'dedicated_cloud_commitments_var_samp_fields';
  total_commitment?: Maybe<Scalars['Float']>;
  yearly_commitment?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dedicated_Cloud_Commitments_Variance_Fields = {
  __typename?: 'dedicated_cloud_commitments_variance_fields';
  total_commitment?: Maybe<Scalars['Float']>;
  yearly_commitment?: Maybe<Scalars['Float']>;
};

/** VPC to run dedicated hasura cloud  */
export type Dedicated_Vpc = {
  __typename?: 'dedicated_vpc';
  cidr?: Maybe<Scalars['String']>;
  cloud: Scalars['String'];
  comments?: Maybe<Scalars['String']>;
  create_with_dev_cluster: Scalars['Boolean'];
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  dedicated_vpc?: Maybe<Dedicated_Vpc>;
  destroy_requested?: Maybe<Scalars['Boolean']>;
  disable_infra_auto_apply: Scalars['Boolean'];
  /** Returns the GCP network name of the VPC on Hasura Cloud */
  gcp_network_name?: Maybe<Scalars['String']>;
  /** Returns the security group to be associated with hasura workers inside dedicated VPC */
  hasura_worker_security_group_id?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  message?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  nat_ip?: Maybe<Scalars['String']>;
  nat_ips?: Maybe<Scalars['json']>;
  our_asn?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  owner: Users;
  owner_id: Scalars['uuid'];
  parent_dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  region: Scalars['String'];
  /** An object relationship */
  region_info?: Maybe<Region>;
  slug: Scalars['String'];
  status: Vpc_Status_Enum;
  /** An array relationship */
  tenant_groups: Array<Tenant_Group>;
  /** An aggregate relationship */
  tenant_groups_aggregate: Tenant_Group_Aggregate;
  /** An array relationship */
  tenants: Array<Tenant>;
  /** An aggregate relationship */
  tenants_aggregate: Tenant_Aggregate;
  their_asn?: Maybe<Scalars['Int']>;
  /** Get the VPC CIDR */
  vpc_cidr?: Maybe<Scalars['String']>;
  /** returns AWS VPC ID of the dedicated VPC */
  vpc_id?: Maybe<Scalars['String']>;
  /** An array relationship */
  vpc_peerings: Array<Vpc_Peering>;
  /** An aggregate relationship */
  vpc_peerings_aggregate: Vpc_Peering_Aggregate;
};

/** VPC to run dedicated hasura cloud  */
export type Dedicated_VpcInput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** VPC to run dedicated hasura cloud  */
export type Dedicated_VpcNat_IpsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** VPC to run dedicated hasura cloud  */
export type Dedicated_VpcOutput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** VPC to run dedicated hasura cloud  */
export type Dedicated_VpcTenant_GroupsArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Order_By>>;
  where?: Maybe<Tenant_Group_Bool_Exp>;
};

/** VPC to run dedicated hasura cloud  */
export type Dedicated_VpcTenant_Groups_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Order_By>>;
  where?: Maybe<Tenant_Group_Bool_Exp>;
};

/** VPC to run dedicated hasura cloud  */
export type Dedicated_VpcTenantsArgs = {
  distinct_on?: Maybe<Array<Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Order_By>>;
  where?: Maybe<Tenant_Bool_Exp>;
};

/** VPC to run dedicated hasura cloud  */
export type Dedicated_VpcTenants_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Order_By>>;
  where?: Maybe<Tenant_Bool_Exp>;
};

/** VPC to run dedicated hasura cloud  */
export type Dedicated_VpcVpc_PeeringsArgs = {
  distinct_on?: Maybe<Array<Vpc_Peering_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Peering_Order_By>>;
  where?: Maybe<Vpc_Peering_Bool_Exp>;
};

/** VPC to run dedicated hasura cloud  */
export type Dedicated_VpcVpc_Peerings_AggregateArgs = {
  distinct_on?: Maybe<Array<Vpc_Peering_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Peering_Order_By>>;
  where?: Maybe<Vpc_Peering_Bool_Exp>;
};

/** aggregated selection of "dedicated_vpc" */
export type Dedicated_Vpc_Aggregate = {
  __typename?: 'dedicated_vpc_aggregate';
  aggregate?: Maybe<Dedicated_Vpc_Aggregate_Fields>;
  nodes: Array<Dedicated_Vpc>;
};

/** aggregate fields of "dedicated_vpc" */
export type Dedicated_Vpc_Aggregate_Fields = {
  __typename?: 'dedicated_vpc_aggregate_fields';
  avg?: Maybe<Dedicated_Vpc_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Dedicated_Vpc_Max_Fields>;
  min?: Maybe<Dedicated_Vpc_Min_Fields>;
  stddev?: Maybe<Dedicated_Vpc_Stddev_Fields>;
  stddev_pop?: Maybe<Dedicated_Vpc_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Dedicated_Vpc_Stddev_Samp_Fields>;
  sum?: Maybe<Dedicated_Vpc_Sum_Fields>;
  var_pop?: Maybe<Dedicated_Vpc_Var_Pop_Fields>;
  var_samp?: Maybe<Dedicated_Vpc_Var_Samp_Fields>;
  variance?: Maybe<Dedicated_Vpc_Variance_Fields>;
};

/** aggregate fields of "dedicated_vpc" */
export type Dedicated_Vpc_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Dedicated_Vpc_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Dedicated_Vpc_Append_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Dedicated_Vpc_Avg_Fields = {
  __typename?: 'dedicated_vpc_avg_fields';
  our_asn?: Maybe<Scalars['Float']>;
  their_asn?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "dedicated_vpc". All fields are combined with a logical 'AND'. */
export type Dedicated_Vpc_Bool_Exp = {
  _and?: Maybe<Array<Dedicated_Vpc_Bool_Exp>>;
  _not?: Maybe<Dedicated_Vpc_Bool_Exp>;
  _or?: Maybe<Array<Dedicated_Vpc_Bool_Exp>>;
  cidr?: Maybe<String_Comparison_Exp>;
  cloud?: Maybe<String_Comparison_Exp>;
  comments?: Maybe<String_Comparison_Exp>;
  create_with_dev_cluster?: Maybe<Boolean_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Bool_Exp>;
  destroy_requested?: Maybe<Boolean_Comparison_Exp>;
  disable_infra_auto_apply?: Maybe<Boolean_Comparison_Exp>;
  gcp_network_name?: Maybe<String_Comparison_Exp>;
  hasura_worker_security_group_id?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  infra_status?: Maybe<Infra_Status_Enum_Comparison_Exp>;
  input_variables?: Maybe<Jsonb_Comparison_Exp>;
  message?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  nat_ip?: Maybe<String_Comparison_Exp>;
  nat_ips?: Maybe<Json_Comparison_Exp>;
  our_asn?: Maybe<Int_Comparison_Exp>;
  output_variables?: Maybe<Jsonb_Comparison_Exp>;
  owner?: Maybe<Users_Bool_Exp>;
  owner_id?: Maybe<Uuid_Comparison_Exp>;
  parent_dedicated_vpc_id?: Maybe<Uuid_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  region_info?: Maybe<Region_Bool_Exp>;
  slug?: Maybe<String_Comparison_Exp>;
  status?: Maybe<Vpc_Status_Enum_Comparison_Exp>;
  tenant_groups?: Maybe<Tenant_Group_Bool_Exp>;
  tenant_groups_aggregate?: Maybe<Tenant_Group_Aggregate_Bool_Exp>;
  tenants?: Maybe<Tenant_Bool_Exp>;
  tenants_aggregate?: Maybe<Tenant_Aggregate_Bool_Exp>;
  their_asn?: Maybe<Int_Comparison_Exp>;
  vpc_cidr?: Maybe<String_Comparison_Exp>;
  vpc_id?: Maybe<String_Comparison_Exp>;
  vpc_peerings?: Maybe<Vpc_Peering_Bool_Exp>;
  vpc_peerings_aggregate?: Maybe<Vpc_Peering_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "dedicated_vpc" */
export enum Dedicated_Vpc_Constraint {
  /** unique or primary key constraint on columns "id" */
  DedicatedVpcPkey = 'dedicated_vpc_pkey',
  /** unique or primary key constraint on columns "slug" */
  DedicatedVpcSlugKey = 'dedicated_vpc_slug_key',
  /** unique or primary key constraint on columns "our_asn", "their_asn" */
  UniqueAsns = 'unique_asns',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Dedicated_Vpc_Delete_At_Path_Input = {
  input_variables?: Maybe<Array<Scalars['String']>>;
  output_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Dedicated_Vpc_Delete_Elem_Input = {
  input_variables?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Dedicated_Vpc_Delete_Key_Input = {
  input_variables?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "dedicated_vpc" */
export type Dedicated_Vpc_Inc_Input = {
  our_asn?: Maybe<Scalars['Int']>;
  their_asn?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "dedicated_vpc" */
export type Dedicated_Vpc_Insert_Input = {
  cidr?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  create_with_dev_cluster?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Obj_Rel_Insert_Input>;
  destroy_requested?: Maybe<Scalars['Boolean']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  message?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  our_asn?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  owner?: Maybe<Users_Obj_Rel_Insert_Input>;
  owner_id?: Maybe<Scalars['uuid']>;
  parent_dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  region_info?: Maybe<Region_Obj_Rel_Insert_Input>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Vpc_Status_Enum>;
  tenant_groups?: Maybe<Tenant_Group_Arr_Rel_Insert_Input>;
  tenants?: Maybe<Tenant_Arr_Rel_Insert_Input>;
  their_asn?: Maybe<Scalars['Int']>;
  vpc_peerings?: Maybe<Vpc_Peering_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Dedicated_Vpc_Max_Fields = {
  __typename?: 'dedicated_vpc_max_fields';
  cidr?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  our_asn?: Maybe<Scalars['Int']>;
  owner_id?: Maybe<Scalars['uuid']>;
  parent_dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  their_asn?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Dedicated_Vpc_Min_Fields = {
  __typename?: 'dedicated_vpc_min_fields';
  cidr?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  our_asn?: Maybe<Scalars['Int']>;
  owner_id?: Maybe<Scalars['uuid']>;
  parent_dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  their_asn?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "dedicated_vpc" */
export type Dedicated_Vpc_Mutation_Response = {
  __typename?: 'dedicated_vpc_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Dedicated_Vpc>;
};

/** input type for inserting object relation for remote table "dedicated_vpc" */
export type Dedicated_Vpc_Obj_Rel_Insert_Input = {
  data: Dedicated_Vpc_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Dedicated_Vpc_On_Conflict>;
};

/** on_conflict condition type for table "dedicated_vpc" */
export type Dedicated_Vpc_On_Conflict = {
  constraint: Dedicated_Vpc_Constraint;
  update_columns?: Array<Dedicated_Vpc_Update_Column>;
  where?: Maybe<Dedicated_Vpc_Bool_Exp>;
};

/** Ordering options when selecting data from "dedicated_vpc". */
export type Dedicated_Vpc_Order_By = {
  cidr?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  comments?: Maybe<Order_By>;
  create_with_dev_cluster?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Order_By>;
  destroy_requested?: Maybe<Order_By>;
  disable_infra_auto_apply?: Maybe<Order_By>;
  gcp_network_name?: Maybe<Order_By>;
  hasura_worker_security_group_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  infra_status?: Maybe<Order_By>;
  input_variables?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  nat_ip?: Maybe<Order_By>;
  nat_ips?: Maybe<Order_By>;
  our_asn?: Maybe<Order_By>;
  output_variables?: Maybe<Order_By>;
  owner?: Maybe<Users_Order_By>;
  owner_id?: Maybe<Order_By>;
  parent_dedicated_vpc_id?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  region_info?: Maybe<Region_Order_By>;
  slug?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  tenant_groups_aggregate?: Maybe<Tenant_Group_Aggregate_Order_By>;
  tenants_aggregate?: Maybe<Tenant_Aggregate_Order_By>;
  their_asn?: Maybe<Order_By>;
  vpc_cidr?: Maybe<Order_By>;
  vpc_id?: Maybe<Order_By>;
  vpc_peerings_aggregate?: Maybe<Vpc_Peering_Aggregate_Order_By>;
};

/** primary key columns input for table: dedicated_vpc */
export type Dedicated_Vpc_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Dedicated_Vpc_Prepend_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "dedicated_vpc" */
export enum Dedicated_Vpc_Select_Column {
  /** column name */
  Cidr = 'cidr',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  Comments = 'comments',
  /** column name */
  CreateWithDevCluster = 'create_with_dev_cluster',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DestroyRequested = 'destroy_requested',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  Id = 'id',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  Message = 'message',
  /** column name */
  Name = 'name',
  /** column name */
  NatIp = 'nat_ip',
  /** column name */
  OurAsn = 'our_asn',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  ParentDedicatedVpcId = 'parent_dedicated_vpc_id',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  TheirAsn = 'their_asn',
}

/** input type for updating data in table "dedicated_vpc" */
export type Dedicated_Vpc_Set_Input = {
  cidr?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  create_with_dev_cluster?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  destroy_requested?: Maybe<Scalars['Boolean']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  message?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  our_asn?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  owner_id?: Maybe<Scalars['uuid']>;
  parent_dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Vpc_Status_Enum>;
  their_asn?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Dedicated_Vpc_Stddev_Fields = {
  __typename?: 'dedicated_vpc_stddev_fields';
  our_asn?: Maybe<Scalars['Float']>;
  their_asn?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Dedicated_Vpc_Stddev_Pop_Fields = {
  __typename?: 'dedicated_vpc_stddev_pop_fields';
  our_asn?: Maybe<Scalars['Float']>;
  their_asn?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Dedicated_Vpc_Stddev_Samp_Fields = {
  __typename?: 'dedicated_vpc_stddev_samp_fields';
  our_asn?: Maybe<Scalars['Float']>;
  their_asn?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "dedicated_vpc" */
export type Dedicated_Vpc_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Dedicated_Vpc_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Dedicated_Vpc_Stream_Cursor_Value_Input = {
  cidr?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  create_with_dev_cluster?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  destroy_requested?: Maybe<Scalars['Boolean']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  message?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  our_asn?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  owner_id?: Maybe<Scalars['uuid']>;
  parent_dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Vpc_Status_Enum>;
  their_asn?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Dedicated_Vpc_Sum_Fields = {
  __typename?: 'dedicated_vpc_sum_fields';
  our_asn?: Maybe<Scalars['Int']>;
  their_asn?: Maybe<Scalars['Int']>;
};

/** update columns of table "dedicated_vpc" */
export enum Dedicated_Vpc_Update_Column {
  /** column name */
  Cidr = 'cidr',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  Comments = 'comments',
  /** column name */
  CreateWithDevCluster = 'create_with_dev_cluster',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DestroyRequested = 'destroy_requested',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  Id = 'id',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  Message = 'message',
  /** column name */
  Name = 'name',
  /** column name */
  NatIp = 'nat_ip',
  /** column name */
  OurAsn = 'our_asn',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  ParentDedicatedVpcId = 'parent_dedicated_vpc_id',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  TheirAsn = 'their_asn',
}

export type Dedicated_Vpc_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Dedicated_Vpc_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Dedicated_Vpc_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Dedicated_Vpc_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Dedicated_Vpc_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Dedicated_Vpc_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Dedicated_Vpc_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Dedicated_Vpc_Set_Input>;
  /** filter the rows which have to be updated */
  where: Dedicated_Vpc_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Dedicated_Vpc_Var_Pop_Fields = {
  __typename?: 'dedicated_vpc_var_pop_fields';
  our_asn?: Maybe<Scalars['Float']>;
  their_asn?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Dedicated_Vpc_Var_Samp_Fields = {
  __typename?: 'dedicated_vpc_var_samp_fields';
  our_asn?: Maybe<Scalars['Float']>;
  their_asn?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Dedicated_Vpc_Variance_Fields = {
  __typename?: 'dedicated_vpc_variance_fields';
  our_asn?: Maybe<Scalars['Float']>;
  their_asn?: Maybe<Scalars['Float']>;
};

export type DedicatedCloudClusterBillsOutput = {
  __typename?: 'DedicatedCloudClusterBillsOutput';
  compute_unit_config_id: Scalars['uuid'];
  cu_usage_amount: Scalars['Int'];
  data_usage_amount: Scalars['Int'];
  month: Scalars['Int'];
  year: Scalars['Int'];
};

export type DefaultPaymentResponse = {
  __typename?: 'DefaultPaymentResponse';
  status: Scalars['String'];
};

/** Table to record user deletion */
export type Delete_User = {
  __typename?: 'delete_user';
  created_at: Scalars['timestamptz'];
  /** An array relationship */
  delete_tasks: Array<Delete_User_Tasks>;
  /** An aggregate relationship */
  delete_tasks_aggregate: Delete_User_Tasks_Aggregate;
  status?: Maybe<Scalars['String']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  user_id: Scalars['uuid'];
};

/** Table to record user deletion */
export type Delete_UserDelete_TasksArgs = {
  distinct_on?: Maybe<Array<Delete_User_Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Tasks_Order_By>>;
  where?: Maybe<Delete_User_Tasks_Bool_Exp>;
};

/** Table to record user deletion */
export type Delete_UserDelete_Tasks_AggregateArgs = {
  distinct_on?: Maybe<Array<Delete_User_Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Tasks_Order_By>>;
  where?: Maybe<Delete_User_Tasks_Bool_Exp>;
};

/** aggregated selection of "delete_user" */
export type Delete_User_Aggregate = {
  __typename?: 'delete_user_aggregate';
  aggregate?: Maybe<Delete_User_Aggregate_Fields>;
  nodes: Array<Delete_User>;
};

/** aggregate fields of "delete_user" */
export type Delete_User_Aggregate_Fields = {
  __typename?: 'delete_user_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Delete_User_Max_Fields>;
  min?: Maybe<Delete_User_Min_Fields>;
};

/** aggregate fields of "delete_user" */
export type Delete_User_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Delete_User_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "delete_user". All fields are combined with a logical 'AND'. */
export type Delete_User_Bool_Exp = {
  _and?: Maybe<Array<Delete_User_Bool_Exp>>;
  _not?: Maybe<Delete_User_Bool_Exp>;
  _or?: Maybe<Array<Delete_User_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  delete_tasks?: Maybe<Delete_User_Tasks_Bool_Exp>;
  delete_tasks_aggregate?: Maybe<Delete_User_Tasks_Aggregate_Bool_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  stripe_customer_id?: Maybe<String_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "delete_user" */
export enum Delete_User_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  DeleteUserPkey = 'delete_user_pkey',
  /** unique or primary key constraint on columns "stripe_customer_id" */
  DeleteUserStripeCustomerIdKey = 'delete_user_stripe_customer_id_key',
}

/** input type for inserting data into table "delete_user" */
export type Delete_User_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  delete_tasks?: Maybe<Delete_User_Tasks_Arr_Rel_Insert_Input>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Delete_User_Max_Fields = {
  __typename?: 'delete_user_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Delete_User_Min_Fields = {
  __typename?: 'delete_user_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "delete_user" */
export type Delete_User_Mutation_Response = {
  __typename?: 'delete_user_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Delete_User>;
};

/** on_conflict condition type for table "delete_user" */
export type Delete_User_On_Conflict = {
  constraint: Delete_User_Constraint;
  update_columns?: Array<Delete_User_Update_Column>;
  where?: Maybe<Delete_User_Bool_Exp>;
};

/** Ordering options when selecting data from "delete_user". */
export type Delete_User_Order_By = {
  created_at?: Maybe<Order_By>;
  delete_tasks_aggregate?: Maybe<Delete_User_Tasks_Aggregate_Order_By>;
  status?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: delete_user */
export type Delete_User_Pk_Columns_Input = {
  user_id: Scalars['uuid'];
};

/** select columns of table "delete_user" */
export enum Delete_User_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "delete_user" */
export type Delete_User_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Hasura enum to capture the status of user deletion */
export type Delete_User_Status = {
  __typename?: 'delete_user_status';
  comment: Scalars['String'];
  status: Scalars['String'];
};

/** aggregated selection of "delete_user_status" */
export type Delete_User_Status_Aggregate = {
  __typename?: 'delete_user_status_aggregate';
  aggregate?: Maybe<Delete_User_Status_Aggregate_Fields>;
  nodes: Array<Delete_User_Status>;
};

/** aggregate fields of "delete_user_status" */
export type Delete_User_Status_Aggregate_Fields = {
  __typename?: 'delete_user_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Delete_User_Status_Max_Fields>;
  min?: Maybe<Delete_User_Status_Min_Fields>;
};

/** aggregate fields of "delete_user_status" */
export type Delete_User_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Delete_User_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "delete_user_status". All fields are combined with a logical 'AND'. */
export type Delete_User_Status_Bool_Exp = {
  _and?: Maybe<Array<Delete_User_Status_Bool_Exp>>;
  _not?: Maybe<Delete_User_Status_Bool_Exp>;
  _or?: Maybe<Array<Delete_User_Status_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "delete_user_status" */
export enum Delete_User_Status_Constraint {
  /** unique or primary key constraint on columns "status" */
  DeleteUserStatusPkey = 'delete_user_status_pkey',
}

export enum Delete_User_Status_Enum {
  /** the task is completed */
  Completed = 'completed',
  /** the task is failed */
  Failed = 'failed',
  /** the task is in progress */
  InProgress = 'in_progress',
  /** the task is pending */
  Pending = 'pending',
}

/** Boolean expression to compare columns of type "delete_user_status_enum". All fields are combined with logical 'AND'. */
export type Delete_User_Status_Enum_Comparison_Exp = {
  _eq?: Maybe<Delete_User_Status_Enum>;
  _in?: Maybe<Array<Delete_User_Status_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Delete_User_Status_Enum>;
  _nin?: Maybe<Array<Delete_User_Status_Enum>>;
};

/** input type for inserting data into table "delete_user_status" */
export type Delete_User_Status_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Delete_User_Status_Max_Fields = {
  __typename?: 'delete_user_status_max_fields';
  comment?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Delete_User_Status_Min_Fields = {
  __typename?: 'delete_user_status_min_fields';
  comment?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "delete_user_status" */
export type Delete_User_Status_Mutation_Response = {
  __typename?: 'delete_user_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Delete_User_Status>;
};

/** on_conflict condition type for table "delete_user_status" */
export type Delete_User_Status_On_Conflict = {
  constraint: Delete_User_Status_Constraint;
  update_columns?: Array<Delete_User_Status_Update_Column>;
  where?: Maybe<Delete_User_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "delete_user_status". */
export type Delete_User_Status_Order_By = {
  comment?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
};

/** primary key columns input for table: delete_user_status */
export type Delete_User_Status_Pk_Columns_Input = {
  status: Scalars['String'];
};

/** select columns of table "delete_user_status" */
export enum Delete_User_Status_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Status = 'status',
}

/** input type for updating data in table "delete_user_status" */
export type Delete_User_Status_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "delete_user_status" */
export type Delete_User_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Delete_User_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Delete_User_Status_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** update columns of table "delete_user_status" */
export enum Delete_User_Status_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Status = 'status',
}

export type Delete_User_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Delete_User_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Delete_User_Status_Bool_Exp;
};

/** Streaming cursor of the table "delete_user" */
export type Delete_User_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Delete_User_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Delete_User_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** User tasks to be deleted */
export type Delete_User_Tasks = {
  __typename?: 'delete_user_tasks';
  additional_info?: Maybe<Scalars['jsonb']>;
  remarks?: Maybe<Scalars['String']>;
  status: Delete_User_Status_Enum;
  task_name: Scalars['String'];
  task_order: Scalars['Int'];
  user_id: Scalars['uuid'];
  /** An object relationship */
  users?: Maybe<Users>;
};

/** User tasks to be deleted */
export type Delete_User_TasksAdditional_InfoArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "delete_user_tasks" */
export type Delete_User_Tasks_Aggregate = {
  __typename?: 'delete_user_tasks_aggregate';
  aggregate?: Maybe<Delete_User_Tasks_Aggregate_Fields>;
  nodes: Array<Delete_User_Tasks>;
};

export type Delete_User_Tasks_Aggregate_Bool_Exp = {
  count?: Maybe<Delete_User_Tasks_Aggregate_Bool_Exp_Count>;
};

export type Delete_User_Tasks_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Delete_User_Tasks_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Delete_User_Tasks_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "delete_user_tasks" */
export type Delete_User_Tasks_Aggregate_Fields = {
  __typename?: 'delete_user_tasks_aggregate_fields';
  avg?: Maybe<Delete_User_Tasks_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Delete_User_Tasks_Max_Fields>;
  min?: Maybe<Delete_User_Tasks_Min_Fields>;
  stddev?: Maybe<Delete_User_Tasks_Stddev_Fields>;
  stddev_pop?: Maybe<Delete_User_Tasks_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Delete_User_Tasks_Stddev_Samp_Fields>;
  sum?: Maybe<Delete_User_Tasks_Sum_Fields>;
  var_pop?: Maybe<Delete_User_Tasks_Var_Pop_Fields>;
  var_samp?: Maybe<Delete_User_Tasks_Var_Samp_Fields>;
  variance?: Maybe<Delete_User_Tasks_Variance_Fields>;
};

/** aggregate fields of "delete_user_tasks" */
export type Delete_User_Tasks_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Delete_User_Tasks_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "delete_user_tasks" */
export type Delete_User_Tasks_Aggregate_Order_By = {
  avg?: Maybe<Delete_User_Tasks_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Delete_User_Tasks_Max_Order_By>;
  min?: Maybe<Delete_User_Tasks_Min_Order_By>;
  stddev?: Maybe<Delete_User_Tasks_Stddev_Order_By>;
  stddev_pop?: Maybe<Delete_User_Tasks_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Delete_User_Tasks_Stddev_Samp_Order_By>;
  sum?: Maybe<Delete_User_Tasks_Sum_Order_By>;
  var_pop?: Maybe<Delete_User_Tasks_Var_Pop_Order_By>;
  var_samp?: Maybe<Delete_User_Tasks_Var_Samp_Order_By>;
  variance?: Maybe<Delete_User_Tasks_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Delete_User_Tasks_Append_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "delete_user_tasks" */
export type Delete_User_Tasks_Arr_Rel_Insert_Input = {
  data: Array<Delete_User_Tasks_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Delete_User_Tasks_On_Conflict>;
};

/** aggregate avg on columns */
export type Delete_User_Tasks_Avg_Fields = {
  __typename?: 'delete_user_tasks_avg_fields';
  task_order?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "delete_user_tasks" */
export type Delete_User_Tasks_Avg_Order_By = {
  task_order?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "delete_user_tasks". All fields are combined with a logical 'AND'. */
export type Delete_User_Tasks_Bool_Exp = {
  _and?: Maybe<Array<Delete_User_Tasks_Bool_Exp>>;
  _not?: Maybe<Delete_User_Tasks_Bool_Exp>;
  _or?: Maybe<Array<Delete_User_Tasks_Bool_Exp>>;
  additional_info?: Maybe<Jsonb_Comparison_Exp>;
  remarks?: Maybe<String_Comparison_Exp>;
  status?: Maybe<Delete_User_Status_Enum_Comparison_Exp>;
  task_name?: Maybe<String_Comparison_Exp>;
  task_order?: Maybe<Int_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
  users?: Maybe<Users_Bool_Exp>;
};

/** unique or primary key constraints on table "delete_user_tasks" */
export enum Delete_User_Tasks_Constraint {
  /** unique or primary key constraint on columns "user_id", "task_name" */
  DeleteUserTasksPkey = 'delete_user_tasks_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Delete_User_Tasks_Delete_At_Path_Input = {
  additional_info?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Delete_User_Tasks_Delete_Elem_Input = {
  additional_info?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Delete_User_Tasks_Delete_Key_Input = {
  additional_info?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "delete_user_tasks" */
export type Delete_User_Tasks_Inc_Input = {
  task_order?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "delete_user_tasks" */
export type Delete_User_Tasks_Insert_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  remarks?: Maybe<Scalars['String']>;
  status?: Maybe<Delete_User_Status_Enum>;
  task_name?: Maybe<Scalars['String']>;
  task_order?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['uuid']>;
  users?: Maybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Delete_User_Tasks_Max_Fields = {
  __typename?: 'delete_user_tasks_max_fields';
  remarks?: Maybe<Scalars['String']>;
  task_name?: Maybe<Scalars['String']>;
  task_order?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "delete_user_tasks" */
export type Delete_User_Tasks_Max_Order_By = {
  remarks?: Maybe<Order_By>;
  task_name?: Maybe<Order_By>;
  task_order?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Delete_User_Tasks_Min_Fields = {
  __typename?: 'delete_user_tasks_min_fields';
  remarks?: Maybe<Scalars['String']>;
  task_name?: Maybe<Scalars['String']>;
  task_order?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "delete_user_tasks" */
export type Delete_User_Tasks_Min_Order_By = {
  remarks?: Maybe<Order_By>;
  task_name?: Maybe<Order_By>;
  task_order?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "delete_user_tasks" */
export type Delete_User_Tasks_Mutation_Response = {
  __typename?: 'delete_user_tasks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Delete_User_Tasks>;
};

/** on_conflict condition type for table "delete_user_tasks" */
export type Delete_User_Tasks_On_Conflict = {
  constraint: Delete_User_Tasks_Constraint;
  update_columns?: Array<Delete_User_Tasks_Update_Column>;
  where?: Maybe<Delete_User_Tasks_Bool_Exp>;
};

/** Ordering options when selecting data from "delete_user_tasks". */
export type Delete_User_Tasks_Order_By = {
  additional_info?: Maybe<Order_By>;
  remarks?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  task_name?: Maybe<Order_By>;
  task_order?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  users?: Maybe<Users_Order_By>;
};

/** primary key columns input for table: delete_user_tasks */
export type Delete_User_Tasks_Pk_Columns_Input = {
  task_name: Scalars['String'];
  user_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Delete_User_Tasks_Prepend_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "delete_user_tasks" */
export enum Delete_User_Tasks_Select_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  Remarks = 'remarks',
  /** column name */
  Status = 'status',
  /** column name */
  TaskName = 'task_name',
  /** column name */
  TaskOrder = 'task_order',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "delete_user_tasks" */
export type Delete_User_Tasks_Set_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  remarks?: Maybe<Scalars['String']>;
  status?: Maybe<Delete_User_Status_Enum>;
  task_name?: Maybe<Scalars['String']>;
  task_order?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Delete_User_Tasks_Stddev_Fields = {
  __typename?: 'delete_user_tasks_stddev_fields';
  task_order?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "delete_user_tasks" */
export type Delete_User_Tasks_Stddev_Order_By = {
  task_order?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Delete_User_Tasks_Stddev_Pop_Fields = {
  __typename?: 'delete_user_tasks_stddev_pop_fields';
  task_order?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "delete_user_tasks" */
export type Delete_User_Tasks_Stddev_Pop_Order_By = {
  task_order?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Delete_User_Tasks_Stddev_Samp_Fields = {
  __typename?: 'delete_user_tasks_stddev_samp_fields';
  task_order?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "delete_user_tasks" */
export type Delete_User_Tasks_Stddev_Samp_Order_By = {
  task_order?: Maybe<Order_By>;
};

/** Streaming cursor of the table "delete_user_tasks" */
export type Delete_User_Tasks_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Delete_User_Tasks_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Delete_User_Tasks_Stream_Cursor_Value_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  remarks?: Maybe<Scalars['String']>;
  status?: Maybe<Delete_User_Status_Enum>;
  task_name?: Maybe<Scalars['String']>;
  task_order?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Delete_User_Tasks_Sum_Fields = {
  __typename?: 'delete_user_tasks_sum_fields';
  task_order?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "delete_user_tasks" */
export type Delete_User_Tasks_Sum_Order_By = {
  task_order?: Maybe<Order_By>;
};

/** update columns of table "delete_user_tasks" */
export enum Delete_User_Tasks_Update_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  Remarks = 'remarks',
  /** column name */
  Status = 'status',
  /** column name */
  TaskName = 'task_name',
  /** column name */
  TaskOrder = 'task_order',
  /** column name */
  UserId = 'user_id',
}

export type Delete_User_Tasks_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Delete_User_Tasks_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Delete_User_Tasks_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Delete_User_Tasks_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Delete_User_Tasks_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Delete_User_Tasks_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Delete_User_Tasks_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Delete_User_Tasks_Set_Input>;
  /** filter the rows which have to be updated */
  where: Delete_User_Tasks_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Delete_User_Tasks_Var_Pop_Fields = {
  __typename?: 'delete_user_tasks_var_pop_fields';
  task_order?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "delete_user_tasks" */
export type Delete_User_Tasks_Var_Pop_Order_By = {
  task_order?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Delete_User_Tasks_Var_Samp_Fields = {
  __typename?: 'delete_user_tasks_var_samp_fields';
  task_order?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "delete_user_tasks" */
export type Delete_User_Tasks_Var_Samp_Order_By = {
  task_order?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Delete_User_Tasks_Variance_Fields = {
  __typename?: 'delete_user_tasks_variance_fields';
  task_order?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "delete_user_tasks" */
export type Delete_User_Tasks_Variance_Order_By = {
  task_order?: Maybe<Order_By>;
};

/** update columns of table "delete_user" */
export enum Delete_User_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  UserId = 'user_id',
}

export type Delete_User_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Delete_User_Set_Input>;
  /** filter the rows which have to be updated */
  where: Delete_User_Bool_Exp;
};

export type DeleteCardResponse = {
  __typename?: 'DeleteCardResponse';
  msg: Scalars['String'];
};

export type DeleteGithubIntegrationInput = {
  integration_id: Scalars['String'];
};

export type DeleteGithubIntegrationStatus = {
  __typename?: 'DeleteGithubIntegrationStatus';
  status: Scalars['String'];
};

export type DeleteProjectInput = {
  id: Scalars['uuid'];
};

export type DeleteProjectResponse = {
  __typename?: 'DeleteProjectResponse';
  id: Scalars['uuid'];
};

export type DeleteSlackAppOutput = {
  __typename?: 'DeleteSlackAppOutput';
  status: Scalars['String'];
};

export type DeleteUserResponse = {
  __typename?: 'deleteUserResponse';
  status: Scalars['String'];
};

export type DelteSlackAppPayload = {
  projectID: Scalars['uuid'];
};

export type DeployLatestCommitStatus = {
  __typename?: 'DeployLatestCommitStatus';
  status: Scalars['String'];
};

export type DeployLatestGithubCommitInput = {
  github_intergation_config_id: Scalars['String'];
};

/** columns and relationships of "email_log" */
export type Email_Log = {
  __typename?: 'email_log';
  created_at: Scalars['timestamptz'];
  created_by_service: Scalars['String'];
  from: Scalars['String'];
  from_name: Scalars['String'];
  id: Scalars['uuid'];
  is_sent: Scalars['Boolean'];
  sent_at?: Maybe<Scalars['timestamptz']>;
  template_metadata?: Maybe<Scalars['jsonb']>;
  template_name: Scalars['String'];
  to: Scalars['String'];
};

/** columns and relationships of "email_log" */
export type Email_LogTemplate_MetadataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "email_log" */
export type Email_Log_Aggregate = {
  __typename?: 'email_log_aggregate';
  aggregate?: Maybe<Email_Log_Aggregate_Fields>;
  nodes: Array<Email_Log>;
};

/** aggregate fields of "email_log" */
export type Email_Log_Aggregate_Fields = {
  __typename?: 'email_log_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Email_Log_Max_Fields>;
  min?: Maybe<Email_Log_Min_Fields>;
};

/** aggregate fields of "email_log" */
export type Email_Log_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Email_Log_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Email_Log_Append_Input = {
  template_metadata?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "email_log". All fields are combined with a logical 'AND'. */
export type Email_Log_Bool_Exp = {
  _and?: Maybe<Array<Email_Log_Bool_Exp>>;
  _not?: Maybe<Email_Log_Bool_Exp>;
  _or?: Maybe<Array<Email_Log_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  created_by_service?: Maybe<String_Comparison_Exp>;
  from?: Maybe<String_Comparison_Exp>;
  from_name?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_sent?: Maybe<Boolean_Comparison_Exp>;
  sent_at?: Maybe<Timestamptz_Comparison_Exp>;
  template_metadata?: Maybe<Jsonb_Comparison_Exp>;
  template_name?: Maybe<String_Comparison_Exp>;
  to?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "email_log" */
export enum Email_Log_Constraint {
  /** unique or primary key constraint on columns "id" */
  EmailLogPkey = 'email_log_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Email_Log_Delete_At_Path_Input = {
  template_metadata?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Email_Log_Delete_Elem_Input = {
  template_metadata?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Email_Log_Delete_Key_Input = {
  template_metadata?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "email_log" */
export type Email_Log_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by_service?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['String']>;
  from_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_sent?: Maybe<Scalars['Boolean']>;
  sent_at?: Maybe<Scalars['timestamptz']>;
  template_metadata?: Maybe<Scalars['jsonb']>;
  template_name?: Maybe<Scalars['String']>;
  to?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Email_Log_Max_Fields = {
  __typename?: 'email_log_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by_service?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['String']>;
  from_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  sent_at?: Maybe<Scalars['timestamptz']>;
  template_name?: Maybe<Scalars['String']>;
  to?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Email_Log_Min_Fields = {
  __typename?: 'email_log_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by_service?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['String']>;
  from_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  sent_at?: Maybe<Scalars['timestamptz']>;
  template_name?: Maybe<Scalars['String']>;
  to?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "email_log" */
export type Email_Log_Mutation_Response = {
  __typename?: 'email_log_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Email_Log>;
};

/** on_conflict condition type for table "email_log" */
export type Email_Log_On_Conflict = {
  constraint: Email_Log_Constraint;
  update_columns?: Array<Email_Log_Update_Column>;
  where?: Maybe<Email_Log_Bool_Exp>;
};

/** Ordering options when selecting data from "email_log". */
export type Email_Log_Order_By = {
  created_at?: Maybe<Order_By>;
  created_by_service?: Maybe<Order_By>;
  from?: Maybe<Order_By>;
  from_name?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_sent?: Maybe<Order_By>;
  sent_at?: Maybe<Order_By>;
  template_metadata?: Maybe<Order_By>;
  template_name?: Maybe<Order_By>;
  to?: Maybe<Order_By>;
};

/** primary key columns input for table: email_log */
export type Email_Log_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Email_Log_Prepend_Input = {
  template_metadata?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "email_log" */
export enum Email_Log_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByService = 'created_by_service',
  /** column name */
  From = 'from',
  /** column name */
  FromName = 'from_name',
  /** column name */
  Id = 'id',
  /** column name */
  IsSent = 'is_sent',
  /** column name */
  SentAt = 'sent_at',
  /** column name */
  TemplateMetadata = 'template_metadata',
  /** column name */
  TemplateName = 'template_name',
  /** column name */
  To = 'to',
}

/** input type for updating data in table "email_log" */
export type Email_Log_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by_service?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['String']>;
  from_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_sent?: Maybe<Scalars['Boolean']>;
  sent_at?: Maybe<Scalars['timestamptz']>;
  template_metadata?: Maybe<Scalars['jsonb']>;
  template_name?: Maybe<Scalars['String']>;
  to?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "email_log" */
export type Email_Log_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Email_Log_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Email_Log_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by_service?: Maybe<Scalars['String']>;
  from?: Maybe<Scalars['String']>;
  from_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_sent?: Maybe<Scalars['Boolean']>;
  sent_at?: Maybe<Scalars['timestamptz']>;
  template_metadata?: Maybe<Scalars['jsonb']>;
  template_name?: Maybe<Scalars['String']>;
  to?: Maybe<Scalars['String']>;
};

/** update columns of table "email_log" */
export enum Email_Log_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedByService = 'created_by_service',
  /** column name */
  From = 'from',
  /** column name */
  FromName = 'from_name',
  /** column name */
  Id = 'id',
  /** column name */
  IsSent = 'is_sent',
  /** column name */
  SentAt = 'sent_at',
  /** column name */
  TemplateMetadata = 'template_metadata',
  /** column name */
  TemplateName = 'template_name',
  /** column name */
  To = 'to',
}

export type Email_Log_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Email_Log_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Email_Log_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Email_Log_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Email_Log_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Email_Log_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Email_Log_Set_Input>;
  /** filter the rows which have to be updated */
  where: Email_Log_Bool_Exp;
};

export type EnableCloudflareProxyResponse = {
  __typename?: 'EnableCloudflareProxyResponse';
  tenant_id: Scalars['uuid'];
};

/** list of users on Hasura enterprise edition */
export type Enterprise_Users = {
  __typename?: 'enterprise_users';
  created_at: Scalars['timestamptz'];
  customer_email: Scalars['citext'];
  id: Scalars['Int'];
  is_active: Scalars['Boolean'];
  is_exempt_from_billing: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  user_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  users?: Maybe<Users>;
};

/** aggregated selection of "enterprise_users" */
export type Enterprise_Users_Aggregate = {
  __typename?: 'enterprise_users_aggregate';
  aggregate?: Maybe<Enterprise_Users_Aggregate_Fields>;
  nodes: Array<Enterprise_Users>;
};

/** aggregate fields of "enterprise_users" */
export type Enterprise_Users_Aggregate_Fields = {
  __typename?: 'enterprise_users_aggregate_fields';
  avg?: Maybe<Enterprise_Users_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Enterprise_Users_Max_Fields>;
  min?: Maybe<Enterprise_Users_Min_Fields>;
  stddev?: Maybe<Enterprise_Users_Stddev_Fields>;
  stddev_pop?: Maybe<Enterprise_Users_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Enterprise_Users_Stddev_Samp_Fields>;
  sum?: Maybe<Enterprise_Users_Sum_Fields>;
  var_pop?: Maybe<Enterprise_Users_Var_Pop_Fields>;
  var_samp?: Maybe<Enterprise_Users_Var_Samp_Fields>;
  variance?: Maybe<Enterprise_Users_Variance_Fields>;
};

/** aggregate fields of "enterprise_users" */
export type Enterprise_Users_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Enterprise_Users_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Enterprise_Users_Avg_Fields = {
  __typename?: 'enterprise_users_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "enterprise_users". All fields are combined with a logical 'AND'. */
export type Enterprise_Users_Bool_Exp = {
  _and?: Maybe<Array<Enterprise_Users_Bool_Exp>>;
  _not?: Maybe<Enterprise_Users_Bool_Exp>;
  _or?: Maybe<Array<Enterprise_Users_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customer_email?: Maybe<Citext_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  is_exempt_from_billing?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
  users?: Maybe<Users_Bool_Exp>;
};

/** unique or primary key constraints on table "enterprise_users" */
export enum Enterprise_Users_Constraint {
  /** unique or primary key constraint on columns "customer_email" */
  EnterpriseUsersCustomerEmailKey = 'enterprise_users_customer_email_key',
  /** unique or primary key constraint on columns "customer_email" */
  EnterpriseUsersPkey = 'enterprise_users_pkey',
}

/** input type for incrementing numeric columns in table "enterprise_users" */
export type Enterprise_Users_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "enterprise_users" */
export type Enterprise_Users_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['Int']>;
  is_active?: Maybe<Scalars['Boolean']>;
  is_exempt_from_billing?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  users?: Maybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Enterprise_Users_Max_Fields = {
  __typename?: 'enterprise_users_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Enterprise_Users_Min_Fields = {
  __typename?: 'enterprise_users_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "enterprise_users" */
export type Enterprise_Users_Mutation_Response = {
  __typename?: 'enterprise_users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Enterprise_Users>;
};

/** input type for inserting object relation for remote table "enterprise_users" */
export type Enterprise_Users_Obj_Rel_Insert_Input = {
  data: Enterprise_Users_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Enterprise_Users_On_Conflict>;
};

/** on_conflict condition type for table "enterprise_users" */
export type Enterprise_Users_On_Conflict = {
  constraint: Enterprise_Users_Constraint;
  update_columns?: Array<Enterprise_Users_Update_Column>;
  where?: Maybe<Enterprise_Users_Bool_Exp>;
};

/** Ordering options when selecting data from "enterprise_users". */
export type Enterprise_Users_Order_By = {
  created_at?: Maybe<Order_By>;
  customer_email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  is_exempt_from_billing?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
  users?: Maybe<Users_Order_By>;
};

/** primary key columns input for table: enterprise_users */
export type Enterprise_Users_Pk_Columns_Input = {
  customer_email: Scalars['citext'];
};

/** select columns of table "enterprise_users" */
export enum Enterprise_Users_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerEmail = 'customer_email',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  IsExemptFromBilling = 'is_exempt_from_billing',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "enterprise_users" */
export type Enterprise_Users_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['Int']>;
  is_active?: Maybe<Scalars['Boolean']>;
  is_exempt_from_billing?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Enterprise_Users_Stddev_Fields = {
  __typename?: 'enterprise_users_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Enterprise_Users_Stddev_Pop_Fields = {
  __typename?: 'enterprise_users_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Enterprise_Users_Stddev_Samp_Fields = {
  __typename?: 'enterprise_users_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "enterprise_users" */
export type Enterprise_Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Enterprise_Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Enterprise_Users_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_email?: Maybe<Scalars['citext']>;
  id?: Maybe<Scalars['Int']>;
  is_active?: Maybe<Scalars['Boolean']>;
  is_exempt_from_billing?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Enterprise_Users_Sum_Fields = {
  __typename?: 'enterprise_users_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** update columns of table "enterprise_users" */
export enum Enterprise_Users_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerEmail = 'customer_email',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  IsExemptFromBilling = 'is_exempt_from_billing',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

export type Enterprise_Users_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Enterprise_Users_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Enterprise_Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Enterprise_Users_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Enterprise_Users_Var_Pop_Fields = {
  __typename?: 'enterprise_users_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Enterprise_Users_Var_Samp_Fields = {
  __typename?: 'enterprise_users_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Enterprise_Users_Variance_Fields = {
  __typename?: 'enterprise_users_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** This enum represents the growth experiments for Hasura. */
export type Experiments = {
  __typename?: 'experiments';
  comment: Scalars['String'];
  experiment: Scalars['String'];
};

/** aggregated selection of "experiments" */
export type Experiments_Aggregate = {
  __typename?: 'experiments_aggregate';
  aggregate?: Maybe<Experiments_Aggregate_Fields>;
  nodes: Array<Experiments>;
};

/** aggregate fields of "experiments" */
export type Experiments_Aggregate_Fields = {
  __typename?: 'experiments_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Experiments_Max_Fields>;
  min?: Maybe<Experiments_Min_Fields>;
};

/** aggregate fields of "experiments" */
export type Experiments_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Experiments_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "experiments". All fields are combined with a logical 'AND'. */
export type Experiments_Bool_Exp = {
  _and?: Maybe<Array<Experiments_Bool_Exp>>;
  _not?: Maybe<Experiments_Bool_Exp>;
  _or?: Maybe<Array<Experiments_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  experiment?: Maybe<String_Comparison_Exp>;
};

/** Cohort of users for the specific experiment. */
export type Experiments_Cohort = {
  __typename?: 'experiments_cohort';
  activity?: Maybe<Scalars['jsonb']>;
  created_at: Scalars['timestamptz'];
  experiment: Experiments_Enum;
  /** An object relationship */
  parent_experiment: Experiments;
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['uuid'];
};

/** Cohort of users for the specific experiment. */
export type Experiments_CohortActivityArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "experiments_cohort" */
export type Experiments_Cohort_Aggregate = {
  __typename?: 'experiments_cohort_aggregate';
  aggregate?: Maybe<Experiments_Cohort_Aggregate_Fields>;
  nodes: Array<Experiments_Cohort>;
};

export type Experiments_Cohort_Aggregate_Bool_Exp = {
  count?: Maybe<Experiments_Cohort_Aggregate_Bool_Exp_Count>;
};

export type Experiments_Cohort_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Experiments_Cohort_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Experiments_Cohort_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "experiments_cohort" */
export type Experiments_Cohort_Aggregate_Fields = {
  __typename?: 'experiments_cohort_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Experiments_Cohort_Max_Fields>;
  min?: Maybe<Experiments_Cohort_Min_Fields>;
};

/** aggregate fields of "experiments_cohort" */
export type Experiments_Cohort_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Experiments_Cohort_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "experiments_cohort" */
export type Experiments_Cohort_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Experiments_Cohort_Max_Order_By>;
  min?: Maybe<Experiments_Cohort_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Experiments_Cohort_Append_Input = {
  activity?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "experiments_cohort" */
export type Experiments_Cohort_Arr_Rel_Insert_Input = {
  data: Array<Experiments_Cohort_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Experiments_Cohort_On_Conflict>;
};

/** Boolean expression to filter rows from the table "experiments_cohort". All fields are combined with a logical 'AND'. */
export type Experiments_Cohort_Bool_Exp = {
  _and?: Maybe<Array<Experiments_Cohort_Bool_Exp>>;
  _not?: Maybe<Experiments_Cohort_Bool_Exp>;
  _or?: Maybe<Array<Experiments_Cohort_Bool_Exp>>;
  activity?: Maybe<Jsonb_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  experiment?: Maybe<Experiments_Enum_Comparison_Exp>;
  parent_experiment?: Maybe<Experiments_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "experiments_cohort" */
export enum Experiments_Cohort_Constraint {
  /** unique or primary key constraint on columns "user_id", "experiment" */
  ExperimentsCohortPkey = 'experiments_cohort_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Experiments_Cohort_Delete_At_Path_Input = {
  activity?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Experiments_Cohort_Delete_Elem_Input = {
  activity?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Experiments_Cohort_Delete_Key_Input = {
  activity?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "experiments_cohort" */
export type Experiments_Cohort_Insert_Input = {
  activity?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  experiment?: Maybe<Experiments_Enum>;
  parent_experiment?: Maybe<Experiments_Obj_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Experiments_Cohort_Max_Fields = {
  __typename?: 'experiments_cohort_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "experiments_cohort" */
export type Experiments_Cohort_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Experiments_Cohort_Min_Fields = {
  __typename?: 'experiments_cohort_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "experiments_cohort" */
export type Experiments_Cohort_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "experiments_cohort" */
export type Experiments_Cohort_Mutation_Response = {
  __typename?: 'experiments_cohort_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Experiments_Cohort>;
};

/** on_conflict condition type for table "experiments_cohort" */
export type Experiments_Cohort_On_Conflict = {
  constraint: Experiments_Cohort_Constraint;
  update_columns?: Array<Experiments_Cohort_Update_Column>;
  where?: Maybe<Experiments_Cohort_Bool_Exp>;
};

/** Ordering options when selecting data from "experiments_cohort". */
export type Experiments_Cohort_Order_By = {
  activity?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  experiment?: Maybe<Order_By>;
  parent_experiment?: Maybe<Experiments_Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: experiments_cohort */
export type Experiments_Cohort_Pk_Columns_Input = {
  experiment: Experiments_Enum;
  user_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Experiments_Cohort_Prepend_Input = {
  activity?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "experiments_cohort" */
export enum Experiments_Cohort_Select_Column {
  /** column name */
  Activity = 'activity',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Experiment = 'experiment',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "experiments_cohort" */
export type Experiments_Cohort_Set_Input = {
  activity?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  experiment?: Maybe<Experiments_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "experiments_cohort" */
export type Experiments_Cohort_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Experiments_Cohort_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Experiments_Cohort_Stream_Cursor_Value_Input = {
  activity?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  experiment?: Maybe<Experiments_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "experiments_cohort" */
export enum Experiments_Cohort_Update_Column {
  /** column name */
  Activity = 'activity',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Experiment = 'experiment',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

export type Experiments_Cohort_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Experiments_Cohort_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Experiments_Cohort_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Experiments_Cohort_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Experiments_Cohort_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Experiments_Cohort_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Experiments_Cohort_Set_Input>;
  /** filter the rows which have to be updated */
  where: Experiments_Cohort_Bool_Exp;
};

/** Configuration settings for growth experiments. */
export type Experiments_Config = {
  __typename?: 'experiments_config';
  /** An array relationship */
  config_cohort_users: Array<Experiments_Cohort>;
  /** An aggregate relationship */
  config_cohort_users_aggregate: Experiments_Cohort_Aggregate;
  created_at: Scalars['timestamptz'];
  experiment: Experiments_Enum;
  metadata?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  parent_experiment: Experiments;
  rollout_percentage: Scalars['Int'];
  status: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Configuration settings for growth experiments. */
export type Experiments_ConfigConfig_Cohort_UsersArgs = {
  distinct_on?: Maybe<Array<Experiments_Cohort_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Cohort_Order_By>>;
  where?: Maybe<Experiments_Cohort_Bool_Exp>;
};

/** Configuration settings for growth experiments. */
export type Experiments_ConfigConfig_Cohort_Users_AggregateArgs = {
  distinct_on?: Maybe<Array<Experiments_Cohort_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Cohort_Order_By>>;
  where?: Maybe<Experiments_Cohort_Bool_Exp>;
};

/** Configuration settings for growth experiments. */
export type Experiments_ConfigMetadataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "experiments_config" */
export type Experiments_Config_Aggregate = {
  __typename?: 'experiments_config_aggregate';
  aggregate?: Maybe<Experiments_Config_Aggregate_Fields>;
  nodes: Array<Experiments_Config>;
};

/** aggregate fields of "experiments_config" */
export type Experiments_Config_Aggregate_Fields = {
  __typename?: 'experiments_config_aggregate_fields';
  avg?: Maybe<Experiments_Config_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Experiments_Config_Max_Fields>;
  min?: Maybe<Experiments_Config_Min_Fields>;
  stddev?: Maybe<Experiments_Config_Stddev_Fields>;
  stddev_pop?: Maybe<Experiments_Config_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Experiments_Config_Stddev_Samp_Fields>;
  sum?: Maybe<Experiments_Config_Sum_Fields>;
  var_pop?: Maybe<Experiments_Config_Var_Pop_Fields>;
  var_samp?: Maybe<Experiments_Config_Var_Samp_Fields>;
  variance?: Maybe<Experiments_Config_Variance_Fields>;
};

/** aggregate fields of "experiments_config" */
export type Experiments_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Experiments_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Experiments_Config_Append_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Experiments_Config_Avg_Fields = {
  __typename?: 'experiments_config_avg_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "experiments_config". All fields are combined with a logical 'AND'. */
export type Experiments_Config_Bool_Exp = {
  _and?: Maybe<Array<Experiments_Config_Bool_Exp>>;
  _not?: Maybe<Experiments_Config_Bool_Exp>;
  _or?: Maybe<Array<Experiments_Config_Bool_Exp>>;
  config_cohort_users?: Maybe<Experiments_Cohort_Bool_Exp>;
  config_cohort_users_aggregate?: Maybe<Experiments_Cohort_Aggregate_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  experiment?: Maybe<Experiments_Enum_Comparison_Exp>;
  metadata?: Maybe<Jsonb_Comparison_Exp>;
  parent_experiment?: Maybe<Experiments_Bool_Exp>;
  rollout_percentage?: Maybe<Int_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "experiments_config" */
export enum Experiments_Config_Constraint {
  /** unique or primary key constraint on columns "experiment" */
  ExperimentsConfigPkey = 'experiments_config_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Experiments_Config_Delete_At_Path_Input = {
  metadata?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Experiments_Config_Delete_Elem_Input = {
  metadata?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Experiments_Config_Delete_Key_Input = {
  metadata?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "experiments_config" */
export type Experiments_Config_Inc_Input = {
  rollout_percentage?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "experiments_config" */
export type Experiments_Config_Insert_Input = {
  config_cohort_users?: Maybe<Experiments_Cohort_Arr_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  experiment?: Maybe<Experiments_Enum>;
  metadata?: Maybe<Scalars['jsonb']>;
  parent_experiment?: Maybe<Experiments_Obj_Rel_Insert_Input>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Experiments_Config_Max_Fields = {
  __typename?: 'experiments_config_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Experiments_Config_Min_Fields = {
  __typename?: 'experiments_config_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "experiments_config" */
export type Experiments_Config_Mutation_Response = {
  __typename?: 'experiments_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Experiments_Config>;
};

/** on_conflict condition type for table "experiments_config" */
export type Experiments_Config_On_Conflict = {
  constraint: Experiments_Config_Constraint;
  update_columns?: Array<Experiments_Config_Update_Column>;
  where?: Maybe<Experiments_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "experiments_config". */
export type Experiments_Config_Order_By = {
  config_cohort_users_aggregate?: Maybe<Experiments_Cohort_Aggregate_Order_By>;
  created_at?: Maybe<Order_By>;
  experiment?: Maybe<Order_By>;
  metadata?: Maybe<Order_By>;
  parent_experiment?: Maybe<Experiments_Order_By>;
  rollout_percentage?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: experiments_config */
export type Experiments_Config_Pk_Columns_Input = {
  experiment: Experiments_Enum;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Experiments_Config_Prepend_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "experiments_config" */
export enum Experiments_Config_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Experiment = 'experiment',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  RolloutPercentage = 'rollout_percentage',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "experiments_config" */
export type Experiments_Config_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  experiment?: Maybe<Experiments_Enum>;
  metadata?: Maybe<Scalars['jsonb']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Experiments_Config_Stddev_Fields = {
  __typename?: 'experiments_config_stddev_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Experiments_Config_Stddev_Pop_Fields = {
  __typename?: 'experiments_config_stddev_pop_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Experiments_Config_Stddev_Samp_Fields = {
  __typename?: 'experiments_config_stddev_samp_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "experiments_config" */
export type Experiments_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Experiments_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Experiments_Config_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  experiment?: Maybe<Experiments_Enum>;
  metadata?: Maybe<Scalars['jsonb']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Experiments_Config_Sum_Fields = {
  __typename?: 'experiments_config_sum_fields';
  rollout_percentage?: Maybe<Scalars['Int']>;
};

/** update columns of table "experiments_config" */
export enum Experiments_Config_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Experiment = 'experiment',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  RolloutPercentage = 'rollout_percentage',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Experiments_Config_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Experiments_Config_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Experiments_Config_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Experiments_Config_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Experiments_Config_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Experiments_Config_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Experiments_Config_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Experiments_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Experiments_Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Experiments_Config_Var_Pop_Fields = {
  __typename?: 'experiments_config_var_pop_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Experiments_Config_Var_Samp_Fields = {
  __typename?: 'experiments_config_var_samp_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Experiments_Config_Variance_Fields = {
  __typename?: 'experiments_config_variance_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** unique or primary key constraints on table "experiments" */
export enum Experiments_Constraint {
  /** unique or primary key constraint on columns "experiment" */
  ExperimentsPkey = 'experiments_pkey',
}

export enum Experiments_Enum {
  /** Console Onboarding Wizard v1 for new users */
  ConsoleOnboardingWizardV1 = 'console_onboarding_wizard_v1',
}

/** Boolean expression to compare columns of type "experiments_enum". All fields are combined with logical 'AND'. */
export type Experiments_Enum_Comparison_Exp = {
  _eq?: Maybe<Experiments_Enum>;
  _in?: Maybe<Array<Experiments_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Experiments_Enum>;
  _nin?: Maybe<Array<Experiments_Enum>>;
};

/** input type for inserting data into table "experiments" */
export type Experiments_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  experiment?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Experiments_Max_Fields = {
  __typename?: 'experiments_max_fields';
  comment?: Maybe<Scalars['String']>;
  experiment?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Experiments_Min_Fields = {
  __typename?: 'experiments_min_fields';
  comment?: Maybe<Scalars['String']>;
  experiment?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "experiments" */
export type Experiments_Mutation_Response = {
  __typename?: 'experiments_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Experiments>;
};

/** input type for inserting object relation for remote table "experiments" */
export type Experiments_Obj_Rel_Insert_Input = {
  data: Experiments_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Experiments_On_Conflict>;
};

/** on_conflict condition type for table "experiments" */
export type Experiments_On_Conflict = {
  constraint: Experiments_Constraint;
  update_columns?: Array<Experiments_Update_Column>;
  where?: Maybe<Experiments_Bool_Exp>;
};

/** Ordering options when selecting data from "experiments". */
export type Experiments_Order_By = {
  comment?: Maybe<Order_By>;
  experiment?: Maybe<Order_By>;
};

/** primary key columns input for table: experiments */
export type Experiments_Pk_Columns_Input = {
  experiment: Scalars['String'];
};

/** select columns of table "experiments" */
export enum Experiments_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Experiment = 'experiment',
}

/** input type for updating data in table "experiments" */
export type Experiments_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  experiment?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "experiments" */
export type Experiments_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Experiments_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Experiments_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  experiment?: Maybe<Scalars['String']>;
};

/** update columns of table "experiments" */
export enum Experiments_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Experiment = 'experiment',
}

export type Experiments_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Experiments_Set_Input>;
  /** filter the rows which have to be updated */
  where: Experiments_Bool_Exp;
};

export type ExperimentsCohortActivityPayload = {
  error_code?: Maybe<Scalars['String']>;
  kind: Scalars['String'];
  project_id: Scalars['uuid'];
};

/** Enums representing features for access control */
export type Feature = {
  __typename?: 'feature';
  description: Scalars['String'];
  name: Scalars['String'];
};

/** Table defining what features a user has access to */
export type Feature_Access = {
  __typename?: 'feature_access';
  email: Scalars['String'];
  feature: Feature_Enum;
  granted_at: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
};

/** aggregated selection of "feature_access" */
export type Feature_Access_Aggregate = {
  __typename?: 'feature_access_aggregate';
  aggregate?: Maybe<Feature_Access_Aggregate_Fields>;
  nodes: Array<Feature_Access>;
};

export type Feature_Access_Aggregate_Bool_Exp = {
  count?: Maybe<Feature_Access_Aggregate_Bool_Exp_Count>;
};

export type Feature_Access_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Feature_Access_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Feature_Access_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "feature_access" */
export type Feature_Access_Aggregate_Fields = {
  __typename?: 'feature_access_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Feature_Access_Max_Fields>;
  min?: Maybe<Feature_Access_Min_Fields>;
};

/** aggregate fields of "feature_access" */
export type Feature_Access_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Feature_Access_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "feature_access" */
export type Feature_Access_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Feature_Access_Max_Order_By>;
  min?: Maybe<Feature_Access_Min_Order_By>;
};

/** input type for inserting array relation for remote table "feature_access" */
export type Feature_Access_Arr_Rel_Insert_Input = {
  data: Array<Feature_Access_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Feature_Access_On_Conflict>;
};

/** Boolean expression to filter rows from the table "feature_access". All fields are combined with a logical 'AND'. */
export type Feature_Access_Bool_Exp = {
  _and?: Maybe<Array<Feature_Access_Bool_Exp>>;
  _not?: Maybe<Feature_Access_Bool_Exp>;
  _or?: Maybe<Array<Feature_Access_Bool_Exp>>;
  email?: Maybe<String_Comparison_Exp>;
  feature?: Maybe<Feature_Enum_Comparison_Exp>;
  granted_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
};

/** unique or primary key constraints on table "feature_access" */
export enum Feature_Access_Constraint {
  /** unique or primary key constraint on columns "email", "feature" */
  FeatureAccessPkey = 'feature_access_pkey',
}

/** input type for inserting data into table "feature_access" */
export type Feature_Access_Insert_Input = {
  email?: Maybe<Scalars['String']>;
  feature?: Maybe<Feature_Enum>;
  granted_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Feature_Access_Max_Fields = {
  __typename?: 'feature_access_max_fields';
  email?: Maybe<Scalars['String']>;
  granted_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "feature_access" */
export type Feature_Access_Max_Order_By = {
  email?: Maybe<Order_By>;
  granted_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Feature_Access_Min_Fields = {
  __typename?: 'feature_access_min_fields';
  email?: Maybe<Scalars['String']>;
  granted_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "feature_access" */
export type Feature_Access_Min_Order_By = {
  email?: Maybe<Order_By>;
  granted_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "feature_access" */
export type Feature_Access_Mutation_Response = {
  __typename?: 'feature_access_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Feature_Access>;
};

/** on_conflict condition type for table "feature_access" */
export type Feature_Access_On_Conflict = {
  constraint: Feature_Access_Constraint;
  update_columns?: Array<Feature_Access_Update_Column>;
  where?: Maybe<Feature_Access_Bool_Exp>;
};

/** Ordering options when selecting data from "feature_access". */
export type Feature_Access_Order_By = {
  email?: Maybe<Order_By>;
  feature?: Maybe<Order_By>;
  granted_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
};

/** primary key columns input for table: feature_access */
export type Feature_Access_Pk_Columns_Input = {
  email: Scalars['String'];
  feature: Feature_Enum;
};

/** select columns of table "feature_access" */
export enum Feature_Access_Select_Column {
  /** column name */
  Email = 'email',
  /** column name */
  Feature = 'feature',
  /** column name */
  GrantedAt = 'granted_at',
}

/** input type for updating data in table "feature_access" */
export type Feature_Access_Set_Input = {
  email?: Maybe<Scalars['String']>;
  feature?: Maybe<Feature_Enum>;
  granted_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "feature_access" */
export type Feature_Access_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Feature_Access_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Feature_Access_Stream_Cursor_Value_Input = {
  email?: Maybe<Scalars['String']>;
  feature?: Maybe<Feature_Enum>;
  granted_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "feature_access" */
export enum Feature_Access_Update_Column {
  /** column name */
  Email = 'email',
  /** column name */
  Feature = 'feature',
  /** column name */
  GrantedAt = 'granted_at',
}

export type Feature_Access_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Feature_Access_Set_Input>;
  /** filter the rows which have to be updated */
  where: Feature_Access_Bool_Exp;
};

/** aggregated selection of "feature" */
export type Feature_Aggregate = {
  __typename?: 'feature_aggregate';
  aggregate?: Maybe<Feature_Aggregate_Fields>;
  nodes: Array<Feature>;
};

/** aggregate fields of "feature" */
export type Feature_Aggregate_Fields = {
  __typename?: 'feature_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Feature_Max_Fields>;
  min?: Maybe<Feature_Min_Fields>;
};

/** aggregate fields of "feature" */
export type Feature_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Feature_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "feature". All fields are combined with a logical 'AND'. */
export type Feature_Bool_Exp = {
  _and?: Maybe<Array<Feature_Bool_Exp>>;
  _not?: Maybe<Feature_Bool_Exp>;
  _or?: Maybe<Array<Feature_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
};

/** Configuration settings for feature */
export type Feature_Config = {
  __typename?: 'feature_config';
  created_at: Scalars['timestamptz'];
  feature: Feature_Enum;
  metadata?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  parent_feature: Feature;
  rollout_percentage: Scalars['Int'];
  status: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Configuration settings for feature */
export type Feature_ConfigMetadataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "feature_config" */
export type Feature_Config_Aggregate = {
  __typename?: 'feature_config_aggregate';
  aggregate?: Maybe<Feature_Config_Aggregate_Fields>;
  nodes: Array<Feature_Config>;
};

/** aggregate fields of "feature_config" */
export type Feature_Config_Aggregate_Fields = {
  __typename?: 'feature_config_aggregate_fields';
  avg?: Maybe<Feature_Config_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Feature_Config_Max_Fields>;
  min?: Maybe<Feature_Config_Min_Fields>;
  stddev?: Maybe<Feature_Config_Stddev_Fields>;
  stddev_pop?: Maybe<Feature_Config_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Feature_Config_Stddev_Samp_Fields>;
  sum?: Maybe<Feature_Config_Sum_Fields>;
  var_pop?: Maybe<Feature_Config_Var_Pop_Fields>;
  var_samp?: Maybe<Feature_Config_Var_Samp_Fields>;
  variance?: Maybe<Feature_Config_Variance_Fields>;
};

/** aggregate fields of "feature_config" */
export type Feature_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Feature_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Feature_Config_Append_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Feature_Config_Avg_Fields = {
  __typename?: 'feature_config_avg_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "feature_config". All fields are combined with a logical 'AND'. */
export type Feature_Config_Bool_Exp = {
  _and?: Maybe<Array<Feature_Config_Bool_Exp>>;
  _not?: Maybe<Feature_Config_Bool_Exp>;
  _or?: Maybe<Array<Feature_Config_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  feature?: Maybe<Feature_Enum_Comparison_Exp>;
  metadata?: Maybe<Jsonb_Comparison_Exp>;
  parent_feature?: Maybe<Feature_Bool_Exp>;
  rollout_percentage?: Maybe<Int_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "feature_config" */
export enum Feature_Config_Constraint {
  /** unique or primary key constraint on columns "feature" */
  FeatureConfigPkey = 'feature_config_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Feature_Config_Delete_At_Path_Input = {
  metadata?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Feature_Config_Delete_Elem_Input = {
  metadata?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Feature_Config_Delete_Key_Input = {
  metadata?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "feature_config" */
export type Feature_Config_Inc_Input = {
  rollout_percentage?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "feature_config" */
export type Feature_Config_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  feature?: Maybe<Feature_Enum>;
  metadata?: Maybe<Scalars['jsonb']>;
  parent_feature?: Maybe<Feature_Obj_Rel_Insert_Input>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Feature_Config_Max_Fields = {
  __typename?: 'feature_config_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Feature_Config_Min_Fields = {
  __typename?: 'feature_config_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "feature_config" */
export type Feature_Config_Mutation_Response = {
  __typename?: 'feature_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Feature_Config>;
};

/** on_conflict condition type for table "feature_config" */
export type Feature_Config_On_Conflict = {
  constraint: Feature_Config_Constraint;
  update_columns?: Array<Feature_Config_Update_Column>;
  where?: Maybe<Feature_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "feature_config". */
export type Feature_Config_Order_By = {
  created_at?: Maybe<Order_By>;
  feature?: Maybe<Order_By>;
  metadata?: Maybe<Order_By>;
  parent_feature?: Maybe<Feature_Order_By>;
  rollout_percentage?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: feature_config */
export type Feature_Config_Pk_Columns_Input = {
  feature: Feature_Enum;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Feature_Config_Prepend_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "feature_config" */
export enum Feature_Config_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Feature = 'feature',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  RolloutPercentage = 'rollout_percentage',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "feature_config" */
export type Feature_Config_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  feature?: Maybe<Feature_Enum>;
  metadata?: Maybe<Scalars['jsonb']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Feature_Config_Stddev_Fields = {
  __typename?: 'feature_config_stddev_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Feature_Config_Stddev_Pop_Fields = {
  __typename?: 'feature_config_stddev_pop_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Feature_Config_Stddev_Samp_Fields = {
  __typename?: 'feature_config_stddev_samp_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "feature_config" */
export type Feature_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Feature_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Feature_Config_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  feature?: Maybe<Feature_Enum>;
  metadata?: Maybe<Scalars['jsonb']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Feature_Config_Sum_Fields = {
  __typename?: 'feature_config_sum_fields';
  rollout_percentage?: Maybe<Scalars['Int']>;
};

/** update columns of table "feature_config" */
export enum Feature_Config_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Feature = 'feature',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  RolloutPercentage = 'rollout_percentage',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Feature_Config_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Feature_Config_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Feature_Config_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Feature_Config_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Feature_Config_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Feature_Config_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Feature_Config_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Feature_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Feature_Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Feature_Config_Var_Pop_Fields = {
  __typename?: 'feature_config_var_pop_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Feature_Config_Var_Samp_Fields = {
  __typename?: 'feature_config_var_samp_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Feature_Config_Variance_Fields = {
  __typename?: 'feature_config_variance_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** unique or primary key constraints on table "feature" */
export enum Feature_Constraint {
  /** unique or primary key constraint on columns "name" */
  FeaturePkey = 'feature_pkey',
}

export enum Feature_Enum {
  /** Collect additional billing information to enable tax calculation */
  Avalara = 'Avalara',
  /** Allows user to create Cloud Dedicated VPC */
  CloudDedicatedVpc = 'CloudDedicatedVPC',
  /** Allows user to create projects with plans: cloud_free_v2, cloud_shared */
  CloudNewPlans = 'CloudNewPlans',
  /** Allows user to create projects with plans: cloud_free, cloud_payg */
  CloudUser = 'CloudUser',
  /** Console Onboarding Wizard for new users */
  ConsoleOnboardingWizard = 'ConsoleOnboardingWizard',
  /** Allows user to configure Datadog api key per project */
  DatadogIntegration = 'DatadogIntegration',
  /** Allows users to create projects on Google Cloud Platform */
  GcpSupport = 'GCPSupport',
  /** Allows user to automatically deploy metadata/migrations to the project from github repo */
  GithubIntegration = 'GithubIntegration',
  /** Allows users to have access to GraphQL Schema Registry */
  GraphQlSchemaRegistry = 'GraphQLSchemaRegistry',
  /** Neon DB Integration through Hasura Console */
  NeonDatabaseIntegration = 'NeonDatabaseIntegration',
  /** Allows user to create Hasura Pro Project */
  ProUser = 'ProUser',
  /** Allows user to configure schema/table access control */
  SchemaTableAcl = 'SchemaTableACL',
  /** Allows user to update Hasura Project to v2.0 */
  V1V2Migration = 'V1V2Migration',
}

/** Boolean expression to compare columns of type "feature_enum". All fields are combined with logical 'AND'. */
export type Feature_Enum_Comparison_Exp = {
  _eq?: Maybe<Feature_Enum>;
  _in?: Maybe<Array<Feature_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Feature_Enum>;
  _nin?: Maybe<Array<Feature_Enum>>;
};

/** input type for inserting data into table "feature" */
export type Feature_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Feature_Max_Fields = {
  __typename?: 'feature_max_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Feature_Min_Fields = {
  __typename?: 'feature_min_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "feature" */
export type Feature_Mutation_Response = {
  __typename?: 'feature_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Feature>;
};

/** input type for inserting object relation for remote table "feature" */
export type Feature_Obj_Rel_Insert_Input = {
  data: Feature_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Feature_On_Conflict>;
};

/** on_conflict condition type for table "feature" */
export type Feature_On_Conflict = {
  constraint: Feature_Constraint;
  update_columns?: Array<Feature_Update_Column>;
  where?: Maybe<Feature_Bool_Exp>;
};

/** Ordering options when selecting data from "feature". */
export type Feature_Order_By = {
  description?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** primary key columns input for table: feature */
export type Feature_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "feature" */
export enum Feature_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

/** input type for updating data in table "feature" */
export type Feature_Set_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "feature" */
export type Feature_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Feature_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Feature_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** update columns of table "feature" */
export enum Feature_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

export type Feature_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Feature_Set_Input>;
  /** filter the rows which have to be updated */
  where: Feature_Bool_Exp;
};

export type FeatureRequest = {
  details: Scalars['jsonb'];
  type: Scalars['String'];
};

export type FeatureRequestResponse = {
  __typename?: 'FeatureRequestResponse';
  status: Scalars['String'];
};

/** Boolean expression to compare columns of type "float8". All fields are combined with logical 'AND'. */
export type Float8_Comparison_Exp = {
  _eq?: Maybe<Scalars['float8']>;
  _gt?: Maybe<Scalars['float8']>;
  _gte?: Maybe<Scalars['float8']>;
  _in?: Maybe<Array<Scalars['float8']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['float8']>;
  _lte?: Maybe<Scalars['float8']>;
  _neq?: Maybe<Scalars['float8']>;
  _nin?: Maybe<Array<Scalars['float8']>>;
};

/** Represents ami's generated for gateway service */
export type Gateway_Ami = {
  __typename?: 'gateway_ami';
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  commit_hash: Scalars['String'];
  created_at: Scalars['timestamptz'];
  region: Scalars['String'];
  remarks: Scalars['String'];
};

/** aggregated selection of "gateway_ami" */
export type Gateway_Ami_Aggregate = {
  __typename?: 'gateway_ami_aggregate';
  aggregate?: Maybe<Gateway_Ami_Aggregate_Fields>;
  nodes: Array<Gateway_Ami>;
};

/** aggregate fields of "gateway_ami" */
export type Gateway_Ami_Aggregate_Fields = {
  __typename?: 'gateway_ami_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Gateway_Ami_Max_Fields>;
  min?: Maybe<Gateway_Ami_Min_Fields>;
};

/** aggregate fields of "gateway_ami" */
export type Gateway_Ami_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Gateway_Ami_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "gateway_ami". All fields are combined with a logical 'AND'. */
export type Gateway_Ami_Bool_Exp = {
  _and?: Maybe<Array<Gateway_Ami_Bool_Exp>>;
  _not?: Maybe<Gateway_Ami_Bool_Exp>;
  _or?: Maybe<Array<Gateway_Ami_Bool_Exp>>;
  ami_id?: Maybe<String_Comparison_Exp>;
  cloud?: Maybe<String_Comparison_Exp>;
  commit_hash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  remarks?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "gateway_ami" */
export enum Gateway_Ami_Constraint {
  /** unique or primary key constraint on columns "ami_id", "cloud", "region" */
  GatewayAmiPkey = 'gateway_ami_pkey',
}

/** input type for inserting data into table "gateway_ami" */
export type Gateway_Ami_Insert_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Gateway_Ami_Max_Fields = {
  __typename?: 'gateway_ami_max_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Gateway_Ami_Min_Fields = {
  __typename?: 'gateway_ami_min_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "gateway_ami" */
export type Gateway_Ami_Mutation_Response = {
  __typename?: 'gateway_ami_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Gateway_Ami>;
};

/** on_conflict condition type for table "gateway_ami" */
export type Gateway_Ami_On_Conflict = {
  constraint: Gateway_Ami_Constraint;
  update_columns?: Array<Gateway_Ami_Update_Column>;
  where?: Maybe<Gateway_Ami_Bool_Exp>;
};

/** Ordering options when selecting data from "gateway_ami". */
export type Gateway_Ami_Order_By = {
  ami_id?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  commit_hash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  remarks?: Maybe<Order_By>;
};

/** primary key columns input for table: gateway_ami */
export type Gateway_Ami_Pk_Columns_Input = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

/** select columns of table "gateway_ami" */
export enum Gateway_Ami_Select_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CommitHash = 'commit_hash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Region = 'region',
  /** column name */
  Remarks = 'remarks',
}

/** input type for updating data in table "gateway_ami" */
export type Gateway_Ami_Set_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "gateway_ami" */
export type Gateway_Ami_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Gateway_Ami_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Gateway_Ami_Stream_Cursor_Value_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** update columns of table "gateway_ami" */
export enum Gateway_Ami_Update_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CommitHash = 'commit_hash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Region = 'region',
  /** column name */
  Remarks = 'remarks',
}

export type Gateway_Ami_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Gateway_Ami_Set_Input>;
  /** filter the rows which have to be updated */
  where: Gateway_Ami_Bool_Exp;
};

/** Set of gateway workers in a specific region */
export type Gateway_Cluster = {
  __typename?: 'gateway_cluster';
  ami_id?: Maybe<Scalars['String']>;
  cloud: Scalars['String'];
  created_at: Scalars['timestamptz'];
  disable_infra_auto_apply: Scalars['Boolean'];
  fqdn?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region: Scalars['String'];
  /** An object relationship */
  region_info?: Maybe<Region>;
  slug: Scalars['String'];
  status: Scalars['String'];
  /** An array relationship */
  workers: Array<Gateway_Worker>;
  /** An aggregate relationship */
  workers_aggregate: Gateway_Worker_Aggregate;
};

/** Set of gateway workers in a specific region */
export type Gateway_ClusterInput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Set of gateway workers in a specific region */
export type Gateway_ClusterOutput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Set of gateway workers in a specific region */
export type Gateway_ClusterWorkersArgs = {
  distinct_on?: Maybe<Array<Gateway_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Worker_Order_By>>;
  where?: Maybe<Gateway_Worker_Bool_Exp>;
};

/** Set of gateway workers in a specific region */
export type Gateway_ClusterWorkers_AggregateArgs = {
  distinct_on?: Maybe<Array<Gateway_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Worker_Order_By>>;
  where?: Maybe<Gateway_Worker_Bool_Exp>;
};

/** aggregated selection of "gateway_cluster" */
export type Gateway_Cluster_Aggregate = {
  __typename?: 'gateway_cluster_aggregate';
  aggregate?: Maybe<Gateway_Cluster_Aggregate_Fields>;
  nodes: Array<Gateway_Cluster>;
};

/** aggregate fields of "gateway_cluster" */
export type Gateway_Cluster_Aggregate_Fields = {
  __typename?: 'gateway_cluster_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Gateway_Cluster_Max_Fields>;
  min?: Maybe<Gateway_Cluster_Min_Fields>;
};

/** aggregate fields of "gateway_cluster" */
export type Gateway_Cluster_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Gateway_Cluster_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Gateway_Cluster_Append_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "gateway_cluster". All fields are combined with a logical 'AND'. */
export type Gateway_Cluster_Bool_Exp = {
  _and?: Maybe<Array<Gateway_Cluster_Bool_Exp>>;
  _not?: Maybe<Gateway_Cluster_Bool_Exp>;
  _or?: Maybe<Array<Gateway_Cluster_Bool_Exp>>;
  ami_id?: Maybe<String_Comparison_Exp>;
  cloud?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  disable_infra_auto_apply?: Maybe<Boolean_Comparison_Exp>;
  fqdn?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  infra_status?: Maybe<Infra_Status_Enum_Comparison_Exp>;
  input_variables?: Maybe<Jsonb_Comparison_Exp>;
  output_variables?: Maybe<Jsonb_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  region_info?: Maybe<Region_Bool_Exp>;
  slug?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  workers?: Maybe<Gateway_Worker_Bool_Exp>;
  workers_aggregate?: Maybe<Gateway_Worker_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "gateway_cluster" */
export enum Gateway_Cluster_Constraint {
  /** unique or primary key constraint on columns "id" */
  GatewayClusterPkey = 'gateway_cluster_pkey',
  /** unique or primary key constraint on columns "slug" */
  GatewayClusterSlugKey = 'gateway_cluster_slug_key',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Gateway_Cluster_Delete_At_Path_Input = {
  input_variables?: Maybe<Array<Scalars['String']>>;
  output_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Gateway_Cluster_Delete_Elem_Input = {
  input_variables?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Gateway_Cluster_Delete_Key_Input = {
  input_variables?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "gateway_cluster" */
export type Gateway_Cluster_Insert_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  region_info?: Maybe<Region_Obj_Rel_Insert_Input>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  workers?: Maybe<Gateway_Worker_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Gateway_Cluster_Max_Fields = {
  __typename?: 'gateway_cluster_max_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Gateway_Cluster_Min_Fields = {
  __typename?: 'gateway_cluster_min_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "gateway_cluster" */
export type Gateway_Cluster_Mutation_Response = {
  __typename?: 'gateway_cluster_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Gateway_Cluster>;
};

/** input type for inserting object relation for remote table "gateway_cluster" */
export type Gateway_Cluster_Obj_Rel_Insert_Input = {
  data: Gateway_Cluster_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Gateway_Cluster_On_Conflict>;
};

/** on_conflict condition type for table "gateway_cluster" */
export type Gateway_Cluster_On_Conflict = {
  constraint: Gateway_Cluster_Constraint;
  update_columns?: Array<Gateway_Cluster_Update_Column>;
  where?: Maybe<Gateway_Cluster_Bool_Exp>;
};

/** Ordering options when selecting data from "gateway_cluster". */
export type Gateway_Cluster_Order_By = {
  ami_id?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  disable_infra_auto_apply?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  infra_status?: Maybe<Order_By>;
  input_variables?: Maybe<Order_By>;
  output_variables?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  region_info?: Maybe<Region_Order_By>;
  slug?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  workers_aggregate?: Maybe<Gateway_Worker_Aggregate_Order_By>;
};

/** primary key columns input for table: gateway_cluster */
export type Gateway_Cluster_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Gateway_Cluster_Prepend_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "gateway_cluster" */
export enum Gateway_Cluster_Select_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
}

/** input type for updating data in table "gateway_cluster" */
export type Gateway_Cluster_Set_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "gateway_cluster" */
export type Gateway_Cluster_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Gateway_Cluster_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Gateway_Cluster_Stream_Cursor_Value_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** columns and relationships of "gateway_cluster_tenants" */
export type Gateway_Cluster_Tenants = {
  __typename?: 'gateway_cluster_tenants';
  cert?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  gateway_cluster_id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  workers?: Maybe<Scalars['_json']>;
};

/** aggregated selection of "gateway_cluster_tenants" */
export type Gateway_Cluster_Tenants_Aggregate = {
  __typename?: 'gateway_cluster_tenants_aggregate';
  aggregate?: Maybe<Gateway_Cluster_Tenants_Aggregate_Fields>;
  nodes: Array<Gateway_Cluster_Tenants>;
};

/** aggregate fields of "gateway_cluster_tenants" */
export type Gateway_Cluster_Tenants_Aggregate_Fields = {
  __typename?: 'gateway_cluster_tenants_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Gateway_Cluster_Tenants_Max_Fields>;
  min?: Maybe<Gateway_Cluster_Tenants_Min_Fields>;
};

/** aggregate fields of "gateway_cluster_tenants" */
export type Gateway_Cluster_Tenants_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Gateway_Cluster_Tenants_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "gateway_cluster_tenants". All fields are combined with a logical 'AND'. */
export type Gateway_Cluster_Tenants_Bool_Exp = {
  _and?: Maybe<Array<Gateway_Cluster_Tenants_Bool_Exp>>;
  _not?: Maybe<Gateway_Cluster_Tenants_Bool_Exp>;
  _or?: Maybe<Array<Gateway_Cluster_Tenants_Bool_Exp>>;
  cert?: Maybe<String_Comparison_Exp>;
  fqdn?: Maybe<String_Comparison_Exp>;
  gateway_cluster_id?: Maybe<Uuid_Comparison_Exp>;
  plan_name?: Maybe<String_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  project_name?: Maybe<String_Comparison_Exp>;
  tenant_id?: Maybe<Uuid_Comparison_Exp>;
  workers?: Maybe<_Json_Comparison_Exp>;
};

/** aggregate max on columns */
export type Gateway_Cluster_Tenants_Max_Fields = {
  __typename?: 'gateway_cluster_tenants_max_fields';
  cert?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  gateway_cluster_id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Gateway_Cluster_Tenants_Min_Fields = {
  __typename?: 'gateway_cluster_tenants_min_fields';
  cert?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  gateway_cluster_id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
};

/** Ordering options when selecting data from "gateway_cluster_tenants". */
export type Gateway_Cluster_Tenants_Order_By = {
  cert?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  gateway_cluster_id?: Maybe<Order_By>;
  plan_name?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  project_name?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  workers?: Maybe<Order_By>;
};

/** select columns of table "gateway_cluster_tenants" */
export enum Gateway_Cluster_Tenants_Select_Column {
  /** column name */
  Cert = 'cert',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  GatewayClusterId = 'gateway_cluster_id',
  /** column name */
  PlanName = 'plan_name',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ProjectName = 'project_name',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  Workers = 'workers',
}

/** Streaming cursor of the table "gateway_cluster_tenants" */
export type Gateway_Cluster_Tenants_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Gateway_Cluster_Tenants_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Gateway_Cluster_Tenants_Stream_Cursor_Value_Input = {
  cert?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  gateway_cluster_id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  workers?: Maybe<Scalars['_json']>;
};

/** update columns of table "gateway_cluster" */
export enum Gateway_Cluster_Update_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
}

export type Gateway_Cluster_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Gateway_Cluster_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Gateway_Cluster_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Gateway_Cluster_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Gateway_Cluster_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Gateway_Cluster_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Gateway_Cluster_Set_Input>;
  /** filter the rows which have to be updated */
  where: Gateway_Cluster_Bool_Exp;
};

/** Gateway worker in a region that routes traffic to multiple Hasura Clusters */
export type Gateway_Worker = {
  __typename?: 'gateway_worker';
  cloud: Scalars['String'];
  /** An object relationship */
  cluster: Gateway_Cluster;
  cluster_id: Scalars['uuid'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  region: Scalars['String'];
  /** An object relationship */
  region_info?: Maybe<Region>;
  slug: Scalars['String'];
  status: Scalars['String'];
  zone: Scalars['String'];
};

/** aggregated selection of "gateway_worker" */
export type Gateway_Worker_Aggregate = {
  __typename?: 'gateway_worker_aggregate';
  aggregate?: Maybe<Gateway_Worker_Aggregate_Fields>;
  nodes: Array<Gateway_Worker>;
};

export type Gateway_Worker_Aggregate_Bool_Exp = {
  count?: Maybe<Gateway_Worker_Aggregate_Bool_Exp_Count>;
};

export type Gateway_Worker_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Gateway_Worker_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Gateway_Worker_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "gateway_worker" */
export type Gateway_Worker_Aggregate_Fields = {
  __typename?: 'gateway_worker_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Gateway_Worker_Max_Fields>;
  min?: Maybe<Gateway_Worker_Min_Fields>;
};

/** aggregate fields of "gateway_worker" */
export type Gateway_Worker_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Gateway_Worker_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "gateway_worker" */
export type Gateway_Worker_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Gateway_Worker_Max_Order_By>;
  min?: Maybe<Gateway_Worker_Min_Order_By>;
};

/** input type for inserting array relation for remote table "gateway_worker" */
export type Gateway_Worker_Arr_Rel_Insert_Input = {
  data: Array<Gateway_Worker_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Gateway_Worker_On_Conflict>;
};

/** Boolean expression to filter rows from the table "gateway_worker". All fields are combined with a logical 'AND'. */
export type Gateway_Worker_Bool_Exp = {
  _and?: Maybe<Array<Gateway_Worker_Bool_Exp>>;
  _not?: Maybe<Gateway_Worker_Bool_Exp>;
  _or?: Maybe<Array<Gateway_Worker_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  cluster?: Maybe<Gateway_Cluster_Bool_Exp>;
  cluster_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  region_info?: Maybe<Region_Bool_Exp>;
  slug?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  zone?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "gateway_worker" */
export enum Gateway_Worker_Constraint {
  /** unique or primary key constraint on columns "id" */
  GatewayWorkerPkey = 'gateway_worker_pkey',
  /** unique or primary key constraint on columns "slug" */
  GatewayWorkerSlugKey = 'gateway_worker_slug_key',
}

/** input type for inserting data into table "gateway_worker" */
export type Gateway_Worker_Insert_Input = {
  cloud?: Maybe<Scalars['String']>;
  cluster?: Maybe<Gateway_Cluster_Obj_Rel_Insert_Input>;
  cluster_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  region_info?: Maybe<Region_Obj_Rel_Insert_Input>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  zone?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Gateway_Worker_Max_Fields = {
  __typename?: 'gateway_worker_max_fields';
  cloud?: Maybe<Scalars['String']>;
  cluster_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  zone?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "gateway_worker" */
export type Gateway_Worker_Max_Order_By = {
  cloud?: Maybe<Order_By>;
  cluster_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  zone?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Gateway_Worker_Min_Fields = {
  __typename?: 'gateway_worker_min_fields';
  cloud?: Maybe<Scalars['String']>;
  cluster_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  zone?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "gateway_worker" */
export type Gateway_Worker_Min_Order_By = {
  cloud?: Maybe<Order_By>;
  cluster_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  zone?: Maybe<Order_By>;
};

/** response of any mutation on the table "gateway_worker" */
export type Gateway_Worker_Mutation_Response = {
  __typename?: 'gateway_worker_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Gateway_Worker>;
};

/** on_conflict condition type for table "gateway_worker" */
export type Gateway_Worker_On_Conflict = {
  constraint: Gateway_Worker_Constraint;
  update_columns?: Array<Gateway_Worker_Update_Column>;
  where?: Maybe<Gateway_Worker_Bool_Exp>;
};

/** Ordering options when selecting data from "gateway_worker". */
export type Gateway_Worker_Order_By = {
  cloud?: Maybe<Order_By>;
  cluster?: Maybe<Gateway_Cluster_Order_By>;
  cluster_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  region_info?: Maybe<Region_Order_By>;
  slug?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  zone?: Maybe<Order_By>;
};

/** primary key columns input for table: gateway_worker */
export type Gateway_Worker_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "gateway_worker" */
export enum Gateway_Worker_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  ClusterId = 'cluster_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  Zone = 'zone',
}

/** input type for updating data in table "gateway_worker" */
export type Gateway_Worker_Set_Input = {
  cloud?: Maybe<Scalars['String']>;
  cluster_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  zone?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "gateway_worker" */
export type Gateway_Worker_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Gateway_Worker_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Gateway_Worker_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  cluster_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  zone?: Maybe<Scalars['String']>;
};

/** update columns of table "gateway_worker" */
export enum Gateway_Worker_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  ClusterId = 'cluster_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  Zone = 'zone',
}

export type Gateway_Worker_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Gateway_Worker_Set_Input>;
  /** filter the rows which have to be updated */
  where: Gateway_Worker_Bool_Exp;
};

export type Get_Aggregated_Cost_For_Project_On_Shared_Plan_Args = {
  fromdate?: Maybe<Scalars['date']>;
  projectid?: Maybe<Scalars['String']>;
  todate?: Maybe<Scalars['date']>;
};

export type GetReportUrlResponse = {
  __typename?: 'GetReportURLResponse';
  url: Scalars['String'];
};

/** Github Integration deploy commits status email types */
export type Github_Email_Type = {
  __typename?: 'github_email_type';
  description: Scalars['String'];
  email_type: Scalars['String'];
};

/** aggregated selection of "github_email_type" */
export type Github_Email_Type_Aggregate = {
  __typename?: 'github_email_type_aggregate';
  aggregate?: Maybe<Github_Email_Type_Aggregate_Fields>;
  nodes: Array<Github_Email_Type>;
};

/** aggregate fields of "github_email_type" */
export type Github_Email_Type_Aggregate_Fields = {
  __typename?: 'github_email_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Github_Email_Type_Max_Fields>;
  min?: Maybe<Github_Email_Type_Min_Fields>;
};

/** aggregate fields of "github_email_type" */
export type Github_Email_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Github_Email_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "github_email_type". All fields are combined with a logical 'AND'. */
export type Github_Email_Type_Bool_Exp = {
  _and?: Maybe<Array<Github_Email_Type_Bool_Exp>>;
  _not?: Maybe<Github_Email_Type_Bool_Exp>;
  _or?: Maybe<Array<Github_Email_Type_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  email_type?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "github_email_type" */
export enum Github_Email_Type_Constraint {
  /** unique or primary key constraint on columns "email_type" */
  GithubEmailTypePkey = 'github_email_type_pkey',
}

export enum Github_Email_Type_Enum {
  /** Both email types to be sent */
  Both = 'both',
  /** Github Integration deployment failure type */
  Failure = 'failure',
  /** No email types to be sent */
  None = 'none',
  /** Github Integration deployment success type */
  Success = 'success',
}

/** Boolean expression to compare columns of type "github_email_type_enum". All fields are combined with logical 'AND'. */
export type Github_Email_Type_Enum_Comparison_Exp = {
  _eq?: Maybe<Github_Email_Type_Enum>;
  _in?: Maybe<Array<Github_Email_Type_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Github_Email_Type_Enum>;
  _nin?: Maybe<Array<Github_Email_Type_Enum>>;
};

/** input type for inserting data into table "github_email_type" */
export type Github_Email_Type_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  email_type?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Github_Email_Type_Max_Fields = {
  __typename?: 'github_email_type_max_fields';
  description?: Maybe<Scalars['String']>;
  email_type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Github_Email_Type_Min_Fields = {
  __typename?: 'github_email_type_min_fields';
  description?: Maybe<Scalars['String']>;
  email_type?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "github_email_type" */
export type Github_Email_Type_Mutation_Response = {
  __typename?: 'github_email_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Github_Email_Type>;
};

/** on_conflict condition type for table "github_email_type" */
export type Github_Email_Type_On_Conflict = {
  constraint: Github_Email_Type_Constraint;
  update_columns?: Array<Github_Email_Type_Update_Column>;
  where?: Maybe<Github_Email_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "github_email_type". */
export type Github_Email_Type_Order_By = {
  description?: Maybe<Order_By>;
  email_type?: Maybe<Order_By>;
};

/** primary key columns input for table: github_email_type */
export type Github_Email_Type_Pk_Columns_Input = {
  email_type: Scalars['String'];
};

/** select columns of table "github_email_type" */
export enum Github_Email_Type_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  EmailType = 'email_type',
}

/** input type for updating data in table "github_email_type" */
export type Github_Email_Type_Set_Input = {
  description?: Maybe<Scalars['String']>;
  email_type?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "github_email_type" */
export type Github_Email_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Github_Email_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Github_Email_Type_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  email_type?: Maybe<Scalars['String']>;
};

/** update columns of table "github_email_type" */
export enum Github_Email_Type_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  EmailType = 'email_type',
}

export type Github_Email_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Github_Email_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Github_Email_Type_Bool_Exp;
};

/** columns and relationships of "github_integration_config" */
export type Github_Integration_Config = {
  __typename?: 'github_integration_config';
  app_installation_id?: Maybe<Scalars['Int']>;
  branch: Scalars['String'];
  created_at: Scalars['timestamptz'];
  directory: Scalars['String'];
  email_status: Github_Email_Type_Enum;
  /** An array relationship */
  github_push_events: Array<Github_Push_Event>;
  /** An aggregate relationship */
  github_push_events_aggregate: Github_Push_Event_Aggregate;
  id: Scalars['uuid'];
  mode: Github_Integration_Mode_Enum;
  organisation: Scalars['String'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  repository: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "github_integration_config" */
export type Github_Integration_ConfigGithub_Push_EventsArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Order_By>>;
  where?: Maybe<Github_Push_Event_Bool_Exp>;
};

/** columns and relationships of "github_integration_config" */
export type Github_Integration_ConfigGithub_Push_Events_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Order_By>>;
  where?: Maybe<Github_Push_Event_Bool_Exp>;
};

/** aggregated selection of "github_integration_config" */
export type Github_Integration_Config_Aggregate = {
  __typename?: 'github_integration_config_aggregate';
  aggregate?: Maybe<Github_Integration_Config_Aggregate_Fields>;
  nodes: Array<Github_Integration_Config>;
};

/** aggregate fields of "github_integration_config" */
export type Github_Integration_Config_Aggregate_Fields = {
  __typename?: 'github_integration_config_aggregate_fields';
  avg?: Maybe<Github_Integration_Config_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Github_Integration_Config_Max_Fields>;
  min?: Maybe<Github_Integration_Config_Min_Fields>;
  stddev?: Maybe<Github_Integration_Config_Stddev_Fields>;
  stddev_pop?: Maybe<Github_Integration_Config_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Github_Integration_Config_Stddev_Samp_Fields>;
  sum?: Maybe<Github_Integration_Config_Sum_Fields>;
  var_pop?: Maybe<Github_Integration_Config_Var_Pop_Fields>;
  var_samp?: Maybe<Github_Integration_Config_Var_Samp_Fields>;
  variance?: Maybe<Github_Integration_Config_Variance_Fields>;
};

/** aggregate fields of "github_integration_config" */
export type Github_Integration_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Github_Integration_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Github_Integration_Config_Avg_Fields = {
  __typename?: 'github_integration_config_avg_fields';
  app_installation_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "github_integration_config". All fields are combined with a logical 'AND'. */
export type Github_Integration_Config_Bool_Exp = {
  _and?: Maybe<Array<Github_Integration_Config_Bool_Exp>>;
  _not?: Maybe<Github_Integration_Config_Bool_Exp>;
  _or?: Maybe<Array<Github_Integration_Config_Bool_Exp>>;
  app_installation_id?: Maybe<Int_Comparison_Exp>;
  branch?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  directory?: Maybe<String_Comparison_Exp>;
  email_status?: Maybe<Github_Email_Type_Enum_Comparison_Exp>;
  github_push_events?: Maybe<Github_Push_Event_Bool_Exp>;
  github_push_events_aggregate?: Maybe<Github_Push_Event_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  mode?: Maybe<Github_Integration_Mode_Enum_Comparison_Exp>;
  organisation?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  repository?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "github_integration_config" */
export enum Github_Integration_Config_Constraint {
  /** unique or primary key constraint on columns "id" */
  GithubIntegrationConfigPkey = 'github_integration_config_pkey',
}

/** input type for incrementing numeric columns in table "github_integration_config" */
export type Github_Integration_Config_Inc_Input = {
  app_installation_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "github_integration_config" */
export type Github_Integration_Config_Insert_Input = {
  app_installation_id?: Maybe<Scalars['Int']>;
  branch?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  directory?: Maybe<Scalars['String']>;
  email_status?: Maybe<Github_Email_Type_Enum>;
  github_push_events?: Maybe<Github_Push_Event_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  mode?: Maybe<Github_Integration_Mode_Enum>;
  organisation?: Maybe<Scalars['String']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  repository?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Github_Integration_Config_Max_Fields = {
  __typename?: 'github_integration_config_max_fields';
  app_installation_id?: Maybe<Scalars['Int']>;
  branch?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  directory?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  organisation?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  repository?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Github_Integration_Config_Min_Fields = {
  __typename?: 'github_integration_config_min_fields';
  app_installation_id?: Maybe<Scalars['Int']>;
  branch?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  directory?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  organisation?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  repository?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "github_integration_config" */
export type Github_Integration_Config_Mutation_Response = {
  __typename?: 'github_integration_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Github_Integration_Config>;
};

/** input type for inserting object relation for remote table "github_integration_config" */
export type Github_Integration_Config_Obj_Rel_Insert_Input = {
  data: Github_Integration_Config_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Github_Integration_Config_On_Conflict>;
};

/** on_conflict condition type for table "github_integration_config" */
export type Github_Integration_Config_On_Conflict = {
  constraint: Github_Integration_Config_Constraint;
  update_columns?: Array<Github_Integration_Config_Update_Column>;
  where?: Maybe<Github_Integration_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "github_integration_config". */
export type Github_Integration_Config_Order_By = {
  app_installation_id?: Maybe<Order_By>;
  branch?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  directory?: Maybe<Order_By>;
  email_status?: Maybe<Order_By>;
  github_push_events_aggregate?: Maybe<Github_Push_Event_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  mode?: Maybe<Order_By>;
  organisation?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  repository?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: github_integration_config */
export type Github_Integration_Config_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "github_integration_config" */
export enum Github_Integration_Config_Select_Column {
  /** column name */
  AppInstallationId = 'app_installation_id',
  /** column name */
  Branch = 'branch',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Directory = 'directory',
  /** column name */
  EmailStatus = 'email_status',
  /** column name */
  Id = 'id',
  /** column name */
  Mode = 'mode',
  /** column name */
  Organisation = 'organisation',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Repository = 'repository',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "github_integration_config" */
export type Github_Integration_Config_Set_Input = {
  app_installation_id?: Maybe<Scalars['Int']>;
  branch?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  directory?: Maybe<Scalars['String']>;
  email_status?: Maybe<Github_Email_Type_Enum>;
  id?: Maybe<Scalars['uuid']>;
  mode?: Maybe<Github_Integration_Mode_Enum>;
  organisation?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  repository?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Github_Integration_Config_Stddev_Fields = {
  __typename?: 'github_integration_config_stddev_fields';
  app_installation_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Github_Integration_Config_Stddev_Pop_Fields = {
  __typename?: 'github_integration_config_stddev_pop_fields';
  app_installation_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Github_Integration_Config_Stddev_Samp_Fields = {
  __typename?: 'github_integration_config_stddev_samp_fields';
  app_installation_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "github_integration_config" */
export type Github_Integration_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Github_Integration_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Github_Integration_Config_Stream_Cursor_Value_Input = {
  app_installation_id?: Maybe<Scalars['Int']>;
  branch?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  directory?: Maybe<Scalars['String']>;
  email_status?: Maybe<Github_Email_Type_Enum>;
  id?: Maybe<Scalars['uuid']>;
  mode?: Maybe<Github_Integration_Mode_Enum>;
  organisation?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  repository?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Github_Integration_Config_Sum_Fields = {
  __typename?: 'github_integration_config_sum_fields';
  app_installation_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "github_integration_config" */
export enum Github_Integration_Config_Update_Column {
  /** column name */
  AppInstallationId = 'app_installation_id',
  /** column name */
  Branch = 'branch',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Directory = 'directory',
  /** column name */
  EmailStatus = 'email_status',
  /** column name */
  Id = 'id',
  /** column name */
  Mode = 'mode',
  /** column name */
  Organisation = 'organisation',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Repository = 'repository',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Github_Integration_Config_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Github_Integration_Config_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Github_Integration_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Github_Integration_Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Github_Integration_Config_Var_Pop_Fields = {
  __typename?: 'github_integration_config_var_pop_fields';
  app_installation_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Github_Integration_Config_Var_Samp_Fields = {
  __typename?: 'github_integration_config_var_samp_fields';
  app_installation_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Github_Integration_Config_Variance_Fields = {
  __typename?: 'github_integration_config_variance_fields';
  app_installation_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "github_integration_mode" */
export type Github_Integration_Mode = {
  __typename?: 'github_integration_mode';
  description: Scalars['String'];
  mode: Scalars['String'];
};

/** aggregated selection of "github_integration_mode" */
export type Github_Integration_Mode_Aggregate = {
  __typename?: 'github_integration_mode_aggregate';
  aggregate?: Maybe<Github_Integration_Mode_Aggregate_Fields>;
  nodes: Array<Github_Integration_Mode>;
};

/** aggregate fields of "github_integration_mode" */
export type Github_Integration_Mode_Aggregate_Fields = {
  __typename?: 'github_integration_mode_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Github_Integration_Mode_Max_Fields>;
  min?: Maybe<Github_Integration_Mode_Min_Fields>;
};

/** aggregate fields of "github_integration_mode" */
export type Github_Integration_Mode_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Github_Integration_Mode_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "github_integration_mode". All fields are combined with a logical 'AND'. */
export type Github_Integration_Mode_Bool_Exp = {
  _and?: Maybe<Array<Github_Integration_Mode_Bool_Exp>>;
  _not?: Maybe<Github_Integration_Mode_Bool_Exp>;
  _or?: Maybe<Array<Github_Integration_Mode_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  mode?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "github_integration_mode" */
export enum Github_Integration_Mode_Constraint {
  /** unique or primary key constraint on columns "mode" */
  GithubIntegrationModePkey = 'github_integration_mode_pkey',
}

export enum Github_Integration_Mode_Enum {
  /** deploy github automatically */
  Automatic = 'automatic',
  /** deploy github manually */
  Manual = 'manual',
  /** deploy github as preview app */
  PreviewApp = 'previewApp',
}

/** Boolean expression to compare columns of type "github_integration_mode_enum". All fields are combined with logical 'AND'. */
export type Github_Integration_Mode_Enum_Comparison_Exp = {
  _eq?: Maybe<Github_Integration_Mode_Enum>;
  _in?: Maybe<Array<Github_Integration_Mode_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Github_Integration_Mode_Enum>;
  _nin?: Maybe<Array<Github_Integration_Mode_Enum>>;
};

/** input type for inserting data into table "github_integration_mode" */
export type Github_Integration_Mode_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  mode?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Github_Integration_Mode_Max_Fields = {
  __typename?: 'github_integration_mode_max_fields';
  description?: Maybe<Scalars['String']>;
  mode?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Github_Integration_Mode_Min_Fields = {
  __typename?: 'github_integration_mode_min_fields';
  description?: Maybe<Scalars['String']>;
  mode?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "github_integration_mode" */
export type Github_Integration_Mode_Mutation_Response = {
  __typename?: 'github_integration_mode_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Github_Integration_Mode>;
};

/** on_conflict condition type for table "github_integration_mode" */
export type Github_Integration_Mode_On_Conflict = {
  constraint: Github_Integration_Mode_Constraint;
  update_columns?: Array<Github_Integration_Mode_Update_Column>;
  where?: Maybe<Github_Integration_Mode_Bool_Exp>;
};

/** Ordering options when selecting data from "github_integration_mode". */
export type Github_Integration_Mode_Order_By = {
  description?: Maybe<Order_By>;
  mode?: Maybe<Order_By>;
};

/** primary key columns input for table: github_integration_mode */
export type Github_Integration_Mode_Pk_Columns_Input = {
  mode: Scalars['String'];
};

/** select columns of table "github_integration_mode" */
export enum Github_Integration_Mode_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Mode = 'mode',
}

/** input type for updating data in table "github_integration_mode" */
export type Github_Integration_Mode_Set_Input = {
  description?: Maybe<Scalars['String']>;
  mode?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "github_integration_mode" */
export type Github_Integration_Mode_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Github_Integration_Mode_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Github_Integration_Mode_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  mode?: Maybe<Scalars['String']>;
};

/** update columns of table "github_integration_mode" */
export enum Github_Integration_Mode_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Mode = 'mode',
}

export type Github_Integration_Mode_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Github_Integration_Mode_Set_Input>;
  /** filter the rows which have to be updated */
  where: Github_Integration_Mode_Bool_Exp;
};

/** columns and relationships of "github_push_event" */
export type Github_Push_Event = {
  __typename?: 'github_push_event';
  archive_url: Scalars['String'];
  commit: Scalars['String'];
  commit_message: Scalars['String'];
  commit_timestamp: Scalars['timestamptz'];
  /** An object relationship */
  github_integration_config: Github_Integration_Config;
  github_integration_config_id: Scalars['uuid'];
  /** An array relationship */
  github_push_event_jobs: Array<Github_Push_Event_Job>;
  /** An aggregate relationship */
  github_push_event_jobs_aggregate: Github_Push_Event_Job_Aggregate;
  id: Scalars['uuid'];
  push_metadata: Scalars['jsonb'];
  received_at: Scalars['timestamptz'];
};

/** columns and relationships of "github_push_event" */
export type Github_Push_EventGithub_Push_Event_JobsArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Job_Order_By>>;
  where?: Maybe<Github_Push_Event_Job_Bool_Exp>;
};

/** columns and relationships of "github_push_event" */
export type Github_Push_EventGithub_Push_Event_Jobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Job_Order_By>>;
  where?: Maybe<Github_Push_Event_Job_Bool_Exp>;
};

/** columns and relationships of "github_push_event" */
export type Github_Push_EventPush_MetadataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "github_push_event" */
export type Github_Push_Event_Aggregate = {
  __typename?: 'github_push_event_aggregate';
  aggregate?: Maybe<Github_Push_Event_Aggregate_Fields>;
  nodes: Array<Github_Push_Event>;
};

export type Github_Push_Event_Aggregate_Bool_Exp = {
  count?: Maybe<Github_Push_Event_Aggregate_Bool_Exp_Count>;
};

export type Github_Push_Event_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Github_Push_Event_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Github_Push_Event_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "github_push_event" */
export type Github_Push_Event_Aggregate_Fields = {
  __typename?: 'github_push_event_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Github_Push_Event_Max_Fields>;
  min?: Maybe<Github_Push_Event_Min_Fields>;
};

/** aggregate fields of "github_push_event" */
export type Github_Push_Event_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Github_Push_Event_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "github_push_event" */
export type Github_Push_Event_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Github_Push_Event_Max_Order_By>;
  min?: Maybe<Github_Push_Event_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Github_Push_Event_Append_Input = {
  push_metadata?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "github_push_event" */
export type Github_Push_Event_Arr_Rel_Insert_Input = {
  data: Array<Github_Push_Event_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Github_Push_Event_On_Conflict>;
};

/** Boolean expression to filter rows from the table "github_push_event". All fields are combined with a logical 'AND'. */
export type Github_Push_Event_Bool_Exp = {
  _and?: Maybe<Array<Github_Push_Event_Bool_Exp>>;
  _not?: Maybe<Github_Push_Event_Bool_Exp>;
  _or?: Maybe<Array<Github_Push_Event_Bool_Exp>>;
  archive_url?: Maybe<String_Comparison_Exp>;
  commit?: Maybe<String_Comparison_Exp>;
  commit_message?: Maybe<String_Comparison_Exp>;
  commit_timestamp?: Maybe<Timestamptz_Comparison_Exp>;
  github_integration_config?: Maybe<Github_Integration_Config_Bool_Exp>;
  github_integration_config_id?: Maybe<Uuid_Comparison_Exp>;
  github_push_event_jobs?: Maybe<Github_Push_Event_Job_Bool_Exp>;
  github_push_event_jobs_aggregate?: Maybe<Github_Push_Event_Job_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  push_metadata?: Maybe<Jsonb_Comparison_Exp>;
  received_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "github_push_event" */
export enum Github_Push_Event_Constraint {
  /** unique or primary key constraint on columns "id" */
  GithubPushEventPkey = 'github_push_event_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Github_Push_Event_Delete_At_Path_Input = {
  push_metadata?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Github_Push_Event_Delete_Elem_Input = {
  push_metadata?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Github_Push_Event_Delete_Key_Input = {
  push_metadata?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "github_push_event" */
export type Github_Push_Event_Insert_Input = {
  archive_url?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  commit_message?: Maybe<Scalars['String']>;
  commit_timestamp?: Maybe<Scalars['timestamptz']>;
  github_integration_config?: Maybe<Github_Integration_Config_Obj_Rel_Insert_Input>;
  github_integration_config_id?: Maybe<Scalars['uuid']>;
  github_push_event_jobs?: Maybe<Github_Push_Event_Job_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  push_metadata?: Maybe<Scalars['jsonb']>;
  received_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "github_push_event_job" */
export type Github_Push_Event_Job = {
  __typename?: 'github_push_event_job';
  /** An object relationship */
  github_push_event: Github_Push_Event;
  github_push_event_id: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  job: Jobs;
  job_id: Scalars['uuid'];
};

/** aggregated selection of "github_push_event_job" */
export type Github_Push_Event_Job_Aggregate = {
  __typename?: 'github_push_event_job_aggregate';
  aggregate?: Maybe<Github_Push_Event_Job_Aggregate_Fields>;
  nodes: Array<Github_Push_Event_Job>;
};

export type Github_Push_Event_Job_Aggregate_Bool_Exp = {
  count?: Maybe<Github_Push_Event_Job_Aggregate_Bool_Exp_Count>;
};

export type Github_Push_Event_Job_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Github_Push_Event_Job_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Github_Push_Event_Job_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "github_push_event_job" */
export type Github_Push_Event_Job_Aggregate_Fields = {
  __typename?: 'github_push_event_job_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Github_Push_Event_Job_Max_Fields>;
  min?: Maybe<Github_Push_Event_Job_Min_Fields>;
};

/** aggregate fields of "github_push_event_job" */
export type Github_Push_Event_Job_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Github_Push_Event_Job_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "github_push_event_job" */
export type Github_Push_Event_Job_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Github_Push_Event_Job_Max_Order_By>;
  min?: Maybe<Github_Push_Event_Job_Min_Order_By>;
};

/** input type for inserting array relation for remote table "github_push_event_job" */
export type Github_Push_Event_Job_Arr_Rel_Insert_Input = {
  data: Array<Github_Push_Event_Job_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Github_Push_Event_Job_On_Conflict>;
};

/** Boolean expression to filter rows from the table "github_push_event_job". All fields are combined with a logical 'AND'. */
export type Github_Push_Event_Job_Bool_Exp = {
  _and?: Maybe<Array<Github_Push_Event_Job_Bool_Exp>>;
  _not?: Maybe<Github_Push_Event_Job_Bool_Exp>;
  _or?: Maybe<Array<Github_Push_Event_Job_Bool_Exp>>;
  github_push_event?: Maybe<Github_Push_Event_Bool_Exp>;
  github_push_event_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  job?: Maybe<Jobs_Bool_Exp>;
  job_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "github_push_event_job" */
export enum Github_Push_Event_Job_Constraint {
  /** unique or primary key constraint on columns "id" */
  GithubPushEventJobPkey = 'github_push_event_job_pkey',
}

/** input type for inserting data into table "github_push_event_job" */
export type Github_Push_Event_Job_Insert_Input = {
  github_push_event?: Maybe<Github_Push_Event_Obj_Rel_Insert_Input>;
  github_push_event_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  job?: Maybe<Jobs_Obj_Rel_Insert_Input>;
  job_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Github_Push_Event_Job_Max_Fields = {
  __typename?: 'github_push_event_job_max_fields';
  github_push_event_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "github_push_event_job" */
export type Github_Push_Event_Job_Max_Order_By = {
  github_push_event_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  job_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Github_Push_Event_Job_Min_Fields = {
  __typename?: 'github_push_event_job_min_fields';
  github_push_event_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "github_push_event_job" */
export type Github_Push_Event_Job_Min_Order_By = {
  github_push_event_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  job_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "github_push_event_job" */
export type Github_Push_Event_Job_Mutation_Response = {
  __typename?: 'github_push_event_job_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Github_Push_Event_Job>;
};

/** on_conflict condition type for table "github_push_event_job" */
export type Github_Push_Event_Job_On_Conflict = {
  constraint: Github_Push_Event_Job_Constraint;
  update_columns?: Array<Github_Push_Event_Job_Update_Column>;
  where?: Maybe<Github_Push_Event_Job_Bool_Exp>;
};

/** Ordering options when selecting data from "github_push_event_job". */
export type Github_Push_Event_Job_Order_By = {
  github_push_event?: Maybe<Github_Push_Event_Order_By>;
  github_push_event_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  job?: Maybe<Jobs_Order_By>;
  job_id?: Maybe<Order_By>;
};

/** primary key columns input for table: github_push_event_job */
export type Github_Push_Event_Job_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "github_push_event_job" */
export enum Github_Push_Event_Job_Select_Column {
  /** column name */
  GithubPushEventId = 'github_push_event_id',
  /** column name */
  Id = 'id',
  /** column name */
  JobId = 'job_id',
}

/** input type for updating data in table "github_push_event_job" */
export type Github_Push_Event_Job_Set_Input = {
  github_push_event_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "github_push_event_job" */
export type Github_Push_Event_Job_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Github_Push_Event_Job_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Github_Push_Event_Job_Stream_Cursor_Value_Input = {
  github_push_event_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "github_push_event_job" */
export enum Github_Push_Event_Job_Update_Column {
  /** column name */
  GithubPushEventId = 'github_push_event_id',
  /** column name */
  Id = 'id',
  /** column name */
  JobId = 'job_id',
}

export type Github_Push_Event_Job_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Github_Push_Event_Job_Set_Input>;
  /** filter the rows which have to be updated */
  where: Github_Push_Event_Job_Bool_Exp;
};

/** aggregate max on columns */
export type Github_Push_Event_Max_Fields = {
  __typename?: 'github_push_event_max_fields';
  archive_url?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  commit_message?: Maybe<Scalars['String']>;
  commit_timestamp?: Maybe<Scalars['timestamptz']>;
  github_integration_config_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  received_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "github_push_event" */
export type Github_Push_Event_Max_Order_By = {
  archive_url?: Maybe<Order_By>;
  commit?: Maybe<Order_By>;
  commit_message?: Maybe<Order_By>;
  commit_timestamp?: Maybe<Order_By>;
  github_integration_config_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  received_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Github_Push_Event_Min_Fields = {
  __typename?: 'github_push_event_min_fields';
  archive_url?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  commit_message?: Maybe<Scalars['String']>;
  commit_timestamp?: Maybe<Scalars['timestamptz']>;
  github_integration_config_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  received_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "github_push_event" */
export type Github_Push_Event_Min_Order_By = {
  archive_url?: Maybe<Order_By>;
  commit?: Maybe<Order_By>;
  commit_message?: Maybe<Order_By>;
  commit_timestamp?: Maybe<Order_By>;
  github_integration_config_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  received_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "github_push_event" */
export type Github_Push_Event_Mutation_Response = {
  __typename?: 'github_push_event_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Github_Push_Event>;
};

/** input type for inserting object relation for remote table "github_push_event" */
export type Github_Push_Event_Obj_Rel_Insert_Input = {
  data: Github_Push_Event_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Github_Push_Event_On_Conflict>;
};

/** on_conflict condition type for table "github_push_event" */
export type Github_Push_Event_On_Conflict = {
  constraint: Github_Push_Event_Constraint;
  update_columns?: Array<Github_Push_Event_Update_Column>;
  where?: Maybe<Github_Push_Event_Bool_Exp>;
};

/** Ordering options when selecting data from "github_push_event". */
export type Github_Push_Event_Order_By = {
  archive_url?: Maybe<Order_By>;
  commit?: Maybe<Order_By>;
  commit_message?: Maybe<Order_By>;
  commit_timestamp?: Maybe<Order_By>;
  github_integration_config?: Maybe<Github_Integration_Config_Order_By>;
  github_integration_config_id?: Maybe<Order_By>;
  github_push_event_jobs_aggregate?: Maybe<Github_Push_Event_Job_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  push_metadata?: Maybe<Order_By>;
  received_at?: Maybe<Order_By>;
};

/** primary key columns input for table: github_push_event */
export type Github_Push_Event_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Github_Push_Event_Prepend_Input = {
  push_metadata?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "github_push_event" */
export enum Github_Push_Event_Select_Column {
  /** column name */
  ArchiveUrl = 'archive_url',
  /** column name */
  Commit = 'commit',
  /** column name */
  CommitMessage = 'commit_message',
  /** column name */
  CommitTimestamp = 'commit_timestamp',
  /** column name */
  GithubIntegrationConfigId = 'github_integration_config_id',
  /** column name */
  Id = 'id',
  /** column name */
  PushMetadata = 'push_metadata',
  /** column name */
  ReceivedAt = 'received_at',
}

/** input type for updating data in table "github_push_event" */
export type Github_Push_Event_Set_Input = {
  archive_url?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  commit_message?: Maybe<Scalars['String']>;
  commit_timestamp?: Maybe<Scalars['timestamptz']>;
  github_integration_config_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  push_metadata?: Maybe<Scalars['jsonb']>;
  received_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "github_push_event" */
export type Github_Push_Event_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Github_Push_Event_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Github_Push_Event_Stream_Cursor_Value_Input = {
  archive_url?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  commit_message?: Maybe<Scalars['String']>;
  commit_timestamp?: Maybe<Scalars['timestamptz']>;
  github_integration_config_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  push_metadata?: Maybe<Scalars['jsonb']>;
  received_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "github_push_event" */
export enum Github_Push_Event_Update_Column {
  /** column name */
  ArchiveUrl = 'archive_url',
  /** column name */
  Commit = 'commit',
  /** column name */
  CommitMessage = 'commit_message',
  /** column name */
  CommitTimestamp = 'commit_timestamp',
  /** column name */
  GithubIntegrationConfigId = 'github_integration_config_id',
  /** column name */
  Id = 'id',
  /** column name */
  PushMetadata = 'push_metadata',
  /** column name */
  ReceivedAt = 'received_at',
}

export type Github_Push_Event_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Github_Push_Event_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Github_Push_Event_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Github_Push_Event_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Github_Push_Event_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Github_Push_Event_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Github_Push_Event_Set_Input>;
  /** filter the rows which have to be updated */
  where: Github_Push_Event_Bool_Exp;
};

export type GithubIntegrationInput = {
  branch: Scalars['String'];
  directory?: Maybe<Scalars['String']>;
  email_status: Scalars['String'];
  installation_id?: Maybe<Scalars['Int']>;
  mode?: Maybe<ModeEnum>;
  org: Scalars['String'];
  project_id: Scalars['String'];
  repo: Scalars['String'];
};

export type GithubIntegrationStatus = {
  __typename?: 'GithubIntegrationStatus';
  status: Scalars['String'];
};

export type GithubRepoDetails = {
  branch: Scalars['String'];
  directory: Scalars['String'];
  owner: Scalars['String'];
  repo: Scalars['String'];
};

export type GithubSession = {
  __typename?: 'GithubSession';
  access_token: Scalars['String'];
  token_type: Scalars['String'];
};

export type GranularComputeUnitCount = {
  __typename?: 'GranularComputeUnitCount';
  count: Scalars['Int'];
  epoch: Scalars['Int'];
};

export type GranularComputeUnitUsagePercentage = {
  __typename?: 'GranularComputeUnitUsagePercentage';
  epoch: Scalars['Int'];
  usage: Scalars['Float'];
};

export type HandleInactiveProjectsResult = {
  __typename?: 'HandleInactiveProjectsResult';
  done?: Maybe<Scalars['Boolean']>;
};

/** columns and relationships of "hasura_ami" */
export type Hasura_Ami = {
  __typename?: 'hasura_ami';
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  cloud_version: Scalars['String'];
  commit_hash: Scalars['String'];
  created_at: Scalars['timestamptz'];
  major_version: Scalars['smallint'];
  region: Scalars['String'];
  remarks: Scalars['String'];
  super_connector_metadata_defaults?: Maybe<Scalars['jsonb']>;
};

/** columns and relationships of "hasura_ami" */
export type Hasura_AmiSuper_Connector_Metadata_DefaultsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "hasura_ami" */
export type Hasura_Ami_Aggregate = {
  __typename?: 'hasura_ami_aggregate';
  aggregate?: Maybe<Hasura_Ami_Aggregate_Fields>;
  nodes: Array<Hasura_Ami>;
};

/** aggregate fields of "hasura_ami" */
export type Hasura_Ami_Aggregate_Fields = {
  __typename?: 'hasura_ami_aggregate_fields';
  avg?: Maybe<Hasura_Ami_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Hasura_Ami_Max_Fields>;
  min?: Maybe<Hasura_Ami_Min_Fields>;
  stddev?: Maybe<Hasura_Ami_Stddev_Fields>;
  stddev_pop?: Maybe<Hasura_Ami_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Hasura_Ami_Stddev_Samp_Fields>;
  sum?: Maybe<Hasura_Ami_Sum_Fields>;
  var_pop?: Maybe<Hasura_Ami_Var_Pop_Fields>;
  var_samp?: Maybe<Hasura_Ami_Var_Samp_Fields>;
  variance?: Maybe<Hasura_Ami_Variance_Fields>;
};

/** aggregate fields of "hasura_ami" */
export type Hasura_Ami_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Hasura_Ami_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Hasura_Ami_Append_Input = {
  super_connector_metadata_defaults?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Hasura_Ami_Avg_Fields = {
  __typename?: 'hasura_ami_avg_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "hasura_ami". All fields are combined with a logical 'AND'. */
export type Hasura_Ami_Bool_Exp = {
  _and?: Maybe<Array<Hasura_Ami_Bool_Exp>>;
  _not?: Maybe<Hasura_Ami_Bool_Exp>;
  _or?: Maybe<Array<Hasura_Ami_Bool_Exp>>;
  ami_id?: Maybe<String_Comparison_Exp>;
  cloud?: Maybe<String_Comparison_Exp>;
  cloud_version?: Maybe<String_Comparison_Exp>;
  commit_hash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  major_version?: Maybe<Smallint_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  remarks?: Maybe<String_Comparison_Exp>;
  super_connector_metadata_defaults?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "hasura_ami" */
export enum Hasura_Ami_Constraint {
  /** unique or primary key constraint on columns "ami_id", "cloud", "cloud_version", "region" */
  HasuraAmiAmiIdCloudRegionCloudVersionKey = 'hasura_ami_ami_id_cloud_region_cloud_version_key',
  /** unique or primary key constraint on columns "ami_id" */
  HasuraAmiAmiIdKey = 'hasura_ami_ami_id_key',
  /** unique or primary key constraint on columns "ami_id", "cloud", "region" */
  HasuraAmiPkey = 'hasura_ami_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Hasura_Ami_Delete_At_Path_Input = {
  super_connector_metadata_defaults?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Hasura_Ami_Delete_Elem_Input = {
  super_connector_metadata_defaults?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Hasura_Ami_Delete_Key_Input = {
  super_connector_metadata_defaults?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "hasura_ami" */
export type Hasura_Ami_Inc_Input = {
  major_version?: Maybe<Scalars['smallint']>;
};

/** input type for inserting data into table "hasura_ami" */
export type Hasura_Ami_Insert_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cloud_version?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  major_version?: Maybe<Scalars['smallint']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
  super_connector_metadata_defaults?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type Hasura_Ami_Max_Fields = {
  __typename?: 'hasura_ami_max_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cloud_version?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  major_version?: Maybe<Scalars['smallint']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Hasura_Ami_Min_Fields = {
  __typename?: 'hasura_ami_min_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cloud_version?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  major_version?: Maybe<Scalars['smallint']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "hasura_ami" */
export type Hasura_Ami_Mutation_Response = {
  __typename?: 'hasura_ami_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Hasura_Ami>;
};

/** on_conflict condition type for table "hasura_ami" */
export type Hasura_Ami_On_Conflict = {
  constraint: Hasura_Ami_Constraint;
  update_columns?: Array<Hasura_Ami_Update_Column>;
  where?: Maybe<Hasura_Ami_Bool_Exp>;
};

/** Ordering options when selecting data from "hasura_ami". */
export type Hasura_Ami_Order_By = {
  ami_id?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  cloud_version?: Maybe<Order_By>;
  commit_hash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  major_version?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  remarks?: Maybe<Order_By>;
  super_connector_metadata_defaults?: Maybe<Order_By>;
};

/** primary key columns input for table: hasura_ami */
export type Hasura_Ami_Pk_Columns_Input = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Hasura_Ami_Prepend_Input = {
  super_connector_metadata_defaults?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "hasura_ami" */
export enum Hasura_Ami_Select_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CloudVersion = 'cloud_version',
  /** column name */
  CommitHash = 'commit_hash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  MajorVersion = 'major_version',
  /** column name */
  Region = 'region',
  /** column name */
  Remarks = 'remarks',
  /** column name */
  SuperConnectorMetadataDefaults = 'super_connector_metadata_defaults',
}

/** input type for updating data in table "hasura_ami" */
export type Hasura_Ami_Set_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cloud_version?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  major_version?: Maybe<Scalars['smallint']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
  super_connector_metadata_defaults?: Maybe<Scalars['jsonb']>;
};

/** aggregate stddev on columns */
export type Hasura_Ami_Stddev_Fields = {
  __typename?: 'hasura_ami_stddev_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Hasura_Ami_Stddev_Pop_Fields = {
  __typename?: 'hasura_ami_stddev_pop_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Hasura_Ami_Stddev_Samp_Fields = {
  __typename?: 'hasura_ami_stddev_samp_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "hasura_ami" */
export type Hasura_Ami_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Hasura_Ami_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Hasura_Ami_Stream_Cursor_Value_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cloud_version?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  major_version?: Maybe<Scalars['smallint']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
  super_connector_metadata_defaults?: Maybe<Scalars['jsonb']>;
};

/** aggregate sum on columns */
export type Hasura_Ami_Sum_Fields = {
  __typename?: 'hasura_ami_sum_fields';
  major_version?: Maybe<Scalars['smallint']>;
};

/** update columns of table "hasura_ami" */
export enum Hasura_Ami_Update_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CloudVersion = 'cloud_version',
  /** column name */
  CommitHash = 'commit_hash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  MajorVersion = 'major_version',
  /** column name */
  Region = 'region',
  /** column name */
  Remarks = 'remarks',
  /** column name */
  SuperConnectorMetadataDefaults = 'super_connector_metadata_defaults',
}

export type Hasura_Ami_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Hasura_Ami_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Hasura_Ami_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Hasura_Ami_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Hasura_Ami_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Hasura_Ami_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Hasura_Ami_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Hasura_Ami_Set_Input>;
  /** filter the rows which have to be updated */
  where: Hasura_Ami_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Hasura_Ami_Var_Pop_Fields = {
  __typename?: 'hasura_ami_var_pop_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Hasura_Ami_Var_Samp_Fields = {
  __typename?: 'hasura_ami_var_samp_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Hasura_Ami_Variance_Fields = {
  __typename?: 'hasura_ami_variance_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** Set of Hasura workers in a specific region */
export type Hasura_Cluster = {
  __typename?: 'hasura_cluster';
  ami_id?: Maybe<Scalars['String']>;
  cloud: Scalars['String'];
  comments?: Maybe<Scalars['String']>;
  /** An object relationship */
  compute_unit_config?: Maybe<Compute_Unit_Config>;
  compute_unit_config_id?: Maybe<Scalars['uuid']>;
  configured_super_connector?: Maybe<Super_Connector_Types_Enum>;
  created_at: Scalars['timestamptz'];
  disable_infra_auto_apply: Scalars['Boolean'];
  id: Scalars['uuid'];
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  node_pool?: Maybe<Node_Pools>;
  node_pool_id?: Maybe<Scalars['uuid']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  pinned_version?: Maybe<Scalars['String']>;
  region: Scalars['String'];
  /** An object relationship */
  region_info?: Maybe<Region>;
  slug: Scalars['String'];
  status: Scalars['String'];
  /** metadata defaults that will be used by the hasura cluster */
  super_connector_metadata_defaults?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  tenant_group?: Maybe<Tenant_Group>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  workers: Array<Hasura_Worker>;
  /** An aggregate relationship */
  workers_aggregate: Hasura_Worker_Aggregate;
};

/** Set of Hasura workers in a specific region */
export type Hasura_ClusterInput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Set of Hasura workers in a specific region */
export type Hasura_ClusterOutput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Set of Hasura workers in a specific region */
export type Hasura_ClusterSuper_Connector_Metadata_DefaultsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Set of Hasura workers in a specific region */
export type Hasura_ClusterWorkersArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Order_By>>;
  where?: Maybe<Hasura_Worker_Bool_Exp>;
};

/** Set of Hasura workers in a specific region */
export type Hasura_ClusterWorkers_AggregateArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Order_By>>;
  where?: Maybe<Hasura_Worker_Bool_Exp>;
};

/** aggregated selection of "hasura_cluster" */
export type Hasura_Cluster_Aggregate = {
  __typename?: 'hasura_cluster_aggregate';
  aggregate?: Maybe<Hasura_Cluster_Aggregate_Fields>;
  nodes: Array<Hasura_Cluster>;
};

export type Hasura_Cluster_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Hasura_Cluster_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Hasura_Cluster_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Hasura_Cluster_Aggregate_Bool_Exp_Count>;
};

export type Hasura_Cluster_Aggregate_Bool_Exp_Bool_And = {
  arguments: Hasura_Cluster_Select_Column_Hasura_Cluster_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Hasura_Cluster_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Hasura_Cluster_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Hasura_Cluster_Select_Column_Hasura_Cluster_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Hasura_Cluster_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Hasura_Cluster_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Hasura_Cluster_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Hasura_Cluster_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "hasura_cluster" */
export type Hasura_Cluster_Aggregate_Fields = {
  __typename?: 'hasura_cluster_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Hasura_Cluster_Max_Fields>;
  min?: Maybe<Hasura_Cluster_Min_Fields>;
};

/** aggregate fields of "hasura_cluster" */
export type Hasura_Cluster_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Hasura_Cluster_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "hasura_cluster" */
export type Hasura_Cluster_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Hasura_Cluster_Max_Order_By>;
  min?: Maybe<Hasura_Cluster_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Hasura_Cluster_Append_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "hasura_cluster" */
export type Hasura_Cluster_Arr_Rel_Insert_Input = {
  data: Array<Hasura_Cluster_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Hasura_Cluster_On_Conflict>;
};

/** Boolean expression to filter rows from the table "hasura_cluster". All fields are combined with a logical 'AND'. */
export type Hasura_Cluster_Bool_Exp = {
  _and?: Maybe<Array<Hasura_Cluster_Bool_Exp>>;
  _not?: Maybe<Hasura_Cluster_Bool_Exp>;
  _or?: Maybe<Array<Hasura_Cluster_Bool_Exp>>;
  ami_id?: Maybe<String_Comparison_Exp>;
  cloud?: Maybe<String_Comparison_Exp>;
  comments?: Maybe<String_Comparison_Exp>;
  compute_unit_config?: Maybe<Compute_Unit_Config_Bool_Exp>;
  compute_unit_config_id?: Maybe<Uuid_Comparison_Exp>;
  configured_super_connector?: Maybe<Super_Connector_Types_Enum_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  disable_infra_auto_apply?: Maybe<Boolean_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  infra_status?: Maybe<Infra_Status_Enum_Comparison_Exp>;
  input_variables?: Maybe<Jsonb_Comparison_Exp>;
  node_pool?: Maybe<Node_Pools_Bool_Exp>;
  node_pool_id?: Maybe<Uuid_Comparison_Exp>;
  output_variables?: Maybe<Jsonb_Comparison_Exp>;
  pinned_version?: Maybe<String_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  region_info?: Maybe<Region_Bool_Exp>;
  slug?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  super_connector_metadata_defaults?: Maybe<Jsonb_Comparison_Exp>;
  tenant_group?: Maybe<Tenant_Group_Bool_Exp>;
  tenant_group_id?: Maybe<Uuid_Comparison_Exp>;
  workers?: Maybe<Hasura_Worker_Bool_Exp>;
  workers_aggregate?: Maybe<Hasura_Worker_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "hasura_cluster" */
export enum Hasura_Cluster_Constraint {
  /** unique or primary key constraint on columns "node_pool_id", "compute_unit_config_id" */
  HasuraClusterComputeUnitConfigIdUniqueKey = 'hasura_cluster_compute_unit_config_id_unique_key',
  /** unique or primary key constraint on columns "id" */
  HasuraClusterPkey = 'hasura_cluster_pkey',
  /** unique or primary key constraint on columns "slug" */
  HasuraClusterSlugKey = 'hasura_cluster_slug_key',
  /** unique or primary key constraint on columns "tenant_group_id" */
  HasuraClusterTenantGroupIdKey = 'hasura_cluster_tenant_group_id_key',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Hasura_Cluster_Delete_At_Path_Input = {
  input_variables?: Maybe<Array<Scalars['String']>>;
  output_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Hasura_Cluster_Delete_Elem_Input = {
  input_variables?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Hasura_Cluster_Delete_Key_Input = {
  input_variables?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "hasura_cluster" */
export type Hasura_Cluster_Insert_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  compute_unit_config?: Maybe<Compute_Unit_Config_Obj_Rel_Insert_Input>;
  compute_unit_config_id?: Maybe<Scalars['uuid']>;
  configured_super_connector?: Maybe<Super_Connector_Types_Enum>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  node_pool?: Maybe<Node_Pools_Obj_Rel_Insert_Input>;
  node_pool_id?: Maybe<Scalars['uuid']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  pinned_version?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  region_info?: Maybe<Region_Obj_Rel_Insert_Input>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  tenant_group?: Maybe<Tenant_Group_Obj_Rel_Insert_Input>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
  workers?: Maybe<Hasura_Worker_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Hasura_Cluster_Max_Fields = {
  __typename?: 'hasura_cluster_max_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  compute_unit_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  node_pool_id?: Maybe<Scalars['uuid']>;
  pinned_version?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "hasura_cluster" */
export type Hasura_Cluster_Max_Order_By = {
  ami_id?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  comments?: Maybe<Order_By>;
  compute_unit_config_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  node_pool_id?: Maybe<Order_By>;
  pinned_version?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  tenant_group_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Hasura_Cluster_Min_Fields = {
  __typename?: 'hasura_cluster_min_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  compute_unit_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  node_pool_id?: Maybe<Scalars['uuid']>;
  pinned_version?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "hasura_cluster" */
export type Hasura_Cluster_Min_Order_By = {
  ami_id?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  comments?: Maybe<Order_By>;
  compute_unit_config_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  node_pool_id?: Maybe<Order_By>;
  pinned_version?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  tenant_group_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "hasura_cluster" */
export type Hasura_Cluster_Mutation_Response = {
  __typename?: 'hasura_cluster_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Hasura_Cluster>;
};

/** input type for inserting object relation for remote table "hasura_cluster" */
export type Hasura_Cluster_Obj_Rel_Insert_Input = {
  data: Hasura_Cluster_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Hasura_Cluster_On_Conflict>;
};

/** on_conflict condition type for table "hasura_cluster" */
export type Hasura_Cluster_On_Conflict = {
  constraint: Hasura_Cluster_Constraint;
  update_columns?: Array<Hasura_Cluster_Update_Column>;
  where?: Maybe<Hasura_Cluster_Bool_Exp>;
};

/** Ordering options when selecting data from "hasura_cluster". */
export type Hasura_Cluster_Order_By = {
  ami_id?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  comments?: Maybe<Order_By>;
  compute_unit_config?: Maybe<Compute_Unit_Config_Order_By>;
  compute_unit_config_id?: Maybe<Order_By>;
  configured_super_connector?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  disable_infra_auto_apply?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  infra_status?: Maybe<Order_By>;
  input_variables?: Maybe<Order_By>;
  node_pool?: Maybe<Node_Pools_Order_By>;
  node_pool_id?: Maybe<Order_By>;
  output_variables?: Maybe<Order_By>;
  pinned_version?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  region_info?: Maybe<Region_Order_By>;
  slug?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  super_connector_metadata_defaults?: Maybe<Order_By>;
  tenant_group?: Maybe<Tenant_Group_Order_By>;
  tenant_group_id?: Maybe<Order_By>;
  workers_aggregate?: Maybe<Hasura_Worker_Aggregate_Order_By>;
};

/** primary key columns input for table: hasura_cluster */
export type Hasura_Cluster_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Hasura_Cluster_Prepend_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "hasura_cluster" */
export enum Hasura_Cluster_Select_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  Comments = 'comments',
  /** column name */
  ComputeUnitConfigId = 'compute_unit_config_id',
  /** column name */
  ConfiguredSuperConnector = 'configured_super_connector',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  Id = 'id',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  NodePoolId = 'node_pool_id',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  PinnedVersion = 'pinned_version',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  TenantGroupId = 'tenant_group_id',
}

/** select "hasura_cluster_aggregate_bool_exp_bool_and_arguments_columns" columns of table "hasura_cluster" */
export enum Hasura_Cluster_Select_Column_Hasura_Cluster_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
}

/** select "hasura_cluster_aggregate_bool_exp_bool_or_arguments_columns" columns of table "hasura_cluster" */
export enum Hasura_Cluster_Select_Column_Hasura_Cluster_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
}

/** input type for updating data in table "hasura_cluster" */
export type Hasura_Cluster_Set_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  compute_unit_config_id?: Maybe<Scalars['uuid']>;
  configured_super_connector?: Maybe<Super_Connector_Types_Enum>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  node_pool_id?: Maybe<Scalars['uuid']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  pinned_version?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "hasura_cluster" */
export type Hasura_Cluster_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Hasura_Cluster_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Hasura_Cluster_Stream_Cursor_Value_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  compute_unit_config_id?: Maybe<Scalars['uuid']>;
  configured_super_connector?: Maybe<Super_Connector_Types_Enum>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  node_pool_id?: Maybe<Scalars['uuid']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  pinned_version?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  tenant_group_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "hasura_cluster" */
export enum Hasura_Cluster_Update_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  Comments = 'comments',
  /** column name */
  ComputeUnitConfigId = 'compute_unit_config_id',
  /** column name */
  ConfiguredSuperConnector = 'configured_super_connector',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  Id = 'id',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  NodePoolId = 'node_pool_id',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  PinnedVersion = 'pinned_version',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  TenantGroupId = 'tenant_group_id',
}

export type Hasura_Cluster_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Hasura_Cluster_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Hasura_Cluster_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Hasura_Cluster_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Hasura_Cluster_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Hasura_Cluster_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Hasura_Cluster_Set_Input>;
  /** filter the rows which have to be updated */
  where: Hasura_Cluster_Bool_Exp;
};

/** Multi-tenant Hasura process capable of providing GraphQL APIs */
export type Hasura_Worker = {
  __typename?: 'hasura_worker';
  cloud: Scalars['String'];
  /** An object relationship */
  cluster: Hasura_Cluster;
  cluster_id: Scalars['uuid'];
  /** An array relationship */
  config_statuses: Array<Config_Status>;
  /** An aggregate relationship */
  config_statuses_aggregate: Config_Status_Aggregate;
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  ip: Scalars['String'];
  region: Scalars['String'];
  slug: Scalars['String'];
  status: Scalars['String'];
  /** An array relationship */
  tenant_statuses: Array<Tenant_Status>;
  /** An aggregate relationship */
  tenant_statuses_aggregate: Tenant_Status_Aggregate;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone: Scalars['String'];
};

/** Multi-tenant Hasura process capable of providing GraphQL APIs */
export type Hasura_WorkerConfig_StatusesArgs = {
  distinct_on?: Maybe<Array<Config_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Status_Order_By>>;
  where?: Maybe<Config_Status_Bool_Exp>;
};

/** Multi-tenant Hasura process capable of providing GraphQL APIs */
export type Hasura_WorkerConfig_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Config_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Status_Order_By>>;
  where?: Maybe<Config_Status_Bool_Exp>;
};

/** Multi-tenant Hasura process capable of providing GraphQL APIs */
export type Hasura_WorkerTenant_StatusesArgs = {
  distinct_on?: Maybe<Array<Tenant_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Status_Order_By>>;
  where?: Maybe<Tenant_Status_Bool_Exp>;
};

/** Multi-tenant Hasura process capable of providing GraphQL APIs */
export type Hasura_WorkerTenant_Statuses_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Status_Order_By>>;
  where?: Maybe<Tenant_Status_Bool_Exp>;
};

/** aggregated selection of "hasura_worker" */
export type Hasura_Worker_Aggregate = {
  __typename?: 'hasura_worker_aggregate';
  aggregate?: Maybe<Hasura_Worker_Aggregate_Fields>;
  nodes: Array<Hasura_Worker>;
};

export type Hasura_Worker_Aggregate_Bool_Exp = {
  count?: Maybe<Hasura_Worker_Aggregate_Bool_Exp_Count>;
};

export type Hasura_Worker_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Hasura_Worker_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Hasura_Worker_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "hasura_worker" */
export type Hasura_Worker_Aggregate_Fields = {
  __typename?: 'hasura_worker_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Hasura_Worker_Max_Fields>;
  min?: Maybe<Hasura_Worker_Min_Fields>;
};

/** aggregate fields of "hasura_worker" */
export type Hasura_Worker_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Hasura_Worker_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "hasura_worker" */
export type Hasura_Worker_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Hasura_Worker_Max_Order_By>;
  min?: Maybe<Hasura_Worker_Min_Order_By>;
};

/** input type for inserting array relation for remote table "hasura_worker" */
export type Hasura_Worker_Arr_Rel_Insert_Input = {
  data: Array<Hasura_Worker_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Hasura_Worker_On_Conflict>;
};

/** Boolean expression to filter rows from the table "hasura_worker". All fields are combined with a logical 'AND'. */
export type Hasura_Worker_Bool_Exp = {
  _and?: Maybe<Array<Hasura_Worker_Bool_Exp>>;
  _not?: Maybe<Hasura_Worker_Bool_Exp>;
  _or?: Maybe<Array<Hasura_Worker_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  cluster?: Maybe<Hasura_Cluster_Bool_Exp>;
  cluster_id?: Maybe<Uuid_Comparison_Exp>;
  config_statuses?: Maybe<Config_Status_Bool_Exp>;
  config_statuses_aggregate?: Maybe<Config_Status_Aggregate_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  ip?: Maybe<String_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  slug?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  tenant_statuses?: Maybe<Tenant_Status_Bool_Exp>;
  tenant_statuses_aggregate?: Maybe<Tenant_Status_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  zone?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "hasura_worker" */
export enum Hasura_Worker_Constraint {
  /** unique or primary key constraint on columns "slug" */
  HasuraWorkerSlugKey = 'hasura_worker_slug_key',
  /** unique or primary key constraint on columns "id" */
  HasuraWorkersPkey = 'hasura_workers_pkey',
}

/** input type for inserting data into table "hasura_worker" */
export type Hasura_Worker_Insert_Input = {
  cloud?: Maybe<Scalars['String']>;
  cluster?: Maybe<Hasura_Cluster_Obj_Rel_Insert_Input>;
  cluster_id?: Maybe<Scalars['uuid']>;
  config_statuses?: Maybe<Config_Status_Arr_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  tenant_statuses?: Maybe<Tenant_Status_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Hasura_Worker_Max_Fields = {
  __typename?: 'hasura_worker_max_fields';
  cloud?: Maybe<Scalars['String']>;
  cluster_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "hasura_worker" */
export type Hasura_Worker_Max_Order_By = {
  cloud?: Maybe<Order_By>;
  cluster_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  ip?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  zone?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Hasura_Worker_Min_Fields = {
  __typename?: 'hasura_worker_min_fields';
  cloud?: Maybe<Scalars['String']>;
  cluster_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "hasura_worker" */
export type Hasura_Worker_Min_Order_By = {
  cloud?: Maybe<Order_By>;
  cluster_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  ip?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  zone?: Maybe<Order_By>;
};

/** response of any mutation on the table "hasura_worker" */
export type Hasura_Worker_Mutation_Response = {
  __typename?: 'hasura_worker_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Hasura_Worker>;
};

/** on_conflict condition type for table "hasura_worker" */
export type Hasura_Worker_On_Conflict = {
  constraint: Hasura_Worker_Constraint;
  update_columns?: Array<Hasura_Worker_Update_Column>;
  where?: Maybe<Hasura_Worker_Bool_Exp>;
};

/** Ordering options when selecting data from "hasura_worker". */
export type Hasura_Worker_Order_By = {
  cloud?: Maybe<Order_By>;
  cluster?: Maybe<Hasura_Cluster_Order_By>;
  cluster_id?: Maybe<Order_By>;
  config_statuses_aggregate?: Maybe<Config_Status_Aggregate_Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  ip?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  tenant_statuses_aggregate?: Maybe<Tenant_Status_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
  zone?: Maybe<Order_By>;
};

/** primary key columns input for table: hasura_worker */
export type Hasura_Worker_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "hasura_worker" */
export enum Hasura_Worker_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  ClusterId = 'cluster_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Zone = 'zone',
}

/** input type for updating data in table "hasura_worker" */
export type Hasura_Worker_Set_Input = {
  cloud?: Maybe<Scalars['String']>;
  cluster_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "hasura_worker" */
export type Hasura_Worker_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Hasura_Worker_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Hasura_Worker_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  cluster_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zone?: Maybe<Scalars['String']>;
};

/** View to visualize hasura workers and corresponding tenants */
export type Hasura_Worker_Tenants = {
  __typename?: 'hasura_worker_tenants';
  group_id?: Maybe<Scalars['uuid']>;
  hash?: Maybe<Scalars['String']>;
  policies?: Maybe<Scalars['json']>;
  port?: Maybe<Scalars['Int']>;
  /** An object relationship */
  tenant?: Maybe<Tenant>;
  tenant_id?: Maybe<Scalars['uuid']>;
  vault_path?: Maybe<Scalars['String']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** View to visualize hasura workers and corresponding tenants */
export type Hasura_Worker_TenantsPoliciesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Aggregate = {
  __typename?: 'hasura_worker_tenants_aggregate';
  aggregate?: Maybe<Hasura_Worker_Tenants_Aggregate_Fields>;
  nodes: Array<Hasura_Worker_Tenants>;
};

export type Hasura_Worker_Tenants_Aggregate_Bool_Exp = {
  count?: Maybe<Hasura_Worker_Tenants_Aggregate_Bool_Exp_Count>;
};

export type Hasura_Worker_Tenants_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Hasura_Worker_Tenants_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Hasura_Worker_Tenants_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Aggregate_Fields = {
  __typename?: 'hasura_worker_tenants_aggregate_fields';
  avg?: Maybe<Hasura_Worker_Tenants_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Hasura_Worker_Tenants_Max_Fields>;
  min?: Maybe<Hasura_Worker_Tenants_Min_Fields>;
  stddev?: Maybe<Hasura_Worker_Tenants_Stddev_Fields>;
  stddev_pop?: Maybe<Hasura_Worker_Tenants_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Hasura_Worker_Tenants_Stddev_Samp_Fields>;
  sum?: Maybe<Hasura_Worker_Tenants_Sum_Fields>;
  var_pop?: Maybe<Hasura_Worker_Tenants_Var_Pop_Fields>;
  var_samp?: Maybe<Hasura_Worker_Tenants_Var_Samp_Fields>;
  variance?: Maybe<Hasura_Worker_Tenants_Variance_Fields>;
};

/** aggregate fields of "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Hasura_Worker_Tenants_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Aggregate_Order_By = {
  avg?: Maybe<Hasura_Worker_Tenants_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Hasura_Worker_Tenants_Max_Order_By>;
  min?: Maybe<Hasura_Worker_Tenants_Min_Order_By>;
  stddev?: Maybe<Hasura_Worker_Tenants_Stddev_Order_By>;
  stddev_pop?: Maybe<Hasura_Worker_Tenants_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Hasura_Worker_Tenants_Stddev_Samp_Order_By>;
  sum?: Maybe<Hasura_Worker_Tenants_Sum_Order_By>;
  var_pop?: Maybe<Hasura_Worker_Tenants_Var_Pop_Order_By>;
  var_samp?: Maybe<Hasura_Worker_Tenants_Var_Samp_Order_By>;
  variance?: Maybe<Hasura_Worker_Tenants_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Arr_Rel_Insert_Input = {
  data: Array<Hasura_Worker_Tenants_Insert_Input>;
};

/** aggregate avg on columns */
export type Hasura_Worker_Tenants_Avg_Fields = {
  __typename?: 'hasura_worker_tenants_avg_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Avg_Order_By = {
  port?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "hasura_worker_tenants". All fields are combined with a logical 'AND'. */
export type Hasura_Worker_Tenants_Bool_Exp = {
  _and?: Maybe<Array<Hasura_Worker_Tenants_Bool_Exp>>;
  _not?: Maybe<Hasura_Worker_Tenants_Bool_Exp>;
  _or?: Maybe<Array<Hasura_Worker_Tenants_Bool_Exp>>;
  group_id?: Maybe<Uuid_Comparison_Exp>;
  hash?: Maybe<String_Comparison_Exp>;
  policies?: Maybe<Json_Comparison_Exp>;
  port?: Maybe<Int_Comparison_Exp>;
  tenant?: Maybe<Tenant_Bool_Exp>;
  tenant_id?: Maybe<Uuid_Comparison_Exp>;
  vault_path?: Maybe<String_Comparison_Exp>;
  worker_id?: Maybe<Uuid_Comparison_Exp>;
};

/** input type for inserting data into table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Insert_Input = {
  group_id?: Maybe<Scalars['uuid']>;
  hash?: Maybe<Scalars['String']>;
  policies?: Maybe<Scalars['json']>;
  port?: Maybe<Scalars['Int']>;
  tenant?: Maybe<Tenant_Obj_Rel_Insert_Input>;
  tenant_id?: Maybe<Scalars['uuid']>;
  vault_path?: Maybe<Scalars['String']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Hasura_Worker_Tenants_Max_Fields = {
  __typename?: 'hasura_worker_tenants_max_fields';
  group_id?: Maybe<Scalars['uuid']>;
  hash?: Maybe<Scalars['String']>;
  port?: Maybe<Scalars['Int']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  vault_path?: Maybe<Scalars['String']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Max_Order_By = {
  group_id?: Maybe<Order_By>;
  hash?: Maybe<Order_By>;
  port?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  vault_path?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Hasura_Worker_Tenants_Min_Fields = {
  __typename?: 'hasura_worker_tenants_min_fields';
  group_id?: Maybe<Scalars['uuid']>;
  hash?: Maybe<Scalars['String']>;
  port?: Maybe<Scalars['Int']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  vault_path?: Maybe<Scalars['String']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Min_Order_By = {
  group_id?: Maybe<Order_By>;
  hash?: Maybe<Order_By>;
  port?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  vault_path?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** Ordering options when selecting data from "hasura_worker_tenants". */
export type Hasura_Worker_Tenants_Order_By = {
  group_id?: Maybe<Order_By>;
  hash?: Maybe<Order_By>;
  policies?: Maybe<Order_By>;
  port?: Maybe<Order_By>;
  tenant?: Maybe<Tenant_Order_By>;
  tenant_id?: Maybe<Order_By>;
  vault_path?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** select columns of table "hasura_worker_tenants" */
export enum Hasura_Worker_Tenants_Select_Column {
  /** column name */
  GroupId = 'group_id',
  /** column name */
  Hash = 'hash',
  /** column name */
  Policies = 'policies',
  /** column name */
  Port = 'port',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  VaultPath = 'vault_path',
  /** column name */
  WorkerId = 'worker_id',
}

/** aggregate stddev on columns */
export type Hasura_Worker_Tenants_Stddev_Fields = {
  __typename?: 'hasura_worker_tenants_stddev_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Stddev_Order_By = {
  port?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Hasura_Worker_Tenants_Stddev_Pop_Fields = {
  __typename?: 'hasura_worker_tenants_stddev_pop_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Stddev_Pop_Order_By = {
  port?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Hasura_Worker_Tenants_Stddev_Samp_Fields = {
  __typename?: 'hasura_worker_tenants_stddev_samp_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Stddev_Samp_Order_By = {
  port?: Maybe<Order_By>;
};

/** Streaming cursor of the table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Hasura_Worker_Tenants_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Hasura_Worker_Tenants_Stream_Cursor_Value_Input = {
  group_id?: Maybe<Scalars['uuid']>;
  hash?: Maybe<Scalars['String']>;
  policies?: Maybe<Scalars['json']>;
  port?: Maybe<Scalars['Int']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  vault_path?: Maybe<Scalars['String']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Hasura_Worker_Tenants_Sum_Fields = {
  __typename?: 'hasura_worker_tenants_sum_fields';
  port?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Sum_Order_By = {
  port?: Maybe<Order_By>;
};

/** aggregate var_pop on columns */
export type Hasura_Worker_Tenants_Var_Pop_Fields = {
  __typename?: 'hasura_worker_tenants_var_pop_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Var_Pop_Order_By = {
  port?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Hasura_Worker_Tenants_Var_Samp_Fields = {
  __typename?: 'hasura_worker_tenants_var_samp_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Var_Samp_Order_By = {
  port?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Hasura_Worker_Tenants_Variance_Fields = {
  __typename?: 'hasura_worker_tenants_variance_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "hasura_worker_tenants" */
export type Hasura_Worker_Tenants_Variance_Order_By = {
  port?: Maybe<Order_By>;
};

/** update columns of table "hasura_worker" */
export enum Hasura_Worker_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  ClusterId = 'cluster_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Zone = 'zone',
}

export type Hasura_Worker_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Hasura_Worker_Set_Input>;
  /** filter the rows which have to be updated */
  where: Hasura_Worker_Bool_Exp;
};

/** heroku integration metadata (1.4+) */
export type Heroku_Integrations = {
  __typename?: 'heroku_integrations';
  /** The agent through which the integration is created */
  agent: Scalars['String'];
  app_id: Scalars['String'];
  app_name: Scalars['String'];
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
  var_name: Scalars['String'];
  webhook_id?: Maybe<Scalars['String']>;
};

/** aggregated selection of "heroku_integrations" */
export type Heroku_Integrations_Aggregate = {
  __typename?: 'heroku_integrations_aggregate';
  aggregate?: Maybe<Heroku_Integrations_Aggregate_Fields>;
  nodes: Array<Heroku_Integrations>;
};

export type Heroku_Integrations_Aggregate_Bool_Exp = {
  count?: Maybe<Heroku_Integrations_Aggregate_Bool_Exp_Count>;
};

export type Heroku_Integrations_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Heroku_Integrations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Heroku_Integrations_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "heroku_integrations" */
export type Heroku_Integrations_Aggregate_Fields = {
  __typename?: 'heroku_integrations_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Heroku_Integrations_Max_Fields>;
  min?: Maybe<Heroku_Integrations_Min_Fields>;
};

/** aggregate fields of "heroku_integrations" */
export type Heroku_Integrations_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Heroku_Integrations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "heroku_integrations" */
export type Heroku_Integrations_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Heroku_Integrations_Max_Order_By>;
  min?: Maybe<Heroku_Integrations_Min_Order_By>;
};

/** input type for inserting array relation for remote table "heroku_integrations" */
export type Heroku_Integrations_Arr_Rel_Insert_Input = {
  data: Array<Heroku_Integrations_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Heroku_Integrations_On_Conflict>;
};

/** Boolean expression to filter rows from the table "heroku_integrations". All fields are combined with a logical 'AND'. */
export type Heroku_Integrations_Bool_Exp = {
  _and?: Maybe<Array<Heroku_Integrations_Bool_Exp>>;
  _not?: Maybe<Heroku_Integrations_Bool_Exp>;
  _or?: Maybe<Array<Heroku_Integrations_Bool_Exp>>;
  agent?: Maybe<String_Comparison_Exp>;
  app_id?: Maybe<String_Comparison_Exp>;
  app_name?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  var_name?: Maybe<String_Comparison_Exp>;
  webhook_id?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "heroku_integrations" */
export enum Heroku_Integrations_Constraint {
  /** unique or primary key constraint on columns "project_id", "var_name" */
  HerokuIntegrationsPkey = 'heroku_integrations_pkey',
}

/** input type for inserting data into table "heroku_integrations" */
export type Heroku_Integrations_Insert_Input = {
  /** The agent through which the integration is created */
  agent?: Maybe<Scalars['String']>;
  app_id?: Maybe<Scalars['String']>;
  app_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  var_name?: Maybe<Scalars['String']>;
  webhook_id?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Heroku_Integrations_Max_Fields = {
  __typename?: 'heroku_integrations_max_fields';
  /** The agent through which the integration is created */
  agent?: Maybe<Scalars['String']>;
  app_id?: Maybe<Scalars['String']>;
  app_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  var_name?: Maybe<Scalars['String']>;
  webhook_id?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "heroku_integrations" */
export type Heroku_Integrations_Max_Order_By = {
  /** The agent through which the integration is created */
  agent?: Maybe<Order_By>;
  app_id?: Maybe<Order_By>;
  app_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  var_name?: Maybe<Order_By>;
  webhook_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Heroku_Integrations_Min_Fields = {
  __typename?: 'heroku_integrations_min_fields';
  /** The agent through which the integration is created */
  agent?: Maybe<Scalars['String']>;
  app_id?: Maybe<Scalars['String']>;
  app_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  var_name?: Maybe<Scalars['String']>;
  webhook_id?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "heroku_integrations" */
export type Heroku_Integrations_Min_Order_By = {
  /** The agent through which the integration is created */
  agent?: Maybe<Order_By>;
  app_id?: Maybe<Order_By>;
  app_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  var_name?: Maybe<Order_By>;
  webhook_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "heroku_integrations" */
export type Heroku_Integrations_Mutation_Response = {
  __typename?: 'heroku_integrations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Heroku_Integrations>;
};

/** on_conflict condition type for table "heroku_integrations" */
export type Heroku_Integrations_On_Conflict = {
  constraint: Heroku_Integrations_Constraint;
  update_columns?: Array<Heroku_Integrations_Update_Column>;
  where?: Maybe<Heroku_Integrations_Bool_Exp>;
};

/** Ordering options when selecting data from "heroku_integrations". */
export type Heroku_Integrations_Order_By = {
  agent?: Maybe<Order_By>;
  app_id?: Maybe<Order_By>;
  app_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  var_name?: Maybe<Order_By>;
  webhook_id?: Maybe<Order_By>;
};

/** primary key columns input for table: heroku_integrations */
export type Heroku_Integrations_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
  var_name: Scalars['String'];
};

/** select columns of table "heroku_integrations" */
export enum Heroku_Integrations_Select_Column {
  /** column name */
  Agent = 'agent',
  /** column name */
  AppId = 'app_id',
  /** column name */
  AppName = 'app_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VarName = 'var_name',
  /** column name */
  WebhookId = 'webhook_id',
}

/** input type for updating data in table "heroku_integrations" */
export type Heroku_Integrations_Set_Input = {
  /** The agent through which the integration is created */
  agent?: Maybe<Scalars['String']>;
  app_id?: Maybe<Scalars['String']>;
  app_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  var_name?: Maybe<Scalars['String']>;
  webhook_id?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "heroku_integrations" */
export type Heroku_Integrations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Heroku_Integrations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Heroku_Integrations_Stream_Cursor_Value_Input = {
  /** The agent through which the integration is created */
  agent?: Maybe<Scalars['String']>;
  app_id?: Maybe<Scalars['String']>;
  app_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  var_name?: Maybe<Scalars['String']>;
  webhook_id?: Maybe<Scalars['String']>;
};

/** update columns of table "heroku_integrations" */
export enum Heroku_Integrations_Update_Column {
  /** column name */
  Agent = 'agent',
  /** column name */
  AppId = 'app_id',
  /** column name */
  AppName = 'app_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VarName = 'var_name',
  /** column name */
  WebhookId = 'webhook_id',
}

export type Heroku_Integrations_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Heroku_Integrations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Heroku_Integrations_Bool_Exp;
};

export type HerokuSession = {
  __typename?: 'HerokuSession';
  access_token: Scalars['String'];
  expires_in: Scalars['Int'];
  refresh_token: Scalars['String'];
  token_type: Scalars['String'];
};

export type HerokuSessionStatus = {
  __typename?: 'HerokuSessionStatus';
  status: Scalars['String'];
};

export type HerokuTokenExchangeInput = {
  type: HerokuTokenExchangeType;
  value: Scalars['String'];
};

export enum HerokuTokenExchangeType {
  Code = 'code',
  Refresh = 'refresh',
}

/** Records projects that are excluded from suspension */
export type Inactive_Project_Exclusions = {
  __typename?: 'inactive_project_exclusions';
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
};

/** aggregated selection of "inactive_project_exclusions" */
export type Inactive_Project_Exclusions_Aggregate = {
  __typename?: 'inactive_project_exclusions_aggregate';
  aggregate?: Maybe<Inactive_Project_Exclusions_Aggregate_Fields>;
  nodes: Array<Inactive_Project_Exclusions>;
};

/** aggregate fields of "inactive_project_exclusions" */
export type Inactive_Project_Exclusions_Aggregate_Fields = {
  __typename?: 'inactive_project_exclusions_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Inactive_Project_Exclusions_Max_Fields>;
  min?: Maybe<Inactive_Project_Exclusions_Min_Fields>;
};

/** aggregate fields of "inactive_project_exclusions" */
export type Inactive_Project_Exclusions_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Inactive_Project_Exclusions_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/**
 * Boolean expression to filter rows from the table "inactive_project_exclusions".
 * All fields are combined with a logical 'AND'.
 */
export type Inactive_Project_Exclusions_Bool_Exp = {
  _and?: Maybe<Array<Inactive_Project_Exclusions_Bool_Exp>>;
  _not?: Maybe<Inactive_Project_Exclusions_Bool_Exp>;
  _or?: Maybe<Array<Inactive_Project_Exclusions_Bool_Exp>>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "inactive_project_exclusions" */
export enum Inactive_Project_Exclusions_Constraint {
  /** unique or primary key constraint on columns "project_id" */
  InactiveProjectExclusionsPkey = 'inactive_project_exclusions_pkey',
}

/** input type for inserting data into table "inactive_project_exclusions" */
export type Inactive_Project_Exclusions_Insert_Input = {
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Inactive_Project_Exclusions_Max_Fields = {
  __typename?: 'inactive_project_exclusions_max_fields';
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Inactive_Project_Exclusions_Min_Fields = {
  __typename?: 'inactive_project_exclusions_min_fields';
  project_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "inactive_project_exclusions" */
export type Inactive_Project_Exclusions_Mutation_Response = {
  __typename?: 'inactive_project_exclusions_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Inactive_Project_Exclusions>;
};

/** on_conflict condition type for table "inactive_project_exclusions" */
export type Inactive_Project_Exclusions_On_Conflict = {
  constraint: Inactive_Project_Exclusions_Constraint;
  update_columns?: Array<Inactive_Project_Exclusions_Update_Column>;
  where?: Maybe<Inactive_Project_Exclusions_Bool_Exp>;
};

/** Ordering options when selecting data from "inactive_project_exclusions". */
export type Inactive_Project_Exclusions_Order_By = {
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
};

/** primary key columns input for table: inactive_project_exclusions */
export type Inactive_Project_Exclusions_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
};

/** select columns of table "inactive_project_exclusions" */
export enum Inactive_Project_Exclusions_Select_Column {
  /** column name */
  ProjectId = 'project_id',
}

/** input type for updating data in table "inactive_project_exclusions" */
export type Inactive_Project_Exclusions_Set_Input = {
  project_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "inactive_project_exclusions" */
export type Inactive_Project_Exclusions_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Inactive_Project_Exclusions_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Inactive_Project_Exclusions_Stream_Cursor_Value_Input = {
  project_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "inactive_project_exclusions" */
export enum Inactive_Project_Exclusions_Update_Column {
  /** column name */
  ProjectId = 'project_id',
}

export type Inactive_Project_Exclusions_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Inactive_Project_Exclusions_Set_Input>;
  /** filter the rows which have to be updated */
  where: Inactive_Project_Exclusions_Bool_Exp;
};

/** Records when the user has been notified about their projects being inactive */
export type Inactive_Project_Notifications = {
  __typename?: 'inactive_project_notifications';
  active: Scalars['Boolean'];
  id: Scalars['Int'];
  is_legacy_schedule: Scalars['Boolean'];
  /** An object relationship */
  owner: Users;
  owner_id: Scalars['uuid'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  sent_at: Scalars['timestamp'];
};

/** aggregated selection of "inactive_project_notifications" */
export type Inactive_Project_Notifications_Aggregate = {
  __typename?: 'inactive_project_notifications_aggregate';
  aggregate?: Maybe<Inactive_Project_Notifications_Aggregate_Fields>;
  nodes: Array<Inactive_Project_Notifications>;
};

/** aggregate fields of "inactive_project_notifications" */
export type Inactive_Project_Notifications_Aggregate_Fields = {
  __typename?: 'inactive_project_notifications_aggregate_fields';
  avg?: Maybe<Inactive_Project_Notifications_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Inactive_Project_Notifications_Max_Fields>;
  min?: Maybe<Inactive_Project_Notifications_Min_Fields>;
  stddev?: Maybe<Inactive_Project_Notifications_Stddev_Fields>;
  stddev_pop?: Maybe<Inactive_Project_Notifications_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Inactive_Project_Notifications_Stddev_Samp_Fields>;
  sum?: Maybe<Inactive_Project_Notifications_Sum_Fields>;
  var_pop?: Maybe<Inactive_Project_Notifications_Var_Pop_Fields>;
  var_samp?: Maybe<Inactive_Project_Notifications_Var_Samp_Fields>;
  variance?: Maybe<Inactive_Project_Notifications_Variance_Fields>;
};

/** aggregate fields of "inactive_project_notifications" */
export type Inactive_Project_Notifications_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Inactive_Project_Notifications_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Inactive_Project_Notifications_Avg_Fields = {
  __typename?: 'inactive_project_notifications_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table
 * "inactive_project_notifications". All fields are combined with a logical 'AND'.
 */
export type Inactive_Project_Notifications_Bool_Exp = {
  _and?: Maybe<Array<Inactive_Project_Notifications_Bool_Exp>>;
  _not?: Maybe<Inactive_Project_Notifications_Bool_Exp>;
  _or?: Maybe<Array<Inactive_Project_Notifications_Bool_Exp>>;
  active?: Maybe<Boolean_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  is_legacy_schedule?: Maybe<Boolean_Comparison_Exp>;
  owner?: Maybe<Users_Bool_Exp>;
  owner_id?: Maybe<Uuid_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  sent_at?: Maybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "inactive_project_notifications" */
export enum Inactive_Project_Notifications_Constraint {
  /** unique or primary key constraint on columns "id" */
  InactiveProjectNotificationsPkey = 'inactive_project_notifications_pkey',
}

/** input type for incrementing numeric columns in table "inactive_project_notifications" */
export type Inactive_Project_Notifications_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "inactive_project_notifications" */
export type Inactive_Project_Notifications_Insert_Input = {
  active?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  is_legacy_schedule?: Maybe<Scalars['Boolean']>;
  owner?: Maybe<Users_Obj_Rel_Insert_Input>;
  owner_id?: Maybe<Scalars['uuid']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  sent_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Inactive_Project_Notifications_Max_Fields = {
  __typename?: 'inactive_project_notifications_max_fields';
  id?: Maybe<Scalars['Int']>;
  owner_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  sent_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type Inactive_Project_Notifications_Min_Fields = {
  __typename?: 'inactive_project_notifications_min_fields';
  id?: Maybe<Scalars['Int']>;
  owner_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  sent_at?: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "inactive_project_notifications" */
export type Inactive_Project_Notifications_Mutation_Response = {
  __typename?: 'inactive_project_notifications_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Inactive_Project_Notifications>;
};

/** on_conflict condition type for table "inactive_project_notifications" */
export type Inactive_Project_Notifications_On_Conflict = {
  constraint: Inactive_Project_Notifications_Constraint;
  update_columns?: Array<Inactive_Project_Notifications_Update_Column>;
  where?: Maybe<Inactive_Project_Notifications_Bool_Exp>;
};

/** Ordering options when selecting data from "inactive_project_notifications". */
export type Inactive_Project_Notifications_Order_By = {
  active?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_legacy_schedule?: Maybe<Order_By>;
  owner?: Maybe<Users_Order_By>;
  owner_id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  sent_at?: Maybe<Order_By>;
};

/** primary key columns input for table: inactive_project_notifications */
export type Inactive_Project_Notifications_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "inactive_project_notifications" */
export enum Inactive_Project_Notifications_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Id = 'id',
  /** column name */
  IsLegacySchedule = 'is_legacy_schedule',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  SentAt = 'sent_at',
}

/** input type for updating data in table "inactive_project_notifications" */
export type Inactive_Project_Notifications_Set_Input = {
  active?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  is_legacy_schedule?: Maybe<Scalars['Boolean']>;
  owner_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  sent_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Inactive_Project_Notifications_Stddev_Fields = {
  __typename?: 'inactive_project_notifications_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Inactive_Project_Notifications_Stddev_Pop_Fields = {
  __typename?: 'inactive_project_notifications_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Inactive_Project_Notifications_Stddev_Samp_Fields = {
  __typename?: 'inactive_project_notifications_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "inactive_project_notifications" */
export type Inactive_Project_Notifications_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Inactive_Project_Notifications_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Inactive_Project_Notifications_Stream_Cursor_Value_Input = {
  active?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['Int']>;
  is_legacy_schedule?: Maybe<Scalars['Boolean']>;
  owner_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  sent_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate sum on columns */
export type Inactive_Project_Notifications_Sum_Fields = {
  __typename?: 'inactive_project_notifications_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** update columns of table "inactive_project_notifications" */
export enum Inactive_Project_Notifications_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Id = 'id',
  /** column name */
  IsLegacySchedule = 'is_legacy_schedule',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  SentAt = 'sent_at',
}

export type Inactive_Project_Notifications_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Inactive_Project_Notifications_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Inactive_Project_Notifications_Set_Input>;
  /** filter the rows which have to be updated */
  where: Inactive_Project_Notifications_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Inactive_Project_Notifications_Var_Pop_Fields = {
  __typename?: 'inactive_project_notifications_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Inactive_Project_Notifications_Var_Samp_Fields = {
  __typename?: 'inactive_project_notifications_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Inactive_Project_Notifications_Variance_Fields = {
  __typename?: 'inactive_project_notifications_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Allows for progressive rollout of inactive_project_suspension. App code will take latest record to base their decisions */
export type Inactive_Project_Suspension_Config = {
  __typename?: 'inactive_project_suspension_config';
  created_at: Scalars['timestamp'];
  enabled_per_thousand?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "inactive_project_suspension_config" */
export type Inactive_Project_Suspension_Config_Aggregate = {
  __typename?: 'inactive_project_suspension_config_aggregate';
  aggregate?: Maybe<Inactive_Project_Suspension_Config_Aggregate_Fields>;
  nodes: Array<Inactive_Project_Suspension_Config>;
};

/** aggregate fields of "inactive_project_suspension_config" */
export type Inactive_Project_Suspension_Config_Aggregate_Fields = {
  __typename?: 'inactive_project_suspension_config_aggregate_fields';
  avg?: Maybe<Inactive_Project_Suspension_Config_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Inactive_Project_Suspension_Config_Max_Fields>;
  min?: Maybe<Inactive_Project_Suspension_Config_Min_Fields>;
  stddev?: Maybe<Inactive_Project_Suspension_Config_Stddev_Fields>;
  stddev_pop?: Maybe<Inactive_Project_Suspension_Config_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Inactive_Project_Suspension_Config_Stddev_Samp_Fields>;
  sum?: Maybe<Inactive_Project_Suspension_Config_Sum_Fields>;
  var_pop?: Maybe<Inactive_Project_Suspension_Config_Var_Pop_Fields>;
  var_samp?: Maybe<Inactive_Project_Suspension_Config_Var_Samp_Fields>;
  variance?: Maybe<Inactive_Project_Suspension_Config_Variance_Fields>;
};

/** aggregate fields of "inactive_project_suspension_config" */
export type Inactive_Project_Suspension_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Inactive_Project_Suspension_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Inactive_Project_Suspension_Config_Avg_Fields = {
  __typename?: 'inactive_project_suspension_config_avg_fields';
  enabled_per_thousand?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table
 * "inactive_project_suspension_config". All fields are combined with a logical 'AND'.
 */
export type Inactive_Project_Suspension_Config_Bool_Exp = {
  _and?: Maybe<Array<Inactive_Project_Suspension_Config_Bool_Exp>>;
  _not?: Maybe<Inactive_Project_Suspension_Config_Bool_Exp>;
  _or?: Maybe<Array<Inactive_Project_Suspension_Config_Bool_Exp>>;
  created_at?: Maybe<Timestamp_Comparison_Exp>;
  enabled_per_thousand?: Maybe<Int_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "inactive_project_suspension_config" */
export type Inactive_Project_Suspension_Config_Inc_Input = {
  enabled_per_thousand?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "inactive_project_suspension_config" */
export type Inactive_Project_Suspension_Config_Insert_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  enabled_per_thousand?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Inactive_Project_Suspension_Config_Max_Fields = {
  __typename?: 'inactive_project_suspension_config_max_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  enabled_per_thousand?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Inactive_Project_Suspension_Config_Min_Fields = {
  __typename?: 'inactive_project_suspension_config_min_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  enabled_per_thousand?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "inactive_project_suspension_config" */
export type Inactive_Project_Suspension_Config_Mutation_Response = {
  __typename?: 'inactive_project_suspension_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Inactive_Project_Suspension_Config>;
};

/** Ordering options when selecting data from "inactive_project_suspension_config". */
export type Inactive_Project_Suspension_Config_Order_By = {
  created_at?: Maybe<Order_By>;
  enabled_per_thousand?: Maybe<Order_By>;
};

/** select columns of table "inactive_project_suspension_config" */
export enum Inactive_Project_Suspension_Config_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EnabledPerThousand = 'enabled_per_thousand',
}

/** input type for updating data in table "inactive_project_suspension_config" */
export type Inactive_Project_Suspension_Config_Set_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  enabled_per_thousand?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Inactive_Project_Suspension_Config_Stddev_Fields = {
  __typename?: 'inactive_project_suspension_config_stddev_fields';
  enabled_per_thousand?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Inactive_Project_Suspension_Config_Stddev_Pop_Fields = {
  __typename?: 'inactive_project_suspension_config_stddev_pop_fields';
  enabled_per_thousand?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Inactive_Project_Suspension_Config_Stddev_Samp_Fields = {
  __typename?: 'inactive_project_suspension_config_stddev_samp_fields';
  enabled_per_thousand?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "inactive_project_suspension_config" */
export type Inactive_Project_Suspension_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Inactive_Project_Suspension_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Inactive_Project_Suspension_Config_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  enabled_per_thousand?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Inactive_Project_Suspension_Config_Sum_Fields = {
  __typename?: 'inactive_project_suspension_config_sum_fields';
  enabled_per_thousand?: Maybe<Scalars['Int']>;
};

export type Inactive_Project_Suspension_Config_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Inactive_Project_Suspension_Config_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Inactive_Project_Suspension_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Inactive_Project_Suspension_Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Inactive_Project_Suspension_Config_Var_Pop_Fields = {
  __typename?: 'inactive_project_suspension_config_var_pop_fields';
  enabled_per_thousand?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Inactive_Project_Suspension_Config_Var_Samp_Fields = {
  __typename?: 'inactive_project_suspension_config_var_samp_fields';
  enabled_per_thousand?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Inactive_Project_Suspension_Config_Variance_Fields = {
  __typename?: 'inactive_project_suspension_config_variance_fields';
  enabled_per_thousand?: Maybe<Scalars['Float']>;
};

/** Free Projects with at least 25 days of continuous inactivity without a notification in at least 7 days */
export type Inactive_Projects = {
  __typename?: 'inactive_projects';
  inactive_since?: Maybe<Scalars['timestamptz']>;
  is_legacy_schedule?: Maybe<Scalars['Boolean']>;
  latest_notified?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  project?: Maybe<Projects>;
  project_created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  times_notified?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "inactive_projects" */
export type Inactive_Projects_Aggregate = {
  __typename?: 'inactive_projects_aggregate';
  aggregate?: Maybe<Inactive_Projects_Aggregate_Fields>;
  nodes: Array<Inactive_Projects>;
};

/** aggregate fields of "inactive_projects" */
export type Inactive_Projects_Aggregate_Fields = {
  __typename?: 'inactive_projects_aggregate_fields';
  avg?: Maybe<Inactive_Projects_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Inactive_Projects_Max_Fields>;
  min?: Maybe<Inactive_Projects_Min_Fields>;
  stddev?: Maybe<Inactive_Projects_Stddev_Fields>;
  stddev_pop?: Maybe<Inactive_Projects_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Inactive_Projects_Stddev_Samp_Fields>;
  sum?: Maybe<Inactive_Projects_Sum_Fields>;
  var_pop?: Maybe<Inactive_Projects_Var_Pop_Fields>;
  var_samp?: Maybe<Inactive_Projects_Var_Samp_Fields>;
  variance?: Maybe<Inactive_Projects_Variance_Fields>;
};

/** aggregate fields of "inactive_projects" */
export type Inactive_Projects_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Inactive_Projects_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Inactive_Projects_Avg_Fields = {
  __typename?: 'inactive_projects_avg_fields';
  times_notified?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "inactive_projects". All fields are combined with a logical 'AND'. */
export type Inactive_Projects_Bool_Exp = {
  _and?: Maybe<Array<Inactive_Projects_Bool_Exp>>;
  _not?: Maybe<Inactive_Projects_Bool_Exp>;
  _or?: Maybe<Array<Inactive_Projects_Bool_Exp>>;
  inactive_since?: Maybe<Timestamptz_Comparison_Exp>;
  is_legacy_schedule?: Maybe<Boolean_Comparison_Exp>;
  latest_notified?: Maybe<Timestamptz_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_created_at?: Maybe<Timestamptz_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  times_notified?: Maybe<Bigint_Comparison_Exp>;
};

/** aggregate max on columns */
export type Inactive_Projects_Max_Fields = {
  __typename?: 'inactive_projects_max_fields';
  inactive_since?: Maybe<Scalars['timestamptz']>;
  latest_notified?: Maybe<Scalars['timestamptz']>;
  project_created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  times_notified?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Inactive_Projects_Min_Fields = {
  __typename?: 'inactive_projects_min_fields';
  inactive_since?: Maybe<Scalars['timestamptz']>;
  latest_notified?: Maybe<Scalars['timestamptz']>;
  project_created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  times_notified?: Maybe<Scalars['bigint']>;
};

/** Ordering options when selecting data from "inactive_projects". */
export type Inactive_Projects_Order_By = {
  inactive_since?: Maybe<Order_By>;
  is_legacy_schedule?: Maybe<Order_By>;
  latest_notified?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_created_at?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  times_notified?: Maybe<Order_By>;
};

/** select columns of table "inactive_projects" */
export enum Inactive_Projects_Select_Column {
  /** column name */
  InactiveSince = 'inactive_since',
  /** column name */
  IsLegacySchedule = 'is_legacy_schedule',
  /** column name */
  LatestNotified = 'latest_notified',
  /** column name */
  ProjectCreatedAt = 'project_created_at',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  TimesNotified = 'times_notified',
}

/** aggregate stddev on columns */
export type Inactive_Projects_Stddev_Fields = {
  __typename?: 'inactive_projects_stddev_fields';
  times_notified?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Inactive_Projects_Stddev_Pop_Fields = {
  __typename?: 'inactive_projects_stddev_pop_fields';
  times_notified?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Inactive_Projects_Stddev_Samp_Fields = {
  __typename?: 'inactive_projects_stddev_samp_fields';
  times_notified?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "inactive_projects" */
export type Inactive_Projects_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Inactive_Projects_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Inactive_Projects_Stream_Cursor_Value_Input = {
  inactive_since?: Maybe<Scalars['timestamptz']>;
  is_legacy_schedule?: Maybe<Scalars['Boolean']>;
  latest_notified?: Maybe<Scalars['timestamptz']>;
  project_created_at?: Maybe<Scalars['timestamptz']>;
  project_id?: Maybe<Scalars['uuid']>;
  times_notified?: Maybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Inactive_Projects_Sum_Fields = {
  __typename?: 'inactive_projects_sum_fields';
  times_notified?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Inactive_Projects_Var_Pop_Fields = {
  __typename?: 'inactive_projects_var_pop_fields';
  times_notified?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Inactive_Projects_Var_Samp_Fields = {
  __typename?: 'inactive_projects_var_samp_fields';
  times_notified?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Inactive_Projects_Variance_Fields = {
  __typename?: 'inactive_projects_variance_fields';
  times_notified?: Maybe<Scalars['Float']>;
};

/** Hasura enum capturing the Terraform status of infra */
export type Infra_Status = {
  __typename?: 'infra_status';
  comment?: Maybe<Scalars['String']>;
  status: Scalars['String'];
};

/** aggregated selection of "infra_status" */
export type Infra_Status_Aggregate = {
  __typename?: 'infra_status_aggregate';
  aggregate?: Maybe<Infra_Status_Aggregate_Fields>;
  nodes: Array<Infra_Status>;
};

/** aggregate fields of "infra_status" */
export type Infra_Status_Aggregate_Fields = {
  __typename?: 'infra_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Infra_Status_Max_Fields>;
  min?: Maybe<Infra_Status_Min_Fields>;
};

/** aggregate fields of "infra_status" */
export type Infra_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Infra_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "infra_status". All fields are combined with a logical 'AND'. */
export type Infra_Status_Bool_Exp = {
  _and?: Maybe<Array<Infra_Status_Bool_Exp>>;
  _not?: Maybe<Infra_Status_Bool_Exp>;
  _or?: Maybe<Array<Infra_Status_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "infra_status" */
export enum Infra_Status_Constraint {
  /** unique or primary key constraint on columns "status" */
  InfraStatusPkey = 'infra_status_pkey',
}

export enum Infra_Status_Enum {
  /** Changes have been applied */
  Applied = 'applied',
  /** Failed to apply changes to infra */
  ApplyFailed = 'apply_failed',
  /** Destroying infra failed */
  DestroyFailed = 'destroy_failed',
  /** Infra has been destroyed */
  Destroyed = 'destroyed',
  /** Waiting for the terraform apply */
  PendingApply = 'pending_apply',
  /** Waiting for the terraform destroy */
  PendingDestroy = 'pending_destroy',
}

/** Boolean expression to compare columns of type "infra_status_enum". All fields are combined with logical 'AND'. */
export type Infra_Status_Enum_Comparison_Exp = {
  _eq?: Maybe<Infra_Status_Enum>;
  _in?: Maybe<Array<Infra_Status_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Infra_Status_Enum>;
  _nin?: Maybe<Array<Infra_Status_Enum>>;
};

/** input type for inserting data into table "infra_status" */
export type Infra_Status_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Infra_Status_Max_Fields = {
  __typename?: 'infra_status_max_fields';
  comment?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Infra_Status_Min_Fields = {
  __typename?: 'infra_status_min_fields';
  comment?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "infra_status" */
export type Infra_Status_Mutation_Response = {
  __typename?: 'infra_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Infra_Status>;
};

/** on_conflict condition type for table "infra_status" */
export type Infra_Status_On_Conflict = {
  constraint: Infra_Status_Constraint;
  update_columns?: Array<Infra_Status_Update_Column>;
  where?: Maybe<Infra_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "infra_status". */
export type Infra_Status_Order_By = {
  comment?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
};

/** primary key columns input for table: infra_status */
export type Infra_Status_Pk_Columns_Input = {
  status: Scalars['String'];
};

/** select columns of table "infra_status" */
export enum Infra_Status_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Status = 'status',
}

/** input type for updating data in table "infra_status" */
export type Infra_Status_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "infra_status" */
export type Infra_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Infra_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Infra_Status_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
};

/** update columns of table "infra_status" */
export enum Infra_Status_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Status = 'status',
}

export type Infra_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Infra_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Infra_Status_Bool_Exp;
};

export type Insert_Db_Usage_Args = {
  created_ats?: Maybe<Scalars['_date']>;
  no_db_usages?: Maybe<Scalars['_int4']>;
  non_pg_usages?: Maybe<Scalars['_int4']>;
  pg_usages?: Maybe<Scalars['_int4']>;
  prices?: Maybe<Scalars['_int8']>;
  project_ids?: Maybe<Scalars['_uuid']>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: Maybe<Scalars['Int']>;
  _gt?: Maybe<Scalars['Int']>;
  _gte?: Maybe<Scalars['Int']>;
  _in?: Maybe<Array<Scalars['Int']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['Int']>;
  _lte?: Maybe<Scalars['Int']>;
  _neq?: Maybe<Scalars['Int']>;
  _nin?: Maybe<Array<Scalars['Int']>>;
};

export type IntercomHashResponse = {
  __typename?: 'intercomHashResponse';
  hash: Scalars['String'];
};

export type InviteColloboratorRequest = {
  collaborator_email: Scalars['String'];
  privileges: Array<Scalars['String']>;
  project_id: Scalars['uuid'];
};

/** Customer invoice for Hasura Cloud services */
export type Invoice = {
  __typename?: 'invoice';
  attempt_count?: Maybe<Scalars['Int']>;
  collection_method: Scalars['String'];
  created_at?: Maybe<Scalars['timestamptz']>;
  /** customer id that represents unique customer at stripe */
  customer_id: Scalars['String'];
  /** any additional appropriate description for this invoice. This will be used on the UI */
  description: Scalars['String'];
  /** due amount of the invoice without coupons and credit applied */
  due_amount?: Maybe<Scalars['numeric']>;
  /** An array relationship */
  invoice_coupon_discounts: Array<Invoice_Coupon_Discount>;
  /** An aggregate relationship */
  invoice_coupon_discounts_aggregate: Invoice_Coupon_Discount_Aggregate;
  /** An array relationship */
  invoice_credit_usages: Array<Customer_Usage>;
  /** An aggregate relationship */
  invoice_credit_usages_aggregate: Customer_Usage_Aggregate;
  invoice_url?: Maybe<Scalars['String']>;
  /** An array relationship */
  items: Array<Invoice_Item>;
  /** An aggregate relationship */
  items_aggregate: Invoice_Item_Aggregate;
  /** represents month for which this invoice is for */
  month: Scalars['Int'];
  /** An object relationship */
  payment_method?: Maybe<Payment_Method>;
  payment_method_id?: Maybe<Scalars['String']>;
  receipt_url?: Maybe<Scalars['String']>;
  /** represents status of this invoice. It can be either `paid`, `failed`, `unpaid` */
  status: Scalars['String'];
  /** unique invoice id, represents invoice id at stripe */
  stripe_invoice_id: Scalars['String'];
  /** subscription for which the current invoice is generated for */
  subscription_id: Scalars['String'];
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  user?: Maybe<Users>;
  /** represents year for which this invoice is for */
  year: Scalars['Int'];
};

/** Customer invoice for Hasura Cloud services */
export type InvoiceInvoice_Coupon_DiscountsArgs = {
  distinct_on?: Maybe<Array<Invoice_Coupon_Discount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Coupon_Discount_Order_By>>;
  where?: Maybe<Invoice_Coupon_Discount_Bool_Exp>;
};

/** Customer invoice for Hasura Cloud services */
export type InvoiceInvoice_Coupon_Discounts_AggregateArgs = {
  distinct_on?: Maybe<Array<Invoice_Coupon_Discount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Coupon_Discount_Order_By>>;
  where?: Maybe<Invoice_Coupon_Discount_Bool_Exp>;
};

/** Customer invoice for Hasura Cloud services */
export type InvoiceInvoice_Credit_UsagesArgs = {
  distinct_on?: Maybe<Array<Customer_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Usage_Order_By>>;
  where?: Maybe<Customer_Usage_Bool_Exp>;
};

/** Customer invoice for Hasura Cloud services */
export type InvoiceInvoice_Credit_Usages_AggregateArgs = {
  distinct_on?: Maybe<Array<Customer_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Usage_Order_By>>;
  where?: Maybe<Customer_Usage_Bool_Exp>;
};

/** Customer invoice for Hasura Cloud services */
export type InvoiceItemsArgs = {
  distinct_on?: Maybe<Array<Invoice_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Item_Order_By>>;
  where?: Maybe<Invoice_Item_Bool_Exp>;
};

/** Customer invoice for Hasura Cloud services */
export type InvoiceItems_AggregateArgs = {
  distinct_on?: Maybe<Array<Invoice_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Item_Order_By>>;
  where?: Maybe<Invoice_Item_Bool_Exp>;
};

/** aggregated selection of "invoice" */
export type Invoice_Aggregate = {
  __typename?: 'invoice_aggregate';
  aggregate?: Maybe<Invoice_Aggregate_Fields>;
  nodes: Array<Invoice>;
};

export type Invoice_Aggregate_Bool_Exp = {
  count?: Maybe<Invoice_Aggregate_Bool_Exp_Count>;
};

export type Invoice_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Invoice_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Invoice_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "invoice" */
export type Invoice_Aggregate_Fields = {
  __typename?: 'invoice_aggregate_fields';
  avg?: Maybe<Invoice_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Invoice_Max_Fields>;
  min?: Maybe<Invoice_Min_Fields>;
  stddev?: Maybe<Invoice_Stddev_Fields>;
  stddev_pop?: Maybe<Invoice_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Invoice_Stddev_Samp_Fields>;
  sum?: Maybe<Invoice_Sum_Fields>;
  var_pop?: Maybe<Invoice_Var_Pop_Fields>;
  var_samp?: Maybe<Invoice_Var_Samp_Fields>;
  variance?: Maybe<Invoice_Variance_Fields>;
};

/** aggregate fields of "invoice" */
export type Invoice_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Invoice_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "invoice" */
export type Invoice_Aggregate_Order_By = {
  avg?: Maybe<Invoice_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Invoice_Max_Order_By>;
  min?: Maybe<Invoice_Min_Order_By>;
  stddev?: Maybe<Invoice_Stddev_Order_By>;
  stddev_pop?: Maybe<Invoice_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Invoice_Stddev_Samp_Order_By>;
  sum?: Maybe<Invoice_Sum_Order_By>;
  var_pop?: Maybe<Invoice_Var_Pop_Order_By>;
  var_samp?: Maybe<Invoice_Var_Samp_Order_By>;
  variance?: Maybe<Invoice_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "invoice" */
export type Invoice_Arr_Rel_Insert_Input = {
  data: Array<Invoice_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Invoice_On_Conflict>;
};

/** aggregate avg on columns */
export type Invoice_Avg_Fields = {
  __typename?: 'invoice_avg_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "invoice" */
export type Invoice_Avg_Order_By = {
  attempt_count?: Maybe<Order_By>;
  /** represents month for which this invoice is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice is for */
  year?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "invoice". All fields are combined with a logical 'AND'. */
export type Invoice_Bool_Exp = {
  _and?: Maybe<Array<Invoice_Bool_Exp>>;
  _not?: Maybe<Invoice_Bool_Exp>;
  _or?: Maybe<Array<Invoice_Bool_Exp>>;
  attempt_count?: Maybe<Int_Comparison_Exp>;
  collection_method?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customer_id?: Maybe<String_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  due_amount?: Maybe<Numeric_Comparison_Exp>;
  invoice_coupon_discounts?: Maybe<Invoice_Coupon_Discount_Bool_Exp>;
  invoice_coupon_discounts_aggregate?: Maybe<Invoice_Coupon_Discount_Aggregate_Bool_Exp>;
  invoice_credit_usages?: Maybe<Customer_Usage_Bool_Exp>;
  invoice_credit_usages_aggregate?: Maybe<Customer_Usage_Aggregate_Bool_Exp>;
  invoice_url?: Maybe<String_Comparison_Exp>;
  items?: Maybe<Invoice_Item_Bool_Exp>;
  items_aggregate?: Maybe<Invoice_Item_Aggregate_Bool_Exp>;
  month?: Maybe<Int_Comparison_Exp>;
  payment_method?: Maybe<Payment_Method_Bool_Exp>;
  payment_method_id?: Maybe<String_Comparison_Exp>;
  receipt_url?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  stripe_invoice_id?: Maybe<String_Comparison_Exp>;
  subscription_id?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  year?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "invoice" */
export enum Invoice_Constraint {
  /** unique or primary key constraint on columns "stripe_invoice_id" */
  InvoicePkey = 'invoice_pkey',
}

/** Discount coupon used on an invoice */
export type Invoice_Coupon_Discount = {
  __typename?: 'invoice_coupon_discount';
  amount: Scalars['numeric'];
  coupon_code: Scalars['String'];
  created_at: Scalars['timestamptz'];
  discount_type: Scalars['String'];
  inv_id: Scalars['String'];
  /** An object relationship */
  invoice?: Maybe<Invoice>;
};

/** aggregated selection of "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Aggregate = {
  __typename?: 'invoice_coupon_discount_aggregate';
  aggregate?: Maybe<Invoice_Coupon_Discount_Aggregate_Fields>;
  nodes: Array<Invoice_Coupon_Discount>;
};

export type Invoice_Coupon_Discount_Aggregate_Bool_Exp = {
  count?: Maybe<Invoice_Coupon_Discount_Aggregate_Bool_Exp_Count>;
};

export type Invoice_Coupon_Discount_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Invoice_Coupon_Discount_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Invoice_Coupon_Discount_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Aggregate_Fields = {
  __typename?: 'invoice_coupon_discount_aggregate_fields';
  avg?: Maybe<Invoice_Coupon_Discount_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Invoice_Coupon_Discount_Max_Fields>;
  min?: Maybe<Invoice_Coupon_Discount_Min_Fields>;
  stddev?: Maybe<Invoice_Coupon_Discount_Stddev_Fields>;
  stddev_pop?: Maybe<Invoice_Coupon_Discount_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Invoice_Coupon_Discount_Stddev_Samp_Fields>;
  sum?: Maybe<Invoice_Coupon_Discount_Sum_Fields>;
  var_pop?: Maybe<Invoice_Coupon_Discount_Var_Pop_Fields>;
  var_samp?: Maybe<Invoice_Coupon_Discount_Var_Samp_Fields>;
  variance?: Maybe<Invoice_Coupon_Discount_Variance_Fields>;
};

/** aggregate fields of "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Invoice_Coupon_Discount_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Aggregate_Order_By = {
  avg?: Maybe<Invoice_Coupon_Discount_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Invoice_Coupon_Discount_Max_Order_By>;
  min?: Maybe<Invoice_Coupon_Discount_Min_Order_By>;
  stddev?: Maybe<Invoice_Coupon_Discount_Stddev_Order_By>;
  stddev_pop?: Maybe<Invoice_Coupon_Discount_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Invoice_Coupon_Discount_Stddev_Samp_Order_By>;
  sum?: Maybe<Invoice_Coupon_Discount_Sum_Order_By>;
  var_pop?: Maybe<Invoice_Coupon_Discount_Var_Pop_Order_By>;
  var_samp?: Maybe<Invoice_Coupon_Discount_Var_Samp_Order_By>;
  variance?: Maybe<Invoice_Coupon_Discount_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Arr_Rel_Insert_Input = {
  data: Array<Invoice_Coupon_Discount_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Invoice_Coupon_Discount_On_Conflict>;
};

/** aggregate avg on columns */
export type Invoice_Coupon_Discount_Avg_Fields = {
  __typename?: 'invoice_coupon_discount_avg_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Avg_Order_By = {
  amount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "invoice_coupon_discount". All fields are combined with a logical 'AND'. */
export type Invoice_Coupon_Discount_Bool_Exp = {
  _and?: Maybe<Array<Invoice_Coupon_Discount_Bool_Exp>>;
  _not?: Maybe<Invoice_Coupon_Discount_Bool_Exp>;
  _or?: Maybe<Array<Invoice_Coupon_Discount_Bool_Exp>>;
  amount?: Maybe<Numeric_Comparison_Exp>;
  coupon_code?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  discount_type?: Maybe<String_Comparison_Exp>;
  inv_id?: Maybe<String_Comparison_Exp>;
  invoice?: Maybe<Invoice_Bool_Exp>;
};

/** unique or primary key constraints on table "invoice_coupon_discount" */
export enum Invoice_Coupon_Discount_Constraint {
  /** unique or primary key constraint on columns "inv_id" */
  InvoiceCouponDiscountPkey = 'invoice_coupon_discount_pkey',
}

/** input type for incrementing numeric columns in table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Inc_Input = {
  amount?: Maybe<Scalars['numeric']>;
};

/** input type for inserting data into table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Insert_Input = {
  amount?: Maybe<Scalars['numeric']>;
  coupon_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  discount_type?: Maybe<Scalars['String']>;
  inv_id?: Maybe<Scalars['String']>;
  invoice?: Maybe<Invoice_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Invoice_Coupon_Discount_Max_Fields = {
  __typename?: 'invoice_coupon_discount_max_fields';
  amount?: Maybe<Scalars['numeric']>;
  coupon_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  discount_type?: Maybe<Scalars['String']>;
  inv_id?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Max_Order_By = {
  amount?: Maybe<Order_By>;
  coupon_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  discount_type?: Maybe<Order_By>;
  inv_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Invoice_Coupon_Discount_Min_Fields = {
  __typename?: 'invoice_coupon_discount_min_fields';
  amount?: Maybe<Scalars['numeric']>;
  coupon_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  discount_type?: Maybe<Scalars['String']>;
  inv_id?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Min_Order_By = {
  amount?: Maybe<Order_By>;
  coupon_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  discount_type?: Maybe<Order_By>;
  inv_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Mutation_Response = {
  __typename?: 'invoice_coupon_discount_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Invoice_Coupon_Discount>;
};

/** on_conflict condition type for table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_On_Conflict = {
  constraint: Invoice_Coupon_Discount_Constraint;
  update_columns?: Array<Invoice_Coupon_Discount_Update_Column>;
  where?: Maybe<Invoice_Coupon_Discount_Bool_Exp>;
};

/** Ordering options when selecting data from "invoice_coupon_discount". */
export type Invoice_Coupon_Discount_Order_By = {
  amount?: Maybe<Order_By>;
  coupon_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  discount_type?: Maybe<Order_By>;
  inv_id?: Maybe<Order_By>;
  invoice?: Maybe<Invoice_Order_By>;
};

/** primary key columns input for table: invoice_coupon_discount */
export type Invoice_Coupon_Discount_Pk_Columns_Input = {
  inv_id: Scalars['String'];
};

/** select columns of table "invoice_coupon_discount" */
export enum Invoice_Coupon_Discount_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CouponCode = 'coupon_code',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DiscountType = 'discount_type',
  /** column name */
  InvId = 'inv_id',
}

/** input type for updating data in table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Set_Input = {
  amount?: Maybe<Scalars['numeric']>;
  coupon_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  discount_type?: Maybe<Scalars['String']>;
  inv_id?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Invoice_Coupon_Discount_Stddev_Fields = {
  __typename?: 'invoice_coupon_discount_stddev_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Stddev_Order_By = {
  amount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Invoice_Coupon_Discount_Stddev_Pop_Fields = {
  __typename?: 'invoice_coupon_discount_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Stddev_Pop_Order_By = {
  amount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Invoice_Coupon_Discount_Stddev_Samp_Fields = {
  __typename?: 'invoice_coupon_discount_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Stddev_Samp_Order_By = {
  amount?: Maybe<Order_By>;
};

/** Streaming cursor of the table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Invoice_Coupon_Discount_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Invoice_Coupon_Discount_Stream_Cursor_Value_Input = {
  amount?: Maybe<Scalars['numeric']>;
  coupon_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  discount_type?: Maybe<Scalars['String']>;
  inv_id?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Invoice_Coupon_Discount_Sum_Fields = {
  __typename?: 'invoice_coupon_discount_sum_fields';
  amount?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Sum_Order_By = {
  amount?: Maybe<Order_By>;
};

/** update columns of table "invoice_coupon_discount" */
export enum Invoice_Coupon_Discount_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CouponCode = 'coupon_code',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DiscountType = 'discount_type',
  /** column name */
  InvId = 'inv_id',
}

export type Invoice_Coupon_Discount_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Invoice_Coupon_Discount_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Invoice_Coupon_Discount_Set_Input>;
  /** filter the rows which have to be updated */
  where: Invoice_Coupon_Discount_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Invoice_Coupon_Discount_Var_Pop_Fields = {
  __typename?: 'invoice_coupon_discount_var_pop_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Var_Pop_Order_By = {
  amount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Invoice_Coupon_Discount_Var_Samp_Fields = {
  __typename?: 'invoice_coupon_discount_var_samp_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Var_Samp_Order_By = {
  amount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Invoice_Coupon_Discount_Variance_Fields = {
  __typename?: 'invoice_coupon_discount_variance_fields';
  amount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "invoice_coupon_discount" */
export type Invoice_Coupon_Discount_Variance_Order_By = {
  amount?: Maybe<Order_By>;
};

/** input type for incrementing numeric columns in table "invoice" */
export type Invoice_Inc_Input = {
  attempt_count?: Maybe<Scalars['Int']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Int']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "invoice" */
export type Invoice_Insert_Input = {
  attempt_count?: Maybe<Scalars['Int']>;
  collection_method?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** customer id that represents unique customer at stripe */
  customer_id?: Maybe<Scalars['String']>;
  /** any additional appropriate description for this invoice. This will be used on the UI */
  description?: Maybe<Scalars['String']>;
  invoice_coupon_discounts?: Maybe<Invoice_Coupon_Discount_Arr_Rel_Insert_Input>;
  invoice_credit_usages?: Maybe<Customer_Usage_Arr_Rel_Insert_Input>;
  invoice_url?: Maybe<Scalars['String']>;
  items?: Maybe<Invoice_Item_Arr_Rel_Insert_Input>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Int']>;
  payment_method?: Maybe<Payment_Method_Obj_Rel_Insert_Input>;
  payment_method_id?: Maybe<Scalars['String']>;
  receipt_url?: Maybe<Scalars['String']>;
  /** represents status of this invoice. It can be either `paid`, `failed`, `unpaid` */
  status?: Maybe<Scalars['String']>;
  /** unique invoice id, represents invoice id at stripe */
  stripe_invoice_id?: Maybe<Scalars['String']>;
  /** subscription for which the current invoice is generated for */
  subscription_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Int']>;
};

/** Item that is part of an invoice */
export type Invoice_Item = {
  __typename?: 'invoice_item';
  amount: Scalars['numeric'];
  created_at?: Maybe<Scalars['timestamptz']>;
  /** represents understandable invoice item description which will reflect in the actual invoice */
  description: Scalars['String'];
  /** contain error when adding invoice item to stripe fails */
  error?: Maybe<Scalars['String']>;
  /** if true, the stripe is updated successfully, otherwise not */
  has_updated_to_stripe: Scalars['Boolean'];
  id: Scalars['uuid'];
  /** An object relationship */
  invoice: Invoice;
  /** represents invoice_id for which this invoice_item is for */
  invoice_id: Scalars['String'];
  /** represents month for which this invoice_item is for */
  month: Scalars['Int'];
  /** represents project_id for which this invoice_item is for */
  project_id: Scalars['uuid'];
  /**
   * represents type for which this invoice_item is for. It can take up values such
   * as `pay_as_you_go`, `additional_data_usage`, `shared_data_passthrough`,
   * `shared_pg_usage`, `shared_no_db_usage`, `shared_non_pg_usage` or `sales_tax`
   */
  type: Scalars['invoice_item_type'];
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** represents year for which this invoice_item is for */
  year: Scalars['Int'];
};

/** aggregated selection of "invoice_item" */
export type Invoice_Item_Aggregate = {
  __typename?: 'invoice_item_aggregate';
  aggregate?: Maybe<Invoice_Item_Aggregate_Fields>;
  nodes: Array<Invoice_Item>;
};

export type Invoice_Item_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Invoice_Item_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Invoice_Item_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Invoice_Item_Aggregate_Bool_Exp_Count>;
};

export type Invoice_Item_Aggregate_Bool_Exp_Bool_And = {
  arguments: Invoice_Item_Select_Column_Invoice_Item_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Invoice_Item_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Invoice_Item_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Invoice_Item_Select_Column_Invoice_Item_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Invoice_Item_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Invoice_Item_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Invoice_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Invoice_Item_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "invoice_item" */
export type Invoice_Item_Aggregate_Fields = {
  __typename?: 'invoice_item_aggregate_fields';
  avg?: Maybe<Invoice_Item_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Invoice_Item_Max_Fields>;
  min?: Maybe<Invoice_Item_Min_Fields>;
  stddev?: Maybe<Invoice_Item_Stddev_Fields>;
  stddev_pop?: Maybe<Invoice_Item_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Invoice_Item_Stddev_Samp_Fields>;
  sum?: Maybe<Invoice_Item_Sum_Fields>;
  var_pop?: Maybe<Invoice_Item_Var_Pop_Fields>;
  var_samp?: Maybe<Invoice_Item_Var_Samp_Fields>;
  variance?: Maybe<Invoice_Item_Variance_Fields>;
};

/** aggregate fields of "invoice_item" */
export type Invoice_Item_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Invoice_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "invoice_item" */
export type Invoice_Item_Aggregate_Order_By = {
  avg?: Maybe<Invoice_Item_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Invoice_Item_Max_Order_By>;
  min?: Maybe<Invoice_Item_Min_Order_By>;
  stddev?: Maybe<Invoice_Item_Stddev_Order_By>;
  stddev_pop?: Maybe<Invoice_Item_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Invoice_Item_Stddev_Samp_Order_By>;
  sum?: Maybe<Invoice_Item_Sum_Order_By>;
  var_pop?: Maybe<Invoice_Item_Var_Pop_Order_By>;
  var_samp?: Maybe<Invoice_Item_Var_Samp_Order_By>;
  variance?: Maybe<Invoice_Item_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "invoice_item" */
export type Invoice_Item_Arr_Rel_Insert_Input = {
  data: Array<Invoice_Item_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Invoice_Item_On_Conflict>;
};

/** aggregate avg on columns */
export type Invoice_Item_Avg_Fields = {
  __typename?: 'invoice_item_avg_fields';
  amount?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "invoice_item" */
export type Invoice_Item_Avg_Order_By = {
  amount?: Maybe<Order_By>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "invoice_item". All fields are combined with a logical 'AND'. */
export type Invoice_Item_Bool_Exp = {
  _and?: Maybe<Array<Invoice_Item_Bool_Exp>>;
  _not?: Maybe<Invoice_Item_Bool_Exp>;
  _or?: Maybe<Array<Invoice_Item_Bool_Exp>>;
  amount?: Maybe<Numeric_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  error?: Maybe<String_Comparison_Exp>;
  has_updated_to_stripe?: Maybe<Boolean_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  invoice?: Maybe<Invoice_Bool_Exp>;
  invoice_id?: Maybe<String_Comparison_Exp>;
  month?: Maybe<Int_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  type?: Maybe<Invoice_Item_Type_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  year?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "invoice_item" */
export enum Invoice_Item_Constraint {
  /** unique or primary key constraint on columns "id" */
  InvoiceItemPkey = 'invoice_item_pkey',
  /** unique or primary key constraint on columns "year", "type", "project_id", "month" */
  InvoiceItemUnique = 'invoice_item_unique',
}

/** input type for incrementing numeric columns in table "invoice_item" */
export type Invoice_Item_Inc_Input = {
  amount?: Maybe<Scalars['numeric']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Int']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "invoice_item" */
export type Invoice_Item_Insert_Input = {
  amount?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** represents understandable invoice item description which will reflect in the actual invoice */
  description?: Maybe<Scalars['String']>;
  /** contain error when adding invoice item to stripe fails */
  error?: Maybe<Scalars['String']>;
  /** if true, the stripe is updated successfully, otherwise not */
  has_updated_to_stripe?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  invoice?: Maybe<Invoice_Obj_Rel_Insert_Input>;
  /** represents invoice_id for which this invoice_item is for */
  invoice_id?: Maybe<Scalars['String']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Int']>;
  /** represents project_id for which this invoice_item is for */
  project_id?: Maybe<Scalars['uuid']>;
  /**
   * represents type for which this invoice_item is for. It can take up values such
   * as `pay_as_you_go`, `additional_data_usage`, `shared_data_passthrough`,
   * `shared_pg_usage`, `shared_no_db_usage`, `shared_non_pg_usage` or `sales_tax`
   */
  type?: Maybe<Scalars['invoice_item_type']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Invoice_Item_Max_Fields = {
  __typename?: 'invoice_item_max_fields';
  amount?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** represents understandable invoice item description which will reflect in the actual invoice */
  description?: Maybe<Scalars['String']>;
  /** contain error when adding invoice item to stripe fails */
  error?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  /** represents invoice_id for which this invoice_item is for */
  invoice_id?: Maybe<Scalars['String']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Int']>;
  /** represents project_id for which this invoice_item is for */
  project_id?: Maybe<Scalars['uuid']>;
  /**
   * represents type for which this invoice_item is for. It can take up values such
   * as `pay_as_you_go`, `additional_data_usage`, `shared_data_passthrough`,
   * `shared_pg_usage`, `shared_no_db_usage`, `shared_non_pg_usage` or `sales_tax`
   */
  type?: Maybe<Scalars['invoice_item_type']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "invoice_item" */
export type Invoice_Item_Max_Order_By = {
  amount?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  /** represents understandable invoice item description which will reflect in the actual invoice */
  description?: Maybe<Order_By>;
  /** contain error when adding invoice item to stripe fails */
  error?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  /** represents invoice_id for which this invoice_item is for */
  invoice_id?: Maybe<Order_By>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Order_By>;
  /** represents project_id for which this invoice_item is for */
  project_id?: Maybe<Order_By>;
  /**
   * represents type for which this invoice_item is for. It can take up values such
   * as `pay_as_you_go`, `additional_data_usage`, `shared_data_passthrough`,
   * `shared_pg_usage`, `shared_no_db_usage`, `shared_non_pg_usage` or `sales_tax`
   */
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Invoice_Item_Min_Fields = {
  __typename?: 'invoice_item_min_fields';
  amount?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** represents understandable invoice item description which will reflect in the actual invoice */
  description?: Maybe<Scalars['String']>;
  /** contain error when adding invoice item to stripe fails */
  error?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  /** represents invoice_id for which this invoice_item is for */
  invoice_id?: Maybe<Scalars['String']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Int']>;
  /** represents project_id for which this invoice_item is for */
  project_id?: Maybe<Scalars['uuid']>;
  /**
   * represents type for which this invoice_item is for. It can take up values such
   * as `pay_as_you_go`, `additional_data_usage`, `shared_data_passthrough`,
   * `shared_pg_usage`, `shared_no_db_usage`, `shared_non_pg_usage` or `sales_tax`
   */
  type?: Maybe<Scalars['invoice_item_type']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "invoice_item" */
export type Invoice_Item_Min_Order_By = {
  amount?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  /** represents understandable invoice item description which will reflect in the actual invoice */
  description?: Maybe<Order_By>;
  /** contain error when adding invoice item to stripe fails */
  error?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  /** represents invoice_id for which this invoice_item is for */
  invoice_id?: Maybe<Order_By>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Order_By>;
  /** represents project_id for which this invoice_item is for */
  project_id?: Maybe<Order_By>;
  /**
   * represents type for which this invoice_item is for. It can take up values such
   * as `pay_as_you_go`, `additional_data_usage`, `shared_data_passthrough`,
   * `shared_pg_usage`, `shared_no_db_usage`, `shared_non_pg_usage` or `sales_tax`
   */
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Order_By>;
};

/** response of any mutation on the table "invoice_item" */
export type Invoice_Item_Mutation_Response = {
  __typename?: 'invoice_item_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Invoice_Item>;
};

/** on_conflict condition type for table "invoice_item" */
export type Invoice_Item_On_Conflict = {
  constraint: Invoice_Item_Constraint;
  update_columns?: Array<Invoice_Item_Update_Column>;
  where?: Maybe<Invoice_Item_Bool_Exp>;
};

/** Ordering options when selecting data from "invoice_item". */
export type Invoice_Item_Order_By = {
  amount?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  error?: Maybe<Order_By>;
  has_updated_to_stripe?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invoice?: Maybe<Invoice_Order_By>;
  invoice_id?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** primary key columns input for table: invoice_item */
export type Invoice_Item_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "invoice_item" */
export enum Invoice_Item_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Error = 'error',
  /** column name */
  HasUpdatedToStripe = 'has_updated_to_stripe',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  Month = 'month',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Year = 'year',
}

/** select "invoice_item_aggregate_bool_exp_bool_and_arguments_columns" columns of table "invoice_item" */
export enum Invoice_Item_Select_Column_Invoice_Item_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  HasUpdatedToStripe = 'has_updated_to_stripe',
}

/** select "invoice_item_aggregate_bool_exp_bool_or_arguments_columns" columns of table "invoice_item" */
export enum Invoice_Item_Select_Column_Invoice_Item_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  HasUpdatedToStripe = 'has_updated_to_stripe',
}

/** input type for updating data in table "invoice_item" */
export type Invoice_Item_Set_Input = {
  amount?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** represents understandable invoice item description which will reflect in the actual invoice */
  description?: Maybe<Scalars['String']>;
  /** contain error when adding invoice item to stripe fails */
  error?: Maybe<Scalars['String']>;
  /** if true, the stripe is updated successfully, otherwise not */
  has_updated_to_stripe?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  /** represents invoice_id for which this invoice_item is for */
  invoice_id?: Maybe<Scalars['String']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Int']>;
  /** represents project_id for which this invoice_item is for */
  project_id?: Maybe<Scalars['uuid']>;
  /**
   * represents type for which this invoice_item is for. It can take up values such
   * as `pay_as_you_go`, `additional_data_usage`, `shared_data_passthrough`,
   * `shared_pg_usage`, `shared_no_db_usage`, `shared_non_pg_usage` or `sales_tax`
   */
  type?: Maybe<Scalars['invoice_item_type']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Invoice_Item_Stddev_Fields = {
  __typename?: 'invoice_item_stddev_fields';
  amount?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "invoice_item" */
export type Invoice_Item_Stddev_Order_By = {
  amount?: Maybe<Order_By>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Invoice_Item_Stddev_Pop_Fields = {
  __typename?: 'invoice_item_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "invoice_item" */
export type Invoice_Item_Stddev_Pop_Order_By = {
  amount?: Maybe<Order_By>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Invoice_Item_Stddev_Samp_Fields = {
  __typename?: 'invoice_item_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "invoice_item" */
export type Invoice_Item_Stddev_Samp_Order_By = {
  amount?: Maybe<Order_By>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Order_By>;
};

/** Streaming cursor of the table "invoice_item" */
export type Invoice_Item_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Invoice_Item_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Invoice_Item_Stream_Cursor_Value_Input = {
  amount?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** represents understandable invoice item description which will reflect in the actual invoice */
  description?: Maybe<Scalars['String']>;
  /** contain error when adding invoice item to stripe fails */
  error?: Maybe<Scalars['String']>;
  /** if true, the stripe is updated successfully, otherwise not */
  has_updated_to_stripe?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  /** represents invoice_id for which this invoice_item is for */
  invoice_id?: Maybe<Scalars['String']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Int']>;
  /** represents project_id for which this invoice_item is for */
  project_id?: Maybe<Scalars['uuid']>;
  /**
   * represents type for which this invoice_item is for. It can take up values such
   * as `pay_as_you_go`, `additional_data_usage`, `shared_data_passthrough`,
   * `shared_pg_usage`, `shared_no_db_usage`, `shared_non_pg_usage` or `sales_tax`
   */
  type?: Maybe<Scalars['invoice_item_type']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Invoice_Item_Sum_Fields = {
  __typename?: 'invoice_item_sum_fields';
  amount?: Maybe<Scalars['numeric']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Int']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "invoice_item" */
export type Invoice_Item_Sum_Order_By = {
  amount?: Maybe<Order_By>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Order_By>;
};

/** Boolean expression to compare columns of type "invoice_item_type". All fields are combined with logical 'AND'. */
export type Invoice_Item_Type_Comparison_Exp = {
  _eq?: Maybe<Scalars['invoice_item_type']>;
  _gt?: Maybe<Scalars['invoice_item_type']>;
  _gte?: Maybe<Scalars['invoice_item_type']>;
  _in?: Maybe<Array<Scalars['invoice_item_type']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['invoice_item_type']>;
  _lte?: Maybe<Scalars['invoice_item_type']>;
  _neq?: Maybe<Scalars['invoice_item_type']>;
  _nin?: Maybe<Array<Scalars['invoice_item_type']>>;
};

/** update columns of table "invoice_item" */
export enum Invoice_Item_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Error = 'error',
  /** column name */
  HasUpdatedToStripe = 'has_updated_to_stripe',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  Month = 'month',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Year = 'year',
}

export type Invoice_Item_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Invoice_Item_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Invoice_Item_Set_Input>;
  /** filter the rows which have to be updated */
  where: Invoice_Item_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Invoice_Item_Var_Pop_Fields = {
  __typename?: 'invoice_item_var_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "invoice_item" */
export type Invoice_Item_Var_Pop_Order_By = {
  amount?: Maybe<Order_By>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Invoice_Item_Var_Samp_Fields = {
  __typename?: 'invoice_item_var_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "invoice_item" */
export type Invoice_Item_Var_Samp_Order_By = {
  amount?: Maybe<Order_By>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Invoice_Item_Variance_Fields = {
  __typename?: 'invoice_item_variance_fields';
  amount?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "invoice_item" */
export type Invoice_Item_Variance_Order_By = {
  amount?: Maybe<Order_By>;
  /** represents month for which this invoice_item is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice_item is for */
  year?: Maybe<Order_By>;
};

/** aggregate max on columns */
export type Invoice_Max_Fields = {
  __typename?: 'invoice_max_fields';
  attempt_count?: Maybe<Scalars['Int']>;
  collection_method?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** customer id that represents unique customer at stripe */
  customer_id?: Maybe<Scalars['String']>;
  /** any additional appropriate description for this invoice. This will be used on the UI */
  description?: Maybe<Scalars['String']>;
  invoice_url?: Maybe<Scalars['String']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Int']>;
  payment_method_id?: Maybe<Scalars['String']>;
  receipt_url?: Maybe<Scalars['String']>;
  /** represents status of this invoice. It can be either `paid`, `failed`, `unpaid` */
  status?: Maybe<Scalars['String']>;
  /** unique invoice id, represents invoice id at stripe */
  stripe_invoice_id?: Maybe<Scalars['String']>;
  /** subscription for which the current invoice is generated for */
  subscription_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "invoice" */
export type Invoice_Max_Order_By = {
  attempt_count?: Maybe<Order_By>;
  collection_method?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  /** customer id that represents unique customer at stripe */
  customer_id?: Maybe<Order_By>;
  /** any additional appropriate description for this invoice. This will be used on the UI */
  description?: Maybe<Order_By>;
  invoice_url?: Maybe<Order_By>;
  /** represents month for which this invoice is for */
  month?: Maybe<Order_By>;
  payment_method_id?: Maybe<Order_By>;
  receipt_url?: Maybe<Order_By>;
  /** represents status of this invoice. It can be either `paid`, `failed`, `unpaid` */
  status?: Maybe<Order_By>;
  /** unique invoice id, represents invoice id at stripe */
  stripe_invoice_id?: Maybe<Order_By>;
  /** subscription for which the current invoice is generated for */
  subscription_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  /** represents year for which this invoice is for */
  year?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Invoice_Min_Fields = {
  __typename?: 'invoice_min_fields';
  attempt_count?: Maybe<Scalars['Int']>;
  collection_method?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** customer id that represents unique customer at stripe */
  customer_id?: Maybe<Scalars['String']>;
  /** any additional appropriate description for this invoice. This will be used on the UI */
  description?: Maybe<Scalars['String']>;
  invoice_url?: Maybe<Scalars['String']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Int']>;
  payment_method_id?: Maybe<Scalars['String']>;
  receipt_url?: Maybe<Scalars['String']>;
  /** represents status of this invoice. It can be either `paid`, `failed`, `unpaid` */
  status?: Maybe<Scalars['String']>;
  /** unique invoice id, represents invoice id at stripe */
  stripe_invoice_id?: Maybe<Scalars['String']>;
  /** subscription for which the current invoice is generated for */
  subscription_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "invoice" */
export type Invoice_Min_Order_By = {
  attempt_count?: Maybe<Order_By>;
  collection_method?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  /** customer id that represents unique customer at stripe */
  customer_id?: Maybe<Order_By>;
  /** any additional appropriate description for this invoice. This will be used on the UI */
  description?: Maybe<Order_By>;
  invoice_url?: Maybe<Order_By>;
  /** represents month for which this invoice is for */
  month?: Maybe<Order_By>;
  payment_method_id?: Maybe<Order_By>;
  receipt_url?: Maybe<Order_By>;
  /** represents status of this invoice. It can be either `paid`, `failed`, `unpaid` */
  status?: Maybe<Order_By>;
  /** unique invoice id, represents invoice id at stripe */
  stripe_invoice_id?: Maybe<Order_By>;
  /** subscription for which the current invoice is generated for */
  subscription_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  /** represents year for which this invoice is for */
  year?: Maybe<Order_By>;
};

/** response of any mutation on the table "invoice" */
export type Invoice_Mutation_Response = {
  __typename?: 'invoice_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Invoice>;
};

/** input type for inserting object relation for remote table "invoice" */
export type Invoice_Obj_Rel_Insert_Input = {
  data: Invoice_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Invoice_On_Conflict>;
};

/** on_conflict condition type for table "invoice" */
export type Invoice_On_Conflict = {
  constraint: Invoice_Constraint;
  update_columns?: Array<Invoice_Update_Column>;
  where?: Maybe<Invoice_Bool_Exp>;
};

/** Ordering options when selecting data from "invoice". */
export type Invoice_Order_By = {
  attempt_count?: Maybe<Order_By>;
  collection_method?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer_id?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  due_amount?: Maybe<Order_By>;
  invoice_coupon_discounts_aggregate?: Maybe<Invoice_Coupon_Discount_Aggregate_Order_By>;
  invoice_credit_usages_aggregate?: Maybe<Customer_Usage_Aggregate_Order_By>;
  invoice_url?: Maybe<Order_By>;
  items_aggregate?: Maybe<Invoice_Item_Aggregate_Order_By>;
  month?: Maybe<Order_By>;
  payment_method?: Maybe<Payment_Method_Order_By>;
  payment_method_id?: Maybe<Order_By>;
  receipt_url?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  stripe_invoice_id?: Maybe<Order_By>;
  subscription_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  year?: Maybe<Order_By>;
};

/** primary key columns input for table: invoice */
export type Invoice_Pk_Columns_Input = {
  /** unique invoice id, represents invoice id at stripe */
  stripe_invoice_id: Scalars['String'];
};

/** select columns of table "invoice" */
export enum Invoice_Select_Column {
  /** column name */
  AttemptCount = 'attempt_count',
  /** column name */
  CollectionMethod = 'collection_method',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  InvoiceUrl = 'invoice_url',
  /** column name */
  Month = 'month',
  /** column name */
  PaymentMethodId = 'payment_method_id',
  /** column name */
  ReceiptUrl = 'receipt_url',
  /** column name */
  Status = 'status',
  /** column name */
  StripeInvoiceId = 'stripe_invoice_id',
  /** column name */
  SubscriptionId = 'subscription_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Year = 'year',
}

/** input type for updating data in table "invoice" */
export type Invoice_Set_Input = {
  attempt_count?: Maybe<Scalars['Int']>;
  collection_method?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** customer id that represents unique customer at stripe */
  customer_id?: Maybe<Scalars['String']>;
  /** any additional appropriate description for this invoice. This will be used on the UI */
  description?: Maybe<Scalars['String']>;
  invoice_url?: Maybe<Scalars['String']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Int']>;
  payment_method_id?: Maybe<Scalars['String']>;
  receipt_url?: Maybe<Scalars['String']>;
  /** represents status of this invoice. It can be either `paid`, `failed`, `unpaid` */
  status?: Maybe<Scalars['String']>;
  /** unique invoice id, represents invoice id at stripe */
  stripe_invoice_id?: Maybe<Scalars['String']>;
  /** subscription for which the current invoice is generated for */
  subscription_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Invoice_Stddev_Fields = {
  __typename?: 'invoice_stddev_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "invoice" */
export type Invoice_Stddev_Order_By = {
  attempt_count?: Maybe<Order_By>;
  /** represents month for which this invoice is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice is for */
  year?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Invoice_Stddev_Pop_Fields = {
  __typename?: 'invoice_stddev_pop_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "invoice" */
export type Invoice_Stddev_Pop_Order_By = {
  attempt_count?: Maybe<Order_By>;
  /** represents month for which this invoice is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice is for */
  year?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Invoice_Stddev_Samp_Fields = {
  __typename?: 'invoice_stddev_samp_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "invoice" */
export type Invoice_Stddev_Samp_Order_By = {
  attempt_count?: Maybe<Order_By>;
  /** represents month for which this invoice is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice is for */
  year?: Maybe<Order_By>;
};

/** Streaming cursor of the table "invoice" */
export type Invoice_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Invoice_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Invoice_Stream_Cursor_Value_Input = {
  attempt_count?: Maybe<Scalars['Int']>;
  collection_method?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** customer id that represents unique customer at stripe */
  customer_id?: Maybe<Scalars['String']>;
  /** any additional appropriate description for this invoice. This will be used on the UI */
  description?: Maybe<Scalars['String']>;
  invoice_url?: Maybe<Scalars['String']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Int']>;
  payment_method_id?: Maybe<Scalars['String']>;
  receipt_url?: Maybe<Scalars['String']>;
  /** represents status of this invoice. It can be either `paid`, `failed`, `unpaid` */
  status?: Maybe<Scalars['String']>;
  /** unique invoice id, represents invoice id at stripe */
  stripe_invoice_id?: Maybe<Scalars['String']>;
  /** subscription for which the current invoice is generated for */
  subscription_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Invoice_Sum_Fields = {
  __typename?: 'invoice_sum_fields';
  attempt_count?: Maybe<Scalars['Int']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Int']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "invoice" */
export type Invoice_Sum_Order_By = {
  attempt_count?: Maybe<Order_By>;
  /** represents month for which this invoice is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice is for */
  year?: Maybe<Order_By>;
};

/** update columns of table "invoice" */
export enum Invoice_Update_Column {
  /** column name */
  AttemptCount = 'attempt_count',
  /** column name */
  CollectionMethod = 'collection_method',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Description = 'description',
  /** column name */
  InvoiceUrl = 'invoice_url',
  /** column name */
  Month = 'month',
  /** column name */
  PaymentMethodId = 'payment_method_id',
  /** column name */
  ReceiptUrl = 'receipt_url',
  /** column name */
  Status = 'status',
  /** column name */
  StripeInvoiceId = 'stripe_invoice_id',
  /** column name */
  SubscriptionId = 'subscription_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Year = 'year',
}

export type Invoice_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Invoice_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Invoice_Set_Input>;
  /** filter the rows which have to be updated */
  where: Invoice_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Invoice_Var_Pop_Fields = {
  __typename?: 'invoice_var_pop_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "invoice" */
export type Invoice_Var_Pop_Order_By = {
  attempt_count?: Maybe<Order_By>;
  /** represents month for which this invoice is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice is for */
  year?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Invoice_Var_Samp_Fields = {
  __typename?: 'invoice_var_samp_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "invoice" */
export type Invoice_Var_Samp_Order_By = {
  attempt_count?: Maybe<Order_By>;
  /** represents month for which this invoice is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice is for */
  year?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Invoice_Variance_Fields = {
  __typename?: 'invoice_variance_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  /** represents month for which this invoice is for */
  month?: Maybe<Scalars['Float']>;
  /** represents year for which this invoice is for */
  year?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "invoice" */
export type Invoice_Variance_Order_By = {
  attempt_count?: Maybe<Order_By>;
  /** represents month for which this invoice is for */
  month?: Maybe<Order_By>;
  /** represents year for which this invoice is for */
  year?: Maybe<Order_By>;
};

export type InvoiceAndReceiptUrLsResponse = {
  __typename?: 'invoiceAndReceiptURLsResponse';
  invoice_url?: Maybe<Scalars['String']>;
  receipt_url?: Maybe<Scalars['String']>;
};

export enum InvoiceCreateStatus {
  Failed = 'failed',
  Success = 'success',
}

/** columns and relationships of "jobs" */
export type Jobs = {
  __typename?: 'jobs';
  created_at: Scalars['timestamptz'];
  /** An array relationship */
  github_push_event_jobs: Array<Github_Push_Event_Job>;
  /** An aggregate relationship */
  github_push_event_jobs_aggregate: Github_Push_Event_Job_Aggregate;
  id: Scalars['uuid'];
  input: Scalars['jsonb'];
  job_type: Scalars['String'];
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  status: Scalars['String'];
  /** An array relationship */
  tasks: Array<Tasks>;
  /** An aggregate relationship */
  tasks_aggregate: Tasks_Aggregate;
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user?: Maybe<Users>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** columns and relationships of "jobs" */
export type JobsGithub_Push_Event_JobsArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Job_Order_By>>;
  where?: Maybe<Github_Push_Event_Job_Bool_Exp>;
};

/** columns and relationships of "jobs" */
export type JobsGithub_Push_Event_Jobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Job_Order_By>>;
  where?: Maybe<Github_Push_Event_Job_Bool_Exp>;
};

/** columns and relationships of "jobs" */
export type JobsInputArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "jobs" */
export type JobsTasksArgs = {
  distinct_on?: Maybe<Array<Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tasks_Order_By>>;
  where?: Maybe<Tasks_Bool_Exp>;
};

/** columns and relationships of "jobs" */
export type JobsTasks_AggregateArgs = {
  distinct_on?: Maybe<Array<Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tasks_Order_By>>;
  where?: Maybe<Tasks_Bool_Exp>;
};

/** aggregated selection of "jobs" */
export type Jobs_Aggregate = {
  __typename?: 'jobs_aggregate';
  aggregate?: Maybe<Jobs_Aggregate_Fields>;
  nodes: Array<Jobs>;
};

export type Jobs_Aggregate_Bool_Exp = {
  count?: Maybe<Jobs_Aggregate_Bool_Exp_Count>;
};

export type Jobs_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Jobs_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Jobs_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "jobs" */
export type Jobs_Aggregate_Fields = {
  __typename?: 'jobs_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Jobs_Max_Fields>;
  min?: Maybe<Jobs_Min_Fields>;
};

/** aggregate fields of "jobs" */
export type Jobs_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Jobs_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "jobs" */
export type Jobs_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Jobs_Max_Order_By>;
  min?: Maybe<Jobs_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Jobs_Append_Input = {
  input?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "jobs" */
export type Jobs_Arr_Rel_Insert_Input = {
  data: Array<Jobs_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Jobs_On_Conflict>;
};

/** Boolean expression to filter rows from the table "jobs". All fields are combined with a logical 'AND'. */
export type Jobs_Bool_Exp = {
  _and?: Maybe<Array<Jobs_Bool_Exp>>;
  _not?: Maybe<Jobs_Bool_Exp>;
  _or?: Maybe<Array<Jobs_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  github_push_event_jobs?: Maybe<Github_Push_Event_Job_Bool_Exp>;
  github_push_event_jobs_aggregate?: Maybe<Github_Push_Event_Job_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  input?: Maybe<Jsonb_Comparison_Exp>;
  job_type?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  project_name?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  tasks?: Maybe<Tasks_Bool_Exp>;
  tasks_aggregate?: Maybe<Tasks_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "jobs" */
export enum Jobs_Constraint {
  /** unique or primary key constraint on columns "id" */
  JobsPkey = 'jobs_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Jobs_Delete_At_Path_Input = {
  input?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Jobs_Delete_Elem_Input = {
  input?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Jobs_Delete_Key_Input = {
  input?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "jobs" */
export type Jobs_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  github_push_event_jobs?: Maybe<Github_Push_Event_Job_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  input?: Maybe<Scalars['jsonb']>;
  job_type?: Maybe<Scalars['String']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  tasks?: Maybe<Tasks_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Jobs_Max_Fields = {
  __typename?: 'jobs_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_type?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "jobs" */
export type Jobs_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  job_type?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  project_name?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Jobs_Min_Fields = {
  __typename?: 'jobs_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_type?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "jobs" */
export type Jobs_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  job_type?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  project_name?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "jobs" */
export type Jobs_Mutation_Response = {
  __typename?: 'jobs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Jobs>;
};

/** input type for inserting object relation for remote table "jobs" */
export type Jobs_Obj_Rel_Insert_Input = {
  data: Jobs_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Jobs_On_Conflict>;
};

/** on_conflict condition type for table "jobs" */
export type Jobs_On_Conflict = {
  constraint: Jobs_Constraint;
  update_columns?: Array<Jobs_Update_Column>;
  where?: Maybe<Jobs_Bool_Exp>;
};

/** Ordering options when selecting data from "jobs". */
export type Jobs_Order_By = {
  created_at?: Maybe<Order_By>;
  github_push_event_jobs_aggregate?: Maybe<Github_Push_Event_Job_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  input?: Maybe<Order_By>;
  job_type?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  project_name?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  tasks_aggregate?: Maybe<Tasks_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: jobs */
export type Jobs_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Jobs_Prepend_Input = {
  input?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "jobs" */
export enum Jobs_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Input = 'input',
  /** column name */
  JobType = 'job_type',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ProjectName = 'project_name',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "jobs" */
export type Jobs_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  input?: Maybe<Scalars['jsonb']>;
  job_type?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "jobs" */
export type Jobs_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Jobs_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Jobs_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  input?: Maybe<Scalars['jsonb']>;
  job_type?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "jobs" */
export enum Jobs_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Input = 'input',
  /** column name */
  JobType = 'job_type',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ProjectName = 'project_name',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

export type Jobs_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Jobs_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Jobs_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Jobs_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Jobs_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Jobs_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Jobs_Set_Input>;
  /** filter the rows which have to be updated */
  where: Jobs_Bool_Exp;
};

export enum JobTypeEnum {
  PreviewApp = 'preview_app',
  RegionMigration = 'region_migration',
  V1ToV2Upgrade = 'v1_to_v2_upgrade',
}

/** Boolean expression to compare columns of type "json". All fields are combined with logical 'AND'. */
export type Json_Comparison_Exp = {
  _eq?: Maybe<Scalars['json']>;
  _gt?: Maybe<Scalars['json']>;
  _gte?: Maybe<Scalars['json']>;
  _in?: Maybe<Array<Scalars['json']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['json']>;
  _lte?: Maybe<Scalars['json']>;
  _neq?: Maybe<Scalars['json']>;
  _nin?: Maybe<Array<Scalars['json']>>;
};

export type Jsonb_Cast_Exp = {
  String?: Maybe<String_Comparison_Exp>;
};

/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  _cast?: Maybe<Jsonb_Cast_Exp>;
  /** is the column contained in the given json value */
  _contained_in?: Maybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  _contains?: Maybe<Scalars['jsonb']>;
  _eq?: Maybe<Scalars['jsonb']>;
  _gt?: Maybe<Scalars['jsonb']>;
  _gte?: Maybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  _has_key?: Maybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  _has_keys_all?: Maybe<Array<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  _has_keys_any?: Maybe<Array<Scalars['String']>>;
  _in?: Maybe<Array<Scalars['jsonb']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['jsonb']>;
  _lte?: Maybe<Scalars['jsonb']>;
  _neq?: Maybe<Scalars['jsonb']>;
  _nin?: Maybe<Array<Scalars['jsonb']>>;
};

/** Labels that can be created per user */
export type Label = {
  __typename?: 'label';
  color?: Maybe<Scalars['String']>;
  created_at: Scalars['timetz'];
  created_by: Scalars['uuid'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  /** An array relationship */
  project_labels: Array<Project_Labels>;
  /** An aggregate relationship */
  project_labels_aggregate: Project_Labels_Aggregate;
};

/** Labels that can be created per user */
export type LabelProject_LabelsArgs = {
  distinct_on?: Maybe<Array<Project_Labels_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Labels_Order_By>>;
  where?: Maybe<Project_Labels_Bool_Exp>;
};

/** Labels that can be created per user */
export type LabelProject_Labels_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Labels_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Labels_Order_By>>;
  where?: Maybe<Project_Labels_Bool_Exp>;
};

/** aggregated selection of "label" */
export type Label_Aggregate = {
  __typename?: 'label_aggregate';
  aggregate?: Maybe<Label_Aggregate_Fields>;
  nodes: Array<Label>;
};

/** aggregate fields of "label" */
export type Label_Aggregate_Fields = {
  __typename?: 'label_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Label_Max_Fields>;
  min?: Maybe<Label_Min_Fields>;
};

/** aggregate fields of "label" */
export type Label_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Label_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "label". All fields are combined with a logical 'AND'. */
export type Label_Bool_Exp = {
  _and?: Maybe<Array<Label_Bool_Exp>>;
  _not?: Maybe<Label_Bool_Exp>;
  _or?: Maybe<Array<Label_Bool_Exp>>;
  color?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timetz_Comparison_Exp>;
  created_by?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  project_labels?: Maybe<Project_Labels_Bool_Exp>;
  project_labels_aggregate?: Maybe<Project_Labels_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "label" */
export enum Label_Constraint {
  /** unique or primary key constraint on columns "name", "created_by" */
  LabelNameCreatedByKey = 'label_name_created_by_key',
  /** unique or primary key constraint on columns "id" */
  TagPkey = 'tag_pkey',
}

/** input type for inserting data into table "label" */
export type Label_Insert_Input = {
  color?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timetz']>;
  created_by?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  project_labels?: Maybe<Project_Labels_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Label_Max_Fields = {
  __typename?: 'label_max_fields';
  color?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timetz']>;
  created_by?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Label_Min_Fields = {
  __typename?: 'label_min_fields';
  color?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timetz']>;
  created_by?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "label" */
export type Label_Mutation_Response = {
  __typename?: 'label_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Label>;
};

/** input type for inserting object relation for remote table "label" */
export type Label_Obj_Rel_Insert_Input = {
  data: Label_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Label_On_Conflict>;
};

/** on_conflict condition type for table "label" */
export type Label_On_Conflict = {
  constraint: Label_Constraint;
  update_columns?: Array<Label_Update_Column>;
  where?: Maybe<Label_Bool_Exp>;
};

/** Ordering options when selecting data from "label". */
export type Label_Order_By = {
  color?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  created_by?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  project_labels_aggregate?: Maybe<Project_Labels_Aggregate_Order_By>;
};

/** primary key columns input for table: label */
export type Label_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "label" */
export enum Label_Select_Column {
  /** column name */
  Color = 'color',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
}

/** input type for updating data in table "label" */
export type Label_Set_Input = {
  color?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timetz']>;
  created_by?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "label" */
export type Label_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Label_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Label_Stream_Cursor_Value_Input = {
  color?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timetz']>;
  created_by?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
};

/** update columns of table "label" */
export enum Label_Update_Column {
  /** column name */
  Color = 'color',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
}

export type Label_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Label_Set_Input>;
  /** filter the rows which have to be updated */
  where: Label_Bool_Exp;
};

/** letsencrypt status of a gateway worker */
export type Letsencrypt_Status = {
  __typename?: 'letsencrypt_status';
  cert_id: Scalars['String'];
  /** An object relationship */
  custom_domain: Custom_Domain;
  fqdn: Scalars['String'];
  is_active: Scalars['Boolean'];
  message?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  worker_id: Scalars['uuid'];
};

/** aggregated selection of "letsencrypt_status" */
export type Letsencrypt_Status_Aggregate = {
  __typename?: 'letsencrypt_status_aggregate';
  aggregate?: Maybe<Letsencrypt_Status_Aggregate_Fields>;
  nodes: Array<Letsencrypt_Status>;
};

export type Letsencrypt_Status_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Letsencrypt_Status_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Letsencrypt_Status_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Letsencrypt_Status_Aggregate_Bool_Exp_Count>;
};

export type Letsencrypt_Status_Aggregate_Bool_Exp_Bool_And = {
  arguments: Letsencrypt_Status_Select_Column_Letsencrypt_Status_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Letsencrypt_Status_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Letsencrypt_Status_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Letsencrypt_Status_Select_Column_Letsencrypt_Status_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Letsencrypt_Status_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Letsencrypt_Status_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Letsencrypt_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Letsencrypt_Status_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "letsencrypt_status" */
export type Letsencrypt_Status_Aggregate_Fields = {
  __typename?: 'letsencrypt_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Letsencrypt_Status_Max_Fields>;
  min?: Maybe<Letsencrypt_Status_Min_Fields>;
};

/** aggregate fields of "letsencrypt_status" */
export type Letsencrypt_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Letsencrypt_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "letsencrypt_status" */
export type Letsencrypt_Status_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Letsencrypt_Status_Max_Order_By>;
  min?: Maybe<Letsencrypt_Status_Min_Order_By>;
};

/** input type for inserting array relation for remote table "letsencrypt_status" */
export type Letsencrypt_Status_Arr_Rel_Insert_Input = {
  data: Array<Letsencrypt_Status_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Letsencrypt_Status_On_Conflict>;
};

/** Boolean expression to filter rows from the table "letsencrypt_status". All fields are combined with a logical 'AND'. */
export type Letsencrypt_Status_Bool_Exp = {
  _and?: Maybe<Array<Letsencrypt_Status_Bool_Exp>>;
  _not?: Maybe<Letsencrypt_Status_Bool_Exp>;
  _or?: Maybe<Array<Letsencrypt_Status_Bool_Exp>>;
  cert_id?: Maybe<String_Comparison_Exp>;
  custom_domain?: Maybe<Custom_Domain_Bool_Exp>;
  fqdn?: Maybe<String_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  message?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  worker_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "letsencrypt_status" */
export enum Letsencrypt_Status_Constraint {
  /** unique or primary key constraint on columns "fqdn" */
  LetsencryptStatusPkey = 'letsencrypt_status_pkey',
}

/** input type for inserting data into table "letsencrypt_status" */
export type Letsencrypt_Status_Insert_Input = {
  cert_id?: Maybe<Scalars['String']>;
  custom_domain?: Maybe<Custom_Domain_Obj_Rel_Insert_Input>;
  fqdn?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Letsencrypt_Status_Max_Fields = {
  __typename?: 'letsencrypt_status_max_fields';
  cert_id?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "letsencrypt_status" */
export type Letsencrypt_Status_Max_Order_By = {
  cert_id?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Letsencrypt_Status_Min_Fields = {
  __typename?: 'letsencrypt_status_min_fields';
  cert_id?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "letsencrypt_status" */
export type Letsencrypt_Status_Min_Order_By = {
  cert_id?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "letsencrypt_status" */
export type Letsencrypt_Status_Mutation_Response = {
  __typename?: 'letsencrypt_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Letsencrypt_Status>;
};

/** on_conflict condition type for table "letsencrypt_status" */
export type Letsencrypt_Status_On_Conflict = {
  constraint: Letsencrypt_Status_Constraint;
  update_columns?: Array<Letsencrypt_Status_Update_Column>;
  where?: Maybe<Letsencrypt_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "letsencrypt_status". */
export type Letsencrypt_Status_Order_By = {
  cert_id?: Maybe<Order_By>;
  custom_domain?: Maybe<Custom_Domain_Order_By>;
  fqdn?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** primary key columns input for table: letsencrypt_status */
export type Letsencrypt_Status_Pk_Columns_Input = {
  fqdn: Scalars['String'];
};

/** select columns of table "letsencrypt_status" */
export enum Letsencrypt_Status_Select_Column {
  /** column name */
  CertId = 'cert_id',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WorkerId = 'worker_id',
}

/** select "letsencrypt_status_aggregate_bool_exp_bool_and_arguments_columns" columns of table "letsencrypt_status" */
export enum Letsencrypt_Status_Select_Column_Letsencrypt_Status_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsActive = 'is_active',
}

/** select "letsencrypt_status_aggregate_bool_exp_bool_or_arguments_columns" columns of table "letsencrypt_status" */
export enum Letsencrypt_Status_Select_Column_Letsencrypt_Status_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsActive = 'is_active',
}

/** input type for updating data in table "letsencrypt_status" */
export type Letsencrypt_Status_Set_Input = {
  cert_id?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "letsencrypt_status" */
export type Letsencrypt_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Letsencrypt_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Letsencrypt_Status_Stream_Cursor_Value_Input = {
  cert_id?: Maybe<Scalars['String']>;
  fqdn?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "letsencrypt_status" */
export enum Letsencrypt_Status_Update_Column {
  /** column name */
  CertId = 'cert_id',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WorkerId = 'worker_id',
}

export type Letsencrypt_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Letsencrypt_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Letsencrypt_Status_Bool_Exp;
};

export type LetsEncryptStatus = {
  __typename?: 'LetsEncryptStatus';
  is_active: Scalars['Boolean'];
  message?: Maybe<Scalars['String']>;
};

/** Record of all manual and automated actions performed on a license.  */
export type License_Activity = {
  __typename?: 'license_activity';
  action: Scalars['String'];
  activity_performed_by: Scalars['String'];
  activity_type: Scalars['String'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  license?: Maybe<Licenses>;
  license_email: Scalars['String'];
  note?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "license_activity" */
export type License_Activity_Aggregate = {
  __typename?: 'license_activity_aggregate';
  aggregate?: Maybe<License_Activity_Aggregate_Fields>;
  nodes: Array<License_Activity>;
};

/** aggregate fields of "license_activity" */
export type License_Activity_Aggregate_Fields = {
  __typename?: 'license_activity_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<License_Activity_Max_Fields>;
  min?: Maybe<License_Activity_Min_Fields>;
};

/** aggregate fields of "license_activity" */
export type License_Activity_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<License_Activity_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "license_activity". All fields are combined with a logical 'AND'. */
export type License_Activity_Bool_Exp = {
  _and?: Maybe<Array<License_Activity_Bool_Exp>>;
  _not?: Maybe<License_Activity_Bool_Exp>;
  _or?: Maybe<Array<License_Activity_Bool_Exp>>;
  action?: Maybe<String_Comparison_Exp>;
  activity_performed_by?: Maybe<String_Comparison_Exp>;
  activity_type?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  license?: Maybe<Licenses_Bool_Exp>;
  license_email?: Maybe<String_Comparison_Exp>;
  note?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "license_activity" */
export enum License_Activity_Constraint {
  /** unique or primary key constraint on columns "id" */
  LicenseActivityPkey = 'license_activity_pkey',
}

/** input type for inserting data into table "license_activity" */
export type License_Activity_Insert_Input = {
  action?: Maybe<Scalars['String']>;
  activity_performed_by?: Maybe<Scalars['String']>;
  activity_type?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  license?: Maybe<Licenses_Obj_Rel_Insert_Input>;
  license_email?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type License_Activity_Max_Fields = {
  __typename?: 'license_activity_max_fields';
  action?: Maybe<Scalars['String']>;
  activity_performed_by?: Maybe<Scalars['String']>;
  activity_type?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  license_email?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type License_Activity_Min_Fields = {
  __typename?: 'license_activity_min_fields';
  action?: Maybe<Scalars['String']>;
  activity_performed_by?: Maybe<Scalars['String']>;
  activity_type?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  license_email?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "license_activity" */
export type License_Activity_Mutation_Response = {
  __typename?: 'license_activity_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<License_Activity>;
};

/** on_conflict condition type for table "license_activity" */
export type License_Activity_On_Conflict = {
  constraint: License_Activity_Constraint;
  update_columns?: Array<License_Activity_Update_Column>;
  where?: Maybe<License_Activity_Bool_Exp>;
};

/** Ordering options when selecting data from "license_activity". */
export type License_Activity_Order_By = {
  action?: Maybe<Order_By>;
  activity_performed_by?: Maybe<Order_By>;
  activity_type?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  license?: Maybe<Licenses_Order_By>;
  license_email?: Maybe<Order_By>;
  note?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: license_activity */
export type License_Activity_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "license_activity" */
export enum License_Activity_Select_Column {
  /** column name */
  Action = 'action',
  /** column name */
  ActivityPerformedBy = 'activity_performed_by',
  /** column name */
  ActivityType = 'activity_type',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  LicenseEmail = 'license_email',
  /** column name */
  Note = 'note',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "license_activity" */
export type License_Activity_Set_Input = {
  action?: Maybe<Scalars['String']>;
  activity_performed_by?: Maybe<Scalars['String']>;
  activity_type?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  license_email?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "license_activity" */
export type License_Activity_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: License_Activity_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type License_Activity_Stream_Cursor_Value_Input = {
  action?: Maybe<Scalars['String']>;
  activity_performed_by?: Maybe<Scalars['String']>;
  activity_type?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  license_email?: Maybe<Scalars['String']>;
  note?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "license_activity" */
export enum License_Activity_Update_Column {
  /** column name */
  Action = 'action',
  /** column name */
  ActivityPerformedBy = 'activity_performed_by',
  /** column name */
  ActivityType = 'activity_type',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  LicenseEmail = 'license_email',
  /** column name */
  Note = 'note',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type License_Activity_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<License_Activity_Set_Input>;
  /** filter the rows which have to be updated */
  where: License_Activity_Bool_Exp;
};

/** columns and relationships of "license_instance" */
export type License_Instance = {
  __typename?: 'license_instance';
  created_at: Scalars['timestamptz'];
  email: Scalars['String'];
  metadata_db_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "license_instance" */
export type License_Instance_Aggregate = {
  __typename?: 'license_instance_aggregate';
  aggregate?: Maybe<License_Instance_Aggregate_Fields>;
  nodes: Array<License_Instance>;
};

/** aggregate fields of "license_instance" */
export type License_Instance_Aggregate_Fields = {
  __typename?: 'license_instance_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<License_Instance_Max_Fields>;
  min?: Maybe<License_Instance_Min_Fields>;
};

/** aggregate fields of "license_instance" */
export type License_Instance_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<License_Instance_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "license_instance". All fields are combined with a logical 'AND'. */
export type License_Instance_Bool_Exp = {
  _and?: Maybe<Array<License_Instance_Bool_Exp>>;
  _not?: Maybe<License_Instance_Bool_Exp>;
  _or?: Maybe<Array<License_Instance_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  metadata_db_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "license_instance" */
export enum License_Instance_Constraint {
  /** unique or primary key constraint on columns "metadata_db_id" */
  LicenseInstancePkey = 'license_instance_pkey',
}

/** input type for inserting data into table "license_instance" */
export type License_Instance_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  metadata_db_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type License_Instance_Max_Fields = {
  __typename?: 'license_instance_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  metadata_db_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type License_Instance_Min_Fields = {
  __typename?: 'license_instance_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  metadata_db_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "license_instance" */
export type License_Instance_Mutation_Response = {
  __typename?: 'license_instance_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<License_Instance>;
};

/** on_conflict condition type for table "license_instance" */
export type License_Instance_On_Conflict = {
  constraint: License_Instance_Constraint;
  update_columns?: Array<License_Instance_Update_Column>;
  where?: Maybe<License_Instance_Bool_Exp>;
};

/** Ordering options when selecting data from "license_instance". */
export type License_Instance_Order_By = {
  created_at?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  metadata_db_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: license_instance */
export type License_Instance_Pk_Columns_Input = {
  metadata_db_id: Scalars['uuid'];
};

/** select columns of table "license_instance" */
export enum License_Instance_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  MetadataDbId = 'metadata_db_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "license_instance" */
export type License_Instance_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  metadata_db_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "license_instance" */
export type License_Instance_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: License_Instance_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type License_Instance_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  metadata_db_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "license_instance" */
export enum License_Instance_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  MetadataDbId = 'metadata_db_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type License_Instance_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<License_Instance_Set_Input>;
  /** filter the rows which have to be updated */
  where: License_Instance_Bool_Exp;
};

/** columns and relationships of "license_type" */
export type License_Type = {
  __typename?: 'license_type';
  comment?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** aggregated selection of "license_type" */
export type License_Type_Aggregate = {
  __typename?: 'license_type_aggregate';
  aggregate?: Maybe<License_Type_Aggregate_Fields>;
  nodes: Array<License_Type>;
};

/** aggregate fields of "license_type" */
export type License_Type_Aggregate_Fields = {
  __typename?: 'license_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<License_Type_Max_Fields>;
  min?: Maybe<License_Type_Min_Fields>;
};

/** aggregate fields of "license_type" */
export type License_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<License_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "license_type". All fields are combined with a logical 'AND'. */
export type License_Type_Bool_Exp = {
  _and?: Maybe<Array<License_Type_Bool_Exp>>;
  _not?: Maybe<License_Type_Bool_Exp>;
  _or?: Maybe<Array<License_Type_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "license_type" */
export enum License_Type_Constraint {
  /** unique or primary key constraint on columns "name" */
  LicenseTypePkey = 'license_type_pkey',
}

export enum License_Type_Enum {
  /** A long-lived EE license requested internally */
  Offline = 'offline',
  /** An EE license which has been paid for */
  Paid = 'paid',
  /** An EE license issued for free with a limited validity timespan */
  Trial = 'trial',
}

/** Boolean expression to compare columns of type "license_type_enum". All fields are combined with logical 'AND'. */
export type License_Type_Enum_Comparison_Exp = {
  _eq?: Maybe<License_Type_Enum>;
  _in?: Maybe<Array<License_Type_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<License_Type_Enum>;
  _nin?: Maybe<Array<License_Type_Enum>>;
};

/** input type for inserting data into table "license_type" */
export type License_Type_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type License_Type_Max_Fields = {
  __typename?: 'license_type_max_fields';
  comment?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type License_Type_Min_Fields = {
  __typename?: 'license_type_min_fields';
  comment?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "license_type" */
export type License_Type_Mutation_Response = {
  __typename?: 'license_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<License_Type>;
};

/** on_conflict condition type for table "license_type" */
export type License_Type_On_Conflict = {
  constraint: License_Type_Constraint;
  update_columns?: Array<License_Type_Update_Column>;
  where?: Maybe<License_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "license_type". */
export type License_Type_Order_By = {
  comment?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** primary key columns input for table: license_type */
export type License_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "license_type" */
export enum License_Type_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Name = 'name',
}

/** input type for updating data in table "license_type" */
export type License_Type_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "license_type" */
export type License_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: License_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type License_Type_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** update columns of table "license_type" */
export enum License_Type_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Name = 'name',
}

export type License_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<License_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: License_Type_Bool_Exp;
};

/** columns and relationships of "licenses" */
export type Licenses = {
  __typename?: 'licenses';
  client_id: Scalars['uuid'];
  created_at: Scalars['timestamptz'];
  email: Scalars['String'];
  expiry_at: Scalars['timestamptz'];
  grace_at: Scalars['timestamptz'];
  license_type: License_Type_Enum;
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "licenses" */
export type Licenses_Aggregate = {
  __typename?: 'licenses_aggregate';
  aggregate?: Maybe<Licenses_Aggregate_Fields>;
  nodes: Array<Licenses>;
};

/** aggregate fields of "licenses" */
export type Licenses_Aggregate_Fields = {
  __typename?: 'licenses_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Licenses_Max_Fields>;
  min?: Maybe<Licenses_Min_Fields>;
};

/** aggregate fields of "licenses" */
export type Licenses_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Licenses_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "licenses". All fields are combined with a logical 'AND'. */
export type Licenses_Bool_Exp = {
  _and?: Maybe<Array<Licenses_Bool_Exp>>;
  _not?: Maybe<Licenses_Bool_Exp>;
  _or?: Maybe<Array<Licenses_Bool_Exp>>;
  client_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  expiry_at?: Maybe<Timestamptz_Comparison_Exp>;
  grace_at?: Maybe<Timestamptz_Comparison_Exp>;
  license_type?: Maybe<License_Type_Enum_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "licenses" */
export enum Licenses_Constraint {
  /** unique or primary key constraint on columns "email" */
  LicensesPkey = 'licenses_pkey',
}

/** input type for inserting data into table "licenses" */
export type Licenses_Insert_Input = {
  client_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  expiry_at?: Maybe<Scalars['timestamptz']>;
  grace_at?: Maybe<Scalars['timestamptz']>;
  license_type?: Maybe<License_Type_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Licenses_Max_Fields = {
  __typename?: 'licenses_max_fields';
  client_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  expiry_at?: Maybe<Scalars['timestamptz']>;
  grace_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Licenses_Min_Fields = {
  __typename?: 'licenses_min_fields';
  client_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  expiry_at?: Maybe<Scalars['timestamptz']>;
  grace_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "licenses" */
export type Licenses_Mutation_Response = {
  __typename?: 'licenses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Licenses>;
};

/** input type for inserting object relation for remote table "licenses" */
export type Licenses_Obj_Rel_Insert_Input = {
  data: Licenses_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Licenses_On_Conflict>;
};

/** on_conflict condition type for table "licenses" */
export type Licenses_On_Conflict = {
  constraint: Licenses_Constraint;
  update_columns?: Array<Licenses_Update_Column>;
  where?: Maybe<Licenses_Bool_Exp>;
};

/** Ordering options when selecting data from "licenses". */
export type Licenses_Order_By = {
  client_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  expiry_at?: Maybe<Order_By>;
  grace_at?: Maybe<Order_By>;
  license_type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: licenses */
export type Licenses_Pk_Columns_Input = {
  email: Scalars['String'];
};

/** select columns of table "licenses" */
export enum Licenses_Select_Column {
  /** column name */
  ClientId = 'client_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  ExpiryAt = 'expiry_at',
  /** column name */
  GraceAt = 'grace_at',
  /** column name */
  LicenseType = 'license_type',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "licenses" */
export type Licenses_Set_Input = {
  client_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  expiry_at?: Maybe<Scalars['timestamptz']>;
  grace_at?: Maybe<Scalars['timestamptz']>;
  license_type?: Maybe<License_Type_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "licenses" */
export type Licenses_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Licenses_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Licenses_Stream_Cursor_Value_Input = {
  client_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  expiry_at?: Maybe<Scalars['timestamptz']>;
  grace_at?: Maybe<Scalars['timestamptz']>;
  license_type?: Maybe<License_Type_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "licenses" */
export enum Licenses_Update_Column {
  /** column name */
  ClientId = 'client_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  ExpiryAt = 'expiry_at',
  /** column name */
  GraceAt = 'grace_at',
  /** column name */
  LicenseType = 'license_type',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Licenses_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Licenses_Set_Input>;
  /** filter the rows which have to be updated */
  where: Licenses_Bool_Exp;
};

/** Proxy service used by dedicated VPCs to connect to Lux and other regional resources */
export type Lux_Proxy = {
  __typename?: 'lux_proxy';
  ami_id?: Maybe<Scalars['String']>;
  cloud: Scalars['String'];
  comments?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  disable_infra_auto_apply: Scalars['Boolean'];
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region: Scalars['String'];
  /** An object relationship */
  region_info?: Maybe<Region>;
  updated_at: Scalars['timestamptz'];
};

/** Proxy service used by dedicated VPCs to connect to Lux and other regional resources */
export type Lux_ProxyInput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Proxy service used by dedicated VPCs to connect to Lux and other regional resources */
export type Lux_ProxyOutput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "lux_proxy" */
export type Lux_Proxy_Aggregate = {
  __typename?: 'lux_proxy_aggregate';
  aggregate?: Maybe<Lux_Proxy_Aggregate_Fields>;
  nodes: Array<Lux_Proxy>;
};

export type Lux_Proxy_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Lux_Proxy_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Lux_Proxy_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Lux_Proxy_Aggregate_Bool_Exp_Count>;
};

export type Lux_Proxy_Aggregate_Bool_Exp_Bool_And = {
  arguments: Lux_Proxy_Select_Column_Lux_Proxy_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Lux_Proxy_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Lux_Proxy_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Lux_Proxy_Select_Column_Lux_Proxy_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Lux_Proxy_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Lux_Proxy_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Lux_Proxy_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Lux_Proxy_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "lux_proxy" */
export type Lux_Proxy_Aggregate_Fields = {
  __typename?: 'lux_proxy_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Lux_Proxy_Max_Fields>;
  min?: Maybe<Lux_Proxy_Min_Fields>;
};

/** aggregate fields of "lux_proxy" */
export type Lux_Proxy_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Lux_Proxy_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "lux_proxy" */
export type Lux_Proxy_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Lux_Proxy_Max_Order_By>;
  min?: Maybe<Lux_Proxy_Min_Order_By>;
};

/** Represents AMIs generated for lux proxy service */
export type Lux_Proxy_Ami = {
  __typename?: 'lux_proxy_ami';
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  commit_hash: Scalars['String'];
  created_at: Scalars['timestamptz'];
  region: Scalars['String'];
  remarks: Scalars['String'];
};

/** aggregated selection of "lux_proxy_ami" */
export type Lux_Proxy_Ami_Aggregate = {
  __typename?: 'lux_proxy_ami_aggregate';
  aggregate?: Maybe<Lux_Proxy_Ami_Aggregate_Fields>;
  nodes: Array<Lux_Proxy_Ami>;
};

/** aggregate fields of "lux_proxy_ami" */
export type Lux_Proxy_Ami_Aggregate_Fields = {
  __typename?: 'lux_proxy_ami_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Lux_Proxy_Ami_Max_Fields>;
  min?: Maybe<Lux_Proxy_Ami_Min_Fields>;
};

/** aggregate fields of "lux_proxy_ami" */
export type Lux_Proxy_Ami_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Lux_Proxy_Ami_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "lux_proxy_ami". All fields are combined with a logical 'AND'. */
export type Lux_Proxy_Ami_Bool_Exp = {
  _and?: Maybe<Array<Lux_Proxy_Ami_Bool_Exp>>;
  _not?: Maybe<Lux_Proxy_Ami_Bool_Exp>;
  _or?: Maybe<Array<Lux_Proxy_Ami_Bool_Exp>>;
  ami_id?: Maybe<String_Comparison_Exp>;
  cloud?: Maybe<String_Comparison_Exp>;
  commit_hash?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  remarks?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "lux_proxy_ami" */
export enum Lux_Proxy_Ami_Constraint {
  /** unique or primary key constraint on columns "ami_id", "cloud", "region" */
  LuxProxyAmiPkey = 'lux_proxy_ami_pkey',
}

/** input type for inserting data into table "lux_proxy_ami" */
export type Lux_Proxy_Ami_Insert_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Lux_Proxy_Ami_Max_Fields = {
  __typename?: 'lux_proxy_ami_max_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Lux_Proxy_Ami_Min_Fields = {
  __typename?: 'lux_proxy_ami_min_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "lux_proxy_ami" */
export type Lux_Proxy_Ami_Mutation_Response = {
  __typename?: 'lux_proxy_ami_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Lux_Proxy_Ami>;
};

/** on_conflict condition type for table "lux_proxy_ami" */
export type Lux_Proxy_Ami_On_Conflict = {
  constraint: Lux_Proxy_Ami_Constraint;
  update_columns?: Array<Lux_Proxy_Ami_Update_Column>;
  where?: Maybe<Lux_Proxy_Ami_Bool_Exp>;
};

/** Ordering options when selecting data from "lux_proxy_ami". */
export type Lux_Proxy_Ami_Order_By = {
  ami_id?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  commit_hash?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  remarks?: Maybe<Order_By>;
};

/** primary key columns input for table: lux_proxy_ami */
export type Lux_Proxy_Ami_Pk_Columns_Input = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

/** select columns of table "lux_proxy_ami" */
export enum Lux_Proxy_Ami_Select_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CommitHash = 'commit_hash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Region = 'region',
  /** column name */
  Remarks = 'remarks',
}

/** input type for updating data in table "lux_proxy_ami" */
export type Lux_Proxy_Ami_Set_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "lux_proxy_ami" */
export type Lux_Proxy_Ami_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Lux_Proxy_Ami_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Lux_Proxy_Ami_Stream_Cursor_Value_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  commit_hash?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
};

/** update columns of table "lux_proxy_ami" */
export enum Lux_Proxy_Ami_Update_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CommitHash = 'commit_hash',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Region = 'region',
  /** column name */
  Remarks = 'remarks',
}

export type Lux_Proxy_Ami_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Lux_Proxy_Ami_Set_Input>;
  /** filter the rows which have to be updated */
  where: Lux_Proxy_Ami_Bool_Exp;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Lux_Proxy_Append_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "lux_proxy" */
export type Lux_Proxy_Arr_Rel_Insert_Input = {
  data: Array<Lux_Proxy_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Lux_Proxy_On_Conflict>;
};

/** Boolean expression to filter rows from the table "lux_proxy". All fields are combined with a logical 'AND'. */
export type Lux_Proxy_Bool_Exp = {
  _and?: Maybe<Array<Lux_Proxy_Bool_Exp>>;
  _not?: Maybe<Lux_Proxy_Bool_Exp>;
  _or?: Maybe<Array<Lux_Proxy_Bool_Exp>>;
  ami_id?: Maybe<String_Comparison_Exp>;
  cloud?: Maybe<String_Comparison_Exp>;
  comments?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  disable_infra_auto_apply?: Maybe<Boolean_Comparison_Exp>;
  infra_status?: Maybe<Infra_Status_Enum_Comparison_Exp>;
  input_variables?: Maybe<Jsonb_Comparison_Exp>;
  output_variables?: Maybe<Jsonb_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  region_info?: Maybe<Region_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "lux_proxy" */
export enum Lux_Proxy_Constraint {
  /** unique or primary key constraint on columns "cloud", "region" */
  LuxProxyPkey = 'lux_proxy_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Lux_Proxy_Delete_At_Path_Input = {
  input_variables?: Maybe<Array<Scalars['String']>>;
  output_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Lux_Proxy_Delete_Elem_Input = {
  input_variables?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Lux_Proxy_Delete_Key_Input = {
  input_variables?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "lux_proxy" */
export type Lux_Proxy_Insert_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  region_info?: Maybe<Region_Obj_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Lux_Proxy_Max_Fields = {
  __typename?: 'lux_proxy_max_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "lux_proxy" */
export type Lux_Proxy_Max_Order_By = {
  ami_id?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  comments?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Lux_Proxy_Min_Fields = {
  __typename?: 'lux_proxy_min_fields';
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "lux_proxy" */
export type Lux_Proxy_Min_Order_By = {
  ami_id?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  comments?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "lux_proxy" */
export type Lux_Proxy_Mutation_Response = {
  __typename?: 'lux_proxy_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Lux_Proxy>;
};

/** on_conflict condition type for table "lux_proxy" */
export type Lux_Proxy_On_Conflict = {
  constraint: Lux_Proxy_Constraint;
  update_columns?: Array<Lux_Proxy_Update_Column>;
  where?: Maybe<Lux_Proxy_Bool_Exp>;
};

/** Ordering options when selecting data from "lux_proxy". */
export type Lux_Proxy_Order_By = {
  ami_id?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  comments?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  disable_infra_auto_apply?: Maybe<Order_By>;
  infra_status?: Maybe<Order_By>;
  input_variables?: Maybe<Order_By>;
  output_variables?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  region_info?: Maybe<Region_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: lux_proxy */
export type Lux_Proxy_Pk_Columns_Input = {
  cloud: Scalars['String'];
  region: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Lux_Proxy_Prepend_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "lux_proxy" */
export enum Lux_Proxy_Select_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  Comments = 'comments',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** select "lux_proxy_aggregate_bool_exp_bool_and_arguments_columns" columns of table "lux_proxy" */
export enum Lux_Proxy_Select_Column_Lux_Proxy_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
}

/** select "lux_proxy_aggregate_bool_exp_bool_or_arguments_columns" columns of table "lux_proxy" */
export enum Lux_Proxy_Select_Column_Lux_Proxy_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
}

/** input type for updating data in table "lux_proxy" */
export type Lux_Proxy_Set_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "lux_proxy" */
export type Lux_Proxy_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Lux_Proxy_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Lux_Proxy_Stream_Cursor_Value_Input = {
  ami_id?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "lux_proxy" */
export enum Lux_Proxy_Update_Column {
  /** column name */
  AmiId = 'ami_id',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  Comments = 'comments',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Lux_Proxy_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Lux_Proxy_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Lux_Proxy_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Lux_Proxy_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Lux_Proxy_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Lux_Proxy_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Lux_Proxy_Set_Input>;
  /** filter the rows which have to be updated */
  where: Lux_Proxy_Bool_Exp;
};

export enum ModeEnum {
  Automatic = 'automatic',
  Manual = 'manual',
  PreviewApp = 'previewApp',
}

export type MoveProjectRegionResponse = {
  __typename?: 'MoveProjectRegionResponse';
  project?: Maybe<Projects>;
  projectId: Scalars['uuid'];
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  acceptBillingManagerInvite?: Maybe<BillingManagerInvitation>;
  acceptInvite: ProjectCollaboratorInvitation;
  acceptTransferOwnershipInvite: ProjectOwnershipTransferInvitation;
  addAzureMonitorConfig?: Maybe<AzureMonitorConfigResponse>;
  addCard?: Maybe<StripeCardResponse>;
  addCustomDomain?: Maybe<AddCustomDomainOutput>;
  addDatadogConfig?: Maybe<DatadogConfigResponse>;
  addFeatureRequest?: Maybe<FeatureRequestResponse>;
  addNewrelicConfig?: Maybe<NewrelicConfigResponse>;
  /** Add openTelemetry Integration to a project */
  addOpentelemetryConfig?: Maybe<OpentelemetryConfigResponse>;
  addProject: AddProjectResponse;
  /** Add Prometheus Integration to a project */
  addPrometheusConfig: PrometheusConfigResponse;
  applyCouponCode?: Maybe<CouponStatus>;
  changePlan?: Maybe<PlanResponse>;
  changeUserEmail: ChangeUserEmailRequest;
  checkDBLatency?: Maybe<CheckDbLatencyOutput>;
  completeChangeUserEmailRequest: ChangeUserEmailRequest;
  /** delete data from the table: "connector_deployment" */
  connector_delete_connector_deployment?: Maybe<Connector_Connector_Deployment_Mutation_Response>;
  /** delete single row from the table: "connector_deployment" */
  connector_delete_connector_deployment_by_pk?: Maybe<Connector_Connector_Deployment>;
  /** insert data into the table: "connector_deployment" */
  connector_insert_connector_deployment?: Maybe<Connector_Connector_Deployment_Mutation_Response>;
  /** insert a single row into the table: "connector_deployment" */
  connector_insert_connector_deployment_one?: Maybe<Connector_Connector_Deployment>;
  /** update data of the table: "connector_deployment" */
  connector_update_connector_deployment?: Maybe<Connector_Connector_Deployment_Mutation_Response>;
  /** update single row of the table: "connector_deployment" */
  connector_update_connector_deployment_by_pk?: Maybe<Connector_Connector_Deployment>;
  /** update multiples rows of table: "connector_deployment" */
  connector_update_connector_deployment_many?: Maybe<
    Array<Maybe<Connector_Connector_Deployment_Mutation_Response>>
  >;
  /** Internal utility action to convert a project's entitlements and plan to dedicated_cloud */
  convertToDedicatedCloud?: Maybe<ConvertPlanResponse>;
  createDedicatedVPC?: Maybe<CreateDedicatedVpcResponse>;
  createGithubIntegration?: Maybe<GithubIntegrationStatus>;
  createGitHubPreviewApp?: Maybe<PreviewAppResponse>;
  createInvoice: CreateInvoiceResponse;
  createJob: CreateJobResponse;
  createOneClickDeployment: CreateOneClickDeploymentOutput;
  createPersonalAccessToken: PersonalAccessToken;
  createTenant?: Maybe<CreateTenantResponse>;
  createZendeskSupportTicket: SuccessOrError;
  declineBillingManagerInvite?: Maybe<BillingManagerInvitation>;
  declineInvite: ProjectCollaboratorInvitation;
  declineTransferOwnershipInvite: ProjectOwnershipTransferInvitation;
  /** delete data from the table: "alert_config" */
  delete_alert_config?: Maybe<Alert_Config_Mutation_Response>;
  /** delete data from the table: "alert_config_alert_type" */
  delete_alert_config_alert_type?: Maybe<Alert_Config_Alert_Type_Mutation_Response>;
  /** delete single row from the table: "alert_config_alert_type" */
  delete_alert_config_alert_type_by_pk?: Maybe<Alert_Config_Alert_Type>;
  /** delete single row from the table: "alert_config" */
  delete_alert_config_by_pk?: Maybe<Alert_Config>;
  /** delete data from the table: "alert_config_service" */
  delete_alert_config_service?: Maybe<Alert_Config_Service_Mutation_Response>;
  /** delete single row from the table: "alert_config_service" */
  delete_alert_config_service_by_pk?: Maybe<Alert_Config_Service>;
  /** delete data from the table: "alert_service_type" */
  delete_alert_service_type?: Maybe<Alert_Service_Type_Mutation_Response>;
  /** delete single row from the table: "alert_service_type" */
  delete_alert_service_type_by_pk?: Maybe<Alert_Service_Type>;
  /** delete data from the table: "alert_type" */
  delete_alert_type?: Maybe<Alert_Type_Mutation_Response>;
  /** delete single row from the table: "alert_type" */
  delete_alert_type_by_pk?: Maybe<Alert_Type>;
  /** delete data from the table: "azuremonitor_config" */
  delete_azuremonitor_config?: Maybe<Azuremonitor_Config_Mutation_Response>;
  /** delete single row from the table: "azuremonitor_config" */
  delete_azuremonitor_config_by_pk?: Maybe<Azuremonitor_Config>;
  /** delete data from the table: "billing_address" */
  delete_billing_address?: Maybe<Billing_Address_Mutation_Response>;
  /** delete single row from the table: "billing_address" */
  delete_billing_address_by_pk?: Maybe<Billing_Address>;
  /** delete data from the table: "central_cloud" */
  delete_central_cloud?: Maybe<Central_Cloud_Mutation_Response>;
  /** delete single row from the table: "central_cloud" */
  delete_central_cloud_by_pk?: Maybe<Central_Cloud>;
  /** delete data from the table: "change_email_request" */
  delete_change_email_request?: Maybe<Change_Email_Request_Mutation_Response>;
  /** delete single row from the table: "change_email_request" */
  delete_change_email_request_by_pk?: Maybe<Change_Email_Request>;
  /** delete data from the table: "cicd.deployment_pipeline_config" */
  delete_cicd_deployment_pipeline_config?: Maybe<Cicd_Deployment_Pipeline_Config_Mutation_Response>;
  /** delete single row from the table: "cicd.deployment_pipeline_config" */
  delete_cicd_deployment_pipeline_config_by_pk?: Maybe<Cicd_Deployment_Pipeline_Config>;
  /** delete data from the table: "cicd.deployment_pool" */
  delete_cicd_deployment_pool?: Maybe<Cicd_Deployment_Pool_Mutation_Response>;
  /** delete data from the table: "cicd.deployment_pool_member" */
  delete_cicd_deployment_pool_member?: Maybe<Cicd_Deployment_Pool_Member_Mutation_Response>;
  /** delete data from the table: "cloud" */
  delete_cloud?: Maybe<Cloud_Mutation_Response>;
  /** delete single row from the table: "cloud" */
  delete_cloud_by_pk?: Maybe<Cloud>;
  /** delete data from the table: "cloud_metadata" */
  delete_cloud_metadata?: Maybe<Cloud_Metadata_Mutation_Response>;
  /** delete single row from the table: "cloud_metadata" */
  delete_cloud_metadata_by_pk?: Maybe<Cloud_Metadata>;
  /** delete data from the table: "compute_unit_config" */
  delete_compute_unit_config?: Maybe<Compute_Unit_Config_Mutation_Response>;
  /** delete single row from the table: "compute_unit_config" */
  delete_compute_unit_config_by_pk?: Maybe<Compute_Unit_Config>;
  /** delete data from the table: "config" */
  delete_config?: Maybe<Config_Mutation_Response>;
  /** delete single row from the table: "config" */
  delete_config_by_pk?: Maybe<Config>;
  /** delete data from the table: "config_status" */
  delete_config_status?: Maybe<Config_Status_Mutation_Response>;
  /** delete single row from the table: "config_status" */
  delete_config_status_by_pk?: Maybe<Config_Status>;
  /** delete data from the table: "connector_config" */
  delete_connector_config?: Maybe<Connector_Config_Mutation_Response>;
  /** delete single row from the table: "connector_config" */
  delete_connector_config_by_pk?: Maybe<Connector_Config>;
  /** delete data from the table: "connector_deployments" */
  delete_connector_deployments?: Maybe<Connector_Deployments_Mutation_Response>;
  /** delete single row from the table: "connector_deployments" */
  delete_connector_deployments_by_pk?: Maybe<Connector_Deployments>;
  /** delete data from the table: "coupon" */
  delete_coupon?: Maybe<Coupon_Mutation_Response>;
  /** delete single row from the table: "coupon" */
  delete_coupon_by_pk?: Maybe<Coupon>;
  /** delete data from the table: "coupon_duration" */
  delete_coupon_duration?: Maybe<Coupon_Duration_Mutation_Response>;
  /** delete single row from the table: "coupon_duration" */
  delete_coupon_duration_by_pk?: Maybe<Coupon_Duration>;
  /** delete data from the table: "coupon_type" */
  delete_coupon_type?: Maybe<Coupon_Type_Mutation_Response>;
  /** delete single row from the table: "coupon_type" */
  delete_coupon_type_by_pk?: Maybe<Coupon_Type>;
  /** delete data from the table: "custom_domain" */
  delete_custom_domain?: Maybe<Custom_Domain_Mutation_Response>;
  /** delete single row from the table: "custom_domain" */
  delete_custom_domain_by_pk?: Maybe<Custom_Domain>;
  /** delete data from the table: "custom_domain_cloudflare" */
  delete_custom_domain_cloudflare?: Maybe<Custom_Domain_Cloudflare_Mutation_Response>;
  /** delete single row from the table: "custom_domain_cloudflare" */
  delete_custom_domain_cloudflare_by_pk?: Maybe<Custom_Domain_Cloudflare>;
  /** delete data from the table: "custom_domain_cloudflare_dns" */
  delete_custom_domain_cloudflare_dns?: Maybe<Custom_Domain_Cloudflare_Dns_Mutation_Response>;
  /** delete single row from the table: "custom_domain_cloudflare_dns" */
  delete_custom_domain_cloudflare_dns_by_pk?: Maybe<Custom_Domain_Cloudflare_Dns>;
  /** delete data from the table: "customer_usage" */
  delete_customer_usage?: Maybe<Customer_Usage_Mutation_Response>;
  /** delete single row from the table: "customer_usage" */
  delete_customer_usage_by_pk?: Maybe<Customer_Usage>;
  /** delete data from the table: "data_connector_type" */
  delete_data_connector_type?: Maybe<Data_Connector_Type_Mutation_Response>;
  /** delete single row from the table: "data_connector_type" */
  delete_data_connector_type_by_pk?: Maybe<Data_Connector_Type>;
  /** delete data from the table: "datadog_config" */
  delete_datadog_config?: Maybe<Datadog_Config_Mutation_Response>;
  /** delete single row from the table: "datadog_config" */
  delete_datadog_config_by_pk?: Maybe<Datadog_Config>;
  /** delete data from the table: "db_latency" */
  delete_db_latency?: Maybe<Db_Latency_Mutation_Response>;
  /** delete single row from the table: "db_latency" */
  delete_db_latency_by_pk?: Maybe<Db_Latency>;
  /** delete data from the table: "ddn.build" */
  delete_ddn_build?: Maybe<Ddn_Build_Mutation_Response>;
  /** delete single row from the table: "ddn.build" */
  delete_ddn_build_by_pk?: Maybe<Ddn_Build>;
  /** delete data from the table: "ddn.build_sync_status" */
  delete_ddn_build_sync_status?: Maybe<Ddn_Build_Sync_Status_Mutation_Response>;
  /** delete single row from the table: "ddn.build_sync_status" */
  delete_ddn_build_sync_status_by_pk?: Maybe<Ddn_Build_Sync_Status>;
  /** delete data from the table: "ddn.build_sync_worker" */
  delete_ddn_build_sync_worker?: Maybe<Ddn_Build_Sync_Worker_Mutation_Response>;
  /** delete single row from the table: "ddn.build_sync_worker" */
  delete_ddn_build_sync_worker_by_pk?: Maybe<Ddn_Build_Sync_Worker>;
  /** delete data from the table: "ddn.environment" */
  delete_ddn_environment?: Maybe<Ddn_Environment_Mutation_Response>;
  /** delete single row from the table: "ddn.environment" */
  delete_ddn_environment_by_pk?: Maybe<Ddn_Environment>;
  /** delete data from the table: "ddn.project_entitlement_access" */
  delete_ddn_project_entitlement_access?: Maybe<Ddn_Project_Entitlement_Access_Mutation_Response>;
  /** delete single row from the table: "ddn.project_entitlement_access" */
  delete_ddn_project_entitlement_access_by_pk?: Maybe<Ddn_Project_Entitlement_Access>;
  /** delete data from the table: "ddn.project_entitlement_catalogue" */
  delete_ddn_project_entitlement_catalogue?: Maybe<Ddn_Project_Entitlement_Catalogue_Mutation_Response>;
  /** delete single row from the table: "ddn.project_entitlement_catalogue" */
  delete_ddn_project_entitlement_catalogue_by_pk?: Maybe<Ddn_Project_Entitlement_Catalogue>;
  /** delete data from the table: "ddn.project_entitlement_types" */
  delete_ddn_project_entitlement_types?: Maybe<Ddn_Project_Entitlement_Types_Mutation_Response>;
  /** delete single row from the table: "ddn.project_entitlement_types" */
  delete_ddn_project_entitlement_types_by_pk?: Maybe<Ddn_Project_Entitlement_Types>;
  /** delete data from the table: "ddn.projects" */
  delete_ddn_projects?: Maybe<Ddn_Projects_Mutation_Response>;
  /** delete single row from the table: "ddn.projects" */
  delete_ddn_projects_by_pk?: Maybe<Ddn_Projects>;
  /** delete data from the table: "ddn.tunnel" */
  delete_ddn_tunnel?: Maybe<Ddn_Tunnel_Mutation_Response>;
  /** delete single row from the table: "ddn.tunnel" */
  delete_ddn_tunnel_by_pk?: Maybe<Ddn_Tunnel>;
  /** delete data from the table: "ddn.tunnel_cluster" */
  delete_ddn_tunnel_cluster?: Maybe<Ddn_Tunnel_Cluster_Mutation_Response>;
  /** delete single row from the table: "ddn.tunnel_cluster" */
  delete_ddn_tunnel_cluster_by_pk?: Maybe<Ddn_Tunnel_Cluster>;
  /** delete data from the table: "dedicated_cloud_bills" */
  delete_dedicated_cloud_bills?: Maybe<Dedicated_Cloud_Bills_Mutation_Response>;
  /** delete single row from the table: "dedicated_cloud_bills" */
  delete_dedicated_cloud_bills_by_pk?: Maybe<Dedicated_Cloud_Bills>;
  /** delete data from the table: "dedicated_cloud_bills_details" */
  delete_dedicated_cloud_bills_details?: Maybe<Dedicated_Cloud_Bills_Details_Mutation_Response>;
  /** delete single row from the table: "dedicated_cloud_bills_details" */
  delete_dedicated_cloud_bills_details_by_pk?: Maybe<Dedicated_Cloud_Bills_Details>;
  /** delete data from the table: "dedicated_cloud_commitments" */
  delete_dedicated_cloud_commitments?: Maybe<Dedicated_Cloud_Commitments_Mutation_Response>;
  /** delete single row from the table: "dedicated_cloud_commitments" */
  delete_dedicated_cloud_commitments_by_pk?: Maybe<Dedicated_Cloud_Commitments>;
  /** delete data from the table: "dedicated_vpc" */
  delete_dedicated_vpc?: Maybe<Dedicated_Vpc_Mutation_Response>;
  /** delete single row from the table: "dedicated_vpc" */
  delete_dedicated_vpc_by_pk?: Maybe<Dedicated_Vpc>;
  /** delete data from the table: "delete_user" */
  delete_delete_user?: Maybe<Delete_User_Mutation_Response>;
  /** delete single row from the table: "delete_user" */
  delete_delete_user_by_pk?: Maybe<Delete_User>;
  /** delete data from the table: "delete_user_status" */
  delete_delete_user_status?: Maybe<Delete_User_Status_Mutation_Response>;
  /** delete single row from the table: "delete_user_status" */
  delete_delete_user_status_by_pk?: Maybe<Delete_User_Status>;
  /** delete data from the table: "delete_user_tasks" */
  delete_delete_user_tasks?: Maybe<Delete_User_Tasks_Mutation_Response>;
  /** delete single row from the table: "delete_user_tasks" */
  delete_delete_user_tasks_by_pk?: Maybe<Delete_User_Tasks>;
  /** delete data from the table: "email_log" */
  delete_email_log?: Maybe<Email_Log_Mutation_Response>;
  /** delete single row from the table: "email_log" */
  delete_email_log_by_pk?: Maybe<Email_Log>;
  /** delete data from the table: "enterprise_users" */
  delete_enterprise_users?: Maybe<Enterprise_Users_Mutation_Response>;
  /** delete single row from the table: "enterprise_users" */
  delete_enterprise_users_by_pk?: Maybe<Enterprise_Users>;
  /** delete data from the table: "experiments" */
  delete_experiments?: Maybe<Experiments_Mutation_Response>;
  /** delete single row from the table: "experiments" */
  delete_experiments_by_pk?: Maybe<Experiments>;
  /** delete data from the table: "experiments_cohort" */
  delete_experiments_cohort?: Maybe<Experiments_Cohort_Mutation_Response>;
  /** delete single row from the table: "experiments_cohort" */
  delete_experiments_cohort_by_pk?: Maybe<Experiments_Cohort>;
  /** delete data from the table: "experiments_config" */
  delete_experiments_config?: Maybe<Experiments_Config_Mutation_Response>;
  /** delete single row from the table: "experiments_config" */
  delete_experiments_config_by_pk?: Maybe<Experiments_Config>;
  /** delete data from the table: "feature" */
  delete_feature?: Maybe<Feature_Mutation_Response>;
  /** delete data from the table: "feature_access" */
  delete_feature_access?: Maybe<Feature_Access_Mutation_Response>;
  /** delete single row from the table: "feature_access" */
  delete_feature_access_by_pk?: Maybe<Feature_Access>;
  /** delete single row from the table: "feature" */
  delete_feature_by_pk?: Maybe<Feature>;
  /** delete data from the table: "feature_config" */
  delete_feature_config?: Maybe<Feature_Config_Mutation_Response>;
  /** delete single row from the table: "feature_config" */
  delete_feature_config_by_pk?: Maybe<Feature_Config>;
  /** delete data from the table: "gateway_ami" */
  delete_gateway_ami?: Maybe<Gateway_Ami_Mutation_Response>;
  /** delete single row from the table: "gateway_ami" */
  delete_gateway_ami_by_pk?: Maybe<Gateway_Ami>;
  /** delete data from the table: "gateway_cluster" */
  delete_gateway_cluster?: Maybe<Gateway_Cluster_Mutation_Response>;
  /** delete single row from the table: "gateway_cluster" */
  delete_gateway_cluster_by_pk?: Maybe<Gateway_Cluster>;
  /** delete data from the table: "gateway_worker" */
  delete_gateway_worker?: Maybe<Gateway_Worker_Mutation_Response>;
  /** delete single row from the table: "gateway_worker" */
  delete_gateway_worker_by_pk?: Maybe<Gateway_Worker>;
  /** delete data from the table: "github_email_type" */
  delete_github_email_type?: Maybe<Github_Email_Type_Mutation_Response>;
  /** delete single row from the table: "github_email_type" */
  delete_github_email_type_by_pk?: Maybe<Github_Email_Type>;
  /** delete data from the table: "github_integration_config" */
  delete_github_integration_config?: Maybe<Github_Integration_Config_Mutation_Response>;
  /** delete single row from the table: "github_integration_config" */
  delete_github_integration_config_by_pk?: Maybe<Github_Integration_Config>;
  /** delete data from the table: "github_integration_mode" */
  delete_github_integration_mode?: Maybe<Github_Integration_Mode_Mutation_Response>;
  /** delete single row from the table: "github_integration_mode" */
  delete_github_integration_mode_by_pk?: Maybe<Github_Integration_Mode>;
  /** delete data from the table: "github_push_event" */
  delete_github_push_event?: Maybe<Github_Push_Event_Mutation_Response>;
  /** delete single row from the table: "github_push_event" */
  delete_github_push_event_by_pk?: Maybe<Github_Push_Event>;
  /** delete data from the table: "github_push_event_job" */
  delete_github_push_event_job?: Maybe<Github_Push_Event_Job_Mutation_Response>;
  /** delete single row from the table: "github_push_event_job" */
  delete_github_push_event_job_by_pk?: Maybe<Github_Push_Event_Job>;
  /** delete data from the table: "hasura_ami" */
  delete_hasura_ami?: Maybe<Hasura_Ami_Mutation_Response>;
  /** delete single row from the table: "hasura_ami" */
  delete_hasura_ami_by_pk?: Maybe<Hasura_Ami>;
  /** delete data from the table: "hasura_cluster" */
  delete_hasura_cluster?: Maybe<Hasura_Cluster_Mutation_Response>;
  /** delete single row from the table: "hasura_cluster" */
  delete_hasura_cluster_by_pk?: Maybe<Hasura_Cluster>;
  /** delete data from the table: "hasura_worker" */
  delete_hasura_worker?: Maybe<Hasura_Worker_Mutation_Response>;
  /** delete single row from the table: "hasura_worker" */
  delete_hasura_worker_by_pk?: Maybe<Hasura_Worker>;
  /** delete data from the table: "heroku_integrations" */
  delete_heroku_integrations?: Maybe<Heroku_Integrations_Mutation_Response>;
  /** delete single row from the table: "heroku_integrations" */
  delete_heroku_integrations_by_pk?: Maybe<Heroku_Integrations>;
  /** delete data from the table: "inactive_project_exclusions" */
  delete_inactive_project_exclusions?: Maybe<Inactive_Project_Exclusions_Mutation_Response>;
  /** delete single row from the table: "inactive_project_exclusions" */
  delete_inactive_project_exclusions_by_pk?: Maybe<Inactive_Project_Exclusions>;
  /** delete data from the table: "inactive_project_notifications" */
  delete_inactive_project_notifications?: Maybe<Inactive_Project_Notifications_Mutation_Response>;
  /** delete single row from the table: "inactive_project_notifications" */
  delete_inactive_project_notifications_by_pk?: Maybe<Inactive_Project_Notifications>;
  /** delete data from the table: "inactive_project_suspension_config" */
  delete_inactive_project_suspension_config?: Maybe<Inactive_Project_Suspension_Config_Mutation_Response>;
  /** delete data from the table: "infra_status" */
  delete_infra_status?: Maybe<Infra_Status_Mutation_Response>;
  /** delete single row from the table: "infra_status" */
  delete_infra_status_by_pk?: Maybe<Infra_Status>;
  /** delete data from the table: "invoice" */
  delete_invoice?: Maybe<Invoice_Mutation_Response>;
  /** delete single row from the table: "invoice" */
  delete_invoice_by_pk?: Maybe<Invoice>;
  /** delete data from the table: "invoice_coupon_discount" */
  delete_invoice_coupon_discount?: Maybe<Invoice_Coupon_Discount_Mutation_Response>;
  /** delete single row from the table: "invoice_coupon_discount" */
  delete_invoice_coupon_discount_by_pk?: Maybe<Invoice_Coupon_Discount>;
  /** delete data from the table: "invoice_item" */
  delete_invoice_item?: Maybe<Invoice_Item_Mutation_Response>;
  /** delete single row from the table: "invoice_item" */
  delete_invoice_item_by_pk?: Maybe<Invoice_Item>;
  /** delete data from the table: "jobs" */
  delete_jobs?: Maybe<Jobs_Mutation_Response>;
  /** delete single row from the table: "jobs" */
  delete_jobs_by_pk?: Maybe<Jobs>;
  /** delete data from the table: "label" */
  delete_label?: Maybe<Label_Mutation_Response>;
  /** delete single row from the table: "label" */
  delete_label_by_pk?: Maybe<Label>;
  /** delete data from the table: "letsencrypt_status" */
  delete_letsencrypt_status?: Maybe<Letsencrypt_Status_Mutation_Response>;
  /** delete single row from the table: "letsencrypt_status" */
  delete_letsencrypt_status_by_pk?: Maybe<Letsencrypt_Status>;
  /** delete data from the table: "license_activity" */
  delete_license_activity?: Maybe<License_Activity_Mutation_Response>;
  /** delete single row from the table: "license_activity" */
  delete_license_activity_by_pk?: Maybe<License_Activity>;
  /** delete data from the table: "license_instance" */
  delete_license_instance?: Maybe<License_Instance_Mutation_Response>;
  /** delete single row from the table: "license_instance" */
  delete_license_instance_by_pk?: Maybe<License_Instance>;
  /** delete data from the table: "license_type" */
  delete_license_type?: Maybe<License_Type_Mutation_Response>;
  /** delete single row from the table: "license_type" */
  delete_license_type_by_pk?: Maybe<License_Type>;
  /** delete data from the table: "licenses" */
  delete_licenses?: Maybe<Licenses_Mutation_Response>;
  /** delete single row from the table: "licenses" */
  delete_licenses_by_pk?: Maybe<Licenses>;
  /** delete data from the table: "lux_proxy" */
  delete_lux_proxy?: Maybe<Lux_Proxy_Mutation_Response>;
  /** delete data from the table: "lux_proxy_ami" */
  delete_lux_proxy_ami?: Maybe<Lux_Proxy_Ami_Mutation_Response>;
  /** delete single row from the table: "lux_proxy_ami" */
  delete_lux_proxy_ami_by_pk?: Maybe<Lux_Proxy_Ami>;
  /** delete single row from the table: "lux_proxy" */
  delete_lux_proxy_by_pk?: Maybe<Lux_Proxy>;
  /** delete data from the table: "neon_db_integration" */
  delete_neon_db_integration?: Maybe<Neon_Db_Integration_Mutation_Response>;
  /** delete single row from the table: "neon_db_integration" */
  delete_neon_db_integration_by_pk?: Maybe<Neon_Db_Integration>;
  /** delete data from the table: "newrelic_config" */
  delete_newrelic_config?: Maybe<Newrelic_Config_Mutation_Response>;
  /** delete single row from the table: "newrelic_config" */
  delete_newrelic_config_by_pk?: Maybe<Newrelic_Config>;
  /** delete data from the table: "node_pool_type" */
  delete_node_pool_type?: Maybe<Node_Pool_Type_Mutation_Response>;
  /** delete single row from the table: "node_pool_type" */
  delete_node_pool_type_by_pk?: Maybe<Node_Pool_Type>;
  /** delete data from the table: "node_pools" */
  delete_node_pools?: Maybe<Node_Pools_Mutation_Response>;
  /** delete single row from the table: "node_pools" */
  delete_node_pools_by_pk?: Maybe<Node_Pools>;
  /** delete data from the table: "notification" */
  delete_notification?: Maybe<Notification_Mutation_Response>;
  /** delete single row from the table: "notification" */
  delete_notification_by_pk?: Maybe<Notification>;
  /** delete data from the table: "notification_type" */
  delete_notification_type?: Maybe<Notification_Type_Mutation_Response>;
  /** delete single row from the table: "notification_type" */
  delete_notification_type_by_pk?: Maybe<Notification_Type>;
  /** delete data from the table: "onboarding_sample_db_cohort" */
  delete_onboarding_sample_db_cohort?: Maybe<Onboarding_Sample_Db_Cohort_Mutation_Response>;
  /** delete single row from the table: "onboarding_sample_db_cohort" */
  delete_onboarding_sample_db_cohort_by_pk?: Maybe<Onboarding_Sample_Db_Cohort>;
  /** delete data from the table: "onboarding_sample_db_config" */
  delete_onboarding_sample_db_config?: Maybe<Onboarding_Sample_Db_Config_Mutation_Response>;
  /** delete single row from the table: "onboarding_sample_db_config" */
  delete_onboarding_sample_db_config_by_pk?: Maybe<Onboarding_Sample_Db_Config>;
  /** delete data from the table: "one_click_deployment" */
  delete_one_click_deployment?: Maybe<One_Click_Deployment_Mutation_Response>;
  /** delete single row from the table: "one_click_deployment" */
  delete_one_click_deployment_by_pk?: Maybe<One_Click_Deployment>;
  /** delete data from the table: "one_click_deployment_sample_apps" */
  delete_one_click_deployment_sample_apps?: Maybe<One_Click_Deployment_Sample_Apps_Mutation_Response>;
  /** delete single row from the table: "one_click_deployment_sample_apps" */
  delete_one_click_deployment_sample_apps_by_pk?: Maybe<One_Click_Deployment_Sample_Apps>;
  /** delete data from the table: "one_click_deployment_state_log" */
  delete_one_click_deployment_state_log?: Maybe<One_Click_Deployment_State_Log_Mutation_Response>;
  /** delete single row from the table: "one_click_deployment_state_log" */
  delete_one_click_deployment_state_log_by_pk?: Maybe<One_Click_Deployment_State_Log>;
  /** delete data from the table: "one_click_deployment_states" */
  delete_one_click_deployment_states?: Maybe<One_Click_Deployment_States_Mutation_Response>;
  /** delete single row from the table: "one_click_deployment_states" */
  delete_one_click_deployment_states_by_pk?: Maybe<One_Click_Deployment_States>;
  /** delete data from the table: "opentelemetry_config" */
  delete_opentelemetry_config?: Maybe<Opentelemetry_Config_Mutation_Response>;
  /** delete single row from the table: "opentelemetry_config" */
  delete_opentelemetry_config_by_pk?: Maybe<Opentelemetry_Config>;
  /** delete data from the table: "operations.delete_free_plan_dns_records_nov_2021" */
  delete_operations_delete_free_plan_dns_records_nov_2021?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Mutation_Response>;
  /** delete single row from the table: "operations.delete_free_plan_dns_records_nov_2021" */
  delete_operations_delete_free_plan_dns_records_nov_2021_by_pk?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021>;
  /** delete data from the table: "operations.tenant" */
  delete_operations_tenant?: Maybe<Operations_Tenant_Mutation_Response>;
  /** delete data from the table: "payment_method" */
  delete_payment_method?: Maybe<Payment_Method_Mutation_Response>;
  /** delete single row from the table: "payment_method" */
  delete_payment_method_by_pk?: Maybe<Payment_Method>;
  /** delete data from the table: "plan_entitlements" */
  delete_plan_entitlements?: Maybe<Plan_Entitlements_Mutation_Response>;
  /** delete single row from the table: "plan_entitlements" */
  delete_plan_entitlements_by_pk?: Maybe<Plan_Entitlements>;
  /** delete data from the table: "plans" */
  delete_plans?: Maybe<Plans_Mutation_Response>;
  /** delete single row from the table: "plans" */
  delete_plans_by_pk?: Maybe<Plans>;
  /** delete data from the table: "policies" */
  delete_policies?: Maybe<Policies_Mutation_Response>;
  /** delete single row from the table: "policies" */
  delete_policies_by_pk?: Maybe<Policies>;
  /** delete data from the table: "privileges" */
  delete_privileges?: Maybe<Privileges_Mutation_Response>;
  /** delete single row from the table: "privileges" */
  delete_privileges_by_pk?: Maybe<Privileges>;
  /** delete data from the table: "pro_license_keys" */
  delete_pro_license_keys?: Maybe<Pro_License_Keys_Mutation_Response>;
  /** delete single row from the table: "pro_license_keys" */
  delete_pro_license_keys_by_pk?: Maybe<Pro_License_Keys>;
  /** delete data from the table: "project_activity" */
  delete_project_activity?: Maybe<Project_Activity_Mutation_Response>;
  /** delete single row from the table: "project_activity" */
  delete_project_activity_by_pk?: Maybe<Project_Activity>;
  /** delete data from the table: "project_billing_manager_invitations" */
  delete_project_billing_manager_invitations?: Maybe<Project_Billing_Manager_Invitations_Mutation_Response>;
  /** delete single row from the table: "project_billing_manager_invitations" */
  delete_project_billing_manager_invitations_by_pk?: Maybe<Project_Billing_Manager_Invitations>;
  /** delete data from the table: "project_collaborator_allowed_schema_tables" */
  delete_project_collaborator_allowed_schema_tables?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Mutation_Response>;
  /** delete single row from the table: "project_collaborator_allowed_schema_tables" */
  delete_project_collaborator_allowed_schema_tables_by_pk?: Maybe<Project_Collaborator_Allowed_Schema_Tables>;
  /** delete data from the table: "project_collaborator_allowed_schemas" */
  delete_project_collaborator_allowed_schemas?: Maybe<Project_Collaborator_Allowed_Schemas_Mutation_Response>;
  /** delete single row from the table: "project_collaborator_allowed_schemas" */
  delete_project_collaborator_allowed_schemas_by_pk?: Maybe<Project_Collaborator_Allowed_Schemas>;
  /** delete data from the table: "project_collaborator_invitations" */
  delete_project_collaborator_invitations?: Maybe<Project_Collaborator_Invitations_Mutation_Response>;
  /** delete single row from the table: "project_collaborator_invitations" */
  delete_project_collaborator_invitations_by_pk?: Maybe<Project_Collaborator_Invitations>;
  /** delete data from the table: "project_collaborator_privileges" */
  delete_project_collaborator_privileges?: Maybe<Project_Collaborator_Privileges_Mutation_Response>;
  /** delete single row from the table: "project_collaborator_privileges" */
  delete_project_collaborator_privileges_by_pk?: Maybe<Project_Collaborator_Privileges>;
  /** delete data from the table: "project_collaborators" */
  delete_project_collaborators?: Maybe<Project_Collaborators_Mutation_Response>;
  /** delete single row from the table: "project_collaborators" */
  delete_project_collaborators_by_pk?: Maybe<Project_Collaborators>;
  /** delete data from the table: "project_data_usage" */
  delete_project_data_usage?: Maybe<Project_Data_Usage_Mutation_Response>;
  /** delete data from the table: "project_data_usage_agg" */
  delete_project_data_usage_agg?: Maybe<Project_Data_Usage_Agg_Mutation_Response>;
  /** delete data from the table: "project_data_usage_agg_user" */
  delete_project_data_usage_agg_user?: Maybe<Project_Data_Usage_Agg_User_Mutation_Response>;
  /** delete single row from the table: "project_data_usage" */
  delete_project_data_usage_by_pk?: Maybe<Project_Data_Usage>;
  /** delete data from the table: "project_data_usage_components" */
  delete_project_data_usage_components?: Maybe<Project_Data_Usage_Components_Mutation_Response>;
  /** delete data from the table: "project_data_usage_prometheus" */
  delete_project_data_usage_prometheus?: Maybe<Project_Data_Usage_Prometheus_Mutation_Response>;
  /** delete data from the table: "project_data_usage_prometheus_agg_user" */
  delete_project_data_usage_prometheus_agg_user?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Mutation_Response>;
  /** delete single row from the table: "project_data_usage_prometheus" */
  delete_project_data_usage_prometheus_by_pk?: Maybe<Project_Data_Usage_Prometheus>;
  /** delete data from the table: "project_data_usage_report" */
  delete_project_data_usage_report?: Maybe<Project_Data_Usage_Report_Mutation_Response>;
  /** delete single row from the table: "project_data_usage_report" */
  delete_project_data_usage_report_by_pk?: Maybe<Project_Data_Usage_Report>;
  /** delete data from the table: "project_db_usage" */
  delete_project_db_usage?: Maybe<Project_Db_Usage_Mutation_Response>;
  /** delete data from the table: "project_db_usage_agg_user" */
  delete_project_db_usage_agg_user?: Maybe<Project_Db_Usage_Agg_User_Mutation_Response>;
  /** delete single row from the table: "project_db_usage" */
  delete_project_db_usage_by_pk?: Maybe<Project_Db_Usage>;
  /** delete data from the table: "project_entitlement_access" */
  delete_project_entitlement_access?: Maybe<Project_Entitlement_Access_Mutation_Response>;
  /** delete single row from the table: "project_entitlement_access" */
  delete_project_entitlement_access_by_pk?: Maybe<Project_Entitlement_Access>;
  /** delete data from the table: "project_entitlement_catalogue" */
  delete_project_entitlement_catalogue?: Maybe<Project_Entitlement_Catalogue_Mutation_Response>;
  /** delete single row from the table: "project_entitlement_catalogue" */
  delete_project_entitlement_catalogue_by_pk?: Maybe<Project_Entitlement_Catalogue>;
  /** delete data from the table: "project_entitlement_types" */
  delete_project_entitlement_types?: Maybe<Project_Entitlement_Types_Mutation_Response>;
  /** delete single row from the table: "project_entitlement_types" */
  delete_project_entitlement_types_by_pk?: Maybe<Project_Entitlement_Types>;
  /** delete data from the table: "project_labels" */
  delete_project_labels?: Maybe<Project_Labels_Mutation_Response>;
  /** delete single row from the table: "project_labels" */
  delete_project_labels_by_pk?: Maybe<Project_Labels>;
  /** delete data from the table: "project_metadata" */
  delete_project_metadata?: Maybe<Project_Metadata_Mutation_Response>;
  /** delete single row from the table: "project_metadata" */
  delete_project_metadata_by_pk?: Maybe<Project_Metadata>;
  /** delete data from the table: "project_notification" */
  delete_project_notification?: Maybe<Project_Notification_Mutation_Response>;
  /** delete single row from the table: "project_notification" */
  delete_project_notification_by_pk?: Maybe<Project_Notification>;
  /** delete data from the table: "project_ownership_transfer_invitations" */
  delete_project_ownership_transfer_invitations?: Maybe<Project_Ownership_Transfer_Invitations_Mutation_Response>;
  /** delete single row from the table: "project_ownership_transfer_invitations" */
  delete_project_ownership_transfer_invitations_by_pk?: Maybe<Project_Ownership_Transfer_Invitations>;
  /** delete data from the table: "project_requests_count" */
  delete_project_requests_count?: Maybe<Project_Requests_Count_Mutation_Response>;
  /** delete single row from the table: "project_requests_count" */
  delete_project_requests_count_by_pk?: Maybe<Project_Requests_Count>;
  /** delete data from the table: "project_stats" */
  delete_project_stats?: Maybe<Project_Stats_Mutation_Response>;
  /** delete single row from the table: "project_stats" */
  delete_project_stats_by_pk?: Maybe<Project_Stats>;
  /** delete data from the table: "project_total_db_usage_agg" */
  delete_project_total_db_usage_agg?: Maybe<Project_Total_Db_Usage_Agg_Mutation_Response>;
  /** delete data from the table: "projects" */
  delete_projects?: Maybe<Projects_Mutation_Response>;
  /** delete single row from the table: "projects" */
  delete_projects_by_pk?: Maybe<Projects>;
  /** delete data from the table: "projects_pool_config" */
  delete_projects_pool_config?: Maybe<Projects_Pool_Config_Mutation_Response>;
  /** delete single row from the table: "projects_pool_config" */
  delete_projects_pool_config_by_pk?: Maybe<Projects_Pool_Config>;
  /** delete data from the table: "projects_pro_key_generations" */
  delete_projects_pro_key_generations?: Maybe<Projects_Pro_Key_Generations_Mutation_Response>;
  /** delete single row from the table: "projects_pro_key_generations" */
  delete_projects_pro_key_generations_by_pk?: Maybe<Projects_Pro_Key_Generations>;
  /** delete data from the table: "prometheus_config" */
  delete_prometheus_config?: Maybe<Prometheus_Config_Mutation_Response>;
  /** delete single row from the table: "prometheus_config" */
  delete_prometheus_config_by_pk?: Maybe<Prometheus_Config>;
  /** delete data from the table: "providers" */
  delete_providers?: Maybe<Providers_Mutation_Response>;
  /** delete single row from the table: "providers" */
  delete_providers_by_pk?: Maybe<Providers>;
  /** delete data from the table: "provisioning" */
  delete_provisioning?: Maybe<Provisioning_Mutation_Response>;
  /** delete single row from the table: "provisioning" */
  delete_provisioning_by_pk?: Maybe<Provisioning>;
  /** delete data from the table: "region" */
  delete_region?: Maybe<Region_Mutation_Response>;
  /** delete single row from the table: "region" */
  delete_region_by_pk?: Maybe<Region>;
  /** delete data from the table: "region_v2" */
  delete_region_v2?: Maybe<Region_V2_Mutation_Response>;
  /** delete data from the table: "regional_data_connectors" */
  delete_regional_data_connectors?: Maybe<Regional_Data_Connectors_Mutation_Response>;
  /** delete single row from the table: "regional_data_connectors" */
  delete_regional_data_connectors_by_pk?: Maybe<Regional_Data_Connectors>;
  /** delete data from the table: "regional_metrics" */
  delete_regional_metrics?: Maybe<Regional_Metrics_Mutation_Response>;
  /** delete single row from the table: "regional_metrics" */
  delete_regional_metrics_by_pk?: Maybe<Regional_Metrics>;
  /** delete data from the table: "saml_idp" */
  delete_saml_idp?: Maybe<Saml_Idp_Mutation_Response>;
  /** delete single row from the table: "saml_idp" */
  delete_saml_idp_by_pk?: Maybe<Saml_Idp>;
  /** delete data from the table: "search_project_login_status_results" */
  delete_search_project_login_status_results?: Maybe<Search_Project_Login_Status_Results_Mutation_Response>;
  /** delete data from the table: "slack_config" */
  delete_slack_config?: Maybe<Slack_Config_Mutation_Response>;
  /** delete single row from the table: "slack_config" */
  delete_slack_config_by_pk?: Maybe<Slack_Config>;
  /** delete data from the table: "stripe_subscription" */
  delete_stripe_subscription?: Maybe<Stripe_Subscription_Mutation_Response>;
  /** delete single row from the table: "stripe_subscription" */
  delete_stripe_subscription_by_pk?: Maybe<Stripe_Subscription>;
  /** delete data from the table: "stripe_webhook_events" */
  delete_stripe_webhook_events?: Maybe<Stripe_Webhook_Events_Mutation_Response>;
  /** delete single row from the table: "stripe_webhook_events" */
  delete_stripe_webhook_events_by_pk?: Maybe<Stripe_Webhook_Events>;
  /** delete data from the table: "super_connector_types" */
  delete_super_connector_types?: Maybe<Super_Connector_Types_Mutation_Response>;
  /** delete single row from the table: "super_connector_types" */
  delete_super_connector_types_by_pk?: Maybe<Super_Connector_Types>;
  /** delete data from the table: "support_plan_types" */
  delete_support_plan_types?: Maybe<Support_Plan_Types_Mutation_Response>;
  /** delete single row from the table: "support_plan_types" */
  delete_support_plan_types_by_pk?: Maybe<Support_Plan_Types>;
  /** delete data from the table: "survey" */
  delete_survey?: Maybe<Survey_Mutation_Response>;
  /** delete single row from the table: "survey" */
  delete_survey_by_pk?: Maybe<Survey>;
  /** delete data from the table: "survey_question" */
  delete_survey_question?: Maybe<Survey_Question_Mutation_Response>;
  /** delete data from the table: "survey_question_answer_option" */
  delete_survey_question_answer_option?: Maybe<Survey_Question_Answer_Option_Mutation_Response>;
  /** delete single row from the table: "survey_question_answer_option" */
  delete_survey_question_answer_option_by_pk?: Maybe<Survey_Question_Answer_Option>;
  /** delete data from the table: "survey_question_answers" */
  delete_survey_question_answers?: Maybe<Survey_Question_Answers_Mutation_Response>;
  /** delete single row from the table: "survey_question_answers" */
  delete_survey_question_answers_by_pk?: Maybe<Survey_Question_Answers>;
  /** delete single row from the table: "survey_question" */
  delete_survey_question_by_pk?: Maybe<Survey_Question>;
  /** delete data from the table: "survey_question_kind" */
  delete_survey_question_kind?: Maybe<Survey_Question_Kind_Mutation_Response>;
  /** delete single row from the table: "survey_question_kind" */
  delete_survey_question_kind_by_pk?: Maybe<Survey_Question_Kind>;
  /** delete data from the table: "survey_question_options" */
  delete_survey_question_options?: Maybe<Survey_Question_Options_Mutation_Response>;
  /** delete single row from the table: "survey_question_options" */
  delete_survey_question_options_by_pk?: Maybe<Survey_Question_Options>;
  /** delete data from the table: "survey_v2" */
  delete_survey_v2?: Maybe<Survey_V2_Mutation_Response>;
  /** delete single row from the table: "survey_v2" */
  delete_survey_v2_by_pk?: Maybe<Survey_V2>;
  /** delete data from the table: "survey_v2_question" */
  delete_survey_v2_question?: Maybe<Survey_V2_Question_Mutation_Response>;
  /** delete single row from the table: "survey_v2_question" */
  delete_survey_v2_question_by_pk?: Maybe<Survey_V2_Question>;
  /** delete data from the table: "survey_v2_question_kind" */
  delete_survey_v2_question_kind?: Maybe<Survey_V2_Question_Kind_Mutation_Response>;
  /** delete single row from the table: "survey_v2_question_kind" */
  delete_survey_v2_question_kind_by_pk?: Maybe<Survey_V2_Question_Kind>;
  /** delete data from the table: "survey_v2_question_option" */
  delete_survey_v2_question_option?: Maybe<Survey_V2_Question_Option_Mutation_Response>;
  /** delete data from the table: "survey_v2_question_option_additional_info_config" */
  delete_survey_v2_question_option_additional_info_config?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Mutation_Response>;
  /** delete single row from the table: "survey_v2_question_option_additional_info_config" */
  delete_survey_v2_question_option_additional_info_config_by_pk?: Maybe<Survey_V2_Question_Option_Additional_Info_Config>;
  /** delete single row from the table: "survey_v2_question_option" */
  delete_survey_v2_question_option_by_pk?: Maybe<Survey_V2_Question_Option>;
  /** delete data from the table: "survey_v2_response" */
  delete_survey_v2_response?: Maybe<Survey_V2_Response_Mutation_Response>;
  /** delete data from the table: "survey_v2_response_answer" */
  delete_survey_v2_response_answer?: Maybe<Survey_V2_Response_Answer_Mutation_Response>;
  /** delete single row from the table: "survey_v2_response_answer" */
  delete_survey_v2_response_answer_by_pk?: Maybe<Survey_V2_Response_Answer>;
  /** delete data from the table: "survey_v2_response_answer_option" */
  delete_survey_v2_response_answer_option?: Maybe<Survey_V2_Response_Answer_Option_Mutation_Response>;
  /** delete single row from the table: "survey_v2_response_answer_option" */
  delete_survey_v2_response_answer_option_by_pk?: Maybe<Survey_V2_Response_Answer_Option>;
  /** delete single row from the table: "survey_v2_response" */
  delete_survey_v2_response_by_pk?: Maybe<Survey_V2_Response>;
  /** delete data from the table: "task_event" */
  delete_task_event?: Maybe<Task_Event_Mutation_Response>;
  /** delete single row from the table: "task_event" */
  delete_task_event_by_pk?: Maybe<Task_Event>;
  /** delete data from the table: "tasks" */
  delete_tasks?: Maybe<Tasks_Mutation_Response>;
  /** delete single row from the table: "tasks" */
  delete_tasks_by_pk?: Maybe<Tasks>;
  /** delete data from the table: "tenant" */
  delete_tenant?: Maybe<Tenant_Mutation_Response>;
  /** delete data from the table: "tenant_active_status_reason" */
  delete_tenant_active_status_reason?: Maybe<Tenant_Active_Status_Reason_Mutation_Response>;
  /** delete single row from the table: "tenant_active_status_reason" */
  delete_tenant_active_status_reason_by_pk?: Maybe<Tenant_Active_Status_Reason>;
  /** delete single row from the table: "tenant" */
  delete_tenant_by_pk?: Maybe<Tenant>;
  /** delete data from the table: "tenant_group" */
  delete_tenant_group?: Maybe<Tenant_Group_Mutation_Response>;
  /** delete single row from the table: "tenant_group" */
  delete_tenant_group_by_pk?: Maybe<Tenant_Group>;
  /** delete data from the table: "tenant_group_member" */
  delete_tenant_group_member?: Maybe<Tenant_Group_Member_Mutation_Response>;
  /** delete single row from the table: "tenant_group_member" */
  delete_tenant_group_member_by_pk?: Maybe<Tenant_Group_Member>;
  /** delete data from the table: "tenant_public_status" */
  delete_tenant_public_status?: Maybe<Tenant_Public_Status_Mutation_Response>;
  /** delete single row from the table: "tenant_public_status" */
  delete_tenant_public_status_by_pk?: Maybe<Tenant_Public_Status>;
  /** delete data from the table: "tenant_status" */
  delete_tenant_status?: Maybe<Tenant_Status_Mutation_Response>;
  /** delete single row from the table: "tenant_status" */
  delete_tenant_status_by_pk?: Maybe<Tenant_Status>;
  /** delete data from the table: "trial_leads" */
  delete_trial_leads?: Maybe<Trial_Leads_Mutation_Response>;
  /** delete single row from the table: "trial_leads" */
  delete_trial_leads_by_pk?: Maybe<Trial_Leads>;
  /** delete data from the table: "ua_audit_logs" */
  delete_ua_audit_logs?: Maybe<Ua_Audit_Logs_Mutation_Response>;
  /** delete single row from the table: "ua_audit_logs" */
  delete_ua_audit_logs_by_pk?: Maybe<Ua_Audit_Logs>;
  /** delete data from the table: "user_activity" */
  delete_user_activity?: Maybe<User_Activity_Mutation_Response>;
  /** delete single row from the table: "user_activity" */
  delete_user_activity_by_pk?: Maybe<User_Activity>;
  /** delete data from the table: "user_coupon" */
  delete_user_coupon?: Maybe<User_Coupon_Mutation_Response>;
  /** delete single row from the table: "user_coupon" */
  delete_user_coupon_by_pk?: Maybe<User_Coupon>;
  /** delete data from the table: "user_entitlement_access" */
  delete_user_entitlement_access?: Maybe<User_Entitlement_Access_Mutation_Response>;
  /** delete single row from the table: "user_entitlement_access" */
  delete_user_entitlement_access_by_pk?: Maybe<User_Entitlement_Access>;
  /** delete data from the table: "user_entitlement_catalogue" */
  delete_user_entitlement_catalogue?: Maybe<User_Entitlement_Catalogue_Mutation_Response>;
  /** delete single row from the table: "user_entitlement_catalogue" */
  delete_user_entitlement_catalogue_by_pk?: Maybe<User_Entitlement_Catalogue>;
  /** delete data from the table: "user_entitlement_types" */
  delete_user_entitlement_types?: Maybe<User_Entitlement_Types_Mutation_Response>;
  /** delete single row from the table: "user_entitlement_types" */
  delete_user_entitlement_types_by_pk?: Maybe<User_Entitlement_Types>;
  /** delete data from the table: "user_onboarding" */
  delete_user_onboarding?: Maybe<User_Onboarding_Mutation_Response>;
  /** delete single row from the table: "user_onboarding" */
  delete_user_onboarding_by_pk?: Maybe<User_Onboarding>;
  /** delete data from the table: "user_personal_access_tokens" */
  delete_user_personal_access_tokens?: Maybe<User_Personal_Access_Tokens_Mutation_Response>;
  /** delete single row from the table: "user_personal_access_tokens" */
  delete_user_personal_access_tokens_by_pk?: Maybe<User_Personal_Access_Tokens>;
  /** delete data from the table: "user_profile" */
  delete_user_profile?: Maybe<User_Profile_Mutation_Response>;
  /** delete single row from the table: "user_profile" */
  delete_user_profile_by_pk?: Maybe<User_Profile>;
  /** delete data from the table: "user_roles" */
  delete_user_roles?: Maybe<User_Roles_Mutation_Response>;
  /** delete single row from the table: "user_roles" */
  delete_user_roles_by_pk?: Maybe<User_Roles>;
  /** delete data from the table: "user_vpc_policy" */
  delete_user_vpc_policy?: Maybe<User_Vpc_Policy_Mutation_Response>;
  /** delete single row from the table: "user_vpc_policy" */
  delete_user_vpc_policy_by_pk?: Maybe<User_Vpc_Policy>;
  /** delete data from the table: "users" */
  delete_users?: Maybe<Users_Mutation_Response>;
  /** delete single row from the table: "users" */
  delete_users_by_pk?: Maybe<Users>;
  /** delete data from the table: "users_public" */
  delete_users_public?: Maybe<Users_Public_Mutation_Response>;
  /** delete data from the table: "vercel_integration" */
  delete_vercel_integration?: Maybe<Vercel_Integration_Mutation_Response>;
  /** delete single row from the table: "vercel_integration" */
  delete_vercel_integration_by_pk?: Maybe<Vercel_Integration>;
  /** delete data from the table: "vercel_integration_connections" */
  delete_vercel_integration_connections?: Maybe<Vercel_Integration_Connections_Mutation_Response>;
  /** delete single row from the table: "vercel_integration_connections" */
  delete_vercel_integration_connections_by_pk?: Maybe<Vercel_Integration_Connections>;
  /** delete data from the table: "vpc_peering" */
  delete_vpc_peering?: Maybe<Vpc_Peering_Mutation_Response>;
  /** delete single row from the table: "vpc_peering" */
  delete_vpc_peering_by_pk?: Maybe<Vpc_Peering>;
  /** delete data from the table: "vpc_peering_direction" */
  delete_vpc_peering_direction?: Maybe<Vpc_Peering_Direction_Mutation_Response>;
  /** delete single row from the table: "vpc_peering_direction" */
  delete_vpc_peering_direction_by_pk?: Maybe<Vpc_Peering_Direction>;
  /** delete data from the table: "vpc_status" */
  delete_vpc_status?: Maybe<Vpc_Status_Mutation_Response>;
  /** delete single row from the table: "vpc_status" */
  delete_vpc_status_by_pk?: Maybe<Vpc_Status>;
  /** delete data from the table: "zendesk_support_category" */
  delete_zendesk_support_category?: Maybe<Zendesk_Support_Category_Mutation_Response>;
  /** delete single row from the table: "zendesk_support_category" */
  delete_zendesk_support_category_by_pk?: Maybe<Zendesk_Support_Category>;
  /** delete data from the table: "zendesk_support_tickets" */
  delete_zendesk_support_tickets?: Maybe<Zendesk_Support_Tickets_Mutation_Response>;
  /** delete single row from the table: "zendesk_support_tickets" */
  delete_zendesk_support_tickets_by_pk?: Maybe<Zendesk_Support_Tickets>;
  deleteCard?: Maybe<DeleteCardResponse>;
  deleteProject: DeleteProjectResponse;
  /** deletes the slack app integrated with the project ID. */
  deleteSlackApp?: Maybe<DeleteSlackAppOutput>;
  deleteTenant?: Maybe<TenantDeleteResponse>;
  deleteTenantEnv?: Maybe<TenantEnv>;
  deleteUser?: Maybe<DeleteUserResponse>;
  deployLatestGithubCommit?: Maybe<DeployLatestCommitStatus>;
  enableCloudflareProxy?: Maybe<EnableCloudflareProxyResponse>;
  getGithubSession?: Maybe<GithubSession>;
  getHerokuSession?: Maybe<HerokuSession>;
  githubTokenExchange?: Maybe<GithubSession>;
  handleInactiveProjects?: Maybe<HandleInactiveProjectsResult>;
  herokuRegisterWebhook: WebhookRegisterStatus;
  herokuRegisterWebhookVar: WebhookRegisterStatus;
  herokuTokenExchange?: Maybe<HerokuSession>;
  herokuUnregisterWebhook: WebhookUnregisterStatus;
  herokuUnregisterWebhookVar: WebhookUnregisterStatus;
  initiateStripeAddCardProcess: ClientSecretInfo;
  /** insert data into the table: "alert_config" */
  insert_alert_config?: Maybe<Alert_Config_Mutation_Response>;
  /** insert data into the table: "alert_config_alert_type" */
  insert_alert_config_alert_type?: Maybe<Alert_Config_Alert_Type_Mutation_Response>;
  /** insert a single row into the table: "alert_config_alert_type" */
  insert_alert_config_alert_type_one?: Maybe<Alert_Config_Alert_Type>;
  /** insert a single row into the table: "alert_config" */
  insert_alert_config_one?: Maybe<Alert_Config>;
  /** insert data into the table: "alert_config_service" */
  insert_alert_config_service?: Maybe<Alert_Config_Service_Mutation_Response>;
  /** insert a single row into the table: "alert_config_service" */
  insert_alert_config_service_one?: Maybe<Alert_Config_Service>;
  /** insert data into the table: "alert_service_type" */
  insert_alert_service_type?: Maybe<Alert_Service_Type_Mutation_Response>;
  /** insert a single row into the table: "alert_service_type" */
  insert_alert_service_type_one?: Maybe<Alert_Service_Type>;
  /** insert data into the table: "alert_type" */
  insert_alert_type?: Maybe<Alert_Type_Mutation_Response>;
  /** insert a single row into the table: "alert_type" */
  insert_alert_type_one?: Maybe<Alert_Type>;
  /** insert data into the table: "azuremonitor_config" */
  insert_azuremonitor_config?: Maybe<Azuremonitor_Config_Mutation_Response>;
  /** insert a single row into the table: "azuremonitor_config" */
  insert_azuremonitor_config_one?: Maybe<Azuremonitor_Config>;
  /** insert data into the table: "billing_address" */
  insert_billing_address?: Maybe<Billing_Address_Mutation_Response>;
  /** insert a single row into the table: "billing_address" */
  insert_billing_address_one?: Maybe<Billing_Address>;
  /** insert data into the table: "central_cloud" */
  insert_central_cloud?: Maybe<Central_Cloud_Mutation_Response>;
  /** insert a single row into the table: "central_cloud" */
  insert_central_cloud_one?: Maybe<Central_Cloud>;
  /** insert data into the table: "change_email_request" */
  insert_change_email_request?: Maybe<Change_Email_Request_Mutation_Response>;
  /** insert a single row into the table: "change_email_request" */
  insert_change_email_request_one?: Maybe<Change_Email_Request>;
  /** insert data into the table: "cicd.deployment_pipeline_config" */
  insert_cicd_deployment_pipeline_config?: Maybe<Cicd_Deployment_Pipeline_Config_Mutation_Response>;
  /** insert a single row into the table: "cicd.deployment_pipeline_config" */
  insert_cicd_deployment_pipeline_config_one?: Maybe<Cicd_Deployment_Pipeline_Config>;
  /** insert data into the table: "cicd.deployment_pool" */
  insert_cicd_deployment_pool?: Maybe<Cicd_Deployment_Pool_Mutation_Response>;
  /** insert data into the table: "cicd.deployment_pool_member" */
  insert_cicd_deployment_pool_member?: Maybe<Cicd_Deployment_Pool_Member_Mutation_Response>;
  /** insert a single row into the table: "cicd.deployment_pool_member" */
  insert_cicd_deployment_pool_member_one?: Maybe<Cicd_Deployment_Pool_Member>;
  /** insert a single row into the table: "cicd.deployment_pool" */
  insert_cicd_deployment_pool_one?: Maybe<Cicd_Deployment_Pool>;
  /** insert data into the table: "cloud" */
  insert_cloud?: Maybe<Cloud_Mutation_Response>;
  /** insert data into the table: "cloud_metadata" */
  insert_cloud_metadata?: Maybe<Cloud_Metadata_Mutation_Response>;
  /** insert a single row into the table: "cloud_metadata" */
  insert_cloud_metadata_one?: Maybe<Cloud_Metadata>;
  /** insert a single row into the table: "cloud" */
  insert_cloud_one?: Maybe<Cloud>;
  /** insert data into the table: "compute_unit_config" */
  insert_compute_unit_config?: Maybe<Compute_Unit_Config_Mutation_Response>;
  /** insert a single row into the table: "compute_unit_config" */
  insert_compute_unit_config_one?: Maybe<Compute_Unit_Config>;
  /** insert data into the table: "config" */
  insert_config?: Maybe<Config_Mutation_Response>;
  /** insert a single row into the table: "config" */
  insert_config_one?: Maybe<Config>;
  /** insert data into the table: "config_status" */
  insert_config_status?: Maybe<Config_Status_Mutation_Response>;
  /** insert a single row into the table: "config_status" */
  insert_config_status_one?: Maybe<Config_Status>;
  /** insert data into the table: "connector_config" */
  insert_connector_config?: Maybe<Connector_Config_Mutation_Response>;
  /** insert a single row into the table: "connector_config" */
  insert_connector_config_one?: Maybe<Connector_Config>;
  /** insert data into the table: "connector_deployments" */
  insert_connector_deployments?: Maybe<Connector_Deployments_Mutation_Response>;
  /** insert a single row into the table: "connector_deployments" */
  insert_connector_deployments_one?: Maybe<Connector_Deployments>;
  /** insert data into the table: "coupon" */
  insert_coupon?: Maybe<Coupon_Mutation_Response>;
  /** insert data into the table: "coupon_duration" */
  insert_coupon_duration?: Maybe<Coupon_Duration_Mutation_Response>;
  /** insert a single row into the table: "coupon_duration" */
  insert_coupon_duration_one?: Maybe<Coupon_Duration>;
  /** insert a single row into the table: "coupon" */
  insert_coupon_one?: Maybe<Coupon>;
  /** insert data into the table: "coupon_type" */
  insert_coupon_type?: Maybe<Coupon_Type_Mutation_Response>;
  /** insert a single row into the table: "coupon_type" */
  insert_coupon_type_one?: Maybe<Coupon_Type>;
  /** insert data into the table: "custom_domain" */
  insert_custom_domain?: Maybe<Custom_Domain_Mutation_Response>;
  /** insert data into the table: "custom_domain_cloudflare" */
  insert_custom_domain_cloudflare?: Maybe<Custom_Domain_Cloudflare_Mutation_Response>;
  /** insert data into the table: "custom_domain_cloudflare_dns" */
  insert_custom_domain_cloudflare_dns?: Maybe<Custom_Domain_Cloudflare_Dns_Mutation_Response>;
  /** insert a single row into the table: "custom_domain_cloudflare_dns" */
  insert_custom_domain_cloudflare_dns_one?: Maybe<Custom_Domain_Cloudflare_Dns>;
  /** insert a single row into the table: "custom_domain_cloudflare" */
  insert_custom_domain_cloudflare_one?: Maybe<Custom_Domain_Cloudflare>;
  /** insert a single row into the table: "custom_domain" */
  insert_custom_domain_one?: Maybe<Custom_Domain>;
  /** insert data into the table: "customer_usage" */
  insert_customer_usage?: Maybe<Customer_Usage_Mutation_Response>;
  /** insert a single row into the table: "customer_usage" */
  insert_customer_usage_one?: Maybe<Customer_Usage>;
  /** insert data into the table: "data_connector_type" */
  insert_data_connector_type?: Maybe<Data_Connector_Type_Mutation_Response>;
  /** insert a single row into the table: "data_connector_type" */
  insert_data_connector_type_one?: Maybe<Data_Connector_Type>;
  /** insert data into the table: "datadog_config" */
  insert_datadog_config?: Maybe<Datadog_Config_Mutation_Response>;
  /** insert a single row into the table: "datadog_config" */
  insert_datadog_config_one?: Maybe<Datadog_Config>;
  /** insert data into the table: "db_latency" */
  insert_db_latency?: Maybe<Db_Latency_Mutation_Response>;
  /** insert a single row into the table: "db_latency" */
  insert_db_latency_one?: Maybe<Db_Latency>;
  /** execute VOLATILE function "insert_db_usage" which returns "project_db_usage" */
  insert_db_usage: Array<Project_Db_Usage>;
  /** insert data into the table: "ddn.build" */
  insert_ddn_build?: Maybe<Ddn_Build_Mutation_Response>;
  /** insert a single row into the table: "ddn.build" */
  insert_ddn_build_one?: Maybe<Ddn_Build>;
  /** insert data into the table: "ddn.build_sync_status" */
  insert_ddn_build_sync_status?: Maybe<Ddn_Build_Sync_Status_Mutation_Response>;
  /** insert a single row into the table: "ddn.build_sync_status" */
  insert_ddn_build_sync_status_one?: Maybe<Ddn_Build_Sync_Status>;
  /** insert data into the table: "ddn.build_sync_worker" */
  insert_ddn_build_sync_worker?: Maybe<Ddn_Build_Sync_Worker_Mutation_Response>;
  /** insert a single row into the table: "ddn.build_sync_worker" */
  insert_ddn_build_sync_worker_one?: Maybe<Ddn_Build_Sync_Worker>;
  /** insert data into the table: "ddn.environment" */
  insert_ddn_environment?: Maybe<Ddn_Environment_Mutation_Response>;
  /** insert a single row into the table: "ddn.environment" */
  insert_ddn_environment_one?: Maybe<Ddn_Environment>;
  /** insert data into the table: "ddn.project_entitlement_access" */
  insert_ddn_project_entitlement_access?: Maybe<Ddn_Project_Entitlement_Access_Mutation_Response>;
  /** insert a single row into the table: "ddn.project_entitlement_access" */
  insert_ddn_project_entitlement_access_one?: Maybe<Ddn_Project_Entitlement_Access>;
  /** insert data into the table: "ddn.project_entitlement_catalogue" */
  insert_ddn_project_entitlement_catalogue?: Maybe<Ddn_Project_Entitlement_Catalogue_Mutation_Response>;
  /** insert a single row into the table: "ddn.project_entitlement_catalogue" */
  insert_ddn_project_entitlement_catalogue_one?: Maybe<Ddn_Project_Entitlement_Catalogue>;
  /** insert data into the table: "ddn.project_entitlement_types" */
  insert_ddn_project_entitlement_types?: Maybe<Ddn_Project_Entitlement_Types_Mutation_Response>;
  /** insert a single row into the table: "ddn.project_entitlement_types" */
  insert_ddn_project_entitlement_types_one?: Maybe<Ddn_Project_Entitlement_Types>;
  /** insert data into the table: "ddn.projects" */
  insert_ddn_projects?: Maybe<Ddn_Projects_Mutation_Response>;
  /** insert a single row into the table: "ddn.projects" */
  insert_ddn_projects_one?: Maybe<Ddn_Projects>;
  /** insert data into the table: "ddn.tunnel" */
  insert_ddn_tunnel?: Maybe<Ddn_Tunnel_Mutation_Response>;
  /** insert data into the table: "ddn.tunnel_cluster" */
  insert_ddn_tunnel_cluster?: Maybe<Ddn_Tunnel_Cluster_Mutation_Response>;
  /** insert a single row into the table: "ddn.tunnel_cluster" */
  insert_ddn_tunnel_cluster_one?: Maybe<Ddn_Tunnel_Cluster>;
  /** insert a single row into the table: "ddn.tunnel" */
  insert_ddn_tunnel_one?: Maybe<Ddn_Tunnel>;
  /** insert data into the table: "dedicated_cloud_bills" */
  insert_dedicated_cloud_bills?: Maybe<Dedicated_Cloud_Bills_Mutation_Response>;
  /** insert data into the table: "dedicated_cloud_bills_details" */
  insert_dedicated_cloud_bills_details?: Maybe<Dedicated_Cloud_Bills_Details_Mutation_Response>;
  /** insert a single row into the table: "dedicated_cloud_bills_details" */
  insert_dedicated_cloud_bills_details_one?: Maybe<Dedicated_Cloud_Bills_Details>;
  /** insert a single row into the table: "dedicated_cloud_bills" */
  insert_dedicated_cloud_bills_one?: Maybe<Dedicated_Cloud_Bills>;
  /** insert data into the table: "dedicated_cloud_commitments" */
  insert_dedicated_cloud_commitments?: Maybe<Dedicated_Cloud_Commitments_Mutation_Response>;
  /** insert a single row into the table: "dedicated_cloud_commitments" */
  insert_dedicated_cloud_commitments_one?: Maybe<Dedicated_Cloud_Commitments>;
  /** insert data into the table: "dedicated_vpc" */
  insert_dedicated_vpc?: Maybe<Dedicated_Vpc_Mutation_Response>;
  /** insert a single row into the table: "dedicated_vpc" */
  insert_dedicated_vpc_one?: Maybe<Dedicated_Vpc>;
  /** insert data into the table: "delete_user" */
  insert_delete_user?: Maybe<Delete_User_Mutation_Response>;
  /** insert a single row into the table: "delete_user" */
  insert_delete_user_one?: Maybe<Delete_User>;
  /** insert data into the table: "delete_user_status" */
  insert_delete_user_status?: Maybe<Delete_User_Status_Mutation_Response>;
  /** insert a single row into the table: "delete_user_status" */
  insert_delete_user_status_one?: Maybe<Delete_User_Status>;
  /** insert data into the table: "delete_user_tasks" */
  insert_delete_user_tasks?: Maybe<Delete_User_Tasks_Mutation_Response>;
  /** insert a single row into the table: "delete_user_tasks" */
  insert_delete_user_tasks_one?: Maybe<Delete_User_Tasks>;
  /** insert data into the table: "email_log" */
  insert_email_log?: Maybe<Email_Log_Mutation_Response>;
  /** insert a single row into the table: "email_log" */
  insert_email_log_one?: Maybe<Email_Log>;
  /** insert data into the table: "enterprise_users" */
  insert_enterprise_users?: Maybe<Enterprise_Users_Mutation_Response>;
  /** insert a single row into the table: "enterprise_users" */
  insert_enterprise_users_one?: Maybe<Enterprise_Users>;
  /** insert data into the table: "experiments" */
  insert_experiments?: Maybe<Experiments_Mutation_Response>;
  /** insert data into the table: "experiments_cohort" */
  insert_experiments_cohort?: Maybe<Experiments_Cohort_Mutation_Response>;
  /** insert a single row into the table: "experiments_cohort" */
  insert_experiments_cohort_one?: Maybe<Experiments_Cohort>;
  /** insert data into the table: "experiments_config" */
  insert_experiments_config?: Maybe<Experiments_Config_Mutation_Response>;
  /** insert a single row into the table: "experiments_config" */
  insert_experiments_config_one?: Maybe<Experiments_Config>;
  /** insert a single row into the table: "experiments" */
  insert_experiments_one?: Maybe<Experiments>;
  /** insert data into the table: "feature" */
  insert_feature?: Maybe<Feature_Mutation_Response>;
  /** insert data into the table: "feature_access" */
  insert_feature_access?: Maybe<Feature_Access_Mutation_Response>;
  /** insert a single row into the table: "feature_access" */
  insert_feature_access_one?: Maybe<Feature_Access>;
  /** insert data into the table: "feature_config" */
  insert_feature_config?: Maybe<Feature_Config_Mutation_Response>;
  /** insert a single row into the table: "feature_config" */
  insert_feature_config_one?: Maybe<Feature_Config>;
  /** insert a single row into the table: "feature" */
  insert_feature_one?: Maybe<Feature>;
  /** insert data into the table: "gateway_ami" */
  insert_gateway_ami?: Maybe<Gateway_Ami_Mutation_Response>;
  /** insert a single row into the table: "gateway_ami" */
  insert_gateway_ami_one?: Maybe<Gateway_Ami>;
  /** insert data into the table: "gateway_cluster" */
  insert_gateway_cluster?: Maybe<Gateway_Cluster_Mutation_Response>;
  /** insert a single row into the table: "gateway_cluster" */
  insert_gateway_cluster_one?: Maybe<Gateway_Cluster>;
  /** insert data into the table: "gateway_worker" */
  insert_gateway_worker?: Maybe<Gateway_Worker_Mutation_Response>;
  /** insert a single row into the table: "gateway_worker" */
  insert_gateway_worker_one?: Maybe<Gateway_Worker>;
  /** insert data into the table: "github_email_type" */
  insert_github_email_type?: Maybe<Github_Email_Type_Mutation_Response>;
  /** insert a single row into the table: "github_email_type" */
  insert_github_email_type_one?: Maybe<Github_Email_Type>;
  /** insert data into the table: "github_integration_config" */
  insert_github_integration_config?: Maybe<Github_Integration_Config_Mutation_Response>;
  /** insert a single row into the table: "github_integration_config" */
  insert_github_integration_config_one?: Maybe<Github_Integration_Config>;
  /** insert data into the table: "github_integration_mode" */
  insert_github_integration_mode?: Maybe<Github_Integration_Mode_Mutation_Response>;
  /** insert a single row into the table: "github_integration_mode" */
  insert_github_integration_mode_one?: Maybe<Github_Integration_Mode>;
  /** insert data into the table: "github_push_event" */
  insert_github_push_event?: Maybe<Github_Push_Event_Mutation_Response>;
  /** insert data into the table: "github_push_event_job" */
  insert_github_push_event_job?: Maybe<Github_Push_Event_Job_Mutation_Response>;
  /** insert a single row into the table: "github_push_event_job" */
  insert_github_push_event_job_one?: Maybe<Github_Push_Event_Job>;
  /** insert a single row into the table: "github_push_event" */
  insert_github_push_event_one?: Maybe<Github_Push_Event>;
  /** insert data into the table: "hasura_ami" */
  insert_hasura_ami?: Maybe<Hasura_Ami_Mutation_Response>;
  /** insert a single row into the table: "hasura_ami" */
  insert_hasura_ami_one?: Maybe<Hasura_Ami>;
  /** insert data into the table: "hasura_cluster" */
  insert_hasura_cluster?: Maybe<Hasura_Cluster_Mutation_Response>;
  /** insert a single row into the table: "hasura_cluster" */
  insert_hasura_cluster_one?: Maybe<Hasura_Cluster>;
  /** insert data into the table: "hasura_worker" */
  insert_hasura_worker?: Maybe<Hasura_Worker_Mutation_Response>;
  /** insert a single row into the table: "hasura_worker" */
  insert_hasura_worker_one?: Maybe<Hasura_Worker>;
  /** insert data into the table: "heroku_integrations" */
  insert_heroku_integrations?: Maybe<Heroku_Integrations_Mutation_Response>;
  /** insert a single row into the table: "heroku_integrations" */
  insert_heroku_integrations_one?: Maybe<Heroku_Integrations>;
  /** insert data into the table: "inactive_project_exclusions" */
  insert_inactive_project_exclusions?: Maybe<Inactive_Project_Exclusions_Mutation_Response>;
  /** insert a single row into the table: "inactive_project_exclusions" */
  insert_inactive_project_exclusions_one?: Maybe<Inactive_Project_Exclusions>;
  /** insert data into the table: "inactive_project_notifications" */
  insert_inactive_project_notifications?: Maybe<Inactive_Project_Notifications_Mutation_Response>;
  /** insert a single row into the table: "inactive_project_notifications" */
  insert_inactive_project_notifications_one?: Maybe<Inactive_Project_Notifications>;
  /** insert data into the table: "inactive_project_suspension_config" */
  insert_inactive_project_suspension_config?: Maybe<Inactive_Project_Suspension_Config_Mutation_Response>;
  /** insert a single row into the table: "inactive_project_suspension_config" */
  insert_inactive_project_suspension_config_one?: Maybe<Inactive_Project_Suspension_Config>;
  /** insert data into the table: "infra_status" */
  insert_infra_status?: Maybe<Infra_Status_Mutation_Response>;
  /** insert a single row into the table: "infra_status" */
  insert_infra_status_one?: Maybe<Infra_Status>;
  /** insert data into the table: "invoice" */
  insert_invoice?: Maybe<Invoice_Mutation_Response>;
  /** insert data into the table: "invoice_coupon_discount" */
  insert_invoice_coupon_discount?: Maybe<Invoice_Coupon_Discount_Mutation_Response>;
  /** insert a single row into the table: "invoice_coupon_discount" */
  insert_invoice_coupon_discount_one?: Maybe<Invoice_Coupon_Discount>;
  /** insert data into the table: "invoice_item" */
  insert_invoice_item?: Maybe<Invoice_Item_Mutation_Response>;
  /** insert a single row into the table: "invoice_item" */
  insert_invoice_item_one?: Maybe<Invoice_Item>;
  /** insert a single row into the table: "invoice" */
  insert_invoice_one?: Maybe<Invoice>;
  /** insert data into the table: "jobs" */
  insert_jobs?: Maybe<Jobs_Mutation_Response>;
  /** insert a single row into the table: "jobs" */
  insert_jobs_one?: Maybe<Jobs>;
  /** insert data into the table: "label" */
  insert_label?: Maybe<Label_Mutation_Response>;
  /** insert a single row into the table: "label" */
  insert_label_one?: Maybe<Label>;
  /** insert data into the table: "letsencrypt_status" */
  insert_letsencrypt_status?: Maybe<Letsencrypt_Status_Mutation_Response>;
  /** insert a single row into the table: "letsencrypt_status" */
  insert_letsencrypt_status_one?: Maybe<Letsencrypt_Status>;
  /** insert data into the table: "license_activity" */
  insert_license_activity?: Maybe<License_Activity_Mutation_Response>;
  /** insert a single row into the table: "license_activity" */
  insert_license_activity_one?: Maybe<License_Activity>;
  /** insert data into the table: "license_instance" */
  insert_license_instance?: Maybe<License_Instance_Mutation_Response>;
  /** insert a single row into the table: "license_instance" */
  insert_license_instance_one?: Maybe<License_Instance>;
  /** insert data into the table: "license_type" */
  insert_license_type?: Maybe<License_Type_Mutation_Response>;
  /** insert a single row into the table: "license_type" */
  insert_license_type_one?: Maybe<License_Type>;
  /** insert data into the table: "licenses" */
  insert_licenses?: Maybe<Licenses_Mutation_Response>;
  /** insert a single row into the table: "licenses" */
  insert_licenses_one?: Maybe<Licenses>;
  /** insert data into the table: "lux_proxy" */
  insert_lux_proxy?: Maybe<Lux_Proxy_Mutation_Response>;
  /** insert data into the table: "lux_proxy_ami" */
  insert_lux_proxy_ami?: Maybe<Lux_Proxy_Ami_Mutation_Response>;
  /** insert a single row into the table: "lux_proxy_ami" */
  insert_lux_proxy_ami_one?: Maybe<Lux_Proxy_Ami>;
  /** insert a single row into the table: "lux_proxy" */
  insert_lux_proxy_one?: Maybe<Lux_Proxy>;
  /** insert data into the table: "neon_db_integration" */
  insert_neon_db_integration?: Maybe<Neon_Db_Integration_Mutation_Response>;
  /** insert a single row into the table: "neon_db_integration" */
  insert_neon_db_integration_one?: Maybe<Neon_Db_Integration>;
  /** insert data into the table: "newrelic_config" */
  insert_newrelic_config?: Maybe<Newrelic_Config_Mutation_Response>;
  /** insert a single row into the table: "newrelic_config" */
  insert_newrelic_config_one?: Maybe<Newrelic_Config>;
  /** insert data into the table: "node_pool_type" */
  insert_node_pool_type?: Maybe<Node_Pool_Type_Mutation_Response>;
  /** insert a single row into the table: "node_pool_type" */
  insert_node_pool_type_one?: Maybe<Node_Pool_Type>;
  /** insert data into the table: "node_pools" */
  insert_node_pools?: Maybe<Node_Pools_Mutation_Response>;
  /** insert a single row into the table: "node_pools" */
  insert_node_pools_one?: Maybe<Node_Pools>;
  /** insert data into the table: "notification" */
  insert_notification?: Maybe<Notification_Mutation_Response>;
  /** insert a single row into the table: "notification" */
  insert_notification_one?: Maybe<Notification>;
  /** insert data into the table: "notification_type" */
  insert_notification_type?: Maybe<Notification_Type_Mutation_Response>;
  /** insert a single row into the table: "notification_type" */
  insert_notification_type_one?: Maybe<Notification_Type>;
  /** insert data into the table: "onboarding_sample_db_cohort" */
  insert_onboarding_sample_db_cohort?: Maybe<Onboarding_Sample_Db_Cohort_Mutation_Response>;
  /** insert a single row into the table: "onboarding_sample_db_cohort" */
  insert_onboarding_sample_db_cohort_one?: Maybe<Onboarding_Sample_Db_Cohort>;
  /** insert data into the table: "onboarding_sample_db_config" */
  insert_onboarding_sample_db_config?: Maybe<Onboarding_Sample_Db_Config_Mutation_Response>;
  /** insert a single row into the table: "onboarding_sample_db_config" */
  insert_onboarding_sample_db_config_one?: Maybe<Onboarding_Sample_Db_Config>;
  /** insert data into the table: "one_click_deployment" */
  insert_one_click_deployment?: Maybe<One_Click_Deployment_Mutation_Response>;
  /** insert a single row into the table: "one_click_deployment" */
  insert_one_click_deployment_one?: Maybe<One_Click_Deployment>;
  /** insert data into the table: "one_click_deployment_sample_apps" */
  insert_one_click_deployment_sample_apps?: Maybe<One_Click_Deployment_Sample_Apps_Mutation_Response>;
  /** insert a single row into the table: "one_click_deployment_sample_apps" */
  insert_one_click_deployment_sample_apps_one?: Maybe<One_Click_Deployment_Sample_Apps>;
  /** insert data into the table: "one_click_deployment_state_log" */
  insert_one_click_deployment_state_log?: Maybe<One_Click_Deployment_State_Log_Mutation_Response>;
  /** insert a single row into the table: "one_click_deployment_state_log" */
  insert_one_click_deployment_state_log_one?: Maybe<One_Click_Deployment_State_Log>;
  /** insert data into the table: "one_click_deployment_states" */
  insert_one_click_deployment_states?: Maybe<One_Click_Deployment_States_Mutation_Response>;
  /** insert a single row into the table: "one_click_deployment_states" */
  insert_one_click_deployment_states_one?: Maybe<One_Click_Deployment_States>;
  /** insert data into the table: "opentelemetry_config" */
  insert_opentelemetry_config?: Maybe<Opentelemetry_Config_Mutation_Response>;
  /** insert a single row into the table: "opentelemetry_config" */
  insert_opentelemetry_config_one?: Maybe<Opentelemetry_Config>;
  /** insert data into the table: "operations.delete_free_plan_dns_records_nov_2021" */
  insert_operations_delete_free_plan_dns_records_nov_2021?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Mutation_Response>;
  /** insert a single row into the table: "operations.delete_free_plan_dns_records_nov_2021" */
  insert_operations_delete_free_plan_dns_records_nov_2021_one?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021>;
  /** insert data into the table: "operations.tenant" */
  insert_operations_tenant?: Maybe<Operations_Tenant_Mutation_Response>;
  /** insert a single row into the table: "operations.tenant" */
  insert_operations_tenant_one?: Maybe<Operations_Tenant>;
  /** insert data into the table: "payment_method" */
  insert_payment_method?: Maybe<Payment_Method_Mutation_Response>;
  /** insert a single row into the table: "payment_method" */
  insert_payment_method_one?: Maybe<Payment_Method>;
  /** insert data into the table: "plan_entitlements" */
  insert_plan_entitlements?: Maybe<Plan_Entitlements_Mutation_Response>;
  /** insert a single row into the table: "plan_entitlements" */
  insert_plan_entitlements_one?: Maybe<Plan_Entitlements>;
  /** insert data into the table: "plans" */
  insert_plans?: Maybe<Plans_Mutation_Response>;
  /** insert a single row into the table: "plans" */
  insert_plans_one?: Maybe<Plans>;
  /** insert data into the table: "policies" */
  insert_policies?: Maybe<Policies_Mutation_Response>;
  /** insert a single row into the table: "policies" */
  insert_policies_one?: Maybe<Policies>;
  /** insert data into the table: "privileges" */
  insert_privileges?: Maybe<Privileges_Mutation_Response>;
  /** insert a single row into the table: "privileges" */
  insert_privileges_one?: Maybe<Privileges>;
  /** insert data into the table: "pro_license_keys" */
  insert_pro_license_keys?: Maybe<Pro_License_Keys_Mutation_Response>;
  /** insert a single row into the table: "pro_license_keys" */
  insert_pro_license_keys_one?: Maybe<Pro_License_Keys>;
  /** insert data into the table: "project_activity" */
  insert_project_activity?: Maybe<Project_Activity_Mutation_Response>;
  /** insert a single row into the table: "project_activity" */
  insert_project_activity_one?: Maybe<Project_Activity>;
  /** insert data into the table: "project_billing_manager_invitations" */
  insert_project_billing_manager_invitations?: Maybe<Project_Billing_Manager_Invitations_Mutation_Response>;
  /** insert a single row into the table: "project_billing_manager_invitations" */
  insert_project_billing_manager_invitations_one?: Maybe<Project_Billing_Manager_Invitations>;
  /** insert data into the table: "project_collaborator_allowed_schema_tables" */
  insert_project_collaborator_allowed_schema_tables?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Mutation_Response>;
  /** insert a single row into the table: "project_collaborator_allowed_schema_tables" */
  insert_project_collaborator_allowed_schema_tables_one?: Maybe<Project_Collaborator_Allowed_Schema_Tables>;
  /** insert data into the table: "project_collaborator_allowed_schemas" */
  insert_project_collaborator_allowed_schemas?: Maybe<Project_Collaborator_Allowed_Schemas_Mutation_Response>;
  /** insert a single row into the table: "project_collaborator_allowed_schemas" */
  insert_project_collaborator_allowed_schemas_one?: Maybe<Project_Collaborator_Allowed_Schemas>;
  /** insert data into the table: "project_collaborator_invitations" */
  insert_project_collaborator_invitations?: Maybe<Project_Collaborator_Invitations_Mutation_Response>;
  /** insert a single row into the table: "project_collaborator_invitations" */
  insert_project_collaborator_invitations_one?: Maybe<Project_Collaborator_Invitations>;
  /** insert data into the table: "project_collaborator_privileges" */
  insert_project_collaborator_privileges?: Maybe<Project_Collaborator_Privileges_Mutation_Response>;
  /** insert a single row into the table: "project_collaborator_privileges" */
  insert_project_collaborator_privileges_one?: Maybe<Project_Collaborator_Privileges>;
  /** insert data into the table: "project_collaborators" */
  insert_project_collaborators?: Maybe<Project_Collaborators_Mutation_Response>;
  /** insert a single row into the table: "project_collaborators" */
  insert_project_collaborators_one?: Maybe<Project_Collaborators>;
  /** insert data into the table: "project_data_usage" */
  insert_project_data_usage?: Maybe<Project_Data_Usage_Mutation_Response>;
  /** insert data into the table: "project_data_usage_agg" */
  insert_project_data_usage_agg?: Maybe<Project_Data_Usage_Agg_Mutation_Response>;
  /** insert a single row into the table: "project_data_usage_agg" */
  insert_project_data_usage_agg_one?: Maybe<Project_Data_Usage_Agg>;
  /** insert data into the table: "project_data_usage_agg_user" */
  insert_project_data_usage_agg_user?: Maybe<Project_Data_Usage_Agg_User_Mutation_Response>;
  /** insert a single row into the table: "project_data_usage_agg_user" */
  insert_project_data_usage_agg_user_one?: Maybe<Project_Data_Usage_Agg_User>;
  /** insert data into the table: "project_data_usage_components" */
  insert_project_data_usage_components?: Maybe<Project_Data_Usage_Components_Mutation_Response>;
  /** insert a single row into the table: "project_data_usage_components" */
  insert_project_data_usage_components_one?: Maybe<Project_Data_Usage_Components>;
  /** insert a single row into the table: "project_data_usage" */
  insert_project_data_usage_one?: Maybe<Project_Data_Usage>;
  /** insert data into the table: "project_data_usage_prometheus" */
  insert_project_data_usage_prometheus?: Maybe<Project_Data_Usage_Prometheus_Mutation_Response>;
  /** insert data into the table: "project_data_usage_prometheus_agg_user" */
  insert_project_data_usage_prometheus_agg_user?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Mutation_Response>;
  /** insert a single row into the table: "project_data_usage_prometheus_agg_user" */
  insert_project_data_usage_prometheus_agg_user_one?: Maybe<Project_Data_Usage_Prometheus_Agg_User>;
  /** insert a single row into the table: "project_data_usage_prometheus" */
  insert_project_data_usage_prometheus_one?: Maybe<Project_Data_Usage_Prometheus>;
  /** insert data into the table: "project_data_usage_report" */
  insert_project_data_usage_report?: Maybe<Project_Data_Usage_Report_Mutation_Response>;
  /** insert a single row into the table: "project_data_usage_report" */
  insert_project_data_usage_report_one?: Maybe<Project_Data_Usage_Report>;
  /** insert data into the table: "project_db_usage" */
  insert_project_db_usage?: Maybe<Project_Db_Usage_Mutation_Response>;
  /** insert data into the table: "project_db_usage_agg_user" */
  insert_project_db_usage_agg_user?: Maybe<Project_Db_Usage_Agg_User_Mutation_Response>;
  /** insert a single row into the table: "project_db_usage_agg_user" */
  insert_project_db_usage_agg_user_one?: Maybe<Project_Db_Usage_Agg_User>;
  /** insert a single row into the table: "project_db_usage" */
  insert_project_db_usage_one?: Maybe<Project_Db_Usage>;
  /** insert data into the table: "project_entitlement_access" */
  insert_project_entitlement_access?: Maybe<Project_Entitlement_Access_Mutation_Response>;
  /** insert a single row into the table: "project_entitlement_access" */
  insert_project_entitlement_access_one?: Maybe<Project_Entitlement_Access>;
  /** insert data into the table: "project_entitlement_catalogue" */
  insert_project_entitlement_catalogue?: Maybe<Project_Entitlement_Catalogue_Mutation_Response>;
  /** insert a single row into the table: "project_entitlement_catalogue" */
  insert_project_entitlement_catalogue_one?: Maybe<Project_Entitlement_Catalogue>;
  /** insert data into the table: "project_entitlement_types" */
  insert_project_entitlement_types?: Maybe<Project_Entitlement_Types_Mutation_Response>;
  /** insert a single row into the table: "project_entitlement_types" */
  insert_project_entitlement_types_one?: Maybe<Project_Entitlement_Types>;
  /** insert data into the table: "project_labels" */
  insert_project_labels?: Maybe<Project_Labels_Mutation_Response>;
  /** insert a single row into the table: "project_labels" */
  insert_project_labels_one?: Maybe<Project_Labels>;
  /** insert data into the table: "project_metadata" */
  insert_project_metadata?: Maybe<Project_Metadata_Mutation_Response>;
  /** insert a single row into the table: "project_metadata" */
  insert_project_metadata_one?: Maybe<Project_Metadata>;
  /** insert data into the table: "project_notification" */
  insert_project_notification?: Maybe<Project_Notification_Mutation_Response>;
  /** insert a single row into the table: "project_notification" */
  insert_project_notification_one?: Maybe<Project_Notification>;
  /** insert data into the table: "project_ownership_transfer_invitations" */
  insert_project_ownership_transfer_invitations?: Maybe<Project_Ownership_Transfer_Invitations_Mutation_Response>;
  /** insert a single row into the table: "project_ownership_transfer_invitations" */
  insert_project_ownership_transfer_invitations_one?: Maybe<Project_Ownership_Transfer_Invitations>;
  /** insert data into the table: "project_requests_count" */
  insert_project_requests_count?: Maybe<Project_Requests_Count_Mutation_Response>;
  /** insert a single row into the table: "project_requests_count" */
  insert_project_requests_count_one?: Maybe<Project_Requests_Count>;
  /** insert data into the table: "project_stats" */
  insert_project_stats?: Maybe<Project_Stats_Mutation_Response>;
  /** insert a single row into the table: "project_stats" */
  insert_project_stats_one?: Maybe<Project_Stats>;
  /** insert data into the table: "project_total_db_usage_agg" */
  insert_project_total_db_usage_agg?: Maybe<Project_Total_Db_Usage_Agg_Mutation_Response>;
  /** insert a single row into the table: "project_total_db_usage_agg" */
  insert_project_total_db_usage_agg_one?: Maybe<Project_Total_Db_Usage_Agg>;
  /** insert data into the table: "projects" */
  insert_projects?: Maybe<Projects_Mutation_Response>;
  /** insert a single row into the table: "projects" */
  insert_projects_one?: Maybe<Projects>;
  /** insert data into the table: "projects_pool_config" */
  insert_projects_pool_config?: Maybe<Projects_Pool_Config_Mutation_Response>;
  /** insert a single row into the table: "projects_pool_config" */
  insert_projects_pool_config_one?: Maybe<Projects_Pool_Config>;
  /** insert data into the table: "projects_pro_key_generations" */
  insert_projects_pro_key_generations?: Maybe<Projects_Pro_Key_Generations_Mutation_Response>;
  /** insert a single row into the table: "projects_pro_key_generations" */
  insert_projects_pro_key_generations_one?: Maybe<Projects_Pro_Key_Generations>;
  /** insert data into the table: "prometheus_config" */
  insert_prometheus_config?: Maybe<Prometheus_Config_Mutation_Response>;
  /** insert a single row into the table: "prometheus_config" */
  insert_prometheus_config_one?: Maybe<Prometheus_Config>;
  /** insert data into the table: "providers" */
  insert_providers?: Maybe<Providers_Mutation_Response>;
  /** insert a single row into the table: "providers" */
  insert_providers_one?: Maybe<Providers>;
  /** insert data into the table: "provisioning" */
  insert_provisioning?: Maybe<Provisioning_Mutation_Response>;
  /** insert a single row into the table: "provisioning" */
  insert_provisioning_one?: Maybe<Provisioning>;
  /** insert data into the table: "region" */
  insert_region?: Maybe<Region_Mutation_Response>;
  /** insert a single row into the table: "region" */
  insert_region_one?: Maybe<Region>;
  /** insert data into the table: "region_v2" */
  insert_region_v2?: Maybe<Region_V2_Mutation_Response>;
  /** insert a single row into the table: "region_v2" */
  insert_region_v2_one?: Maybe<Region_V2>;
  /** insert data into the table: "regional_data_connectors" */
  insert_regional_data_connectors?: Maybe<Regional_Data_Connectors_Mutation_Response>;
  /** insert a single row into the table: "regional_data_connectors" */
  insert_regional_data_connectors_one?: Maybe<Regional_Data_Connectors>;
  /** insert data into the table: "regional_metrics" */
  insert_regional_metrics?: Maybe<Regional_Metrics_Mutation_Response>;
  /** insert a single row into the table: "regional_metrics" */
  insert_regional_metrics_one?: Maybe<Regional_Metrics>;
  /** insert data into the table: "saml_idp" */
  insert_saml_idp?: Maybe<Saml_Idp_Mutation_Response>;
  /** insert a single row into the table: "saml_idp" */
  insert_saml_idp_one?: Maybe<Saml_Idp>;
  /** insert data into the table: "search_project_login_status_results" */
  insert_search_project_login_status_results?: Maybe<Search_Project_Login_Status_Results_Mutation_Response>;
  /** insert a single row into the table: "search_project_login_status_results" */
  insert_search_project_login_status_results_one?: Maybe<Search_Project_Login_Status_Results>;
  /** insert data into the table: "slack_config" */
  insert_slack_config?: Maybe<Slack_Config_Mutation_Response>;
  /** insert a single row into the table: "slack_config" */
  insert_slack_config_one?: Maybe<Slack_Config>;
  /** insert data into the table: "stripe_subscription" */
  insert_stripe_subscription?: Maybe<Stripe_Subscription_Mutation_Response>;
  /** insert a single row into the table: "stripe_subscription" */
  insert_stripe_subscription_one?: Maybe<Stripe_Subscription>;
  /** insert data into the table: "stripe_webhook_events" */
  insert_stripe_webhook_events?: Maybe<Stripe_Webhook_Events_Mutation_Response>;
  /** insert a single row into the table: "stripe_webhook_events" */
  insert_stripe_webhook_events_one?: Maybe<Stripe_Webhook_Events>;
  /** insert data into the table: "super_connector_types" */
  insert_super_connector_types?: Maybe<Super_Connector_Types_Mutation_Response>;
  /** insert a single row into the table: "super_connector_types" */
  insert_super_connector_types_one?: Maybe<Super_Connector_Types>;
  /** insert data into the table: "support_plan_types" */
  insert_support_plan_types?: Maybe<Support_Plan_Types_Mutation_Response>;
  /** insert a single row into the table: "support_plan_types" */
  insert_support_plan_types_one?: Maybe<Support_Plan_Types>;
  /** insert data into the table: "survey" */
  insert_survey?: Maybe<Survey_Mutation_Response>;
  /** insert a single row into the table: "survey" */
  insert_survey_one?: Maybe<Survey>;
  /** insert data into the table: "survey_question" */
  insert_survey_question?: Maybe<Survey_Question_Mutation_Response>;
  /** insert data into the table: "survey_question_answer_option" */
  insert_survey_question_answer_option?: Maybe<Survey_Question_Answer_Option_Mutation_Response>;
  /** insert a single row into the table: "survey_question_answer_option" */
  insert_survey_question_answer_option_one?: Maybe<Survey_Question_Answer_Option>;
  /** insert data into the table: "survey_question_answers" */
  insert_survey_question_answers?: Maybe<Survey_Question_Answers_Mutation_Response>;
  /** insert a single row into the table: "survey_question_answers" */
  insert_survey_question_answers_one?: Maybe<Survey_Question_Answers>;
  /** insert data into the table: "survey_question_kind" */
  insert_survey_question_kind?: Maybe<Survey_Question_Kind_Mutation_Response>;
  /** insert a single row into the table: "survey_question_kind" */
  insert_survey_question_kind_one?: Maybe<Survey_Question_Kind>;
  /** insert a single row into the table: "survey_question" */
  insert_survey_question_one?: Maybe<Survey_Question>;
  /** insert data into the table: "survey_question_options" */
  insert_survey_question_options?: Maybe<Survey_Question_Options_Mutation_Response>;
  /** insert a single row into the table: "survey_question_options" */
  insert_survey_question_options_one?: Maybe<Survey_Question_Options>;
  /** insert data into the table: "survey_v2" */
  insert_survey_v2?: Maybe<Survey_V2_Mutation_Response>;
  /** insert a single row into the table: "survey_v2" */
  insert_survey_v2_one?: Maybe<Survey_V2>;
  /** insert data into the table: "survey_v2_question" */
  insert_survey_v2_question?: Maybe<Survey_V2_Question_Mutation_Response>;
  /** insert data into the table: "survey_v2_question_kind" */
  insert_survey_v2_question_kind?: Maybe<Survey_V2_Question_Kind_Mutation_Response>;
  /** insert a single row into the table: "survey_v2_question_kind" */
  insert_survey_v2_question_kind_one?: Maybe<Survey_V2_Question_Kind>;
  /** insert a single row into the table: "survey_v2_question" */
  insert_survey_v2_question_one?: Maybe<Survey_V2_Question>;
  /** insert data into the table: "survey_v2_question_option" */
  insert_survey_v2_question_option?: Maybe<Survey_V2_Question_Option_Mutation_Response>;
  /** insert data into the table: "survey_v2_question_option_additional_info_config" */
  insert_survey_v2_question_option_additional_info_config?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Mutation_Response>;
  /** insert a single row into the table: "survey_v2_question_option_additional_info_config" */
  insert_survey_v2_question_option_additional_info_config_one?: Maybe<Survey_V2_Question_Option_Additional_Info_Config>;
  /** insert a single row into the table: "survey_v2_question_option" */
  insert_survey_v2_question_option_one?: Maybe<Survey_V2_Question_Option>;
  /** insert data into the table: "survey_v2_response" */
  insert_survey_v2_response?: Maybe<Survey_V2_Response_Mutation_Response>;
  /** insert data into the table: "survey_v2_response_answer" */
  insert_survey_v2_response_answer?: Maybe<Survey_V2_Response_Answer_Mutation_Response>;
  /** insert a single row into the table: "survey_v2_response_answer" */
  insert_survey_v2_response_answer_one?: Maybe<Survey_V2_Response_Answer>;
  /** insert data into the table: "survey_v2_response_answer_option" */
  insert_survey_v2_response_answer_option?: Maybe<Survey_V2_Response_Answer_Option_Mutation_Response>;
  /** insert a single row into the table: "survey_v2_response_answer_option" */
  insert_survey_v2_response_answer_option_one?: Maybe<Survey_V2_Response_Answer_Option>;
  /** insert a single row into the table: "survey_v2_response" */
  insert_survey_v2_response_one?: Maybe<Survey_V2_Response>;
  /** insert data into the table: "task_event" */
  insert_task_event?: Maybe<Task_Event_Mutation_Response>;
  /** insert a single row into the table: "task_event" */
  insert_task_event_one?: Maybe<Task_Event>;
  /** insert data into the table: "tasks" */
  insert_tasks?: Maybe<Tasks_Mutation_Response>;
  /** insert a single row into the table: "tasks" */
  insert_tasks_one?: Maybe<Tasks>;
  /** insert data into the table: "tenant" */
  insert_tenant?: Maybe<Tenant_Mutation_Response>;
  /** insert data into the table: "tenant_active_status_reason" */
  insert_tenant_active_status_reason?: Maybe<Tenant_Active_Status_Reason_Mutation_Response>;
  /** insert a single row into the table: "tenant_active_status_reason" */
  insert_tenant_active_status_reason_one?: Maybe<Tenant_Active_Status_Reason>;
  /** insert data into the table: "tenant_group" */
  insert_tenant_group?: Maybe<Tenant_Group_Mutation_Response>;
  /** insert data into the table: "tenant_group_member" */
  insert_tenant_group_member?: Maybe<Tenant_Group_Member_Mutation_Response>;
  /** insert a single row into the table: "tenant_group_member" */
  insert_tenant_group_member_one?: Maybe<Tenant_Group_Member>;
  /** insert a single row into the table: "tenant_group" */
  insert_tenant_group_one?: Maybe<Tenant_Group>;
  /** insert a single row into the table: "tenant" */
  insert_tenant_one?: Maybe<Tenant>;
  /** insert data into the table: "tenant_public_status" */
  insert_tenant_public_status?: Maybe<Tenant_Public_Status_Mutation_Response>;
  /** insert a single row into the table: "tenant_public_status" */
  insert_tenant_public_status_one?: Maybe<Tenant_Public_Status>;
  /** insert data into the table: "tenant_status" */
  insert_tenant_status?: Maybe<Tenant_Status_Mutation_Response>;
  /** insert a single row into the table: "tenant_status" */
  insert_tenant_status_one?: Maybe<Tenant_Status>;
  /** insert data into the table: "trial_leads" */
  insert_trial_leads?: Maybe<Trial_Leads_Mutation_Response>;
  /** insert a single row into the table: "trial_leads" */
  insert_trial_leads_one?: Maybe<Trial_Leads>;
  /** insert data into the table: "ua_audit_logs" */
  insert_ua_audit_logs?: Maybe<Ua_Audit_Logs_Mutation_Response>;
  /** insert a single row into the table: "ua_audit_logs" */
  insert_ua_audit_logs_one?: Maybe<Ua_Audit_Logs>;
  /** insert data into the table: "user_activity" */
  insert_user_activity?: Maybe<User_Activity_Mutation_Response>;
  /** insert a single row into the table: "user_activity" */
  insert_user_activity_one?: Maybe<User_Activity>;
  /** insert data into the table: "user_coupon" */
  insert_user_coupon?: Maybe<User_Coupon_Mutation_Response>;
  /** insert a single row into the table: "user_coupon" */
  insert_user_coupon_one?: Maybe<User_Coupon>;
  /** insert data into the table: "user_entitlement_access" */
  insert_user_entitlement_access?: Maybe<User_Entitlement_Access_Mutation_Response>;
  /** insert a single row into the table: "user_entitlement_access" */
  insert_user_entitlement_access_one?: Maybe<User_Entitlement_Access>;
  /** insert data into the table: "user_entitlement_catalogue" */
  insert_user_entitlement_catalogue?: Maybe<User_Entitlement_Catalogue_Mutation_Response>;
  /** insert a single row into the table: "user_entitlement_catalogue" */
  insert_user_entitlement_catalogue_one?: Maybe<User_Entitlement_Catalogue>;
  /** insert data into the table: "user_entitlement_types" */
  insert_user_entitlement_types?: Maybe<User_Entitlement_Types_Mutation_Response>;
  /** insert a single row into the table: "user_entitlement_types" */
  insert_user_entitlement_types_one?: Maybe<User_Entitlement_Types>;
  /** insert data into the table: "user_onboarding" */
  insert_user_onboarding?: Maybe<User_Onboarding_Mutation_Response>;
  /** insert a single row into the table: "user_onboarding" */
  insert_user_onboarding_one?: Maybe<User_Onboarding>;
  /** insert data into the table: "user_personal_access_tokens" */
  insert_user_personal_access_tokens?: Maybe<User_Personal_Access_Tokens_Mutation_Response>;
  /** insert a single row into the table: "user_personal_access_tokens" */
  insert_user_personal_access_tokens_one?: Maybe<User_Personal_Access_Tokens>;
  /** insert data into the table: "user_profile" */
  insert_user_profile?: Maybe<User_Profile_Mutation_Response>;
  /** insert a single row into the table: "user_profile" */
  insert_user_profile_one?: Maybe<User_Profile>;
  /** insert data into the table: "user_roles" */
  insert_user_roles?: Maybe<User_Roles_Mutation_Response>;
  /** insert a single row into the table: "user_roles" */
  insert_user_roles_one?: Maybe<User_Roles>;
  /** insert data into the table: "user_vpc_policy" */
  insert_user_vpc_policy?: Maybe<User_Vpc_Policy_Mutation_Response>;
  /** insert a single row into the table: "user_vpc_policy" */
  insert_user_vpc_policy_one?: Maybe<User_Vpc_Policy>;
  /** insert data into the table: "users" */
  insert_users?: Maybe<Users_Mutation_Response>;
  /** insert a single row into the table: "users" */
  insert_users_one?: Maybe<Users>;
  /** insert data into the table: "users_public" */
  insert_users_public?: Maybe<Users_Public_Mutation_Response>;
  /** insert a single row into the table: "users_public" */
  insert_users_public_one?: Maybe<Users_Public>;
  /** insert data into the table: "vercel_integration" */
  insert_vercel_integration?: Maybe<Vercel_Integration_Mutation_Response>;
  /** insert data into the table: "vercel_integration_connections" */
  insert_vercel_integration_connections?: Maybe<Vercel_Integration_Connections_Mutation_Response>;
  /** insert a single row into the table: "vercel_integration_connections" */
  insert_vercel_integration_connections_one?: Maybe<Vercel_Integration_Connections>;
  /** insert a single row into the table: "vercel_integration" */
  insert_vercel_integration_one?: Maybe<Vercel_Integration>;
  /** insert data into the table: "vpc_peering" */
  insert_vpc_peering?: Maybe<Vpc_Peering_Mutation_Response>;
  /** insert data into the table: "vpc_peering_direction" */
  insert_vpc_peering_direction?: Maybe<Vpc_Peering_Direction_Mutation_Response>;
  /** insert a single row into the table: "vpc_peering_direction" */
  insert_vpc_peering_direction_one?: Maybe<Vpc_Peering_Direction>;
  /** insert a single row into the table: "vpc_peering" */
  insert_vpc_peering_one?: Maybe<Vpc_Peering>;
  /** insert data into the table: "vpc_status" */
  insert_vpc_status?: Maybe<Vpc_Status_Mutation_Response>;
  /** insert a single row into the table: "vpc_status" */
  insert_vpc_status_one?: Maybe<Vpc_Status>;
  /** insert data into the table: "zendesk_support_category" */
  insert_zendesk_support_category?: Maybe<Zendesk_Support_Category_Mutation_Response>;
  /** insert a single row into the table: "zendesk_support_category" */
  insert_zendesk_support_category_one?: Maybe<Zendesk_Support_Category>;
  /** insert data into the table: "zendesk_support_tickets" */
  insert_zendesk_support_tickets?: Maybe<Zendesk_Support_Tickets_Mutation_Response>;
  /** insert a single row into the table: "zendesk_support_tickets" */
  insert_zendesk_support_tickets_one?: Maybe<Zendesk_Support_Tickets>;
  inviteBillingManager?: Maybe<BillingManagerInvitation>;
  inviteCollaborator?: Maybe<ProjectCollaboratorInvitation>;
  lastMonthProjectUsage: Array<ProjectUsage>;
  moveProjectRegion: MoveProjectRegionResponse;
  /** Creates a project with a database on Neon */
  neonCreateDatabase?: Maybe<NeonCreateDatabaseResponse>;
  /** Action to exchange granted code for access token */
  neonExchangeOAuthToken: NeonExchangeTokenResponse;
  /** Removes the persisted Neon session from Hasura Cloud */
  neonRemoveSession?: Maybe<SuccessOrError>;
  /** Fetches the bills accured by a project in a month for projects on the new plans */
  newPlansProjectUsage?: Maybe<NewPlansProjectOutput>;
  /** Fetches the bills accured by a user in a month for projects on the new plans, grouped by project */
  newPlansProjectUsagePerMonth: Array<NewPlansProjectUsageOutput>;
  payInvoice?: Maybe<PayInvoiceStatus>;
  /** Allows users to reactivate their suspended projects */
  reactivateSuspendedProject: ProjectReactivationResponse;
  regenerateKey: AddProjectResponse;
  removeGithubIntegration?: Maybe<DeleteGithubIntegrationStatus>;
  removeGithubSession?: Maybe<GithubIntegrationStatus>;
  removeHerokuSession: HerokuSessionStatus;
  resendBillingManagerInvite?: Maybe<BillingManagerInvitation>;
  resendChangeUserEmailVerification: ChangeUserEmailRequest;
  resendInvite: ProjectCollaboratorInvitation;
  resendTransferOwnershipInvite: ProjectOwnershipTransferInvitation;
  revokeChangeUserEmailRequest: ChangeUserEmailRequest;
  /** Action to save survey question's answer */
  saveSurveyAnswer?: Maybe<SuccessOrError>;
  /** Action to save survey question's answer */
  saveSurveyAnswerV2?: Maybe<SuccessOrError>;
  setDefaultPaymentMethod?: Maybe<DefaultPaymentResponse>;
  /** Action to exchange granted code for access token */
  slackExchangeOAuthToken: SlackExchangeTokenResponse;
  /** Action to track activity of experiments cohort users */
  trackExperimentsCohortActivity?: Maybe<SuccessOrError>;
  /** Action to track the onboarding activity */
  trackOnboardingActivity?: Maybe<SuccessOrError>;
  trackOnboardingSampleDbCohortActivity?: Maybe<TrackOnboardingSampleDbCohortActivityResponse>;
  transferOwnershipInvite: ProjectOwnershipTransferInvitation;
  triggerAnalyticsInfraModule?: Maybe<BuildKiteBuild>;
  triggerCentralModule?: Maybe<BuildKiteBuild>;
  triggerCentralMonitoringModule?: Maybe<BuildKiteBuild>;
  triggerDataConnectorModule?: Maybe<BuildKiteBuild>;
  triggerDvpcInfraModule?: Maybe<BuildKiteBuild>;
  triggerDvpcLogsModule?: Maybe<BuildKiteBuild>;
  triggerDvpcMonitoringModule?: Maybe<BuildKiteBuild>;
  triggerDvpcOperatorModule?: Maybe<BuildKiteBuild>;
  triggerDvpcPeeringModule?: Maybe<BuildKiteBuild>;
  triggerGatewayClusterModule?: Maybe<BuildKiteBuild>;
  triggerHasuraClusterModule?: Maybe<BuildKiteBuild>;
  triggerHealthcheckModule?: Maybe<BuildKiteBuild>;
  triggerLogsModule?: Maybe<BuildKiteBuild>;
  triggerLuxProxyModule?: Maybe<BuildKiteBuild>;
  triggerMetricsModule?: Maybe<BuildKiteBuild>;
  triggerNodePoolModule?: Maybe<BuildKiteBuild>;
  /** execute one-click-deploy workflow configured for a project idempotently */
  triggerOneClickDeployment?: Maybe<OneClickDeployResponse>;
  triggerOperatorModule?: Maybe<BuildKiteBuild>;
  triggerRegionModule?: Maybe<BuildKiteBuild>;
  triggerRegionMonitoringModule?: Maybe<BuildKiteBuild>;
  triggerTaskqModule?: Maybe<BuildKiteBuild>;
  triggerV3CentralModule?: Maybe<BuildKiteBuild>;
  triggerV3ServerModule?: Maybe<BuildKiteBuild>;
  triggerV3SyncModule?: Maybe<BuildKiteBuild>;
  /** update data of the table: "alert_config" */
  update_alert_config?: Maybe<Alert_Config_Mutation_Response>;
  /** update data of the table: "alert_config_alert_type" */
  update_alert_config_alert_type?: Maybe<Alert_Config_Alert_Type_Mutation_Response>;
  /** update single row of the table: "alert_config_alert_type" */
  update_alert_config_alert_type_by_pk?: Maybe<Alert_Config_Alert_Type>;
  /** update multiples rows of table: "alert_config_alert_type" */
  update_alert_config_alert_type_many?: Maybe<
    Array<Maybe<Alert_Config_Alert_Type_Mutation_Response>>
  >;
  /** update single row of the table: "alert_config" */
  update_alert_config_by_pk?: Maybe<Alert_Config>;
  /** update multiples rows of table: "alert_config" */
  update_alert_config_many?: Maybe<
    Array<Maybe<Alert_Config_Mutation_Response>>
  >;
  /** update data of the table: "alert_config_service" */
  update_alert_config_service?: Maybe<Alert_Config_Service_Mutation_Response>;
  /** update single row of the table: "alert_config_service" */
  update_alert_config_service_by_pk?: Maybe<Alert_Config_Service>;
  /** update multiples rows of table: "alert_config_service" */
  update_alert_config_service_many?: Maybe<
    Array<Maybe<Alert_Config_Service_Mutation_Response>>
  >;
  /** update data of the table: "alert_service_type" */
  update_alert_service_type?: Maybe<Alert_Service_Type_Mutation_Response>;
  /** update single row of the table: "alert_service_type" */
  update_alert_service_type_by_pk?: Maybe<Alert_Service_Type>;
  /** update multiples rows of table: "alert_service_type" */
  update_alert_service_type_many?: Maybe<
    Array<Maybe<Alert_Service_Type_Mutation_Response>>
  >;
  /** update data of the table: "alert_type" */
  update_alert_type?: Maybe<Alert_Type_Mutation_Response>;
  /** update single row of the table: "alert_type" */
  update_alert_type_by_pk?: Maybe<Alert_Type>;
  /** update multiples rows of table: "alert_type" */
  update_alert_type_many?: Maybe<Array<Maybe<Alert_Type_Mutation_Response>>>;
  /** update data of the table: "azuremonitor_config" */
  update_azuremonitor_config?: Maybe<Azuremonitor_Config_Mutation_Response>;
  /** update single row of the table: "azuremonitor_config" */
  update_azuremonitor_config_by_pk?: Maybe<Azuremonitor_Config>;
  /** update multiples rows of table: "azuremonitor_config" */
  update_azuremonitor_config_many?: Maybe<
    Array<Maybe<Azuremonitor_Config_Mutation_Response>>
  >;
  /** update data of the table: "billing_address" */
  update_billing_address?: Maybe<Billing_Address_Mutation_Response>;
  /** update single row of the table: "billing_address" */
  update_billing_address_by_pk?: Maybe<Billing_Address>;
  /** update multiples rows of table: "billing_address" */
  update_billing_address_many?: Maybe<
    Array<Maybe<Billing_Address_Mutation_Response>>
  >;
  /** update data of the table: "central_cloud" */
  update_central_cloud?: Maybe<Central_Cloud_Mutation_Response>;
  /** update single row of the table: "central_cloud" */
  update_central_cloud_by_pk?: Maybe<Central_Cloud>;
  /** update multiples rows of table: "central_cloud" */
  update_central_cloud_many?: Maybe<
    Array<Maybe<Central_Cloud_Mutation_Response>>
  >;
  /** update data of the table: "change_email_request" */
  update_change_email_request?: Maybe<Change_Email_Request_Mutation_Response>;
  /** update single row of the table: "change_email_request" */
  update_change_email_request_by_pk?: Maybe<Change_Email_Request>;
  /** update multiples rows of table: "change_email_request" */
  update_change_email_request_many?: Maybe<
    Array<Maybe<Change_Email_Request_Mutation_Response>>
  >;
  /** update data of the table: "cicd.deployment_pipeline_config" */
  update_cicd_deployment_pipeline_config?: Maybe<Cicd_Deployment_Pipeline_Config_Mutation_Response>;
  /** update single row of the table: "cicd.deployment_pipeline_config" */
  update_cicd_deployment_pipeline_config_by_pk?: Maybe<Cicd_Deployment_Pipeline_Config>;
  /** update multiples rows of table: "cicd.deployment_pipeline_config" */
  update_cicd_deployment_pipeline_config_many?: Maybe<
    Array<Maybe<Cicd_Deployment_Pipeline_Config_Mutation_Response>>
  >;
  /** update data of the table: "cicd.deployment_pool" */
  update_cicd_deployment_pool?: Maybe<Cicd_Deployment_Pool_Mutation_Response>;
  /** update multiples rows of table: "cicd.deployment_pool" */
  update_cicd_deployment_pool_many?: Maybe<
    Array<Maybe<Cicd_Deployment_Pool_Mutation_Response>>
  >;
  /** update data of the table: "cicd.deployment_pool_member" */
  update_cicd_deployment_pool_member?: Maybe<Cicd_Deployment_Pool_Member_Mutation_Response>;
  /** update multiples rows of table: "cicd.deployment_pool_member" */
  update_cicd_deployment_pool_member_many?: Maybe<
    Array<Maybe<Cicd_Deployment_Pool_Member_Mutation_Response>>
  >;
  /** update data of the table: "cloud" */
  update_cloud?: Maybe<Cloud_Mutation_Response>;
  /** update single row of the table: "cloud" */
  update_cloud_by_pk?: Maybe<Cloud>;
  /** update multiples rows of table: "cloud" */
  update_cloud_many?: Maybe<Array<Maybe<Cloud_Mutation_Response>>>;
  /** update data of the table: "cloud_metadata" */
  update_cloud_metadata?: Maybe<Cloud_Metadata_Mutation_Response>;
  /** update single row of the table: "cloud_metadata" */
  update_cloud_metadata_by_pk?: Maybe<Cloud_Metadata>;
  /** update multiples rows of table: "cloud_metadata" */
  update_cloud_metadata_many?: Maybe<
    Array<Maybe<Cloud_Metadata_Mutation_Response>>
  >;
  /** update data of the table: "compute_unit_config" */
  update_compute_unit_config?: Maybe<Compute_Unit_Config_Mutation_Response>;
  /** update single row of the table: "compute_unit_config" */
  update_compute_unit_config_by_pk?: Maybe<Compute_Unit_Config>;
  /** update multiples rows of table: "compute_unit_config" */
  update_compute_unit_config_many?: Maybe<
    Array<Maybe<Compute_Unit_Config_Mutation_Response>>
  >;
  /** update data of the table: "config" */
  update_config?: Maybe<Config_Mutation_Response>;
  /** update single row of the table: "config" */
  update_config_by_pk?: Maybe<Config>;
  /** update multiples rows of table: "config" */
  update_config_many?: Maybe<Array<Maybe<Config_Mutation_Response>>>;
  /** update data of the table: "config_status" */
  update_config_status?: Maybe<Config_Status_Mutation_Response>;
  /** update single row of the table: "config_status" */
  update_config_status_by_pk?: Maybe<Config_Status>;
  /** update multiples rows of table: "config_status" */
  update_config_status_many?: Maybe<
    Array<Maybe<Config_Status_Mutation_Response>>
  >;
  /** update data of the table: "connector_config" */
  update_connector_config?: Maybe<Connector_Config_Mutation_Response>;
  /** update single row of the table: "connector_config" */
  update_connector_config_by_pk?: Maybe<Connector_Config>;
  /** update multiples rows of table: "connector_config" */
  update_connector_config_many?: Maybe<
    Array<Maybe<Connector_Config_Mutation_Response>>
  >;
  /** update data of the table: "connector_deployments" */
  update_connector_deployments?: Maybe<Connector_Deployments_Mutation_Response>;
  /** update single row of the table: "connector_deployments" */
  update_connector_deployments_by_pk?: Maybe<Connector_Deployments>;
  /** update multiples rows of table: "connector_deployments" */
  update_connector_deployments_many?: Maybe<
    Array<Maybe<Connector_Deployments_Mutation_Response>>
  >;
  /** update data of the table: "coupon" */
  update_coupon?: Maybe<Coupon_Mutation_Response>;
  /** update single row of the table: "coupon" */
  update_coupon_by_pk?: Maybe<Coupon>;
  /** update data of the table: "coupon_duration" */
  update_coupon_duration?: Maybe<Coupon_Duration_Mutation_Response>;
  /** update single row of the table: "coupon_duration" */
  update_coupon_duration_by_pk?: Maybe<Coupon_Duration>;
  /** update multiples rows of table: "coupon_duration" */
  update_coupon_duration_many?: Maybe<
    Array<Maybe<Coupon_Duration_Mutation_Response>>
  >;
  /** update multiples rows of table: "coupon" */
  update_coupon_many?: Maybe<Array<Maybe<Coupon_Mutation_Response>>>;
  /** update data of the table: "coupon_type" */
  update_coupon_type?: Maybe<Coupon_Type_Mutation_Response>;
  /** update single row of the table: "coupon_type" */
  update_coupon_type_by_pk?: Maybe<Coupon_Type>;
  /** update multiples rows of table: "coupon_type" */
  update_coupon_type_many?: Maybe<Array<Maybe<Coupon_Type_Mutation_Response>>>;
  /** update data of the table: "custom_domain" */
  update_custom_domain?: Maybe<Custom_Domain_Mutation_Response>;
  /** update single row of the table: "custom_domain" */
  update_custom_domain_by_pk?: Maybe<Custom_Domain>;
  /** update data of the table: "custom_domain_cloudflare" */
  update_custom_domain_cloudflare?: Maybe<Custom_Domain_Cloudflare_Mutation_Response>;
  /** update single row of the table: "custom_domain_cloudflare" */
  update_custom_domain_cloudflare_by_pk?: Maybe<Custom_Domain_Cloudflare>;
  /** update data of the table: "custom_domain_cloudflare_dns" */
  update_custom_domain_cloudflare_dns?: Maybe<Custom_Domain_Cloudflare_Dns_Mutation_Response>;
  /** update single row of the table: "custom_domain_cloudflare_dns" */
  update_custom_domain_cloudflare_dns_by_pk?: Maybe<Custom_Domain_Cloudflare_Dns>;
  /** update multiples rows of table: "custom_domain_cloudflare_dns" */
  update_custom_domain_cloudflare_dns_many?: Maybe<
    Array<Maybe<Custom_Domain_Cloudflare_Dns_Mutation_Response>>
  >;
  /** update multiples rows of table: "custom_domain_cloudflare" */
  update_custom_domain_cloudflare_many?: Maybe<
    Array<Maybe<Custom_Domain_Cloudflare_Mutation_Response>>
  >;
  /** update multiples rows of table: "custom_domain" */
  update_custom_domain_many?: Maybe<
    Array<Maybe<Custom_Domain_Mutation_Response>>
  >;
  /** update data of the table: "customer_usage" */
  update_customer_usage?: Maybe<Customer_Usage_Mutation_Response>;
  /** update single row of the table: "customer_usage" */
  update_customer_usage_by_pk?: Maybe<Customer_Usage>;
  /** update multiples rows of table: "customer_usage" */
  update_customer_usage_many?: Maybe<
    Array<Maybe<Customer_Usage_Mutation_Response>>
  >;
  /** update data of the table: "data_connector_type" */
  update_data_connector_type?: Maybe<Data_Connector_Type_Mutation_Response>;
  /** update single row of the table: "data_connector_type" */
  update_data_connector_type_by_pk?: Maybe<Data_Connector_Type>;
  /** update multiples rows of table: "data_connector_type" */
  update_data_connector_type_many?: Maybe<
    Array<Maybe<Data_Connector_Type_Mutation_Response>>
  >;
  /** update data of the table: "datadog_config" */
  update_datadog_config?: Maybe<Datadog_Config_Mutation_Response>;
  /** update single row of the table: "datadog_config" */
  update_datadog_config_by_pk?: Maybe<Datadog_Config>;
  /** update multiples rows of table: "datadog_config" */
  update_datadog_config_many?: Maybe<
    Array<Maybe<Datadog_Config_Mutation_Response>>
  >;
  /** update data of the table: "db_latency" */
  update_db_latency?: Maybe<Db_Latency_Mutation_Response>;
  /** update single row of the table: "db_latency" */
  update_db_latency_by_pk?: Maybe<Db_Latency>;
  /** update multiples rows of table: "db_latency" */
  update_db_latency_many?: Maybe<Array<Maybe<Db_Latency_Mutation_Response>>>;
  /** update data of the table: "ddn.build" */
  update_ddn_build?: Maybe<Ddn_Build_Mutation_Response>;
  /** update single row of the table: "ddn.build" */
  update_ddn_build_by_pk?: Maybe<Ddn_Build>;
  /** update multiples rows of table: "ddn.build" */
  update_ddn_build_many?: Maybe<Array<Maybe<Ddn_Build_Mutation_Response>>>;
  /** update data of the table: "ddn.build_sync_status" */
  update_ddn_build_sync_status?: Maybe<Ddn_Build_Sync_Status_Mutation_Response>;
  /** update single row of the table: "ddn.build_sync_status" */
  update_ddn_build_sync_status_by_pk?: Maybe<Ddn_Build_Sync_Status>;
  /** update multiples rows of table: "ddn.build_sync_status" */
  update_ddn_build_sync_status_many?: Maybe<
    Array<Maybe<Ddn_Build_Sync_Status_Mutation_Response>>
  >;
  /** update data of the table: "ddn.build_sync_worker" */
  update_ddn_build_sync_worker?: Maybe<Ddn_Build_Sync_Worker_Mutation_Response>;
  /** update single row of the table: "ddn.build_sync_worker" */
  update_ddn_build_sync_worker_by_pk?: Maybe<Ddn_Build_Sync_Worker>;
  /** update multiples rows of table: "ddn.build_sync_worker" */
  update_ddn_build_sync_worker_many?: Maybe<
    Array<Maybe<Ddn_Build_Sync_Worker_Mutation_Response>>
  >;
  /** update data of the table: "ddn.environment" */
  update_ddn_environment?: Maybe<Ddn_Environment_Mutation_Response>;
  /** update single row of the table: "ddn.environment" */
  update_ddn_environment_by_pk?: Maybe<Ddn_Environment>;
  /** update multiples rows of table: "ddn.environment" */
  update_ddn_environment_many?: Maybe<
    Array<Maybe<Ddn_Environment_Mutation_Response>>
  >;
  /** update data of the table: "ddn.project_entitlement_access" */
  update_ddn_project_entitlement_access?: Maybe<Ddn_Project_Entitlement_Access_Mutation_Response>;
  /** update single row of the table: "ddn.project_entitlement_access" */
  update_ddn_project_entitlement_access_by_pk?: Maybe<Ddn_Project_Entitlement_Access>;
  /** update multiples rows of table: "ddn.project_entitlement_access" */
  update_ddn_project_entitlement_access_many?: Maybe<
    Array<Maybe<Ddn_Project_Entitlement_Access_Mutation_Response>>
  >;
  /** update data of the table: "ddn.project_entitlement_catalogue" */
  update_ddn_project_entitlement_catalogue?: Maybe<Ddn_Project_Entitlement_Catalogue_Mutation_Response>;
  /** update single row of the table: "ddn.project_entitlement_catalogue" */
  update_ddn_project_entitlement_catalogue_by_pk?: Maybe<Ddn_Project_Entitlement_Catalogue>;
  /** update multiples rows of table: "ddn.project_entitlement_catalogue" */
  update_ddn_project_entitlement_catalogue_many?: Maybe<
    Array<Maybe<Ddn_Project_Entitlement_Catalogue_Mutation_Response>>
  >;
  /** update data of the table: "ddn.project_entitlement_types" */
  update_ddn_project_entitlement_types?: Maybe<Ddn_Project_Entitlement_Types_Mutation_Response>;
  /** update single row of the table: "ddn.project_entitlement_types" */
  update_ddn_project_entitlement_types_by_pk?: Maybe<Ddn_Project_Entitlement_Types>;
  /** update multiples rows of table: "ddn.project_entitlement_types" */
  update_ddn_project_entitlement_types_many?: Maybe<
    Array<Maybe<Ddn_Project_Entitlement_Types_Mutation_Response>>
  >;
  /** update data of the table: "ddn.projects" */
  update_ddn_projects?: Maybe<Ddn_Projects_Mutation_Response>;
  /** update single row of the table: "ddn.projects" */
  update_ddn_projects_by_pk?: Maybe<Ddn_Projects>;
  /** update multiples rows of table: "ddn.projects" */
  update_ddn_projects_many?: Maybe<
    Array<Maybe<Ddn_Projects_Mutation_Response>>
  >;
  /** update data of the table: "ddn.tunnel" */
  update_ddn_tunnel?: Maybe<Ddn_Tunnel_Mutation_Response>;
  /** update single row of the table: "ddn.tunnel" */
  update_ddn_tunnel_by_pk?: Maybe<Ddn_Tunnel>;
  /** update data of the table: "ddn.tunnel_cluster" */
  update_ddn_tunnel_cluster?: Maybe<Ddn_Tunnel_Cluster_Mutation_Response>;
  /** update single row of the table: "ddn.tunnel_cluster" */
  update_ddn_tunnel_cluster_by_pk?: Maybe<Ddn_Tunnel_Cluster>;
  /** update multiples rows of table: "ddn.tunnel_cluster" */
  update_ddn_tunnel_cluster_many?: Maybe<
    Array<Maybe<Ddn_Tunnel_Cluster_Mutation_Response>>
  >;
  /** update multiples rows of table: "ddn.tunnel" */
  update_ddn_tunnel_many?: Maybe<Array<Maybe<Ddn_Tunnel_Mutation_Response>>>;
  /** update data of the table: "dedicated_cloud_bills" */
  update_dedicated_cloud_bills?: Maybe<Dedicated_Cloud_Bills_Mutation_Response>;
  /** update single row of the table: "dedicated_cloud_bills" */
  update_dedicated_cloud_bills_by_pk?: Maybe<Dedicated_Cloud_Bills>;
  /** update data of the table: "dedicated_cloud_bills_details" */
  update_dedicated_cloud_bills_details?: Maybe<Dedicated_Cloud_Bills_Details_Mutation_Response>;
  /** update single row of the table: "dedicated_cloud_bills_details" */
  update_dedicated_cloud_bills_details_by_pk?: Maybe<Dedicated_Cloud_Bills_Details>;
  /** update multiples rows of table: "dedicated_cloud_bills_details" */
  update_dedicated_cloud_bills_details_many?: Maybe<
    Array<Maybe<Dedicated_Cloud_Bills_Details_Mutation_Response>>
  >;
  /** update multiples rows of table: "dedicated_cloud_bills" */
  update_dedicated_cloud_bills_many?: Maybe<
    Array<Maybe<Dedicated_Cloud_Bills_Mutation_Response>>
  >;
  /** update data of the table: "dedicated_cloud_commitments" */
  update_dedicated_cloud_commitments?: Maybe<Dedicated_Cloud_Commitments_Mutation_Response>;
  /** update single row of the table: "dedicated_cloud_commitments" */
  update_dedicated_cloud_commitments_by_pk?: Maybe<Dedicated_Cloud_Commitments>;
  /** update multiples rows of table: "dedicated_cloud_commitments" */
  update_dedicated_cloud_commitments_many?: Maybe<
    Array<Maybe<Dedicated_Cloud_Commitments_Mutation_Response>>
  >;
  /** update data of the table: "dedicated_vpc" */
  update_dedicated_vpc?: Maybe<Dedicated_Vpc_Mutation_Response>;
  /** update single row of the table: "dedicated_vpc" */
  update_dedicated_vpc_by_pk?: Maybe<Dedicated_Vpc>;
  /** update multiples rows of table: "dedicated_vpc" */
  update_dedicated_vpc_many?: Maybe<
    Array<Maybe<Dedicated_Vpc_Mutation_Response>>
  >;
  /** update data of the table: "delete_user" */
  update_delete_user?: Maybe<Delete_User_Mutation_Response>;
  /** update single row of the table: "delete_user" */
  update_delete_user_by_pk?: Maybe<Delete_User>;
  /** update multiples rows of table: "delete_user" */
  update_delete_user_many?: Maybe<Array<Maybe<Delete_User_Mutation_Response>>>;
  /** update data of the table: "delete_user_status" */
  update_delete_user_status?: Maybe<Delete_User_Status_Mutation_Response>;
  /** update single row of the table: "delete_user_status" */
  update_delete_user_status_by_pk?: Maybe<Delete_User_Status>;
  /** update multiples rows of table: "delete_user_status" */
  update_delete_user_status_many?: Maybe<
    Array<Maybe<Delete_User_Status_Mutation_Response>>
  >;
  /** update data of the table: "delete_user_tasks" */
  update_delete_user_tasks?: Maybe<Delete_User_Tasks_Mutation_Response>;
  /** update single row of the table: "delete_user_tasks" */
  update_delete_user_tasks_by_pk?: Maybe<Delete_User_Tasks>;
  /** update multiples rows of table: "delete_user_tasks" */
  update_delete_user_tasks_many?: Maybe<
    Array<Maybe<Delete_User_Tasks_Mutation_Response>>
  >;
  /** update data of the table: "email_log" */
  update_email_log?: Maybe<Email_Log_Mutation_Response>;
  /** update single row of the table: "email_log" */
  update_email_log_by_pk?: Maybe<Email_Log>;
  /** update multiples rows of table: "email_log" */
  update_email_log_many?: Maybe<Array<Maybe<Email_Log_Mutation_Response>>>;
  /** update data of the table: "enterprise_users" */
  update_enterprise_users?: Maybe<Enterprise_Users_Mutation_Response>;
  /** update single row of the table: "enterprise_users" */
  update_enterprise_users_by_pk?: Maybe<Enterprise_Users>;
  /** update multiples rows of table: "enterprise_users" */
  update_enterprise_users_many?: Maybe<
    Array<Maybe<Enterprise_Users_Mutation_Response>>
  >;
  /** update data of the table: "experiments" */
  update_experiments?: Maybe<Experiments_Mutation_Response>;
  /** update single row of the table: "experiments" */
  update_experiments_by_pk?: Maybe<Experiments>;
  /** update data of the table: "experiments_cohort" */
  update_experiments_cohort?: Maybe<Experiments_Cohort_Mutation_Response>;
  /** update single row of the table: "experiments_cohort" */
  update_experiments_cohort_by_pk?: Maybe<Experiments_Cohort>;
  /** update multiples rows of table: "experiments_cohort" */
  update_experiments_cohort_many?: Maybe<
    Array<Maybe<Experiments_Cohort_Mutation_Response>>
  >;
  /** update data of the table: "experiments_config" */
  update_experiments_config?: Maybe<Experiments_Config_Mutation_Response>;
  /** update single row of the table: "experiments_config" */
  update_experiments_config_by_pk?: Maybe<Experiments_Config>;
  /** update multiples rows of table: "experiments_config" */
  update_experiments_config_many?: Maybe<
    Array<Maybe<Experiments_Config_Mutation_Response>>
  >;
  /** update multiples rows of table: "experiments" */
  update_experiments_many?: Maybe<Array<Maybe<Experiments_Mutation_Response>>>;
  /** update data of the table: "feature" */
  update_feature?: Maybe<Feature_Mutation_Response>;
  /** update data of the table: "feature_access" */
  update_feature_access?: Maybe<Feature_Access_Mutation_Response>;
  /** update single row of the table: "feature_access" */
  update_feature_access_by_pk?: Maybe<Feature_Access>;
  /** update multiples rows of table: "feature_access" */
  update_feature_access_many?: Maybe<
    Array<Maybe<Feature_Access_Mutation_Response>>
  >;
  /** update single row of the table: "feature" */
  update_feature_by_pk?: Maybe<Feature>;
  /** update data of the table: "feature_config" */
  update_feature_config?: Maybe<Feature_Config_Mutation_Response>;
  /** update single row of the table: "feature_config" */
  update_feature_config_by_pk?: Maybe<Feature_Config>;
  /** update multiples rows of table: "feature_config" */
  update_feature_config_many?: Maybe<
    Array<Maybe<Feature_Config_Mutation_Response>>
  >;
  /** update multiples rows of table: "feature" */
  update_feature_many?: Maybe<Array<Maybe<Feature_Mutation_Response>>>;
  /** update data of the table: "gateway_ami" */
  update_gateway_ami?: Maybe<Gateway_Ami_Mutation_Response>;
  /** update single row of the table: "gateway_ami" */
  update_gateway_ami_by_pk?: Maybe<Gateway_Ami>;
  /** update multiples rows of table: "gateway_ami" */
  update_gateway_ami_many?: Maybe<Array<Maybe<Gateway_Ami_Mutation_Response>>>;
  /** update data of the table: "gateway_cluster" */
  update_gateway_cluster?: Maybe<Gateway_Cluster_Mutation_Response>;
  /** update single row of the table: "gateway_cluster" */
  update_gateway_cluster_by_pk?: Maybe<Gateway_Cluster>;
  /** update multiples rows of table: "gateway_cluster" */
  update_gateway_cluster_many?: Maybe<
    Array<Maybe<Gateway_Cluster_Mutation_Response>>
  >;
  /** update data of the table: "gateway_worker" */
  update_gateway_worker?: Maybe<Gateway_Worker_Mutation_Response>;
  /** update single row of the table: "gateway_worker" */
  update_gateway_worker_by_pk?: Maybe<Gateway_Worker>;
  /** update multiples rows of table: "gateway_worker" */
  update_gateway_worker_many?: Maybe<
    Array<Maybe<Gateway_Worker_Mutation_Response>>
  >;
  /** update data of the table: "github_email_type" */
  update_github_email_type?: Maybe<Github_Email_Type_Mutation_Response>;
  /** update single row of the table: "github_email_type" */
  update_github_email_type_by_pk?: Maybe<Github_Email_Type>;
  /** update multiples rows of table: "github_email_type" */
  update_github_email_type_many?: Maybe<
    Array<Maybe<Github_Email_Type_Mutation_Response>>
  >;
  /** update data of the table: "github_integration_config" */
  update_github_integration_config?: Maybe<Github_Integration_Config_Mutation_Response>;
  /** update single row of the table: "github_integration_config" */
  update_github_integration_config_by_pk?: Maybe<Github_Integration_Config>;
  /** update multiples rows of table: "github_integration_config" */
  update_github_integration_config_many?: Maybe<
    Array<Maybe<Github_Integration_Config_Mutation_Response>>
  >;
  /** update data of the table: "github_integration_mode" */
  update_github_integration_mode?: Maybe<Github_Integration_Mode_Mutation_Response>;
  /** update single row of the table: "github_integration_mode" */
  update_github_integration_mode_by_pk?: Maybe<Github_Integration_Mode>;
  /** update multiples rows of table: "github_integration_mode" */
  update_github_integration_mode_many?: Maybe<
    Array<Maybe<Github_Integration_Mode_Mutation_Response>>
  >;
  /** update data of the table: "github_push_event" */
  update_github_push_event?: Maybe<Github_Push_Event_Mutation_Response>;
  /** update single row of the table: "github_push_event" */
  update_github_push_event_by_pk?: Maybe<Github_Push_Event>;
  /** update data of the table: "github_push_event_job" */
  update_github_push_event_job?: Maybe<Github_Push_Event_Job_Mutation_Response>;
  /** update single row of the table: "github_push_event_job" */
  update_github_push_event_job_by_pk?: Maybe<Github_Push_Event_Job>;
  /** update multiples rows of table: "github_push_event_job" */
  update_github_push_event_job_many?: Maybe<
    Array<Maybe<Github_Push_Event_Job_Mutation_Response>>
  >;
  /** update multiples rows of table: "github_push_event" */
  update_github_push_event_many?: Maybe<
    Array<Maybe<Github_Push_Event_Mutation_Response>>
  >;
  /** update data of the table: "hasura_ami" */
  update_hasura_ami?: Maybe<Hasura_Ami_Mutation_Response>;
  /** update single row of the table: "hasura_ami" */
  update_hasura_ami_by_pk?: Maybe<Hasura_Ami>;
  /** update multiples rows of table: "hasura_ami" */
  update_hasura_ami_many?: Maybe<Array<Maybe<Hasura_Ami_Mutation_Response>>>;
  /** update data of the table: "hasura_cluster" */
  update_hasura_cluster?: Maybe<Hasura_Cluster_Mutation_Response>;
  /** update single row of the table: "hasura_cluster" */
  update_hasura_cluster_by_pk?: Maybe<Hasura_Cluster>;
  /** update multiples rows of table: "hasura_cluster" */
  update_hasura_cluster_many?: Maybe<
    Array<Maybe<Hasura_Cluster_Mutation_Response>>
  >;
  /** update data of the table: "hasura_worker" */
  update_hasura_worker?: Maybe<Hasura_Worker_Mutation_Response>;
  /** update single row of the table: "hasura_worker" */
  update_hasura_worker_by_pk?: Maybe<Hasura_Worker>;
  /** update multiples rows of table: "hasura_worker" */
  update_hasura_worker_many?: Maybe<
    Array<Maybe<Hasura_Worker_Mutation_Response>>
  >;
  /** update data of the table: "heroku_integrations" */
  update_heroku_integrations?: Maybe<Heroku_Integrations_Mutation_Response>;
  /** update single row of the table: "heroku_integrations" */
  update_heroku_integrations_by_pk?: Maybe<Heroku_Integrations>;
  /** update multiples rows of table: "heroku_integrations" */
  update_heroku_integrations_many?: Maybe<
    Array<Maybe<Heroku_Integrations_Mutation_Response>>
  >;
  /** update data of the table: "inactive_project_exclusions" */
  update_inactive_project_exclusions?: Maybe<Inactive_Project_Exclusions_Mutation_Response>;
  /** update single row of the table: "inactive_project_exclusions" */
  update_inactive_project_exclusions_by_pk?: Maybe<Inactive_Project_Exclusions>;
  /** update multiples rows of table: "inactive_project_exclusions" */
  update_inactive_project_exclusions_many?: Maybe<
    Array<Maybe<Inactive_Project_Exclusions_Mutation_Response>>
  >;
  /** update data of the table: "inactive_project_notifications" */
  update_inactive_project_notifications?: Maybe<Inactive_Project_Notifications_Mutation_Response>;
  /** update single row of the table: "inactive_project_notifications" */
  update_inactive_project_notifications_by_pk?: Maybe<Inactive_Project_Notifications>;
  /** update multiples rows of table: "inactive_project_notifications" */
  update_inactive_project_notifications_many?: Maybe<
    Array<Maybe<Inactive_Project_Notifications_Mutation_Response>>
  >;
  /** update data of the table: "inactive_project_suspension_config" */
  update_inactive_project_suspension_config?: Maybe<Inactive_Project_Suspension_Config_Mutation_Response>;
  /** update multiples rows of table: "inactive_project_suspension_config" */
  update_inactive_project_suspension_config_many?: Maybe<
    Array<Maybe<Inactive_Project_Suspension_Config_Mutation_Response>>
  >;
  /** update data of the table: "infra_status" */
  update_infra_status?: Maybe<Infra_Status_Mutation_Response>;
  /** update single row of the table: "infra_status" */
  update_infra_status_by_pk?: Maybe<Infra_Status>;
  /** update multiples rows of table: "infra_status" */
  update_infra_status_many?: Maybe<
    Array<Maybe<Infra_Status_Mutation_Response>>
  >;
  /** update data of the table: "invoice" */
  update_invoice?: Maybe<Invoice_Mutation_Response>;
  /** update single row of the table: "invoice" */
  update_invoice_by_pk?: Maybe<Invoice>;
  /** update data of the table: "invoice_coupon_discount" */
  update_invoice_coupon_discount?: Maybe<Invoice_Coupon_Discount_Mutation_Response>;
  /** update single row of the table: "invoice_coupon_discount" */
  update_invoice_coupon_discount_by_pk?: Maybe<Invoice_Coupon_Discount>;
  /** update multiples rows of table: "invoice_coupon_discount" */
  update_invoice_coupon_discount_many?: Maybe<
    Array<Maybe<Invoice_Coupon_Discount_Mutation_Response>>
  >;
  /** update data of the table: "invoice_item" */
  update_invoice_item?: Maybe<Invoice_Item_Mutation_Response>;
  /** update single row of the table: "invoice_item" */
  update_invoice_item_by_pk?: Maybe<Invoice_Item>;
  /** update multiples rows of table: "invoice_item" */
  update_invoice_item_many?: Maybe<
    Array<Maybe<Invoice_Item_Mutation_Response>>
  >;
  /** update multiples rows of table: "invoice" */
  update_invoice_many?: Maybe<Array<Maybe<Invoice_Mutation_Response>>>;
  /** update data of the table: "jobs" */
  update_jobs?: Maybe<Jobs_Mutation_Response>;
  /** update single row of the table: "jobs" */
  update_jobs_by_pk?: Maybe<Jobs>;
  /** update multiples rows of table: "jobs" */
  update_jobs_many?: Maybe<Array<Maybe<Jobs_Mutation_Response>>>;
  /** update data of the table: "label" */
  update_label?: Maybe<Label_Mutation_Response>;
  /** update single row of the table: "label" */
  update_label_by_pk?: Maybe<Label>;
  /** update multiples rows of table: "label" */
  update_label_many?: Maybe<Array<Maybe<Label_Mutation_Response>>>;
  /** update data of the table: "letsencrypt_status" */
  update_letsencrypt_status?: Maybe<Letsencrypt_Status_Mutation_Response>;
  /** update single row of the table: "letsencrypt_status" */
  update_letsencrypt_status_by_pk?: Maybe<Letsencrypt_Status>;
  /** update multiples rows of table: "letsencrypt_status" */
  update_letsencrypt_status_many?: Maybe<
    Array<Maybe<Letsencrypt_Status_Mutation_Response>>
  >;
  /** update data of the table: "license_activity" */
  update_license_activity?: Maybe<License_Activity_Mutation_Response>;
  /** update single row of the table: "license_activity" */
  update_license_activity_by_pk?: Maybe<License_Activity>;
  /** update multiples rows of table: "license_activity" */
  update_license_activity_many?: Maybe<
    Array<Maybe<License_Activity_Mutation_Response>>
  >;
  /** update data of the table: "license_instance" */
  update_license_instance?: Maybe<License_Instance_Mutation_Response>;
  /** update single row of the table: "license_instance" */
  update_license_instance_by_pk?: Maybe<License_Instance>;
  /** update multiples rows of table: "license_instance" */
  update_license_instance_many?: Maybe<
    Array<Maybe<License_Instance_Mutation_Response>>
  >;
  /** update data of the table: "license_type" */
  update_license_type?: Maybe<License_Type_Mutation_Response>;
  /** update single row of the table: "license_type" */
  update_license_type_by_pk?: Maybe<License_Type>;
  /** update multiples rows of table: "license_type" */
  update_license_type_many?: Maybe<
    Array<Maybe<License_Type_Mutation_Response>>
  >;
  /** update data of the table: "licenses" */
  update_licenses?: Maybe<Licenses_Mutation_Response>;
  /** update single row of the table: "licenses" */
  update_licenses_by_pk?: Maybe<Licenses>;
  /** update multiples rows of table: "licenses" */
  update_licenses_many?: Maybe<Array<Maybe<Licenses_Mutation_Response>>>;
  /** update data of the table: "lux_proxy" */
  update_lux_proxy?: Maybe<Lux_Proxy_Mutation_Response>;
  /** update data of the table: "lux_proxy_ami" */
  update_lux_proxy_ami?: Maybe<Lux_Proxy_Ami_Mutation_Response>;
  /** update single row of the table: "lux_proxy_ami" */
  update_lux_proxy_ami_by_pk?: Maybe<Lux_Proxy_Ami>;
  /** update multiples rows of table: "lux_proxy_ami" */
  update_lux_proxy_ami_many?: Maybe<
    Array<Maybe<Lux_Proxy_Ami_Mutation_Response>>
  >;
  /** update single row of the table: "lux_proxy" */
  update_lux_proxy_by_pk?: Maybe<Lux_Proxy>;
  /** update multiples rows of table: "lux_proxy" */
  update_lux_proxy_many?: Maybe<Array<Maybe<Lux_Proxy_Mutation_Response>>>;
  /** update data of the table: "neon_db_integration" */
  update_neon_db_integration?: Maybe<Neon_Db_Integration_Mutation_Response>;
  /** update single row of the table: "neon_db_integration" */
  update_neon_db_integration_by_pk?: Maybe<Neon_Db_Integration>;
  /** update multiples rows of table: "neon_db_integration" */
  update_neon_db_integration_many?: Maybe<
    Array<Maybe<Neon_Db_Integration_Mutation_Response>>
  >;
  /** update data of the table: "newrelic_config" */
  update_newrelic_config?: Maybe<Newrelic_Config_Mutation_Response>;
  /** update single row of the table: "newrelic_config" */
  update_newrelic_config_by_pk?: Maybe<Newrelic_Config>;
  /** update multiples rows of table: "newrelic_config" */
  update_newrelic_config_many?: Maybe<
    Array<Maybe<Newrelic_Config_Mutation_Response>>
  >;
  /** update data of the table: "node_pool_type" */
  update_node_pool_type?: Maybe<Node_Pool_Type_Mutation_Response>;
  /** update single row of the table: "node_pool_type" */
  update_node_pool_type_by_pk?: Maybe<Node_Pool_Type>;
  /** update multiples rows of table: "node_pool_type" */
  update_node_pool_type_many?: Maybe<
    Array<Maybe<Node_Pool_Type_Mutation_Response>>
  >;
  /** update data of the table: "node_pools" */
  update_node_pools?: Maybe<Node_Pools_Mutation_Response>;
  /** update single row of the table: "node_pools" */
  update_node_pools_by_pk?: Maybe<Node_Pools>;
  /** update multiples rows of table: "node_pools" */
  update_node_pools_many?: Maybe<Array<Maybe<Node_Pools_Mutation_Response>>>;
  /** update data of the table: "notification" */
  update_notification?: Maybe<Notification_Mutation_Response>;
  /** update single row of the table: "notification" */
  update_notification_by_pk?: Maybe<Notification>;
  /** update multiples rows of table: "notification" */
  update_notification_many?: Maybe<
    Array<Maybe<Notification_Mutation_Response>>
  >;
  /** update data of the table: "notification_type" */
  update_notification_type?: Maybe<Notification_Type_Mutation_Response>;
  /** update single row of the table: "notification_type" */
  update_notification_type_by_pk?: Maybe<Notification_Type>;
  /** update multiples rows of table: "notification_type" */
  update_notification_type_many?: Maybe<
    Array<Maybe<Notification_Type_Mutation_Response>>
  >;
  /** update data of the table: "onboarding_sample_db_cohort" */
  update_onboarding_sample_db_cohort?: Maybe<Onboarding_Sample_Db_Cohort_Mutation_Response>;
  /** update single row of the table: "onboarding_sample_db_cohort" */
  update_onboarding_sample_db_cohort_by_pk?: Maybe<Onboarding_Sample_Db_Cohort>;
  /** update multiples rows of table: "onboarding_sample_db_cohort" */
  update_onboarding_sample_db_cohort_many?: Maybe<
    Array<Maybe<Onboarding_Sample_Db_Cohort_Mutation_Response>>
  >;
  /** update data of the table: "onboarding_sample_db_config" */
  update_onboarding_sample_db_config?: Maybe<Onboarding_Sample_Db_Config_Mutation_Response>;
  /** update single row of the table: "onboarding_sample_db_config" */
  update_onboarding_sample_db_config_by_pk?: Maybe<Onboarding_Sample_Db_Config>;
  /** update multiples rows of table: "onboarding_sample_db_config" */
  update_onboarding_sample_db_config_many?: Maybe<
    Array<Maybe<Onboarding_Sample_Db_Config_Mutation_Response>>
  >;
  /** update data of the table: "one_click_deployment" */
  update_one_click_deployment?: Maybe<One_Click_Deployment_Mutation_Response>;
  /** update single row of the table: "one_click_deployment" */
  update_one_click_deployment_by_pk?: Maybe<One_Click_Deployment>;
  /** update multiples rows of table: "one_click_deployment" */
  update_one_click_deployment_many?: Maybe<
    Array<Maybe<One_Click_Deployment_Mutation_Response>>
  >;
  /** update data of the table: "one_click_deployment_sample_apps" */
  update_one_click_deployment_sample_apps?: Maybe<One_Click_Deployment_Sample_Apps_Mutation_Response>;
  /** update single row of the table: "one_click_deployment_sample_apps" */
  update_one_click_deployment_sample_apps_by_pk?: Maybe<One_Click_Deployment_Sample_Apps>;
  /** update multiples rows of table: "one_click_deployment_sample_apps" */
  update_one_click_deployment_sample_apps_many?: Maybe<
    Array<Maybe<One_Click_Deployment_Sample_Apps_Mutation_Response>>
  >;
  /** update data of the table: "one_click_deployment_state_log" */
  update_one_click_deployment_state_log?: Maybe<One_Click_Deployment_State_Log_Mutation_Response>;
  /** update single row of the table: "one_click_deployment_state_log" */
  update_one_click_deployment_state_log_by_pk?: Maybe<One_Click_Deployment_State_Log>;
  /** update multiples rows of table: "one_click_deployment_state_log" */
  update_one_click_deployment_state_log_many?: Maybe<
    Array<Maybe<One_Click_Deployment_State_Log_Mutation_Response>>
  >;
  /** update data of the table: "one_click_deployment_states" */
  update_one_click_deployment_states?: Maybe<One_Click_Deployment_States_Mutation_Response>;
  /** update single row of the table: "one_click_deployment_states" */
  update_one_click_deployment_states_by_pk?: Maybe<One_Click_Deployment_States>;
  /** update multiples rows of table: "one_click_deployment_states" */
  update_one_click_deployment_states_many?: Maybe<
    Array<Maybe<One_Click_Deployment_States_Mutation_Response>>
  >;
  /** update data of the table: "opentelemetry_config" */
  update_opentelemetry_config?: Maybe<Opentelemetry_Config_Mutation_Response>;
  /** update single row of the table: "opentelemetry_config" */
  update_opentelemetry_config_by_pk?: Maybe<Opentelemetry_Config>;
  /** update multiples rows of table: "opentelemetry_config" */
  update_opentelemetry_config_many?: Maybe<
    Array<Maybe<Opentelemetry_Config_Mutation_Response>>
  >;
  /** update data of the table: "operations.delete_free_plan_dns_records_nov_2021" */
  update_operations_delete_free_plan_dns_records_nov_2021?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Mutation_Response>;
  /** update single row of the table: "operations.delete_free_plan_dns_records_nov_2021" */
  update_operations_delete_free_plan_dns_records_nov_2021_by_pk?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021>;
  /** update multiples rows of table: "operations.delete_free_plan_dns_records_nov_2021" */
  update_operations_delete_free_plan_dns_records_nov_2021_many?: Maybe<
    Array<
      Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Mutation_Response>
    >
  >;
  /** update data of the table: "operations.tenant" */
  update_operations_tenant?: Maybe<Operations_Tenant_Mutation_Response>;
  /** update multiples rows of table: "operations.tenant" */
  update_operations_tenant_many?: Maybe<
    Array<Maybe<Operations_Tenant_Mutation_Response>>
  >;
  /** update data of the table: "payment_method" */
  update_payment_method?: Maybe<Payment_Method_Mutation_Response>;
  /** update single row of the table: "payment_method" */
  update_payment_method_by_pk?: Maybe<Payment_Method>;
  /** update multiples rows of table: "payment_method" */
  update_payment_method_many?: Maybe<
    Array<Maybe<Payment_Method_Mutation_Response>>
  >;
  /** update data of the table: "plan_entitlements" */
  update_plan_entitlements?: Maybe<Plan_Entitlements_Mutation_Response>;
  /** update single row of the table: "plan_entitlements" */
  update_plan_entitlements_by_pk?: Maybe<Plan_Entitlements>;
  /** update multiples rows of table: "plan_entitlements" */
  update_plan_entitlements_many?: Maybe<
    Array<Maybe<Plan_Entitlements_Mutation_Response>>
  >;
  /** update data of the table: "plans" */
  update_plans?: Maybe<Plans_Mutation_Response>;
  /** update single row of the table: "plans" */
  update_plans_by_pk?: Maybe<Plans>;
  /** update multiples rows of table: "plans" */
  update_plans_many?: Maybe<Array<Maybe<Plans_Mutation_Response>>>;
  /** update data of the table: "policies" */
  update_policies?: Maybe<Policies_Mutation_Response>;
  /** update single row of the table: "policies" */
  update_policies_by_pk?: Maybe<Policies>;
  /** update multiples rows of table: "policies" */
  update_policies_many?: Maybe<Array<Maybe<Policies_Mutation_Response>>>;
  /** update data of the table: "privileges" */
  update_privileges?: Maybe<Privileges_Mutation_Response>;
  /** update single row of the table: "privileges" */
  update_privileges_by_pk?: Maybe<Privileges>;
  /** update multiples rows of table: "privileges" */
  update_privileges_many?: Maybe<Array<Maybe<Privileges_Mutation_Response>>>;
  /** update data of the table: "pro_license_keys" */
  update_pro_license_keys?: Maybe<Pro_License_Keys_Mutation_Response>;
  /** update single row of the table: "pro_license_keys" */
  update_pro_license_keys_by_pk?: Maybe<Pro_License_Keys>;
  /** update multiples rows of table: "pro_license_keys" */
  update_pro_license_keys_many?: Maybe<
    Array<Maybe<Pro_License_Keys_Mutation_Response>>
  >;
  /** update data of the table: "project_activity" */
  update_project_activity?: Maybe<Project_Activity_Mutation_Response>;
  /** update single row of the table: "project_activity" */
  update_project_activity_by_pk?: Maybe<Project_Activity>;
  /** update multiples rows of table: "project_activity" */
  update_project_activity_many?: Maybe<
    Array<Maybe<Project_Activity_Mutation_Response>>
  >;
  /** update data of the table: "project_billing_manager_invitations" */
  update_project_billing_manager_invitations?: Maybe<Project_Billing_Manager_Invitations_Mutation_Response>;
  /** update single row of the table: "project_billing_manager_invitations" */
  update_project_billing_manager_invitations_by_pk?: Maybe<Project_Billing_Manager_Invitations>;
  /** update multiples rows of table: "project_billing_manager_invitations" */
  update_project_billing_manager_invitations_many?: Maybe<
    Array<Maybe<Project_Billing_Manager_Invitations_Mutation_Response>>
  >;
  /** update data of the table: "project_collaborator_allowed_schema_tables" */
  update_project_collaborator_allowed_schema_tables?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Mutation_Response>;
  /** update single row of the table: "project_collaborator_allowed_schema_tables" */
  update_project_collaborator_allowed_schema_tables_by_pk?: Maybe<Project_Collaborator_Allowed_Schema_Tables>;
  /** update multiples rows of table: "project_collaborator_allowed_schema_tables" */
  update_project_collaborator_allowed_schema_tables_many?: Maybe<
    Array<Maybe<Project_Collaborator_Allowed_Schema_Tables_Mutation_Response>>
  >;
  /** update data of the table: "project_collaborator_allowed_schemas" */
  update_project_collaborator_allowed_schemas?: Maybe<Project_Collaborator_Allowed_Schemas_Mutation_Response>;
  /** update single row of the table: "project_collaborator_allowed_schemas" */
  update_project_collaborator_allowed_schemas_by_pk?: Maybe<Project_Collaborator_Allowed_Schemas>;
  /** update multiples rows of table: "project_collaborator_allowed_schemas" */
  update_project_collaborator_allowed_schemas_many?: Maybe<
    Array<Maybe<Project_Collaborator_Allowed_Schemas_Mutation_Response>>
  >;
  /** update data of the table: "project_collaborator_invitations" */
  update_project_collaborator_invitations?: Maybe<Project_Collaborator_Invitations_Mutation_Response>;
  /** update single row of the table: "project_collaborator_invitations" */
  update_project_collaborator_invitations_by_pk?: Maybe<Project_Collaborator_Invitations>;
  /** update multiples rows of table: "project_collaborator_invitations" */
  update_project_collaborator_invitations_many?: Maybe<
    Array<Maybe<Project_Collaborator_Invitations_Mutation_Response>>
  >;
  /** update data of the table: "project_collaborator_privileges" */
  update_project_collaborator_privileges?: Maybe<Project_Collaborator_Privileges_Mutation_Response>;
  /** update single row of the table: "project_collaborator_privileges" */
  update_project_collaborator_privileges_by_pk?: Maybe<Project_Collaborator_Privileges>;
  /** update multiples rows of table: "project_collaborator_privileges" */
  update_project_collaborator_privileges_many?: Maybe<
    Array<Maybe<Project_Collaborator_Privileges_Mutation_Response>>
  >;
  /** update data of the table: "project_collaborators" */
  update_project_collaborators?: Maybe<Project_Collaborators_Mutation_Response>;
  /** update single row of the table: "project_collaborators" */
  update_project_collaborators_by_pk?: Maybe<Project_Collaborators>;
  /** update multiples rows of table: "project_collaborators" */
  update_project_collaborators_many?: Maybe<
    Array<Maybe<Project_Collaborators_Mutation_Response>>
  >;
  /** update data of the table: "project_data_usage" */
  update_project_data_usage?: Maybe<Project_Data_Usage_Mutation_Response>;
  /** update data of the table: "project_data_usage_agg" */
  update_project_data_usage_agg?: Maybe<Project_Data_Usage_Agg_Mutation_Response>;
  /** update multiples rows of table: "project_data_usage_agg" */
  update_project_data_usage_agg_many?: Maybe<
    Array<Maybe<Project_Data_Usage_Agg_Mutation_Response>>
  >;
  /** update data of the table: "project_data_usage_agg_user" */
  update_project_data_usage_agg_user?: Maybe<Project_Data_Usage_Agg_User_Mutation_Response>;
  /** update multiples rows of table: "project_data_usage_agg_user" */
  update_project_data_usage_agg_user_many?: Maybe<
    Array<Maybe<Project_Data_Usage_Agg_User_Mutation_Response>>
  >;
  /** update single row of the table: "project_data_usage" */
  update_project_data_usage_by_pk?: Maybe<Project_Data_Usage>;
  /** update data of the table: "project_data_usage_components" */
  update_project_data_usage_components?: Maybe<Project_Data_Usage_Components_Mutation_Response>;
  /** update multiples rows of table: "project_data_usage_components" */
  update_project_data_usage_components_many?: Maybe<
    Array<Maybe<Project_Data_Usage_Components_Mutation_Response>>
  >;
  /** update multiples rows of table: "project_data_usage" */
  update_project_data_usage_many?: Maybe<
    Array<Maybe<Project_Data_Usage_Mutation_Response>>
  >;
  /** update data of the table: "project_data_usage_prometheus" */
  update_project_data_usage_prometheus?: Maybe<Project_Data_Usage_Prometheus_Mutation_Response>;
  /** update data of the table: "project_data_usage_prometheus_agg_user" */
  update_project_data_usage_prometheus_agg_user?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Mutation_Response>;
  /** update multiples rows of table: "project_data_usage_prometheus_agg_user" */
  update_project_data_usage_prometheus_agg_user_many?: Maybe<
    Array<Maybe<Project_Data_Usage_Prometheus_Agg_User_Mutation_Response>>
  >;
  /** update single row of the table: "project_data_usage_prometheus" */
  update_project_data_usage_prometheus_by_pk?: Maybe<Project_Data_Usage_Prometheus>;
  /** update multiples rows of table: "project_data_usage_prometheus" */
  update_project_data_usage_prometheus_many?: Maybe<
    Array<Maybe<Project_Data_Usage_Prometheus_Mutation_Response>>
  >;
  /** update data of the table: "project_data_usage_report" */
  update_project_data_usage_report?: Maybe<Project_Data_Usage_Report_Mutation_Response>;
  /** update single row of the table: "project_data_usage_report" */
  update_project_data_usage_report_by_pk?: Maybe<Project_Data_Usage_Report>;
  /** update multiples rows of table: "project_data_usage_report" */
  update_project_data_usage_report_many?: Maybe<
    Array<Maybe<Project_Data_Usage_Report_Mutation_Response>>
  >;
  /** update data of the table: "project_db_usage" */
  update_project_db_usage?: Maybe<Project_Db_Usage_Mutation_Response>;
  /** update data of the table: "project_db_usage_agg_user" */
  update_project_db_usage_agg_user?: Maybe<Project_Db_Usage_Agg_User_Mutation_Response>;
  /** update multiples rows of table: "project_db_usage_agg_user" */
  update_project_db_usage_agg_user_many?: Maybe<
    Array<Maybe<Project_Db_Usage_Agg_User_Mutation_Response>>
  >;
  /** update single row of the table: "project_db_usage" */
  update_project_db_usage_by_pk?: Maybe<Project_Db_Usage>;
  /** update multiples rows of table: "project_db_usage" */
  update_project_db_usage_many?: Maybe<
    Array<Maybe<Project_Db_Usage_Mutation_Response>>
  >;
  /** update data of the table: "project_entitlement_access" */
  update_project_entitlement_access?: Maybe<Project_Entitlement_Access_Mutation_Response>;
  /** update single row of the table: "project_entitlement_access" */
  update_project_entitlement_access_by_pk?: Maybe<Project_Entitlement_Access>;
  /** update multiples rows of table: "project_entitlement_access" */
  update_project_entitlement_access_many?: Maybe<
    Array<Maybe<Project_Entitlement_Access_Mutation_Response>>
  >;
  /** update data of the table: "project_entitlement_catalogue" */
  update_project_entitlement_catalogue?: Maybe<Project_Entitlement_Catalogue_Mutation_Response>;
  /** update single row of the table: "project_entitlement_catalogue" */
  update_project_entitlement_catalogue_by_pk?: Maybe<Project_Entitlement_Catalogue>;
  /** update multiples rows of table: "project_entitlement_catalogue" */
  update_project_entitlement_catalogue_many?: Maybe<
    Array<Maybe<Project_Entitlement_Catalogue_Mutation_Response>>
  >;
  /** update data of the table: "project_entitlement_types" */
  update_project_entitlement_types?: Maybe<Project_Entitlement_Types_Mutation_Response>;
  /** update single row of the table: "project_entitlement_types" */
  update_project_entitlement_types_by_pk?: Maybe<Project_Entitlement_Types>;
  /** update multiples rows of table: "project_entitlement_types" */
  update_project_entitlement_types_many?: Maybe<
    Array<Maybe<Project_Entitlement_Types_Mutation_Response>>
  >;
  /** update data of the table: "project_labels" */
  update_project_labels?: Maybe<Project_Labels_Mutation_Response>;
  /** update single row of the table: "project_labels" */
  update_project_labels_by_pk?: Maybe<Project_Labels>;
  /** update multiples rows of table: "project_labels" */
  update_project_labels_many?: Maybe<
    Array<Maybe<Project_Labels_Mutation_Response>>
  >;
  /** update data of the table: "project_metadata" */
  update_project_metadata?: Maybe<Project_Metadata_Mutation_Response>;
  /** update single row of the table: "project_metadata" */
  update_project_metadata_by_pk?: Maybe<Project_Metadata>;
  /** update multiples rows of table: "project_metadata" */
  update_project_metadata_many?: Maybe<
    Array<Maybe<Project_Metadata_Mutation_Response>>
  >;
  /** update data of the table: "project_notification" */
  update_project_notification?: Maybe<Project_Notification_Mutation_Response>;
  /** update single row of the table: "project_notification" */
  update_project_notification_by_pk?: Maybe<Project_Notification>;
  /** update multiples rows of table: "project_notification" */
  update_project_notification_many?: Maybe<
    Array<Maybe<Project_Notification_Mutation_Response>>
  >;
  /** update data of the table: "project_ownership_transfer_invitations" */
  update_project_ownership_transfer_invitations?: Maybe<Project_Ownership_Transfer_Invitations_Mutation_Response>;
  /** update single row of the table: "project_ownership_transfer_invitations" */
  update_project_ownership_transfer_invitations_by_pk?: Maybe<Project_Ownership_Transfer_Invitations>;
  /** update multiples rows of table: "project_ownership_transfer_invitations" */
  update_project_ownership_transfer_invitations_many?: Maybe<
    Array<Maybe<Project_Ownership_Transfer_Invitations_Mutation_Response>>
  >;
  /** update data of the table: "project_requests_count" */
  update_project_requests_count?: Maybe<Project_Requests_Count_Mutation_Response>;
  /** update single row of the table: "project_requests_count" */
  update_project_requests_count_by_pk?: Maybe<Project_Requests_Count>;
  /** update multiples rows of table: "project_requests_count" */
  update_project_requests_count_many?: Maybe<
    Array<Maybe<Project_Requests_Count_Mutation_Response>>
  >;
  /** update data of the table: "project_stats" */
  update_project_stats?: Maybe<Project_Stats_Mutation_Response>;
  /** update single row of the table: "project_stats" */
  update_project_stats_by_pk?: Maybe<Project_Stats>;
  /** update multiples rows of table: "project_stats" */
  update_project_stats_many?: Maybe<
    Array<Maybe<Project_Stats_Mutation_Response>>
  >;
  /** update data of the table: "project_total_db_usage_agg" */
  update_project_total_db_usage_agg?: Maybe<Project_Total_Db_Usage_Agg_Mutation_Response>;
  /** update multiples rows of table: "project_total_db_usage_agg" */
  update_project_total_db_usage_agg_many?: Maybe<
    Array<Maybe<Project_Total_Db_Usage_Agg_Mutation_Response>>
  >;
  /** update data of the table: "projects" */
  update_projects?: Maybe<Projects_Mutation_Response>;
  /** update single row of the table: "projects" */
  update_projects_by_pk?: Maybe<Projects>;
  /** update multiples rows of table: "projects" */
  update_projects_many?: Maybe<Array<Maybe<Projects_Mutation_Response>>>;
  /** update data of the table: "projects_pool_config" */
  update_projects_pool_config?: Maybe<Projects_Pool_Config_Mutation_Response>;
  /** update single row of the table: "projects_pool_config" */
  update_projects_pool_config_by_pk?: Maybe<Projects_Pool_Config>;
  /** update multiples rows of table: "projects_pool_config" */
  update_projects_pool_config_many?: Maybe<
    Array<Maybe<Projects_Pool_Config_Mutation_Response>>
  >;
  /** update data of the table: "projects_pro_key_generations" */
  update_projects_pro_key_generations?: Maybe<Projects_Pro_Key_Generations_Mutation_Response>;
  /** update single row of the table: "projects_pro_key_generations" */
  update_projects_pro_key_generations_by_pk?: Maybe<Projects_Pro_Key_Generations>;
  /** update multiples rows of table: "projects_pro_key_generations" */
  update_projects_pro_key_generations_many?: Maybe<
    Array<Maybe<Projects_Pro_Key_Generations_Mutation_Response>>
  >;
  /** update data of the table: "prometheus_config" */
  update_prometheus_config?: Maybe<Prometheus_Config_Mutation_Response>;
  /** update single row of the table: "prometheus_config" */
  update_prometheus_config_by_pk?: Maybe<Prometheus_Config>;
  /** update multiples rows of table: "prometheus_config" */
  update_prometheus_config_many?: Maybe<
    Array<Maybe<Prometheus_Config_Mutation_Response>>
  >;
  /** update data of the table: "providers" */
  update_providers?: Maybe<Providers_Mutation_Response>;
  /** update single row of the table: "providers" */
  update_providers_by_pk?: Maybe<Providers>;
  /** update multiples rows of table: "providers" */
  update_providers_many?: Maybe<Array<Maybe<Providers_Mutation_Response>>>;
  /** update data of the table: "provisioning" */
  update_provisioning?: Maybe<Provisioning_Mutation_Response>;
  /** update single row of the table: "provisioning" */
  update_provisioning_by_pk?: Maybe<Provisioning>;
  /** update multiples rows of table: "provisioning" */
  update_provisioning_many?: Maybe<
    Array<Maybe<Provisioning_Mutation_Response>>
  >;
  /** update data of the table: "region" */
  update_region?: Maybe<Region_Mutation_Response>;
  /** update single row of the table: "region" */
  update_region_by_pk?: Maybe<Region>;
  /** update multiples rows of table: "region" */
  update_region_many?: Maybe<Array<Maybe<Region_Mutation_Response>>>;
  /** update data of the table: "region_v2" */
  update_region_v2?: Maybe<Region_V2_Mutation_Response>;
  /** update multiples rows of table: "region_v2" */
  update_region_v2_many?: Maybe<Array<Maybe<Region_V2_Mutation_Response>>>;
  /** update data of the table: "regional_data_connectors" */
  update_regional_data_connectors?: Maybe<Regional_Data_Connectors_Mutation_Response>;
  /** update single row of the table: "regional_data_connectors" */
  update_regional_data_connectors_by_pk?: Maybe<Regional_Data_Connectors>;
  /** update multiples rows of table: "regional_data_connectors" */
  update_regional_data_connectors_many?: Maybe<
    Array<Maybe<Regional_Data_Connectors_Mutation_Response>>
  >;
  /** update data of the table: "regional_metrics" */
  update_regional_metrics?: Maybe<Regional_Metrics_Mutation_Response>;
  /** update single row of the table: "regional_metrics" */
  update_regional_metrics_by_pk?: Maybe<Regional_Metrics>;
  /** update multiples rows of table: "regional_metrics" */
  update_regional_metrics_many?: Maybe<
    Array<Maybe<Regional_Metrics_Mutation_Response>>
  >;
  /** update data of the table: "saml_idp" */
  update_saml_idp?: Maybe<Saml_Idp_Mutation_Response>;
  /** update single row of the table: "saml_idp" */
  update_saml_idp_by_pk?: Maybe<Saml_Idp>;
  /** update multiples rows of table: "saml_idp" */
  update_saml_idp_many?: Maybe<Array<Maybe<Saml_Idp_Mutation_Response>>>;
  /** update data of the table: "search_project_login_status_results" */
  update_search_project_login_status_results?: Maybe<Search_Project_Login_Status_Results_Mutation_Response>;
  /** update multiples rows of table: "search_project_login_status_results" */
  update_search_project_login_status_results_many?: Maybe<
    Array<Maybe<Search_Project_Login_Status_Results_Mutation_Response>>
  >;
  /** update data of the table: "slack_config" */
  update_slack_config?: Maybe<Slack_Config_Mutation_Response>;
  /** update single row of the table: "slack_config" */
  update_slack_config_by_pk?: Maybe<Slack_Config>;
  /** update multiples rows of table: "slack_config" */
  update_slack_config_many?: Maybe<
    Array<Maybe<Slack_Config_Mutation_Response>>
  >;
  /** update data of the table: "stripe_subscription" */
  update_stripe_subscription?: Maybe<Stripe_Subscription_Mutation_Response>;
  /** update single row of the table: "stripe_subscription" */
  update_stripe_subscription_by_pk?: Maybe<Stripe_Subscription>;
  /** update multiples rows of table: "stripe_subscription" */
  update_stripe_subscription_many?: Maybe<
    Array<Maybe<Stripe_Subscription_Mutation_Response>>
  >;
  /** update data of the table: "stripe_webhook_events" */
  update_stripe_webhook_events?: Maybe<Stripe_Webhook_Events_Mutation_Response>;
  /** update single row of the table: "stripe_webhook_events" */
  update_stripe_webhook_events_by_pk?: Maybe<Stripe_Webhook_Events>;
  /** update multiples rows of table: "stripe_webhook_events" */
  update_stripe_webhook_events_many?: Maybe<
    Array<Maybe<Stripe_Webhook_Events_Mutation_Response>>
  >;
  /** update data of the table: "super_connector_types" */
  update_super_connector_types?: Maybe<Super_Connector_Types_Mutation_Response>;
  /** update single row of the table: "super_connector_types" */
  update_super_connector_types_by_pk?: Maybe<Super_Connector_Types>;
  /** update multiples rows of table: "super_connector_types" */
  update_super_connector_types_many?: Maybe<
    Array<Maybe<Super_Connector_Types_Mutation_Response>>
  >;
  /** update data of the table: "support_plan_types" */
  update_support_plan_types?: Maybe<Support_Plan_Types_Mutation_Response>;
  /** update single row of the table: "support_plan_types" */
  update_support_plan_types_by_pk?: Maybe<Support_Plan_Types>;
  /** update multiples rows of table: "support_plan_types" */
  update_support_plan_types_many?: Maybe<
    Array<Maybe<Support_Plan_Types_Mutation_Response>>
  >;
  /** update data of the table: "survey" */
  update_survey?: Maybe<Survey_Mutation_Response>;
  /** update single row of the table: "survey" */
  update_survey_by_pk?: Maybe<Survey>;
  /** update multiples rows of table: "survey" */
  update_survey_many?: Maybe<Array<Maybe<Survey_Mutation_Response>>>;
  /** update data of the table: "survey_question" */
  update_survey_question?: Maybe<Survey_Question_Mutation_Response>;
  /** update data of the table: "survey_question_answer_option" */
  update_survey_question_answer_option?: Maybe<Survey_Question_Answer_Option_Mutation_Response>;
  /** update single row of the table: "survey_question_answer_option" */
  update_survey_question_answer_option_by_pk?: Maybe<Survey_Question_Answer_Option>;
  /** update multiples rows of table: "survey_question_answer_option" */
  update_survey_question_answer_option_many?: Maybe<
    Array<Maybe<Survey_Question_Answer_Option_Mutation_Response>>
  >;
  /** update data of the table: "survey_question_answers" */
  update_survey_question_answers?: Maybe<Survey_Question_Answers_Mutation_Response>;
  /** update single row of the table: "survey_question_answers" */
  update_survey_question_answers_by_pk?: Maybe<Survey_Question_Answers>;
  /** update multiples rows of table: "survey_question_answers" */
  update_survey_question_answers_many?: Maybe<
    Array<Maybe<Survey_Question_Answers_Mutation_Response>>
  >;
  /** update single row of the table: "survey_question" */
  update_survey_question_by_pk?: Maybe<Survey_Question>;
  /** update data of the table: "survey_question_kind" */
  update_survey_question_kind?: Maybe<Survey_Question_Kind_Mutation_Response>;
  /** update single row of the table: "survey_question_kind" */
  update_survey_question_kind_by_pk?: Maybe<Survey_Question_Kind>;
  /** update multiples rows of table: "survey_question_kind" */
  update_survey_question_kind_many?: Maybe<
    Array<Maybe<Survey_Question_Kind_Mutation_Response>>
  >;
  /** update multiples rows of table: "survey_question" */
  update_survey_question_many?: Maybe<
    Array<Maybe<Survey_Question_Mutation_Response>>
  >;
  /** update data of the table: "survey_question_options" */
  update_survey_question_options?: Maybe<Survey_Question_Options_Mutation_Response>;
  /** update single row of the table: "survey_question_options" */
  update_survey_question_options_by_pk?: Maybe<Survey_Question_Options>;
  /** update multiples rows of table: "survey_question_options" */
  update_survey_question_options_many?: Maybe<
    Array<Maybe<Survey_Question_Options_Mutation_Response>>
  >;
  /** update data of the table: "survey_v2" */
  update_survey_v2?: Maybe<Survey_V2_Mutation_Response>;
  /** update single row of the table: "survey_v2" */
  update_survey_v2_by_pk?: Maybe<Survey_V2>;
  /** update multiples rows of table: "survey_v2" */
  update_survey_v2_many?: Maybe<Array<Maybe<Survey_V2_Mutation_Response>>>;
  /** update data of the table: "survey_v2_question" */
  update_survey_v2_question?: Maybe<Survey_V2_Question_Mutation_Response>;
  /** update single row of the table: "survey_v2_question" */
  update_survey_v2_question_by_pk?: Maybe<Survey_V2_Question>;
  /** update data of the table: "survey_v2_question_kind" */
  update_survey_v2_question_kind?: Maybe<Survey_V2_Question_Kind_Mutation_Response>;
  /** update single row of the table: "survey_v2_question_kind" */
  update_survey_v2_question_kind_by_pk?: Maybe<Survey_V2_Question_Kind>;
  /** update multiples rows of table: "survey_v2_question_kind" */
  update_survey_v2_question_kind_many?: Maybe<
    Array<Maybe<Survey_V2_Question_Kind_Mutation_Response>>
  >;
  /** update multiples rows of table: "survey_v2_question" */
  update_survey_v2_question_many?: Maybe<
    Array<Maybe<Survey_V2_Question_Mutation_Response>>
  >;
  /** update data of the table: "survey_v2_question_option" */
  update_survey_v2_question_option?: Maybe<Survey_V2_Question_Option_Mutation_Response>;
  /** update data of the table: "survey_v2_question_option_additional_info_config" */
  update_survey_v2_question_option_additional_info_config?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Mutation_Response>;
  /** update single row of the table: "survey_v2_question_option_additional_info_config" */
  update_survey_v2_question_option_additional_info_config_by_pk?: Maybe<Survey_V2_Question_Option_Additional_Info_Config>;
  /** update multiples rows of table: "survey_v2_question_option_additional_info_config" */
  update_survey_v2_question_option_additional_info_config_many?: Maybe<
    Array<
      Maybe<Survey_V2_Question_Option_Additional_Info_Config_Mutation_Response>
    >
  >;
  /** update single row of the table: "survey_v2_question_option" */
  update_survey_v2_question_option_by_pk?: Maybe<Survey_V2_Question_Option>;
  /** update multiples rows of table: "survey_v2_question_option" */
  update_survey_v2_question_option_many?: Maybe<
    Array<Maybe<Survey_V2_Question_Option_Mutation_Response>>
  >;
  /** update data of the table: "survey_v2_response" */
  update_survey_v2_response?: Maybe<Survey_V2_Response_Mutation_Response>;
  /** update data of the table: "survey_v2_response_answer" */
  update_survey_v2_response_answer?: Maybe<Survey_V2_Response_Answer_Mutation_Response>;
  /** update single row of the table: "survey_v2_response_answer" */
  update_survey_v2_response_answer_by_pk?: Maybe<Survey_V2_Response_Answer>;
  /** update multiples rows of table: "survey_v2_response_answer" */
  update_survey_v2_response_answer_many?: Maybe<
    Array<Maybe<Survey_V2_Response_Answer_Mutation_Response>>
  >;
  /** update data of the table: "survey_v2_response_answer_option" */
  update_survey_v2_response_answer_option?: Maybe<Survey_V2_Response_Answer_Option_Mutation_Response>;
  /** update single row of the table: "survey_v2_response_answer_option" */
  update_survey_v2_response_answer_option_by_pk?: Maybe<Survey_V2_Response_Answer_Option>;
  /** update multiples rows of table: "survey_v2_response_answer_option" */
  update_survey_v2_response_answer_option_many?: Maybe<
    Array<Maybe<Survey_V2_Response_Answer_Option_Mutation_Response>>
  >;
  /** update single row of the table: "survey_v2_response" */
  update_survey_v2_response_by_pk?: Maybe<Survey_V2_Response>;
  /** update multiples rows of table: "survey_v2_response" */
  update_survey_v2_response_many?: Maybe<
    Array<Maybe<Survey_V2_Response_Mutation_Response>>
  >;
  /** update data of the table: "task_event" */
  update_task_event?: Maybe<Task_Event_Mutation_Response>;
  /** update single row of the table: "task_event" */
  update_task_event_by_pk?: Maybe<Task_Event>;
  /** update multiples rows of table: "task_event" */
  update_task_event_many?: Maybe<Array<Maybe<Task_Event_Mutation_Response>>>;
  /** update data of the table: "tasks" */
  update_tasks?: Maybe<Tasks_Mutation_Response>;
  /** update single row of the table: "tasks" */
  update_tasks_by_pk?: Maybe<Tasks>;
  /** update multiples rows of table: "tasks" */
  update_tasks_many?: Maybe<Array<Maybe<Tasks_Mutation_Response>>>;
  /** update data of the table: "tenant" */
  update_tenant?: Maybe<Tenant_Mutation_Response>;
  /** update data of the table: "tenant_active_status_reason" */
  update_tenant_active_status_reason?: Maybe<Tenant_Active_Status_Reason_Mutation_Response>;
  /** update single row of the table: "tenant_active_status_reason" */
  update_tenant_active_status_reason_by_pk?: Maybe<Tenant_Active_Status_Reason>;
  /** update multiples rows of table: "tenant_active_status_reason" */
  update_tenant_active_status_reason_many?: Maybe<
    Array<Maybe<Tenant_Active_Status_Reason_Mutation_Response>>
  >;
  /** update single row of the table: "tenant" */
  update_tenant_by_pk?: Maybe<Tenant>;
  /** update data of the table: "tenant_group" */
  update_tenant_group?: Maybe<Tenant_Group_Mutation_Response>;
  /** update single row of the table: "tenant_group" */
  update_tenant_group_by_pk?: Maybe<Tenant_Group>;
  /** update multiples rows of table: "tenant_group" */
  update_tenant_group_many?: Maybe<
    Array<Maybe<Tenant_Group_Mutation_Response>>
  >;
  /** update data of the table: "tenant_group_member" */
  update_tenant_group_member?: Maybe<Tenant_Group_Member_Mutation_Response>;
  /** update single row of the table: "tenant_group_member" */
  update_tenant_group_member_by_pk?: Maybe<Tenant_Group_Member>;
  /** update multiples rows of table: "tenant_group_member" */
  update_tenant_group_member_many?: Maybe<
    Array<Maybe<Tenant_Group_Member_Mutation_Response>>
  >;
  /** update multiples rows of table: "tenant" */
  update_tenant_many?: Maybe<Array<Maybe<Tenant_Mutation_Response>>>;
  /** update data of the table: "tenant_public_status" */
  update_tenant_public_status?: Maybe<Tenant_Public_Status_Mutation_Response>;
  /** update single row of the table: "tenant_public_status" */
  update_tenant_public_status_by_pk?: Maybe<Tenant_Public_Status>;
  /** update multiples rows of table: "tenant_public_status" */
  update_tenant_public_status_many?: Maybe<
    Array<Maybe<Tenant_Public_Status_Mutation_Response>>
  >;
  /** update data of the table: "tenant_status" */
  update_tenant_status?: Maybe<Tenant_Status_Mutation_Response>;
  /** update single row of the table: "tenant_status" */
  update_tenant_status_by_pk?: Maybe<Tenant_Status>;
  /** update multiples rows of table: "tenant_status" */
  update_tenant_status_many?: Maybe<
    Array<Maybe<Tenant_Status_Mutation_Response>>
  >;
  /** update data of the table: "trial_leads" */
  update_trial_leads?: Maybe<Trial_Leads_Mutation_Response>;
  /** update single row of the table: "trial_leads" */
  update_trial_leads_by_pk?: Maybe<Trial_Leads>;
  /** update multiples rows of table: "trial_leads" */
  update_trial_leads_many?: Maybe<Array<Maybe<Trial_Leads_Mutation_Response>>>;
  /** update data of the table: "ua_audit_logs" */
  update_ua_audit_logs?: Maybe<Ua_Audit_Logs_Mutation_Response>;
  /** update single row of the table: "ua_audit_logs" */
  update_ua_audit_logs_by_pk?: Maybe<Ua_Audit_Logs>;
  /** update multiples rows of table: "ua_audit_logs" */
  update_ua_audit_logs_many?: Maybe<
    Array<Maybe<Ua_Audit_Logs_Mutation_Response>>
  >;
  /** update data of the table: "user_activity" */
  update_user_activity?: Maybe<User_Activity_Mutation_Response>;
  /** update single row of the table: "user_activity" */
  update_user_activity_by_pk?: Maybe<User_Activity>;
  /** update multiples rows of table: "user_activity" */
  update_user_activity_many?: Maybe<
    Array<Maybe<User_Activity_Mutation_Response>>
  >;
  /** update data of the table: "user_coupon" */
  update_user_coupon?: Maybe<User_Coupon_Mutation_Response>;
  /** update single row of the table: "user_coupon" */
  update_user_coupon_by_pk?: Maybe<User_Coupon>;
  /** update multiples rows of table: "user_coupon" */
  update_user_coupon_many?: Maybe<Array<Maybe<User_Coupon_Mutation_Response>>>;
  /** update data of the table: "user_entitlement_access" */
  update_user_entitlement_access?: Maybe<User_Entitlement_Access_Mutation_Response>;
  /** update single row of the table: "user_entitlement_access" */
  update_user_entitlement_access_by_pk?: Maybe<User_Entitlement_Access>;
  /** update multiples rows of table: "user_entitlement_access" */
  update_user_entitlement_access_many?: Maybe<
    Array<Maybe<User_Entitlement_Access_Mutation_Response>>
  >;
  /** update data of the table: "user_entitlement_catalogue" */
  update_user_entitlement_catalogue?: Maybe<User_Entitlement_Catalogue_Mutation_Response>;
  /** update single row of the table: "user_entitlement_catalogue" */
  update_user_entitlement_catalogue_by_pk?: Maybe<User_Entitlement_Catalogue>;
  /** update multiples rows of table: "user_entitlement_catalogue" */
  update_user_entitlement_catalogue_many?: Maybe<
    Array<Maybe<User_Entitlement_Catalogue_Mutation_Response>>
  >;
  /** update data of the table: "user_entitlement_types" */
  update_user_entitlement_types?: Maybe<User_Entitlement_Types_Mutation_Response>;
  /** update single row of the table: "user_entitlement_types" */
  update_user_entitlement_types_by_pk?: Maybe<User_Entitlement_Types>;
  /** update multiples rows of table: "user_entitlement_types" */
  update_user_entitlement_types_many?: Maybe<
    Array<Maybe<User_Entitlement_Types_Mutation_Response>>
  >;
  /** update data of the table: "user_onboarding" */
  update_user_onboarding?: Maybe<User_Onboarding_Mutation_Response>;
  /** update single row of the table: "user_onboarding" */
  update_user_onboarding_by_pk?: Maybe<User_Onboarding>;
  /** update multiples rows of table: "user_onboarding" */
  update_user_onboarding_many?: Maybe<
    Array<Maybe<User_Onboarding_Mutation_Response>>
  >;
  /** update data of the table: "user_personal_access_tokens" */
  update_user_personal_access_tokens?: Maybe<User_Personal_Access_Tokens_Mutation_Response>;
  /** update single row of the table: "user_personal_access_tokens" */
  update_user_personal_access_tokens_by_pk?: Maybe<User_Personal_Access_Tokens>;
  /** update multiples rows of table: "user_personal_access_tokens" */
  update_user_personal_access_tokens_many?: Maybe<
    Array<Maybe<User_Personal_Access_Tokens_Mutation_Response>>
  >;
  /** update data of the table: "user_profile" */
  update_user_profile?: Maybe<User_Profile_Mutation_Response>;
  /** update single row of the table: "user_profile" */
  update_user_profile_by_pk?: Maybe<User_Profile>;
  /** update multiples rows of table: "user_profile" */
  update_user_profile_many?: Maybe<
    Array<Maybe<User_Profile_Mutation_Response>>
  >;
  /** update data of the table: "user_roles" */
  update_user_roles?: Maybe<User_Roles_Mutation_Response>;
  /** update single row of the table: "user_roles" */
  update_user_roles_by_pk?: Maybe<User_Roles>;
  /** update multiples rows of table: "user_roles" */
  update_user_roles_many?: Maybe<Array<Maybe<User_Roles_Mutation_Response>>>;
  /** update data of the table: "user_vpc_policy" */
  update_user_vpc_policy?: Maybe<User_Vpc_Policy_Mutation_Response>;
  /** update single row of the table: "user_vpc_policy" */
  update_user_vpc_policy_by_pk?: Maybe<User_Vpc_Policy>;
  /** update multiples rows of table: "user_vpc_policy" */
  update_user_vpc_policy_many?: Maybe<
    Array<Maybe<User_Vpc_Policy_Mutation_Response>>
  >;
  /** update data of the table: "users" */
  update_users?: Maybe<Users_Mutation_Response>;
  /** update single row of the table: "users" */
  update_users_by_pk?: Maybe<Users>;
  /** update multiples rows of table: "users" */
  update_users_many?: Maybe<Array<Maybe<Users_Mutation_Response>>>;
  /** update data of the table: "users_public" */
  update_users_public?: Maybe<Users_Public_Mutation_Response>;
  /** update multiples rows of table: "users_public" */
  update_users_public_many?: Maybe<
    Array<Maybe<Users_Public_Mutation_Response>>
  >;
  /** update data of the table: "vercel_integration" */
  update_vercel_integration?: Maybe<Vercel_Integration_Mutation_Response>;
  /** update single row of the table: "vercel_integration" */
  update_vercel_integration_by_pk?: Maybe<Vercel_Integration>;
  /** update data of the table: "vercel_integration_connections" */
  update_vercel_integration_connections?: Maybe<Vercel_Integration_Connections_Mutation_Response>;
  /** update single row of the table: "vercel_integration_connections" */
  update_vercel_integration_connections_by_pk?: Maybe<Vercel_Integration_Connections>;
  /** update multiples rows of table: "vercel_integration_connections" */
  update_vercel_integration_connections_many?: Maybe<
    Array<Maybe<Vercel_Integration_Connections_Mutation_Response>>
  >;
  /** update multiples rows of table: "vercel_integration" */
  update_vercel_integration_many?: Maybe<
    Array<Maybe<Vercel_Integration_Mutation_Response>>
  >;
  /** update data of the table: "vpc_peering" */
  update_vpc_peering?: Maybe<Vpc_Peering_Mutation_Response>;
  /** update single row of the table: "vpc_peering" */
  update_vpc_peering_by_pk?: Maybe<Vpc_Peering>;
  /** update data of the table: "vpc_peering_direction" */
  update_vpc_peering_direction?: Maybe<Vpc_Peering_Direction_Mutation_Response>;
  /** update single row of the table: "vpc_peering_direction" */
  update_vpc_peering_direction_by_pk?: Maybe<Vpc_Peering_Direction>;
  /** update multiples rows of table: "vpc_peering_direction" */
  update_vpc_peering_direction_many?: Maybe<
    Array<Maybe<Vpc_Peering_Direction_Mutation_Response>>
  >;
  /** update multiples rows of table: "vpc_peering" */
  update_vpc_peering_many?: Maybe<Array<Maybe<Vpc_Peering_Mutation_Response>>>;
  /** update data of the table: "vpc_status" */
  update_vpc_status?: Maybe<Vpc_Status_Mutation_Response>;
  /** update single row of the table: "vpc_status" */
  update_vpc_status_by_pk?: Maybe<Vpc_Status>;
  /** update multiples rows of table: "vpc_status" */
  update_vpc_status_many?: Maybe<Array<Maybe<Vpc_Status_Mutation_Response>>>;
  /** update data of the table: "zendesk_support_category" */
  update_zendesk_support_category?: Maybe<Zendesk_Support_Category_Mutation_Response>;
  /** update single row of the table: "zendesk_support_category" */
  update_zendesk_support_category_by_pk?: Maybe<Zendesk_Support_Category>;
  /** update multiples rows of table: "zendesk_support_category" */
  update_zendesk_support_category_many?: Maybe<
    Array<Maybe<Zendesk_Support_Category_Mutation_Response>>
  >;
  /** update data of the table: "zendesk_support_tickets" */
  update_zendesk_support_tickets?: Maybe<Zendesk_Support_Tickets_Mutation_Response>;
  /** update single row of the table: "zendesk_support_tickets" */
  update_zendesk_support_tickets_by_pk?: Maybe<Zendesk_Support_Tickets>;
  /** update multiples rows of table: "zendesk_support_tickets" */
  update_zendesk_support_tickets_many?: Maybe<
    Array<Maybe<Zendesk_Support_Tickets_Mutation_Response>>
  >;
  updateAzureMonitorConfig?: Maybe<AzureMonitorConfigResponse>;
  updateBillingManager?: Maybe<UpdateBillingManagerResponse>;
  updateDatadogConfig?: Maybe<DatadogConfigResponse>;
  updateGithubIntegration?: Maybe<UpdateGithubIntegrationStatus>;
  updateNewrelicConfig?: Maybe<NewrelicConfigResponse>;
  /** Update the OpenTelemetry Integration Configuration */
  updateOpentelemetryConfig?: Maybe<OpentelemetryConfigResponse>;
  /** Refreshes the Access token for the configured Prometheus Integration */
  updatePrometheusAccessToken: PrometheusConfigResponse;
  /** Update the Prometheus Integration Configuration */
  updatePrometheusConfig: PrometheusConfigResponse;
  updateServerEndpoint: UpdateServerEndpointResponse;
  updateTenantEnv?: Maybe<TenantEnv>;
  updateTenantName?: Maybe<UpdateTenantNameResponse>;
  /** Marks the tenant status and reason for deactivation/activation. Only available for data service admins. */
  updateTenantStatus?: Maybe<UpdateTenantStatusResponse>;
  /** Setup/Update Vercel integration */
  vercelSetIntegration?: Maybe<SetVercelIntegrationOutput>;
  vercelTokenExchange?: Maybe<SuccessOrError>;
};

/** mutation root */
export type Mutation_RootAcceptBillingManagerInviteArgs = {
  key: Scalars['String'];
};

/** mutation root */
export type Mutation_RootAcceptInviteArgs = {
  inviteKey: Scalars['String'];
};

/** mutation root */
export type Mutation_RootAcceptTransferOwnershipInviteArgs = {
  inviteKey: Scalars['String'];
};

/** mutation root */
export type Mutation_RootAddAzureMonitorConfigArgs = {
  activedirectory_client_id: Scalars['String'];
  activedirectory_client_secret: Scalars['String'];
  activedirectory_tenant_id: Scalars['String'];
  attributes?: Maybe<Scalars['jsonb']>;
  azure_region: Scalars['String'];
  azuremonitor_workspace_id: Scalars['String'];
  instrumentation_key?: Maybe<Scalars['String']>;
  log_type: Scalars['String'];
  metric_namespace: Scalars['String'];
  project_id: Scalars['uuid'];
  resource_id: Scalars['String'];
  shared_key: Scalars['String'];
};

/** mutation root */
export type Mutation_RootAddCardArgs = {
  id: Scalars['String'];
  is_default: Scalars['Boolean'];
};

/** mutation root */
export type Mutation_RootAddCustomDomainArgs = {
  fqdn: Scalars['String'];
  tenant_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootAddDatadogConfigArgs = {
  datadog_region: Scalars['String'];
  host?: Maybe<Scalars['String']>;
  key: Scalars['String'];
  project_id: Scalars['uuid'];
  service_name?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
};

/** mutation root */
export type Mutation_RootAddFeatureRequestArgs = {
  payload: FeatureRequest;
};

/** mutation root */
export type Mutation_RootAddNewrelicConfigArgs = {
  attributes: Scalars['jsonb'];
  key: Scalars['String'];
  newrelic_region: Scalars['String'];
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootAddOpentelemetryConfigArgs = {
  attributes?: Maybe<Scalars['jsonb']>;
  batch_size?: Maybe<Scalars['Int']>;
  connection_type: Scalars['String'];
  endpoint: Scalars['String'];
  export_traces?: Maybe<Scalars['Boolean']>;
  headers?: Maybe<Scalars['jsonb']>;
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootAddProjectArgs = {
  project: AddProjectInput;
};

/** mutation root */
export type Mutation_RootAddPrometheusConfigArgs = {
  labels?: Maybe<Scalars['jsonb']>;
  namespace?: Maybe<Scalars['String']>;
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootApplyCouponCodeArgs = {
  coupon: Scalars['String'];
};

/** mutation root */
export type Mutation_RootChangePlanArgs = {
  plan: Plan;
  projectId: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootChangeUserEmailArgs = {
  input: ChangeUserEmailRequestInput;
};

/** mutation root */
export type Mutation_RootCheckDbLatencyArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootCompleteChangeUserEmailRequestArgs = {
  input: ChangeUserEmailRequestKeyInput;
};

/** mutation root */
export type Mutation_RootConnector_Delete_Connector_DeploymentArgs = {
  where: Connector_Connector_Deployment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootConnector_Delete_Connector_Deployment_By_PkArgs = {
  id: Scalars['connector_uuid'];
};

/** mutation root */
export type Mutation_RootConnector_Insert_Connector_DeploymentArgs = {
  objects: Array<Connector_Connector_Deployment_Insert_Input>;
  on_conflict?: Maybe<Connector_Connector_Deployment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootConnector_Insert_Connector_Deployment_OneArgs = {
  object: Connector_Connector_Deployment_Insert_Input;
  on_conflict?: Maybe<Connector_Connector_Deployment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootConnector_Update_Connector_DeploymentArgs = {
  _set?: Maybe<Connector_Connector_Deployment_Set_Input>;
  where: Connector_Connector_Deployment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootConnector_Update_Connector_Deployment_By_PkArgs = {
  _set?: Maybe<Connector_Connector_Deployment_Set_Input>;
  pk_columns: Connector_Connector_Deployment_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootConnector_Update_Connector_Deployment_ManyArgs = {
  updates: Array<Connector_Connector_Deployment_Updates>;
};

/** mutation root */
export type Mutation_RootConvertToDedicatedCloudArgs = {
  projectId: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootCreateDedicatedVpcArgs = {
  cidr: Scalars['String'];
  cloud: Scalars['String'];
  name: Scalars['String'];
  region: Scalars['String'];
};

/** mutation root */
export type Mutation_RootCreateGithubIntegrationArgs = {
  payload: GithubIntegrationInput;
};

/** mutation root */
export type Mutation_RootCreateGitHubPreviewAppArgs = {
  payload?: Maybe<CreateGithubPreviewAppInputPayload>;
};

/** mutation root */
export type Mutation_RootCreateInvoiceArgs = {
  args?: Maybe<CreateInvoiceInput>;
};

/** mutation root */
export type Mutation_RootCreateJobArgs = {
  input: CreateJobInput;
};

/** mutation root */
export type Mutation_RootCreateOneClickDeploymentArgs = {
  payload: CreateOneClickDeploymentInputPayload;
};

/** mutation root */
export type Mutation_RootCreatePersonalAccessTokenArgs = {
  token: PersonalAccessTokenInput;
};

/** mutation root */
export type Mutation_RootCreateTenantArgs = {
  cloud: Scalars['String'];
  dedicatedVPCID?: Maybe<Scalars['String']>;
  envs?: Maybe<Array<Maybe<UpdateEnvsObject>>>;
  name?: Maybe<Scalars['String']>;
  plan?: Maybe<Scalars['String']>;
  projectMetadata?: Maybe<ProjectMiscMetadata>;
  region: Scalars['String'];
};

/** mutation root */
export type Mutation_RootCreateZendeskSupportTicketArgs = {
  body: Scalars['String'];
  priority?: Maybe<SupportTicketPriority>;
  project_id?: Maybe<Scalars['uuid']>;
  subject: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDeclineBillingManagerInviteArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDeclineInviteArgs = {
  inviteKey: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDeclineTransferOwnershipInviteArgs = {
  inviteKey: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Alert_ConfigArgs = {
  where: Alert_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Alert_Config_Alert_TypeArgs = {
  where: Alert_Config_Alert_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Alert_Config_Alert_Type_By_PkArgs = {
  project_id: Scalars['uuid'];
  type: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Alert_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Alert_Config_ServiceArgs = {
  where: Alert_Config_Service_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Alert_Config_Service_By_PkArgs = {
  project_id: Scalars['uuid'];
  type: Alert_Service_Type_Enum;
};

/** mutation root */
export type Mutation_RootDelete_Alert_Service_TypeArgs = {
  where: Alert_Service_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Alert_Service_Type_By_PkArgs = {
  name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Alert_TypeArgs = {
  where: Alert_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Alert_Type_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Azuremonitor_ConfigArgs = {
  where: Azuremonitor_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Azuremonitor_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Billing_AddressArgs = {
  where: Billing_Address_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Billing_Address_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Central_CloudArgs = {
  where: Central_Cloud_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Central_Cloud_By_PkArgs = {
  cloud: Cloud_Enum;
};

/** mutation root */
export type Mutation_RootDelete_Change_Email_RequestArgs = {
  where: Change_Email_Request_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Change_Email_Request_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Cicd_Deployment_Pipeline_ConfigArgs = {
  where: Cicd_Deployment_Pipeline_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Cicd_Deployment_Pipeline_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Cicd_Deployment_PoolArgs = {
  where: Cicd_Deployment_Pool_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Cicd_Deployment_Pool_MemberArgs = {
  where: Cicd_Deployment_Pool_Member_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_CloudArgs = {
  where: Cloud_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Cloud_By_PkArgs = {
  name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Cloud_MetadataArgs = {
  where: Cloud_Metadata_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Cloud_Metadata_By_PkArgs = {
  cloud: Cloud_Enum;
};

/** mutation root */
export type Mutation_RootDelete_Compute_Unit_ConfigArgs = {
  where: Compute_Unit_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Compute_Unit_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_ConfigArgs = {
  where: Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Config_By_PkArgs = {
  tenant_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Config_StatusArgs = {
  where: Config_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Config_Status_By_PkArgs = {
  hash: Scalars['String'];
  tenant_id: Scalars['uuid'];
  worker_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Connector_ConfigArgs = {
  where: Connector_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Connector_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Connector_DeploymentsArgs = {
  where: Connector_Deployments_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Connector_Deployments_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_CouponArgs = {
  where: Coupon_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Coupon_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Coupon_DurationArgs = {
  where: Coupon_Duration_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Coupon_Duration_By_PkArgs = {
  duration: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Coupon_TypeArgs = {
  where: Coupon_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Coupon_Type_By_PkArgs = {
  type: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Custom_DomainArgs = {
  where: Custom_Domain_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Custom_Domain_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Custom_Domain_CloudflareArgs = {
  where: Custom_Domain_Cloudflare_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Custom_Domain_Cloudflare_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Custom_Domain_Cloudflare_DnsArgs = {
  where: Custom_Domain_Cloudflare_Dns_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Custom_Domain_Cloudflare_Dns_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Customer_UsageArgs = {
  where: Customer_Usage_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Customer_Usage_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Data_Connector_TypeArgs = {
  where: Data_Connector_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Data_Connector_Type_By_PkArgs = {
  name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Datadog_ConfigArgs = {
  where: Datadog_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Datadog_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Db_LatencyArgs = {
  where: Db_Latency_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Db_Latency_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Ddn_BuildArgs = {
  where: Ddn_Build_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Build_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Build_Sync_StatusArgs = {
  where: Ddn_Build_Sync_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Build_Sync_Status_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Build_Sync_WorkerArgs = {
  where: Ddn_Build_Sync_Worker_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Build_Sync_Worker_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Ddn_EnvironmentArgs = {
  where: Ddn_Environment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Environment_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Project_Entitlement_AccessArgs = {
  where: Ddn_Project_Entitlement_Access_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Project_Entitlement_Access_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Project_Entitlement_CatalogueArgs = {
  where: Ddn_Project_Entitlement_Catalogue_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Project_Entitlement_Catalogue_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Project_Entitlement_TypesArgs = {
  where: Ddn_Project_Entitlement_Types_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Project_Entitlement_Types_By_PkArgs = {
  value: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Ddn_ProjectsArgs = {
  where: Ddn_Projects_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Projects_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Ddn_TunnelArgs = {
  where: Ddn_Tunnel_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Tunnel_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Tunnel_ClusterArgs = {
  where: Ddn_Tunnel_Cluster_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Ddn_Tunnel_Cluster_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Dedicated_Cloud_BillsArgs = {
  where: Dedicated_Cloud_Bills_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dedicated_Cloud_Bills_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Dedicated_Cloud_Bills_DetailsArgs = {
  where: Dedicated_Cloud_Bills_Details_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dedicated_Cloud_Bills_Details_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Dedicated_Cloud_CommitmentsArgs = {
  where: Dedicated_Cloud_Commitments_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dedicated_Cloud_Commitments_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Dedicated_VpcArgs = {
  where: Dedicated_Vpc_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Dedicated_Vpc_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Delete_UserArgs = {
  where: Delete_User_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Delete_User_By_PkArgs = {
  user_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Delete_User_StatusArgs = {
  where: Delete_User_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Delete_User_Status_By_PkArgs = {
  status: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Delete_User_TasksArgs = {
  where: Delete_User_Tasks_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Delete_User_Tasks_By_PkArgs = {
  task_name: Scalars['String'];
  user_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Email_LogArgs = {
  where: Email_Log_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Email_Log_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Enterprise_UsersArgs = {
  where: Enterprise_Users_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Enterprise_Users_By_PkArgs = {
  customer_email: Scalars['citext'];
};

/** mutation root */
export type Mutation_RootDelete_ExperimentsArgs = {
  where: Experiments_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Experiments_By_PkArgs = {
  experiment: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Experiments_CohortArgs = {
  where: Experiments_Cohort_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Experiments_Cohort_By_PkArgs = {
  experiment: Experiments_Enum;
  user_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Experiments_ConfigArgs = {
  where: Experiments_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Experiments_Config_By_PkArgs = {
  experiment: Experiments_Enum;
};

/** mutation root */
export type Mutation_RootDelete_FeatureArgs = {
  where: Feature_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Feature_AccessArgs = {
  where: Feature_Access_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Feature_Access_By_PkArgs = {
  email: Scalars['String'];
  feature: Feature_Enum;
};

/** mutation root */
export type Mutation_RootDelete_Feature_By_PkArgs = {
  name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Feature_ConfigArgs = {
  where: Feature_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Feature_Config_By_PkArgs = {
  feature: Feature_Enum;
};

/** mutation root */
export type Mutation_RootDelete_Gateway_AmiArgs = {
  where: Gateway_Ami_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Gateway_Ami_By_PkArgs = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Gateway_ClusterArgs = {
  where: Gateway_Cluster_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Gateway_Cluster_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Gateway_WorkerArgs = {
  where: Gateway_Worker_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Gateway_Worker_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Github_Email_TypeArgs = {
  where: Github_Email_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Github_Email_Type_By_PkArgs = {
  email_type: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Github_Integration_ConfigArgs = {
  where: Github_Integration_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Github_Integration_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Github_Integration_ModeArgs = {
  where: Github_Integration_Mode_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Github_Integration_Mode_By_PkArgs = {
  mode: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Github_Push_EventArgs = {
  where: Github_Push_Event_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Github_Push_Event_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Github_Push_Event_JobArgs = {
  where: Github_Push_Event_Job_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Github_Push_Event_Job_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Hasura_AmiArgs = {
  where: Hasura_Ami_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Hasura_Ami_By_PkArgs = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Hasura_ClusterArgs = {
  where: Hasura_Cluster_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Hasura_Cluster_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Hasura_WorkerArgs = {
  where: Hasura_Worker_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Hasura_Worker_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Heroku_IntegrationsArgs = {
  where: Heroku_Integrations_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Heroku_Integrations_By_PkArgs = {
  project_id: Scalars['uuid'];
  var_name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Inactive_Project_ExclusionsArgs = {
  where: Inactive_Project_Exclusions_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Inactive_Project_Exclusions_By_PkArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Inactive_Project_NotificationsArgs = {
  where: Inactive_Project_Notifications_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Inactive_Project_Notifications_By_PkArgs = {
  id: Scalars['Int'];
};

/** mutation root */
export type Mutation_RootDelete_Inactive_Project_Suspension_ConfigArgs = {
  where: Inactive_Project_Suspension_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Infra_StatusArgs = {
  where: Infra_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Infra_Status_By_PkArgs = {
  status: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_InvoiceArgs = {
  where: Invoice_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Invoice_By_PkArgs = {
  stripe_invoice_id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Invoice_Coupon_DiscountArgs = {
  where: Invoice_Coupon_Discount_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Invoice_Coupon_Discount_By_PkArgs = {
  inv_id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Invoice_ItemArgs = {
  where: Invoice_Item_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Invoice_Item_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_JobsArgs = {
  where: Jobs_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Jobs_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_LabelArgs = {
  where: Label_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Label_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Letsencrypt_StatusArgs = {
  where: Letsencrypt_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Letsencrypt_Status_By_PkArgs = {
  fqdn: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_License_ActivityArgs = {
  where: License_Activity_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_License_Activity_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_License_InstanceArgs = {
  where: License_Instance_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_License_Instance_By_PkArgs = {
  metadata_db_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_License_TypeArgs = {
  where: License_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_License_Type_By_PkArgs = {
  name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_LicensesArgs = {
  where: Licenses_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Licenses_By_PkArgs = {
  email: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Lux_ProxyArgs = {
  where: Lux_Proxy_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Lux_Proxy_AmiArgs = {
  where: Lux_Proxy_Ami_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Lux_Proxy_Ami_By_PkArgs = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Lux_Proxy_By_PkArgs = {
  cloud: Scalars['String'];
  region: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Neon_Db_IntegrationArgs = {
  where: Neon_Db_Integration_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Neon_Db_Integration_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Newrelic_ConfigArgs = {
  where: Newrelic_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Newrelic_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Node_Pool_TypeArgs = {
  where: Node_Pool_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Node_Pool_Type_By_PkArgs = {
  name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Node_PoolsArgs = {
  where: Node_Pools_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Node_Pools_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_NotificationArgs = {
  where: Notification_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Notification_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Notification_TypeArgs = {
  where: Notification_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Notification_Type_By_PkArgs = {
  type: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Onboarding_Sample_Db_CohortArgs = {
  where: Onboarding_Sample_Db_Cohort_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Onboarding_Sample_Db_Cohort_By_PkArgs = {
  user_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Onboarding_Sample_Db_ConfigArgs = {
  where: Onboarding_Sample_Db_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Onboarding_Sample_Db_Config_By_PkArgs = {
  created_at: Scalars['timestamptz'];
};

/** mutation root */
export type Mutation_RootDelete_One_Click_DeploymentArgs = {
  where: One_Click_Deployment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_One_Click_Deployment_By_PkArgs = {
  id: Scalars['bigint'];
};

/** mutation root */
export type Mutation_RootDelete_One_Click_Deployment_Sample_AppsArgs = {
  where: One_Click_Deployment_Sample_Apps_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_One_Click_Deployment_Sample_Apps_By_PkArgs = {
  git_repository_branch: Scalars['String'];
  git_repository_url: Scalars['String'];
  hasura_directory: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_One_Click_Deployment_State_LogArgs = {
  where: One_Click_Deployment_State_Log_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_One_Click_Deployment_State_Log_By_PkArgs = {
  id: Scalars['bigint'];
};

/** mutation root */
export type Mutation_RootDelete_One_Click_Deployment_StatesArgs = {
  where: One_Click_Deployment_States_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_One_Click_Deployment_States_By_PkArgs = {
  name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Opentelemetry_ConfigArgs = {
  where: Opentelemetry_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Opentelemetry_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Operations_Delete_Free_Plan_Dns_Records_Nov_2021Args =
  {
    where: Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp;
  };

/** mutation root */
export type Mutation_RootDelete_Operations_Delete_Free_Plan_Dns_Records_Nov_2021_By_PkArgs =
  {
    tenant_id: Scalars['uuid'];
  };

/** mutation root */
export type Mutation_RootDelete_Operations_TenantArgs = {
  where: Operations_Tenant_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Payment_MethodArgs = {
  where: Payment_Method_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Payment_Method_By_PkArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Plan_EntitlementsArgs = {
  where: Plan_Entitlements_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Plan_Entitlements_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_PlansArgs = {
  where: Plans_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Plans_By_PkArgs = {
  name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_PoliciesArgs = {
  where: Policies_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Policies_By_PkArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_PrivilegesArgs = {
  where: Privileges_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Privileges_By_PkArgs = {
  slug: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Pro_License_KeysArgs = {
  where: Pro_License_Keys_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Pro_License_Keys_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_ActivityArgs = {
  where: Project_Activity_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Activity_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_Billing_Manager_InvitationsArgs = {
  where: Project_Billing_Manager_Invitations_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Billing_Manager_Invitations_By_PkArgs =
  {
    id: Scalars['uuid'];
  };

/** mutation root */
export type Mutation_RootDelete_Project_Collaborator_Allowed_Schema_TablesArgs =
  {
    where: Project_Collaborator_Allowed_Schema_Tables_Bool_Exp;
  };

/** mutation root */
export type Mutation_RootDelete_Project_Collaborator_Allowed_Schema_Tables_By_PkArgs =
  {
    project_collaborator_id: Scalars['uuid'];
    schema: Scalars['String'];
    table_name: Scalars['String'];
  };

/** mutation root */
export type Mutation_RootDelete_Project_Collaborator_Allowed_SchemasArgs = {
  where: Project_Collaborator_Allowed_Schemas_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Collaborator_Allowed_Schemas_By_PkArgs =
  {
    project_collaborator_id: Scalars['uuid'];
    schema: Scalars['String'];
  };

/** mutation root */
export type Mutation_RootDelete_Project_Collaborator_InvitationsArgs = {
  where: Project_Collaborator_Invitations_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Collaborator_Invitations_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_Collaborator_PrivilegesArgs = {
  where: Project_Collaborator_Privileges_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Collaborator_Privileges_By_PkArgs = {
  privilege_slug: Scalars['String'];
  project_collaborator_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_CollaboratorsArgs = {
  where: Project_Collaborators_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Collaborators_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_Data_UsageArgs = {
  where: Project_Data_Usage_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Data_Usage_AggArgs = {
  where: Project_Data_Usage_Agg_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Data_Usage_Agg_UserArgs = {
  where: Project_Data_Usage_Agg_User_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Data_Usage_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_Data_Usage_ComponentsArgs = {
  where: Project_Data_Usage_Components_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Data_Usage_PrometheusArgs = {
  where: Project_Data_Usage_Prometheus_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Data_Usage_Prometheus_Agg_UserArgs = {
  where: Project_Data_Usage_Prometheus_Agg_User_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Data_Usage_Prometheus_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_Data_Usage_ReportArgs = {
  where: Project_Data_Usage_Report_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Data_Usage_Report_By_PkArgs = {
  project_id: Scalars['uuid'];
  report_date: Scalars['date'];
};

/** mutation root */
export type Mutation_RootDelete_Project_Db_UsageArgs = {
  where: Project_Db_Usage_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Db_Usage_Agg_UserArgs = {
  where: Project_Db_Usage_Agg_User_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Db_Usage_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_Entitlement_AccessArgs = {
  where: Project_Entitlement_Access_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Entitlement_Access_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_Entitlement_CatalogueArgs = {
  where: Project_Entitlement_Catalogue_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Entitlement_Catalogue_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_Entitlement_TypesArgs = {
  where: Project_Entitlement_Types_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Entitlement_Types_By_PkArgs = {
  value: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Project_LabelsArgs = {
  where: Project_Labels_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Labels_By_PkArgs = {
  label_id: Scalars['uuid'];
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_MetadataArgs = {
  where: Project_Metadata_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Metadata_By_PkArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_NotificationArgs = {
  where: Project_Notification_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Notification_By_PkArgs = {
  month: Scalars['Int'];
  project_id: Scalars['uuid'];
  type: Scalars['reminder_type_enum'];
  year: Scalars['Int'];
};

/** mutation root */
export type Mutation_RootDelete_Project_Ownership_Transfer_InvitationsArgs = {
  where: Project_Ownership_Transfer_Invitations_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Ownership_Transfer_Invitations_By_PkArgs =
  {
    id: Scalars['uuid'];
  };

/** mutation root */
export type Mutation_RootDelete_Project_Requests_CountArgs = {
  where: Project_Requests_Count_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Requests_Count_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_StatsArgs = {
  where: Project_Stats_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Project_Stats_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Project_Total_Db_Usage_AggArgs = {
  where: Project_Total_Db_Usage_Agg_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_ProjectsArgs = {
  where: Projects_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Projects_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Projects_Pool_ConfigArgs = {
  where: Projects_Pool_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Projects_Pool_Config_By_PkArgs = {
  cloud: Scalars['String'];
  plan_name: Scalars['String'];
  region: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Projects_Pro_Key_GenerationsArgs = {
  where: Projects_Pro_Key_Generations_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Projects_Pro_Key_Generations_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Prometheus_ConfigArgs = {
  where: Prometheus_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Prometheus_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_ProvidersArgs = {
  where: Providers_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Providers_By_PkArgs = {
  id: Scalars['Int'];
};

/** mutation root */
export type Mutation_RootDelete_ProvisioningArgs = {
  where: Provisioning_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Provisioning_By_PkArgs = {
  provisioning: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_RegionArgs = {
  where: Region_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Region_By_PkArgs = {
  cloud: Cloud_Enum;
  name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Region_V2Args = {
  where: Region_V2_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Regional_Data_ConnectorsArgs = {
  where: Regional_Data_Connectors_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Regional_Data_Connectors_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Regional_MetricsArgs = {
  where: Regional_Metrics_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Regional_Metrics_By_PkArgs = {
  cloud: Scalars['String'];
  region: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Saml_IdpArgs = {
  where: Saml_Idp_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Saml_Idp_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Search_Project_Login_Status_ResultsArgs = {
  where: Search_Project_Login_Status_Results_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Slack_ConfigArgs = {
  where: Slack_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Slack_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Stripe_SubscriptionArgs = {
  where: Stripe_Subscription_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Stripe_Subscription_By_PkArgs = {
  customer_id: Scalars['String'];
  subscription_id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Stripe_Webhook_EventsArgs = {
  where: Stripe_Webhook_Events_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Stripe_Webhook_Events_By_PkArgs = {
  stripe_event_id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Super_Connector_TypesArgs = {
  where: Super_Connector_Types_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Super_Connector_Types_By_PkArgs = {
  type: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Support_Plan_TypesArgs = {
  where: Support_Plan_Types_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Support_Plan_Types_By_PkArgs = {
  value: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_SurveyArgs = {
  where: Survey_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_By_PkArgs = {
  survey_name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_QuestionArgs = {
  where: Survey_Question_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_Question_Answer_OptionArgs = {
  where: Survey_Question_Answer_Option_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_Question_Answer_Option_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_Question_AnswersArgs = {
  where: Survey_Question_Answers_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_Question_Answers_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_Question_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_Question_KindArgs = {
  where: Survey_Question_Kind_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_Question_Kind_By_PkArgs = {
  kind: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_Question_OptionsArgs = {
  where: Survey_Question_Options_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_Question_Options_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2Args = {
  where: Survey_V2_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_QuestionArgs = {
  where: Survey_V2_Question_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Question_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Question_KindArgs = {
  where: Survey_V2_Question_Kind_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Question_Kind_By_PkArgs = {
  kind: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Question_OptionArgs = {
  where: Survey_V2_Question_Option_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Question_Option_Additional_Info_ConfigArgs =
  {
    where: Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp;
  };

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Question_Option_Additional_Info_Config_By_PkArgs =
  {
    id: Scalars['uuid'];
  };

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Question_Option_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_ResponseArgs = {
  where: Survey_V2_Response_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Response_AnswerArgs = {
  where: Survey_V2_Response_Answer_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Response_Answer_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Response_Answer_OptionArgs = {
  where: Survey_V2_Response_Answer_Option_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Response_Answer_Option_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Survey_V2_Response_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Task_EventArgs = {
  where: Task_Event_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Task_Event_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_TasksArgs = {
  where: Tasks_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Tasks_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_TenantArgs = {
  where: Tenant_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Tenant_Active_Status_ReasonArgs = {
  where: Tenant_Active_Status_Reason_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Tenant_Active_Status_Reason_By_PkArgs = {
  name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Tenant_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Tenant_GroupArgs = {
  where: Tenant_Group_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Tenant_Group_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Tenant_Group_MemberArgs = {
  where: Tenant_Group_Member_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Tenant_Group_Member_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Tenant_Public_StatusArgs = {
  where: Tenant_Public_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Tenant_Public_Status_By_PkArgs = {
  endpoint: Scalars['String'];
  tenant_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Tenant_StatusArgs = {
  where: Tenant_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Tenant_Status_By_PkArgs = {
  tenant_id: Scalars['uuid'];
  worker_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Trial_LeadsArgs = {
  where: Trial_Leads_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Trial_Leads_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Ua_Audit_LogsArgs = {
  where: Ua_Audit_Logs_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Ua_Audit_Logs_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_User_ActivityArgs = {
  where: User_Activity_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_User_Activity_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_User_CouponArgs = {
  where: User_Coupon_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_User_Coupon_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_User_Entitlement_AccessArgs = {
  where: User_Entitlement_Access_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_User_Entitlement_Access_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_User_Entitlement_CatalogueArgs = {
  where: User_Entitlement_Catalogue_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_User_Entitlement_Catalogue_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_User_Entitlement_TypesArgs = {
  where: User_Entitlement_Types_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_User_Entitlement_Types_By_PkArgs = {
  value: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_User_OnboardingArgs = {
  where: User_Onboarding_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_User_Onboarding_By_PkArgs = {
  target: Scalars['String'];
  user_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_User_Personal_Access_TokensArgs = {
  where: User_Personal_Access_Tokens_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_User_Personal_Access_Tokens_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_User_ProfileArgs = {
  where: User_Profile_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_User_Profile_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_User_RolesArgs = {
  where: User_Roles_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_User_Roles_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_User_Vpc_PolicyArgs = {
  where: User_Vpc_Policy_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_User_Vpc_Policy_By_PkArgs = {
  id: Scalars['Int'];
};

/** mutation root */
export type Mutation_RootDelete_UsersArgs = {
  where: Users_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Users_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Users_PublicArgs = {
  where: Users_Public_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Vercel_IntegrationArgs = {
  where: Vercel_Integration_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Vercel_Integration_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Vercel_Integration_ConnectionsArgs = {
  where: Vercel_Integration_Connections_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Vercel_Integration_Connections_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Vpc_PeeringArgs = {
  where: Vpc_Peering_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Vpc_Peering_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDelete_Vpc_Peering_DirectionArgs = {
  where: Vpc_Peering_Direction_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Vpc_Peering_Direction_By_PkArgs = {
  direction: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Vpc_StatusArgs = {
  where: Vpc_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Vpc_Status_By_PkArgs = {
  status: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Zendesk_Support_CategoryArgs = {
  where: Zendesk_Support_Category_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Zendesk_Support_Category_By_PkArgs = {
  name: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDelete_Zendesk_Support_TicketsArgs = {
  where: Zendesk_Support_Tickets_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_Zendesk_Support_Tickets_By_PkArgs = {
  id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDeleteCardArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootDeleteProjectArgs = {
  project: DeleteProjectInput;
};

/** mutation root */
export type Mutation_RootDeleteSlackAppArgs = {
  args: DelteSlackAppPayload;
};

/** mutation root */
export type Mutation_RootDeleteTenantArgs = {
  tenantId: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDeleteTenantEnvArgs = {
  currentHash: Scalars['String'];
  deleteEnvs: Array<Scalars['String']>;
  tenantId: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootDeployLatestGithubCommitArgs = {
  payload: DeployLatestGithubCommitInput;
};

/** mutation root */
export type Mutation_RootEnableCloudflareProxyArgs = {
  tenant_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootGetGithubSessionArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootGithubTokenExchangeArgs = {
  code: Scalars['String'];
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootHerokuRegisterWebhookArgs = {
  appID: Scalars['String'];
  appName: Scalars['String'];
  projectID: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootHerokuRegisterWebhookVarArgs = {
  agent?: Maybe<ActionAgent>;
  appID: Scalars['String'];
  appName: Scalars['String'];
  projectID: Scalars['uuid'];
  varName: Scalars['String'];
};

/** mutation root */
export type Mutation_RootHerokuTokenExchangeArgs = {
  payload: HerokuTokenExchangeInput;
};

/** mutation root */
export type Mutation_RootHerokuUnregisterWebhookArgs = {
  projectID: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootHerokuUnregisterWebhookVarArgs = {
  projectID: Scalars['uuid'];
  varName: Scalars['String'];
};

/** mutation root */
export type Mutation_RootInsert_Alert_ConfigArgs = {
  objects: Array<Alert_Config_Insert_Input>;
  on_conflict?: Maybe<Alert_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Alert_Config_Alert_TypeArgs = {
  objects: Array<Alert_Config_Alert_Type_Insert_Input>;
  on_conflict?: Maybe<Alert_Config_Alert_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Alert_Config_Alert_Type_OneArgs = {
  object: Alert_Config_Alert_Type_Insert_Input;
  on_conflict?: Maybe<Alert_Config_Alert_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Alert_Config_OneArgs = {
  object: Alert_Config_Insert_Input;
  on_conflict?: Maybe<Alert_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Alert_Config_ServiceArgs = {
  objects: Array<Alert_Config_Service_Insert_Input>;
  on_conflict?: Maybe<Alert_Config_Service_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Alert_Config_Service_OneArgs = {
  object: Alert_Config_Service_Insert_Input;
  on_conflict?: Maybe<Alert_Config_Service_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Alert_Service_TypeArgs = {
  objects: Array<Alert_Service_Type_Insert_Input>;
  on_conflict?: Maybe<Alert_Service_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Alert_Service_Type_OneArgs = {
  object: Alert_Service_Type_Insert_Input;
  on_conflict?: Maybe<Alert_Service_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Alert_TypeArgs = {
  objects: Array<Alert_Type_Insert_Input>;
  on_conflict?: Maybe<Alert_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Alert_Type_OneArgs = {
  object: Alert_Type_Insert_Input;
  on_conflict?: Maybe<Alert_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Azuremonitor_ConfigArgs = {
  objects: Array<Azuremonitor_Config_Insert_Input>;
  on_conflict?: Maybe<Azuremonitor_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Azuremonitor_Config_OneArgs = {
  object: Azuremonitor_Config_Insert_Input;
  on_conflict?: Maybe<Azuremonitor_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Billing_AddressArgs = {
  objects: Array<Billing_Address_Insert_Input>;
  on_conflict?: Maybe<Billing_Address_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Billing_Address_OneArgs = {
  object: Billing_Address_Insert_Input;
  on_conflict?: Maybe<Billing_Address_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Central_CloudArgs = {
  objects: Array<Central_Cloud_Insert_Input>;
  on_conflict?: Maybe<Central_Cloud_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Central_Cloud_OneArgs = {
  object: Central_Cloud_Insert_Input;
  on_conflict?: Maybe<Central_Cloud_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Change_Email_RequestArgs = {
  objects: Array<Change_Email_Request_Insert_Input>;
  on_conflict?: Maybe<Change_Email_Request_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Change_Email_Request_OneArgs = {
  object: Change_Email_Request_Insert_Input;
  on_conflict?: Maybe<Change_Email_Request_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Cicd_Deployment_Pipeline_ConfigArgs = {
  objects: Array<Cicd_Deployment_Pipeline_Config_Insert_Input>;
  on_conflict?: Maybe<Cicd_Deployment_Pipeline_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Cicd_Deployment_Pipeline_Config_OneArgs = {
  object: Cicd_Deployment_Pipeline_Config_Insert_Input;
  on_conflict?: Maybe<Cicd_Deployment_Pipeline_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Cicd_Deployment_PoolArgs = {
  objects: Array<Cicd_Deployment_Pool_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Cicd_Deployment_Pool_MemberArgs = {
  objects: Array<Cicd_Deployment_Pool_Member_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Cicd_Deployment_Pool_Member_OneArgs = {
  object: Cicd_Deployment_Pool_Member_Insert_Input;
};

/** mutation root */
export type Mutation_RootInsert_Cicd_Deployment_Pool_OneArgs = {
  object: Cicd_Deployment_Pool_Insert_Input;
};

/** mutation root */
export type Mutation_RootInsert_CloudArgs = {
  objects: Array<Cloud_Insert_Input>;
  on_conflict?: Maybe<Cloud_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Cloud_MetadataArgs = {
  objects: Array<Cloud_Metadata_Insert_Input>;
  on_conflict?: Maybe<Cloud_Metadata_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Cloud_Metadata_OneArgs = {
  object: Cloud_Metadata_Insert_Input;
  on_conflict?: Maybe<Cloud_Metadata_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Cloud_OneArgs = {
  object: Cloud_Insert_Input;
  on_conflict?: Maybe<Cloud_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Compute_Unit_ConfigArgs = {
  objects: Array<Compute_Unit_Config_Insert_Input>;
  on_conflict?: Maybe<Compute_Unit_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Compute_Unit_Config_OneArgs = {
  object: Compute_Unit_Config_Insert_Input;
  on_conflict?: Maybe<Compute_Unit_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ConfigArgs = {
  objects: Array<Config_Insert_Input>;
  on_conflict?: Maybe<Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Config_OneArgs = {
  object: Config_Insert_Input;
  on_conflict?: Maybe<Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Config_StatusArgs = {
  objects: Array<Config_Status_Insert_Input>;
  on_conflict?: Maybe<Config_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Config_Status_OneArgs = {
  object: Config_Status_Insert_Input;
  on_conflict?: Maybe<Config_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Connector_ConfigArgs = {
  objects: Array<Connector_Config_Insert_Input>;
  on_conflict?: Maybe<Connector_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Connector_Config_OneArgs = {
  object: Connector_Config_Insert_Input;
  on_conflict?: Maybe<Connector_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Connector_DeploymentsArgs = {
  objects: Array<Connector_Deployments_Insert_Input>;
  on_conflict?: Maybe<Connector_Deployments_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Connector_Deployments_OneArgs = {
  object: Connector_Deployments_Insert_Input;
  on_conflict?: Maybe<Connector_Deployments_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_CouponArgs = {
  objects: Array<Coupon_Insert_Input>;
  on_conflict?: Maybe<Coupon_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Coupon_DurationArgs = {
  objects: Array<Coupon_Duration_Insert_Input>;
  on_conflict?: Maybe<Coupon_Duration_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Coupon_Duration_OneArgs = {
  object: Coupon_Duration_Insert_Input;
  on_conflict?: Maybe<Coupon_Duration_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Coupon_OneArgs = {
  object: Coupon_Insert_Input;
  on_conflict?: Maybe<Coupon_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Coupon_TypeArgs = {
  objects: Array<Coupon_Type_Insert_Input>;
  on_conflict?: Maybe<Coupon_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Coupon_Type_OneArgs = {
  object: Coupon_Type_Insert_Input;
  on_conflict?: Maybe<Coupon_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Custom_DomainArgs = {
  objects: Array<Custom_Domain_Insert_Input>;
  on_conflict?: Maybe<Custom_Domain_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Custom_Domain_CloudflareArgs = {
  objects: Array<Custom_Domain_Cloudflare_Insert_Input>;
  on_conflict?: Maybe<Custom_Domain_Cloudflare_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Custom_Domain_Cloudflare_DnsArgs = {
  objects: Array<Custom_Domain_Cloudflare_Dns_Insert_Input>;
  on_conflict?: Maybe<Custom_Domain_Cloudflare_Dns_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Custom_Domain_Cloudflare_Dns_OneArgs = {
  object: Custom_Domain_Cloudflare_Dns_Insert_Input;
  on_conflict?: Maybe<Custom_Domain_Cloudflare_Dns_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Custom_Domain_Cloudflare_OneArgs = {
  object: Custom_Domain_Cloudflare_Insert_Input;
  on_conflict?: Maybe<Custom_Domain_Cloudflare_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Custom_Domain_OneArgs = {
  object: Custom_Domain_Insert_Input;
  on_conflict?: Maybe<Custom_Domain_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Customer_UsageArgs = {
  objects: Array<Customer_Usage_Insert_Input>;
  on_conflict?: Maybe<Customer_Usage_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Customer_Usage_OneArgs = {
  object: Customer_Usage_Insert_Input;
  on_conflict?: Maybe<Customer_Usage_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Data_Connector_TypeArgs = {
  objects: Array<Data_Connector_Type_Insert_Input>;
  on_conflict?: Maybe<Data_Connector_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Data_Connector_Type_OneArgs = {
  object: Data_Connector_Type_Insert_Input;
  on_conflict?: Maybe<Data_Connector_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Datadog_ConfigArgs = {
  objects: Array<Datadog_Config_Insert_Input>;
  on_conflict?: Maybe<Datadog_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Datadog_Config_OneArgs = {
  object: Datadog_Config_Insert_Input;
  on_conflict?: Maybe<Datadog_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Db_LatencyArgs = {
  objects: Array<Db_Latency_Insert_Input>;
  on_conflict?: Maybe<Db_Latency_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Db_Latency_OneArgs = {
  object: Db_Latency_Insert_Input;
  on_conflict?: Maybe<Db_Latency_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Db_UsageArgs = {
  args: Insert_Db_Usage_Args;
  distinct_on?: Maybe<Array<Project_Db_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Order_By>>;
  where?: Maybe<Project_Db_Usage_Bool_Exp>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_BuildArgs = {
  objects: Array<Ddn_Build_Insert_Input>;
  on_conflict?: Maybe<Ddn_Build_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Build_OneArgs = {
  object: Ddn_Build_Insert_Input;
  on_conflict?: Maybe<Ddn_Build_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Build_Sync_StatusArgs = {
  objects: Array<Ddn_Build_Sync_Status_Insert_Input>;
  on_conflict?: Maybe<Ddn_Build_Sync_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Build_Sync_Status_OneArgs = {
  object: Ddn_Build_Sync_Status_Insert_Input;
  on_conflict?: Maybe<Ddn_Build_Sync_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Build_Sync_WorkerArgs = {
  objects: Array<Ddn_Build_Sync_Worker_Insert_Input>;
  on_conflict?: Maybe<Ddn_Build_Sync_Worker_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Build_Sync_Worker_OneArgs = {
  object: Ddn_Build_Sync_Worker_Insert_Input;
  on_conflict?: Maybe<Ddn_Build_Sync_Worker_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_EnvironmentArgs = {
  objects: Array<Ddn_Environment_Insert_Input>;
  on_conflict?: Maybe<Ddn_Environment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Environment_OneArgs = {
  object: Ddn_Environment_Insert_Input;
  on_conflict?: Maybe<Ddn_Environment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Project_Entitlement_AccessArgs = {
  objects: Array<Ddn_Project_Entitlement_Access_Insert_Input>;
  on_conflict?: Maybe<Ddn_Project_Entitlement_Access_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Project_Entitlement_Access_OneArgs = {
  object: Ddn_Project_Entitlement_Access_Insert_Input;
  on_conflict?: Maybe<Ddn_Project_Entitlement_Access_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Project_Entitlement_CatalogueArgs = {
  objects: Array<Ddn_Project_Entitlement_Catalogue_Insert_Input>;
  on_conflict?: Maybe<Ddn_Project_Entitlement_Catalogue_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Project_Entitlement_Catalogue_OneArgs = {
  object: Ddn_Project_Entitlement_Catalogue_Insert_Input;
  on_conflict?: Maybe<Ddn_Project_Entitlement_Catalogue_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Project_Entitlement_TypesArgs = {
  objects: Array<Ddn_Project_Entitlement_Types_Insert_Input>;
  on_conflict?: Maybe<Ddn_Project_Entitlement_Types_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Project_Entitlement_Types_OneArgs = {
  object: Ddn_Project_Entitlement_Types_Insert_Input;
  on_conflict?: Maybe<Ddn_Project_Entitlement_Types_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_ProjectsArgs = {
  objects: Array<Ddn_Projects_Insert_Input>;
  on_conflict?: Maybe<Ddn_Projects_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Projects_OneArgs = {
  object: Ddn_Projects_Insert_Input;
  on_conflict?: Maybe<Ddn_Projects_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_TunnelArgs = {
  objects: Array<Ddn_Tunnel_Insert_Input>;
  on_conflict?: Maybe<Ddn_Tunnel_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Tunnel_ClusterArgs = {
  objects: Array<Ddn_Tunnel_Cluster_Insert_Input>;
  on_conflict?: Maybe<Ddn_Tunnel_Cluster_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Tunnel_Cluster_OneArgs = {
  object: Ddn_Tunnel_Cluster_Insert_Input;
  on_conflict?: Maybe<Ddn_Tunnel_Cluster_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ddn_Tunnel_OneArgs = {
  object: Ddn_Tunnel_Insert_Input;
  on_conflict?: Maybe<Ddn_Tunnel_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dedicated_Cloud_BillsArgs = {
  objects: Array<Dedicated_Cloud_Bills_Insert_Input>;
  on_conflict?: Maybe<Dedicated_Cloud_Bills_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dedicated_Cloud_Bills_DetailsArgs = {
  objects: Array<Dedicated_Cloud_Bills_Details_Insert_Input>;
  on_conflict?: Maybe<Dedicated_Cloud_Bills_Details_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dedicated_Cloud_Bills_Details_OneArgs = {
  object: Dedicated_Cloud_Bills_Details_Insert_Input;
  on_conflict?: Maybe<Dedicated_Cloud_Bills_Details_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dedicated_Cloud_Bills_OneArgs = {
  object: Dedicated_Cloud_Bills_Insert_Input;
  on_conflict?: Maybe<Dedicated_Cloud_Bills_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dedicated_Cloud_CommitmentsArgs = {
  objects: Array<Dedicated_Cloud_Commitments_Insert_Input>;
  on_conflict?: Maybe<Dedicated_Cloud_Commitments_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dedicated_Cloud_Commitments_OneArgs = {
  object: Dedicated_Cloud_Commitments_Insert_Input;
  on_conflict?: Maybe<Dedicated_Cloud_Commitments_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dedicated_VpcArgs = {
  objects: Array<Dedicated_Vpc_Insert_Input>;
  on_conflict?: Maybe<Dedicated_Vpc_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Dedicated_Vpc_OneArgs = {
  object: Dedicated_Vpc_Insert_Input;
  on_conflict?: Maybe<Dedicated_Vpc_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Delete_UserArgs = {
  objects: Array<Delete_User_Insert_Input>;
  on_conflict?: Maybe<Delete_User_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Delete_User_OneArgs = {
  object: Delete_User_Insert_Input;
  on_conflict?: Maybe<Delete_User_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Delete_User_StatusArgs = {
  objects: Array<Delete_User_Status_Insert_Input>;
  on_conflict?: Maybe<Delete_User_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Delete_User_Status_OneArgs = {
  object: Delete_User_Status_Insert_Input;
  on_conflict?: Maybe<Delete_User_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Delete_User_TasksArgs = {
  objects: Array<Delete_User_Tasks_Insert_Input>;
  on_conflict?: Maybe<Delete_User_Tasks_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Delete_User_Tasks_OneArgs = {
  object: Delete_User_Tasks_Insert_Input;
  on_conflict?: Maybe<Delete_User_Tasks_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Email_LogArgs = {
  objects: Array<Email_Log_Insert_Input>;
  on_conflict?: Maybe<Email_Log_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Email_Log_OneArgs = {
  object: Email_Log_Insert_Input;
  on_conflict?: Maybe<Email_Log_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Enterprise_UsersArgs = {
  objects: Array<Enterprise_Users_Insert_Input>;
  on_conflict?: Maybe<Enterprise_Users_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Enterprise_Users_OneArgs = {
  object: Enterprise_Users_Insert_Input;
  on_conflict?: Maybe<Enterprise_Users_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ExperimentsArgs = {
  objects: Array<Experiments_Insert_Input>;
  on_conflict?: Maybe<Experiments_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Experiments_CohortArgs = {
  objects: Array<Experiments_Cohort_Insert_Input>;
  on_conflict?: Maybe<Experiments_Cohort_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Experiments_Cohort_OneArgs = {
  object: Experiments_Cohort_Insert_Input;
  on_conflict?: Maybe<Experiments_Cohort_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Experiments_ConfigArgs = {
  objects: Array<Experiments_Config_Insert_Input>;
  on_conflict?: Maybe<Experiments_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Experiments_Config_OneArgs = {
  object: Experiments_Config_Insert_Input;
  on_conflict?: Maybe<Experiments_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Experiments_OneArgs = {
  object: Experiments_Insert_Input;
  on_conflict?: Maybe<Experiments_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_FeatureArgs = {
  objects: Array<Feature_Insert_Input>;
  on_conflict?: Maybe<Feature_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Feature_AccessArgs = {
  objects: Array<Feature_Access_Insert_Input>;
  on_conflict?: Maybe<Feature_Access_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Feature_Access_OneArgs = {
  object: Feature_Access_Insert_Input;
  on_conflict?: Maybe<Feature_Access_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Feature_ConfigArgs = {
  objects: Array<Feature_Config_Insert_Input>;
  on_conflict?: Maybe<Feature_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Feature_Config_OneArgs = {
  object: Feature_Config_Insert_Input;
  on_conflict?: Maybe<Feature_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Feature_OneArgs = {
  object: Feature_Insert_Input;
  on_conflict?: Maybe<Feature_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Gateway_AmiArgs = {
  objects: Array<Gateway_Ami_Insert_Input>;
  on_conflict?: Maybe<Gateway_Ami_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Gateway_Ami_OneArgs = {
  object: Gateway_Ami_Insert_Input;
  on_conflict?: Maybe<Gateway_Ami_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Gateway_ClusterArgs = {
  objects: Array<Gateway_Cluster_Insert_Input>;
  on_conflict?: Maybe<Gateway_Cluster_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Gateway_Cluster_OneArgs = {
  object: Gateway_Cluster_Insert_Input;
  on_conflict?: Maybe<Gateway_Cluster_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Gateway_WorkerArgs = {
  objects: Array<Gateway_Worker_Insert_Input>;
  on_conflict?: Maybe<Gateway_Worker_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Gateway_Worker_OneArgs = {
  object: Gateway_Worker_Insert_Input;
  on_conflict?: Maybe<Gateway_Worker_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Github_Email_TypeArgs = {
  objects: Array<Github_Email_Type_Insert_Input>;
  on_conflict?: Maybe<Github_Email_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Github_Email_Type_OneArgs = {
  object: Github_Email_Type_Insert_Input;
  on_conflict?: Maybe<Github_Email_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Github_Integration_ConfigArgs = {
  objects: Array<Github_Integration_Config_Insert_Input>;
  on_conflict?: Maybe<Github_Integration_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Github_Integration_Config_OneArgs = {
  object: Github_Integration_Config_Insert_Input;
  on_conflict?: Maybe<Github_Integration_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Github_Integration_ModeArgs = {
  objects: Array<Github_Integration_Mode_Insert_Input>;
  on_conflict?: Maybe<Github_Integration_Mode_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Github_Integration_Mode_OneArgs = {
  object: Github_Integration_Mode_Insert_Input;
  on_conflict?: Maybe<Github_Integration_Mode_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Github_Push_EventArgs = {
  objects: Array<Github_Push_Event_Insert_Input>;
  on_conflict?: Maybe<Github_Push_Event_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Github_Push_Event_JobArgs = {
  objects: Array<Github_Push_Event_Job_Insert_Input>;
  on_conflict?: Maybe<Github_Push_Event_Job_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Github_Push_Event_Job_OneArgs = {
  object: Github_Push_Event_Job_Insert_Input;
  on_conflict?: Maybe<Github_Push_Event_Job_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Github_Push_Event_OneArgs = {
  object: Github_Push_Event_Insert_Input;
  on_conflict?: Maybe<Github_Push_Event_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Hasura_AmiArgs = {
  objects: Array<Hasura_Ami_Insert_Input>;
  on_conflict?: Maybe<Hasura_Ami_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Hasura_Ami_OneArgs = {
  object: Hasura_Ami_Insert_Input;
  on_conflict?: Maybe<Hasura_Ami_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Hasura_ClusterArgs = {
  objects: Array<Hasura_Cluster_Insert_Input>;
  on_conflict?: Maybe<Hasura_Cluster_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Hasura_Cluster_OneArgs = {
  object: Hasura_Cluster_Insert_Input;
  on_conflict?: Maybe<Hasura_Cluster_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Hasura_WorkerArgs = {
  objects: Array<Hasura_Worker_Insert_Input>;
  on_conflict?: Maybe<Hasura_Worker_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Hasura_Worker_OneArgs = {
  object: Hasura_Worker_Insert_Input;
  on_conflict?: Maybe<Hasura_Worker_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Heroku_IntegrationsArgs = {
  objects: Array<Heroku_Integrations_Insert_Input>;
  on_conflict?: Maybe<Heroku_Integrations_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Heroku_Integrations_OneArgs = {
  object: Heroku_Integrations_Insert_Input;
  on_conflict?: Maybe<Heroku_Integrations_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Inactive_Project_ExclusionsArgs = {
  objects: Array<Inactive_Project_Exclusions_Insert_Input>;
  on_conflict?: Maybe<Inactive_Project_Exclusions_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Inactive_Project_Exclusions_OneArgs = {
  object: Inactive_Project_Exclusions_Insert_Input;
  on_conflict?: Maybe<Inactive_Project_Exclusions_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Inactive_Project_NotificationsArgs = {
  objects: Array<Inactive_Project_Notifications_Insert_Input>;
  on_conflict?: Maybe<Inactive_Project_Notifications_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Inactive_Project_Notifications_OneArgs = {
  object: Inactive_Project_Notifications_Insert_Input;
  on_conflict?: Maybe<Inactive_Project_Notifications_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Inactive_Project_Suspension_ConfigArgs = {
  objects: Array<Inactive_Project_Suspension_Config_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Inactive_Project_Suspension_Config_OneArgs = {
  object: Inactive_Project_Suspension_Config_Insert_Input;
};

/** mutation root */
export type Mutation_RootInsert_Infra_StatusArgs = {
  objects: Array<Infra_Status_Insert_Input>;
  on_conflict?: Maybe<Infra_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Infra_Status_OneArgs = {
  object: Infra_Status_Insert_Input;
  on_conflict?: Maybe<Infra_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_InvoiceArgs = {
  objects: Array<Invoice_Insert_Input>;
  on_conflict?: Maybe<Invoice_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Invoice_Coupon_DiscountArgs = {
  objects: Array<Invoice_Coupon_Discount_Insert_Input>;
  on_conflict?: Maybe<Invoice_Coupon_Discount_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Invoice_Coupon_Discount_OneArgs = {
  object: Invoice_Coupon_Discount_Insert_Input;
  on_conflict?: Maybe<Invoice_Coupon_Discount_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Invoice_ItemArgs = {
  objects: Array<Invoice_Item_Insert_Input>;
  on_conflict?: Maybe<Invoice_Item_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Invoice_Item_OneArgs = {
  object: Invoice_Item_Insert_Input;
  on_conflict?: Maybe<Invoice_Item_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Invoice_OneArgs = {
  object: Invoice_Insert_Input;
  on_conflict?: Maybe<Invoice_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_JobsArgs = {
  objects: Array<Jobs_Insert_Input>;
  on_conflict?: Maybe<Jobs_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Jobs_OneArgs = {
  object: Jobs_Insert_Input;
  on_conflict?: Maybe<Jobs_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_LabelArgs = {
  objects: Array<Label_Insert_Input>;
  on_conflict?: Maybe<Label_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Label_OneArgs = {
  object: Label_Insert_Input;
  on_conflict?: Maybe<Label_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Letsencrypt_StatusArgs = {
  objects: Array<Letsencrypt_Status_Insert_Input>;
  on_conflict?: Maybe<Letsencrypt_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Letsencrypt_Status_OneArgs = {
  object: Letsencrypt_Status_Insert_Input;
  on_conflict?: Maybe<Letsencrypt_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_License_ActivityArgs = {
  objects: Array<License_Activity_Insert_Input>;
  on_conflict?: Maybe<License_Activity_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_License_Activity_OneArgs = {
  object: License_Activity_Insert_Input;
  on_conflict?: Maybe<License_Activity_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_License_InstanceArgs = {
  objects: Array<License_Instance_Insert_Input>;
  on_conflict?: Maybe<License_Instance_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_License_Instance_OneArgs = {
  object: License_Instance_Insert_Input;
  on_conflict?: Maybe<License_Instance_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_License_TypeArgs = {
  objects: Array<License_Type_Insert_Input>;
  on_conflict?: Maybe<License_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_License_Type_OneArgs = {
  object: License_Type_Insert_Input;
  on_conflict?: Maybe<License_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_LicensesArgs = {
  objects: Array<Licenses_Insert_Input>;
  on_conflict?: Maybe<Licenses_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Licenses_OneArgs = {
  object: Licenses_Insert_Input;
  on_conflict?: Maybe<Licenses_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Lux_ProxyArgs = {
  objects: Array<Lux_Proxy_Insert_Input>;
  on_conflict?: Maybe<Lux_Proxy_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Lux_Proxy_AmiArgs = {
  objects: Array<Lux_Proxy_Ami_Insert_Input>;
  on_conflict?: Maybe<Lux_Proxy_Ami_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Lux_Proxy_Ami_OneArgs = {
  object: Lux_Proxy_Ami_Insert_Input;
  on_conflict?: Maybe<Lux_Proxy_Ami_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Lux_Proxy_OneArgs = {
  object: Lux_Proxy_Insert_Input;
  on_conflict?: Maybe<Lux_Proxy_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Neon_Db_IntegrationArgs = {
  objects: Array<Neon_Db_Integration_Insert_Input>;
  on_conflict?: Maybe<Neon_Db_Integration_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Neon_Db_Integration_OneArgs = {
  object: Neon_Db_Integration_Insert_Input;
  on_conflict?: Maybe<Neon_Db_Integration_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Newrelic_ConfigArgs = {
  objects: Array<Newrelic_Config_Insert_Input>;
  on_conflict?: Maybe<Newrelic_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Newrelic_Config_OneArgs = {
  object: Newrelic_Config_Insert_Input;
  on_conflict?: Maybe<Newrelic_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Node_Pool_TypeArgs = {
  objects: Array<Node_Pool_Type_Insert_Input>;
  on_conflict?: Maybe<Node_Pool_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Node_Pool_Type_OneArgs = {
  object: Node_Pool_Type_Insert_Input;
  on_conflict?: Maybe<Node_Pool_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Node_PoolsArgs = {
  objects: Array<Node_Pools_Insert_Input>;
  on_conflict?: Maybe<Node_Pools_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Node_Pools_OneArgs = {
  object: Node_Pools_Insert_Input;
  on_conflict?: Maybe<Node_Pools_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_NotificationArgs = {
  objects: Array<Notification_Insert_Input>;
  on_conflict?: Maybe<Notification_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Notification_OneArgs = {
  object: Notification_Insert_Input;
  on_conflict?: Maybe<Notification_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Notification_TypeArgs = {
  objects: Array<Notification_Type_Insert_Input>;
  on_conflict?: Maybe<Notification_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Notification_Type_OneArgs = {
  object: Notification_Type_Insert_Input;
  on_conflict?: Maybe<Notification_Type_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Onboarding_Sample_Db_CohortArgs = {
  objects: Array<Onboarding_Sample_Db_Cohort_Insert_Input>;
  on_conflict?: Maybe<Onboarding_Sample_Db_Cohort_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Onboarding_Sample_Db_Cohort_OneArgs = {
  object: Onboarding_Sample_Db_Cohort_Insert_Input;
  on_conflict?: Maybe<Onboarding_Sample_Db_Cohort_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Onboarding_Sample_Db_ConfigArgs = {
  objects: Array<Onboarding_Sample_Db_Config_Insert_Input>;
  on_conflict?: Maybe<Onboarding_Sample_Db_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Onboarding_Sample_Db_Config_OneArgs = {
  object: Onboarding_Sample_Db_Config_Insert_Input;
  on_conflict?: Maybe<Onboarding_Sample_Db_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_One_Click_DeploymentArgs = {
  objects: Array<One_Click_Deployment_Insert_Input>;
  on_conflict?: Maybe<One_Click_Deployment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_One_Click_Deployment_OneArgs = {
  object: One_Click_Deployment_Insert_Input;
  on_conflict?: Maybe<One_Click_Deployment_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_One_Click_Deployment_Sample_AppsArgs = {
  objects: Array<One_Click_Deployment_Sample_Apps_Insert_Input>;
  on_conflict?: Maybe<One_Click_Deployment_Sample_Apps_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_One_Click_Deployment_Sample_Apps_OneArgs = {
  object: One_Click_Deployment_Sample_Apps_Insert_Input;
  on_conflict?: Maybe<One_Click_Deployment_Sample_Apps_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_One_Click_Deployment_State_LogArgs = {
  objects: Array<One_Click_Deployment_State_Log_Insert_Input>;
  on_conflict?: Maybe<One_Click_Deployment_State_Log_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_One_Click_Deployment_State_Log_OneArgs = {
  object: One_Click_Deployment_State_Log_Insert_Input;
  on_conflict?: Maybe<One_Click_Deployment_State_Log_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_One_Click_Deployment_StatesArgs = {
  objects: Array<One_Click_Deployment_States_Insert_Input>;
  on_conflict?: Maybe<One_Click_Deployment_States_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_One_Click_Deployment_States_OneArgs = {
  object: One_Click_Deployment_States_Insert_Input;
  on_conflict?: Maybe<One_Click_Deployment_States_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Opentelemetry_ConfigArgs = {
  objects: Array<Opentelemetry_Config_Insert_Input>;
  on_conflict?: Maybe<Opentelemetry_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Opentelemetry_Config_OneArgs = {
  object: Opentelemetry_Config_Insert_Input;
  on_conflict?: Maybe<Opentelemetry_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Operations_Delete_Free_Plan_Dns_Records_Nov_2021Args =
  {
    objects: Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Insert_Input>;
    on_conflict?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_On_Conflict>;
  };

/** mutation root */
export type Mutation_RootInsert_Operations_Delete_Free_Plan_Dns_Records_Nov_2021_OneArgs =
  {
    object: Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Insert_Input;
    on_conflict?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_On_Conflict>;
  };

/** mutation root */
export type Mutation_RootInsert_Operations_TenantArgs = {
  objects: Array<Operations_Tenant_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Operations_Tenant_OneArgs = {
  object: Operations_Tenant_Insert_Input;
};

/** mutation root */
export type Mutation_RootInsert_Payment_MethodArgs = {
  objects: Array<Payment_Method_Insert_Input>;
  on_conflict?: Maybe<Payment_Method_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Payment_Method_OneArgs = {
  object: Payment_Method_Insert_Input;
  on_conflict?: Maybe<Payment_Method_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Plan_EntitlementsArgs = {
  objects: Array<Plan_Entitlements_Insert_Input>;
  on_conflict?: Maybe<Plan_Entitlements_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Plan_Entitlements_OneArgs = {
  object: Plan_Entitlements_Insert_Input;
  on_conflict?: Maybe<Plan_Entitlements_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_PlansArgs = {
  objects: Array<Plans_Insert_Input>;
  on_conflict?: Maybe<Plans_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Plans_OneArgs = {
  object: Plans_Insert_Input;
  on_conflict?: Maybe<Plans_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_PoliciesArgs = {
  objects: Array<Policies_Insert_Input>;
  on_conflict?: Maybe<Policies_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Policies_OneArgs = {
  object: Policies_Insert_Input;
  on_conflict?: Maybe<Policies_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_PrivilegesArgs = {
  objects: Array<Privileges_Insert_Input>;
  on_conflict?: Maybe<Privileges_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Privileges_OneArgs = {
  object: Privileges_Insert_Input;
  on_conflict?: Maybe<Privileges_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Pro_License_KeysArgs = {
  objects: Array<Pro_License_Keys_Insert_Input>;
  on_conflict?: Maybe<Pro_License_Keys_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Pro_License_Keys_OneArgs = {
  object: Pro_License_Keys_Insert_Input;
  on_conflict?: Maybe<Pro_License_Keys_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_ActivityArgs = {
  objects: Array<Project_Activity_Insert_Input>;
  on_conflict?: Maybe<Project_Activity_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Activity_OneArgs = {
  object: Project_Activity_Insert_Input;
  on_conflict?: Maybe<Project_Activity_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Billing_Manager_InvitationsArgs = {
  objects: Array<Project_Billing_Manager_Invitations_Insert_Input>;
  on_conflict?: Maybe<Project_Billing_Manager_Invitations_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Billing_Manager_Invitations_OneArgs = {
  object: Project_Billing_Manager_Invitations_Insert_Input;
  on_conflict?: Maybe<Project_Billing_Manager_Invitations_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Collaborator_Allowed_Schema_TablesArgs =
  {
    objects: Array<Project_Collaborator_Allowed_Schema_Tables_Insert_Input>;
    on_conflict?: Maybe<Project_Collaborator_Allowed_Schema_Tables_On_Conflict>;
  };

/** mutation root */
export type Mutation_RootInsert_Project_Collaborator_Allowed_Schema_Tables_OneArgs =
  {
    object: Project_Collaborator_Allowed_Schema_Tables_Insert_Input;
    on_conflict?: Maybe<Project_Collaborator_Allowed_Schema_Tables_On_Conflict>;
  };

/** mutation root */
export type Mutation_RootInsert_Project_Collaborator_Allowed_SchemasArgs = {
  objects: Array<Project_Collaborator_Allowed_Schemas_Insert_Input>;
  on_conflict?: Maybe<Project_Collaborator_Allowed_Schemas_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Collaborator_Allowed_Schemas_OneArgs = {
  object: Project_Collaborator_Allowed_Schemas_Insert_Input;
  on_conflict?: Maybe<Project_Collaborator_Allowed_Schemas_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Collaborator_InvitationsArgs = {
  objects: Array<Project_Collaborator_Invitations_Insert_Input>;
  on_conflict?: Maybe<Project_Collaborator_Invitations_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Collaborator_Invitations_OneArgs = {
  object: Project_Collaborator_Invitations_Insert_Input;
  on_conflict?: Maybe<Project_Collaborator_Invitations_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Collaborator_PrivilegesArgs = {
  objects: Array<Project_Collaborator_Privileges_Insert_Input>;
  on_conflict?: Maybe<Project_Collaborator_Privileges_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Collaborator_Privileges_OneArgs = {
  object: Project_Collaborator_Privileges_Insert_Input;
  on_conflict?: Maybe<Project_Collaborator_Privileges_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_CollaboratorsArgs = {
  objects: Array<Project_Collaborators_Insert_Input>;
  on_conflict?: Maybe<Project_Collaborators_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Collaborators_OneArgs = {
  object: Project_Collaborators_Insert_Input;
  on_conflict?: Maybe<Project_Collaborators_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_UsageArgs = {
  objects: Array<Project_Data_Usage_Insert_Input>;
  on_conflict?: Maybe<Project_Data_Usage_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_AggArgs = {
  objects: Array<Project_Data_Usage_Agg_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_Agg_OneArgs = {
  object: Project_Data_Usage_Agg_Insert_Input;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_Agg_UserArgs = {
  objects: Array<Project_Data_Usage_Agg_User_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_Agg_User_OneArgs = {
  object: Project_Data_Usage_Agg_User_Insert_Input;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_ComponentsArgs = {
  objects: Array<Project_Data_Usage_Components_Insert_Input>;
  on_conflict?: Maybe<Project_Data_Usage_Components_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_Components_OneArgs = {
  object: Project_Data_Usage_Components_Insert_Input;
  on_conflict?: Maybe<Project_Data_Usage_Components_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_OneArgs = {
  object: Project_Data_Usage_Insert_Input;
  on_conflict?: Maybe<Project_Data_Usage_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_PrometheusArgs = {
  objects: Array<Project_Data_Usage_Prometheus_Insert_Input>;
  on_conflict?: Maybe<Project_Data_Usage_Prometheus_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_Prometheus_Agg_UserArgs = {
  objects: Array<Project_Data_Usage_Prometheus_Agg_User_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_Prometheus_Agg_User_OneArgs =
  {
    object: Project_Data_Usage_Prometheus_Agg_User_Insert_Input;
  };

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_Prometheus_OneArgs = {
  object: Project_Data_Usage_Prometheus_Insert_Input;
  on_conflict?: Maybe<Project_Data_Usage_Prometheus_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_ReportArgs = {
  objects: Array<Project_Data_Usage_Report_Insert_Input>;
  on_conflict?: Maybe<Project_Data_Usage_Report_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Data_Usage_Report_OneArgs = {
  object: Project_Data_Usage_Report_Insert_Input;
  on_conflict?: Maybe<Project_Data_Usage_Report_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Db_UsageArgs = {
  objects: Array<Project_Db_Usage_Insert_Input>;
  on_conflict?: Maybe<Project_Db_Usage_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Db_Usage_Agg_UserArgs = {
  objects: Array<Project_Db_Usage_Agg_User_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Db_Usage_Agg_User_OneArgs = {
  object: Project_Db_Usage_Agg_User_Insert_Input;
};

/** mutation root */
export type Mutation_RootInsert_Project_Db_Usage_OneArgs = {
  object: Project_Db_Usage_Insert_Input;
  on_conflict?: Maybe<Project_Db_Usage_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Entitlement_AccessArgs = {
  objects: Array<Project_Entitlement_Access_Insert_Input>;
  on_conflict?: Maybe<Project_Entitlement_Access_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Entitlement_Access_OneArgs = {
  object: Project_Entitlement_Access_Insert_Input;
  on_conflict?: Maybe<Project_Entitlement_Access_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Entitlement_CatalogueArgs = {
  objects: Array<Project_Entitlement_Catalogue_Insert_Input>;
  on_conflict?: Maybe<Project_Entitlement_Catalogue_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Entitlement_Catalogue_OneArgs = {
  object: Project_Entitlement_Catalogue_Insert_Input;
  on_conflict?: Maybe<Project_Entitlement_Catalogue_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Entitlement_TypesArgs = {
  objects: Array<Project_Entitlement_Types_Insert_Input>;
  on_conflict?: Maybe<Project_Entitlement_Types_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Entitlement_Types_OneArgs = {
  object: Project_Entitlement_Types_Insert_Input;
  on_conflict?: Maybe<Project_Entitlement_Types_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_LabelsArgs = {
  objects: Array<Project_Labels_Insert_Input>;
  on_conflict?: Maybe<Project_Labels_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Labels_OneArgs = {
  object: Project_Labels_Insert_Input;
  on_conflict?: Maybe<Project_Labels_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_MetadataArgs = {
  objects: Array<Project_Metadata_Insert_Input>;
  on_conflict?: Maybe<Project_Metadata_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Metadata_OneArgs = {
  object: Project_Metadata_Insert_Input;
  on_conflict?: Maybe<Project_Metadata_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_NotificationArgs = {
  objects: Array<Project_Notification_Insert_Input>;
  on_conflict?: Maybe<Project_Notification_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Notification_OneArgs = {
  object: Project_Notification_Insert_Input;
  on_conflict?: Maybe<Project_Notification_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Ownership_Transfer_InvitationsArgs = {
  objects: Array<Project_Ownership_Transfer_Invitations_Insert_Input>;
  on_conflict?: Maybe<Project_Ownership_Transfer_Invitations_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Ownership_Transfer_Invitations_OneArgs =
  {
    object: Project_Ownership_Transfer_Invitations_Insert_Input;
    on_conflict?: Maybe<Project_Ownership_Transfer_Invitations_On_Conflict>;
  };

/** mutation root */
export type Mutation_RootInsert_Project_Requests_CountArgs = {
  objects: Array<Project_Requests_Count_Insert_Input>;
  on_conflict?: Maybe<Project_Requests_Count_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Requests_Count_OneArgs = {
  object: Project_Requests_Count_Insert_Input;
  on_conflict?: Maybe<Project_Requests_Count_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_StatsArgs = {
  objects: Array<Project_Stats_Insert_Input>;
  on_conflict?: Maybe<Project_Stats_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Stats_OneArgs = {
  object: Project_Stats_Insert_Input;
  on_conflict?: Maybe<Project_Stats_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Total_Db_Usage_AggArgs = {
  objects: Array<Project_Total_Db_Usage_Agg_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Project_Total_Db_Usage_Agg_OneArgs = {
  object: Project_Total_Db_Usage_Agg_Insert_Input;
};

/** mutation root */
export type Mutation_RootInsert_ProjectsArgs = {
  objects: Array<Projects_Insert_Input>;
  on_conflict?: Maybe<Projects_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Projects_OneArgs = {
  object: Projects_Insert_Input;
  on_conflict?: Maybe<Projects_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Projects_Pool_ConfigArgs = {
  objects: Array<Projects_Pool_Config_Insert_Input>;
  on_conflict?: Maybe<Projects_Pool_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Projects_Pool_Config_OneArgs = {
  object: Projects_Pool_Config_Insert_Input;
  on_conflict?: Maybe<Projects_Pool_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Projects_Pro_Key_GenerationsArgs = {
  objects: Array<Projects_Pro_Key_Generations_Insert_Input>;
  on_conflict?: Maybe<Projects_Pro_Key_Generations_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Projects_Pro_Key_Generations_OneArgs = {
  object: Projects_Pro_Key_Generations_Insert_Input;
  on_conflict?: Maybe<Projects_Pro_Key_Generations_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Prometheus_ConfigArgs = {
  objects: Array<Prometheus_Config_Insert_Input>;
  on_conflict?: Maybe<Prometheus_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Prometheus_Config_OneArgs = {
  object: Prometheus_Config_Insert_Input;
  on_conflict?: Maybe<Prometheus_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ProvidersArgs = {
  objects: Array<Providers_Insert_Input>;
  on_conflict?: Maybe<Providers_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Providers_OneArgs = {
  object: Providers_Insert_Input;
  on_conflict?: Maybe<Providers_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ProvisioningArgs = {
  objects: Array<Provisioning_Insert_Input>;
  on_conflict?: Maybe<Provisioning_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Provisioning_OneArgs = {
  object: Provisioning_Insert_Input;
  on_conflict?: Maybe<Provisioning_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_RegionArgs = {
  objects: Array<Region_Insert_Input>;
  on_conflict?: Maybe<Region_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Region_OneArgs = {
  object: Region_Insert_Input;
  on_conflict?: Maybe<Region_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Region_V2Args = {
  objects: Array<Region_V2_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Region_V2_OneArgs = {
  object: Region_V2_Insert_Input;
};

/** mutation root */
export type Mutation_RootInsert_Regional_Data_ConnectorsArgs = {
  objects: Array<Regional_Data_Connectors_Insert_Input>;
  on_conflict?: Maybe<Regional_Data_Connectors_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Regional_Data_Connectors_OneArgs = {
  object: Regional_Data_Connectors_Insert_Input;
  on_conflict?: Maybe<Regional_Data_Connectors_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Regional_MetricsArgs = {
  objects: Array<Regional_Metrics_Insert_Input>;
  on_conflict?: Maybe<Regional_Metrics_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Regional_Metrics_OneArgs = {
  object: Regional_Metrics_Insert_Input;
  on_conflict?: Maybe<Regional_Metrics_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Saml_IdpArgs = {
  objects: Array<Saml_Idp_Insert_Input>;
  on_conflict?: Maybe<Saml_Idp_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Saml_Idp_OneArgs = {
  object: Saml_Idp_Insert_Input;
  on_conflict?: Maybe<Saml_Idp_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Search_Project_Login_Status_ResultsArgs = {
  objects: Array<Search_Project_Login_Status_Results_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Search_Project_Login_Status_Results_OneArgs = {
  object: Search_Project_Login_Status_Results_Insert_Input;
};

/** mutation root */
export type Mutation_RootInsert_Slack_ConfigArgs = {
  objects: Array<Slack_Config_Insert_Input>;
  on_conflict?: Maybe<Slack_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Slack_Config_OneArgs = {
  object: Slack_Config_Insert_Input;
  on_conflict?: Maybe<Slack_Config_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Stripe_SubscriptionArgs = {
  objects: Array<Stripe_Subscription_Insert_Input>;
  on_conflict?: Maybe<Stripe_Subscription_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Stripe_Subscription_OneArgs = {
  object: Stripe_Subscription_Insert_Input;
  on_conflict?: Maybe<Stripe_Subscription_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Stripe_Webhook_EventsArgs = {
  objects: Array<Stripe_Webhook_Events_Insert_Input>;
  on_conflict?: Maybe<Stripe_Webhook_Events_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Stripe_Webhook_Events_OneArgs = {
  object: Stripe_Webhook_Events_Insert_Input;
  on_conflict?: Maybe<Stripe_Webhook_Events_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Super_Connector_TypesArgs = {
  objects: Array<Super_Connector_Types_Insert_Input>;
  on_conflict?: Maybe<Super_Connector_Types_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Super_Connector_Types_OneArgs = {
  object: Super_Connector_Types_Insert_Input;
  on_conflict?: Maybe<Super_Connector_Types_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Support_Plan_TypesArgs = {
  objects: Array<Support_Plan_Types_Insert_Input>;
  on_conflict?: Maybe<Support_Plan_Types_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Support_Plan_Types_OneArgs = {
  object: Support_Plan_Types_Insert_Input;
  on_conflict?: Maybe<Support_Plan_Types_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_SurveyArgs = {
  objects: Array<Survey_Insert_Input>;
  on_conflict?: Maybe<Survey_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_OneArgs = {
  object: Survey_Insert_Input;
  on_conflict?: Maybe<Survey_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_QuestionArgs = {
  objects: Array<Survey_Question_Insert_Input>;
  on_conflict?: Maybe<Survey_Question_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_Question_Answer_OptionArgs = {
  objects: Array<Survey_Question_Answer_Option_Insert_Input>;
  on_conflict?: Maybe<Survey_Question_Answer_Option_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_Question_Answer_Option_OneArgs = {
  object: Survey_Question_Answer_Option_Insert_Input;
  on_conflict?: Maybe<Survey_Question_Answer_Option_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_Question_AnswersArgs = {
  objects: Array<Survey_Question_Answers_Insert_Input>;
  on_conflict?: Maybe<Survey_Question_Answers_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_Question_Answers_OneArgs = {
  object: Survey_Question_Answers_Insert_Input;
  on_conflict?: Maybe<Survey_Question_Answers_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_Question_KindArgs = {
  objects: Array<Survey_Question_Kind_Insert_Input>;
  on_conflict?: Maybe<Survey_Question_Kind_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_Question_Kind_OneArgs = {
  object: Survey_Question_Kind_Insert_Input;
  on_conflict?: Maybe<Survey_Question_Kind_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_Question_OneArgs = {
  object: Survey_Question_Insert_Input;
  on_conflict?: Maybe<Survey_Question_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_Question_OptionsArgs = {
  objects: Array<Survey_Question_Options_Insert_Input>;
  on_conflict?: Maybe<Survey_Question_Options_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_Question_Options_OneArgs = {
  object: Survey_Question_Options_Insert_Input;
  on_conflict?: Maybe<Survey_Question_Options_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2Args = {
  objects: Array<Survey_V2_Insert_Input>;
  on_conflict?: Maybe<Survey_V2_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_OneArgs = {
  object: Survey_V2_Insert_Input;
  on_conflict?: Maybe<Survey_V2_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_QuestionArgs = {
  objects: Array<Survey_V2_Question_Insert_Input>;
  on_conflict?: Maybe<Survey_V2_Question_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Question_KindArgs = {
  objects: Array<Survey_V2_Question_Kind_Insert_Input>;
  on_conflict?: Maybe<Survey_V2_Question_Kind_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Question_Kind_OneArgs = {
  object: Survey_V2_Question_Kind_Insert_Input;
  on_conflict?: Maybe<Survey_V2_Question_Kind_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Question_OneArgs = {
  object: Survey_V2_Question_Insert_Input;
  on_conflict?: Maybe<Survey_V2_Question_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Question_OptionArgs = {
  objects: Array<Survey_V2_Question_Option_Insert_Input>;
  on_conflict?: Maybe<Survey_V2_Question_Option_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Question_Option_Additional_Info_ConfigArgs =
  {
    objects: Array<Survey_V2_Question_Option_Additional_Info_Config_Insert_Input>;
    on_conflict?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_On_Conflict>;
  };

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Question_Option_Additional_Info_Config_OneArgs =
  {
    object: Survey_V2_Question_Option_Additional_Info_Config_Insert_Input;
    on_conflict?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_On_Conflict>;
  };

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Question_Option_OneArgs = {
  object: Survey_V2_Question_Option_Insert_Input;
  on_conflict?: Maybe<Survey_V2_Question_Option_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_ResponseArgs = {
  objects: Array<Survey_V2_Response_Insert_Input>;
  on_conflict?: Maybe<Survey_V2_Response_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Response_AnswerArgs = {
  objects: Array<Survey_V2_Response_Answer_Insert_Input>;
  on_conflict?: Maybe<Survey_V2_Response_Answer_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Response_Answer_OneArgs = {
  object: Survey_V2_Response_Answer_Insert_Input;
  on_conflict?: Maybe<Survey_V2_Response_Answer_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Response_Answer_OptionArgs = {
  objects: Array<Survey_V2_Response_Answer_Option_Insert_Input>;
  on_conflict?: Maybe<Survey_V2_Response_Answer_Option_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Response_Answer_Option_OneArgs = {
  object: Survey_V2_Response_Answer_Option_Insert_Input;
  on_conflict?: Maybe<Survey_V2_Response_Answer_Option_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Survey_V2_Response_OneArgs = {
  object: Survey_V2_Response_Insert_Input;
  on_conflict?: Maybe<Survey_V2_Response_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Task_EventArgs = {
  objects: Array<Task_Event_Insert_Input>;
  on_conflict?: Maybe<Task_Event_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Task_Event_OneArgs = {
  object: Task_Event_Insert_Input;
  on_conflict?: Maybe<Task_Event_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_TasksArgs = {
  objects: Array<Tasks_Insert_Input>;
  on_conflict?: Maybe<Tasks_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tasks_OneArgs = {
  object: Tasks_Insert_Input;
  on_conflict?: Maybe<Tasks_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_TenantArgs = {
  objects: Array<Tenant_Insert_Input>;
  on_conflict?: Maybe<Tenant_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tenant_Active_Status_ReasonArgs = {
  objects: Array<Tenant_Active_Status_Reason_Insert_Input>;
  on_conflict?: Maybe<Tenant_Active_Status_Reason_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tenant_Active_Status_Reason_OneArgs = {
  object: Tenant_Active_Status_Reason_Insert_Input;
  on_conflict?: Maybe<Tenant_Active_Status_Reason_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tenant_GroupArgs = {
  objects: Array<Tenant_Group_Insert_Input>;
  on_conflict?: Maybe<Tenant_Group_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tenant_Group_MemberArgs = {
  objects: Array<Tenant_Group_Member_Insert_Input>;
  on_conflict?: Maybe<Tenant_Group_Member_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tenant_Group_Member_OneArgs = {
  object: Tenant_Group_Member_Insert_Input;
  on_conflict?: Maybe<Tenant_Group_Member_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tenant_Group_OneArgs = {
  object: Tenant_Group_Insert_Input;
  on_conflict?: Maybe<Tenant_Group_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tenant_OneArgs = {
  object: Tenant_Insert_Input;
  on_conflict?: Maybe<Tenant_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tenant_Public_StatusArgs = {
  objects: Array<Tenant_Public_Status_Insert_Input>;
  on_conflict?: Maybe<Tenant_Public_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tenant_Public_Status_OneArgs = {
  object: Tenant_Public_Status_Insert_Input;
  on_conflict?: Maybe<Tenant_Public_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tenant_StatusArgs = {
  objects: Array<Tenant_Status_Insert_Input>;
  on_conflict?: Maybe<Tenant_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Tenant_Status_OneArgs = {
  object: Tenant_Status_Insert_Input;
  on_conflict?: Maybe<Tenant_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Trial_LeadsArgs = {
  objects: Array<Trial_Leads_Insert_Input>;
  on_conflict?: Maybe<Trial_Leads_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Trial_Leads_OneArgs = {
  object: Trial_Leads_Insert_Input;
  on_conflict?: Maybe<Trial_Leads_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ua_Audit_LogsArgs = {
  objects: Array<Ua_Audit_Logs_Insert_Input>;
  on_conflict?: Maybe<Ua_Audit_Logs_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Ua_Audit_Logs_OneArgs = {
  object: Ua_Audit_Logs_Insert_Input;
  on_conflict?: Maybe<Ua_Audit_Logs_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_ActivityArgs = {
  objects: Array<User_Activity_Insert_Input>;
  on_conflict?: Maybe<User_Activity_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Activity_OneArgs = {
  object: User_Activity_Insert_Input;
  on_conflict?: Maybe<User_Activity_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_CouponArgs = {
  objects: Array<User_Coupon_Insert_Input>;
  on_conflict?: Maybe<User_Coupon_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Coupon_OneArgs = {
  object: User_Coupon_Insert_Input;
  on_conflict?: Maybe<User_Coupon_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Entitlement_AccessArgs = {
  objects: Array<User_Entitlement_Access_Insert_Input>;
  on_conflict?: Maybe<User_Entitlement_Access_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Entitlement_Access_OneArgs = {
  object: User_Entitlement_Access_Insert_Input;
  on_conflict?: Maybe<User_Entitlement_Access_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Entitlement_CatalogueArgs = {
  objects: Array<User_Entitlement_Catalogue_Insert_Input>;
  on_conflict?: Maybe<User_Entitlement_Catalogue_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Entitlement_Catalogue_OneArgs = {
  object: User_Entitlement_Catalogue_Insert_Input;
  on_conflict?: Maybe<User_Entitlement_Catalogue_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Entitlement_TypesArgs = {
  objects: Array<User_Entitlement_Types_Insert_Input>;
  on_conflict?: Maybe<User_Entitlement_Types_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Entitlement_Types_OneArgs = {
  object: User_Entitlement_Types_Insert_Input;
  on_conflict?: Maybe<User_Entitlement_Types_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_OnboardingArgs = {
  objects: Array<User_Onboarding_Insert_Input>;
  on_conflict?: Maybe<User_Onboarding_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Onboarding_OneArgs = {
  object: User_Onboarding_Insert_Input;
  on_conflict?: Maybe<User_Onboarding_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Personal_Access_TokensArgs = {
  objects: Array<User_Personal_Access_Tokens_Insert_Input>;
  on_conflict?: Maybe<User_Personal_Access_Tokens_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Personal_Access_Tokens_OneArgs = {
  object: User_Personal_Access_Tokens_Insert_Input;
  on_conflict?: Maybe<User_Personal_Access_Tokens_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_ProfileArgs = {
  objects: Array<User_Profile_Insert_Input>;
  on_conflict?: Maybe<User_Profile_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Profile_OneArgs = {
  object: User_Profile_Insert_Input;
  on_conflict?: Maybe<User_Profile_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_RolesArgs = {
  objects: Array<User_Roles_Insert_Input>;
  on_conflict?: Maybe<User_Roles_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Roles_OneArgs = {
  object: User_Roles_Insert_Input;
  on_conflict?: Maybe<User_Roles_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Vpc_PolicyArgs = {
  objects: Array<User_Vpc_Policy_Insert_Input>;
  on_conflict?: Maybe<User_Vpc_Policy_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_User_Vpc_Policy_OneArgs = {
  object: User_Vpc_Policy_Insert_Input;
  on_conflict?: Maybe<User_Vpc_Policy_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_UsersArgs = {
  objects: Array<Users_Insert_Input>;
  on_conflict?: Maybe<Users_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Users_OneArgs = {
  object: Users_Insert_Input;
  on_conflict?: Maybe<Users_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Users_PublicArgs = {
  objects: Array<Users_Public_Insert_Input>;
};

/** mutation root */
export type Mutation_RootInsert_Users_Public_OneArgs = {
  object: Users_Public_Insert_Input;
};

/** mutation root */
export type Mutation_RootInsert_Vercel_IntegrationArgs = {
  objects: Array<Vercel_Integration_Insert_Input>;
  on_conflict?: Maybe<Vercel_Integration_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Vercel_Integration_ConnectionsArgs = {
  objects: Array<Vercel_Integration_Connections_Insert_Input>;
  on_conflict?: Maybe<Vercel_Integration_Connections_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Vercel_Integration_Connections_OneArgs = {
  object: Vercel_Integration_Connections_Insert_Input;
  on_conflict?: Maybe<Vercel_Integration_Connections_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Vercel_Integration_OneArgs = {
  object: Vercel_Integration_Insert_Input;
  on_conflict?: Maybe<Vercel_Integration_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Vpc_PeeringArgs = {
  objects: Array<Vpc_Peering_Insert_Input>;
  on_conflict?: Maybe<Vpc_Peering_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Vpc_Peering_DirectionArgs = {
  objects: Array<Vpc_Peering_Direction_Insert_Input>;
  on_conflict?: Maybe<Vpc_Peering_Direction_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Vpc_Peering_Direction_OneArgs = {
  object: Vpc_Peering_Direction_Insert_Input;
  on_conflict?: Maybe<Vpc_Peering_Direction_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Vpc_Peering_OneArgs = {
  object: Vpc_Peering_Insert_Input;
  on_conflict?: Maybe<Vpc_Peering_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Vpc_StatusArgs = {
  objects: Array<Vpc_Status_Insert_Input>;
  on_conflict?: Maybe<Vpc_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Vpc_Status_OneArgs = {
  object: Vpc_Status_Insert_Input;
  on_conflict?: Maybe<Vpc_Status_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Zendesk_Support_CategoryArgs = {
  objects: Array<Zendesk_Support_Category_Insert_Input>;
  on_conflict?: Maybe<Zendesk_Support_Category_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Zendesk_Support_Category_OneArgs = {
  object: Zendesk_Support_Category_Insert_Input;
  on_conflict?: Maybe<Zendesk_Support_Category_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Zendesk_Support_TicketsArgs = {
  objects: Array<Zendesk_Support_Tickets_Insert_Input>;
  on_conflict?: Maybe<Zendesk_Support_Tickets_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_Zendesk_Support_Tickets_OneArgs = {
  object: Zendesk_Support_Tickets_Insert_Input;
  on_conflict?: Maybe<Zendesk_Support_Tickets_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInviteBillingManagerArgs = {
  manager_email: Scalars['String'];
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootInviteCollaboratorArgs = {
  invite: InviteColloboratorRequest;
};

/** mutation root */
export type Mutation_RootLastMonthProjectUsageArgs = {
  args?: Maybe<ProjectUsageInput>;
};

/** mutation root */
export type Mutation_RootMoveProjectRegionArgs = {
  cloud?: Maybe<Scalars['String']>;
  projectId: Scalars['uuid'];
  region?: Maybe<Scalars['String']>;
  tenantGroupId?: Maybe<Scalars['uuid']>;
};

/** mutation root */
export type Mutation_RootNeonCreateDatabaseArgs = {
  projectId: Scalars['uuid'];
  projectName?: Maybe<Scalars['String']>;
};

/** mutation root */
export type Mutation_RootNeonExchangeOAuthTokenArgs = {
  code: Scalars['String'];
  projectId: Scalars['uuid'];
  state: Scalars['String'];
};

/** mutation root */
export type Mutation_RootNewPlansProjectUsageArgs = {
  month: Scalars['Int'];
  project_id: Scalars['uuid'];
  year: Scalars['Int'];
};

/** mutation root */
export type Mutation_RootNewPlansProjectUsagePerMonthArgs = {
  month: Scalars['Int'];
  user_id: Scalars['uuid'];
  year: Scalars['Int'];
};

/** mutation root */
export type Mutation_RootPayInvoiceArgs = {
  invoice_id: Scalars['String'];
  payment_method_id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootReactivateSuspendedProjectArgs = {
  projectId: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootRegenerateKeyArgs = {
  project: RegenerateKeyInput;
};

/** mutation root */
export type Mutation_RootRemoveGithubIntegrationArgs = {
  payload: DeleteGithubIntegrationInput;
};

/** mutation root */
export type Mutation_RootRemoveGithubSessionArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootResendBillingManagerInviteArgs = {
  manager_email: Scalars['String'];
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootResendChangeUserEmailVerificationArgs = {
  input: ChangeUserEmailRequestInput;
};

/** mutation root */
export type Mutation_RootResendInviteArgs = {
  args: ResendInvitationRequest;
};

/** mutation root */
export type Mutation_RootResendTransferOwnershipInviteArgs = {
  args: ResendTransferOwnershipInvitationRequest;
};

/** mutation root */
export type Mutation_RootRevokeChangeUserEmailRequestArgs = {
  input: ChangeUserEmailRequestInput;
};

/** mutation root */
export type Mutation_RootSaveSurveyAnswerArgs = {
  payload: SurveyAnswersPayload;
};

/** mutation root */
export type Mutation_RootSaveSurveyAnswerV2Args = {
  payload: SaveSurveyAnswerV2Payload;
};

/** mutation root */
export type Mutation_RootSetDefaultPaymentMethodArgs = {
  id: Scalars['String'];
};

/** mutation root */
export type Mutation_RootSlackExchangeOAuthTokenArgs = {
  code: Scalars['String'];
  projectId: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootTrackExperimentsCohortActivityArgs = {
  experiment: Scalars['String'];
  payload: ExperimentsCohortActivityPayload;
};

/** mutation root */
export type Mutation_RootTrackOnboardingActivityArgs = {
  payload: OnboardingActivityPayload;
};

/** mutation root */
export type Mutation_RootTrackOnboardingSampleDbCohortActivityArgs = {
  error_message?: Maybe<Scalars['String']>;
  event: Scalars['String'];
  project_id: Scalars['uuid'];
  status?: Maybe<Scalars['String']>;
};

/** mutation root */
export type Mutation_RootTransferOwnershipInviteArgs = {
  input: TransferOwnershipRequest;
};

/** mutation root */
export type Mutation_RootTriggerAnalyticsInfraModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerCentralModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerCentralMonitoringModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: Scalars['String'];
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerDataConnectorModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerDvpcInfraModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerDvpcLogsModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerDvpcMonitoringModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerDvpcOperatorModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerDvpcPeeringModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerGatewayClusterModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerHasuraClusterModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerHealthcheckModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  region: Scalars['String'];
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerLogsModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  region: Scalars['String'];
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerLuxProxyModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  region: Scalars['String'];
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerMetricsModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  region: Scalars['String'];
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerNodePoolModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  commit?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerOneClickDeploymentArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootTriggerOperatorModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  region: Scalars['String'];
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerRegionModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  region: Scalars['String'];
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerRegionMonitoringModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  region: Scalars['String'];
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerTaskqModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  region: Scalars['String'];
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerV3CentralModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerV3ServerModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  region: Scalars['String'];
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootTriggerV3SyncModuleArgs = {
  branch?: Maybe<Scalars['String']>;
  cloud: CloudProvider;
  commit?: Maybe<Scalars['String']>;
  mode: PulumiMode;
  region: Scalars['String'];
  targets?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_ConfigArgs = {
  _set?: Maybe<Alert_Config_Set_Input>;
  where: Alert_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Config_Alert_TypeArgs = {
  _set?: Maybe<Alert_Config_Alert_Type_Set_Input>;
  where: Alert_Config_Alert_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Config_Alert_Type_By_PkArgs = {
  _set?: Maybe<Alert_Config_Alert_Type_Set_Input>;
  pk_columns: Alert_Config_Alert_Type_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Config_Alert_Type_ManyArgs = {
  updates: Array<Alert_Config_Alert_Type_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Config_By_PkArgs = {
  _set?: Maybe<Alert_Config_Set_Input>;
  pk_columns: Alert_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Config_ManyArgs = {
  updates: Array<Alert_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Config_ServiceArgs = {
  _append?: Maybe<Alert_Config_Service_Append_Input>;
  _delete_at_path?: Maybe<Alert_Config_Service_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Alert_Config_Service_Delete_Elem_Input>;
  _delete_key?: Maybe<Alert_Config_Service_Delete_Key_Input>;
  _prepend?: Maybe<Alert_Config_Service_Prepend_Input>;
  _set?: Maybe<Alert_Config_Service_Set_Input>;
  where: Alert_Config_Service_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Config_Service_By_PkArgs = {
  _append?: Maybe<Alert_Config_Service_Append_Input>;
  _delete_at_path?: Maybe<Alert_Config_Service_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Alert_Config_Service_Delete_Elem_Input>;
  _delete_key?: Maybe<Alert_Config_Service_Delete_Key_Input>;
  _prepend?: Maybe<Alert_Config_Service_Prepend_Input>;
  _set?: Maybe<Alert_Config_Service_Set_Input>;
  pk_columns: Alert_Config_Service_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Config_Service_ManyArgs = {
  updates: Array<Alert_Config_Service_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Service_TypeArgs = {
  _set?: Maybe<Alert_Service_Type_Set_Input>;
  where: Alert_Service_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Service_Type_By_PkArgs = {
  _set?: Maybe<Alert_Service_Type_Set_Input>;
  pk_columns: Alert_Service_Type_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Service_Type_ManyArgs = {
  updates: Array<Alert_Service_Type_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_TypeArgs = {
  _set?: Maybe<Alert_Type_Set_Input>;
  where: Alert_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Type_By_PkArgs = {
  _set?: Maybe<Alert_Type_Set_Input>;
  pk_columns: Alert_Type_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Alert_Type_ManyArgs = {
  updates: Array<Alert_Type_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Azuremonitor_ConfigArgs = {
  _append?: Maybe<Azuremonitor_Config_Append_Input>;
  _delete_at_path?: Maybe<Azuremonitor_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Azuremonitor_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Azuremonitor_Config_Delete_Key_Input>;
  _inc?: Maybe<Azuremonitor_Config_Inc_Input>;
  _prepend?: Maybe<Azuremonitor_Config_Prepend_Input>;
  _set?: Maybe<Azuremonitor_Config_Set_Input>;
  where: Azuremonitor_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Azuremonitor_Config_By_PkArgs = {
  _append?: Maybe<Azuremonitor_Config_Append_Input>;
  _delete_at_path?: Maybe<Azuremonitor_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Azuremonitor_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Azuremonitor_Config_Delete_Key_Input>;
  _inc?: Maybe<Azuremonitor_Config_Inc_Input>;
  _prepend?: Maybe<Azuremonitor_Config_Prepend_Input>;
  _set?: Maybe<Azuremonitor_Config_Set_Input>;
  pk_columns: Azuremonitor_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Azuremonitor_Config_ManyArgs = {
  updates: Array<Azuremonitor_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Billing_AddressArgs = {
  _set?: Maybe<Billing_Address_Set_Input>;
  where: Billing_Address_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Billing_Address_By_PkArgs = {
  _set?: Maybe<Billing_Address_Set_Input>;
  pk_columns: Billing_Address_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Billing_Address_ManyArgs = {
  updates: Array<Billing_Address_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Central_CloudArgs = {
  _append?: Maybe<Central_Cloud_Append_Input>;
  _delete_at_path?: Maybe<Central_Cloud_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Central_Cloud_Delete_Elem_Input>;
  _delete_key?: Maybe<Central_Cloud_Delete_Key_Input>;
  _prepend?: Maybe<Central_Cloud_Prepend_Input>;
  _set?: Maybe<Central_Cloud_Set_Input>;
  where: Central_Cloud_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Central_Cloud_By_PkArgs = {
  _append?: Maybe<Central_Cloud_Append_Input>;
  _delete_at_path?: Maybe<Central_Cloud_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Central_Cloud_Delete_Elem_Input>;
  _delete_key?: Maybe<Central_Cloud_Delete_Key_Input>;
  _prepend?: Maybe<Central_Cloud_Prepend_Input>;
  _set?: Maybe<Central_Cloud_Set_Input>;
  pk_columns: Central_Cloud_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Central_Cloud_ManyArgs = {
  updates: Array<Central_Cloud_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Change_Email_RequestArgs = {
  _inc?: Maybe<Change_Email_Request_Inc_Input>;
  _set?: Maybe<Change_Email_Request_Set_Input>;
  where: Change_Email_Request_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Change_Email_Request_By_PkArgs = {
  _inc?: Maybe<Change_Email_Request_Inc_Input>;
  _set?: Maybe<Change_Email_Request_Set_Input>;
  pk_columns: Change_Email_Request_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Change_Email_Request_ManyArgs = {
  updates: Array<Change_Email_Request_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Cicd_Deployment_Pipeline_ConfigArgs = {
  _set?: Maybe<Cicd_Deployment_Pipeline_Config_Set_Input>;
  where: Cicd_Deployment_Pipeline_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Cicd_Deployment_Pipeline_Config_By_PkArgs = {
  _set?: Maybe<Cicd_Deployment_Pipeline_Config_Set_Input>;
  pk_columns: Cicd_Deployment_Pipeline_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Cicd_Deployment_Pipeline_Config_ManyArgs = {
  updates: Array<Cicd_Deployment_Pipeline_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Cicd_Deployment_PoolArgs = {
  _set?: Maybe<Cicd_Deployment_Pool_Set_Input>;
  where: Cicd_Deployment_Pool_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Cicd_Deployment_Pool_ManyArgs = {
  updates: Array<Cicd_Deployment_Pool_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Cicd_Deployment_Pool_MemberArgs = {
  _set?: Maybe<Cicd_Deployment_Pool_Member_Set_Input>;
  where: Cicd_Deployment_Pool_Member_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Cicd_Deployment_Pool_Member_ManyArgs = {
  updates: Array<Cicd_Deployment_Pool_Member_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_CloudArgs = {
  _set?: Maybe<Cloud_Set_Input>;
  where: Cloud_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Cloud_By_PkArgs = {
  _set?: Maybe<Cloud_Set_Input>;
  pk_columns: Cloud_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Cloud_ManyArgs = {
  updates: Array<Cloud_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Cloud_MetadataArgs = {
  _append?: Maybe<Cloud_Metadata_Append_Input>;
  _delete_at_path?: Maybe<Cloud_Metadata_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Cloud_Metadata_Delete_Elem_Input>;
  _delete_key?: Maybe<Cloud_Metadata_Delete_Key_Input>;
  _prepend?: Maybe<Cloud_Metadata_Prepend_Input>;
  _set?: Maybe<Cloud_Metadata_Set_Input>;
  where: Cloud_Metadata_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Cloud_Metadata_By_PkArgs = {
  _append?: Maybe<Cloud_Metadata_Append_Input>;
  _delete_at_path?: Maybe<Cloud_Metadata_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Cloud_Metadata_Delete_Elem_Input>;
  _delete_key?: Maybe<Cloud_Metadata_Delete_Key_Input>;
  _prepend?: Maybe<Cloud_Metadata_Prepend_Input>;
  _set?: Maybe<Cloud_Metadata_Set_Input>;
  pk_columns: Cloud_Metadata_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Cloud_Metadata_ManyArgs = {
  updates: Array<Cloud_Metadata_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Compute_Unit_ConfigArgs = {
  _append?: Maybe<Compute_Unit_Config_Append_Input>;
  _delete_at_path?: Maybe<Compute_Unit_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Compute_Unit_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Compute_Unit_Config_Delete_Key_Input>;
  _prepend?: Maybe<Compute_Unit_Config_Prepend_Input>;
  _set?: Maybe<Compute_Unit_Config_Set_Input>;
  where: Compute_Unit_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Compute_Unit_Config_By_PkArgs = {
  _append?: Maybe<Compute_Unit_Config_Append_Input>;
  _delete_at_path?: Maybe<Compute_Unit_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Compute_Unit_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Compute_Unit_Config_Delete_Key_Input>;
  _prepend?: Maybe<Compute_Unit_Config_Prepend_Input>;
  _set?: Maybe<Compute_Unit_Config_Set_Input>;
  pk_columns: Compute_Unit_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Compute_Unit_Config_ManyArgs = {
  updates: Array<Compute_Unit_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_ConfigArgs = {
  _set?: Maybe<Config_Set_Input>;
  where: Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Config_By_PkArgs = {
  _set?: Maybe<Config_Set_Input>;
  pk_columns: Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Config_ManyArgs = {
  updates: Array<Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Config_StatusArgs = {
  _set?: Maybe<Config_Status_Set_Input>;
  where: Config_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Config_Status_By_PkArgs = {
  _set?: Maybe<Config_Status_Set_Input>;
  pk_columns: Config_Status_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Config_Status_ManyArgs = {
  updates: Array<Config_Status_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Connector_ConfigArgs = {
  _set?: Maybe<Connector_Config_Set_Input>;
  where: Connector_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Connector_Config_By_PkArgs = {
  _set?: Maybe<Connector_Config_Set_Input>;
  pk_columns: Connector_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Connector_Config_ManyArgs = {
  updates: Array<Connector_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Connector_DeploymentsArgs = {
  _set?: Maybe<Connector_Deployments_Set_Input>;
  where: Connector_Deployments_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Connector_Deployments_By_PkArgs = {
  _set?: Maybe<Connector_Deployments_Set_Input>;
  pk_columns: Connector_Deployments_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Connector_Deployments_ManyArgs = {
  updates: Array<Connector_Deployments_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_CouponArgs = {
  _append?: Maybe<Coupon_Append_Input>;
  _delete_at_path?: Maybe<Coupon_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Coupon_Delete_Elem_Input>;
  _delete_key?: Maybe<Coupon_Delete_Key_Input>;
  _inc?: Maybe<Coupon_Inc_Input>;
  _prepend?: Maybe<Coupon_Prepend_Input>;
  _set?: Maybe<Coupon_Set_Input>;
  where: Coupon_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Coupon_By_PkArgs = {
  _append?: Maybe<Coupon_Append_Input>;
  _delete_at_path?: Maybe<Coupon_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Coupon_Delete_Elem_Input>;
  _delete_key?: Maybe<Coupon_Delete_Key_Input>;
  _inc?: Maybe<Coupon_Inc_Input>;
  _prepend?: Maybe<Coupon_Prepend_Input>;
  _set?: Maybe<Coupon_Set_Input>;
  pk_columns: Coupon_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Coupon_DurationArgs = {
  _set?: Maybe<Coupon_Duration_Set_Input>;
  where: Coupon_Duration_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Coupon_Duration_By_PkArgs = {
  _set?: Maybe<Coupon_Duration_Set_Input>;
  pk_columns: Coupon_Duration_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Coupon_Duration_ManyArgs = {
  updates: Array<Coupon_Duration_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Coupon_ManyArgs = {
  updates: Array<Coupon_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Coupon_TypeArgs = {
  _set?: Maybe<Coupon_Type_Set_Input>;
  where: Coupon_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Coupon_Type_By_PkArgs = {
  _set?: Maybe<Coupon_Type_Set_Input>;
  pk_columns: Coupon_Type_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Coupon_Type_ManyArgs = {
  updates: Array<Coupon_Type_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Custom_DomainArgs = {
  _set?: Maybe<Custom_Domain_Set_Input>;
  where: Custom_Domain_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Custom_Domain_By_PkArgs = {
  _set?: Maybe<Custom_Domain_Set_Input>;
  pk_columns: Custom_Domain_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Custom_Domain_CloudflareArgs = {
  _append?: Maybe<Custom_Domain_Cloudflare_Append_Input>;
  _delete_at_path?: Maybe<Custom_Domain_Cloudflare_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Custom_Domain_Cloudflare_Delete_Elem_Input>;
  _delete_key?: Maybe<Custom_Domain_Cloudflare_Delete_Key_Input>;
  _prepend?: Maybe<Custom_Domain_Cloudflare_Prepend_Input>;
  _set?: Maybe<Custom_Domain_Cloudflare_Set_Input>;
  where: Custom_Domain_Cloudflare_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Custom_Domain_Cloudflare_By_PkArgs = {
  _append?: Maybe<Custom_Domain_Cloudflare_Append_Input>;
  _delete_at_path?: Maybe<Custom_Domain_Cloudflare_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Custom_Domain_Cloudflare_Delete_Elem_Input>;
  _delete_key?: Maybe<Custom_Domain_Cloudflare_Delete_Key_Input>;
  _prepend?: Maybe<Custom_Domain_Cloudflare_Prepend_Input>;
  _set?: Maybe<Custom_Domain_Cloudflare_Set_Input>;
  pk_columns: Custom_Domain_Cloudflare_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Custom_Domain_Cloudflare_DnsArgs = {
  _set?: Maybe<Custom_Domain_Cloudflare_Dns_Set_Input>;
  where: Custom_Domain_Cloudflare_Dns_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Custom_Domain_Cloudflare_Dns_By_PkArgs = {
  _set?: Maybe<Custom_Domain_Cloudflare_Dns_Set_Input>;
  pk_columns: Custom_Domain_Cloudflare_Dns_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Custom_Domain_Cloudflare_Dns_ManyArgs = {
  updates: Array<Custom_Domain_Cloudflare_Dns_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Custom_Domain_Cloudflare_ManyArgs = {
  updates: Array<Custom_Domain_Cloudflare_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Custom_Domain_ManyArgs = {
  updates: Array<Custom_Domain_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Customer_UsageArgs = {
  _inc?: Maybe<Customer_Usage_Inc_Input>;
  _set?: Maybe<Customer_Usage_Set_Input>;
  where: Customer_Usage_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Customer_Usage_By_PkArgs = {
  _inc?: Maybe<Customer_Usage_Inc_Input>;
  _set?: Maybe<Customer_Usage_Set_Input>;
  pk_columns: Customer_Usage_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Customer_Usage_ManyArgs = {
  updates: Array<Customer_Usage_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Data_Connector_TypeArgs = {
  _set?: Maybe<Data_Connector_Type_Set_Input>;
  where: Data_Connector_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Data_Connector_Type_By_PkArgs = {
  _set?: Maybe<Data_Connector_Type_Set_Input>;
  pk_columns: Data_Connector_Type_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Data_Connector_Type_ManyArgs = {
  updates: Array<Data_Connector_Type_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Datadog_ConfigArgs = {
  _inc?: Maybe<Datadog_Config_Inc_Input>;
  _set?: Maybe<Datadog_Config_Set_Input>;
  where: Datadog_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Datadog_Config_By_PkArgs = {
  _inc?: Maybe<Datadog_Config_Inc_Input>;
  _set?: Maybe<Datadog_Config_Set_Input>;
  pk_columns: Datadog_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Datadog_Config_ManyArgs = {
  updates: Array<Datadog_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Db_LatencyArgs = {
  _inc?: Maybe<Db_Latency_Inc_Input>;
  _set?: Maybe<Db_Latency_Set_Input>;
  where: Db_Latency_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Db_Latency_By_PkArgs = {
  _inc?: Maybe<Db_Latency_Inc_Input>;
  _set?: Maybe<Db_Latency_Set_Input>;
  pk_columns: Db_Latency_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Db_Latency_ManyArgs = {
  updates: Array<Db_Latency_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_BuildArgs = {
  _append?: Maybe<Ddn_Build_Append_Input>;
  _delete_at_path?: Maybe<Ddn_Build_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Ddn_Build_Delete_Elem_Input>;
  _delete_key?: Maybe<Ddn_Build_Delete_Key_Input>;
  _prepend?: Maybe<Ddn_Build_Prepend_Input>;
  _set?: Maybe<Ddn_Build_Set_Input>;
  where: Ddn_Build_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Build_By_PkArgs = {
  _append?: Maybe<Ddn_Build_Append_Input>;
  _delete_at_path?: Maybe<Ddn_Build_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Ddn_Build_Delete_Elem_Input>;
  _delete_key?: Maybe<Ddn_Build_Delete_Key_Input>;
  _prepend?: Maybe<Ddn_Build_Prepend_Input>;
  _set?: Maybe<Ddn_Build_Set_Input>;
  pk_columns: Ddn_Build_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Build_ManyArgs = {
  updates: Array<Ddn_Build_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Build_Sync_StatusArgs = {
  _set?: Maybe<Ddn_Build_Sync_Status_Set_Input>;
  where: Ddn_Build_Sync_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Build_Sync_Status_By_PkArgs = {
  _set?: Maybe<Ddn_Build_Sync_Status_Set_Input>;
  pk_columns: Ddn_Build_Sync_Status_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Build_Sync_Status_ManyArgs = {
  updates: Array<Ddn_Build_Sync_Status_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Build_Sync_WorkerArgs = {
  _set?: Maybe<Ddn_Build_Sync_Worker_Set_Input>;
  where: Ddn_Build_Sync_Worker_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Build_Sync_Worker_By_PkArgs = {
  _set?: Maybe<Ddn_Build_Sync_Worker_Set_Input>;
  pk_columns: Ddn_Build_Sync_Worker_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Build_Sync_Worker_ManyArgs = {
  updates: Array<Ddn_Build_Sync_Worker_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_EnvironmentArgs = {
  _set?: Maybe<Ddn_Environment_Set_Input>;
  where: Ddn_Environment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Environment_By_PkArgs = {
  _set?: Maybe<Ddn_Environment_Set_Input>;
  pk_columns: Ddn_Environment_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Environment_ManyArgs = {
  updates: Array<Ddn_Environment_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Project_Entitlement_AccessArgs = {
  _set?: Maybe<Ddn_Project_Entitlement_Access_Set_Input>;
  where: Ddn_Project_Entitlement_Access_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Project_Entitlement_Access_By_PkArgs = {
  _set?: Maybe<Ddn_Project_Entitlement_Access_Set_Input>;
  pk_columns: Ddn_Project_Entitlement_Access_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Project_Entitlement_Access_ManyArgs = {
  updates: Array<Ddn_Project_Entitlement_Access_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Project_Entitlement_CatalogueArgs = {
  _inc?: Maybe<Ddn_Project_Entitlement_Catalogue_Inc_Input>;
  _set?: Maybe<Ddn_Project_Entitlement_Catalogue_Set_Input>;
  where: Ddn_Project_Entitlement_Catalogue_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Project_Entitlement_Catalogue_By_PkArgs = {
  _inc?: Maybe<Ddn_Project_Entitlement_Catalogue_Inc_Input>;
  _set?: Maybe<Ddn_Project_Entitlement_Catalogue_Set_Input>;
  pk_columns: Ddn_Project_Entitlement_Catalogue_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Project_Entitlement_Catalogue_ManyArgs = {
  updates: Array<Ddn_Project_Entitlement_Catalogue_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Project_Entitlement_TypesArgs = {
  _set?: Maybe<Ddn_Project_Entitlement_Types_Set_Input>;
  where: Ddn_Project_Entitlement_Types_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Project_Entitlement_Types_By_PkArgs = {
  _set?: Maybe<Ddn_Project_Entitlement_Types_Set_Input>;
  pk_columns: Ddn_Project_Entitlement_Types_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Project_Entitlement_Types_ManyArgs = {
  updates: Array<Ddn_Project_Entitlement_Types_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_ProjectsArgs = {
  _set?: Maybe<Ddn_Projects_Set_Input>;
  where: Ddn_Projects_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Projects_By_PkArgs = {
  _set?: Maybe<Ddn_Projects_Set_Input>;
  pk_columns: Ddn_Projects_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Projects_ManyArgs = {
  updates: Array<Ddn_Projects_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_TunnelArgs = {
  _inc?: Maybe<Ddn_Tunnel_Inc_Input>;
  _set?: Maybe<Ddn_Tunnel_Set_Input>;
  where: Ddn_Tunnel_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Tunnel_By_PkArgs = {
  _inc?: Maybe<Ddn_Tunnel_Inc_Input>;
  _set?: Maybe<Ddn_Tunnel_Set_Input>;
  pk_columns: Ddn_Tunnel_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Tunnel_ClusterArgs = {
  _set?: Maybe<Ddn_Tunnel_Cluster_Set_Input>;
  where: Ddn_Tunnel_Cluster_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Tunnel_Cluster_By_PkArgs = {
  _set?: Maybe<Ddn_Tunnel_Cluster_Set_Input>;
  pk_columns: Ddn_Tunnel_Cluster_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Tunnel_Cluster_ManyArgs = {
  updates: Array<Ddn_Tunnel_Cluster_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Ddn_Tunnel_ManyArgs = {
  updates: Array<Ddn_Tunnel_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_Cloud_BillsArgs = {
  _append?: Maybe<Dedicated_Cloud_Bills_Append_Input>;
  _delete_at_path?: Maybe<Dedicated_Cloud_Bills_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Dedicated_Cloud_Bills_Delete_Elem_Input>;
  _delete_key?: Maybe<Dedicated_Cloud_Bills_Delete_Key_Input>;
  _inc?: Maybe<Dedicated_Cloud_Bills_Inc_Input>;
  _prepend?: Maybe<Dedicated_Cloud_Bills_Prepend_Input>;
  _set?: Maybe<Dedicated_Cloud_Bills_Set_Input>;
  where: Dedicated_Cloud_Bills_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_Cloud_Bills_By_PkArgs = {
  _append?: Maybe<Dedicated_Cloud_Bills_Append_Input>;
  _delete_at_path?: Maybe<Dedicated_Cloud_Bills_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Dedicated_Cloud_Bills_Delete_Elem_Input>;
  _delete_key?: Maybe<Dedicated_Cloud_Bills_Delete_Key_Input>;
  _inc?: Maybe<Dedicated_Cloud_Bills_Inc_Input>;
  _prepend?: Maybe<Dedicated_Cloud_Bills_Prepend_Input>;
  _set?: Maybe<Dedicated_Cloud_Bills_Set_Input>;
  pk_columns: Dedicated_Cloud_Bills_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_Cloud_Bills_DetailsArgs = {
  _append?: Maybe<Dedicated_Cloud_Bills_Details_Append_Input>;
  _delete_at_path?: Maybe<Dedicated_Cloud_Bills_Details_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Dedicated_Cloud_Bills_Details_Delete_Elem_Input>;
  _delete_key?: Maybe<Dedicated_Cloud_Bills_Details_Delete_Key_Input>;
  _inc?: Maybe<Dedicated_Cloud_Bills_Details_Inc_Input>;
  _prepend?: Maybe<Dedicated_Cloud_Bills_Details_Prepend_Input>;
  _set?: Maybe<Dedicated_Cloud_Bills_Details_Set_Input>;
  where: Dedicated_Cloud_Bills_Details_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_Cloud_Bills_Details_By_PkArgs = {
  _append?: Maybe<Dedicated_Cloud_Bills_Details_Append_Input>;
  _delete_at_path?: Maybe<Dedicated_Cloud_Bills_Details_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Dedicated_Cloud_Bills_Details_Delete_Elem_Input>;
  _delete_key?: Maybe<Dedicated_Cloud_Bills_Details_Delete_Key_Input>;
  _inc?: Maybe<Dedicated_Cloud_Bills_Details_Inc_Input>;
  _prepend?: Maybe<Dedicated_Cloud_Bills_Details_Prepend_Input>;
  _set?: Maybe<Dedicated_Cloud_Bills_Details_Set_Input>;
  pk_columns: Dedicated_Cloud_Bills_Details_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_Cloud_Bills_Details_ManyArgs = {
  updates: Array<Dedicated_Cloud_Bills_Details_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_Cloud_Bills_ManyArgs = {
  updates: Array<Dedicated_Cloud_Bills_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_Cloud_CommitmentsArgs = {
  _inc?: Maybe<Dedicated_Cloud_Commitments_Inc_Input>;
  _set?: Maybe<Dedicated_Cloud_Commitments_Set_Input>;
  where: Dedicated_Cloud_Commitments_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_Cloud_Commitments_By_PkArgs = {
  _inc?: Maybe<Dedicated_Cloud_Commitments_Inc_Input>;
  _set?: Maybe<Dedicated_Cloud_Commitments_Set_Input>;
  pk_columns: Dedicated_Cloud_Commitments_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_Cloud_Commitments_ManyArgs = {
  updates: Array<Dedicated_Cloud_Commitments_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_VpcArgs = {
  _append?: Maybe<Dedicated_Vpc_Append_Input>;
  _delete_at_path?: Maybe<Dedicated_Vpc_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Dedicated_Vpc_Delete_Elem_Input>;
  _delete_key?: Maybe<Dedicated_Vpc_Delete_Key_Input>;
  _inc?: Maybe<Dedicated_Vpc_Inc_Input>;
  _prepend?: Maybe<Dedicated_Vpc_Prepend_Input>;
  _set?: Maybe<Dedicated_Vpc_Set_Input>;
  where: Dedicated_Vpc_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_Vpc_By_PkArgs = {
  _append?: Maybe<Dedicated_Vpc_Append_Input>;
  _delete_at_path?: Maybe<Dedicated_Vpc_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Dedicated_Vpc_Delete_Elem_Input>;
  _delete_key?: Maybe<Dedicated_Vpc_Delete_Key_Input>;
  _inc?: Maybe<Dedicated_Vpc_Inc_Input>;
  _prepend?: Maybe<Dedicated_Vpc_Prepend_Input>;
  _set?: Maybe<Dedicated_Vpc_Set_Input>;
  pk_columns: Dedicated_Vpc_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Dedicated_Vpc_ManyArgs = {
  updates: Array<Dedicated_Vpc_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Delete_UserArgs = {
  _set?: Maybe<Delete_User_Set_Input>;
  where: Delete_User_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Delete_User_By_PkArgs = {
  _set?: Maybe<Delete_User_Set_Input>;
  pk_columns: Delete_User_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Delete_User_ManyArgs = {
  updates: Array<Delete_User_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Delete_User_StatusArgs = {
  _set?: Maybe<Delete_User_Status_Set_Input>;
  where: Delete_User_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Delete_User_Status_By_PkArgs = {
  _set?: Maybe<Delete_User_Status_Set_Input>;
  pk_columns: Delete_User_Status_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Delete_User_Status_ManyArgs = {
  updates: Array<Delete_User_Status_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Delete_User_TasksArgs = {
  _append?: Maybe<Delete_User_Tasks_Append_Input>;
  _delete_at_path?: Maybe<Delete_User_Tasks_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Delete_User_Tasks_Delete_Elem_Input>;
  _delete_key?: Maybe<Delete_User_Tasks_Delete_Key_Input>;
  _inc?: Maybe<Delete_User_Tasks_Inc_Input>;
  _prepend?: Maybe<Delete_User_Tasks_Prepend_Input>;
  _set?: Maybe<Delete_User_Tasks_Set_Input>;
  where: Delete_User_Tasks_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Delete_User_Tasks_By_PkArgs = {
  _append?: Maybe<Delete_User_Tasks_Append_Input>;
  _delete_at_path?: Maybe<Delete_User_Tasks_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Delete_User_Tasks_Delete_Elem_Input>;
  _delete_key?: Maybe<Delete_User_Tasks_Delete_Key_Input>;
  _inc?: Maybe<Delete_User_Tasks_Inc_Input>;
  _prepend?: Maybe<Delete_User_Tasks_Prepend_Input>;
  _set?: Maybe<Delete_User_Tasks_Set_Input>;
  pk_columns: Delete_User_Tasks_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Delete_User_Tasks_ManyArgs = {
  updates: Array<Delete_User_Tasks_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Email_LogArgs = {
  _append?: Maybe<Email_Log_Append_Input>;
  _delete_at_path?: Maybe<Email_Log_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Email_Log_Delete_Elem_Input>;
  _delete_key?: Maybe<Email_Log_Delete_Key_Input>;
  _prepend?: Maybe<Email_Log_Prepend_Input>;
  _set?: Maybe<Email_Log_Set_Input>;
  where: Email_Log_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Email_Log_By_PkArgs = {
  _append?: Maybe<Email_Log_Append_Input>;
  _delete_at_path?: Maybe<Email_Log_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Email_Log_Delete_Elem_Input>;
  _delete_key?: Maybe<Email_Log_Delete_Key_Input>;
  _prepend?: Maybe<Email_Log_Prepend_Input>;
  _set?: Maybe<Email_Log_Set_Input>;
  pk_columns: Email_Log_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Email_Log_ManyArgs = {
  updates: Array<Email_Log_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Enterprise_UsersArgs = {
  _inc?: Maybe<Enterprise_Users_Inc_Input>;
  _set?: Maybe<Enterprise_Users_Set_Input>;
  where: Enterprise_Users_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Enterprise_Users_By_PkArgs = {
  _inc?: Maybe<Enterprise_Users_Inc_Input>;
  _set?: Maybe<Enterprise_Users_Set_Input>;
  pk_columns: Enterprise_Users_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Enterprise_Users_ManyArgs = {
  updates: Array<Enterprise_Users_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_ExperimentsArgs = {
  _set?: Maybe<Experiments_Set_Input>;
  where: Experiments_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Experiments_By_PkArgs = {
  _set?: Maybe<Experiments_Set_Input>;
  pk_columns: Experiments_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Experiments_CohortArgs = {
  _append?: Maybe<Experiments_Cohort_Append_Input>;
  _delete_at_path?: Maybe<Experiments_Cohort_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Experiments_Cohort_Delete_Elem_Input>;
  _delete_key?: Maybe<Experiments_Cohort_Delete_Key_Input>;
  _prepend?: Maybe<Experiments_Cohort_Prepend_Input>;
  _set?: Maybe<Experiments_Cohort_Set_Input>;
  where: Experiments_Cohort_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Experiments_Cohort_By_PkArgs = {
  _append?: Maybe<Experiments_Cohort_Append_Input>;
  _delete_at_path?: Maybe<Experiments_Cohort_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Experiments_Cohort_Delete_Elem_Input>;
  _delete_key?: Maybe<Experiments_Cohort_Delete_Key_Input>;
  _prepend?: Maybe<Experiments_Cohort_Prepend_Input>;
  _set?: Maybe<Experiments_Cohort_Set_Input>;
  pk_columns: Experiments_Cohort_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Experiments_Cohort_ManyArgs = {
  updates: Array<Experiments_Cohort_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Experiments_ConfigArgs = {
  _append?: Maybe<Experiments_Config_Append_Input>;
  _delete_at_path?: Maybe<Experiments_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Experiments_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Experiments_Config_Delete_Key_Input>;
  _inc?: Maybe<Experiments_Config_Inc_Input>;
  _prepend?: Maybe<Experiments_Config_Prepend_Input>;
  _set?: Maybe<Experiments_Config_Set_Input>;
  where: Experiments_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Experiments_Config_By_PkArgs = {
  _append?: Maybe<Experiments_Config_Append_Input>;
  _delete_at_path?: Maybe<Experiments_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Experiments_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Experiments_Config_Delete_Key_Input>;
  _inc?: Maybe<Experiments_Config_Inc_Input>;
  _prepend?: Maybe<Experiments_Config_Prepend_Input>;
  _set?: Maybe<Experiments_Config_Set_Input>;
  pk_columns: Experiments_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Experiments_Config_ManyArgs = {
  updates: Array<Experiments_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Experiments_ManyArgs = {
  updates: Array<Experiments_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_FeatureArgs = {
  _set?: Maybe<Feature_Set_Input>;
  where: Feature_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Feature_AccessArgs = {
  _set?: Maybe<Feature_Access_Set_Input>;
  where: Feature_Access_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Feature_Access_By_PkArgs = {
  _set?: Maybe<Feature_Access_Set_Input>;
  pk_columns: Feature_Access_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Feature_Access_ManyArgs = {
  updates: Array<Feature_Access_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Feature_By_PkArgs = {
  _set?: Maybe<Feature_Set_Input>;
  pk_columns: Feature_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Feature_ConfigArgs = {
  _append?: Maybe<Feature_Config_Append_Input>;
  _delete_at_path?: Maybe<Feature_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Feature_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Feature_Config_Delete_Key_Input>;
  _inc?: Maybe<Feature_Config_Inc_Input>;
  _prepend?: Maybe<Feature_Config_Prepend_Input>;
  _set?: Maybe<Feature_Config_Set_Input>;
  where: Feature_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Feature_Config_By_PkArgs = {
  _append?: Maybe<Feature_Config_Append_Input>;
  _delete_at_path?: Maybe<Feature_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Feature_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Feature_Config_Delete_Key_Input>;
  _inc?: Maybe<Feature_Config_Inc_Input>;
  _prepend?: Maybe<Feature_Config_Prepend_Input>;
  _set?: Maybe<Feature_Config_Set_Input>;
  pk_columns: Feature_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Feature_Config_ManyArgs = {
  updates: Array<Feature_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Feature_ManyArgs = {
  updates: Array<Feature_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Gateway_AmiArgs = {
  _set?: Maybe<Gateway_Ami_Set_Input>;
  where: Gateway_Ami_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Gateway_Ami_By_PkArgs = {
  _set?: Maybe<Gateway_Ami_Set_Input>;
  pk_columns: Gateway_Ami_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Gateway_Ami_ManyArgs = {
  updates: Array<Gateway_Ami_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Gateway_ClusterArgs = {
  _append?: Maybe<Gateway_Cluster_Append_Input>;
  _delete_at_path?: Maybe<Gateway_Cluster_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Gateway_Cluster_Delete_Elem_Input>;
  _delete_key?: Maybe<Gateway_Cluster_Delete_Key_Input>;
  _prepend?: Maybe<Gateway_Cluster_Prepend_Input>;
  _set?: Maybe<Gateway_Cluster_Set_Input>;
  where: Gateway_Cluster_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Gateway_Cluster_By_PkArgs = {
  _append?: Maybe<Gateway_Cluster_Append_Input>;
  _delete_at_path?: Maybe<Gateway_Cluster_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Gateway_Cluster_Delete_Elem_Input>;
  _delete_key?: Maybe<Gateway_Cluster_Delete_Key_Input>;
  _prepend?: Maybe<Gateway_Cluster_Prepend_Input>;
  _set?: Maybe<Gateway_Cluster_Set_Input>;
  pk_columns: Gateway_Cluster_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Gateway_Cluster_ManyArgs = {
  updates: Array<Gateway_Cluster_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Gateway_WorkerArgs = {
  _set?: Maybe<Gateway_Worker_Set_Input>;
  where: Gateway_Worker_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Gateway_Worker_By_PkArgs = {
  _set?: Maybe<Gateway_Worker_Set_Input>;
  pk_columns: Gateway_Worker_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Gateway_Worker_ManyArgs = {
  updates: Array<Gateway_Worker_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Email_TypeArgs = {
  _set?: Maybe<Github_Email_Type_Set_Input>;
  where: Github_Email_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Email_Type_By_PkArgs = {
  _set?: Maybe<Github_Email_Type_Set_Input>;
  pk_columns: Github_Email_Type_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Email_Type_ManyArgs = {
  updates: Array<Github_Email_Type_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Integration_ConfigArgs = {
  _inc?: Maybe<Github_Integration_Config_Inc_Input>;
  _set?: Maybe<Github_Integration_Config_Set_Input>;
  where: Github_Integration_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Integration_Config_By_PkArgs = {
  _inc?: Maybe<Github_Integration_Config_Inc_Input>;
  _set?: Maybe<Github_Integration_Config_Set_Input>;
  pk_columns: Github_Integration_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Integration_Config_ManyArgs = {
  updates: Array<Github_Integration_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Integration_ModeArgs = {
  _set?: Maybe<Github_Integration_Mode_Set_Input>;
  where: Github_Integration_Mode_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Integration_Mode_By_PkArgs = {
  _set?: Maybe<Github_Integration_Mode_Set_Input>;
  pk_columns: Github_Integration_Mode_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Integration_Mode_ManyArgs = {
  updates: Array<Github_Integration_Mode_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Push_EventArgs = {
  _append?: Maybe<Github_Push_Event_Append_Input>;
  _delete_at_path?: Maybe<Github_Push_Event_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Github_Push_Event_Delete_Elem_Input>;
  _delete_key?: Maybe<Github_Push_Event_Delete_Key_Input>;
  _prepend?: Maybe<Github_Push_Event_Prepend_Input>;
  _set?: Maybe<Github_Push_Event_Set_Input>;
  where: Github_Push_Event_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Push_Event_By_PkArgs = {
  _append?: Maybe<Github_Push_Event_Append_Input>;
  _delete_at_path?: Maybe<Github_Push_Event_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Github_Push_Event_Delete_Elem_Input>;
  _delete_key?: Maybe<Github_Push_Event_Delete_Key_Input>;
  _prepend?: Maybe<Github_Push_Event_Prepend_Input>;
  _set?: Maybe<Github_Push_Event_Set_Input>;
  pk_columns: Github_Push_Event_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Push_Event_JobArgs = {
  _set?: Maybe<Github_Push_Event_Job_Set_Input>;
  where: Github_Push_Event_Job_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Push_Event_Job_By_PkArgs = {
  _set?: Maybe<Github_Push_Event_Job_Set_Input>;
  pk_columns: Github_Push_Event_Job_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Push_Event_Job_ManyArgs = {
  updates: Array<Github_Push_Event_Job_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Github_Push_Event_ManyArgs = {
  updates: Array<Github_Push_Event_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Hasura_AmiArgs = {
  _append?: Maybe<Hasura_Ami_Append_Input>;
  _delete_at_path?: Maybe<Hasura_Ami_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Hasura_Ami_Delete_Elem_Input>;
  _delete_key?: Maybe<Hasura_Ami_Delete_Key_Input>;
  _inc?: Maybe<Hasura_Ami_Inc_Input>;
  _prepend?: Maybe<Hasura_Ami_Prepend_Input>;
  _set?: Maybe<Hasura_Ami_Set_Input>;
  where: Hasura_Ami_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Hasura_Ami_By_PkArgs = {
  _append?: Maybe<Hasura_Ami_Append_Input>;
  _delete_at_path?: Maybe<Hasura_Ami_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Hasura_Ami_Delete_Elem_Input>;
  _delete_key?: Maybe<Hasura_Ami_Delete_Key_Input>;
  _inc?: Maybe<Hasura_Ami_Inc_Input>;
  _prepend?: Maybe<Hasura_Ami_Prepend_Input>;
  _set?: Maybe<Hasura_Ami_Set_Input>;
  pk_columns: Hasura_Ami_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Hasura_Ami_ManyArgs = {
  updates: Array<Hasura_Ami_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Hasura_ClusterArgs = {
  _append?: Maybe<Hasura_Cluster_Append_Input>;
  _delete_at_path?: Maybe<Hasura_Cluster_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Hasura_Cluster_Delete_Elem_Input>;
  _delete_key?: Maybe<Hasura_Cluster_Delete_Key_Input>;
  _prepend?: Maybe<Hasura_Cluster_Prepend_Input>;
  _set?: Maybe<Hasura_Cluster_Set_Input>;
  where: Hasura_Cluster_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Hasura_Cluster_By_PkArgs = {
  _append?: Maybe<Hasura_Cluster_Append_Input>;
  _delete_at_path?: Maybe<Hasura_Cluster_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Hasura_Cluster_Delete_Elem_Input>;
  _delete_key?: Maybe<Hasura_Cluster_Delete_Key_Input>;
  _prepend?: Maybe<Hasura_Cluster_Prepend_Input>;
  _set?: Maybe<Hasura_Cluster_Set_Input>;
  pk_columns: Hasura_Cluster_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Hasura_Cluster_ManyArgs = {
  updates: Array<Hasura_Cluster_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Hasura_WorkerArgs = {
  _set?: Maybe<Hasura_Worker_Set_Input>;
  where: Hasura_Worker_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Hasura_Worker_By_PkArgs = {
  _set?: Maybe<Hasura_Worker_Set_Input>;
  pk_columns: Hasura_Worker_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Hasura_Worker_ManyArgs = {
  updates: Array<Hasura_Worker_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Heroku_IntegrationsArgs = {
  _set?: Maybe<Heroku_Integrations_Set_Input>;
  where: Heroku_Integrations_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Heroku_Integrations_By_PkArgs = {
  _set?: Maybe<Heroku_Integrations_Set_Input>;
  pk_columns: Heroku_Integrations_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Heroku_Integrations_ManyArgs = {
  updates: Array<Heroku_Integrations_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Inactive_Project_ExclusionsArgs = {
  _set?: Maybe<Inactive_Project_Exclusions_Set_Input>;
  where: Inactive_Project_Exclusions_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Inactive_Project_Exclusions_By_PkArgs = {
  _set?: Maybe<Inactive_Project_Exclusions_Set_Input>;
  pk_columns: Inactive_Project_Exclusions_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Inactive_Project_Exclusions_ManyArgs = {
  updates: Array<Inactive_Project_Exclusions_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Inactive_Project_NotificationsArgs = {
  _inc?: Maybe<Inactive_Project_Notifications_Inc_Input>;
  _set?: Maybe<Inactive_Project_Notifications_Set_Input>;
  where: Inactive_Project_Notifications_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Inactive_Project_Notifications_By_PkArgs = {
  _inc?: Maybe<Inactive_Project_Notifications_Inc_Input>;
  _set?: Maybe<Inactive_Project_Notifications_Set_Input>;
  pk_columns: Inactive_Project_Notifications_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Inactive_Project_Notifications_ManyArgs = {
  updates: Array<Inactive_Project_Notifications_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Inactive_Project_Suspension_ConfigArgs = {
  _inc?: Maybe<Inactive_Project_Suspension_Config_Inc_Input>;
  _set?: Maybe<Inactive_Project_Suspension_Config_Set_Input>;
  where: Inactive_Project_Suspension_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Inactive_Project_Suspension_Config_ManyArgs = {
  updates: Array<Inactive_Project_Suspension_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Infra_StatusArgs = {
  _set?: Maybe<Infra_Status_Set_Input>;
  where: Infra_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Infra_Status_By_PkArgs = {
  _set?: Maybe<Infra_Status_Set_Input>;
  pk_columns: Infra_Status_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Infra_Status_ManyArgs = {
  updates: Array<Infra_Status_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_InvoiceArgs = {
  _inc?: Maybe<Invoice_Inc_Input>;
  _set?: Maybe<Invoice_Set_Input>;
  where: Invoice_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Invoice_By_PkArgs = {
  _inc?: Maybe<Invoice_Inc_Input>;
  _set?: Maybe<Invoice_Set_Input>;
  pk_columns: Invoice_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Invoice_Coupon_DiscountArgs = {
  _inc?: Maybe<Invoice_Coupon_Discount_Inc_Input>;
  _set?: Maybe<Invoice_Coupon_Discount_Set_Input>;
  where: Invoice_Coupon_Discount_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Invoice_Coupon_Discount_By_PkArgs = {
  _inc?: Maybe<Invoice_Coupon_Discount_Inc_Input>;
  _set?: Maybe<Invoice_Coupon_Discount_Set_Input>;
  pk_columns: Invoice_Coupon_Discount_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Invoice_Coupon_Discount_ManyArgs = {
  updates: Array<Invoice_Coupon_Discount_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Invoice_ItemArgs = {
  _inc?: Maybe<Invoice_Item_Inc_Input>;
  _set?: Maybe<Invoice_Item_Set_Input>;
  where: Invoice_Item_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Invoice_Item_By_PkArgs = {
  _inc?: Maybe<Invoice_Item_Inc_Input>;
  _set?: Maybe<Invoice_Item_Set_Input>;
  pk_columns: Invoice_Item_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Invoice_Item_ManyArgs = {
  updates: Array<Invoice_Item_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Invoice_ManyArgs = {
  updates: Array<Invoice_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_JobsArgs = {
  _append?: Maybe<Jobs_Append_Input>;
  _delete_at_path?: Maybe<Jobs_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Jobs_Delete_Elem_Input>;
  _delete_key?: Maybe<Jobs_Delete_Key_Input>;
  _prepend?: Maybe<Jobs_Prepend_Input>;
  _set?: Maybe<Jobs_Set_Input>;
  where: Jobs_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Jobs_By_PkArgs = {
  _append?: Maybe<Jobs_Append_Input>;
  _delete_at_path?: Maybe<Jobs_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Jobs_Delete_Elem_Input>;
  _delete_key?: Maybe<Jobs_Delete_Key_Input>;
  _prepend?: Maybe<Jobs_Prepend_Input>;
  _set?: Maybe<Jobs_Set_Input>;
  pk_columns: Jobs_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Jobs_ManyArgs = {
  updates: Array<Jobs_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_LabelArgs = {
  _set?: Maybe<Label_Set_Input>;
  where: Label_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Label_By_PkArgs = {
  _set?: Maybe<Label_Set_Input>;
  pk_columns: Label_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Label_ManyArgs = {
  updates: Array<Label_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Letsencrypt_StatusArgs = {
  _set?: Maybe<Letsencrypt_Status_Set_Input>;
  where: Letsencrypt_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Letsencrypt_Status_By_PkArgs = {
  _set?: Maybe<Letsencrypt_Status_Set_Input>;
  pk_columns: Letsencrypt_Status_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Letsencrypt_Status_ManyArgs = {
  updates: Array<Letsencrypt_Status_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_License_ActivityArgs = {
  _set?: Maybe<License_Activity_Set_Input>;
  where: License_Activity_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_License_Activity_By_PkArgs = {
  _set?: Maybe<License_Activity_Set_Input>;
  pk_columns: License_Activity_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_License_Activity_ManyArgs = {
  updates: Array<License_Activity_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_License_InstanceArgs = {
  _set?: Maybe<License_Instance_Set_Input>;
  where: License_Instance_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_License_Instance_By_PkArgs = {
  _set?: Maybe<License_Instance_Set_Input>;
  pk_columns: License_Instance_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_License_Instance_ManyArgs = {
  updates: Array<License_Instance_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_License_TypeArgs = {
  _set?: Maybe<License_Type_Set_Input>;
  where: License_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_License_Type_By_PkArgs = {
  _set?: Maybe<License_Type_Set_Input>;
  pk_columns: License_Type_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_License_Type_ManyArgs = {
  updates: Array<License_Type_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_LicensesArgs = {
  _set?: Maybe<Licenses_Set_Input>;
  where: Licenses_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Licenses_By_PkArgs = {
  _set?: Maybe<Licenses_Set_Input>;
  pk_columns: Licenses_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Licenses_ManyArgs = {
  updates: Array<Licenses_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Lux_ProxyArgs = {
  _append?: Maybe<Lux_Proxy_Append_Input>;
  _delete_at_path?: Maybe<Lux_Proxy_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Lux_Proxy_Delete_Elem_Input>;
  _delete_key?: Maybe<Lux_Proxy_Delete_Key_Input>;
  _prepend?: Maybe<Lux_Proxy_Prepend_Input>;
  _set?: Maybe<Lux_Proxy_Set_Input>;
  where: Lux_Proxy_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Lux_Proxy_AmiArgs = {
  _set?: Maybe<Lux_Proxy_Ami_Set_Input>;
  where: Lux_Proxy_Ami_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Lux_Proxy_Ami_By_PkArgs = {
  _set?: Maybe<Lux_Proxy_Ami_Set_Input>;
  pk_columns: Lux_Proxy_Ami_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Lux_Proxy_Ami_ManyArgs = {
  updates: Array<Lux_Proxy_Ami_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Lux_Proxy_By_PkArgs = {
  _append?: Maybe<Lux_Proxy_Append_Input>;
  _delete_at_path?: Maybe<Lux_Proxy_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Lux_Proxy_Delete_Elem_Input>;
  _delete_key?: Maybe<Lux_Proxy_Delete_Key_Input>;
  _prepend?: Maybe<Lux_Proxy_Prepend_Input>;
  _set?: Maybe<Lux_Proxy_Set_Input>;
  pk_columns: Lux_Proxy_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Lux_Proxy_ManyArgs = {
  updates: Array<Lux_Proxy_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Neon_Db_IntegrationArgs = {
  _set?: Maybe<Neon_Db_Integration_Set_Input>;
  where: Neon_Db_Integration_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Neon_Db_Integration_By_PkArgs = {
  _set?: Maybe<Neon_Db_Integration_Set_Input>;
  pk_columns: Neon_Db_Integration_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Neon_Db_Integration_ManyArgs = {
  updates: Array<Neon_Db_Integration_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Newrelic_ConfigArgs = {
  _append?: Maybe<Newrelic_Config_Append_Input>;
  _delete_at_path?: Maybe<Newrelic_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Newrelic_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Newrelic_Config_Delete_Key_Input>;
  _inc?: Maybe<Newrelic_Config_Inc_Input>;
  _prepend?: Maybe<Newrelic_Config_Prepend_Input>;
  _set?: Maybe<Newrelic_Config_Set_Input>;
  where: Newrelic_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Newrelic_Config_By_PkArgs = {
  _append?: Maybe<Newrelic_Config_Append_Input>;
  _delete_at_path?: Maybe<Newrelic_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Newrelic_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Newrelic_Config_Delete_Key_Input>;
  _inc?: Maybe<Newrelic_Config_Inc_Input>;
  _prepend?: Maybe<Newrelic_Config_Prepend_Input>;
  _set?: Maybe<Newrelic_Config_Set_Input>;
  pk_columns: Newrelic_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Newrelic_Config_ManyArgs = {
  updates: Array<Newrelic_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Node_Pool_TypeArgs = {
  _set?: Maybe<Node_Pool_Type_Set_Input>;
  where: Node_Pool_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Node_Pool_Type_By_PkArgs = {
  _set?: Maybe<Node_Pool_Type_Set_Input>;
  pk_columns: Node_Pool_Type_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Node_Pool_Type_ManyArgs = {
  updates: Array<Node_Pool_Type_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Node_PoolsArgs = {
  _append?: Maybe<Node_Pools_Append_Input>;
  _delete_at_path?: Maybe<Node_Pools_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Node_Pools_Delete_Elem_Input>;
  _delete_key?: Maybe<Node_Pools_Delete_Key_Input>;
  _prepend?: Maybe<Node_Pools_Prepend_Input>;
  _set?: Maybe<Node_Pools_Set_Input>;
  where: Node_Pools_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Node_Pools_By_PkArgs = {
  _append?: Maybe<Node_Pools_Append_Input>;
  _delete_at_path?: Maybe<Node_Pools_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Node_Pools_Delete_Elem_Input>;
  _delete_key?: Maybe<Node_Pools_Delete_Key_Input>;
  _prepend?: Maybe<Node_Pools_Prepend_Input>;
  _set?: Maybe<Node_Pools_Set_Input>;
  pk_columns: Node_Pools_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Node_Pools_ManyArgs = {
  updates: Array<Node_Pools_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_NotificationArgs = {
  _set?: Maybe<Notification_Set_Input>;
  where: Notification_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Notification_By_PkArgs = {
  _set?: Maybe<Notification_Set_Input>;
  pk_columns: Notification_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Notification_ManyArgs = {
  updates: Array<Notification_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Notification_TypeArgs = {
  _set?: Maybe<Notification_Type_Set_Input>;
  where: Notification_Type_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Notification_Type_By_PkArgs = {
  _set?: Maybe<Notification_Type_Set_Input>;
  pk_columns: Notification_Type_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Notification_Type_ManyArgs = {
  updates: Array<Notification_Type_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Onboarding_Sample_Db_CohortArgs = {
  _append?: Maybe<Onboarding_Sample_Db_Cohort_Append_Input>;
  _delete_at_path?: Maybe<Onboarding_Sample_Db_Cohort_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Onboarding_Sample_Db_Cohort_Delete_Elem_Input>;
  _delete_key?: Maybe<Onboarding_Sample_Db_Cohort_Delete_Key_Input>;
  _prepend?: Maybe<Onboarding_Sample_Db_Cohort_Prepend_Input>;
  _set?: Maybe<Onboarding_Sample_Db_Cohort_Set_Input>;
  where: Onboarding_Sample_Db_Cohort_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Onboarding_Sample_Db_Cohort_By_PkArgs = {
  _append?: Maybe<Onboarding_Sample_Db_Cohort_Append_Input>;
  _delete_at_path?: Maybe<Onboarding_Sample_Db_Cohort_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Onboarding_Sample_Db_Cohort_Delete_Elem_Input>;
  _delete_key?: Maybe<Onboarding_Sample_Db_Cohort_Delete_Key_Input>;
  _prepend?: Maybe<Onboarding_Sample_Db_Cohort_Prepend_Input>;
  _set?: Maybe<Onboarding_Sample_Db_Cohort_Set_Input>;
  pk_columns: Onboarding_Sample_Db_Cohort_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Onboarding_Sample_Db_Cohort_ManyArgs = {
  updates: Array<Onboarding_Sample_Db_Cohort_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Onboarding_Sample_Db_ConfigArgs = {
  _append?: Maybe<Onboarding_Sample_Db_Config_Append_Input>;
  _delete_at_path?: Maybe<Onboarding_Sample_Db_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Onboarding_Sample_Db_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Onboarding_Sample_Db_Config_Delete_Key_Input>;
  _inc?: Maybe<Onboarding_Sample_Db_Config_Inc_Input>;
  _prepend?: Maybe<Onboarding_Sample_Db_Config_Prepend_Input>;
  _set?: Maybe<Onboarding_Sample_Db_Config_Set_Input>;
  where: Onboarding_Sample_Db_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Onboarding_Sample_Db_Config_By_PkArgs = {
  _append?: Maybe<Onboarding_Sample_Db_Config_Append_Input>;
  _delete_at_path?: Maybe<Onboarding_Sample_Db_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Onboarding_Sample_Db_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Onboarding_Sample_Db_Config_Delete_Key_Input>;
  _inc?: Maybe<Onboarding_Sample_Db_Config_Inc_Input>;
  _prepend?: Maybe<Onboarding_Sample_Db_Config_Prepend_Input>;
  _set?: Maybe<Onboarding_Sample_Db_Config_Set_Input>;
  pk_columns: Onboarding_Sample_Db_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Onboarding_Sample_Db_Config_ManyArgs = {
  updates: Array<Onboarding_Sample_Db_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_DeploymentArgs = {
  _append?: Maybe<One_Click_Deployment_Append_Input>;
  _delete_at_path?: Maybe<One_Click_Deployment_Delete_At_Path_Input>;
  _delete_elem?: Maybe<One_Click_Deployment_Delete_Elem_Input>;
  _delete_key?: Maybe<One_Click_Deployment_Delete_Key_Input>;
  _inc?: Maybe<One_Click_Deployment_Inc_Input>;
  _prepend?: Maybe<One_Click_Deployment_Prepend_Input>;
  _set?: Maybe<One_Click_Deployment_Set_Input>;
  where: One_Click_Deployment_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_Deployment_By_PkArgs = {
  _append?: Maybe<One_Click_Deployment_Append_Input>;
  _delete_at_path?: Maybe<One_Click_Deployment_Delete_At_Path_Input>;
  _delete_elem?: Maybe<One_Click_Deployment_Delete_Elem_Input>;
  _delete_key?: Maybe<One_Click_Deployment_Delete_Key_Input>;
  _inc?: Maybe<One_Click_Deployment_Inc_Input>;
  _prepend?: Maybe<One_Click_Deployment_Prepend_Input>;
  _set?: Maybe<One_Click_Deployment_Set_Input>;
  pk_columns: One_Click_Deployment_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_Deployment_ManyArgs = {
  updates: Array<One_Click_Deployment_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_Deployment_Sample_AppsArgs = {
  _inc?: Maybe<One_Click_Deployment_Sample_Apps_Inc_Input>;
  _set?: Maybe<One_Click_Deployment_Sample_Apps_Set_Input>;
  where: One_Click_Deployment_Sample_Apps_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_Deployment_Sample_Apps_By_PkArgs = {
  _inc?: Maybe<One_Click_Deployment_Sample_Apps_Inc_Input>;
  _set?: Maybe<One_Click_Deployment_Sample_Apps_Set_Input>;
  pk_columns: One_Click_Deployment_Sample_Apps_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_Deployment_Sample_Apps_ManyArgs = {
  updates: Array<One_Click_Deployment_Sample_Apps_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_Deployment_State_LogArgs = {
  _append?: Maybe<One_Click_Deployment_State_Log_Append_Input>;
  _delete_at_path?: Maybe<One_Click_Deployment_State_Log_Delete_At_Path_Input>;
  _delete_elem?: Maybe<One_Click_Deployment_State_Log_Delete_Elem_Input>;
  _delete_key?: Maybe<One_Click_Deployment_State_Log_Delete_Key_Input>;
  _inc?: Maybe<One_Click_Deployment_State_Log_Inc_Input>;
  _prepend?: Maybe<One_Click_Deployment_State_Log_Prepend_Input>;
  _set?: Maybe<One_Click_Deployment_State_Log_Set_Input>;
  where: One_Click_Deployment_State_Log_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_Deployment_State_Log_By_PkArgs = {
  _append?: Maybe<One_Click_Deployment_State_Log_Append_Input>;
  _delete_at_path?: Maybe<One_Click_Deployment_State_Log_Delete_At_Path_Input>;
  _delete_elem?: Maybe<One_Click_Deployment_State_Log_Delete_Elem_Input>;
  _delete_key?: Maybe<One_Click_Deployment_State_Log_Delete_Key_Input>;
  _inc?: Maybe<One_Click_Deployment_State_Log_Inc_Input>;
  _prepend?: Maybe<One_Click_Deployment_State_Log_Prepend_Input>;
  _set?: Maybe<One_Click_Deployment_State_Log_Set_Input>;
  pk_columns: One_Click_Deployment_State_Log_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_Deployment_State_Log_ManyArgs = {
  updates: Array<One_Click_Deployment_State_Log_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_Deployment_StatesArgs = {
  _set?: Maybe<One_Click_Deployment_States_Set_Input>;
  where: One_Click_Deployment_States_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_Deployment_States_By_PkArgs = {
  _set?: Maybe<One_Click_Deployment_States_Set_Input>;
  pk_columns: One_Click_Deployment_States_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_One_Click_Deployment_States_ManyArgs = {
  updates: Array<One_Click_Deployment_States_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Opentelemetry_ConfigArgs = {
  _append?: Maybe<Opentelemetry_Config_Append_Input>;
  _delete_at_path?: Maybe<Opentelemetry_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Opentelemetry_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Opentelemetry_Config_Delete_Key_Input>;
  _inc?: Maybe<Opentelemetry_Config_Inc_Input>;
  _prepend?: Maybe<Opentelemetry_Config_Prepend_Input>;
  _set?: Maybe<Opentelemetry_Config_Set_Input>;
  where: Opentelemetry_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Opentelemetry_Config_By_PkArgs = {
  _append?: Maybe<Opentelemetry_Config_Append_Input>;
  _delete_at_path?: Maybe<Opentelemetry_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Opentelemetry_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Opentelemetry_Config_Delete_Key_Input>;
  _inc?: Maybe<Opentelemetry_Config_Inc_Input>;
  _prepend?: Maybe<Opentelemetry_Config_Prepend_Input>;
  _set?: Maybe<Opentelemetry_Config_Set_Input>;
  pk_columns: Opentelemetry_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Opentelemetry_Config_ManyArgs = {
  updates: Array<Opentelemetry_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Operations_Delete_Free_Plan_Dns_Records_Nov_2021Args =
  {
    _set?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Set_Input>;
    where: Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp;
  };

/** mutation root */
export type Mutation_RootUpdate_Operations_Delete_Free_Plan_Dns_Records_Nov_2021_By_PkArgs =
  {
    _set?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Set_Input>;
    pk_columns: Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Pk_Columns_Input;
  };

/** mutation root */
export type Mutation_RootUpdate_Operations_Delete_Free_Plan_Dns_Records_Nov_2021_ManyArgs =
  {
    updates: Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Updates>;
  };

/** mutation root */
export type Mutation_RootUpdate_Operations_TenantArgs = {
  _inc?: Maybe<Operations_Tenant_Inc_Input>;
  _set?: Maybe<Operations_Tenant_Set_Input>;
  where: Operations_Tenant_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Operations_Tenant_ManyArgs = {
  updates: Array<Operations_Tenant_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Payment_MethodArgs = {
  _inc?: Maybe<Payment_Method_Inc_Input>;
  _set?: Maybe<Payment_Method_Set_Input>;
  where: Payment_Method_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Payment_Method_By_PkArgs = {
  _inc?: Maybe<Payment_Method_Inc_Input>;
  _set?: Maybe<Payment_Method_Set_Input>;
  pk_columns: Payment_Method_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Payment_Method_ManyArgs = {
  updates: Array<Payment_Method_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Plan_EntitlementsArgs = {
  _set?: Maybe<Plan_Entitlements_Set_Input>;
  where: Plan_Entitlements_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Plan_Entitlements_By_PkArgs = {
  _set?: Maybe<Plan_Entitlements_Set_Input>;
  pk_columns: Plan_Entitlements_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Plan_Entitlements_ManyArgs = {
  updates: Array<Plan_Entitlements_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_PlansArgs = {
  _inc?: Maybe<Plans_Inc_Input>;
  _set?: Maybe<Plans_Set_Input>;
  where: Plans_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Plans_By_PkArgs = {
  _inc?: Maybe<Plans_Inc_Input>;
  _set?: Maybe<Plans_Set_Input>;
  pk_columns: Plans_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Plans_ManyArgs = {
  updates: Array<Plans_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_PoliciesArgs = {
  _inc?: Maybe<Policies_Inc_Input>;
  _set?: Maybe<Policies_Set_Input>;
  where: Policies_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Policies_By_PkArgs = {
  _inc?: Maybe<Policies_Inc_Input>;
  _set?: Maybe<Policies_Set_Input>;
  pk_columns: Policies_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Policies_ManyArgs = {
  updates: Array<Policies_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_PrivilegesArgs = {
  _inc?: Maybe<Privileges_Inc_Input>;
  _set?: Maybe<Privileges_Set_Input>;
  where: Privileges_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Privileges_By_PkArgs = {
  _inc?: Maybe<Privileges_Inc_Input>;
  _set?: Maybe<Privileges_Set_Input>;
  pk_columns: Privileges_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Privileges_ManyArgs = {
  updates: Array<Privileges_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Pro_License_KeysArgs = {
  _inc?: Maybe<Pro_License_Keys_Inc_Input>;
  _set?: Maybe<Pro_License_Keys_Set_Input>;
  where: Pro_License_Keys_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Pro_License_Keys_By_PkArgs = {
  _inc?: Maybe<Pro_License_Keys_Inc_Input>;
  _set?: Maybe<Pro_License_Keys_Set_Input>;
  pk_columns: Pro_License_Keys_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Pro_License_Keys_ManyArgs = {
  updates: Array<Pro_License_Keys_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_ActivityArgs = {
  _append?: Maybe<Project_Activity_Append_Input>;
  _delete_at_path?: Maybe<Project_Activity_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Project_Activity_Delete_Elem_Input>;
  _delete_key?: Maybe<Project_Activity_Delete_Key_Input>;
  _inc?: Maybe<Project_Activity_Inc_Input>;
  _prepend?: Maybe<Project_Activity_Prepend_Input>;
  _set?: Maybe<Project_Activity_Set_Input>;
  where: Project_Activity_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Activity_By_PkArgs = {
  _append?: Maybe<Project_Activity_Append_Input>;
  _delete_at_path?: Maybe<Project_Activity_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Project_Activity_Delete_Elem_Input>;
  _delete_key?: Maybe<Project_Activity_Delete_Key_Input>;
  _inc?: Maybe<Project_Activity_Inc_Input>;
  _prepend?: Maybe<Project_Activity_Prepend_Input>;
  _set?: Maybe<Project_Activity_Set_Input>;
  pk_columns: Project_Activity_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Activity_ManyArgs = {
  updates: Array<Project_Activity_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Billing_Manager_InvitationsArgs = {
  _inc?: Maybe<Project_Billing_Manager_Invitations_Inc_Input>;
  _set?: Maybe<Project_Billing_Manager_Invitations_Set_Input>;
  where: Project_Billing_Manager_Invitations_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Billing_Manager_Invitations_By_PkArgs =
  {
    _inc?: Maybe<Project_Billing_Manager_Invitations_Inc_Input>;
    _set?: Maybe<Project_Billing_Manager_Invitations_Set_Input>;
    pk_columns: Project_Billing_Manager_Invitations_Pk_Columns_Input;
  };

/** mutation root */
export type Mutation_RootUpdate_Project_Billing_Manager_Invitations_ManyArgs = {
  updates: Array<Project_Billing_Manager_Invitations_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_Allowed_Schema_TablesArgs =
  {
    _set?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Set_Input>;
    where: Project_Collaborator_Allowed_Schema_Tables_Bool_Exp;
  };

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_Allowed_Schema_Tables_By_PkArgs =
  {
    _set?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Set_Input>;
    pk_columns: Project_Collaborator_Allowed_Schema_Tables_Pk_Columns_Input;
  };

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_Allowed_Schema_Tables_ManyArgs =
  {
    updates: Array<Project_Collaborator_Allowed_Schema_Tables_Updates>;
  };

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_Allowed_SchemasArgs = {
  _set?: Maybe<Project_Collaborator_Allowed_Schemas_Set_Input>;
  where: Project_Collaborator_Allowed_Schemas_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_Allowed_Schemas_By_PkArgs =
  {
    _set?: Maybe<Project_Collaborator_Allowed_Schemas_Set_Input>;
    pk_columns: Project_Collaborator_Allowed_Schemas_Pk_Columns_Input;
  };

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_Allowed_Schemas_ManyArgs =
  {
    updates: Array<Project_Collaborator_Allowed_Schemas_Updates>;
  };

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_InvitationsArgs = {
  _append?: Maybe<Project_Collaborator_Invitations_Append_Input>;
  _delete_at_path?: Maybe<Project_Collaborator_Invitations_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Project_Collaborator_Invitations_Delete_Elem_Input>;
  _delete_key?: Maybe<Project_Collaborator_Invitations_Delete_Key_Input>;
  _inc?: Maybe<Project_Collaborator_Invitations_Inc_Input>;
  _prepend?: Maybe<Project_Collaborator_Invitations_Prepend_Input>;
  _set?: Maybe<Project_Collaborator_Invitations_Set_Input>;
  where: Project_Collaborator_Invitations_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_Invitations_By_PkArgs = {
  _append?: Maybe<Project_Collaborator_Invitations_Append_Input>;
  _delete_at_path?: Maybe<Project_Collaborator_Invitations_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Project_Collaborator_Invitations_Delete_Elem_Input>;
  _delete_key?: Maybe<Project_Collaborator_Invitations_Delete_Key_Input>;
  _inc?: Maybe<Project_Collaborator_Invitations_Inc_Input>;
  _prepend?: Maybe<Project_Collaborator_Invitations_Prepend_Input>;
  _set?: Maybe<Project_Collaborator_Invitations_Set_Input>;
  pk_columns: Project_Collaborator_Invitations_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_Invitations_ManyArgs = {
  updates: Array<Project_Collaborator_Invitations_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_PrivilegesArgs = {
  _set?: Maybe<Project_Collaborator_Privileges_Set_Input>;
  where: Project_Collaborator_Privileges_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_Privileges_By_PkArgs = {
  _set?: Maybe<Project_Collaborator_Privileges_Set_Input>;
  pk_columns: Project_Collaborator_Privileges_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborator_Privileges_ManyArgs = {
  updates: Array<Project_Collaborator_Privileges_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_CollaboratorsArgs = {
  _set?: Maybe<Project_Collaborators_Set_Input>;
  where: Project_Collaborators_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborators_By_PkArgs = {
  _set?: Maybe<Project_Collaborators_Set_Input>;
  pk_columns: Project_Collaborators_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Collaborators_ManyArgs = {
  updates: Array<Project_Collaborators_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_UsageArgs = {
  _inc?: Maybe<Project_Data_Usage_Inc_Input>;
  _set?: Maybe<Project_Data_Usage_Set_Input>;
  where: Project_Data_Usage_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_AggArgs = {
  _inc?: Maybe<Project_Data_Usage_Agg_Inc_Input>;
  _set?: Maybe<Project_Data_Usage_Agg_Set_Input>;
  where: Project_Data_Usage_Agg_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_Agg_ManyArgs = {
  updates: Array<Project_Data_Usage_Agg_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_Agg_UserArgs = {
  _inc?: Maybe<Project_Data_Usage_Agg_User_Inc_Input>;
  _set?: Maybe<Project_Data_Usage_Agg_User_Set_Input>;
  where: Project_Data_Usage_Agg_User_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_Agg_User_ManyArgs = {
  updates: Array<Project_Data_Usage_Agg_User_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_By_PkArgs = {
  _inc?: Maybe<Project_Data_Usage_Inc_Input>;
  _set?: Maybe<Project_Data_Usage_Set_Input>;
  pk_columns: Project_Data_Usage_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_ComponentsArgs = {
  _inc?: Maybe<Project_Data_Usage_Components_Inc_Input>;
  _set?: Maybe<Project_Data_Usage_Components_Set_Input>;
  where: Project_Data_Usage_Components_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_Components_ManyArgs = {
  updates: Array<Project_Data_Usage_Components_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_ManyArgs = {
  updates: Array<Project_Data_Usage_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_PrometheusArgs = {
  _inc?: Maybe<Project_Data_Usage_Prometheus_Inc_Input>;
  _set?: Maybe<Project_Data_Usage_Prometheus_Set_Input>;
  where: Project_Data_Usage_Prometheus_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_Prometheus_Agg_UserArgs = {
  _inc?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Inc_Input>;
  _set?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Set_Input>;
  where: Project_Data_Usage_Prometheus_Agg_User_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_Prometheus_Agg_User_ManyArgs =
  {
    updates: Array<Project_Data_Usage_Prometheus_Agg_User_Updates>;
  };

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_Prometheus_By_PkArgs = {
  _inc?: Maybe<Project_Data_Usage_Prometheus_Inc_Input>;
  _set?: Maybe<Project_Data_Usage_Prometheus_Set_Input>;
  pk_columns: Project_Data_Usage_Prometheus_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_Prometheus_ManyArgs = {
  updates: Array<Project_Data_Usage_Prometheus_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_ReportArgs = {
  _set?: Maybe<Project_Data_Usage_Report_Set_Input>;
  where: Project_Data_Usage_Report_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_Report_By_PkArgs = {
  _set?: Maybe<Project_Data_Usage_Report_Set_Input>;
  pk_columns: Project_Data_Usage_Report_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Data_Usage_Report_ManyArgs = {
  updates: Array<Project_Data_Usage_Report_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Db_UsageArgs = {
  _inc?: Maybe<Project_Db_Usage_Inc_Input>;
  _set?: Maybe<Project_Db_Usage_Set_Input>;
  where: Project_Db_Usage_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Db_Usage_Agg_UserArgs = {
  _inc?: Maybe<Project_Db_Usage_Agg_User_Inc_Input>;
  _set?: Maybe<Project_Db_Usage_Agg_User_Set_Input>;
  where: Project_Db_Usage_Agg_User_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Db_Usage_Agg_User_ManyArgs = {
  updates: Array<Project_Db_Usage_Agg_User_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Db_Usage_By_PkArgs = {
  _inc?: Maybe<Project_Db_Usage_Inc_Input>;
  _set?: Maybe<Project_Db_Usage_Set_Input>;
  pk_columns: Project_Db_Usage_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Db_Usage_ManyArgs = {
  updates: Array<Project_Db_Usage_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Entitlement_AccessArgs = {
  _set?: Maybe<Project_Entitlement_Access_Set_Input>;
  where: Project_Entitlement_Access_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Entitlement_Access_By_PkArgs = {
  _set?: Maybe<Project_Entitlement_Access_Set_Input>;
  pk_columns: Project_Entitlement_Access_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Entitlement_Access_ManyArgs = {
  updates: Array<Project_Entitlement_Access_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Entitlement_CatalogueArgs = {
  _inc?: Maybe<Project_Entitlement_Catalogue_Inc_Input>;
  _set?: Maybe<Project_Entitlement_Catalogue_Set_Input>;
  where: Project_Entitlement_Catalogue_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Entitlement_Catalogue_By_PkArgs = {
  _inc?: Maybe<Project_Entitlement_Catalogue_Inc_Input>;
  _set?: Maybe<Project_Entitlement_Catalogue_Set_Input>;
  pk_columns: Project_Entitlement_Catalogue_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Entitlement_Catalogue_ManyArgs = {
  updates: Array<Project_Entitlement_Catalogue_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Entitlement_TypesArgs = {
  _set?: Maybe<Project_Entitlement_Types_Set_Input>;
  where: Project_Entitlement_Types_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Entitlement_Types_By_PkArgs = {
  _set?: Maybe<Project_Entitlement_Types_Set_Input>;
  pk_columns: Project_Entitlement_Types_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Entitlement_Types_ManyArgs = {
  updates: Array<Project_Entitlement_Types_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_LabelsArgs = {
  _set?: Maybe<Project_Labels_Set_Input>;
  where: Project_Labels_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Labels_By_PkArgs = {
  _set?: Maybe<Project_Labels_Set_Input>;
  pk_columns: Project_Labels_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Labels_ManyArgs = {
  updates: Array<Project_Labels_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_MetadataArgs = {
  _inc?: Maybe<Project_Metadata_Inc_Input>;
  _set?: Maybe<Project_Metadata_Set_Input>;
  where: Project_Metadata_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Metadata_By_PkArgs = {
  _inc?: Maybe<Project_Metadata_Inc_Input>;
  _set?: Maybe<Project_Metadata_Set_Input>;
  pk_columns: Project_Metadata_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Metadata_ManyArgs = {
  updates: Array<Project_Metadata_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_NotificationArgs = {
  _append?: Maybe<Project_Notification_Append_Input>;
  _delete_at_path?: Maybe<Project_Notification_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Project_Notification_Delete_Elem_Input>;
  _delete_key?: Maybe<Project_Notification_Delete_Key_Input>;
  _inc?: Maybe<Project_Notification_Inc_Input>;
  _prepend?: Maybe<Project_Notification_Prepend_Input>;
  _set?: Maybe<Project_Notification_Set_Input>;
  where: Project_Notification_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Notification_By_PkArgs = {
  _append?: Maybe<Project_Notification_Append_Input>;
  _delete_at_path?: Maybe<Project_Notification_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Project_Notification_Delete_Elem_Input>;
  _delete_key?: Maybe<Project_Notification_Delete_Key_Input>;
  _inc?: Maybe<Project_Notification_Inc_Input>;
  _prepend?: Maybe<Project_Notification_Prepend_Input>;
  _set?: Maybe<Project_Notification_Set_Input>;
  pk_columns: Project_Notification_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Notification_ManyArgs = {
  updates: Array<Project_Notification_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Ownership_Transfer_InvitationsArgs = {
  _inc?: Maybe<Project_Ownership_Transfer_Invitations_Inc_Input>;
  _set?: Maybe<Project_Ownership_Transfer_Invitations_Set_Input>;
  where: Project_Ownership_Transfer_Invitations_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Ownership_Transfer_Invitations_By_PkArgs =
  {
    _inc?: Maybe<Project_Ownership_Transfer_Invitations_Inc_Input>;
    _set?: Maybe<Project_Ownership_Transfer_Invitations_Set_Input>;
    pk_columns: Project_Ownership_Transfer_Invitations_Pk_Columns_Input;
  };

/** mutation root */
export type Mutation_RootUpdate_Project_Ownership_Transfer_Invitations_ManyArgs =
  {
    updates: Array<Project_Ownership_Transfer_Invitations_Updates>;
  };

/** mutation root */
export type Mutation_RootUpdate_Project_Requests_CountArgs = {
  _inc?: Maybe<Project_Requests_Count_Inc_Input>;
  _set?: Maybe<Project_Requests_Count_Set_Input>;
  where: Project_Requests_Count_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Requests_Count_By_PkArgs = {
  _inc?: Maybe<Project_Requests_Count_Inc_Input>;
  _set?: Maybe<Project_Requests_Count_Set_Input>;
  pk_columns: Project_Requests_Count_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Requests_Count_ManyArgs = {
  updates: Array<Project_Requests_Count_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_StatsArgs = {
  _inc?: Maybe<Project_Stats_Inc_Input>;
  _set?: Maybe<Project_Stats_Set_Input>;
  where: Project_Stats_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Stats_By_PkArgs = {
  _inc?: Maybe<Project_Stats_Inc_Input>;
  _set?: Maybe<Project_Stats_Set_Input>;
  pk_columns: Project_Stats_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Stats_ManyArgs = {
  updates: Array<Project_Stats_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Total_Db_Usage_AggArgs = {
  _inc?: Maybe<Project_Total_Db_Usage_Agg_Inc_Input>;
  _set?: Maybe<Project_Total_Db_Usage_Agg_Set_Input>;
  where: Project_Total_Db_Usage_Agg_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Project_Total_Db_Usage_Agg_ManyArgs = {
  updates: Array<Project_Total_Db_Usage_Agg_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_ProjectsArgs = {
  _set?: Maybe<Projects_Set_Input>;
  where: Projects_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Projects_By_PkArgs = {
  _set?: Maybe<Projects_Set_Input>;
  pk_columns: Projects_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Projects_ManyArgs = {
  updates: Array<Projects_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Projects_Pool_ConfigArgs = {
  _inc?: Maybe<Projects_Pool_Config_Inc_Input>;
  _set?: Maybe<Projects_Pool_Config_Set_Input>;
  where: Projects_Pool_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Projects_Pool_Config_By_PkArgs = {
  _inc?: Maybe<Projects_Pool_Config_Inc_Input>;
  _set?: Maybe<Projects_Pool_Config_Set_Input>;
  pk_columns: Projects_Pool_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Projects_Pool_Config_ManyArgs = {
  updates: Array<Projects_Pool_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Projects_Pro_Key_GenerationsArgs = {
  _set?: Maybe<Projects_Pro_Key_Generations_Set_Input>;
  where: Projects_Pro_Key_Generations_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Projects_Pro_Key_Generations_By_PkArgs = {
  _set?: Maybe<Projects_Pro_Key_Generations_Set_Input>;
  pk_columns: Projects_Pro_Key_Generations_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Projects_Pro_Key_Generations_ManyArgs = {
  updates: Array<Projects_Pro_Key_Generations_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Prometheus_ConfigArgs = {
  _append?: Maybe<Prometheus_Config_Append_Input>;
  _delete_at_path?: Maybe<Prometheus_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Prometheus_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Prometheus_Config_Delete_Key_Input>;
  _inc?: Maybe<Prometheus_Config_Inc_Input>;
  _prepend?: Maybe<Prometheus_Config_Prepend_Input>;
  _set?: Maybe<Prometheus_Config_Set_Input>;
  where: Prometheus_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Prometheus_Config_By_PkArgs = {
  _append?: Maybe<Prometheus_Config_Append_Input>;
  _delete_at_path?: Maybe<Prometheus_Config_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Prometheus_Config_Delete_Elem_Input>;
  _delete_key?: Maybe<Prometheus_Config_Delete_Key_Input>;
  _inc?: Maybe<Prometheus_Config_Inc_Input>;
  _prepend?: Maybe<Prometheus_Config_Prepend_Input>;
  _set?: Maybe<Prometheus_Config_Set_Input>;
  pk_columns: Prometheus_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Prometheus_Config_ManyArgs = {
  updates: Array<Prometheus_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_ProvidersArgs = {
  _inc?: Maybe<Providers_Inc_Input>;
  _set?: Maybe<Providers_Set_Input>;
  where: Providers_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Providers_By_PkArgs = {
  _inc?: Maybe<Providers_Inc_Input>;
  _set?: Maybe<Providers_Set_Input>;
  pk_columns: Providers_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Providers_ManyArgs = {
  updates: Array<Providers_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_ProvisioningArgs = {
  _set?: Maybe<Provisioning_Set_Input>;
  where: Provisioning_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Provisioning_By_PkArgs = {
  _set?: Maybe<Provisioning_Set_Input>;
  pk_columns: Provisioning_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Provisioning_ManyArgs = {
  updates: Array<Provisioning_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_RegionArgs = {
  _append?: Maybe<Region_Append_Input>;
  _delete_at_path?: Maybe<Region_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Region_Delete_Elem_Input>;
  _delete_key?: Maybe<Region_Delete_Key_Input>;
  _prepend?: Maybe<Region_Prepend_Input>;
  _set?: Maybe<Region_Set_Input>;
  where: Region_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Region_By_PkArgs = {
  _append?: Maybe<Region_Append_Input>;
  _delete_at_path?: Maybe<Region_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Region_Delete_Elem_Input>;
  _delete_key?: Maybe<Region_Delete_Key_Input>;
  _prepend?: Maybe<Region_Prepend_Input>;
  _set?: Maybe<Region_Set_Input>;
  pk_columns: Region_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Region_ManyArgs = {
  updates: Array<Region_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Region_V2Args = {
  _append?: Maybe<Region_V2_Append_Input>;
  _delete_at_path?: Maybe<Region_V2_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Region_V2_Delete_Elem_Input>;
  _delete_key?: Maybe<Region_V2_Delete_Key_Input>;
  _prepend?: Maybe<Region_V2_Prepend_Input>;
  _set?: Maybe<Region_V2_Set_Input>;
  where: Region_V2_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Region_V2_ManyArgs = {
  updates: Array<Region_V2_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Regional_Data_ConnectorsArgs = {
  _append?: Maybe<Regional_Data_Connectors_Append_Input>;
  _delete_at_path?: Maybe<Regional_Data_Connectors_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Regional_Data_Connectors_Delete_Elem_Input>;
  _delete_key?: Maybe<Regional_Data_Connectors_Delete_Key_Input>;
  _prepend?: Maybe<Regional_Data_Connectors_Prepend_Input>;
  _set?: Maybe<Regional_Data_Connectors_Set_Input>;
  where: Regional_Data_Connectors_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Regional_Data_Connectors_By_PkArgs = {
  _append?: Maybe<Regional_Data_Connectors_Append_Input>;
  _delete_at_path?: Maybe<Regional_Data_Connectors_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Regional_Data_Connectors_Delete_Elem_Input>;
  _delete_key?: Maybe<Regional_Data_Connectors_Delete_Key_Input>;
  _prepend?: Maybe<Regional_Data_Connectors_Prepend_Input>;
  _set?: Maybe<Regional_Data_Connectors_Set_Input>;
  pk_columns: Regional_Data_Connectors_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Regional_Data_Connectors_ManyArgs = {
  updates: Array<Regional_Data_Connectors_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Regional_MetricsArgs = {
  _append?: Maybe<Regional_Metrics_Append_Input>;
  _delete_at_path?: Maybe<Regional_Metrics_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Regional_Metrics_Delete_Elem_Input>;
  _delete_key?: Maybe<Regional_Metrics_Delete_Key_Input>;
  _prepend?: Maybe<Regional_Metrics_Prepend_Input>;
  _set?: Maybe<Regional_Metrics_Set_Input>;
  where: Regional_Metrics_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Regional_Metrics_By_PkArgs = {
  _append?: Maybe<Regional_Metrics_Append_Input>;
  _delete_at_path?: Maybe<Regional_Metrics_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Regional_Metrics_Delete_Elem_Input>;
  _delete_key?: Maybe<Regional_Metrics_Delete_Key_Input>;
  _prepend?: Maybe<Regional_Metrics_Prepend_Input>;
  _set?: Maybe<Regional_Metrics_Set_Input>;
  pk_columns: Regional_Metrics_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Regional_Metrics_ManyArgs = {
  updates: Array<Regional_Metrics_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Saml_IdpArgs = {
  _set?: Maybe<Saml_Idp_Set_Input>;
  where: Saml_Idp_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Saml_Idp_By_PkArgs = {
  _set?: Maybe<Saml_Idp_Set_Input>;
  pk_columns: Saml_Idp_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Saml_Idp_ManyArgs = {
  updates: Array<Saml_Idp_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Search_Project_Login_Status_ResultsArgs = {
  _inc?: Maybe<Search_Project_Login_Status_Results_Inc_Input>;
  _set?: Maybe<Search_Project_Login_Status_Results_Set_Input>;
  where: Search_Project_Login_Status_Results_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Search_Project_Login_Status_Results_ManyArgs = {
  updates: Array<Search_Project_Login_Status_Results_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Slack_ConfigArgs = {
  _set?: Maybe<Slack_Config_Set_Input>;
  where: Slack_Config_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Slack_Config_By_PkArgs = {
  _set?: Maybe<Slack_Config_Set_Input>;
  pk_columns: Slack_Config_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Slack_Config_ManyArgs = {
  updates: Array<Slack_Config_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Stripe_SubscriptionArgs = {
  _set?: Maybe<Stripe_Subscription_Set_Input>;
  where: Stripe_Subscription_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Stripe_Subscription_By_PkArgs = {
  _set?: Maybe<Stripe_Subscription_Set_Input>;
  pk_columns: Stripe_Subscription_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Stripe_Subscription_ManyArgs = {
  updates: Array<Stripe_Subscription_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Stripe_Webhook_EventsArgs = {
  _append?: Maybe<Stripe_Webhook_Events_Append_Input>;
  _delete_at_path?: Maybe<Stripe_Webhook_Events_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Stripe_Webhook_Events_Delete_Elem_Input>;
  _delete_key?: Maybe<Stripe_Webhook_Events_Delete_Key_Input>;
  _prepend?: Maybe<Stripe_Webhook_Events_Prepend_Input>;
  _set?: Maybe<Stripe_Webhook_Events_Set_Input>;
  where: Stripe_Webhook_Events_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Stripe_Webhook_Events_By_PkArgs = {
  _append?: Maybe<Stripe_Webhook_Events_Append_Input>;
  _delete_at_path?: Maybe<Stripe_Webhook_Events_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Stripe_Webhook_Events_Delete_Elem_Input>;
  _delete_key?: Maybe<Stripe_Webhook_Events_Delete_Key_Input>;
  _prepend?: Maybe<Stripe_Webhook_Events_Prepend_Input>;
  _set?: Maybe<Stripe_Webhook_Events_Set_Input>;
  pk_columns: Stripe_Webhook_Events_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Stripe_Webhook_Events_ManyArgs = {
  updates: Array<Stripe_Webhook_Events_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Super_Connector_TypesArgs = {
  _set?: Maybe<Super_Connector_Types_Set_Input>;
  where: Super_Connector_Types_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Super_Connector_Types_By_PkArgs = {
  _set?: Maybe<Super_Connector_Types_Set_Input>;
  pk_columns: Super_Connector_Types_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Super_Connector_Types_ManyArgs = {
  updates: Array<Super_Connector_Types_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Support_Plan_TypesArgs = {
  _set?: Maybe<Support_Plan_Types_Set_Input>;
  where: Support_Plan_Types_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Support_Plan_Types_By_PkArgs = {
  _set?: Maybe<Support_Plan_Types_Set_Input>;
  pk_columns: Support_Plan_Types_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Support_Plan_Types_ManyArgs = {
  updates: Array<Support_Plan_Types_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_SurveyArgs = {
  _set?: Maybe<Survey_Set_Input>;
  where: Survey_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_By_PkArgs = {
  _set?: Maybe<Survey_Set_Input>;
  pk_columns: Survey_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_ManyArgs = {
  updates: Array<Survey_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_QuestionArgs = {
  _set?: Maybe<Survey_Question_Set_Input>;
  where: Survey_Question_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_Answer_OptionArgs = {
  _set?: Maybe<Survey_Question_Answer_Option_Set_Input>;
  where: Survey_Question_Answer_Option_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_Answer_Option_By_PkArgs = {
  _set?: Maybe<Survey_Question_Answer_Option_Set_Input>;
  pk_columns: Survey_Question_Answer_Option_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_Answer_Option_ManyArgs = {
  updates: Array<Survey_Question_Answer_Option_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_AnswersArgs = {
  _set?: Maybe<Survey_Question_Answers_Set_Input>;
  where: Survey_Question_Answers_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_Answers_By_PkArgs = {
  _set?: Maybe<Survey_Question_Answers_Set_Input>;
  pk_columns: Survey_Question_Answers_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_Answers_ManyArgs = {
  updates: Array<Survey_Question_Answers_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_By_PkArgs = {
  _set?: Maybe<Survey_Question_Set_Input>;
  pk_columns: Survey_Question_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_KindArgs = {
  _set?: Maybe<Survey_Question_Kind_Set_Input>;
  where: Survey_Question_Kind_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_Kind_By_PkArgs = {
  _set?: Maybe<Survey_Question_Kind_Set_Input>;
  pk_columns: Survey_Question_Kind_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_Kind_ManyArgs = {
  updates: Array<Survey_Question_Kind_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_ManyArgs = {
  updates: Array<Survey_Question_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_OptionsArgs = {
  _set?: Maybe<Survey_Question_Options_Set_Input>;
  where: Survey_Question_Options_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_Options_By_PkArgs = {
  _set?: Maybe<Survey_Question_Options_Set_Input>;
  pk_columns: Survey_Question_Options_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_Question_Options_ManyArgs = {
  updates: Array<Survey_Question_Options_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2Args = {
  _append?: Maybe<Survey_V2_Append_Input>;
  _delete_at_path?: Maybe<Survey_V2_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Survey_V2_Delete_Elem_Input>;
  _delete_key?: Maybe<Survey_V2_Delete_Key_Input>;
  _prepend?: Maybe<Survey_V2_Prepend_Input>;
  _set?: Maybe<Survey_V2_Set_Input>;
  where: Survey_V2_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_By_PkArgs = {
  _append?: Maybe<Survey_V2_Append_Input>;
  _delete_at_path?: Maybe<Survey_V2_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Survey_V2_Delete_Elem_Input>;
  _delete_key?: Maybe<Survey_V2_Delete_Key_Input>;
  _prepend?: Maybe<Survey_V2_Prepend_Input>;
  _set?: Maybe<Survey_V2_Set_Input>;
  pk_columns: Survey_V2_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_ManyArgs = {
  updates: Array<Survey_V2_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_QuestionArgs = {
  _append?: Maybe<Survey_V2_Question_Append_Input>;
  _delete_at_path?: Maybe<Survey_V2_Question_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Survey_V2_Question_Delete_Elem_Input>;
  _delete_key?: Maybe<Survey_V2_Question_Delete_Key_Input>;
  _inc?: Maybe<Survey_V2_Question_Inc_Input>;
  _prepend?: Maybe<Survey_V2_Question_Prepend_Input>;
  _set?: Maybe<Survey_V2_Question_Set_Input>;
  where: Survey_V2_Question_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Question_By_PkArgs = {
  _append?: Maybe<Survey_V2_Question_Append_Input>;
  _delete_at_path?: Maybe<Survey_V2_Question_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Survey_V2_Question_Delete_Elem_Input>;
  _delete_key?: Maybe<Survey_V2_Question_Delete_Key_Input>;
  _inc?: Maybe<Survey_V2_Question_Inc_Input>;
  _prepend?: Maybe<Survey_V2_Question_Prepend_Input>;
  _set?: Maybe<Survey_V2_Question_Set_Input>;
  pk_columns: Survey_V2_Question_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Question_KindArgs = {
  _set?: Maybe<Survey_V2_Question_Kind_Set_Input>;
  where: Survey_V2_Question_Kind_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Question_Kind_By_PkArgs = {
  _set?: Maybe<Survey_V2_Question_Kind_Set_Input>;
  pk_columns: Survey_V2_Question_Kind_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Question_Kind_ManyArgs = {
  updates: Array<Survey_V2_Question_Kind_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Question_ManyArgs = {
  updates: Array<Survey_V2_Question_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Question_OptionArgs = {
  _append?: Maybe<Survey_V2_Question_Option_Append_Input>;
  _delete_at_path?: Maybe<Survey_V2_Question_Option_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Survey_V2_Question_Option_Delete_Elem_Input>;
  _delete_key?: Maybe<Survey_V2_Question_Option_Delete_Key_Input>;
  _inc?: Maybe<Survey_V2_Question_Option_Inc_Input>;
  _prepend?: Maybe<Survey_V2_Question_Option_Prepend_Input>;
  _set?: Maybe<Survey_V2_Question_Option_Set_Input>;
  where: Survey_V2_Question_Option_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Question_Option_Additional_Info_ConfigArgs =
  {
    _set?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Set_Input>;
    where: Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp;
  };

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Question_Option_Additional_Info_Config_By_PkArgs =
  {
    _set?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Set_Input>;
    pk_columns: Survey_V2_Question_Option_Additional_Info_Config_Pk_Columns_Input;
  };

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Question_Option_Additional_Info_Config_ManyArgs =
  {
    updates: Array<Survey_V2_Question_Option_Additional_Info_Config_Updates>;
  };

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Question_Option_By_PkArgs = {
  _append?: Maybe<Survey_V2_Question_Option_Append_Input>;
  _delete_at_path?: Maybe<Survey_V2_Question_Option_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Survey_V2_Question_Option_Delete_Elem_Input>;
  _delete_key?: Maybe<Survey_V2_Question_Option_Delete_Key_Input>;
  _inc?: Maybe<Survey_V2_Question_Option_Inc_Input>;
  _prepend?: Maybe<Survey_V2_Question_Option_Prepend_Input>;
  _set?: Maybe<Survey_V2_Question_Option_Set_Input>;
  pk_columns: Survey_V2_Question_Option_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Question_Option_ManyArgs = {
  updates: Array<Survey_V2_Question_Option_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_ResponseArgs = {
  _set?: Maybe<Survey_V2_Response_Set_Input>;
  where: Survey_V2_Response_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Response_AnswerArgs = {
  _set?: Maybe<Survey_V2_Response_Answer_Set_Input>;
  where: Survey_V2_Response_Answer_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Response_Answer_By_PkArgs = {
  _set?: Maybe<Survey_V2_Response_Answer_Set_Input>;
  pk_columns: Survey_V2_Response_Answer_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Response_Answer_ManyArgs = {
  updates: Array<Survey_V2_Response_Answer_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Response_Answer_OptionArgs = {
  _set?: Maybe<Survey_V2_Response_Answer_Option_Set_Input>;
  where: Survey_V2_Response_Answer_Option_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Response_Answer_Option_By_PkArgs = {
  _set?: Maybe<Survey_V2_Response_Answer_Option_Set_Input>;
  pk_columns: Survey_V2_Response_Answer_Option_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Response_Answer_Option_ManyArgs = {
  updates: Array<Survey_V2_Response_Answer_Option_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Response_By_PkArgs = {
  _set?: Maybe<Survey_V2_Response_Set_Input>;
  pk_columns: Survey_V2_Response_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Survey_V2_Response_ManyArgs = {
  updates: Array<Survey_V2_Response_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Task_EventArgs = {
  _append?: Maybe<Task_Event_Append_Input>;
  _delete_at_path?: Maybe<Task_Event_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Task_Event_Delete_Elem_Input>;
  _delete_key?: Maybe<Task_Event_Delete_Key_Input>;
  _prepend?: Maybe<Task_Event_Prepend_Input>;
  _set?: Maybe<Task_Event_Set_Input>;
  where: Task_Event_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Task_Event_By_PkArgs = {
  _append?: Maybe<Task_Event_Append_Input>;
  _delete_at_path?: Maybe<Task_Event_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Task_Event_Delete_Elem_Input>;
  _delete_key?: Maybe<Task_Event_Delete_Key_Input>;
  _prepend?: Maybe<Task_Event_Prepend_Input>;
  _set?: Maybe<Task_Event_Set_Input>;
  pk_columns: Task_Event_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Task_Event_ManyArgs = {
  updates: Array<Task_Event_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_TasksArgs = {
  _append?: Maybe<Tasks_Append_Input>;
  _delete_at_path?: Maybe<Tasks_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Tasks_Delete_Elem_Input>;
  _delete_key?: Maybe<Tasks_Delete_Key_Input>;
  _inc?: Maybe<Tasks_Inc_Input>;
  _prepend?: Maybe<Tasks_Prepend_Input>;
  _set?: Maybe<Tasks_Set_Input>;
  where: Tasks_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Tasks_By_PkArgs = {
  _append?: Maybe<Tasks_Append_Input>;
  _delete_at_path?: Maybe<Tasks_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Tasks_Delete_Elem_Input>;
  _delete_key?: Maybe<Tasks_Delete_Key_Input>;
  _inc?: Maybe<Tasks_Inc_Input>;
  _prepend?: Maybe<Tasks_Prepend_Input>;
  _set?: Maybe<Tasks_Set_Input>;
  pk_columns: Tasks_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Tasks_ManyArgs = {
  updates: Array<Tasks_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_TenantArgs = {
  _inc?: Maybe<Tenant_Inc_Input>;
  _set?: Maybe<Tenant_Set_Input>;
  where: Tenant_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Active_Status_ReasonArgs = {
  _set?: Maybe<Tenant_Active_Status_Reason_Set_Input>;
  where: Tenant_Active_Status_Reason_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Active_Status_Reason_By_PkArgs = {
  _set?: Maybe<Tenant_Active_Status_Reason_Set_Input>;
  pk_columns: Tenant_Active_Status_Reason_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Active_Status_Reason_ManyArgs = {
  updates: Array<Tenant_Active_Status_Reason_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_By_PkArgs = {
  _inc?: Maybe<Tenant_Inc_Input>;
  _set?: Maybe<Tenant_Set_Input>;
  pk_columns: Tenant_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_GroupArgs = {
  _inc?: Maybe<Tenant_Group_Inc_Input>;
  _set?: Maybe<Tenant_Group_Set_Input>;
  where: Tenant_Group_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Group_By_PkArgs = {
  _inc?: Maybe<Tenant_Group_Inc_Input>;
  _set?: Maybe<Tenant_Group_Set_Input>;
  pk_columns: Tenant_Group_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Group_ManyArgs = {
  updates: Array<Tenant_Group_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Group_MemberArgs = {
  _inc?: Maybe<Tenant_Group_Member_Inc_Input>;
  _set?: Maybe<Tenant_Group_Member_Set_Input>;
  where: Tenant_Group_Member_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Group_Member_By_PkArgs = {
  _inc?: Maybe<Tenant_Group_Member_Inc_Input>;
  _set?: Maybe<Tenant_Group_Member_Set_Input>;
  pk_columns: Tenant_Group_Member_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Group_Member_ManyArgs = {
  updates: Array<Tenant_Group_Member_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_ManyArgs = {
  updates: Array<Tenant_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Public_StatusArgs = {
  _set?: Maybe<Tenant_Public_Status_Set_Input>;
  where: Tenant_Public_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Public_Status_By_PkArgs = {
  _set?: Maybe<Tenant_Public_Status_Set_Input>;
  pk_columns: Tenant_Public_Status_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Public_Status_ManyArgs = {
  updates: Array<Tenant_Public_Status_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_StatusArgs = {
  _set?: Maybe<Tenant_Status_Set_Input>;
  where: Tenant_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Status_By_PkArgs = {
  _set?: Maybe<Tenant_Status_Set_Input>;
  pk_columns: Tenant_Status_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Tenant_Status_ManyArgs = {
  updates: Array<Tenant_Status_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Trial_LeadsArgs = {
  _append?: Maybe<Trial_Leads_Append_Input>;
  _delete_at_path?: Maybe<Trial_Leads_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Trial_Leads_Delete_Elem_Input>;
  _delete_key?: Maybe<Trial_Leads_Delete_Key_Input>;
  _prepend?: Maybe<Trial_Leads_Prepend_Input>;
  _set?: Maybe<Trial_Leads_Set_Input>;
  where: Trial_Leads_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Trial_Leads_By_PkArgs = {
  _append?: Maybe<Trial_Leads_Append_Input>;
  _delete_at_path?: Maybe<Trial_Leads_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Trial_Leads_Delete_Elem_Input>;
  _delete_key?: Maybe<Trial_Leads_Delete_Key_Input>;
  _prepend?: Maybe<Trial_Leads_Prepend_Input>;
  _set?: Maybe<Trial_Leads_Set_Input>;
  pk_columns: Trial_Leads_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Trial_Leads_ManyArgs = {
  updates: Array<Trial_Leads_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Ua_Audit_LogsArgs = {
  _set?: Maybe<Ua_Audit_Logs_Set_Input>;
  where: Ua_Audit_Logs_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Ua_Audit_Logs_By_PkArgs = {
  _set?: Maybe<Ua_Audit_Logs_Set_Input>;
  pk_columns: Ua_Audit_Logs_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Ua_Audit_Logs_ManyArgs = {
  updates: Array<Ua_Audit_Logs_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_User_ActivityArgs = {
  _append?: Maybe<User_Activity_Append_Input>;
  _delete_at_path?: Maybe<User_Activity_Delete_At_Path_Input>;
  _delete_elem?: Maybe<User_Activity_Delete_Elem_Input>;
  _delete_key?: Maybe<User_Activity_Delete_Key_Input>;
  _prepend?: Maybe<User_Activity_Prepend_Input>;
  _set?: Maybe<User_Activity_Set_Input>;
  where: User_Activity_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_User_Activity_By_PkArgs = {
  _append?: Maybe<User_Activity_Append_Input>;
  _delete_at_path?: Maybe<User_Activity_Delete_At_Path_Input>;
  _delete_elem?: Maybe<User_Activity_Delete_Elem_Input>;
  _delete_key?: Maybe<User_Activity_Delete_Key_Input>;
  _prepend?: Maybe<User_Activity_Prepend_Input>;
  _set?: Maybe<User_Activity_Set_Input>;
  pk_columns: User_Activity_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_User_Activity_ManyArgs = {
  updates: Array<User_Activity_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_User_CouponArgs = {
  _inc?: Maybe<User_Coupon_Inc_Input>;
  _set?: Maybe<User_Coupon_Set_Input>;
  where: User_Coupon_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_User_Coupon_By_PkArgs = {
  _inc?: Maybe<User_Coupon_Inc_Input>;
  _set?: Maybe<User_Coupon_Set_Input>;
  pk_columns: User_Coupon_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_User_Coupon_ManyArgs = {
  updates: Array<User_Coupon_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_User_Entitlement_AccessArgs = {
  _set?: Maybe<User_Entitlement_Access_Set_Input>;
  where: User_Entitlement_Access_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_User_Entitlement_Access_By_PkArgs = {
  _set?: Maybe<User_Entitlement_Access_Set_Input>;
  pk_columns: User_Entitlement_Access_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_User_Entitlement_Access_ManyArgs = {
  updates: Array<User_Entitlement_Access_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_User_Entitlement_CatalogueArgs = {
  _inc?: Maybe<User_Entitlement_Catalogue_Inc_Input>;
  _set?: Maybe<User_Entitlement_Catalogue_Set_Input>;
  where: User_Entitlement_Catalogue_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_User_Entitlement_Catalogue_By_PkArgs = {
  _inc?: Maybe<User_Entitlement_Catalogue_Inc_Input>;
  _set?: Maybe<User_Entitlement_Catalogue_Set_Input>;
  pk_columns: User_Entitlement_Catalogue_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_User_Entitlement_Catalogue_ManyArgs = {
  updates: Array<User_Entitlement_Catalogue_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_User_Entitlement_TypesArgs = {
  _set?: Maybe<User_Entitlement_Types_Set_Input>;
  where: User_Entitlement_Types_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_User_Entitlement_Types_By_PkArgs = {
  _set?: Maybe<User_Entitlement_Types_Set_Input>;
  pk_columns: User_Entitlement_Types_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_User_Entitlement_Types_ManyArgs = {
  updates: Array<User_Entitlement_Types_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_User_OnboardingArgs = {
  _append?: Maybe<User_Onboarding_Append_Input>;
  _delete_at_path?: Maybe<User_Onboarding_Delete_At_Path_Input>;
  _delete_elem?: Maybe<User_Onboarding_Delete_Elem_Input>;
  _delete_key?: Maybe<User_Onboarding_Delete_Key_Input>;
  _prepend?: Maybe<User_Onboarding_Prepend_Input>;
  _set?: Maybe<User_Onboarding_Set_Input>;
  where: User_Onboarding_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_User_Onboarding_By_PkArgs = {
  _append?: Maybe<User_Onboarding_Append_Input>;
  _delete_at_path?: Maybe<User_Onboarding_Delete_At_Path_Input>;
  _delete_elem?: Maybe<User_Onboarding_Delete_Elem_Input>;
  _delete_key?: Maybe<User_Onboarding_Delete_Key_Input>;
  _prepend?: Maybe<User_Onboarding_Prepend_Input>;
  _set?: Maybe<User_Onboarding_Set_Input>;
  pk_columns: User_Onboarding_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_User_Onboarding_ManyArgs = {
  updates: Array<User_Onboarding_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_User_Personal_Access_TokensArgs = {
  _set?: Maybe<User_Personal_Access_Tokens_Set_Input>;
  where: User_Personal_Access_Tokens_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_User_Personal_Access_Tokens_By_PkArgs = {
  _set?: Maybe<User_Personal_Access_Tokens_Set_Input>;
  pk_columns: User_Personal_Access_Tokens_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_User_Personal_Access_Tokens_ManyArgs = {
  updates: Array<User_Personal_Access_Tokens_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_User_ProfileArgs = {
  _set?: Maybe<User_Profile_Set_Input>;
  where: User_Profile_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_User_Profile_By_PkArgs = {
  _set?: Maybe<User_Profile_Set_Input>;
  pk_columns: User_Profile_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_User_Profile_ManyArgs = {
  updates: Array<User_Profile_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_User_RolesArgs = {
  _set?: Maybe<User_Roles_Set_Input>;
  where: User_Roles_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_User_Roles_By_PkArgs = {
  _set?: Maybe<User_Roles_Set_Input>;
  pk_columns: User_Roles_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_User_Roles_ManyArgs = {
  updates: Array<User_Roles_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_User_Vpc_PolicyArgs = {
  _inc?: Maybe<User_Vpc_Policy_Inc_Input>;
  _set?: Maybe<User_Vpc_Policy_Set_Input>;
  where: User_Vpc_Policy_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_User_Vpc_Policy_By_PkArgs = {
  _inc?: Maybe<User_Vpc_Policy_Inc_Input>;
  _set?: Maybe<User_Vpc_Policy_Set_Input>;
  pk_columns: User_Vpc_Policy_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_User_Vpc_Policy_ManyArgs = {
  updates: Array<User_Vpc_Policy_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_UsersArgs = {
  _inc?: Maybe<Users_Inc_Input>;
  _set?: Maybe<Users_Set_Input>;
  where: Users_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Users_By_PkArgs = {
  _inc?: Maybe<Users_Inc_Input>;
  _set?: Maybe<Users_Set_Input>;
  pk_columns: Users_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Users_ManyArgs = {
  updates: Array<Users_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Users_PublicArgs = {
  _set?: Maybe<Users_Public_Set_Input>;
  where: Users_Public_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Users_Public_ManyArgs = {
  updates: Array<Users_Public_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Vercel_IntegrationArgs = {
  _append?: Maybe<Vercel_Integration_Append_Input>;
  _delete_at_path?: Maybe<Vercel_Integration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Vercel_Integration_Delete_Elem_Input>;
  _delete_key?: Maybe<Vercel_Integration_Delete_Key_Input>;
  _prepend?: Maybe<Vercel_Integration_Prepend_Input>;
  _set?: Maybe<Vercel_Integration_Set_Input>;
  where: Vercel_Integration_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Vercel_Integration_By_PkArgs = {
  _append?: Maybe<Vercel_Integration_Append_Input>;
  _delete_at_path?: Maybe<Vercel_Integration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Vercel_Integration_Delete_Elem_Input>;
  _delete_key?: Maybe<Vercel_Integration_Delete_Key_Input>;
  _prepend?: Maybe<Vercel_Integration_Prepend_Input>;
  _set?: Maybe<Vercel_Integration_Set_Input>;
  pk_columns: Vercel_Integration_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Vercel_Integration_ConnectionsArgs = {
  _set?: Maybe<Vercel_Integration_Connections_Set_Input>;
  where: Vercel_Integration_Connections_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Vercel_Integration_Connections_By_PkArgs = {
  _set?: Maybe<Vercel_Integration_Connections_Set_Input>;
  pk_columns: Vercel_Integration_Connections_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Vercel_Integration_Connections_ManyArgs = {
  updates: Array<Vercel_Integration_Connections_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Vercel_Integration_ManyArgs = {
  updates: Array<Vercel_Integration_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Vpc_PeeringArgs = {
  _append?: Maybe<Vpc_Peering_Append_Input>;
  _delete_at_path?: Maybe<Vpc_Peering_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Vpc_Peering_Delete_Elem_Input>;
  _delete_key?: Maybe<Vpc_Peering_Delete_Key_Input>;
  _prepend?: Maybe<Vpc_Peering_Prepend_Input>;
  _set?: Maybe<Vpc_Peering_Set_Input>;
  where: Vpc_Peering_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Vpc_Peering_By_PkArgs = {
  _append?: Maybe<Vpc_Peering_Append_Input>;
  _delete_at_path?: Maybe<Vpc_Peering_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Vpc_Peering_Delete_Elem_Input>;
  _delete_key?: Maybe<Vpc_Peering_Delete_Key_Input>;
  _prepend?: Maybe<Vpc_Peering_Prepend_Input>;
  _set?: Maybe<Vpc_Peering_Set_Input>;
  pk_columns: Vpc_Peering_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Vpc_Peering_DirectionArgs = {
  _set?: Maybe<Vpc_Peering_Direction_Set_Input>;
  where: Vpc_Peering_Direction_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Vpc_Peering_Direction_By_PkArgs = {
  _set?: Maybe<Vpc_Peering_Direction_Set_Input>;
  pk_columns: Vpc_Peering_Direction_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Vpc_Peering_Direction_ManyArgs = {
  updates: Array<Vpc_Peering_Direction_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Vpc_Peering_ManyArgs = {
  updates: Array<Vpc_Peering_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Vpc_StatusArgs = {
  _set?: Maybe<Vpc_Status_Set_Input>;
  where: Vpc_Status_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Vpc_Status_By_PkArgs = {
  _set?: Maybe<Vpc_Status_Set_Input>;
  pk_columns: Vpc_Status_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Vpc_Status_ManyArgs = {
  updates: Array<Vpc_Status_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Zendesk_Support_CategoryArgs = {
  _inc?: Maybe<Zendesk_Support_Category_Inc_Input>;
  _set?: Maybe<Zendesk_Support_Category_Set_Input>;
  where: Zendesk_Support_Category_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Zendesk_Support_Category_By_PkArgs = {
  _inc?: Maybe<Zendesk_Support_Category_Inc_Input>;
  _set?: Maybe<Zendesk_Support_Category_Set_Input>;
  pk_columns: Zendesk_Support_Category_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Zendesk_Support_Category_ManyArgs = {
  updates: Array<Zendesk_Support_Category_Updates>;
};

/** mutation root */
export type Mutation_RootUpdate_Zendesk_Support_TicketsArgs = {
  _inc?: Maybe<Zendesk_Support_Tickets_Inc_Input>;
  _set?: Maybe<Zendesk_Support_Tickets_Set_Input>;
  where: Zendesk_Support_Tickets_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_Zendesk_Support_Tickets_By_PkArgs = {
  _inc?: Maybe<Zendesk_Support_Tickets_Inc_Input>;
  _set?: Maybe<Zendesk_Support_Tickets_Set_Input>;
  pk_columns: Zendesk_Support_Tickets_Pk_Columns_Input;
};

/** mutation root */
export type Mutation_RootUpdate_Zendesk_Support_Tickets_ManyArgs = {
  updates: Array<Zendesk_Support_Tickets_Updates>;
};

/** mutation root */
export type Mutation_RootUpdateAzureMonitorConfigArgs = {
  activedirectory_client_id?: Maybe<Scalars['String']>;
  activedirectory_client_secret?: Maybe<Scalars['String']>;
  activedirectory_tenant_id?: Maybe<Scalars['String']>;
  attributes?: Maybe<Scalars['jsonb']>;
  azure_region?: Maybe<Scalars['String']>;
  azuremonitor_workspace_id?: Maybe<Scalars['String']>;
  instrumentation_key?: Maybe<Scalars['String']>;
  log_type?: Maybe<Scalars['String']>;
  metric_namespace?: Maybe<Scalars['String']>;
  project_id: Scalars['uuid'];
  resource_id?: Maybe<Scalars['String']>;
  shared_key?: Maybe<Scalars['String']>;
};

/** mutation root */
export type Mutation_RootUpdateBillingManagerArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootUpdateDatadogConfigArgs = {
  datadog_region?: Maybe<Scalars['String']>;
  host?: Maybe<Scalars['String']>;
  key?: Maybe<Scalars['String']>;
  project_id: Scalars['uuid'];
  service_name?: Maybe<Scalars['String']>;
  tags?: Maybe<Scalars['String']>;
};

/** mutation root */
export type Mutation_RootUpdateGithubIntegrationArgs = {
  payload: UpdateGithubIntegrationInput;
};

/** mutation root */
export type Mutation_RootUpdateNewrelicConfigArgs = {
  attributes?: Maybe<Scalars['jsonb']>;
  key?: Maybe<Scalars['String']>;
  newrelic_region?: Maybe<Scalars['String']>;
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootUpdateOpentelemetryConfigArgs = {
  attributes?: Maybe<Scalars['jsonb']>;
  batch_size?: Maybe<Scalars['Int']>;
  connection_type?: Maybe<Scalars['String']>;
  endpoint?: Maybe<Scalars['String']>;
  export_traces?: Maybe<Scalars['Boolean']>;
  headers?: Maybe<Scalars['jsonb']>;
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootUpdatePrometheusAccessTokenArgs = {
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootUpdatePrometheusConfigArgs = {
  labels?: Maybe<Scalars['jsonb']>;
  namespace?: Maybe<Scalars['String']>;
  project_id: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootUpdateServerEndpointArgs = {
  project: UpdateServerEndpointInput;
};

/** mutation root */
export type Mutation_RootUpdateTenantEnvArgs = {
  currentHash: Scalars['String'];
  envs: Array<UpdateEnvObject>;
  tenantId: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootUpdateTenantNameArgs = {
  name: Scalars['String'];
  tenantId: Scalars['uuid'];
};

/** mutation root */
export type Mutation_RootUpdateTenantStatusArgs = {
  input: UpdateTenantStatusInputPayload;
};

/** mutation root */
export type Mutation_RootVercelSetIntegrationArgs = {
  payload: SetVercelIntegrationInput;
};

/** mutation root */
export type Mutation_RootVercelTokenExchangeArgs = {
  payload?: Maybe<VercelTokenInputPayload>;
};

/** Stores integration state for all neon DB integrations */
export type Neon_Db_Integration = {
  __typename?: 'neon_db_integration';
  created_at: Scalars['timestamptz'];
  env_var?: Maybe<Scalars['String']>;
  hasura_cloud_project_id: Scalars['uuid'];
  id: Scalars['uuid'];
  neon_branch_id?: Maybe<Scalars['String']>;
  neon_database_id?: Maybe<Scalars['String']>;
  neon_integration_version: Scalars['String'];
  neon_project_id: Scalars['String'];
  /** An object relationship */
  project: Projects;
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "neon_db_integration" */
export type Neon_Db_Integration_Aggregate = {
  __typename?: 'neon_db_integration_aggregate';
  aggregate?: Maybe<Neon_Db_Integration_Aggregate_Fields>;
  nodes: Array<Neon_Db_Integration>;
};

/** aggregate fields of "neon_db_integration" */
export type Neon_Db_Integration_Aggregate_Fields = {
  __typename?: 'neon_db_integration_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Neon_Db_Integration_Max_Fields>;
  min?: Maybe<Neon_Db_Integration_Min_Fields>;
};

/** aggregate fields of "neon_db_integration" */
export type Neon_Db_Integration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Neon_Db_Integration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "neon_db_integration". All fields are combined with a logical 'AND'. */
export type Neon_Db_Integration_Bool_Exp = {
  _and?: Maybe<Array<Neon_Db_Integration_Bool_Exp>>;
  _not?: Maybe<Neon_Db_Integration_Bool_Exp>;
  _or?: Maybe<Array<Neon_Db_Integration_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  env_var?: Maybe<String_Comparison_Exp>;
  hasura_cloud_project_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  neon_branch_id?: Maybe<String_Comparison_Exp>;
  neon_database_id?: Maybe<String_Comparison_Exp>;
  neon_integration_version?: Maybe<String_Comparison_Exp>;
  neon_project_id?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "neon_db_integration" */
export enum Neon_Db_Integration_Constraint {
  /** unique or primary key constraint on columns "id" */
  NeonDbIntegrationPkey = 'neon_db_integration_pkey',
}

/** input type for inserting data into table "neon_db_integration" */
export type Neon_Db_Integration_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  env_var?: Maybe<Scalars['String']>;
  hasura_cloud_project_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  neon_branch_id?: Maybe<Scalars['String']>;
  neon_database_id?: Maybe<Scalars['String']>;
  neon_integration_version?: Maybe<Scalars['String']>;
  neon_project_id?: Maybe<Scalars['String']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Neon_Db_Integration_Max_Fields = {
  __typename?: 'neon_db_integration_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  env_var?: Maybe<Scalars['String']>;
  hasura_cloud_project_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  neon_branch_id?: Maybe<Scalars['String']>;
  neon_database_id?: Maybe<Scalars['String']>;
  neon_integration_version?: Maybe<Scalars['String']>;
  neon_project_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Neon_Db_Integration_Min_Fields = {
  __typename?: 'neon_db_integration_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  env_var?: Maybe<Scalars['String']>;
  hasura_cloud_project_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  neon_branch_id?: Maybe<Scalars['String']>;
  neon_database_id?: Maybe<Scalars['String']>;
  neon_integration_version?: Maybe<Scalars['String']>;
  neon_project_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "neon_db_integration" */
export type Neon_Db_Integration_Mutation_Response = {
  __typename?: 'neon_db_integration_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Neon_Db_Integration>;
};

/** on_conflict condition type for table "neon_db_integration" */
export type Neon_Db_Integration_On_Conflict = {
  constraint: Neon_Db_Integration_Constraint;
  update_columns?: Array<Neon_Db_Integration_Update_Column>;
  where?: Maybe<Neon_Db_Integration_Bool_Exp>;
};

/** Ordering options when selecting data from "neon_db_integration". */
export type Neon_Db_Integration_Order_By = {
  created_at?: Maybe<Order_By>;
  env_var?: Maybe<Order_By>;
  hasura_cloud_project_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  neon_branch_id?: Maybe<Order_By>;
  neon_database_id?: Maybe<Order_By>;
  neon_integration_version?: Maybe<Order_By>;
  neon_project_id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: neon_db_integration */
export type Neon_Db_Integration_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "neon_db_integration" */
export enum Neon_Db_Integration_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EnvVar = 'env_var',
  /** column name */
  HasuraCloudProjectId = 'hasura_cloud_project_id',
  /** column name */
  Id = 'id',
  /** column name */
  NeonBranchId = 'neon_branch_id',
  /** column name */
  NeonDatabaseId = 'neon_database_id',
  /** column name */
  NeonIntegrationVersion = 'neon_integration_version',
  /** column name */
  NeonProjectId = 'neon_project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "neon_db_integration" */
export type Neon_Db_Integration_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  env_var?: Maybe<Scalars['String']>;
  hasura_cloud_project_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  neon_branch_id?: Maybe<Scalars['String']>;
  neon_database_id?: Maybe<Scalars['String']>;
  neon_integration_version?: Maybe<Scalars['String']>;
  neon_project_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "neon_db_integration" */
export type Neon_Db_Integration_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Neon_Db_Integration_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Neon_Db_Integration_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  env_var?: Maybe<Scalars['String']>;
  hasura_cloud_project_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  neon_branch_id?: Maybe<Scalars['String']>;
  neon_database_id?: Maybe<Scalars['String']>;
  neon_integration_version?: Maybe<Scalars['String']>;
  neon_project_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "neon_db_integration" */
export enum Neon_Db_Integration_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EnvVar = 'env_var',
  /** column name */
  HasuraCloudProjectId = 'hasura_cloud_project_id',
  /** column name */
  Id = 'id',
  /** column name */
  NeonBranchId = 'neon_branch_id',
  /** column name */
  NeonDatabaseId = 'neon_database_id',
  /** column name */
  NeonIntegrationVersion = 'neon_integration_version',
  /** column name */
  NeonProjectId = 'neon_project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Neon_Db_Integration_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Neon_Db_Integration_Set_Input>;
  /** filter the rows which have to be updated */
  where: Neon_Db_Integration_Bool_Exp;
};

export type NeonCreateDatabaseResponse = {
  __typename?: 'NeonCreateDatabaseResponse';
  databaseUrl?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  envVar?: Maybe<Scalars['String']>;
  integrationId?: Maybe<Scalars['uuid']>;
  isAuthenticated: Scalars['Boolean'];
  neon_db_integration?: Maybe<Neon_Db_Integration>;
};

export type NeonExchangeTokenResponse = {
  __typename?: 'NeonExchangeTokenResponse';
  accessToken: Scalars['String'];
  email: Scalars['String'];
};

export type NeonGetUserInfoResponse = {
  __typename?: 'NeonGetUserInfoResponse';
  email?: Maybe<Scalars['String']>;
  isAuthenticated: Scalars['Boolean'];
};

export type NewPlansProjectOutput = {
  __typename?: 'NewPlansProjectOutput';
  data_usage?: Maybe<Scalars['Int']>;
  data_usage_amount?: Maybe<Scalars['Int']>;
  db_usage?: Maybe<Array<Maybe<ProjectDbUsage>>>;
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
};

export type NewPlansProjectUsageOutput = {
  __typename?: 'NewPlansProjectUsageOutput';
  data_usage: Scalars['Int'];
  data_usage_amount: Scalars['Int'];
  db_usage: Array<ProjectDbUsage>;
  project_id: Scalars['uuid'];
  project_name?: Maybe<Scalars['String']>;
};

/** columns and relationships of "newrelic_config" */
export type Newrelic_Config = {
  __typename?: 'newrelic_config';
  attributes: Scalars['jsonb'];
  created_at: Scalars['timestamptz'];
  key: Scalars['String'];
  logs_last_logged: Scalars['timestamptz'];
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged: Scalars['timestamptz'];
  metrics_response_code?: Maybe<Scalars['Int']>;
  newrelic_region: Scalars['String'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
};

/** columns and relationships of "newrelic_config" */
export type Newrelic_ConfigAttributesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "newrelic_config" */
export type Newrelic_Config_Aggregate = {
  __typename?: 'newrelic_config_aggregate';
  aggregate?: Maybe<Newrelic_Config_Aggregate_Fields>;
  nodes: Array<Newrelic_Config>;
};

/** aggregate fields of "newrelic_config" */
export type Newrelic_Config_Aggregate_Fields = {
  __typename?: 'newrelic_config_aggregate_fields';
  avg?: Maybe<Newrelic_Config_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Newrelic_Config_Max_Fields>;
  min?: Maybe<Newrelic_Config_Min_Fields>;
  stddev?: Maybe<Newrelic_Config_Stddev_Fields>;
  stddev_pop?: Maybe<Newrelic_Config_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Newrelic_Config_Stddev_Samp_Fields>;
  sum?: Maybe<Newrelic_Config_Sum_Fields>;
  var_pop?: Maybe<Newrelic_Config_Var_Pop_Fields>;
  var_samp?: Maybe<Newrelic_Config_Var_Samp_Fields>;
  variance?: Maybe<Newrelic_Config_Variance_Fields>;
};

/** aggregate fields of "newrelic_config" */
export type Newrelic_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Newrelic_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Newrelic_Config_Append_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Newrelic_Config_Avg_Fields = {
  __typename?: 'newrelic_config_avg_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "newrelic_config". All fields are combined with a logical 'AND'. */
export type Newrelic_Config_Bool_Exp = {
  _and?: Maybe<Array<Newrelic_Config_Bool_Exp>>;
  _not?: Maybe<Newrelic_Config_Bool_Exp>;
  _or?: Maybe<Array<Newrelic_Config_Bool_Exp>>;
  attributes?: Maybe<Jsonb_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  key?: Maybe<String_Comparison_Exp>;
  logs_last_logged?: Maybe<Timestamptz_Comparison_Exp>;
  logs_response_code?: Maybe<Int_Comparison_Exp>;
  metrics_last_logged?: Maybe<Timestamptz_Comparison_Exp>;
  metrics_response_code?: Maybe<Int_Comparison_Exp>;
  newrelic_region?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "newrelic_config" */
export enum Newrelic_Config_Constraint {
  /** unique or primary key constraint on columns "project_id" */
  NewrelicConfigPkey = 'newrelic_config_pkey',
  /** unique or primary key constraint on columns "project_id" */
  NewrelicConfigProjectIdKey = 'newrelic_config_project_id_key',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Newrelic_Config_Delete_At_Path_Input = {
  attributes?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Newrelic_Config_Delete_Elem_Input = {
  attributes?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Newrelic_Config_Delete_Key_Input = {
  attributes?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "newrelic_config" */
export type Newrelic_Config_Inc_Input = {
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "newrelic_config" */
export type Newrelic_Config_Insert_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  newrelic_region?: Maybe<Scalars['String']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Newrelic_Config_Max_Fields = {
  __typename?: 'newrelic_config_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  newrelic_region?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Newrelic_Config_Min_Fields = {
  __typename?: 'newrelic_config_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  newrelic_region?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "newrelic_config" */
export type Newrelic_Config_Mutation_Response = {
  __typename?: 'newrelic_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Newrelic_Config>;
};

/** input type for inserting object relation for remote table "newrelic_config" */
export type Newrelic_Config_Obj_Rel_Insert_Input = {
  data: Newrelic_Config_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Newrelic_Config_On_Conflict>;
};

/** on_conflict condition type for table "newrelic_config" */
export type Newrelic_Config_On_Conflict = {
  constraint: Newrelic_Config_Constraint;
  update_columns?: Array<Newrelic_Config_Update_Column>;
  where?: Maybe<Newrelic_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "newrelic_config". */
export type Newrelic_Config_Order_By = {
  attributes?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  logs_last_logged?: Maybe<Order_By>;
  logs_response_code?: Maybe<Order_By>;
  metrics_last_logged?: Maybe<Order_By>;
  metrics_response_code?: Maybe<Order_By>;
  newrelic_region?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
};

/** primary key columns input for table: newrelic_config */
export type Newrelic_Config_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Newrelic_Config_Prepend_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "newrelic_config" */
export enum Newrelic_Config_Select_Column {
  /** column name */
  Attributes = 'attributes',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Key = 'key',
  /** column name */
  LogsLastLogged = 'logs_last_logged',
  /** column name */
  LogsResponseCode = 'logs_response_code',
  /** column name */
  MetricsLastLogged = 'metrics_last_logged',
  /** column name */
  MetricsResponseCode = 'metrics_response_code',
  /** column name */
  NewrelicRegion = 'newrelic_region',
  /** column name */
  ProjectId = 'project_id',
}

/** input type for updating data in table "newrelic_config" */
export type Newrelic_Config_Set_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  newrelic_region?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Newrelic_Config_Stddev_Fields = {
  __typename?: 'newrelic_config_stddev_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Newrelic_Config_Stddev_Pop_Fields = {
  __typename?: 'newrelic_config_stddev_pop_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Newrelic_Config_Stddev_Samp_Fields = {
  __typename?: 'newrelic_config_stddev_samp_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "newrelic_config" */
export type Newrelic_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Newrelic_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Newrelic_Config_Stream_Cursor_Value_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  logs_last_logged?: Maybe<Scalars['timestamptz']>;
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  newrelic_region?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Newrelic_Config_Sum_Fields = {
  __typename?: 'newrelic_config_sum_fields';
  logs_response_code?: Maybe<Scalars['Int']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
};

/** update columns of table "newrelic_config" */
export enum Newrelic_Config_Update_Column {
  /** column name */
  Attributes = 'attributes',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Key = 'key',
  /** column name */
  LogsLastLogged = 'logs_last_logged',
  /** column name */
  LogsResponseCode = 'logs_response_code',
  /** column name */
  MetricsLastLogged = 'metrics_last_logged',
  /** column name */
  MetricsResponseCode = 'metrics_response_code',
  /** column name */
  NewrelicRegion = 'newrelic_region',
  /** column name */
  ProjectId = 'project_id',
}

export type Newrelic_Config_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Newrelic_Config_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Newrelic_Config_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Newrelic_Config_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Newrelic_Config_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Newrelic_Config_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Newrelic_Config_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Newrelic_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Newrelic_Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Newrelic_Config_Var_Pop_Fields = {
  __typename?: 'newrelic_config_var_pop_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Newrelic_Config_Var_Samp_Fields = {
  __typename?: 'newrelic_config_var_samp_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Newrelic_Config_Variance_Fields = {
  __typename?: 'newrelic_config_variance_fields';
  logs_response_code?: Maybe<Scalars['Float']>;
  metrics_response_code?: Maybe<Scalars['Float']>;
};

export type NewrelicConfigResponse = {
  __typename?: 'NewrelicConfigResponse';
  project_id: Scalars['uuid'];
};

/** columns and relationships of "node_pool_type" */
export type Node_Pool_Type = {
  __typename?: 'node_pool_type';
  description: Scalars['String'];
  name: Scalars['String'];
};

/** aggregated selection of "node_pool_type" */
export type Node_Pool_Type_Aggregate = {
  __typename?: 'node_pool_type_aggregate';
  aggregate?: Maybe<Node_Pool_Type_Aggregate_Fields>;
  nodes: Array<Node_Pool_Type>;
};

/** aggregate fields of "node_pool_type" */
export type Node_Pool_Type_Aggregate_Fields = {
  __typename?: 'node_pool_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Node_Pool_Type_Max_Fields>;
  min?: Maybe<Node_Pool_Type_Min_Fields>;
};

/** aggregate fields of "node_pool_type" */
export type Node_Pool_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Node_Pool_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "node_pool_type". All fields are combined with a logical 'AND'. */
export type Node_Pool_Type_Bool_Exp = {
  _and?: Maybe<Array<Node_Pool_Type_Bool_Exp>>;
  _not?: Maybe<Node_Pool_Type_Bool_Exp>;
  _or?: Maybe<Array<Node_Pool_Type_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "node_pool_type" */
export enum Node_Pool_Type_Constraint {
  /** unique or primary key constraint on columns "name" */
  NodePoolTypePkey = 'node_pool_type_pkey',
}

export enum Node_Pool_Type_Enum {
  /** Node pool for apps related resources */
  Apps = 'apps',
  /** Node pool for data connector related resources */
  DataConnector = 'data_connector',
  /** Node pool for gateway related resources */
  Gateway = 'gateway',
  /** Node pool for metrics related resources */
  Metrics = 'metrics',
  /** Node pool for monitoring related resources */
  Monitoring = 'monitoring',
  /** Node pool for multitenant related resources */
  Multitenant = 'multitenant',
  /** Node pool for timescale related resources */
  Timescale = 'timescale',
  /** Node pool for v3 server */
  V3Server = 'v3_server',
}

/** Boolean expression to compare columns of type "node_pool_type_enum". All fields are combined with logical 'AND'. */
export type Node_Pool_Type_Enum_Comparison_Exp = {
  _eq?: Maybe<Node_Pool_Type_Enum>;
  _in?: Maybe<Array<Node_Pool_Type_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Node_Pool_Type_Enum>;
  _nin?: Maybe<Array<Node_Pool_Type_Enum>>;
};

/** input type for inserting data into table "node_pool_type" */
export type Node_Pool_Type_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Node_Pool_Type_Max_Fields = {
  __typename?: 'node_pool_type_max_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Node_Pool_Type_Min_Fields = {
  __typename?: 'node_pool_type_min_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "node_pool_type" */
export type Node_Pool_Type_Mutation_Response = {
  __typename?: 'node_pool_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Node_Pool_Type>;
};

/** on_conflict condition type for table "node_pool_type" */
export type Node_Pool_Type_On_Conflict = {
  constraint: Node_Pool_Type_Constraint;
  update_columns?: Array<Node_Pool_Type_Update_Column>;
  where?: Maybe<Node_Pool_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "node_pool_type". */
export type Node_Pool_Type_Order_By = {
  description?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** primary key columns input for table: node_pool_type */
export type Node_Pool_Type_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "node_pool_type" */
export enum Node_Pool_Type_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

/** input type for updating data in table "node_pool_type" */
export type Node_Pool_Type_Set_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "node_pool_type" */
export type Node_Pool_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Node_Pool_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Node_Pool_Type_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** update columns of table "node_pool_type" */
export enum Node_Pool_Type_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

export type Node_Pool_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Node_Pool_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Node_Pool_Type_Bool_Exp;
};

/** columns and relationships of "node_pools" */
export type Node_Pools = {
  __typename?: 'node_pools';
  cloud: Scalars['String'];
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  dedicated_vpc?: Maybe<Dedicated_Vpc>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  hasura_clusters: Array<Hasura_Cluster>;
  /** An aggregate relationship */
  hasura_clusters_aggregate: Hasura_Cluster_Aggregate;
  id: Scalars['uuid'];
  input_variables: Scalars['jsonb'];
  name: Scalars['String'];
  pool_type: Node_Pool_Type_Enum;
  region: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "node_pools" */
export type Node_PoolsHasura_ClustersArgs = {
  distinct_on?: Maybe<Array<Hasura_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Cluster_Order_By>>;
  where?: Maybe<Hasura_Cluster_Bool_Exp>;
};

/** columns and relationships of "node_pools" */
export type Node_PoolsHasura_Clusters_AggregateArgs = {
  distinct_on?: Maybe<Array<Hasura_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Cluster_Order_By>>;
  where?: Maybe<Hasura_Cluster_Bool_Exp>;
};

/** columns and relationships of "node_pools" */
export type Node_PoolsInput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "node_pools" */
export type Node_Pools_Aggregate = {
  __typename?: 'node_pools_aggregate';
  aggregate?: Maybe<Node_Pools_Aggregate_Fields>;
  nodes: Array<Node_Pools>;
};

/** aggregate fields of "node_pools" */
export type Node_Pools_Aggregate_Fields = {
  __typename?: 'node_pools_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Node_Pools_Max_Fields>;
  min?: Maybe<Node_Pools_Min_Fields>;
};

/** aggregate fields of "node_pools" */
export type Node_Pools_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Node_Pools_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Node_Pools_Append_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "node_pools". All fields are combined with a logical 'AND'. */
export type Node_Pools_Bool_Exp = {
  _and?: Maybe<Array<Node_Pools_Bool_Exp>>;
  _not?: Maybe<Node_Pools_Bool_Exp>;
  _or?: Maybe<Array<Node_Pools_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Bool_Exp>;
  dedicated_vpc_id?: Maybe<Uuid_Comparison_Exp>;
  hasura_clusters?: Maybe<Hasura_Cluster_Bool_Exp>;
  hasura_clusters_aggregate?: Maybe<Hasura_Cluster_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  input_variables?: Maybe<Jsonb_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  pool_type?: Maybe<Node_Pool_Type_Enum_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "node_pools" */
export enum Node_Pools_Constraint {
  /** unique or primary key constraint on columns "id" */
  NodePoolsPkey = 'node_pools_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Node_Pools_Delete_At_Path_Input = {
  input_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Node_Pools_Delete_Elem_Input = {
  input_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Node_Pools_Delete_Key_Input = {
  input_variables?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "node_pools" */
export type Node_Pools_Insert_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Obj_Rel_Insert_Input>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  hasura_clusters?: Maybe<Hasura_Cluster_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  name?: Maybe<Scalars['String']>;
  pool_type?: Maybe<Node_Pool_Type_Enum>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Node_Pools_Max_Fields = {
  __typename?: 'node_pools_max_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Node_Pools_Min_Fields = {
  __typename?: 'node_pools_min_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "node_pools" */
export type Node_Pools_Mutation_Response = {
  __typename?: 'node_pools_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Node_Pools>;
};

/** input type for inserting object relation for remote table "node_pools" */
export type Node_Pools_Obj_Rel_Insert_Input = {
  data: Node_Pools_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Node_Pools_On_Conflict>;
};

/** on_conflict condition type for table "node_pools" */
export type Node_Pools_On_Conflict = {
  constraint: Node_Pools_Constraint;
  update_columns?: Array<Node_Pools_Update_Column>;
  where?: Maybe<Node_Pools_Bool_Exp>;
};

/** Ordering options when selecting data from "node_pools". */
export type Node_Pools_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Order_By>;
  dedicated_vpc_id?: Maybe<Order_By>;
  hasura_clusters_aggregate?: Maybe<Hasura_Cluster_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  input_variables?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  pool_type?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: node_pools */
export type Node_Pools_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Node_Pools_Prepend_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "node_pools" */
export enum Node_Pools_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DedicatedVpcId = 'dedicated_vpc_id',
  /** column name */
  Id = 'id',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  Name = 'name',
  /** column name */
  PoolType = 'pool_type',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "node_pools" */
export type Node_Pools_Set_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  name?: Maybe<Scalars['String']>;
  pool_type?: Maybe<Node_Pool_Type_Enum>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "node_pools" */
export type Node_Pools_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Node_Pools_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Node_Pools_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  name?: Maybe<Scalars['String']>;
  pool_type?: Maybe<Node_Pool_Type_Enum>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "node_pools" */
export enum Node_Pools_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DedicatedVpcId = 'dedicated_vpc_id',
  /** column name */
  Id = 'id',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  Name = 'name',
  /** column name */
  PoolType = 'pool_type',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Node_Pools_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Node_Pools_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Node_Pools_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Node_Pools_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Node_Pools_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Node_Pools_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Node_Pools_Set_Input>;
  /** filter the rows which have to be updated */
  where: Node_Pools_Bool_Exp;
};

/** Notifications that can be triggered per user */
export type Notification = {
  __typename?: 'notification';
  content?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  end_date?: Maybe<Scalars['timestamptz']>;
  href?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  image?: Maybe<Scalars['String']>;
  is_active: Scalars['Boolean'];
  read_at?: Maybe<Scalars['timestamptz']>;
  start_date?: Maybe<Scalars['timestamptz']>;
  title: Scalars['String'];
  type: Scalars['String'];
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "notification" */
export type Notification_Aggregate = {
  __typename?: 'notification_aggregate';
  aggregate?: Maybe<Notification_Aggregate_Fields>;
  nodes: Array<Notification>;
};

/** aggregate fields of "notification" */
export type Notification_Aggregate_Fields = {
  __typename?: 'notification_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Notification_Max_Fields>;
  min?: Maybe<Notification_Min_Fields>;
};

/** aggregate fields of "notification" */
export type Notification_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Notification_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "notification". All fields are combined with a logical 'AND'. */
export type Notification_Bool_Exp = {
  _and?: Maybe<Array<Notification_Bool_Exp>>;
  _not?: Maybe<Notification_Bool_Exp>;
  _or?: Maybe<Array<Notification_Bool_Exp>>;
  content?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  end_date?: Maybe<Timestamptz_Comparison_Exp>;
  href?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  image?: Maybe<String_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  read_at?: Maybe<Timestamptz_Comparison_Exp>;
  start_date?: Maybe<Timestamptz_Comparison_Exp>;
  title?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "notification" */
export enum Notification_Constraint {
  /** unique or primary key constraint on columns "id" */
  NotificationPkey = 'notification_pkey',
}

/** input type for inserting data into table "notification" */
export type Notification_Insert_Input = {
  content?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  end_date?: Maybe<Scalars['timestamptz']>;
  href?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  read_at?: Maybe<Scalars['timestamptz']>;
  start_date?: Maybe<Scalars['timestamptz']>;
  title?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Notification_Max_Fields = {
  __typename?: 'notification_max_fields';
  content?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  end_date?: Maybe<Scalars['timestamptz']>;
  href?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image?: Maybe<Scalars['String']>;
  read_at?: Maybe<Scalars['timestamptz']>;
  start_date?: Maybe<Scalars['timestamptz']>;
  title?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Notification_Min_Fields = {
  __typename?: 'notification_min_fields';
  content?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  end_date?: Maybe<Scalars['timestamptz']>;
  href?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image?: Maybe<Scalars['String']>;
  read_at?: Maybe<Scalars['timestamptz']>;
  start_date?: Maybe<Scalars['timestamptz']>;
  title?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "notification" */
export type Notification_Mutation_Response = {
  __typename?: 'notification_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Notification>;
};

/** on_conflict condition type for table "notification" */
export type Notification_On_Conflict = {
  constraint: Notification_Constraint;
  update_columns?: Array<Notification_Update_Column>;
  where?: Maybe<Notification_Bool_Exp>;
};

/** Ordering options when selecting data from "notification". */
export type Notification_Order_By = {
  content?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  end_date?: Maybe<Order_By>;
  href?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  image?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  read_at?: Maybe<Order_By>;
  start_date?: Maybe<Order_By>;
  title?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: notification */
export type Notification_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "notification" */
export enum Notification_Select_Column {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Href = 'href',
  /** column name */
  Id = 'id',
  /** column name */
  Image = 'image',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  ReadAt = 'read_at',
  /** column name */
  StartDate = 'start_date',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "notification" */
export type Notification_Set_Input = {
  content?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  end_date?: Maybe<Scalars['timestamptz']>;
  href?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  read_at?: Maybe<Scalars['timestamptz']>;
  start_date?: Maybe<Scalars['timestamptz']>;
  title?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "notification" */
export type Notification_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Notification_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Notification_Stream_Cursor_Value_Input = {
  content?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  end_date?: Maybe<Scalars['timestamptz']>;
  href?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  image?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  read_at?: Maybe<Scalars['timestamptz']>;
  start_date?: Maybe<Scalars['timestamptz']>;
  title?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Hasura enum to capture type of notification */
export type Notification_Type = {
  __typename?: 'notification_type';
  description: Scalars['String'];
  type: Scalars['String'];
};

/** aggregated selection of "notification_type" */
export type Notification_Type_Aggregate = {
  __typename?: 'notification_type_aggregate';
  aggregate?: Maybe<Notification_Type_Aggregate_Fields>;
  nodes: Array<Notification_Type>;
};

/** aggregate fields of "notification_type" */
export type Notification_Type_Aggregate_Fields = {
  __typename?: 'notification_type_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Notification_Type_Max_Fields>;
  min?: Maybe<Notification_Type_Min_Fields>;
};

/** aggregate fields of "notification_type" */
export type Notification_Type_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Notification_Type_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "notification_type". All fields are combined with a logical 'AND'. */
export type Notification_Type_Bool_Exp = {
  _and?: Maybe<Array<Notification_Type_Bool_Exp>>;
  _not?: Maybe<Notification_Type_Bool_Exp>;
  _or?: Maybe<Array<Notification_Type_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "notification_type" */
export enum Notification_Type_Constraint {
  /** unique or primary key constraint on columns "type" */
  NotificationTypePkey = 'notification_type_pkey',
}

/** input type for inserting data into table "notification_type" */
export type Notification_Type_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Notification_Type_Max_Fields = {
  __typename?: 'notification_type_max_fields';
  description?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Notification_Type_Min_Fields = {
  __typename?: 'notification_type_min_fields';
  description?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "notification_type" */
export type Notification_Type_Mutation_Response = {
  __typename?: 'notification_type_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Notification_Type>;
};

/** on_conflict condition type for table "notification_type" */
export type Notification_Type_On_Conflict = {
  constraint: Notification_Type_Constraint;
  update_columns?: Array<Notification_Type_Update_Column>;
  where?: Maybe<Notification_Type_Bool_Exp>;
};

/** Ordering options when selecting data from "notification_type". */
export type Notification_Type_Order_By = {
  description?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** primary key columns input for table: notification_type */
export type Notification_Type_Pk_Columns_Input = {
  type: Scalars['String'];
};

/** select columns of table "notification_type" */
export enum Notification_Type_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Type = 'type',
}

/** input type for updating data in table "notification_type" */
export type Notification_Type_Set_Input = {
  description?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "notification_type" */
export type Notification_Type_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Notification_Type_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Notification_Type_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** update columns of table "notification_type" */
export enum Notification_Type_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Type = 'type',
}

export type Notification_Type_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Notification_Type_Set_Input>;
  /** filter the rows which have to be updated */
  where: Notification_Type_Bool_Exp;
};

/** update columns of table "notification" */
export enum Notification_Update_Column {
  /** column name */
  Content = 'content',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndDate = 'end_date',
  /** column name */
  Href = 'href',
  /** column name */
  Id = 'id',
  /** column name */
  Image = 'image',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  ReadAt = 'read_at',
  /** column name */
  StartDate = 'start_date',
  /** column name */
  Title = 'title',
  /** column name */
  Type = 'type',
  /** column name */
  UserId = 'user_id',
}

export type Notification_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Notification_Set_Input>;
  /** filter the rows which have to be updated */
  where: Notification_Bool_Exp;
};

export type NumberOfConnectedSourcesOutput = {
  __typename?: 'NumberOfConnectedSourcesOutput';
  databases_connected?: Maybe<Scalars['Int']>;
  plan_name?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  project_info?: Maybe<Projects>;
  unsupported?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  _eq?: Maybe<Scalars['numeric']>;
  _gt?: Maybe<Scalars['numeric']>;
  _gte?: Maybe<Scalars['numeric']>;
  _in?: Maybe<Array<Scalars['numeric']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['numeric']>;
  _lte?: Maybe<Scalars['numeric']>;
  _neq?: Maybe<Scalars['numeric']>;
  _nin?: Maybe<Array<Scalars['numeric']>>;
};

/** Sample DB cohort and its activity */
export type Onboarding_Sample_Db_Cohort = {
  __typename?: 'onboarding_sample_db_cohort';
  activity: Scalars['jsonb'];
  created_at: Scalars['timestamptz'];
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['uuid'];
};

/** Sample DB cohort and its activity */
export type Onboarding_Sample_Db_CohortActivityArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "onboarding_sample_db_cohort" */
export type Onboarding_Sample_Db_Cohort_Aggregate = {
  __typename?: 'onboarding_sample_db_cohort_aggregate';
  aggregate?: Maybe<Onboarding_Sample_Db_Cohort_Aggregate_Fields>;
  nodes: Array<Onboarding_Sample_Db_Cohort>;
};

/** aggregate fields of "onboarding_sample_db_cohort" */
export type Onboarding_Sample_Db_Cohort_Aggregate_Fields = {
  __typename?: 'onboarding_sample_db_cohort_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Onboarding_Sample_Db_Cohort_Max_Fields>;
  min?: Maybe<Onboarding_Sample_Db_Cohort_Min_Fields>;
};

/** aggregate fields of "onboarding_sample_db_cohort" */
export type Onboarding_Sample_Db_Cohort_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Onboarding_Sample_Db_Cohort_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Onboarding_Sample_Db_Cohort_Append_Input = {
  activity?: Maybe<Scalars['jsonb']>;
};

/**
 * Boolean expression to filter rows from the table "onboarding_sample_db_cohort".
 * All fields are combined with a logical 'AND'.
 */
export type Onboarding_Sample_Db_Cohort_Bool_Exp = {
  _and?: Maybe<Array<Onboarding_Sample_Db_Cohort_Bool_Exp>>;
  _not?: Maybe<Onboarding_Sample_Db_Cohort_Bool_Exp>;
  _or?: Maybe<Array<Onboarding_Sample_Db_Cohort_Bool_Exp>>;
  activity?: Maybe<Jsonb_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "onboarding_sample_db_cohort" */
export enum Onboarding_Sample_Db_Cohort_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  OnboardingSampleDbCohortPkey = 'onboarding_sample_db_cohort_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Onboarding_Sample_Db_Cohort_Delete_At_Path_Input = {
  activity?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Onboarding_Sample_Db_Cohort_Delete_Elem_Input = {
  activity?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Onboarding_Sample_Db_Cohort_Delete_Key_Input = {
  activity?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "onboarding_sample_db_cohort" */
export type Onboarding_Sample_Db_Cohort_Insert_Input = {
  activity?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Onboarding_Sample_Db_Cohort_Max_Fields = {
  __typename?: 'onboarding_sample_db_cohort_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Onboarding_Sample_Db_Cohort_Min_Fields = {
  __typename?: 'onboarding_sample_db_cohort_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "onboarding_sample_db_cohort" */
export type Onboarding_Sample_Db_Cohort_Mutation_Response = {
  __typename?: 'onboarding_sample_db_cohort_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Onboarding_Sample_Db_Cohort>;
};

/** on_conflict condition type for table "onboarding_sample_db_cohort" */
export type Onboarding_Sample_Db_Cohort_On_Conflict = {
  constraint: Onboarding_Sample_Db_Cohort_Constraint;
  update_columns?: Array<Onboarding_Sample_Db_Cohort_Update_Column>;
  where?: Maybe<Onboarding_Sample_Db_Cohort_Bool_Exp>;
};

/** Ordering options when selecting data from "onboarding_sample_db_cohort". */
export type Onboarding_Sample_Db_Cohort_Order_By = {
  activity?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: onboarding_sample_db_cohort */
export type Onboarding_Sample_Db_Cohort_Pk_Columns_Input = {
  user_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Onboarding_Sample_Db_Cohort_Prepend_Input = {
  activity?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "onboarding_sample_db_cohort" */
export enum Onboarding_Sample_Db_Cohort_Select_Column {
  /** column name */
  Activity = 'activity',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "onboarding_sample_db_cohort" */
export type Onboarding_Sample_Db_Cohort_Set_Input = {
  activity?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "onboarding_sample_db_cohort" */
export type Onboarding_Sample_Db_Cohort_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Onboarding_Sample_Db_Cohort_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Onboarding_Sample_Db_Cohort_Stream_Cursor_Value_Input = {
  activity?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "onboarding_sample_db_cohort" */
export enum Onboarding_Sample_Db_Cohort_Update_Column {
  /** column name */
  Activity = 'activity',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

export type Onboarding_Sample_Db_Cohort_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Onboarding_Sample_Db_Cohort_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Onboarding_Sample_Db_Cohort_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Onboarding_Sample_Db_Cohort_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Onboarding_Sample_Db_Cohort_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Onboarding_Sample_Db_Cohort_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Onboarding_Sample_Db_Cohort_Set_Input>;
  /** filter the rows which have to be updated */
  where: Onboarding_Sample_Db_Cohort_Bool_Exp;
};

/** Configuration for onboarding sample DB experiment */
export type Onboarding_Sample_Db_Config = {
  __typename?: 'onboarding_sample_db_config';
  created_at: Scalars['timestamptz'];
  database_url: Scalars['String'];
  metadata: Scalars['jsonb'];
  rollout_percentage: Scalars['Int'];
  status: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** Configuration for onboarding sample DB experiment */
export type Onboarding_Sample_Db_ConfigMetadataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "onboarding_sample_db_config" */
export type Onboarding_Sample_Db_Config_Aggregate = {
  __typename?: 'onboarding_sample_db_config_aggregate';
  aggregate?: Maybe<Onboarding_Sample_Db_Config_Aggregate_Fields>;
  nodes: Array<Onboarding_Sample_Db_Config>;
};

/** aggregate fields of "onboarding_sample_db_config" */
export type Onboarding_Sample_Db_Config_Aggregate_Fields = {
  __typename?: 'onboarding_sample_db_config_aggregate_fields';
  avg?: Maybe<Onboarding_Sample_Db_Config_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Onboarding_Sample_Db_Config_Max_Fields>;
  min?: Maybe<Onboarding_Sample_Db_Config_Min_Fields>;
  stddev?: Maybe<Onboarding_Sample_Db_Config_Stddev_Fields>;
  stddev_pop?: Maybe<Onboarding_Sample_Db_Config_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Onboarding_Sample_Db_Config_Stddev_Samp_Fields>;
  sum?: Maybe<Onboarding_Sample_Db_Config_Sum_Fields>;
  var_pop?: Maybe<Onboarding_Sample_Db_Config_Var_Pop_Fields>;
  var_samp?: Maybe<Onboarding_Sample_Db_Config_Var_Samp_Fields>;
  variance?: Maybe<Onboarding_Sample_Db_Config_Variance_Fields>;
};

/** aggregate fields of "onboarding_sample_db_config" */
export type Onboarding_Sample_Db_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Onboarding_Sample_Db_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Onboarding_Sample_Db_Config_Append_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Onboarding_Sample_Db_Config_Avg_Fields = {
  __typename?: 'onboarding_sample_db_config_avg_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table "onboarding_sample_db_config".
 * All fields are combined with a logical 'AND'.
 */
export type Onboarding_Sample_Db_Config_Bool_Exp = {
  _and?: Maybe<Array<Onboarding_Sample_Db_Config_Bool_Exp>>;
  _not?: Maybe<Onboarding_Sample_Db_Config_Bool_Exp>;
  _or?: Maybe<Array<Onboarding_Sample_Db_Config_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  database_url?: Maybe<String_Comparison_Exp>;
  metadata?: Maybe<Jsonb_Comparison_Exp>;
  rollout_percentage?: Maybe<Int_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "onboarding_sample_db_config" */
export enum Onboarding_Sample_Db_Config_Constraint {
  /** unique or primary key constraint on columns "created_at" */
  OnboardingSampleDbConfigPkey = 'onboarding_sample_db_config_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Onboarding_Sample_Db_Config_Delete_At_Path_Input = {
  metadata?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Onboarding_Sample_Db_Config_Delete_Elem_Input = {
  metadata?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Onboarding_Sample_Db_Config_Delete_Key_Input = {
  metadata?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "onboarding_sample_db_config" */
export type Onboarding_Sample_Db_Config_Inc_Input = {
  rollout_percentage?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "onboarding_sample_db_config" */
export type Onboarding_Sample_Db_Config_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  database_url?: Maybe<Scalars['String']>;
  metadata?: Maybe<Scalars['jsonb']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Onboarding_Sample_Db_Config_Max_Fields = {
  __typename?: 'onboarding_sample_db_config_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  database_url?: Maybe<Scalars['String']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Onboarding_Sample_Db_Config_Min_Fields = {
  __typename?: 'onboarding_sample_db_config_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  database_url?: Maybe<Scalars['String']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "onboarding_sample_db_config" */
export type Onboarding_Sample_Db_Config_Mutation_Response = {
  __typename?: 'onboarding_sample_db_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Onboarding_Sample_Db_Config>;
};

/** on_conflict condition type for table "onboarding_sample_db_config" */
export type Onboarding_Sample_Db_Config_On_Conflict = {
  constraint: Onboarding_Sample_Db_Config_Constraint;
  update_columns?: Array<Onboarding_Sample_Db_Config_Update_Column>;
  where?: Maybe<Onboarding_Sample_Db_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "onboarding_sample_db_config". */
export type Onboarding_Sample_Db_Config_Order_By = {
  created_at?: Maybe<Order_By>;
  database_url?: Maybe<Order_By>;
  metadata?: Maybe<Order_By>;
  rollout_percentage?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: onboarding_sample_db_config */
export type Onboarding_Sample_Db_Config_Pk_Columns_Input = {
  created_at: Scalars['timestamptz'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Onboarding_Sample_Db_Config_Prepend_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "onboarding_sample_db_config" */
export enum Onboarding_Sample_Db_Config_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DatabaseUrl = 'database_url',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  RolloutPercentage = 'rollout_percentage',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "onboarding_sample_db_config" */
export type Onboarding_Sample_Db_Config_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  database_url?: Maybe<Scalars['String']>;
  metadata?: Maybe<Scalars['jsonb']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Onboarding_Sample_Db_Config_Stddev_Fields = {
  __typename?: 'onboarding_sample_db_config_stddev_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Onboarding_Sample_Db_Config_Stddev_Pop_Fields = {
  __typename?: 'onboarding_sample_db_config_stddev_pop_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Onboarding_Sample_Db_Config_Stddev_Samp_Fields = {
  __typename?: 'onboarding_sample_db_config_stddev_samp_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "onboarding_sample_db_config" */
export type Onboarding_Sample_Db_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Onboarding_Sample_Db_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Onboarding_Sample_Db_Config_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  database_url?: Maybe<Scalars['String']>;
  metadata?: Maybe<Scalars['jsonb']>;
  rollout_percentage?: Maybe<Scalars['Int']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Onboarding_Sample_Db_Config_Sum_Fields = {
  __typename?: 'onboarding_sample_db_config_sum_fields';
  rollout_percentage?: Maybe<Scalars['Int']>;
};

/** update columns of table "onboarding_sample_db_config" */
export enum Onboarding_Sample_Db_Config_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DatabaseUrl = 'database_url',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  RolloutPercentage = 'rollout_percentage',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Onboarding_Sample_Db_Config_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Onboarding_Sample_Db_Config_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Onboarding_Sample_Db_Config_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Onboarding_Sample_Db_Config_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Onboarding_Sample_Db_Config_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Onboarding_Sample_Db_Config_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Onboarding_Sample_Db_Config_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Onboarding_Sample_Db_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Onboarding_Sample_Db_Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Onboarding_Sample_Db_Config_Var_Pop_Fields = {
  __typename?: 'onboarding_sample_db_config_var_pop_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Onboarding_Sample_Db_Config_Var_Samp_Fields = {
  __typename?: 'onboarding_sample_db_config_var_samp_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Onboarding_Sample_Db_Config_Variance_Fields = {
  __typename?: 'onboarding_sample_db_config_variance_fields';
  rollout_percentage?: Maybe<Scalars['Float']>;
};

export type OnboardingActivityPayload = {
  error_code?: Maybe<Scalars['String']>;
  kind: Scalars['String'];
  project_id: Scalars['uuid'];
  subkind?: Maybe<Scalars['String']>;
};

/** columns and relationships of "one_click_deployment" */
export type One_Click_Deployment = {
  __typename?: 'one_click_deployment';
  additional_info: Scalars['jsonb'];
  created_at: Scalars['timestamptz'];
  git_repository_branch?: Maybe<Scalars['String']>;
  git_repository_url: Scalars['String'];
  hasura_directory?: Maybe<Scalars['String']>;
  id: Scalars['bigint'];
  /** An array relationship */
  one_click_deployment_state_logs: Array<One_Click_Deployment_State_Log>;
  /** An aggregate relationship */
  one_click_deployment_state_logs_aggregate: One_Click_Deployment_State_Log_Aggregate;
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  /** A computed field, executes function "one_click_deployment_state" */
  state?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "one_click_deployment" */
export type One_Click_DeploymentAdditional_InfoArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "one_click_deployment" */
export type One_Click_DeploymentOne_Click_Deployment_State_LogsArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_State_Log_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_State_Log_Order_By>>;
  where?: Maybe<One_Click_Deployment_State_Log_Bool_Exp>;
};

/** columns and relationships of "one_click_deployment" */
export type One_Click_DeploymentOne_Click_Deployment_State_Logs_AggregateArgs =
  {
    distinct_on?: Maybe<Array<One_Click_Deployment_State_Log_Select_Column>>;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<One_Click_Deployment_State_Log_Order_By>>;
    where?: Maybe<One_Click_Deployment_State_Log_Bool_Exp>;
  };

/** aggregated selection of "one_click_deployment" */
export type One_Click_Deployment_Aggregate = {
  __typename?: 'one_click_deployment_aggregate';
  aggregate?: Maybe<One_Click_Deployment_Aggregate_Fields>;
  nodes: Array<One_Click_Deployment>;
};

/** aggregate fields of "one_click_deployment" */
export type One_Click_Deployment_Aggregate_Fields = {
  __typename?: 'one_click_deployment_aggregate_fields';
  avg?: Maybe<One_Click_Deployment_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<One_Click_Deployment_Max_Fields>;
  min?: Maybe<One_Click_Deployment_Min_Fields>;
  stddev?: Maybe<One_Click_Deployment_Stddev_Fields>;
  stddev_pop?: Maybe<One_Click_Deployment_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<One_Click_Deployment_Stddev_Samp_Fields>;
  sum?: Maybe<One_Click_Deployment_Sum_Fields>;
  var_pop?: Maybe<One_Click_Deployment_Var_Pop_Fields>;
  var_samp?: Maybe<One_Click_Deployment_Var_Samp_Fields>;
  variance?: Maybe<One_Click_Deployment_Variance_Fields>;
};

/** aggregate fields of "one_click_deployment" */
export type One_Click_Deployment_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<One_Click_Deployment_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type One_Click_Deployment_Append_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type One_Click_Deployment_Avg_Fields = {
  __typename?: 'one_click_deployment_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "one_click_deployment". All fields are combined with a logical 'AND'. */
export type One_Click_Deployment_Bool_Exp = {
  _and?: Maybe<Array<One_Click_Deployment_Bool_Exp>>;
  _not?: Maybe<One_Click_Deployment_Bool_Exp>;
  _or?: Maybe<Array<One_Click_Deployment_Bool_Exp>>;
  additional_info?: Maybe<Jsonb_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  git_repository_branch?: Maybe<String_Comparison_Exp>;
  git_repository_url?: Maybe<String_Comparison_Exp>;
  hasura_directory?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  one_click_deployment_state_logs?: Maybe<One_Click_Deployment_State_Log_Bool_Exp>;
  one_click_deployment_state_logs_aggregate?: Maybe<One_Click_Deployment_State_Log_Aggregate_Bool_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  state?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "one_click_deployment" */
export enum One_Click_Deployment_Constraint {
  /** unique or primary key constraint on columns "id" */
  OneClickDeploymentPkey = 'one_click_deployment_pkey',
  /** unique or primary key constraint on columns "project_id" */
  OneClickDeploymentProjectIdKey = 'one_click_deployment_project_id_key',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type One_Click_Deployment_Delete_At_Path_Input = {
  additional_info?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type One_Click_Deployment_Delete_Elem_Input = {
  additional_info?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type One_Click_Deployment_Delete_Key_Input = {
  additional_info?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "one_click_deployment" */
export type One_Click_Deployment_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "one_click_deployment" */
export type One_Click_Deployment_Insert_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  git_repository_branch?: Maybe<Scalars['String']>;
  git_repository_url?: Maybe<Scalars['String']>;
  hasura_directory?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  one_click_deployment_state_logs?: Maybe<One_Click_Deployment_State_Log_Arr_Rel_Insert_Input>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type One_Click_Deployment_Max_Fields = {
  __typename?: 'one_click_deployment_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  git_repository_branch?: Maybe<Scalars['String']>;
  git_repository_url?: Maybe<Scalars['String']>;
  hasura_directory?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type One_Click_Deployment_Min_Fields = {
  __typename?: 'one_click_deployment_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  git_repository_branch?: Maybe<Scalars['String']>;
  git_repository_url?: Maybe<Scalars['String']>;
  hasura_directory?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "one_click_deployment" */
export type One_Click_Deployment_Mutation_Response = {
  __typename?: 'one_click_deployment_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<One_Click_Deployment>;
};

/** input type for inserting object relation for remote table "one_click_deployment" */
export type One_Click_Deployment_Obj_Rel_Insert_Input = {
  data: One_Click_Deployment_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<One_Click_Deployment_On_Conflict>;
};

/** on_conflict condition type for table "one_click_deployment" */
export type One_Click_Deployment_On_Conflict = {
  constraint: One_Click_Deployment_Constraint;
  update_columns?: Array<One_Click_Deployment_Update_Column>;
  where?: Maybe<One_Click_Deployment_Bool_Exp>;
};

/** Ordering options when selecting data from "one_click_deployment". */
export type One_Click_Deployment_Order_By = {
  additional_info?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  git_repository_branch?: Maybe<Order_By>;
  git_repository_url?: Maybe<Order_By>;
  hasura_directory?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  one_click_deployment_state_logs_aggregate?: Maybe<One_Click_Deployment_State_Log_Aggregate_Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  state?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: one_click_deployment */
export type One_Click_Deployment_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type One_Click_Deployment_Prepend_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
};

/** columns and relationships of "one_click_deployment_sample_apps" */
export type One_Click_Deployment_Sample_Apps = {
  __typename?: 'one_click_deployment_sample_apps';
  /** Description of the sample app */
  description?: Maybe<Scalars['String']>;
  /** Branch of the GitHub repository */
  git_repository_branch: Scalars['String'];
  /** URL to the GitHub repository along with the protocol */
  git_repository_url: Scalars['String'];
  /** Path of the Hasura project relative to the root of the repository */
  hasura_directory: Scalars['String'];
  /** Name of the sample app */
  name: Scalars['String'];
  /** Rank used for ordering these sample apps on the client. */
  rank: Scalars['Int'];
  /**
   * Font awesome react-icons component name from
   * https://react-icons.github.io/react-icons/icons?name=fa. Example:
   * FaShoppingCart, FaMusic etc
   */
  react_icons_fa_component_name?: Maybe<Scalars['String']>;
};

/** aggregated selection of "one_click_deployment_sample_apps" */
export type One_Click_Deployment_Sample_Apps_Aggregate = {
  __typename?: 'one_click_deployment_sample_apps_aggregate';
  aggregate?: Maybe<One_Click_Deployment_Sample_Apps_Aggregate_Fields>;
  nodes: Array<One_Click_Deployment_Sample_Apps>;
};

/** aggregate fields of "one_click_deployment_sample_apps" */
export type One_Click_Deployment_Sample_Apps_Aggregate_Fields = {
  __typename?: 'one_click_deployment_sample_apps_aggregate_fields';
  avg?: Maybe<One_Click_Deployment_Sample_Apps_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<One_Click_Deployment_Sample_Apps_Max_Fields>;
  min?: Maybe<One_Click_Deployment_Sample_Apps_Min_Fields>;
  stddev?: Maybe<One_Click_Deployment_Sample_Apps_Stddev_Fields>;
  stddev_pop?: Maybe<One_Click_Deployment_Sample_Apps_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<One_Click_Deployment_Sample_Apps_Stddev_Samp_Fields>;
  sum?: Maybe<One_Click_Deployment_Sample_Apps_Sum_Fields>;
  var_pop?: Maybe<One_Click_Deployment_Sample_Apps_Var_Pop_Fields>;
  var_samp?: Maybe<One_Click_Deployment_Sample_Apps_Var_Samp_Fields>;
  variance?: Maybe<One_Click_Deployment_Sample_Apps_Variance_Fields>;
};

/** aggregate fields of "one_click_deployment_sample_apps" */
export type One_Click_Deployment_Sample_Apps_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<One_Click_Deployment_Sample_Apps_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type One_Click_Deployment_Sample_Apps_Avg_Fields = {
  __typename?: 'one_click_deployment_sample_apps_avg_fields';
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table
 * "one_click_deployment_sample_apps". All fields are combined with a logical 'AND'.
 */
export type One_Click_Deployment_Sample_Apps_Bool_Exp = {
  _and?: Maybe<Array<One_Click_Deployment_Sample_Apps_Bool_Exp>>;
  _not?: Maybe<One_Click_Deployment_Sample_Apps_Bool_Exp>;
  _or?: Maybe<Array<One_Click_Deployment_Sample_Apps_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  git_repository_branch?: Maybe<String_Comparison_Exp>;
  git_repository_url?: Maybe<String_Comparison_Exp>;
  hasura_directory?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  rank?: Maybe<Int_Comparison_Exp>;
  react_icons_fa_component_name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "one_click_deployment_sample_apps" */
export enum One_Click_Deployment_Sample_Apps_Constraint {
  /** unique or primary key constraint on columns "git_repository_branch", "git_repository_url", "hasura_directory" */
  OneClickDeploymentSampleAppsPkey = 'one_click_deployment_sample_apps_pkey',
}

/** input type for incrementing numeric columns in table "one_click_deployment_sample_apps" */
export type One_Click_Deployment_Sample_Apps_Inc_Input = {
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "one_click_deployment_sample_apps" */
export type One_Click_Deployment_Sample_Apps_Insert_Input = {
  /** Description of the sample app */
  description?: Maybe<Scalars['String']>;
  /** Branch of the GitHub repository */
  git_repository_branch?: Maybe<Scalars['String']>;
  /** URL to the GitHub repository along with the protocol */
  git_repository_url?: Maybe<Scalars['String']>;
  /** Path of the Hasura project relative to the root of the repository */
  hasura_directory?: Maybe<Scalars['String']>;
  /** Name of the sample app */
  name?: Maybe<Scalars['String']>;
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Int']>;
  /**
   * Font awesome react-icons component name from
   * https://react-icons.github.io/react-icons/icons?name=fa. Example:
   * FaShoppingCart, FaMusic etc
   */
  react_icons_fa_component_name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type One_Click_Deployment_Sample_Apps_Max_Fields = {
  __typename?: 'one_click_deployment_sample_apps_max_fields';
  /** Description of the sample app */
  description?: Maybe<Scalars['String']>;
  /** Branch of the GitHub repository */
  git_repository_branch?: Maybe<Scalars['String']>;
  /** URL to the GitHub repository along with the protocol */
  git_repository_url?: Maybe<Scalars['String']>;
  /** Path of the Hasura project relative to the root of the repository */
  hasura_directory?: Maybe<Scalars['String']>;
  /** Name of the sample app */
  name?: Maybe<Scalars['String']>;
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Int']>;
  /**
   * Font awesome react-icons component name from
   * https://react-icons.github.io/react-icons/icons?name=fa. Example:
   * FaShoppingCart, FaMusic etc
   */
  react_icons_fa_component_name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type One_Click_Deployment_Sample_Apps_Min_Fields = {
  __typename?: 'one_click_deployment_sample_apps_min_fields';
  /** Description of the sample app */
  description?: Maybe<Scalars['String']>;
  /** Branch of the GitHub repository */
  git_repository_branch?: Maybe<Scalars['String']>;
  /** URL to the GitHub repository along with the protocol */
  git_repository_url?: Maybe<Scalars['String']>;
  /** Path of the Hasura project relative to the root of the repository */
  hasura_directory?: Maybe<Scalars['String']>;
  /** Name of the sample app */
  name?: Maybe<Scalars['String']>;
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Int']>;
  /**
   * Font awesome react-icons component name from
   * https://react-icons.github.io/react-icons/icons?name=fa. Example:
   * FaShoppingCart, FaMusic etc
   */
  react_icons_fa_component_name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "one_click_deployment_sample_apps" */
export type One_Click_Deployment_Sample_Apps_Mutation_Response = {
  __typename?: 'one_click_deployment_sample_apps_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<One_Click_Deployment_Sample_Apps>;
};

/** on_conflict condition type for table "one_click_deployment_sample_apps" */
export type One_Click_Deployment_Sample_Apps_On_Conflict = {
  constraint: One_Click_Deployment_Sample_Apps_Constraint;
  update_columns?: Array<One_Click_Deployment_Sample_Apps_Update_Column>;
  where?: Maybe<One_Click_Deployment_Sample_Apps_Bool_Exp>;
};

/** Ordering options when selecting data from "one_click_deployment_sample_apps". */
export type One_Click_Deployment_Sample_Apps_Order_By = {
  description?: Maybe<Order_By>;
  git_repository_branch?: Maybe<Order_By>;
  git_repository_url?: Maybe<Order_By>;
  hasura_directory?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  rank?: Maybe<Order_By>;
  react_icons_fa_component_name?: Maybe<Order_By>;
};

/** primary key columns input for table: one_click_deployment_sample_apps */
export type One_Click_Deployment_Sample_Apps_Pk_Columns_Input = {
  /** Branch of the GitHub repository */
  git_repository_branch: Scalars['String'];
  /** URL to the GitHub repository along with the protocol */
  git_repository_url: Scalars['String'];
  /** Path of the Hasura project relative to the root of the repository */
  hasura_directory: Scalars['String'];
};

/** select columns of table "one_click_deployment_sample_apps" */
export enum One_Click_Deployment_Sample_Apps_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  GitRepositoryBranch = 'git_repository_branch',
  /** column name */
  GitRepositoryUrl = 'git_repository_url',
  /** column name */
  HasuraDirectory = 'hasura_directory',
  /** column name */
  Name = 'name',
  /** column name */
  Rank = 'rank',
  /** column name */
  ReactIconsFaComponentName = 'react_icons_fa_component_name',
}

/** input type for updating data in table "one_click_deployment_sample_apps" */
export type One_Click_Deployment_Sample_Apps_Set_Input = {
  /** Description of the sample app */
  description?: Maybe<Scalars['String']>;
  /** Branch of the GitHub repository */
  git_repository_branch?: Maybe<Scalars['String']>;
  /** URL to the GitHub repository along with the protocol */
  git_repository_url?: Maybe<Scalars['String']>;
  /** Path of the Hasura project relative to the root of the repository */
  hasura_directory?: Maybe<Scalars['String']>;
  /** Name of the sample app */
  name?: Maybe<Scalars['String']>;
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Int']>;
  /**
   * Font awesome react-icons component name from
   * https://react-icons.github.io/react-icons/icons?name=fa. Example:
   * FaShoppingCart, FaMusic etc
   */
  react_icons_fa_component_name?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type One_Click_Deployment_Sample_Apps_Stddev_Fields = {
  __typename?: 'one_click_deployment_sample_apps_stddev_fields';
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type One_Click_Deployment_Sample_Apps_Stddev_Pop_Fields = {
  __typename?: 'one_click_deployment_sample_apps_stddev_pop_fields';
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type One_Click_Deployment_Sample_Apps_Stddev_Samp_Fields = {
  __typename?: 'one_click_deployment_sample_apps_stddev_samp_fields';
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "one_click_deployment_sample_apps" */
export type One_Click_Deployment_Sample_Apps_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: One_Click_Deployment_Sample_Apps_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type One_Click_Deployment_Sample_Apps_Stream_Cursor_Value_Input = {
  /** Description of the sample app */
  description?: Maybe<Scalars['String']>;
  /** Branch of the GitHub repository */
  git_repository_branch?: Maybe<Scalars['String']>;
  /** URL to the GitHub repository along with the protocol */
  git_repository_url?: Maybe<Scalars['String']>;
  /** Path of the Hasura project relative to the root of the repository */
  hasura_directory?: Maybe<Scalars['String']>;
  /** Name of the sample app */
  name?: Maybe<Scalars['String']>;
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Int']>;
  /**
   * Font awesome react-icons component name from
   * https://react-icons.github.io/react-icons/icons?name=fa. Example:
   * FaShoppingCart, FaMusic etc
   */
  react_icons_fa_component_name?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type One_Click_Deployment_Sample_Apps_Sum_Fields = {
  __typename?: 'one_click_deployment_sample_apps_sum_fields';
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Int']>;
};

/** update columns of table "one_click_deployment_sample_apps" */
export enum One_Click_Deployment_Sample_Apps_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  GitRepositoryBranch = 'git_repository_branch',
  /** column name */
  GitRepositoryUrl = 'git_repository_url',
  /** column name */
  HasuraDirectory = 'hasura_directory',
  /** column name */
  Name = 'name',
  /** column name */
  Rank = 'rank',
  /** column name */
  ReactIconsFaComponentName = 'react_icons_fa_component_name',
}

export type One_Click_Deployment_Sample_Apps_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<One_Click_Deployment_Sample_Apps_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<One_Click_Deployment_Sample_Apps_Set_Input>;
  /** filter the rows which have to be updated */
  where: One_Click_Deployment_Sample_Apps_Bool_Exp;
};

/** aggregate var_pop on columns */
export type One_Click_Deployment_Sample_Apps_Var_Pop_Fields = {
  __typename?: 'one_click_deployment_sample_apps_var_pop_fields';
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type One_Click_Deployment_Sample_Apps_Var_Samp_Fields = {
  __typename?: 'one_click_deployment_sample_apps_var_samp_fields';
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type One_Click_Deployment_Sample_Apps_Variance_Fields = {
  __typename?: 'one_click_deployment_sample_apps_variance_fields';
  /** Rank used for ordering these sample apps on the client. */
  rank?: Maybe<Scalars['Float']>;
};

/** select columns of table "one_click_deployment" */
export enum One_Click_Deployment_Select_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  GitRepositoryBranch = 'git_repository_branch',
  /** column name */
  GitRepositoryUrl = 'git_repository_url',
  /** column name */
  HasuraDirectory = 'hasura_directory',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "one_click_deployment" */
export type One_Click_Deployment_Set_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  git_repository_branch?: Maybe<Scalars['String']>;
  git_repository_url?: Maybe<Scalars['String']>;
  hasura_directory?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log = {
  __typename?: 'one_click_deployment_state_log';
  additional_info: Scalars['jsonb'];
  created_at: Scalars['timestamptz'];
  execution_id?: Maybe<Scalars['uuid']>;
  from_state: One_Click_Deployment_States_Enum;
  id: Scalars['bigint'];
  /** An object relationship */
  one_click_deployment: One_Click_Deployment;
  one_click_deployment_id: Scalars['Int'];
  to_state: One_Click_Deployment_States_Enum;
};

/** columns and relationships of "one_click_deployment_state_log" */
export type One_Click_Deployment_State_LogAdditional_InfoArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Aggregate = {
  __typename?: 'one_click_deployment_state_log_aggregate';
  aggregate?: Maybe<One_Click_Deployment_State_Log_Aggregate_Fields>;
  nodes: Array<One_Click_Deployment_State_Log>;
};

export type One_Click_Deployment_State_Log_Aggregate_Bool_Exp = {
  count?: Maybe<One_Click_Deployment_State_Log_Aggregate_Bool_Exp_Count>;
};

export type One_Click_Deployment_State_Log_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<One_Click_Deployment_State_Log_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<One_Click_Deployment_State_Log_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Aggregate_Fields = {
  __typename?: 'one_click_deployment_state_log_aggregate_fields';
  avg?: Maybe<One_Click_Deployment_State_Log_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<One_Click_Deployment_State_Log_Max_Fields>;
  min?: Maybe<One_Click_Deployment_State_Log_Min_Fields>;
  stddev?: Maybe<One_Click_Deployment_State_Log_Stddev_Fields>;
  stddev_pop?: Maybe<One_Click_Deployment_State_Log_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<One_Click_Deployment_State_Log_Stddev_Samp_Fields>;
  sum?: Maybe<One_Click_Deployment_State_Log_Sum_Fields>;
  var_pop?: Maybe<One_Click_Deployment_State_Log_Var_Pop_Fields>;
  var_samp?: Maybe<One_Click_Deployment_State_Log_Var_Samp_Fields>;
  variance?: Maybe<One_Click_Deployment_State_Log_Variance_Fields>;
};

/** aggregate fields of "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<One_Click_Deployment_State_Log_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Aggregate_Order_By = {
  avg?: Maybe<One_Click_Deployment_State_Log_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<One_Click_Deployment_State_Log_Max_Order_By>;
  min?: Maybe<One_Click_Deployment_State_Log_Min_Order_By>;
  stddev?: Maybe<One_Click_Deployment_State_Log_Stddev_Order_By>;
  stddev_pop?: Maybe<One_Click_Deployment_State_Log_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<One_Click_Deployment_State_Log_Stddev_Samp_Order_By>;
  sum?: Maybe<One_Click_Deployment_State_Log_Sum_Order_By>;
  var_pop?: Maybe<One_Click_Deployment_State_Log_Var_Pop_Order_By>;
  var_samp?: Maybe<One_Click_Deployment_State_Log_Var_Samp_Order_By>;
  variance?: Maybe<One_Click_Deployment_State_Log_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type One_Click_Deployment_State_Log_Append_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Arr_Rel_Insert_Input = {
  data: Array<One_Click_Deployment_State_Log_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<One_Click_Deployment_State_Log_On_Conflict>;
};

/** aggregate avg on columns */
export type One_Click_Deployment_State_Log_Avg_Fields = {
  __typename?: 'one_click_deployment_state_log_avg_fields';
  id?: Maybe<Scalars['Float']>;
  one_click_deployment_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Avg_Order_By = {
  id?: Maybe<Order_By>;
  one_click_deployment_id?: Maybe<Order_By>;
};

/**
 * Boolean expression to filter rows from the table
 * "one_click_deployment_state_log". All fields are combined with a logical 'AND'.
 */
export type One_Click_Deployment_State_Log_Bool_Exp = {
  _and?: Maybe<Array<One_Click_Deployment_State_Log_Bool_Exp>>;
  _not?: Maybe<One_Click_Deployment_State_Log_Bool_Exp>;
  _or?: Maybe<Array<One_Click_Deployment_State_Log_Bool_Exp>>;
  additional_info?: Maybe<Jsonb_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  execution_id?: Maybe<Uuid_Comparison_Exp>;
  from_state?: Maybe<One_Click_Deployment_States_Enum_Comparison_Exp>;
  id?: Maybe<Bigint_Comparison_Exp>;
  one_click_deployment?: Maybe<One_Click_Deployment_Bool_Exp>;
  one_click_deployment_id?: Maybe<Int_Comparison_Exp>;
  to_state?: Maybe<One_Click_Deployment_States_Enum_Comparison_Exp>;
};

/** unique or primary key constraints on table "one_click_deployment_state_log" */
export enum One_Click_Deployment_State_Log_Constraint {
  /** unique or primary key constraint on columns "id" */
  OneClickDeploymentStateLogPkey = 'one_click_deployment_state_log_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type One_Click_Deployment_State_Log_Delete_At_Path_Input = {
  additional_info?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type One_Click_Deployment_State_Log_Delete_Elem_Input = {
  additional_info?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type One_Click_Deployment_State_Log_Delete_Key_Input = {
  additional_info?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Inc_Input = {
  id?: Maybe<Scalars['bigint']>;
  one_click_deployment_id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Insert_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  execution_id?: Maybe<Scalars['uuid']>;
  from_state?: Maybe<One_Click_Deployment_States_Enum>;
  id?: Maybe<Scalars['bigint']>;
  one_click_deployment?: Maybe<One_Click_Deployment_Obj_Rel_Insert_Input>;
  one_click_deployment_id?: Maybe<Scalars['Int']>;
  to_state?: Maybe<One_Click_Deployment_States_Enum>;
};

/** aggregate max on columns */
export type One_Click_Deployment_State_Log_Max_Fields = {
  __typename?: 'one_click_deployment_state_log_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  execution_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  one_click_deployment_id?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  execution_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  one_click_deployment_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type One_Click_Deployment_State_Log_Min_Fields = {
  __typename?: 'one_click_deployment_state_log_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  execution_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['bigint']>;
  one_click_deployment_id?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  execution_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  one_click_deployment_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Mutation_Response = {
  __typename?: 'one_click_deployment_state_log_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<One_Click_Deployment_State_Log>;
};

/** on_conflict condition type for table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_On_Conflict = {
  constraint: One_Click_Deployment_State_Log_Constraint;
  update_columns?: Array<One_Click_Deployment_State_Log_Update_Column>;
  where?: Maybe<One_Click_Deployment_State_Log_Bool_Exp>;
};

/** Ordering options when selecting data from "one_click_deployment_state_log". */
export type One_Click_Deployment_State_Log_Order_By = {
  additional_info?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  execution_id?: Maybe<Order_By>;
  from_state?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  one_click_deployment?: Maybe<One_Click_Deployment_Order_By>;
  one_click_deployment_id?: Maybe<Order_By>;
  to_state?: Maybe<Order_By>;
};

/** primary key columns input for table: one_click_deployment_state_log */
export type One_Click_Deployment_State_Log_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type One_Click_Deployment_State_Log_Prepend_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "one_click_deployment_state_log" */
export enum One_Click_Deployment_State_Log_Select_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ExecutionId = 'execution_id',
  /** column name */
  FromState = 'from_state',
  /** column name */
  Id = 'id',
  /** column name */
  OneClickDeploymentId = 'one_click_deployment_id',
  /** column name */
  ToState = 'to_state',
}

/** input type for updating data in table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Set_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  execution_id?: Maybe<Scalars['uuid']>;
  from_state?: Maybe<One_Click_Deployment_States_Enum>;
  id?: Maybe<Scalars['bigint']>;
  one_click_deployment_id?: Maybe<Scalars['Int']>;
  to_state?: Maybe<One_Click_Deployment_States_Enum>;
};

/** aggregate stddev on columns */
export type One_Click_Deployment_State_Log_Stddev_Fields = {
  __typename?: 'one_click_deployment_state_log_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  one_click_deployment_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Stddev_Order_By = {
  id?: Maybe<Order_By>;
  one_click_deployment_id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type One_Click_Deployment_State_Log_Stddev_Pop_Fields = {
  __typename?: 'one_click_deployment_state_log_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  one_click_deployment_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
  one_click_deployment_id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type One_Click_Deployment_State_Log_Stddev_Samp_Fields = {
  __typename?: 'one_click_deployment_state_log_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  one_click_deployment_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
  one_click_deployment_id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: One_Click_Deployment_State_Log_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type One_Click_Deployment_State_Log_Stream_Cursor_Value_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  execution_id?: Maybe<Scalars['uuid']>;
  from_state?: Maybe<One_Click_Deployment_States_Enum>;
  id?: Maybe<Scalars['bigint']>;
  one_click_deployment_id?: Maybe<Scalars['Int']>;
  to_state?: Maybe<One_Click_Deployment_States_Enum>;
};

/** aggregate sum on columns */
export type One_Click_Deployment_State_Log_Sum_Fields = {
  __typename?: 'one_click_deployment_state_log_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  one_click_deployment_id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Sum_Order_By = {
  id?: Maybe<Order_By>;
  one_click_deployment_id?: Maybe<Order_By>;
};

/** update columns of table "one_click_deployment_state_log" */
export enum One_Click_Deployment_State_Log_Update_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ExecutionId = 'execution_id',
  /** column name */
  FromState = 'from_state',
  /** column name */
  Id = 'id',
  /** column name */
  OneClickDeploymentId = 'one_click_deployment_id',
  /** column name */
  ToState = 'to_state',
}

export type One_Click_Deployment_State_Log_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<One_Click_Deployment_State_Log_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<One_Click_Deployment_State_Log_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<One_Click_Deployment_State_Log_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<One_Click_Deployment_State_Log_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<One_Click_Deployment_State_Log_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<One_Click_Deployment_State_Log_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<One_Click_Deployment_State_Log_Set_Input>;
  /** filter the rows which have to be updated */
  where: One_Click_Deployment_State_Log_Bool_Exp;
};

/** aggregate var_pop on columns */
export type One_Click_Deployment_State_Log_Var_Pop_Fields = {
  __typename?: 'one_click_deployment_state_log_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  one_click_deployment_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
  one_click_deployment_id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type One_Click_Deployment_State_Log_Var_Samp_Fields = {
  __typename?: 'one_click_deployment_state_log_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  one_click_deployment_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
  one_click_deployment_id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type One_Click_Deployment_State_Log_Variance_Fields = {
  __typename?: 'one_click_deployment_state_log_variance_fields';
  id?: Maybe<Scalars['Float']>;
  one_click_deployment_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "one_click_deployment_state_log" */
export type One_Click_Deployment_State_Log_Variance_Order_By = {
  id?: Maybe<Order_By>;
  one_click_deployment_id?: Maybe<Order_By>;
};

/** This enum represents the different states one_click_deployment feature can be in. */
export type One_Click_Deployment_States = {
  __typename?: 'one_click_deployment_states';
  description: Scalars['String'];
  name: Scalars['String'];
};

/** aggregated selection of "one_click_deployment_states" */
export type One_Click_Deployment_States_Aggregate = {
  __typename?: 'one_click_deployment_states_aggregate';
  aggregate?: Maybe<One_Click_Deployment_States_Aggregate_Fields>;
  nodes: Array<One_Click_Deployment_States>;
};

/** aggregate fields of "one_click_deployment_states" */
export type One_Click_Deployment_States_Aggregate_Fields = {
  __typename?: 'one_click_deployment_states_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<One_Click_Deployment_States_Max_Fields>;
  min?: Maybe<One_Click_Deployment_States_Min_Fields>;
};

/** aggregate fields of "one_click_deployment_states" */
export type One_Click_Deployment_States_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<One_Click_Deployment_States_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/**
 * Boolean expression to filter rows from the table "one_click_deployment_states".
 * All fields are combined with a logical 'AND'.
 */
export type One_Click_Deployment_States_Bool_Exp = {
  _and?: Maybe<Array<One_Click_Deployment_States_Bool_Exp>>;
  _not?: Maybe<One_Click_Deployment_States_Bool_Exp>;
  _or?: Maybe<Array<One_Click_Deployment_States_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "one_click_deployment_states" */
export enum One_Click_Deployment_States_Constraint {
  /** unique or primary key constraint on columns "name" */
  OneClickDeploymentStatesPkey = 'one_click_deployment_states_pkey',
}

export enum One_Click_Deployment_States_Enum {
  /** Applying metadata, migration and seed data to the project */
  ApplyingMetadataMigrationsSeeds = 'APPLYING_METADATA_MIGRATIONS_SEEDS',
  /** Waiting for environment variables from user to be available */
  AwaitingEnvironmentVariables = 'AWAITING_ENVIRONMENT_VARIABLES',
  /** Cloning git repository */
  CloningGitRepository = 'CLONING_GIT_REPOSITORY',
  /** One click deployment executed successfully */
  Completed = 'COMPLETED',
  /** Some error occurred while deploying the git repository to hasura cloud project */
  Error = 'ERROR',
  /** One click deployment initiated */
  Initialized = 'INITIALIZED',
  /** Checking if the required environment variables are present in the project */
  ReadingEnvironmentVariables = 'READING_ENVIRONMENT_VARIABLES',
  /** No environment variables required from the user */
  SufficientEnvironmentVariables = 'SUFFICIENT_ENVIRONMENT_VARIABLES',
}

/**
 * Boolean expression to compare columns of type
 * "one_click_deployment_states_enum". All fields are combined with logical 'AND'.
 */
export type One_Click_Deployment_States_Enum_Comparison_Exp = {
  _eq?: Maybe<One_Click_Deployment_States_Enum>;
  _in?: Maybe<Array<One_Click_Deployment_States_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<One_Click_Deployment_States_Enum>;
  _nin?: Maybe<Array<One_Click_Deployment_States_Enum>>;
};

/** input type for inserting data into table "one_click_deployment_states" */
export type One_Click_Deployment_States_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type One_Click_Deployment_States_Max_Fields = {
  __typename?: 'one_click_deployment_states_max_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type One_Click_Deployment_States_Min_Fields = {
  __typename?: 'one_click_deployment_states_min_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "one_click_deployment_states" */
export type One_Click_Deployment_States_Mutation_Response = {
  __typename?: 'one_click_deployment_states_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<One_Click_Deployment_States>;
};

/** on_conflict condition type for table "one_click_deployment_states" */
export type One_Click_Deployment_States_On_Conflict = {
  constraint: One_Click_Deployment_States_Constraint;
  update_columns?: Array<One_Click_Deployment_States_Update_Column>;
  where?: Maybe<One_Click_Deployment_States_Bool_Exp>;
};

/** Ordering options when selecting data from "one_click_deployment_states". */
export type One_Click_Deployment_States_Order_By = {
  description?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** primary key columns input for table: one_click_deployment_states */
export type One_Click_Deployment_States_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "one_click_deployment_states" */
export enum One_Click_Deployment_States_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

/** input type for updating data in table "one_click_deployment_states" */
export type One_Click_Deployment_States_Set_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "one_click_deployment_states" */
export type One_Click_Deployment_States_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: One_Click_Deployment_States_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type One_Click_Deployment_States_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** update columns of table "one_click_deployment_states" */
export enum One_Click_Deployment_States_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

export type One_Click_Deployment_States_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<One_Click_Deployment_States_Set_Input>;
  /** filter the rows which have to be updated */
  where: One_Click_Deployment_States_Bool_Exp;
};

/** aggregate stddev on columns */
export type One_Click_Deployment_Stddev_Fields = {
  __typename?: 'one_click_deployment_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type One_Click_Deployment_Stddev_Pop_Fields = {
  __typename?: 'one_click_deployment_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type One_Click_Deployment_Stddev_Samp_Fields = {
  __typename?: 'one_click_deployment_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "one_click_deployment" */
export type One_Click_Deployment_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: One_Click_Deployment_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type One_Click_Deployment_Stream_Cursor_Value_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  git_repository_branch?: Maybe<Scalars['String']>;
  git_repository_url?: Maybe<Scalars['String']>;
  hasura_directory?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type One_Click_Deployment_Sum_Fields = {
  __typename?: 'one_click_deployment_sum_fields';
  id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "one_click_deployment" */
export enum One_Click_Deployment_Update_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  GitRepositoryBranch = 'git_repository_branch',
  /** column name */
  GitRepositoryUrl = 'git_repository_url',
  /** column name */
  HasuraDirectory = 'hasura_directory',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type One_Click_Deployment_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<One_Click_Deployment_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<One_Click_Deployment_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<One_Click_Deployment_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<One_Click_Deployment_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<One_Click_Deployment_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<One_Click_Deployment_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<One_Click_Deployment_Set_Input>;
  /** filter the rows which have to be updated */
  where: One_Click_Deployment_Bool_Exp;
};

/** aggregate var_pop on columns */
export type One_Click_Deployment_Var_Pop_Fields = {
  __typename?: 'one_click_deployment_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type One_Click_Deployment_Var_Samp_Fields = {
  __typename?: 'one_click_deployment_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type One_Click_Deployment_Variance_Fields = {
  __typename?: 'one_click_deployment_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

export type OneClickDeployResponse = {
  __typename?: 'OneClickDeployResponse';
  message?: Maybe<Scalars['String']>;
  status: Scalars['String'];
};

/** OpenTelemetry Exporter Config */
export type Opentelemetry_Config = {
  __typename?: 'opentelemetry_config';
  attributes?: Maybe<Scalars['jsonb']>;
  batch_size?: Maybe<Scalars['Int']>;
  connection_type: Scalars['opentelemetry_connection_type_enum'];
  created_at: Scalars['timestamptz'];
  endpoint: Scalars['String'];
  export_traces: Scalars['Boolean'];
  headers?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  traces_last_exported?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** OpenTelemetry Exporter Config */
export type Opentelemetry_ConfigAttributesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** OpenTelemetry Exporter Config */
export type Opentelemetry_ConfigHeadersArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "opentelemetry_config" */
export type Opentelemetry_Config_Aggregate = {
  __typename?: 'opentelemetry_config_aggregate';
  aggregate?: Maybe<Opentelemetry_Config_Aggregate_Fields>;
  nodes: Array<Opentelemetry_Config>;
};

/** aggregate fields of "opentelemetry_config" */
export type Opentelemetry_Config_Aggregate_Fields = {
  __typename?: 'opentelemetry_config_aggregate_fields';
  avg?: Maybe<Opentelemetry_Config_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Opentelemetry_Config_Max_Fields>;
  min?: Maybe<Opentelemetry_Config_Min_Fields>;
  stddev?: Maybe<Opentelemetry_Config_Stddev_Fields>;
  stddev_pop?: Maybe<Opentelemetry_Config_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Opentelemetry_Config_Stddev_Samp_Fields>;
  sum?: Maybe<Opentelemetry_Config_Sum_Fields>;
  var_pop?: Maybe<Opentelemetry_Config_Var_Pop_Fields>;
  var_samp?: Maybe<Opentelemetry_Config_Var_Samp_Fields>;
  variance?: Maybe<Opentelemetry_Config_Variance_Fields>;
};

/** aggregate fields of "opentelemetry_config" */
export type Opentelemetry_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Opentelemetry_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Opentelemetry_Config_Append_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
  headers?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Opentelemetry_Config_Avg_Fields = {
  __typename?: 'opentelemetry_config_avg_fields';
  batch_size?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "opentelemetry_config". All fields are combined with a logical 'AND'. */
export type Opentelemetry_Config_Bool_Exp = {
  _and?: Maybe<Array<Opentelemetry_Config_Bool_Exp>>;
  _not?: Maybe<Opentelemetry_Config_Bool_Exp>;
  _or?: Maybe<Array<Opentelemetry_Config_Bool_Exp>>;
  attributes?: Maybe<Jsonb_Comparison_Exp>;
  batch_size?: Maybe<Int_Comparison_Exp>;
  connection_type?: Maybe<Opentelemetry_Connection_Type_Enum_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  endpoint?: Maybe<String_Comparison_Exp>;
  export_traces?: Maybe<Boolean_Comparison_Exp>;
  headers?: Maybe<Jsonb_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  traces_last_exported?: Maybe<Timestamptz_Comparison_Exp>;
  traces_response_code?: Maybe<Int_Comparison_Exp>;
  traces_response_message?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "opentelemetry_config" */
export enum Opentelemetry_Config_Constraint {
  /** unique or primary key constraint on columns "project_id" */
  OpentelemetryConfigPkey = 'opentelemetry_config_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Opentelemetry_Config_Delete_At_Path_Input = {
  attributes?: Maybe<Array<Scalars['String']>>;
  headers?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Opentelemetry_Config_Delete_Elem_Input = {
  attributes?: Maybe<Scalars['Int']>;
  headers?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Opentelemetry_Config_Delete_Key_Input = {
  attributes?: Maybe<Scalars['String']>;
  headers?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "opentelemetry_config" */
export type Opentelemetry_Config_Inc_Input = {
  batch_size?: Maybe<Scalars['Int']>;
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "opentelemetry_config" */
export type Opentelemetry_Config_Insert_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
  batch_size?: Maybe<Scalars['Int']>;
  connection_type?: Maybe<Scalars['opentelemetry_connection_type_enum']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  endpoint?: Maybe<Scalars['String']>;
  export_traces?: Maybe<Scalars['Boolean']>;
  headers?: Maybe<Scalars['jsonb']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  traces_last_exported?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Opentelemetry_Config_Max_Fields = {
  __typename?: 'opentelemetry_config_max_fields';
  batch_size?: Maybe<Scalars['Int']>;
  connection_type?: Maybe<Scalars['opentelemetry_connection_type_enum']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  endpoint?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  traces_last_exported?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Opentelemetry_Config_Min_Fields = {
  __typename?: 'opentelemetry_config_min_fields';
  batch_size?: Maybe<Scalars['Int']>;
  connection_type?: Maybe<Scalars['opentelemetry_connection_type_enum']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  endpoint?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  traces_last_exported?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "opentelemetry_config" */
export type Opentelemetry_Config_Mutation_Response = {
  __typename?: 'opentelemetry_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Opentelemetry_Config>;
};

/** input type for inserting object relation for remote table "opentelemetry_config" */
export type Opentelemetry_Config_Obj_Rel_Insert_Input = {
  data: Opentelemetry_Config_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Opentelemetry_Config_On_Conflict>;
};

/** on_conflict condition type for table "opentelemetry_config" */
export type Opentelemetry_Config_On_Conflict = {
  constraint: Opentelemetry_Config_Constraint;
  update_columns?: Array<Opentelemetry_Config_Update_Column>;
  where?: Maybe<Opentelemetry_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "opentelemetry_config". */
export type Opentelemetry_Config_Order_By = {
  attributes?: Maybe<Order_By>;
  batch_size?: Maybe<Order_By>;
  connection_type?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  endpoint?: Maybe<Order_By>;
  export_traces?: Maybe<Order_By>;
  headers?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  traces_last_exported?: Maybe<Order_By>;
  traces_response_code?: Maybe<Order_By>;
  traces_response_message?: Maybe<Order_By>;
};

/** primary key columns input for table: opentelemetry_config */
export type Opentelemetry_Config_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Opentelemetry_Config_Prepend_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
  headers?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "opentelemetry_config" */
export enum Opentelemetry_Config_Select_Column {
  /** column name */
  Attributes = 'attributes',
  /** column name */
  BatchSize = 'batch_size',
  /** column name */
  ConnectionType = 'connection_type',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  ExportTraces = 'export_traces',
  /** column name */
  Headers = 'headers',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  TracesLastExported = 'traces_last_exported',
  /** column name */
  TracesResponseCode = 'traces_response_code',
  /** column name */
  TracesResponseMessage = 'traces_response_message',
}

/** input type for updating data in table "opentelemetry_config" */
export type Opentelemetry_Config_Set_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
  batch_size?: Maybe<Scalars['Int']>;
  connection_type?: Maybe<Scalars['opentelemetry_connection_type_enum']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  endpoint?: Maybe<Scalars['String']>;
  export_traces?: Maybe<Scalars['Boolean']>;
  headers?: Maybe<Scalars['jsonb']>;
  project_id?: Maybe<Scalars['uuid']>;
  traces_last_exported?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Opentelemetry_Config_Stddev_Fields = {
  __typename?: 'opentelemetry_config_stddev_fields';
  batch_size?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Opentelemetry_Config_Stddev_Pop_Fields = {
  __typename?: 'opentelemetry_config_stddev_pop_fields';
  batch_size?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Opentelemetry_Config_Stddev_Samp_Fields = {
  __typename?: 'opentelemetry_config_stddev_samp_fields';
  batch_size?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "opentelemetry_config" */
export type Opentelemetry_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Opentelemetry_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Opentelemetry_Config_Stream_Cursor_Value_Input = {
  attributes?: Maybe<Scalars['jsonb']>;
  batch_size?: Maybe<Scalars['Int']>;
  connection_type?: Maybe<Scalars['opentelemetry_connection_type_enum']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  endpoint?: Maybe<Scalars['String']>;
  export_traces?: Maybe<Scalars['Boolean']>;
  headers?: Maybe<Scalars['jsonb']>;
  project_id?: Maybe<Scalars['uuid']>;
  traces_last_exported?: Maybe<Scalars['timestamptz']>;
  traces_response_code?: Maybe<Scalars['Int']>;
  traces_response_message?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Opentelemetry_Config_Sum_Fields = {
  __typename?: 'opentelemetry_config_sum_fields';
  batch_size?: Maybe<Scalars['Int']>;
  traces_response_code?: Maybe<Scalars['Int']>;
};

/** update columns of table "opentelemetry_config" */
export enum Opentelemetry_Config_Update_Column {
  /** column name */
  Attributes = 'attributes',
  /** column name */
  BatchSize = 'batch_size',
  /** column name */
  ConnectionType = 'connection_type',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  ExportTraces = 'export_traces',
  /** column name */
  Headers = 'headers',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  TracesLastExported = 'traces_last_exported',
  /** column name */
  TracesResponseCode = 'traces_response_code',
  /** column name */
  TracesResponseMessage = 'traces_response_message',
}

export type Opentelemetry_Config_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Opentelemetry_Config_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Opentelemetry_Config_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Opentelemetry_Config_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Opentelemetry_Config_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Opentelemetry_Config_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Opentelemetry_Config_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Opentelemetry_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Opentelemetry_Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Opentelemetry_Config_Var_Pop_Fields = {
  __typename?: 'opentelemetry_config_var_pop_fields';
  batch_size?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Opentelemetry_Config_Var_Samp_Fields = {
  __typename?: 'opentelemetry_config_var_samp_fields';
  batch_size?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Opentelemetry_Config_Variance_Fields = {
  __typename?: 'opentelemetry_config_variance_fields';
  batch_size?: Maybe<Scalars['Float']>;
  traces_response_code?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to compare columns of type
 * "opentelemetry_connection_type_enum". All fields are combined with logical 'AND'.
 */
export type Opentelemetry_Connection_Type_Enum_Comparison_Exp = {
  _eq?: Maybe<Scalars['opentelemetry_connection_type_enum']>;
  _gt?: Maybe<Scalars['opentelemetry_connection_type_enum']>;
  _gte?: Maybe<Scalars['opentelemetry_connection_type_enum']>;
  _in?: Maybe<Array<Scalars['opentelemetry_connection_type_enum']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['opentelemetry_connection_type_enum']>;
  _lte?: Maybe<Scalars['opentelemetry_connection_type_enum']>;
  _neq?: Maybe<Scalars['opentelemetry_connection_type_enum']>;
  _nin?: Maybe<Array<Scalars['opentelemetry_connection_type_enum']>>;
};

export type OpentelemetryConfigResponse = {
  __typename?: 'OpentelemetryConfigResponse';
  project_id: Scalars['uuid'];
};

/** Keeps track of tenants for which DNS records were deleted */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021 = {
  __typename?: 'operations_delete_free_plan_dns_records_nov_2021';
  dns_record_deleted: Scalars['Boolean'];
  message: Scalars['String'];
  /** An object relationship */
  tenant: Tenant;
  tenant_id: Scalars['uuid'];
};

/** aggregated selection of "operations.delete_free_plan_dns_records_nov_2021" */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Aggregate = {
  __typename?: 'operations_delete_free_plan_dns_records_nov_2021_aggregate';
  aggregate?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Aggregate_Fields>;
  nodes: Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021>;
};

/** aggregate fields of "operations.delete_free_plan_dns_records_nov_2021" */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Aggregate_Fields =
  {
    __typename?: 'operations_delete_free_plan_dns_records_nov_2021_aggregate_fields';
    count: Scalars['Int'];
    max?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Max_Fields>;
    min?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Min_Fields>;
  };

/** aggregate fields of "operations.delete_free_plan_dns_records_nov_2021" */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Aggregate_FieldsCountArgs =
  {
    columns?: Maybe<
      Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Select_Column>
    >;
    distinct?: Maybe<Scalars['Boolean']>;
  };

/**
 * Boolean expression to filter rows from the table
 * "operations.delete_free_plan_dns_records_nov_2021". All fields are combined with
 * a logical 'AND'.
 */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp = {
  _and?: Maybe<
    Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp>
  >;
  _not?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp>;
  _or?: Maybe<Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp>>;
  dns_record_deleted?: Maybe<Boolean_Comparison_Exp>;
  message?: Maybe<String_Comparison_Exp>;
  tenant?: Maybe<Tenant_Bool_Exp>;
  tenant_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "operations.delete_free_plan_dns_records_nov_2021" */
export enum Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Constraint {
  /** unique or primary key constraint on columns "tenant_id" */
  DeleteFreePlanDnsRecordsNov_2021Pkey = 'delete_free_plan_dns_records_nov_2021_pkey',
}

/** input type for inserting data into table "operations.delete_free_plan_dns_records_nov_2021" */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Insert_Input = {
  dns_record_deleted?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  tenant?: Maybe<Tenant_Obj_Rel_Insert_Input>;
  tenant_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Max_Fields = {
  __typename?: 'operations_delete_free_plan_dns_records_nov_2021_max_fields';
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Min_Fields = {
  __typename?: 'operations_delete_free_plan_dns_records_nov_2021_min_fields';
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "operations.delete_free_plan_dns_records_nov_2021" */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Mutation_Response =
  {
    __typename?: 'operations_delete_free_plan_dns_records_nov_2021_mutation_response';
    /** number of rows affected by the mutation */
    affected_rows: Scalars['Int'];
    /** data from the rows affected by the mutation */
    returning: Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021>;
  };

/** on_conflict condition type for table "operations.delete_free_plan_dns_records_nov_2021" */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_On_Conflict = {
  constraint: Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Constraint;
  update_columns?: Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Update_Column>;
  where?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp>;
};

/** Ordering options when selecting data from "operations.delete_free_plan_dns_records_nov_2021". */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Order_By = {
  dns_record_deleted?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  tenant?: Maybe<Tenant_Order_By>;
  tenant_id?: Maybe<Order_By>;
};

/** primary key columns input for table: operations.delete_free_plan_dns_records_nov_2021 */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Pk_Columns_Input =
  {
    tenant_id: Scalars['uuid'];
  };

/** select columns of table "operations.delete_free_plan_dns_records_nov_2021" */
export enum Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Select_Column {
  /** column name */
  DnsRecordDeleted = 'dns_record_deleted',
  /** column name */
  Message = 'message',
  /** column name */
  TenantId = 'tenant_id',
}

/** input type for updating data in table "operations.delete_free_plan_dns_records_nov_2021" */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Set_Input = {
  dns_record_deleted?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "operations_delete_free_plan_dns_records_nov_2021" */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Stream_Cursor_Input =
  {
    /** Stream column input with initial value */
    initial_value: Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Stream_Cursor_Value_Input;
    /** cursor ordering */
    ordering?: Maybe<Cursor_Ordering>;
  };

/** Initial value of the column from where the streaming should start */
export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Stream_Cursor_Value_Input =
  {
    dns_record_deleted?: Maybe<Scalars['Boolean']>;
    message?: Maybe<Scalars['String']>;
    tenant_id?: Maybe<Scalars['uuid']>;
  };

/** update columns of table "operations.delete_free_plan_dns_records_nov_2021" */
export enum Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Update_Column {
  /** column name */
  DnsRecordDeleted = 'dns_record_deleted',
  /** column name */
  Message = 'message',
  /** column name */
  TenantId = 'tenant_id',
}

export type Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Set_Input>;
  /** filter the rows which have to be updated */
  where: Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp;
};

/** columns and relationships of "operations.tenant" */
export type Operations_Tenant = {
  __typename?: 'operations_tenant';
  active?: Maybe<Scalars['Boolean']>;
  alias?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cloudflare_proxy_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  maintenance_mode?: Maybe<Scalars['Boolean']>;
  major_version?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregated selection of "operations.tenant" */
export type Operations_Tenant_Aggregate = {
  __typename?: 'operations_tenant_aggregate';
  aggregate?: Maybe<Operations_Tenant_Aggregate_Fields>;
  nodes: Array<Operations_Tenant>;
};

/** aggregate fields of "operations.tenant" */
export type Operations_Tenant_Aggregate_Fields = {
  __typename?: 'operations_tenant_aggregate_fields';
  avg?: Maybe<Operations_Tenant_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Operations_Tenant_Max_Fields>;
  min?: Maybe<Operations_Tenant_Min_Fields>;
  stddev?: Maybe<Operations_Tenant_Stddev_Fields>;
  stddev_pop?: Maybe<Operations_Tenant_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Operations_Tenant_Stddev_Samp_Fields>;
  sum?: Maybe<Operations_Tenant_Sum_Fields>;
  var_pop?: Maybe<Operations_Tenant_Var_Pop_Fields>;
  var_samp?: Maybe<Operations_Tenant_Var_Samp_Fields>;
  variance?: Maybe<Operations_Tenant_Variance_Fields>;
};

/** aggregate fields of "operations.tenant" */
export type Operations_Tenant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Operations_Tenant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Operations_Tenant_Avg_Fields = {
  __typename?: 'operations_tenant_avg_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "operations.tenant". All fields are combined with a logical 'AND'. */
export type Operations_Tenant_Bool_Exp = {
  _and?: Maybe<Array<Operations_Tenant_Bool_Exp>>;
  _not?: Maybe<Operations_Tenant_Bool_Exp>;
  _or?: Maybe<Array<Operations_Tenant_Bool_Exp>>;
  active?: Maybe<Boolean_Comparison_Exp>;
  alias?: Maybe<String_Comparison_Exp>;
  cloud?: Maybe<String_Comparison_Exp>;
  cloudflare_proxy_enabled?: Maybe<Boolean_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dedicated_vpc_id?: Maybe<Uuid_Comparison_Exp>;
  fqdn?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  maintenance_mode?: Maybe<Boolean_Comparison_Exp>;
  major_version?: Maybe<Int_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  slug?: Maybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "operations.tenant" */
export type Operations_Tenant_Inc_Input = {
  major_version?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "operations.tenant" */
export type Operations_Tenant_Insert_Input = {
  active?: Maybe<Scalars['Boolean']>;
  alias?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cloudflare_proxy_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  maintenance_mode?: Maybe<Scalars['Boolean']>;
  major_version?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Operations_Tenant_Max_Fields = {
  __typename?: 'operations_tenant_max_fields';
  alias?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  major_version?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Operations_Tenant_Min_Fields = {
  __typename?: 'operations_tenant_min_fields';
  alias?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  major_version?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "operations.tenant" */
export type Operations_Tenant_Mutation_Response = {
  __typename?: 'operations_tenant_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Operations_Tenant>;
};

/** Ordering options when selecting data from "operations.tenant". */
export type Operations_Tenant_Order_By = {
  active?: Maybe<Order_By>;
  alias?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  cloudflare_proxy_enabled?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dedicated_vpc_id?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  maintenance_mode?: Maybe<Order_By>;
  major_version?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
};

/** select columns of table "operations.tenant" */
export enum Operations_Tenant_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  Alias = 'alias',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CloudflareProxyEnabled = 'cloudflare_proxy_enabled',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DedicatedVpcId = 'dedicated_vpc_id',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  MaintenanceMode = 'maintenance_mode',
  /** column name */
  MajorVersion = 'major_version',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
}

/** input type for updating data in table "operations.tenant" */
export type Operations_Tenant_Set_Input = {
  active?: Maybe<Scalars['Boolean']>;
  alias?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cloudflare_proxy_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  maintenance_mode?: Maybe<Scalars['Boolean']>;
  major_version?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Operations_Tenant_Stddev_Fields = {
  __typename?: 'operations_tenant_stddev_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Operations_Tenant_Stddev_Pop_Fields = {
  __typename?: 'operations_tenant_stddev_pop_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Operations_Tenant_Stddev_Samp_Fields = {
  __typename?: 'operations_tenant_stddev_samp_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "operations_tenant" */
export type Operations_Tenant_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Operations_Tenant_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Operations_Tenant_Stream_Cursor_Value_Input = {
  active?: Maybe<Scalars['Boolean']>;
  alias?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cloudflare_proxy_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  maintenance_mode?: Maybe<Scalars['Boolean']>;
  major_version?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Operations_Tenant_Sum_Fields = {
  __typename?: 'operations_tenant_sum_fields';
  major_version?: Maybe<Scalars['Int']>;
};

export type Operations_Tenant_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Operations_Tenant_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Operations_Tenant_Set_Input>;
  /** filter the rows which have to be updated */
  where: Operations_Tenant_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Operations_Tenant_Var_Pop_Fields = {
  __typename?: 'operations_tenant_var_pop_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Operations_Tenant_Var_Samp_Fields = {
  __typename?: 'operations_tenant_var_samp_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Operations_Tenant_Variance_Fields = {
  __typename?: 'operations_tenant_variance_fields';
  major_version?: Maybe<Scalars['Float']>;
};

export type Operations_To_Delete_Free_Plan_Dns_Records_Args = {
  free_plan_region?: Maybe<Scalars['String']>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last',
}

export type PayInvoiceStatus = {
  __typename?: 'PayInvoiceStatus';
  status: Scalars['String'];
};

/** Payment method used by stripe customer  */
export type Payment_Method = {
  __typename?: 'payment_method';
  brand: Scalars['String'];
  country_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  exp_month: Scalars['Int'];
  exp_year: Scalars['Int'];
  id: Scalars['String'];
  is_default: Scalars['Boolean'];
  last4: Scalars['String'];
  name: Scalars['String'];
  status?: Maybe<Scalars['String']>;
  stripe_customer_id: Scalars['String'];
  type: Scalars['String'];
  /** An object relationship */
  user?: Maybe<Users>;
};

/** aggregated selection of "payment_method" */
export type Payment_Method_Aggregate = {
  __typename?: 'payment_method_aggregate';
  aggregate?: Maybe<Payment_Method_Aggregate_Fields>;
  nodes: Array<Payment_Method>;
};

export type Payment_Method_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Payment_Method_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Payment_Method_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Payment_Method_Aggregate_Bool_Exp_Count>;
};

export type Payment_Method_Aggregate_Bool_Exp_Bool_And = {
  arguments: Payment_Method_Select_Column_Payment_Method_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Payment_Method_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Payment_Method_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Payment_Method_Select_Column_Payment_Method_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Payment_Method_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Payment_Method_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Payment_Method_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Payment_Method_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "payment_method" */
export type Payment_Method_Aggregate_Fields = {
  __typename?: 'payment_method_aggregate_fields';
  avg?: Maybe<Payment_Method_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Payment_Method_Max_Fields>;
  min?: Maybe<Payment_Method_Min_Fields>;
  stddev?: Maybe<Payment_Method_Stddev_Fields>;
  stddev_pop?: Maybe<Payment_Method_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Payment_Method_Stddev_Samp_Fields>;
  sum?: Maybe<Payment_Method_Sum_Fields>;
  var_pop?: Maybe<Payment_Method_Var_Pop_Fields>;
  var_samp?: Maybe<Payment_Method_Var_Samp_Fields>;
  variance?: Maybe<Payment_Method_Variance_Fields>;
};

/** aggregate fields of "payment_method" */
export type Payment_Method_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Payment_Method_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "payment_method" */
export type Payment_Method_Aggregate_Order_By = {
  avg?: Maybe<Payment_Method_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Payment_Method_Max_Order_By>;
  min?: Maybe<Payment_Method_Min_Order_By>;
  stddev?: Maybe<Payment_Method_Stddev_Order_By>;
  stddev_pop?: Maybe<Payment_Method_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Payment_Method_Stddev_Samp_Order_By>;
  sum?: Maybe<Payment_Method_Sum_Order_By>;
  var_pop?: Maybe<Payment_Method_Var_Pop_Order_By>;
  var_samp?: Maybe<Payment_Method_Var_Samp_Order_By>;
  variance?: Maybe<Payment_Method_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "payment_method" */
export type Payment_Method_Arr_Rel_Insert_Input = {
  data: Array<Payment_Method_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Payment_Method_On_Conflict>;
};

/** aggregate avg on columns */
export type Payment_Method_Avg_Fields = {
  __typename?: 'payment_method_avg_fields';
  exp_month?: Maybe<Scalars['Float']>;
  exp_year?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "payment_method" */
export type Payment_Method_Avg_Order_By = {
  exp_month?: Maybe<Order_By>;
  exp_year?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "payment_method". All fields are combined with a logical 'AND'. */
export type Payment_Method_Bool_Exp = {
  _and?: Maybe<Array<Payment_Method_Bool_Exp>>;
  _not?: Maybe<Payment_Method_Bool_Exp>;
  _or?: Maybe<Array<Payment_Method_Bool_Exp>>;
  brand?: Maybe<String_Comparison_Exp>;
  country_code?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  exp_month?: Maybe<Int_Comparison_Exp>;
  exp_year?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<String_Comparison_Exp>;
  is_default?: Maybe<Boolean_Comparison_Exp>;
  last4?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  stripe_customer_id?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
};

/** unique or primary key constraints on table "payment_method" */
export enum Payment_Method_Constraint {
  /** unique or primary key constraint on columns "id" */
  PaymentMethodPkey = 'payment_method_pkey',
}

/** input type for incrementing numeric columns in table "payment_method" */
export type Payment_Method_Inc_Input = {
  exp_month?: Maybe<Scalars['Int']>;
  exp_year?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "payment_method" */
export type Payment_Method_Insert_Input = {
  brand?: Maybe<Scalars['String']>;
  country_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  exp_month?: Maybe<Scalars['Int']>;
  exp_year?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  is_default?: Maybe<Scalars['Boolean']>;
  last4?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Payment_Method_Max_Fields = {
  __typename?: 'payment_method_max_fields';
  brand?: Maybe<Scalars['String']>;
  country_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  exp_month?: Maybe<Scalars['Int']>;
  exp_year?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  last4?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "payment_method" */
export type Payment_Method_Max_Order_By = {
  brand?: Maybe<Order_By>;
  country_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  exp_month?: Maybe<Order_By>;
  exp_year?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last4?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Payment_Method_Min_Fields = {
  __typename?: 'payment_method_min_fields';
  brand?: Maybe<Scalars['String']>;
  country_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  exp_month?: Maybe<Scalars['Int']>;
  exp_year?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  last4?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "payment_method" */
export type Payment_Method_Min_Order_By = {
  brand?: Maybe<Order_By>;
  country_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  exp_month?: Maybe<Order_By>;
  exp_year?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last4?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** response of any mutation on the table "payment_method" */
export type Payment_Method_Mutation_Response = {
  __typename?: 'payment_method_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Payment_Method>;
};

/** input type for inserting object relation for remote table "payment_method" */
export type Payment_Method_Obj_Rel_Insert_Input = {
  data: Payment_Method_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Payment_Method_On_Conflict>;
};

/** on_conflict condition type for table "payment_method" */
export type Payment_Method_On_Conflict = {
  constraint: Payment_Method_Constraint;
  update_columns?: Array<Payment_Method_Update_Column>;
  where?: Maybe<Payment_Method_Bool_Exp>;
};

/** Ordering options when selecting data from "payment_method". */
export type Payment_Method_Order_By = {
  brand?: Maybe<Order_By>;
  country_code?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  exp_month?: Maybe<Order_By>;
  exp_year?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_default?: Maybe<Order_By>;
  last4?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  stripe_customer_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
};

/** primary key columns input for table: payment_method */
export type Payment_Method_Pk_Columns_Input = {
  id: Scalars['String'];
};

/** select columns of table "payment_method" */
export enum Payment_Method_Select_Column {
  /** column name */
  Brand = 'brand',
  /** column name */
  CountryCode = 'country_code',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ExpMonth = 'exp_month',
  /** column name */
  ExpYear = 'exp_year',
  /** column name */
  Id = 'id',
  /** column name */
  IsDefault = 'is_default',
  /** column name */
  Last4 = 'last4',
  /** column name */
  Name = 'name',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  Type = 'type',
}

/** select "payment_method_aggregate_bool_exp_bool_and_arguments_columns" columns of table "payment_method" */
export enum Payment_Method_Select_Column_Payment_Method_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsDefault = 'is_default',
}

/** select "payment_method_aggregate_bool_exp_bool_or_arguments_columns" columns of table "payment_method" */
export enum Payment_Method_Select_Column_Payment_Method_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsDefault = 'is_default',
}

/** input type for updating data in table "payment_method" */
export type Payment_Method_Set_Input = {
  brand?: Maybe<Scalars['String']>;
  country_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  exp_month?: Maybe<Scalars['Int']>;
  exp_year?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  is_default?: Maybe<Scalars['Boolean']>;
  last4?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Payment_Method_Stddev_Fields = {
  __typename?: 'payment_method_stddev_fields';
  exp_month?: Maybe<Scalars['Float']>;
  exp_year?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "payment_method" */
export type Payment_Method_Stddev_Order_By = {
  exp_month?: Maybe<Order_By>;
  exp_year?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Payment_Method_Stddev_Pop_Fields = {
  __typename?: 'payment_method_stddev_pop_fields';
  exp_month?: Maybe<Scalars['Float']>;
  exp_year?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "payment_method" */
export type Payment_Method_Stddev_Pop_Order_By = {
  exp_month?: Maybe<Order_By>;
  exp_year?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Payment_Method_Stddev_Samp_Fields = {
  __typename?: 'payment_method_stddev_samp_fields';
  exp_month?: Maybe<Scalars['Float']>;
  exp_year?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "payment_method" */
export type Payment_Method_Stddev_Samp_Order_By = {
  exp_month?: Maybe<Order_By>;
  exp_year?: Maybe<Order_By>;
};

/** Streaming cursor of the table "payment_method" */
export type Payment_Method_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Payment_Method_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Payment_Method_Stream_Cursor_Value_Input = {
  brand?: Maybe<Scalars['String']>;
  country_code?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  exp_month?: Maybe<Scalars['Int']>;
  exp_year?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['String']>;
  is_default?: Maybe<Scalars['Boolean']>;
  last4?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  stripe_customer_id?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Payment_Method_Sum_Fields = {
  __typename?: 'payment_method_sum_fields';
  exp_month?: Maybe<Scalars['Int']>;
  exp_year?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "payment_method" */
export type Payment_Method_Sum_Order_By = {
  exp_month?: Maybe<Order_By>;
  exp_year?: Maybe<Order_By>;
};

/** update columns of table "payment_method" */
export enum Payment_Method_Update_Column {
  /** column name */
  Brand = 'brand',
  /** column name */
  CountryCode = 'country_code',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ExpMonth = 'exp_month',
  /** column name */
  ExpYear = 'exp_year',
  /** column name */
  Id = 'id',
  /** column name */
  IsDefault = 'is_default',
  /** column name */
  Last4 = 'last4',
  /** column name */
  Name = 'name',
  /** column name */
  Status = 'status',
  /** column name */
  StripeCustomerId = 'stripe_customer_id',
  /** column name */
  Type = 'type',
}

export type Payment_Method_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Payment_Method_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Payment_Method_Set_Input>;
  /** filter the rows which have to be updated */
  where: Payment_Method_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Payment_Method_Var_Pop_Fields = {
  __typename?: 'payment_method_var_pop_fields';
  exp_month?: Maybe<Scalars['Float']>;
  exp_year?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "payment_method" */
export type Payment_Method_Var_Pop_Order_By = {
  exp_month?: Maybe<Order_By>;
  exp_year?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Payment_Method_Var_Samp_Fields = {
  __typename?: 'payment_method_var_samp_fields';
  exp_month?: Maybe<Scalars['Float']>;
  exp_year?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "payment_method" */
export type Payment_Method_Var_Samp_Order_By = {
  exp_month?: Maybe<Order_By>;
  exp_year?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Payment_Method_Variance_Fields = {
  __typename?: 'payment_method_variance_fields';
  exp_month?: Maybe<Scalars['Float']>;
  exp_year?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "payment_method" */
export type Payment_Method_Variance_Order_By = {
  exp_month?: Maybe<Order_By>;
  exp_year?: Maybe<Order_By>;
};

export type PersonalAccessToken = {
  __typename?: 'PersonalAccessToken';
  description: Scalars['String'];
  id: Scalars['uuid'];
  is_active: Scalars['Boolean'];
  token: Scalars['String'];
  user_id: Scalars['uuid'];
};

export type PersonalAccessTokenInput = {
  description: Scalars['String'];
};

export enum Plan {
  CloudFree = 'cloud_free',
  CloudFreeV2 = 'cloud_free_v2',
  CloudPayg = 'cloud_payg',
  CloudShared = 'cloud_shared',
}

/** Each row represents which entitlements a plan has access to.  */
export type Plan_Entitlements = {
  __typename?: 'plan_entitlements';
  created_at: Scalars['timestamp'];
  /** An object relationship */
  entitlement: Project_Entitlement_Catalogue;
  entitlement_id: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  plan: Plans;
  plan_name: Scalars['String'];
  updated_at: Scalars['timestamp'];
};

/** aggregated selection of "plan_entitlements" */
export type Plan_Entitlements_Aggregate = {
  __typename?: 'plan_entitlements_aggregate';
  aggregate?: Maybe<Plan_Entitlements_Aggregate_Fields>;
  nodes: Array<Plan_Entitlements>;
};

export type Plan_Entitlements_Aggregate_Bool_Exp = {
  count?: Maybe<Plan_Entitlements_Aggregate_Bool_Exp_Count>;
};

export type Plan_Entitlements_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Plan_Entitlements_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Plan_Entitlements_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "plan_entitlements" */
export type Plan_Entitlements_Aggregate_Fields = {
  __typename?: 'plan_entitlements_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Plan_Entitlements_Max_Fields>;
  min?: Maybe<Plan_Entitlements_Min_Fields>;
};

/** aggregate fields of "plan_entitlements" */
export type Plan_Entitlements_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Plan_Entitlements_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "plan_entitlements" */
export type Plan_Entitlements_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Plan_Entitlements_Max_Order_By>;
  min?: Maybe<Plan_Entitlements_Min_Order_By>;
};

/** input type for inserting array relation for remote table "plan_entitlements" */
export type Plan_Entitlements_Arr_Rel_Insert_Input = {
  data: Array<Plan_Entitlements_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Plan_Entitlements_On_Conflict>;
};

/** Boolean expression to filter rows from the table "plan_entitlements". All fields are combined with a logical 'AND'. */
export type Plan_Entitlements_Bool_Exp = {
  _and?: Maybe<Array<Plan_Entitlements_Bool_Exp>>;
  _not?: Maybe<Plan_Entitlements_Bool_Exp>;
  _or?: Maybe<Array<Plan_Entitlements_Bool_Exp>>;
  created_at?: Maybe<Timestamp_Comparison_Exp>;
  entitlement?: Maybe<Project_Entitlement_Catalogue_Bool_Exp>;
  entitlement_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  plan?: Maybe<Plans_Bool_Exp>;
  plan_name?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "plan_entitlements" */
export enum Plan_Entitlements_Constraint {
  /** unique or primary key constraint on columns "id" */
  PlanEntitlementsPkey = 'plan_entitlements_pkey',
}

/** input type for inserting data into table "plan_entitlements" */
export type Plan_Entitlements_Insert_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement?: Maybe<Project_Entitlement_Catalogue_Obj_Rel_Insert_Input>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  plan?: Maybe<Plans_Obj_Rel_Insert_Input>;
  plan_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Plan_Entitlements_Max_Fields = {
  __typename?: 'plan_entitlements_max_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by max() on columns of table "plan_entitlements" */
export type Plan_Entitlements_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  plan_name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Plan_Entitlements_Min_Fields = {
  __typename?: 'plan_entitlements_min_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by min() on columns of table "plan_entitlements" */
export type Plan_Entitlements_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  plan_name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "plan_entitlements" */
export type Plan_Entitlements_Mutation_Response = {
  __typename?: 'plan_entitlements_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Plan_Entitlements>;
};

/** on_conflict condition type for table "plan_entitlements" */
export type Plan_Entitlements_On_Conflict = {
  constraint: Plan_Entitlements_Constraint;
  update_columns?: Array<Plan_Entitlements_Update_Column>;
  where?: Maybe<Plan_Entitlements_Bool_Exp>;
};

/** Ordering options when selecting data from "plan_entitlements". */
export type Plan_Entitlements_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement?: Maybe<Project_Entitlement_Catalogue_Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  plan?: Maybe<Plans_Order_By>;
  plan_name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: plan_entitlements */
export type Plan_Entitlements_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "plan_entitlements" */
export enum Plan_Entitlements_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntitlementId = 'entitlement_id',
  /** column name */
  Id = 'id',
  /** column name */
  PlanName = 'plan_name',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "plan_entitlements" */
export type Plan_Entitlements_Set_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** Streaming cursor of the table "plan_entitlements" */
export type Plan_Entitlements_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Plan_Entitlements_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Plan_Entitlements_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** update columns of table "plan_entitlements" */
export enum Plan_Entitlements_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntitlementId = 'entitlement_id',
  /** column name */
  Id = 'id',
  /** column name */
  PlanName = 'plan_name',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Plan_Entitlements_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Plan_Entitlements_Set_Input>;
  /** filter the rows which have to be updated */
  where: Plan_Entitlements_Bool_Exp;
};

export type PlanResponse = {
  __typename?: 'PlanResponse';
  activity_id: Scalars['uuid'];
  newPlan: Plan;
  oldPlan: Plan;
  project?: Maybe<Projects>;
  projectId: Scalars['uuid'];
  status: Scalars['String'];
};

/** Payment / usage plans available for Hasura Cloud */
export type Plans = {
  __typename?: 'plans';
  alloc_limit?: Maybe<Scalars['Int']>;
  allow_list_enabled: Scalars['Boolean'];
  api_limits_enabled: Scalars['Boolean'];
  autoscaling_enabled: Scalars['Boolean'];
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  caching_enabled: Scalars['Boolean'];
  collaborators_enabled: Scalars['Boolean'];
  created_at: Scalars['timestamptz'];
  description: Scalars['String'];
  enable_granular_metrics?: Maybe<Scalars['Boolean']>;
  enable_otel_exporter: Scalars['Boolean'];
  /** An array relationship */
  entitlements: Array<Plan_Entitlements>;
  /** An aggregate relationship */
  entitlements_aggregate: Plan_Entitlements_Aggregate;
  high_availability_enabled: Scalars['Boolean'];
  log_retention: Scalars['Int'];
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  metrics_enabled: Scalars['Boolean'];
  name: Scalars['String'];
  operation_retention: Scalars['bigint'];
  read_replicas_enabled: Scalars['Boolean'];
  regression_tests_enabled: Scalars['Boolean'];
  request_time_limit?: Maybe<Scalars['Int']>;
  tracing_enabled: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  vpc_peering_enabled: Scalars['Boolean'];
};

/** Payment / usage plans available for Hasura Cloud */
export type PlansEntitlementsArgs = {
  distinct_on?: Maybe<Array<Plan_Entitlements_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Plan_Entitlements_Order_By>>;
  where?: Maybe<Plan_Entitlements_Bool_Exp>;
};

/** Payment / usage plans available for Hasura Cloud */
export type PlansEntitlements_AggregateArgs = {
  distinct_on?: Maybe<Array<Plan_Entitlements_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Plan_Entitlements_Order_By>>;
  where?: Maybe<Plan_Entitlements_Bool_Exp>;
};

/** aggregated selection of "plans" */
export type Plans_Aggregate = {
  __typename?: 'plans_aggregate';
  aggregate?: Maybe<Plans_Aggregate_Fields>;
  nodes: Array<Plans>;
};

/** aggregate fields of "plans" */
export type Plans_Aggregate_Fields = {
  __typename?: 'plans_aggregate_fields';
  avg?: Maybe<Plans_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Plans_Max_Fields>;
  min?: Maybe<Plans_Min_Fields>;
  stddev?: Maybe<Plans_Stddev_Fields>;
  stddev_pop?: Maybe<Plans_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Plans_Stddev_Samp_Fields>;
  sum?: Maybe<Plans_Sum_Fields>;
  var_pop?: Maybe<Plans_Var_Pop_Fields>;
  var_samp?: Maybe<Plans_Var_Samp_Fields>;
  variance?: Maybe<Plans_Variance_Fields>;
};

/** aggregate fields of "plans" */
export type Plans_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Plans_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Plans_Avg_Fields = {
  __typename?: 'plans_avg_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "plans". All fields are combined with a logical 'AND'. */
export type Plans_Bool_Exp = {
  _and?: Maybe<Array<Plans_Bool_Exp>>;
  _not?: Maybe<Plans_Bool_Exp>;
  _or?: Maybe<Array<Plans_Bool_Exp>>;
  alloc_limit?: Maybe<Int_Comparison_Exp>;
  allow_list_enabled?: Maybe<Boolean_Comparison_Exp>;
  api_limits_enabled?: Maybe<Boolean_Comparison_Exp>;
  autoscaling_enabled?: Maybe<Boolean_Comparison_Exp>;
  bucket_capacity?: Maybe<Bigint_Comparison_Exp>;
  bucket_rate?: Maybe<Bigint_Comparison_Exp>;
  caching_enabled?: Maybe<Boolean_Comparison_Exp>;
  collaborators_enabled?: Maybe<Boolean_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  enable_granular_metrics?: Maybe<Boolean_Comparison_Exp>;
  enable_otel_exporter?: Maybe<Boolean_Comparison_Exp>;
  entitlements?: Maybe<Plan_Entitlements_Bool_Exp>;
  entitlements_aggregate?: Maybe<Plan_Entitlements_Aggregate_Bool_Exp>;
  high_availability_enabled?: Maybe<Boolean_Comparison_Exp>;
  log_retention?: Maybe<Int_Comparison_Exp>;
  max_api_limit_roles?: Maybe<Int_Comparison_Exp>;
  max_cache_size?: Maybe<Bigint_Comparison_Exp>;
  max_cache_ttl?: Maybe<Bigint_Comparison_Exp>;
  max_collaborators?: Maybe<Int_Comparison_Exp>;
  max_data_usage?: Maybe<Bigint_Comparison_Exp>;
  max_read_replicas?: Maybe<Int_Comparison_Exp>;
  max_reqs_per_min?: Maybe<Int_Comparison_Exp>;
  metrics_enabled?: Maybe<Boolean_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  operation_retention?: Maybe<Bigint_Comparison_Exp>;
  read_replicas_enabled?: Maybe<Boolean_Comparison_Exp>;
  regression_tests_enabled?: Maybe<Boolean_Comparison_Exp>;
  request_time_limit?: Maybe<Int_Comparison_Exp>;
  tracing_enabled?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  vpc_peering_enabled?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "plans" */
export enum Plans_Constraint {
  /** unique or primary key constraint on columns "name" */
  PlansPkey = 'plans_pkey',
}

/** input type for incrementing numeric columns in table "plans" */
export type Plans_Inc_Input = {
  alloc_limit?: Maybe<Scalars['Int']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  request_time_limit?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "plans" */
export type Plans_Insert_Input = {
  alloc_limit?: Maybe<Scalars['Int']>;
  allow_list_enabled?: Maybe<Scalars['Boolean']>;
  api_limits_enabled?: Maybe<Scalars['Boolean']>;
  autoscaling_enabled?: Maybe<Scalars['Boolean']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  caching_enabled?: Maybe<Scalars['Boolean']>;
  collaborators_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  enable_granular_metrics?: Maybe<Scalars['Boolean']>;
  enable_otel_exporter?: Maybe<Scalars['Boolean']>;
  entitlements?: Maybe<Plan_Entitlements_Arr_Rel_Insert_Input>;
  high_availability_enabled?: Maybe<Scalars['Boolean']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  metrics_enabled?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  read_replicas_enabled?: Maybe<Scalars['Boolean']>;
  regression_tests_enabled?: Maybe<Scalars['Boolean']>;
  request_time_limit?: Maybe<Scalars['Int']>;
  tracing_enabled?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vpc_peering_enabled?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Plans_Max_Fields = {
  __typename?: 'plans_max_fields';
  alloc_limit?: Maybe<Scalars['Int']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  request_time_limit?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Plans_Min_Fields = {
  __typename?: 'plans_min_fields';
  alloc_limit?: Maybe<Scalars['Int']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  request_time_limit?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "plans" */
export type Plans_Mutation_Response = {
  __typename?: 'plans_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Plans>;
};

/** input type for inserting object relation for remote table "plans" */
export type Plans_Obj_Rel_Insert_Input = {
  data: Plans_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Plans_On_Conflict>;
};

/** on_conflict condition type for table "plans" */
export type Plans_On_Conflict = {
  constraint: Plans_Constraint;
  update_columns?: Array<Plans_Update_Column>;
  where?: Maybe<Plans_Bool_Exp>;
};

/** Ordering options when selecting data from "plans". */
export type Plans_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  allow_list_enabled?: Maybe<Order_By>;
  api_limits_enabled?: Maybe<Order_By>;
  autoscaling_enabled?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  caching_enabled?: Maybe<Order_By>;
  collaborators_enabled?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  enable_granular_metrics?: Maybe<Order_By>;
  enable_otel_exporter?: Maybe<Order_By>;
  entitlements_aggregate?: Maybe<Plan_Entitlements_Aggregate_Order_By>;
  high_availability_enabled?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  metrics_enabled?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  read_replicas_enabled?: Maybe<Order_By>;
  regression_tests_enabled?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
  tracing_enabled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  vpc_peering_enabled?: Maybe<Order_By>;
};

/** primary key columns input for table: plans */
export type Plans_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "plans" */
export enum Plans_Select_Column {
  /** column name */
  AllocLimit = 'alloc_limit',
  /** column name */
  AllowListEnabled = 'allow_list_enabled',
  /** column name */
  ApiLimitsEnabled = 'api_limits_enabled',
  /** column name */
  AutoscalingEnabled = 'autoscaling_enabled',
  /** column name */
  BucketCapacity = 'bucket_capacity',
  /** column name */
  BucketRate = 'bucket_rate',
  /** column name */
  CachingEnabled = 'caching_enabled',
  /** column name */
  CollaboratorsEnabled = 'collaborators_enabled',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  EnableGranularMetrics = 'enable_granular_metrics',
  /** column name */
  EnableOtelExporter = 'enable_otel_exporter',
  /** column name */
  HighAvailabilityEnabled = 'high_availability_enabled',
  /** column name */
  LogRetention = 'log_retention',
  /** column name */
  MaxApiLimitRoles = 'max_api_limit_roles',
  /** column name */
  MaxCacheSize = 'max_cache_size',
  /** column name */
  MaxCacheTtl = 'max_cache_ttl',
  /** column name */
  MaxCollaborators = 'max_collaborators',
  /** column name */
  MaxDataUsage = 'max_data_usage',
  /** column name */
  MaxReadReplicas = 'max_read_replicas',
  /** column name */
  MaxReqsPerMin = 'max_reqs_per_min',
  /** column name */
  MetricsEnabled = 'metrics_enabled',
  /** column name */
  Name = 'name',
  /** column name */
  OperationRetention = 'operation_retention',
  /** column name */
  ReadReplicasEnabled = 'read_replicas_enabled',
  /** column name */
  RegressionTestsEnabled = 'regression_tests_enabled',
  /** column name */
  RequestTimeLimit = 'request_time_limit',
  /** column name */
  TracingEnabled = 'tracing_enabled',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VpcPeeringEnabled = 'vpc_peering_enabled',
}

/** input type for updating data in table "plans" */
export type Plans_Set_Input = {
  alloc_limit?: Maybe<Scalars['Int']>;
  allow_list_enabled?: Maybe<Scalars['Boolean']>;
  api_limits_enabled?: Maybe<Scalars['Boolean']>;
  autoscaling_enabled?: Maybe<Scalars['Boolean']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  caching_enabled?: Maybe<Scalars['Boolean']>;
  collaborators_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  enable_granular_metrics?: Maybe<Scalars['Boolean']>;
  enable_otel_exporter?: Maybe<Scalars['Boolean']>;
  high_availability_enabled?: Maybe<Scalars['Boolean']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  metrics_enabled?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  read_replicas_enabled?: Maybe<Scalars['Boolean']>;
  regression_tests_enabled?: Maybe<Scalars['Boolean']>;
  request_time_limit?: Maybe<Scalars['Int']>;
  tracing_enabled?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vpc_peering_enabled?: Maybe<Scalars['Boolean']>;
};

/** aggregate stddev on columns */
export type Plans_Stddev_Fields = {
  __typename?: 'plans_stddev_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Plans_Stddev_Pop_Fields = {
  __typename?: 'plans_stddev_pop_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Plans_Stddev_Samp_Fields = {
  __typename?: 'plans_stddev_samp_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "plans" */
export type Plans_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Plans_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Plans_Stream_Cursor_Value_Input = {
  alloc_limit?: Maybe<Scalars['Int']>;
  allow_list_enabled?: Maybe<Scalars['Boolean']>;
  api_limits_enabled?: Maybe<Scalars['Boolean']>;
  autoscaling_enabled?: Maybe<Scalars['Boolean']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  caching_enabled?: Maybe<Scalars['Boolean']>;
  collaborators_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  enable_granular_metrics?: Maybe<Scalars['Boolean']>;
  enable_otel_exporter?: Maybe<Scalars['Boolean']>;
  high_availability_enabled?: Maybe<Scalars['Boolean']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  metrics_enabled?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  read_replicas_enabled?: Maybe<Scalars['Boolean']>;
  regression_tests_enabled?: Maybe<Scalars['Boolean']>;
  request_time_limit?: Maybe<Scalars['Int']>;
  tracing_enabled?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vpc_peering_enabled?: Maybe<Scalars['Boolean']>;
};

/** aggregate sum on columns */
export type Plans_Sum_Fields = {
  __typename?: 'plans_sum_fields';
  alloc_limit?: Maybe<Scalars['Int']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  request_time_limit?: Maybe<Scalars['Int']>;
};

/** update columns of table "plans" */
export enum Plans_Update_Column {
  /** column name */
  AllocLimit = 'alloc_limit',
  /** column name */
  AllowListEnabled = 'allow_list_enabled',
  /** column name */
  ApiLimitsEnabled = 'api_limits_enabled',
  /** column name */
  AutoscalingEnabled = 'autoscaling_enabled',
  /** column name */
  BucketCapacity = 'bucket_capacity',
  /** column name */
  BucketRate = 'bucket_rate',
  /** column name */
  CachingEnabled = 'caching_enabled',
  /** column name */
  CollaboratorsEnabled = 'collaborators_enabled',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  EnableGranularMetrics = 'enable_granular_metrics',
  /** column name */
  EnableOtelExporter = 'enable_otel_exporter',
  /** column name */
  HighAvailabilityEnabled = 'high_availability_enabled',
  /** column name */
  LogRetention = 'log_retention',
  /** column name */
  MaxApiLimitRoles = 'max_api_limit_roles',
  /** column name */
  MaxCacheSize = 'max_cache_size',
  /** column name */
  MaxCacheTtl = 'max_cache_ttl',
  /** column name */
  MaxCollaborators = 'max_collaborators',
  /** column name */
  MaxDataUsage = 'max_data_usage',
  /** column name */
  MaxReadReplicas = 'max_read_replicas',
  /** column name */
  MaxReqsPerMin = 'max_reqs_per_min',
  /** column name */
  MetricsEnabled = 'metrics_enabled',
  /** column name */
  Name = 'name',
  /** column name */
  OperationRetention = 'operation_retention',
  /** column name */
  ReadReplicasEnabled = 'read_replicas_enabled',
  /** column name */
  RegressionTestsEnabled = 'regression_tests_enabled',
  /** column name */
  RequestTimeLimit = 'request_time_limit',
  /** column name */
  TracingEnabled = 'tracing_enabled',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VpcPeeringEnabled = 'vpc_peering_enabled',
}

export type Plans_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Plans_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Plans_Set_Input>;
  /** filter the rows which have to be updated */
  where: Plans_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Plans_Var_Pop_Fields = {
  __typename?: 'plans_var_pop_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Plans_Var_Samp_Fields = {
  __typename?: 'plans_var_samp_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Plans_Variance_Fields = {
  __typename?: 'plans_variance_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** Policies (features) that are enabled for a project */
export type Policies = {
  __typename?: 'policies';
  alloc_limit?: Maybe<Scalars['Int']>;
  allow_list_enabled: Scalars['Boolean'];
  api_limits_enabled: Scalars['Boolean'];
  autoscaling_enabled: Scalars['Boolean'];
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  caching_enabled: Scalars['Boolean'];
  collaborators_enabled: Scalars['Boolean'];
  created_at: Scalars['timestamptz'];
  enable_granular_metrics?: Maybe<Scalars['Boolean']>;
  enable_otel_exporter: Scalars['Boolean'];
  high_availability_enabled: Scalars['Boolean'];
  log_retention: Scalars['Int'];
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  metrics_enabled: Scalars['Boolean'];
  operation_retention: Scalars['bigint'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  read_replicas_enabled: Scalars['Boolean'];
  regression_tests_enabled: Scalars['Boolean'];
  request_time_limit?: Maybe<Scalars['Int']>;
  tracing_enabled: Scalars['Boolean'];
  updated_at: Scalars['timestamptz'];
  vpc_peering_enabled: Scalars['Boolean'];
};

/** aggregated selection of "policies" */
export type Policies_Aggregate = {
  __typename?: 'policies_aggregate';
  aggregate?: Maybe<Policies_Aggregate_Fields>;
  nodes: Array<Policies>;
};

export type Policies_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Policies_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Policies_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Policies_Aggregate_Bool_Exp_Count>;
};

export type Policies_Aggregate_Bool_Exp_Bool_And = {
  arguments: Policies_Select_Column_Policies_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Policies_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Policies_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Policies_Select_Column_Policies_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Policies_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Policies_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Policies_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Policies_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "policies" */
export type Policies_Aggregate_Fields = {
  __typename?: 'policies_aggregate_fields';
  avg?: Maybe<Policies_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Policies_Max_Fields>;
  min?: Maybe<Policies_Min_Fields>;
  stddev?: Maybe<Policies_Stddev_Fields>;
  stddev_pop?: Maybe<Policies_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Policies_Stddev_Samp_Fields>;
  sum?: Maybe<Policies_Sum_Fields>;
  var_pop?: Maybe<Policies_Var_Pop_Fields>;
  var_samp?: Maybe<Policies_Var_Samp_Fields>;
  variance?: Maybe<Policies_Variance_Fields>;
};

/** aggregate fields of "policies" */
export type Policies_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Policies_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "policies" */
export type Policies_Aggregate_Order_By = {
  avg?: Maybe<Policies_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Policies_Max_Order_By>;
  min?: Maybe<Policies_Min_Order_By>;
  stddev?: Maybe<Policies_Stddev_Order_By>;
  stddev_pop?: Maybe<Policies_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Policies_Stddev_Samp_Order_By>;
  sum?: Maybe<Policies_Sum_Order_By>;
  var_pop?: Maybe<Policies_Var_Pop_Order_By>;
  var_samp?: Maybe<Policies_Var_Samp_Order_By>;
  variance?: Maybe<Policies_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "policies" */
export type Policies_Arr_Rel_Insert_Input = {
  data: Array<Policies_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Policies_On_Conflict>;
};

/** aggregate avg on columns */
export type Policies_Avg_Fields = {
  __typename?: 'policies_avg_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "policies" */
export type Policies_Avg_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "policies". All fields are combined with a logical 'AND'. */
export type Policies_Bool_Exp = {
  _and?: Maybe<Array<Policies_Bool_Exp>>;
  _not?: Maybe<Policies_Bool_Exp>;
  _or?: Maybe<Array<Policies_Bool_Exp>>;
  alloc_limit?: Maybe<Int_Comparison_Exp>;
  allow_list_enabled?: Maybe<Boolean_Comparison_Exp>;
  api_limits_enabled?: Maybe<Boolean_Comparison_Exp>;
  autoscaling_enabled?: Maybe<Boolean_Comparison_Exp>;
  bucket_capacity?: Maybe<Bigint_Comparison_Exp>;
  bucket_rate?: Maybe<Bigint_Comparison_Exp>;
  caching_enabled?: Maybe<Boolean_Comparison_Exp>;
  collaborators_enabled?: Maybe<Boolean_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  enable_granular_metrics?: Maybe<Boolean_Comparison_Exp>;
  enable_otel_exporter?: Maybe<Boolean_Comparison_Exp>;
  high_availability_enabled?: Maybe<Boolean_Comparison_Exp>;
  log_retention?: Maybe<Int_Comparison_Exp>;
  max_api_limit_roles?: Maybe<Int_Comparison_Exp>;
  max_cache_size?: Maybe<Bigint_Comparison_Exp>;
  max_cache_ttl?: Maybe<Bigint_Comparison_Exp>;
  max_collaborators?: Maybe<Int_Comparison_Exp>;
  max_data_usage?: Maybe<Bigint_Comparison_Exp>;
  max_read_replicas?: Maybe<Int_Comparison_Exp>;
  max_reqs_per_min?: Maybe<Int_Comparison_Exp>;
  metrics_enabled?: Maybe<Boolean_Comparison_Exp>;
  operation_retention?: Maybe<Bigint_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  read_replicas_enabled?: Maybe<Boolean_Comparison_Exp>;
  regression_tests_enabled?: Maybe<Boolean_Comparison_Exp>;
  request_time_limit?: Maybe<Int_Comparison_Exp>;
  tracing_enabled?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  vpc_peering_enabled?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "policies" */
export enum Policies_Constraint {
  /** unique or primary key constraint on columns "project_id" */
  PoliciesPkey = 'policies_pkey',
}

/** input type for incrementing numeric columns in table "policies" */
export type Policies_Inc_Input = {
  alloc_limit?: Maybe<Scalars['Int']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  request_time_limit?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "policies" */
export type Policies_Insert_Input = {
  alloc_limit?: Maybe<Scalars['Int']>;
  allow_list_enabled?: Maybe<Scalars['Boolean']>;
  api_limits_enabled?: Maybe<Scalars['Boolean']>;
  autoscaling_enabled?: Maybe<Scalars['Boolean']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  caching_enabled?: Maybe<Scalars['Boolean']>;
  collaborators_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  enable_granular_metrics?: Maybe<Scalars['Boolean']>;
  enable_otel_exporter?: Maybe<Scalars['Boolean']>;
  high_availability_enabled?: Maybe<Scalars['Boolean']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  metrics_enabled?: Maybe<Scalars['Boolean']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  read_replicas_enabled?: Maybe<Scalars['Boolean']>;
  regression_tests_enabled?: Maybe<Scalars['Boolean']>;
  request_time_limit?: Maybe<Scalars['Int']>;
  tracing_enabled?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vpc_peering_enabled?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Policies_Max_Fields = {
  __typename?: 'policies_max_fields';
  alloc_limit?: Maybe<Scalars['Int']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  request_time_limit?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "policies" */
export type Policies_Max_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Policies_Min_Fields = {
  __typename?: 'policies_min_fields';
  alloc_limit?: Maybe<Scalars['Int']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  request_time_limit?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "policies" */
export type Policies_Min_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "policies" */
export type Policies_Mutation_Response = {
  __typename?: 'policies_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Policies>;
};

/** input type for inserting object relation for remote table "policies" */
export type Policies_Obj_Rel_Insert_Input = {
  data: Policies_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Policies_On_Conflict>;
};

/** on_conflict condition type for table "policies" */
export type Policies_On_Conflict = {
  constraint: Policies_Constraint;
  update_columns?: Array<Policies_Update_Column>;
  where?: Maybe<Policies_Bool_Exp>;
};

/** Ordering options when selecting data from "policies". */
export type Policies_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  allow_list_enabled?: Maybe<Order_By>;
  api_limits_enabled?: Maybe<Order_By>;
  autoscaling_enabled?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  caching_enabled?: Maybe<Order_By>;
  collaborators_enabled?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  enable_granular_metrics?: Maybe<Order_By>;
  enable_otel_exporter?: Maybe<Order_By>;
  high_availability_enabled?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  metrics_enabled?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  read_replicas_enabled?: Maybe<Order_By>;
  regression_tests_enabled?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
  tracing_enabled?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  vpc_peering_enabled?: Maybe<Order_By>;
};

/** primary key columns input for table: policies */
export type Policies_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
};

/** select columns of table "policies" */
export enum Policies_Select_Column {
  /** column name */
  AllocLimit = 'alloc_limit',
  /** column name */
  AllowListEnabled = 'allow_list_enabled',
  /** column name */
  ApiLimitsEnabled = 'api_limits_enabled',
  /** column name */
  AutoscalingEnabled = 'autoscaling_enabled',
  /** column name */
  BucketCapacity = 'bucket_capacity',
  /** column name */
  BucketRate = 'bucket_rate',
  /** column name */
  CachingEnabled = 'caching_enabled',
  /** column name */
  CollaboratorsEnabled = 'collaborators_enabled',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EnableGranularMetrics = 'enable_granular_metrics',
  /** column name */
  EnableOtelExporter = 'enable_otel_exporter',
  /** column name */
  HighAvailabilityEnabled = 'high_availability_enabled',
  /** column name */
  LogRetention = 'log_retention',
  /** column name */
  MaxApiLimitRoles = 'max_api_limit_roles',
  /** column name */
  MaxCacheSize = 'max_cache_size',
  /** column name */
  MaxCacheTtl = 'max_cache_ttl',
  /** column name */
  MaxCollaborators = 'max_collaborators',
  /** column name */
  MaxDataUsage = 'max_data_usage',
  /** column name */
  MaxReadReplicas = 'max_read_replicas',
  /** column name */
  MaxReqsPerMin = 'max_reqs_per_min',
  /** column name */
  MetricsEnabled = 'metrics_enabled',
  /** column name */
  OperationRetention = 'operation_retention',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ReadReplicasEnabled = 'read_replicas_enabled',
  /** column name */
  RegressionTestsEnabled = 'regression_tests_enabled',
  /** column name */
  RequestTimeLimit = 'request_time_limit',
  /** column name */
  TracingEnabled = 'tracing_enabled',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VpcPeeringEnabled = 'vpc_peering_enabled',
}

/** select "policies_aggregate_bool_exp_bool_and_arguments_columns" columns of table "policies" */
export enum Policies_Select_Column_Policies_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  AllowListEnabled = 'allow_list_enabled',
  /** column name */
  ApiLimitsEnabled = 'api_limits_enabled',
  /** column name */
  AutoscalingEnabled = 'autoscaling_enabled',
  /** column name */
  CachingEnabled = 'caching_enabled',
  /** column name */
  CollaboratorsEnabled = 'collaborators_enabled',
  /** column name */
  EnableGranularMetrics = 'enable_granular_metrics',
  /** column name */
  EnableOtelExporter = 'enable_otel_exporter',
  /** column name */
  HighAvailabilityEnabled = 'high_availability_enabled',
  /** column name */
  MetricsEnabled = 'metrics_enabled',
  /** column name */
  ReadReplicasEnabled = 'read_replicas_enabled',
  /** column name */
  RegressionTestsEnabled = 'regression_tests_enabled',
  /** column name */
  TracingEnabled = 'tracing_enabled',
  /** column name */
  VpcPeeringEnabled = 'vpc_peering_enabled',
}

/** select "policies_aggregate_bool_exp_bool_or_arguments_columns" columns of table "policies" */
export enum Policies_Select_Column_Policies_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  AllowListEnabled = 'allow_list_enabled',
  /** column name */
  ApiLimitsEnabled = 'api_limits_enabled',
  /** column name */
  AutoscalingEnabled = 'autoscaling_enabled',
  /** column name */
  CachingEnabled = 'caching_enabled',
  /** column name */
  CollaboratorsEnabled = 'collaborators_enabled',
  /** column name */
  EnableGranularMetrics = 'enable_granular_metrics',
  /** column name */
  EnableOtelExporter = 'enable_otel_exporter',
  /** column name */
  HighAvailabilityEnabled = 'high_availability_enabled',
  /** column name */
  MetricsEnabled = 'metrics_enabled',
  /** column name */
  ReadReplicasEnabled = 'read_replicas_enabled',
  /** column name */
  RegressionTestsEnabled = 'regression_tests_enabled',
  /** column name */
  TracingEnabled = 'tracing_enabled',
  /** column name */
  VpcPeeringEnabled = 'vpc_peering_enabled',
}

/** input type for updating data in table "policies" */
export type Policies_Set_Input = {
  alloc_limit?: Maybe<Scalars['Int']>;
  allow_list_enabled?: Maybe<Scalars['Boolean']>;
  api_limits_enabled?: Maybe<Scalars['Boolean']>;
  autoscaling_enabled?: Maybe<Scalars['Boolean']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  caching_enabled?: Maybe<Scalars['Boolean']>;
  collaborators_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  enable_granular_metrics?: Maybe<Scalars['Boolean']>;
  enable_otel_exporter?: Maybe<Scalars['Boolean']>;
  high_availability_enabled?: Maybe<Scalars['Boolean']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  metrics_enabled?: Maybe<Scalars['Boolean']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  read_replicas_enabled?: Maybe<Scalars['Boolean']>;
  regression_tests_enabled?: Maybe<Scalars['Boolean']>;
  request_time_limit?: Maybe<Scalars['Int']>;
  tracing_enabled?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vpc_peering_enabled?: Maybe<Scalars['Boolean']>;
};

/** aggregate stddev on columns */
export type Policies_Stddev_Fields = {
  __typename?: 'policies_stddev_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "policies" */
export type Policies_Stddev_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Policies_Stddev_Pop_Fields = {
  __typename?: 'policies_stddev_pop_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "policies" */
export type Policies_Stddev_Pop_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Policies_Stddev_Samp_Fields = {
  __typename?: 'policies_stddev_samp_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "policies" */
export type Policies_Stddev_Samp_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
};

/** Streaming cursor of the table "policies" */
export type Policies_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Policies_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Policies_Stream_Cursor_Value_Input = {
  alloc_limit?: Maybe<Scalars['Int']>;
  allow_list_enabled?: Maybe<Scalars['Boolean']>;
  api_limits_enabled?: Maybe<Scalars['Boolean']>;
  autoscaling_enabled?: Maybe<Scalars['Boolean']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  caching_enabled?: Maybe<Scalars['Boolean']>;
  collaborators_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  enable_granular_metrics?: Maybe<Scalars['Boolean']>;
  enable_otel_exporter?: Maybe<Scalars['Boolean']>;
  high_availability_enabled?: Maybe<Scalars['Boolean']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  metrics_enabled?: Maybe<Scalars['Boolean']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  read_replicas_enabled?: Maybe<Scalars['Boolean']>;
  regression_tests_enabled?: Maybe<Scalars['Boolean']>;
  request_time_limit?: Maybe<Scalars['Int']>;
  tracing_enabled?: Maybe<Scalars['Boolean']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  vpc_peering_enabled?: Maybe<Scalars['Boolean']>;
};

/** aggregate sum on columns */
export type Policies_Sum_Fields = {
  __typename?: 'policies_sum_fields';
  alloc_limit?: Maybe<Scalars['Int']>;
  bucket_capacity?: Maybe<Scalars['bigint']>;
  bucket_rate?: Maybe<Scalars['bigint']>;
  log_retention?: Maybe<Scalars['Int']>;
  max_api_limit_roles?: Maybe<Scalars['Int']>;
  max_cache_size?: Maybe<Scalars['bigint']>;
  max_cache_ttl?: Maybe<Scalars['bigint']>;
  max_collaborators?: Maybe<Scalars['Int']>;
  max_data_usage?: Maybe<Scalars['bigint']>;
  max_read_replicas?: Maybe<Scalars['Int']>;
  max_reqs_per_min?: Maybe<Scalars['Int']>;
  operation_retention?: Maybe<Scalars['bigint']>;
  request_time_limit?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "policies" */
export type Policies_Sum_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
};

/** update columns of table "policies" */
export enum Policies_Update_Column {
  /** column name */
  AllocLimit = 'alloc_limit',
  /** column name */
  AllowListEnabled = 'allow_list_enabled',
  /** column name */
  ApiLimitsEnabled = 'api_limits_enabled',
  /** column name */
  AutoscalingEnabled = 'autoscaling_enabled',
  /** column name */
  BucketCapacity = 'bucket_capacity',
  /** column name */
  BucketRate = 'bucket_rate',
  /** column name */
  CachingEnabled = 'caching_enabled',
  /** column name */
  CollaboratorsEnabled = 'collaborators_enabled',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EnableGranularMetrics = 'enable_granular_metrics',
  /** column name */
  EnableOtelExporter = 'enable_otel_exporter',
  /** column name */
  HighAvailabilityEnabled = 'high_availability_enabled',
  /** column name */
  LogRetention = 'log_retention',
  /** column name */
  MaxApiLimitRoles = 'max_api_limit_roles',
  /** column name */
  MaxCacheSize = 'max_cache_size',
  /** column name */
  MaxCacheTtl = 'max_cache_ttl',
  /** column name */
  MaxCollaborators = 'max_collaborators',
  /** column name */
  MaxDataUsage = 'max_data_usage',
  /** column name */
  MaxReadReplicas = 'max_read_replicas',
  /** column name */
  MaxReqsPerMin = 'max_reqs_per_min',
  /** column name */
  MetricsEnabled = 'metrics_enabled',
  /** column name */
  OperationRetention = 'operation_retention',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ReadReplicasEnabled = 'read_replicas_enabled',
  /** column name */
  RegressionTestsEnabled = 'regression_tests_enabled',
  /** column name */
  RequestTimeLimit = 'request_time_limit',
  /** column name */
  TracingEnabled = 'tracing_enabled',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VpcPeeringEnabled = 'vpc_peering_enabled',
}

export type Policies_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Policies_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Policies_Set_Input>;
  /** filter the rows which have to be updated */
  where: Policies_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Policies_Var_Pop_Fields = {
  __typename?: 'policies_var_pop_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "policies" */
export type Policies_Var_Pop_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Policies_Var_Samp_Fields = {
  __typename?: 'policies_var_samp_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "policies" */
export type Policies_Var_Samp_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Policies_Variance_Fields = {
  __typename?: 'policies_variance_fields';
  alloc_limit?: Maybe<Scalars['Float']>;
  bucket_capacity?: Maybe<Scalars['Float']>;
  bucket_rate?: Maybe<Scalars['Float']>;
  log_retention?: Maybe<Scalars['Float']>;
  max_api_limit_roles?: Maybe<Scalars['Float']>;
  max_cache_size?: Maybe<Scalars['Float']>;
  max_cache_ttl?: Maybe<Scalars['Float']>;
  max_collaborators?: Maybe<Scalars['Float']>;
  max_data_usage?: Maybe<Scalars['Float']>;
  max_read_replicas?: Maybe<Scalars['Float']>;
  max_reqs_per_min?: Maybe<Scalars['Float']>;
  operation_retention?: Maybe<Scalars['Float']>;
  request_time_limit?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "policies" */
export type Policies_Variance_Order_By = {
  alloc_limit?: Maybe<Order_By>;
  bucket_capacity?: Maybe<Order_By>;
  bucket_rate?: Maybe<Order_By>;
  log_retention?: Maybe<Order_By>;
  max_api_limit_roles?: Maybe<Order_By>;
  max_cache_size?: Maybe<Order_By>;
  max_cache_ttl?: Maybe<Order_By>;
  max_collaborators?: Maybe<Order_By>;
  max_data_usage?: Maybe<Order_By>;
  max_read_replicas?: Maybe<Order_By>;
  max_reqs_per_min?: Maybe<Order_By>;
  operation_retention?: Maybe<Order_By>;
  request_time_limit?: Maybe<Order_By>;
};

export type PreviewAppResponse = {
  __typename?: 'PreviewAppResponse';
  github_preview_app_job?: Maybe<Jobs>;
  githubPreviewAppJobID: Scalars['uuid'];
};

export type PrivilegedProjectInput = {
  privileges?: Maybe<Array<Scalars['String']>>;
};

/** Available privileges (e.g. admin) for Hasura Cloud */
export type Privileges = {
  __typename?: 'privileges';
  description?: Maybe<Scalars['String']>;
  display_order: Scalars['Int'];
  name: Scalars['String'];
  slug: Scalars['String'];
};

/** aggregated selection of "privileges" */
export type Privileges_Aggregate = {
  __typename?: 'privileges_aggregate';
  aggregate?: Maybe<Privileges_Aggregate_Fields>;
  nodes: Array<Privileges>;
};

/** aggregate fields of "privileges" */
export type Privileges_Aggregate_Fields = {
  __typename?: 'privileges_aggregate_fields';
  avg?: Maybe<Privileges_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Privileges_Max_Fields>;
  min?: Maybe<Privileges_Min_Fields>;
  stddev?: Maybe<Privileges_Stddev_Fields>;
  stddev_pop?: Maybe<Privileges_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Privileges_Stddev_Samp_Fields>;
  sum?: Maybe<Privileges_Sum_Fields>;
  var_pop?: Maybe<Privileges_Var_Pop_Fields>;
  var_samp?: Maybe<Privileges_Var_Samp_Fields>;
  variance?: Maybe<Privileges_Variance_Fields>;
};

/** aggregate fields of "privileges" */
export type Privileges_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Privileges_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Privileges_Avg_Fields = {
  __typename?: 'privileges_avg_fields';
  display_order?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "privileges". All fields are combined with a logical 'AND'. */
export type Privileges_Bool_Exp = {
  _and?: Maybe<Array<Privileges_Bool_Exp>>;
  _not?: Maybe<Privileges_Bool_Exp>;
  _or?: Maybe<Array<Privileges_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  display_order?: Maybe<Int_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  slug?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "privileges" */
export enum Privileges_Constraint {
  /** unique or primary key constraint on columns "slug" */
  PrivilegesPkey = 'privileges_pkey',
}

/** input type for incrementing numeric columns in table "privileges" */
export type Privileges_Inc_Input = {
  display_order?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "privileges" */
export type Privileges_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  display_order?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Privileges_Max_Fields = {
  __typename?: 'privileges_max_fields';
  description?: Maybe<Scalars['String']>;
  display_order?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Privileges_Min_Fields = {
  __typename?: 'privileges_min_fields';
  description?: Maybe<Scalars['String']>;
  display_order?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "privileges" */
export type Privileges_Mutation_Response = {
  __typename?: 'privileges_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Privileges>;
};

/** on_conflict condition type for table "privileges" */
export type Privileges_On_Conflict = {
  constraint: Privileges_Constraint;
  update_columns?: Array<Privileges_Update_Column>;
  where?: Maybe<Privileges_Bool_Exp>;
};

/** Ordering options when selecting data from "privileges". */
export type Privileges_Order_By = {
  description?: Maybe<Order_By>;
  display_order?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
};

/** primary key columns input for table: privileges */
export type Privileges_Pk_Columns_Input = {
  slug: Scalars['String'];
};

/** select columns of table "privileges" */
export enum Privileges_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  DisplayOrder = 'display_order',
  /** column name */
  Name = 'name',
  /** column name */
  Slug = 'slug',
}

/** input type for updating data in table "privileges" */
export type Privileges_Set_Input = {
  description?: Maybe<Scalars['String']>;
  display_order?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Privileges_Stddev_Fields = {
  __typename?: 'privileges_stddev_fields';
  display_order?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Privileges_Stddev_Pop_Fields = {
  __typename?: 'privileges_stddev_pop_fields';
  display_order?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Privileges_Stddev_Samp_Fields = {
  __typename?: 'privileges_stddev_samp_fields';
  display_order?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "privileges" */
export type Privileges_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Privileges_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Privileges_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  display_order?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Privileges_Sum_Fields = {
  __typename?: 'privileges_sum_fields';
  display_order?: Maybe<Scalars['Int']>;
};

/** update columns of table "privileges" */
export enum Privileges_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  DisplayOrder = 'display_order',
  /** column name */
  Name = 'name',
  /** column name */
  Slug = 'slug',
}

export type Privileges_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Privileges_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Privileges_Set_Input>;
  /** filter the rows which have to be updated */
  where: Privileges_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Privileges_Var_Pop_Fields = {
  __typename?: 'privileges_var_pop_fields';
  display_order?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Privileges_Var_Samp_Fields = {
  __typename?: 'privileges_var_samp_fields';
  display_order?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Privileges_Variance_Fields = {
  __typename?: 'privileges_variance_fields';
  display_order?: Maybe<Scalars['Float']>;
};

/** Pro License Keys generated for EE Lite */
export type Pro_License_Keys = {
  __typename?: 'pro_license_keys';
  created_at: Scalars['timestamptz'];
  created_by: Scalars['uuid'];
  customer_email: Scalars['String'];
  customer_name: Scalars['String'];
  id: Scalars['uuid'];
  is_active: Scalars['Boolean'];
  license_key: Scalars['String'];
  notes?: Maybe<Scalars['String']>;
  /** Token Lifetime in days */
  validity: Scalars['Int'];
};

/** aggregated selection of "pro_license_keys" */
export type Pro_License_Keys_Aggregate = {
  __typename?: 'pro_license_keys_aggregate';
  aggregate?: Maybe<Pro_License_Keys_Aggregate_Fields>;
  nodes: Array<Pro_License_Keys>;
};

/** aggregate fields of "pro_license_keys" */
export type Pro_License_Keys_Aggregate_Fields = {
  __typename?: 'pro_license_keys_aggregate_fields';
  avg?: Maybe<Pro_License_Keys_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Pro_License_Keys_Max_Fields>;
  min?: Maybe<Pro_License_Keys_Min_Fields>;
  stddev?: Maybe<Pro_License_Keys_Stddev_Fields>;
  stddev_pop?: Maybe<Pro_License_Keys_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Pro_License_Keys_Stddev_Samp_Fields>;
  sum?: Maybe<Pro_License_Keys_Sum_Fields>;
  var_pop?: Maybe<Pro_License_Keys_Var_Pop_Fields>;
  var_samp?: Maybe<Pro_License_Keys_Var_Samp_Fields>;
  variance?: Maybe<Pro_License_Keys_Variance_Fields>;
};

/** aggregate fields of "pro_license_keys" */
export type Pro_License_Keys_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Pro_License_Keys_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Pro_License_Keys_Avg_Fields = {
  __typename?: 'pro_license_keys_avg_fields';
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "pro_license_keys". All fields are combined with a logical 'AND'. */
export type Pro_License_Keys_Bool_Exp = {
  _and?: Maybe<Array<Pro_License_Keys_Bool_Exp>>;
  _not?: Maybe<Pro_License_Keys_Bool_Exp>;
  _or?: Maybe<Array<Pro_License_Keys_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  created_by?: Maybe<Uuid_Comparison_Exp>;
  customer_email?: Maybe<String_Comparison_Exp>;
  customer_name?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  license_key?: Maybe<String_Comparison_Exp>;
  notes?: Maybe<String_Comparison_Exp>;
  validity?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "pro_license_keys" */
export enum Pro_License_Keys_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProLicenseKeysPkey = 'pro_license_keys_pkey',
}

/** input type for incrementing numeric columns in table "pro_license_keys" */
export type Pro_License_Keys_Inc_Input = {
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "pro_license_keys" */
export type Pro_License_Keys_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  customer_email?: Maybe<Scalars['String']>;
  customer_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  license_key?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Pro_License_Keys_Max_Fields = {
  __typename?: 'pro_license_keys_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  customer_email?: Maybe<Scalars['String']>;
  customer_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  license_key?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Pro_License_Keys_Min_Fields = {
  __typename?: 'pro_license_keys_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  customer_email?: Maybe<Scalars['String']>;
  customer_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  license_key?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "pro_license_keys" */
export type Pro_License_Keys_Mutation_Response = {
  __typename?: 'pro_license_keys_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Pro_License_Keys>;
};

/** on_conflict condition type for table "pro_license_keys" */
export type Pro_License_Keys_On_Conflict = {
  constraint: Pro_License_Keys_Constraint;
  update_columns?: Array<Pro_License_Keys_Update_Column>;
  where?: Maybe<Pro_License_Keys_Bool_Exp>;
};

/** Ordering options when selecting data from "pro_license_keys". */
export type Pro_License_Keys_Order_By = {
  created_at?: Maybe<Order_By>;
  created_by?: Maybe<Order_By>;
  customer_email?: Maybe<Order_By>;
  customer_name?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  license_key?: Maybe<Order_By>;
  notes?: Maybe<Order_By>;
  validity?: Maybe<Order_By>;
};

/** primary key columns input for table: pro_license_keys */
export type Pro_License_Keys_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "pro_license_keys" */
export enum Pro_License_Keys_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  CustomerEmail = 'customer_email',
  /** column name */
  CustomerName = 'customer_name',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  LicenseKey = 'license_key',
  /** column name */
  Notes = 'notes',
  /** column name */
  Validity = 'validity',
}

/** input type for updating data in table "pro_license_keys" */
export type Pro_License_Keys_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  customer_email?: Maybe<Scalars['String']>;
  customer_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  license_key?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Pro_License_Keys_Stddev_Fields = {
  __typename?: 'pro_license_keys_stddev_fields';
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Pro_License_Keys_Stddev_Pop_Fields = {
  __typename?: 'pro_license_keys_stddev_pop_fields';
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Pro_License_Keys_Stddev_Samp_Fields = {
  __typename?: 'pro_license_keys_stddev_samp_fields';
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "pro_license_keys" */
export type Pro_License_Keys_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Pro_License_Keys_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Pro_License_Keys_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['uuid']>;
  customer_email?: Maybe<Scalars['String']>;
  customer_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  license_key?: Maybe<Scalars['String']>;
  notes?: Maybe<Scalars['String']>;
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Pro_License_Keys_Sum_Fields = {
  __typename?: 'pro_license_keys_sum_fields';
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Int']>;
};

/** update columns of table "pro_license_keys" */
export enum Pro_License_Keys_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  CustomerEmail = 'customer_email',
  /** column name */
  CustomerName = 'customer_name',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  LicenseKey = 'license_key',
  /** column name */
  Notes = 'notes',
  /** column name */
  Validity = 'validity',
}

export type Pro_License_Keys_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Pro_License_Keys_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Pro_License_Keys_Set_Input>;
  /** filter the rows which have to be updated */
  where: Pro_License_Keys_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Pro_License_Keys_Var_Pop_Fields = {
  __typename?: 'pro_license_keys_var_pop_fields';
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Pro_License_Keys_Var_Samp_Fields = {
  __typename?: 'pro_license_keys_var_samp_fields';
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Pro_License_Keys_Variance_Fields = {
  __typename?: 'pro_license_keys_variance_fields';
  /** Token Lifetime in days */
  validity?: Maybe<Scalars['Float']>;
};

/** Table to capture project activity (features, plan etc.) */
export type Project_Activity = {
  __typename?: 'project_activity';
  activity_info?: Maybe<Scalars['String']>;
  activity_type?: Maybe<Scalars['String']>;
  changed_by_user_id: Scalars['uuid'];
  created_at: Scalars['timestamptz'];
  description: Scalars['String'];
  feature?: Maybe<Scalars['String']>;
  feature_enabled?: Maybe<Scalars['Boolean']>;
  feature_limit?: Maybe<Scalars['Int']>;
  id: Scalars['uuid'];
  is_feature_update?: Maybe<Scalars['Boolean']>;
  meta: Scalars['jsonb'];
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id?: Maybe<Scalars['uuid']>;
  status: Scalars['project_activity_status_enum'];
  /** An object relationship */
  user?: Maybe<Users>;
  /** user ID of the user to be billed for the plan/feature change */
  user_id: Scalars['uuid'];
};

/** Table to capture project activity (features, plan etc.) */
export type Project_ActivityMetaArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "project_activity" */
export type Project_Activity_Aggregate = {
  __typename?: 'project_activity_aggregate';
  aggregate?: Maybe<Project_Activity_Aggregate_Fields>;
  nodes: Array<Project_Activity>;
};

export type Project_Activity_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Project_Activity_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Project_Activity_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Project_Activity_Aggregate_Bool_Exp_Count>;
};

export type Project_Activity_Aggregate_Bool_Exp_Bool_And = {
  arguments: Project_Activity_Select_Column_Project_Activity_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Activity_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Project_Activity_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Project_Activity_Select_Column_Project_Activity_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Activity_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Project_Activity_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Project_Activity_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Activity_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_activity" */
export type Project_Activity_Aggregate_Fields = {
  __typename?: 'project_activity_aggregate_fields';
  avg?: Maybe<Project_Activity_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Activity_Max_Fields>;
  min?: Maybe<Project_Activity_Min_Fields>;
  stddev?: Maybe<Project_Activity_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Activity_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Activity_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Activity_Sum_Fields>;
  var_pop?: Maybe<Project_Activity_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Activity_Var_Samp_Fields>;
  variance?: Maybe<Project_Activity_Variance_Fields>;
};

/** aggregate fields of "project_activity" */
export type Project_Activity_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Activity_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_activity" */
export type Project_Activity_Aggregate_Order_By = {
  avg?: Maybe<Project_Activity_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Activity_Max_Order_By>;
  min?: Maybe<Project_Activity_Min_Order_By>;
  stddev?: Maybe<Project_Activity_Stddev_Order_By>;
  stddev_pop?: Maybe<Project_Activity_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Project_Activity_Stddev_Samp_Order_By>;
  sum?: Maybe<Project_Activity_Sum_Order_By>;
  var_pop?: Maybe<Project_Activity_Var_Pop_Order_By>;
  var_samp?: Maybe<Project_Activity_Var_Samp_Order_By>;
  variance?: Maybe<Project_Activity_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Project_Activity_Append_Input = {
  meta?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "project_activity" */
export type Project_Activity_Arr_Rel_Insert_Input = {
  data: Array<Project_Activity_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Activity_On_Conflict>;
};

/** aggregate avg on columns */
export type Project_Activity_Avg_Fields = {
  __typename?: 'project_activity_avg_fields';
  feature_limit?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "project_activity" */
export type Project_Activity_Avg_Order_By = {
  feature_limit?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "project_activity". All fields are combined with a logical 'AND'. */
export type Project_Activity_Bool_Exp = {
  _and?: Maybe<Array<Project_Activity_Bool_Exp>>;
  _not?: Maybe<Project_Activity_Bool_Exp>;
  _or?: Maybe<Array<Project_Activity_Bool_Exp>>;
  activity_info?: Maybe<String_Comparison_Exp>;
  activity_type?: Maybe<String_Comparison_Exp>;
  changed_by_user_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  feature?: Maybe<String_Comparison_Exp>;
  feature_enabled?: Maybe<Boolean_Comparison_Exp>;
  feature_limit?: Maybe<Int_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_feature_update?: Maybe<Boolean_Comparison_Exp>;
  meta?: Maybe<Jsonb_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  status?: Maybe<Project_Activity_Status_Enum_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_activity" */
export enum Project_Activity_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectActivityPkey = 'project_activity_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Project_Activity_Delete_At_Path_Input = {
  meta?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Project_Activity_Delete_Elem_Input = {
  meta?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Project_Activity_Delete_Key_Input = {
  meta?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "project_activity" */
export type Project_Activity_Inc_Input = {
  feature_limit?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "project_activity" */
export type Project_Activity_Insert_Input = {
  activity_info?: Maybe<Scalars['String']>;
  activity_type?: Maybe<Scalars['String']>;
  changed_by_user_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  feature?: Maybe<Scalars['String']>;
  feature_enabled?: Maybe<Scalars['Boolean']>;
  feature_limit?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  is_feature_update?: Maybe<Scalars['Boolean']>;
  meta?: Maybe<Scalars['jsonb']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['project_activity_status_enum']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  /** user ID of the user to be billed for the plan/feature change */
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Project_Activity_Max_Fields = {
  __typename?: 'project_activity_max_fields';
  activity_info?: Maybe<Scalars['String']>;
  activity_type?: Maybe<Scalars['String']>;
  changed_by_user_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  feature?: Maybe<Scalars['String']>;
  feature_limit?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['project_activity_status_enum']>;
  /** user ID of the user to be billed for the plan/feature change */
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "project_activity" */
export type Project_Activity_Max_Order_By = {
  activity_info?: Maybe<Order_By>;
  activity_type?: Maybe<Order_By>;
  changed_by_user_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  feature?: Maybe<Order_By>;
  feature_limit?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  /** user ID of the user to be billed for the plan/feature change */
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Activity_Min_Fields = {
  __typename?: 'project_activity_min_fields';
  activity_info?: Maybe<Scalars['String']>;
  activity_type?: Maybe<Scalars['String']>;
  changed_by_user_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  feature?: Maybe<Scalars['String']>;
  feature_limit?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['project_activity_status_enum']>;
  /** user ID of the user to be billed for the plan/feature change */
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "project_activity" */
export type Project_Activity_Min_Order_By = {
  activity_info?: Maybe<Order_By>;
  activity_type?: Maybe<Order_By>;
  changed_by_user_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  feature?: Maybe<Order_By>;
  feature_limit?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  /** user ID of the user to be billed for the plan/feature change */
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_activity" */
export type Project_Activity_Mutation_Response = {
  __typename?: 'project_activity_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Activity>;
};

/** on_conflict condition type for table "project_activity" */
export type Project_Activity_On_Conflict = {
  constraint: Project_Activity_Constraint;
  update_columns?: Array<Project_Activity_Update_Column>;
  where?: Maybe<Project_Activity_Bool_Exp>;
};

/** Ordering options when selecting data from "project_activity". */
export type Project_Activity_Order_By = {
  activity_info?: Maybe<Order_By>;
  activity_type?: Maybe<Order_By>;
  changed_by_user_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  feature?: Maybe<Order_By>;
  feature_enabled?: Maybe<Order_By>;
  feature_limit?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_feature_update?: Maybe<Order_By>;
  meta?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: project_activity */
export type Project_Activity_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Project_Activity_Prepend_Input = {
  meta?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "project_activity" */
export enum Project_Activity_Select_Column {
  /** column name */
  ActivityInfo = 'activity_info',
  /** column name */
  ActivityType = 'activity_type',
  /** column name */
  ChangedByUserId = 'changed_by_user_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Feature = 'feature',
  /** column name */
  FeatureEnabled = 'feature_enabled',
  /** column name */
  FeatureLimit = 'feature_limit',
  /** column name */
  Id = 'id',
  /** column name */
  IsFeatureUpdate = 'is_feature_update',
  /** column name */
  Meta = 'meta',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Status = 'status',
  /** column name */
  UserId = 'user_id',
}

/** select "project_activity_aggregate_bool_exp_bool_and_arguments_columns" columns of table "project_activity" */
export enum Project_Activity_Select_Column_Project_Activity_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  FeatureEnabled = 'feature_enabled',
  /** column name */
  IsFeatureUpdate = 'is_feature_update',
}

/** select "project_activity_aggregate_bool_exp_bool_or_arguments_columns" columns of table "project_activity" */
export enum Project_Activity_Select_Column_Project_Activity_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  FeatureEnabled = 'feature_enabled',
  /** column name */
  IsFeatureUpdate = 'is_feature_update',
}

/** input type for updating data in table "project_activity" */
export type Project_Activity_Set_Input = {
  activity_info?: Maybe<Scalars['String']>;
  activity_type?: Maybe<Scalars['String']>;
  changed_by_user_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  feature?: Maybe<Scalars['String']>;
  feature_enabled?: Maybe<Scalars['Boolean']>;
  feature_limit?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  is_feature_update?: Maybe<Scalars['Boolean']>;
  meta?: Maybe<Scalars['jsonb']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['project_activity_status_enum']>;
  /** user ID of the user to be billed for the plan/feature change */
  user_id?: Maybe<Scalars['uuid']>;
};

/** Boolean expression to compare columns of type "project_activity_status_enum". All fields are combined with logical 'AND'. */
export type Project_Activity_Status_Enum_Comparison_Exp = {
  _eq?: Maybe<Scalars['project_activity_status_enum']>;
  _gt?: Maybe<Scalars['project_activity_status_enum']>;
  _gte?: Maybe<Scalars['project_activity_status_enum']>;
  _in?: Maybe<Array<Scalars['project_activity_status_enum']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['project_activity_status_enum']>;
  _lte?: Maybe<Scalars['project_activity_status_enum']>;
  _neq?: Maybe<Scalars['project_activity_status_enum']>;
  _nin?: Maybe<Array<Scalars['project_activity_status_enum']>>;
};

/** aggregate stddev on columns */
export type Project_Activity_Stddev_Fields = {
  __typename?: 'project_activity_stddev_fields';
  feature_limit?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "project_activity" */
export type Project_Activity_Stddev_Order_By = {
  feature_limit?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Project_Activity_Stddev_Pop_Fields = {
  __typename?: 'project_activity_stddev_pop_fields';
  feature_limit?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "project_activity" */
export type Project_Activity_Stddev_Pop_Order_By = {
  feature_limit?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Project_Activity_Stddev_Samp_Fields = {
  __typename?: 'project_activity_stddev_samp_fields';
  feature_limit?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "project_activity" */
export type Project_Activity_Stddev_Samp_Order_By = {
  feature_limit?: Maybe<Order_By>;
};

/** Streaming cursor of the table "project_activity" */
export type Project_Activity_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Activity_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Activity_Stream_Cursor_Value_Input = {
  activity_info?: Maybe<Scalars['String']>;
  activity_type?: Maybe<Scalars['String']>;
  changed_by_user_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  feature?: Maybe<Scalars['String']>;
  feature_enabled?: Maybe<Scalars['Boolean']>;
  feature_limit?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['uuid']>;
  is_feature_update?: Maybe<Scalars['Boolean']>;
  meta?: Maybe<Scalars['jsonb']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['project_activity_status_enum']>;
  /** user ID of the user to be billed for the plan/feature change */
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Project_Activity_Sum_Fields = {
  __typename?: 'project_activity_sum_fields';
  feature_limit?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "project_activity" */
export type Project_Activity_Sum_Order_By = {
  feature_limit?: Maybe<Order_By>;
};

/** update columns of table "project_activity" */
export enum Project_Activity_Update_Column {
  /** column name */
  ActivityInfo = 'activity_info',
  /** column name */
  ActivityType = 'activity_type',
  /** column name */
  ChangedByUserId = 'changed_by_user_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Feature = 'feature',
  /** column name */
  FeatureEnabled = 'feature_enabled',
  /** column name */
  FeatureLimit = 'feature_limit',
  /** column name */
  Id = 'id',
  /** column name */
  IsFeatureUpdate = 'is_feature_update',
  /** column name */
  Meta = 'meta',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Status = 'status',
  /** column name */
  UserId = 'user_id',
}

export type Project_Activity_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Project_Activity_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Project_Activity_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Project_Activity_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Project_Activity_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Activity_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Project_Activity_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Activity_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Activity_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Activity_Var_Pop_Fields = {
  __typename?: 'project_activity_var_pop_fields';
  feature_limit?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "project_activity" */
export type Project_Activity_Var_Pop_Order_By = {
  feature_limit?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Project_Activity_Var_Samp_Fields = {
  __typename?: 'project_activity_var_samp_fields';
  feature_limit?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "project_activity" */
export type Project_Activity_Var_Samp_Order_By = {
  feature_limit?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Project_Activity_Variance_Fields = {
  __typename?: 'project_activity_variance_fields';
  feature_limit?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "project_activity" */
export type Project_Activity_Variance_Order_By = {
  feature_limit?: Maybe<Order_By>;
};

/** columns and relationships of "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations = {
  __typename?: 'project_billing_manager_invitations';
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  invited_at: Scalars['timestamptz'];
  invited_by: Scalars['uuid'];
  /** An object relationship */
  invited_by_user: Users;
  /** An object relationship */
  invited_manager?: Maybe<Users>;
  key: Scalars['uuid'];
  manager_email: Scalars['String'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  resend_invitation_count: Scalars['Int'];
};

/** aggregated selection of "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Aggregate = {
  __typename?: 'project_billing_manager_invitations_aggregate';
  aggregate?: Maybe<Project_Billing_Manager_Invitations_Aggregate_Fields>;
  nodes: Array<Project_Billing_Manager_Invitations>;
};

export type Project_Billing_Manager_Invitations_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Billing_Manager_Invitations_Aggregate_Bool_Exp_Count>;
};

export type Project_Billing_Manager_Invitations_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Project_Billing_Manager_Invitations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Billing_Manager_Invitations_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Aggregate_Fields = {
  __typename?: 'project_billing_manager_invitations_aggregate_fields';
  avg?: Maybe<Project_Billing_Manager_Invitations_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Billing_Manager_Invitations_Max_Fields>;
  min?: Maybe<Project_Billing_Manager_Invitations_Min_Fields>;
  stddev?: Maybe<Project_Billing_Manager_Invitations_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Billing_Manager_Invitations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Billing_Manager_Invitations_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Billing_Manager_Invitations_Sum_Fields>;
  var_pop?: Maybe<Project_Billing_Manager_Invitations_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Billing_Manager_Invitations_Var_Samp_Fields>;
  variance?: Maybe<Project_Billing_Manager_Invitations_Variance_Fields>;
};

/** aggregate fields of "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Billing_Manager_Invitations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Aggregate_Order_By = {
  avg?: Maybe<Project_Billing_Manager_Invitations_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Billing_Manager_Invitations_Max_Order_By>;
  min?: Maybe<Project_Billing_Manager_Invitations_Min_Order_By>;
  stddev?: Maybe<Project_Billing_Manager_Invitations_Stddev_Order_By>;
  stddev_pop?: Maybe<Project_Billing_Manager_Invitations_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Project_Billing_Manager_Invitations_Stddev_Samp_Order_By>;
  sum?: Maybe<Project_Billing_Manager_Invitations_Sum_Order_By>;
  var_pop?: Maybe<Project_Billing_Manager_Invitations_Var_Pop_Order_By>;
  var_samp?: Maybe<Project_Billing_Manager_Invitations_Var_Samp_Order_By>;
  variance?: Maybe<Project_Billing_Manager_Invitations_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Arr_Rel_Insert_Input = {
  data: Array<Project_Billing_Manager_Invitations_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Billing_Manager_Invitations_On_Conflict>;
};

/** aggregate avg on columns */
export type Project_Billing_Manager_Invitations_Avg_Fields = {
  __typename?: 'project_billing_manager_invitations_avg_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Avg_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/**
 * Boolean expression to filter rows from the table
 * "project_billing_manager_invitations". All fields are combined with a logical 'AND'.
 */
export type Project_Billing_Manager_Invitations_Bool_Exp = {
  _and?: Maybe<Array<Project_Billing_Manager_Invitations_Bool_Exp>>;
  _not?: Maybe<Project_Billing_Manager_Invitations_Bool_Exp>;
  _or?: Maybe<Array<Project_Billing_Manager_Invitations_Bool_Exp>>;
  accepted_at?: Maybe<Timestamptz_Comparison_Exp>;
  declined_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  invited_at?: Maybe<Timestamptz_Comparison_Exp>;
  invited_by?: Maybe<Uuid_Comparison_Exp>;
  invited_by_user?: Maybe<Users_Bool_Exp>;
  invited_manager?: Maybe<Users_Bool_Exp>;
  key?: Maybe<Uuid_Comparison_Exp>;
  manager_email?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  resend_invitation_count?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_billing_manager_invitations" */
export enum Project_Billing_Manager_Invitations_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectBillingManagerInvitationsPkey = 'project_billing_manager_invitations_pkey',
}

/** input type for incrementing numeric columns in table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Inc_Input = {
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Insert_Input = {
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  invited_by_user?: Maybe<Users_Obj_Rel_Insert_Input>;
  invited_manager?: Maybe<Users_Obj_Rel_Insert_Input>;
  key?: Maybe<Scalars['uuid']>;
  manager_email?: Maybe<Scalars['String']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Project_Billing_Manager_Invitations_Max_Fields = {
  __typename?: 'project_billing_manager_invitations_max_fields';
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['uuid']>;
  manager_email?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Max_Order_By = {
  accepted_at?: Maybe<Order_By>;
  declined_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invited_at?: Maybe<Order_By>;
  invited_by?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  manager_email?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Billing_Manager_Invitations_Min_Fields = {
  __typename?: 'project_billing_manager_invitations_min_fields';
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['uuid']>;
  manager_email?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Min_Order_By = {
  accepted_at?: Maybe<Order_By>;
  declined_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invited_at?: Maybe<Order_By>;
  invited_by?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  manager_email?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  resend_invitation_count?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Mutation_Response = {
  __typename?: 'project_billing_manager_invitations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Billing_Manager_Invitations>;
};

/** on_conflict condition type for table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_On_Conflict = {
  constraint: Project_Billing_Manager_Invitations_Constraint;
  update_columns?: Array<Project_Billing_Manager_Invitations_Update_Column>;
  where?: Maybe<Project_Billing_Manager_Invitations_Bool_Exp>;
};

/** Ordering options when selecting data from "project_billing_manager_invitations". */
export type Project_Billing_Manager_Invitations_Order_By = {
  accepted_at?: Maybe<Order_By>;
  declined_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invited_at?: Maybe<Order_By>;
  invited_by?: Maybe<Order_By>;
  invited_by_user?: Maybe<Users_Order_By>;
  invited_manager?: Maybe<Users_Order_By>;
  key?: Maybe<Order_By>;
  manager_email?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  resend_invitation_count?: Maybe<Order_By>;
};

/** primary key columns input for table: project_billing_manager_invitations */
export type Project_Billing_Manager_Invitations_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "project_billing_manager_invitations" */
export enum Project_Billing_Manager_Invitations_Select_Column {
  /** column name */
  AcceptedAt = 'accepted_at',
  /** column name */
  DeclinedAt = 'declined_at',
  /** column name */
  Id = 'id',
  /** column name */
  InvitedAt = 'invited_at',
  /** column name */
  InvitedBy = 'invited_by',
  /** column name */
  Key = 'key',
  /** column name */
  ManagerEmail = 'manager_email',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ResendInvitationCount = 'resend_invitation_count',
}

/** input type for updating data in table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Set_Input = {
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['uuid']>;
  manager_email?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Project_Billing_Manager_Invitations_Stddev_Fields = {
  __typename?: 'project_billing_manager_invitations_stddev_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Stddev_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Project_Billing_Manager_Invitations_Stddev_Pop_Fields = {
  __typename?: 'project_billing_manager_invitations_stddev_pop_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Stddev_Pop_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Project_Billing_Manager_Invitations_Stddev_Samp_Fields = {
  __typename?: 'project_billing_manager_invitations_stddev_samp_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Stddev_Samp_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** Streaming cursor of the table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Billing_Manager_Invitations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Billing_Manager_Invitations_Stream_Cursor_Value_Input = {
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['uuid']>;
  manager_email?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Project_Billing_Manager_Invitations_Sum_Fields = {
  __typename?: 'project_billing_manager_invitations_sum_fields';
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Sum_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** update columns of table "project_billing_manager_invitations" */
export enum Project_Billing_Manager_Invitations_Update_Column {
  /** column name */
  AcceptedAt = 'accepted_at',
  /** column name */
  DeclinedAt = 'declined_at',
  /** column name */
  Id = 'id',
  /** column name */
  InvitedAt = 'invited_at',
  /** column name */
  InvitedBy = 'invited_by',
  /** column name */
  Key = 'key',
  /** column name */
  ManagerEmail = 'manager_email',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ResendInvitationCount = 'resend_invitation_count',
}

export type Project_Billing_Manager_Invitations_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Billing_Manager_Invitations_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Billing_Manager_Invitations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Billing_Manager_Invitations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Billing_Manager_Invitations_Var_Pop_Fields = {
  __typename?: 'project_billing_manager_invitations_var_pop_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Var_Pop_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Project_Billing_Manager_Invitations_Var_Samp_Fields = {
  __typename?: 'project_billing_manager_invitations_var_samp_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Var_Samp_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Project_Billing_Manager_Invitations_Variance_Fields = {
  __typename?: 'project_billing_manager_invitations_variance_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "project_billing_manager_invitations" */
export type Project_Billing_Manager_Invitations_Variance_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** Captures table access for each collaborator */
export type Project_Collaborator_Allowed_Schema_Tables = {
  __typename?: 'project_collaborator_allowed_schema_tables';
  granted_at: Scalars['timestamptz'];
  granted_by: Scalars['uuid'];
  project_collaborator_id: Scalars['uuid'];
  /** An object relationship */
  project_schema?: Maybe<Project_Collaborator_Allowed_Schemas>;
  schema: Scalars['String'];
  table_name: Scalars['String'];
};

/** aggregated selection of "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_Aggregate = {
  __typename?: 'project_collaborator_allowed_schema_tables_aggregate';
  aggregate?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Aggregate_Fields>;
  nodes: Array<Project_Collaborator_Allowed_Schema_Tables>;
};

export type Project_Collaborator_Allowed_Schema_Tables_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Aggregate_Bool_Exp_Count>;
};

export type Project_Collaborator_Allowed_Schema_Tables_Aggregate_Bool_Exp_Count =
  {
    arguments?: Maybe<
      Array<Project_Collaborator_Allowed_Schema_Tables_Select_Column>
    >;
    distinct?: Maybe<Scalars['Boolean']>;
    filter?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>;
    predicate: Int_Comparison_Exp;
  };

/** aggregate fields of "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_Aggregate_Fields = {
  __typename?: 'project_collaborator_allowed_schema_tables_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Max_Fields>;
  min?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Min_Fields>;
};

/** aggregate fields of "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_Aggregate_FieldsCountArgs =
  {
    columns?: Maybe<
      Array<Project_Collaborator_Allowed_Schema_Tables_Select_Column>
    >;
    distinct?: Maybe<Scalars['Boolean']>;
  };

/** order by aggregate values of table "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Max_Order_By>;
  min?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Min_Order_By>;
};

/** input type for inserting array relation for remote table "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_Arr_Rel_Insert_Input = {
  data: Array<Project_Collaborator_Allowed_Schema_Tables_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Collaborator_Allowed_Schema_Tables_On_Conflict>;
};

/**
 * Boolean expression to filter rows from the table
 * "project_collaborator_allowed_schema_tables". All fields are combined with a logical 'AND'.
 */
export type Project_Collaborator_Allowed_Schema_Tables_Bool_Exp = {
  _and?: Maybe<Array<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>>;
  _not?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>;
  _or?: Maybe<Array<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>>;
  granted_at?: Maybe<Timestamptz_Comparison_Exp>;
  granted_by?: Maybe<Uuid_Comparison_Exp>;
  project_collaborator_id?: Maybe<Uuid_Comparison_Exp>;
  project_schema?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
  schema?: Maybe<String_Comparison_Exp>;
  table_name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_collaborator_allowed_schema_tables" */
export enum Project_Collaborator_Allowed_Schema_Tables_Constraint {
  /** unique or primary key constraint on columns "table_name", "project_collaborator_id", "schema" */
  ProjectCollaboratorAllowedSchemaTablesPkey = 'project_collaborator_allowed_schema_tables_pkey',
}

/** input type for inserting data into table "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_Insert_Input = {
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  project_schema?: Maybe<Project_Collaborator_Allowed_Schemas_Obj_Rel_Insert_Input>;
  schema?: Maybe<Scalars['String']>;
  table_name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Project_Collaborator_Allowed_Schema_Tables_Max_Fields = {
  __typename?: 'project_collaborator_allowed_schema_tables_max_fields';
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
  table_name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_Max_Order_By = {
  granted_at?: Maybe<Order_By>;
  granted_by?: Maybe<Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
  schema?: Maybe<Order_By>;
  table_name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Collaborator_Allowed_Schema_Tables_Min_Fields = {
  __typename?: 'project_collaborator_allowed_schema_tables_min_fields';
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
  table_name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_Min_Order_By = {
  granted_at?: Maybe<Order_By>;
  granted_by?: Maybe<Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
  schema?: Maybe<Order_By>;
  table_name?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_Mutation_Response = {
  __typename?: 'project_collaborator_allowed_schema_tables_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Collaborator_Allowed_Schema_Tables>;
};

/** on_conflict condition type for table "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_On_Conflict = {
  constraint: Project_Collaborator_Allowed_Schema_Tables_Constraint;
  update_columns?: Array<Project_Collaborator_Allowed_Schema_Tables_Update_Column>;
  where?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>;
};

/** Ordering options when selecting data from "project_collaborator_allowed_schema_tables". */
export type Project_Collaborator_Allowed_Schema_Tables_Order_By = {
  granted_at?: Maybe<Order_By>;
  granted_by?: Maybe<Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
  project_schema?: Maybe<Project_Collaborator_Allowed_Schemas_Order_By>;
  schema?: Maybe<Order_By>;
  table_name?: Maybe<Order_By>;
};

/** primary key columns input for table: project_collaborator_allowed_schema_tables */
export type Project_Collaborator_Allowed_Schema_Tables_Pk_Columns_Input = {
  project_collaborator_id: Scalars['uuid'];
  schema: Scalars['String'];
  table_name: Scalars['String'];
};

/** select columns of table "project_collaborator_allowed_schema_tables" */
export enum Project_Collaborator_Allowed_Schema_Tables_Select_Column {
  /** column name */
  GrantedAt = 'granted_at',
  /** column name */
  GrantedBy = 'granted_by',
  /** column name */
  ProjectCollaboratorId = 'project_collaborator_id',
  /** column name */
  Schema = 'schema',
  /** column name */
  TableName = 'table_name',
}

/** input type for updating data in table "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_Set_Input = {
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
  table_name?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "project_collaborator_allowed_schema_tables" */
export type Project_Collaborator_Allowed_Schema_Tables_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Collaborator_Allowed_Schema_Tables_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Collaborator_Allowed_Schema_Tables_Stream_Cursor_Value_Input =
  {
    granted_at?: Maybe<Scalars['timestamptz']>;
    granted_by?: Maybe<Scalars['uuid']>;
    project_collaborator_id?: Maybe<Scalars['uuid']>;
    schema?: Maybe<Scalars['String']>;
    table_name?: Maybe<Scalars['String']>;
  };

/** update columns of table "project_collaborator_allowed_schema_tables" */
export enum Project_Collaborator_Allowed_Schema_Tables_Update_Column {
  /** column name */
  GrantedAt = 'granted_at',
  /** column name */
  GrantedBy = 'granted_by',
  /** column name */
  ProjectCollaboratorId = 'project_collaborator_id',
  /** column name */
  Schema = 'schema',
  /** column name */
  TableName = 'table_name',
}

export type Project_Collaborator_Allowed_Schema_Tables_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Collaborator_Allowed_Schema_Tables_Bool_Exp;
};

/** Captures schema access for each collaborator */
export type Project_Collaborator_Allowed_Schemas = {
  __typename?: 'project_collaborator_allowed_schemas';
  granted_at: Scalars['timestamptz'];
  granted_by: Scalars['uuid'];
  /** An object relationship */
  project_collaborator: Project_Collaborators;
  project_collaborator_id: Scalars['uuid'];
  schema: Scalars['String'];
  /** An array relationship */
  tables: Array<Project_Collaborator_Allowed_Schema_Tables>;
  /** An aggregate relationship */
  tables_aggregate: Project_Collaborator_Allowed_Schema_Tables_Aggregate;
};

/** Captures schema access for each collaborator */
export type Project_Collaborator_Allowed_SchemasTablesArgs = {
  distinct_on?: Maybe<
    Array<Project_Collaborator_Allowed_Schema_Tables_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Allowed_Schema_Tables_Order_By>>;
  where?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>;
};

/** Captures schema access for each collaborator */
export type Project_Collaborator_Allowed_SchemasTables_AggregateArgs = {
  distinct_on?: Maybe<
    Array<Project_Collaborator_Allowed_Schema_Tables_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Allowed_Schema_Tables_Order_By>>;
  where?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>;
};

/** aggregated selection of "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Aggregate = {
  __typename?: 'project_collaborator_allowed_schemas_aggregate';
  aggregate?: Maybe<Project_Collaborator_Allowed_Schemas_Aggregate_Fields>;
  nodes: Array<Project_Collaborator_Allowed_Schemas>;
};

export type Project_Collaborator_Allowed_Schemas_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Collaborator_Allowed_Schemas_Aggregate_Bool_Exp_Count>;
};

export type Project_Collaborator_Allowed_Schemas_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Project_Collaborator_Allowed_Schemas_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Aggregate_Fields = {
  __typename?: 'project_collaborator_allowed_schemas_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Project_Collaborator_Allowed_Schemas_Max_Fields>;
  min?: Maybe<Project_Collaborator_Allowed_Schemas_Min_Fields>;
};

/** aggregate fields of "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Collaborator_Allowed_Schemas_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Collaborator_Allowed_Schemas_Max_Order_By>;
  min?: Maybe<Project_Collaborator_Allowed_Schemas_Min_Order_By>;
};

/** input type for inserting array relation for remote table "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Arr_Rel_Insert_Input = {
  data: Array<Project_Collaborator_Allowed_Schemas_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Collaborator_Allowed_Schemas_On_Conflict>;
};

/**
 * Boolean expression to filter rows from the table
 * "project_collaborator_allowed_schemas". All fields are combined with a logical 'AND'.
 */
export type Project_Collaborator_Allowed_Schemas_Bool_Exp = {
  _and?: Maybe<Array<Project_Collaborator_Allowed_Schemas_Bool_Exp>>;
  _not?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
  _or?: Maybe<Array<Project_Collaborator_Allowed_Schemas_Bool_Exp>>;
  granted_at?: Maybe<Timestamptz_Comparison_Exp>;
  granted_by?: Maybe<Uuid_Comparison_Exp>;
  project_collaborator?: Maybe<Project_Collaborators_Bool_Exp>;
  project_collaborator_id?: Maybe<Uuid_Comparison_Exp>;
  schema?: Maybe<String_Comparison_Exp>;
  tables?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>;
  tables_aggregate?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "project_collaborator_allowed_schemas" */
export enum Project_Collaborator_Allowed_Schemas_Constraint {
  /** unique or primary key constraint on columns "project_collaborator_id", "schema" */
  ProjectCollaboratorAllowedSchemasPkey = 'project_collaborator_allowed_schemas_pkey',
}

/** input type for inserting data into table "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Insert_Input = {
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  project_collaborator?: Maybe<Project_Collaborators_Obj_Rel_Insert_Input>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
  tables?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Project_Collaborator_Allowed_Schemas_Max_Fields = {
  __typename?: 'project_collaborator_allowed_schemas_max_fields';
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Max_Order_By = {
  granted_at?: Maybe<Order_By>;
  granted_by?: Maybe<Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
  schema?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Collaborator_Allowed_Schemas_Min_Fields = {
  __typename?: 'project_collaborator_allowed_schemas_min_fields';
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Min_Order_By = {
  granted_at?: Maybe<Order_By>;
  granted_by?: Maybe<Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
  schema?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Mutation_Response = {
  __typename?: 'project_collaborator_allowed_schemas_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Collaborator_Allowed_Schemas>;
};

/** input type for inserting object relation for remote table "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Obj_Rel_Insert_Input = {
  data: Project_Collaborator_Allowed_Schemas_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Project_Collaborator_Allowed_Schemas_On_Conflict>;
};

/** on_conflict condition type for table "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_On_Conflict = {
  constraint: Project_Collaborator_Allowed_Schemas_Constraint;
  update_columns?: Array<Project_Collaborator_Allowed_Schemas_Update_Column>;
  where?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
};

/** Ordering options when selecting data from "project_collaborator_allowed_schemas". */
export type Project_Collaborator_Allowed_Schemas_Order_By = {
  granted_at?: Maybe<Order_By>;
  granted_by?: Maybe<Order_By>;
  project_collaborator?: Maybe<Project_Collaborators_Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
  schema?: Maybe<Order_By>;
  tables_aggregate?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Aggregate_Order_By>;
};

/** primary key columns input for table: project_collaborator_allowed_schemas */
export type Project_Collaborator_Allowed_Schemas_Pk_Columns_Input = {
  project_collaborator_id: Scalars['uuid'];
  schema: Scalars['String'];
};

/** select columns of table "project_collaborator_allowed_schemas" */
export enum Project_Collaborator_Allowed_Schemas_Select_Column {
  /** column name */
  GrantedAt = 'granted_at',
  /** column name */
  GrantedBy = 'granted_by',
  /** column name */
  ProjectCollaboratorId = 'project_collaborator_id',
  /** column name */
  Schema = 'schema',
}

/** input type for updating data in table "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Set_Input = {
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "project_collaborator_allowed_schemas" */
export type Project_Collaborator_Allowed_Schemas_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Collaborator_Allowed_Schemas_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Collaborator_Allowed_Schemas_Stream_Cursor_Value_Input = {
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  schema?: Maybe<Scalars['String']>;
};

/** update columns of table "project_collaborator_allowed_schemas" */
export enum Project_Collaborator_Allowed_Schemas_Update_Column {
  /** column name */
  GrantedAt = 'granted_at',
  /** column name */
  GrantedBy = 'granted_by',
  /** column name */
  ProjectCollaboratorId = 'project_collaborator_id',
  /** column name */
  Schema = 'schema',
}

export type Project_Collaborator_Allowed_Schemas_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Collaborator_Allowed_Schemas_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Collaborator_Allowed_Schemas_Bool_Exp;
};

/** Captures invitations to collaborate on a project */
export type Project_Collaborator_Invitations = {
  __typename?: 'project_collaborator_invitations';
  accepted_at?: Maybe<Scalars['timestamptz']>;
  collaborator_email: Scalars['citext'];
  declined_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  invited_at: Scalars['timestamptz'];
  invited_by: Scalars['uuid'];
  /** An object relationship */
  invited_by_user: Users;
  key: Scalars['String'];
  privileges?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  project: Projects;
  /** An object relationship */
  project_collaborator?: Maybe<Project_Collaborators>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  project_id: Scalars['uuid'];
  resend_invitation_count: Scalars['Int'];
};

/** Captures invitations to collaborate on a project */
export type Project_Collaborator_InvitationsPrivilegesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Aggregate = {
  __typename?: 'project_collaborator_invitations_aggregate';
  aggregate?: Maybe<Project_Collaborator_Invitations_Aggregate_Fields>;
  nodes: Array<Project_Collaborator_Invitations>;
};

export type Project_Collaborator_Invitations_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Collaborator_Invitations_Aggregate_Bool_Exp_Count>;
};

export type Project_Collaborator_Invitations_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Project_Collaborator_Invitations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Collaborator_Invitations_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Aggregate_Fields = {
  __typename?: 'project_collaborator_invitations_aggregate_fields';
  avg?: Maybe<Project_Collaborator_Invitations_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Collaborator_Invitations_Max_Fields>;
  min?: Maybe<Project_Collaborator_Invitations_Min_Fields>;
  stddev?: Maybe<Project_Collaborator_Invitations_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Collaborator_Invitations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Collaborator_Invitations_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Collaborator_Invitations_Sum_Fields>;
  var_pop?: Maybe<Project_Collaborator_Invitations_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Collaborator_Invitations_Var_Samp_Fields>;
  variance?: Maybe<Project_Collaborator_Invitations_Variance_Fields>;
};

/** aggregate fields of "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Collaborator_Invitations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Aggregate_Order_By = {
  avg?: Maybe<Project_Collaborator_Invitations_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Collaborator_Invitations_Max_Order_By>;
  min?: Maybe<Project_Collaborator_Invitations_Min_Order_By>;
  stddev?: Maybe<Project_Collaborator_Invitations_Stddev_Order_By>;
  stddev_pop?: Maybe<Project_Collaborator_Invitations_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Project_Collaborator_Invitations_Stddev_Samp_Order_By>;
  sum?: Maybe<Project_Collaborator_Invitations_Sum_Order_By>;
  var_pop?: Maybe<Project_Collaborator_Invitations_Var_Pop_Order_By>;
  var_samp?: Maybe<Project_Collaborator_Invitations_Var_Samp_Order_By>;
  variance?: Maybe<Project_Collaborator_Invitations_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Project_Collaborator_Invitations_Append_Input = {
  privileges?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Arr_Rel_Insert_Input = {
  data: Array<Project_Collaborator_Invitations_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Collaborator_Invitations_On_Conflict>;
};

/** aggregate avg on columns */
export type Project_Collaborator_Invitations_Avg_Fields = {
  __typename?: 'project_collaborator_invitations_avg_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Avg_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/**
 * Boolean expression to filter rows from the table
 * "project_collaborator_invitations". All fields are combined with a logical 'AND'.
 */
export type Project_Collaborator_Invitations_Bool_Exp = {
  _and?: Maybe<Array<Project_Collaborator_Invitations_Bool_Exp>>;
  _not?: Maybe<Project_Collaborator_Invitations_Bool_Exp>;
  _or?: Maybe<Array<Project_Collaborator_Invitations_Bool_Exp>>;
  accepted_at?: Maybe<Timestamptz_Comparison_Exp>;
  collaborator_email?: Maybe<Citext_Comparison_Exp>;
  declined_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  invited_at?: Maybe<Timestamptz_Comparison_Exp>;
  invited_by?: Maybe<Uuid_Comparison_Exp>;
  invited_by_user?: Maybe<Users_Bool_Exp>;
  key?: Maybe<String_Comparison_Exp>;
  privileges?: Maybe<Jsonb_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_collaborator?: Maybe<Project_Collaborators_Bool_Exp>;
  project_collaborator_id?: Maybe<Uuid_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  resend_invitation_count?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_collaborator_invitations" */
export enum Project_Collaborator_Invitations_Constraint {
  /** unique or primary key constraint on columns "key" */
  ProjectCollaboratorInvitationsKeyKey = 'project_collaborator_invitations_key_key',
  /** unique or primary key constraint on columns "id" */
  ProjectCollaboratorInvitationsPkey = 'project_collaborator_invitations_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Project_Collaborator_Invitations_Delete_At_Path_Input = {
  privileges?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Project_Collaborator_Invitations_Delete_Elem_Input = {
  privileges?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Project_Collaborator_Invitations_Delete_Key_Input = {
  privileges?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Inc_Input = {
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Insert_Input = {
  accepted_at?: Maybe<Scalars['timestamptz']>;
  collaborator_email?: Maybe<Scalars['citext']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  invited_by_user?: Maybe<Users_Obj_Rel_Insert_Input>;
  key?: Maybe<Scalars['String']>;
  privileges?: Maybe<Scalars['jsonb']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_collaborator?: Maybe<Project_Collaborators_Obj_Rel_Insert_Input>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Project_Collaborator_Invitations_Max_Fields = {
  __typename?: 'project_collaborator_invitations_max_fields';
  accepted_at?: Maybe<Scalars['timestamptz']>;
  collaborator_email?: Maybe<Scalars['citext']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Max_Order_By = {
  accepted_at?: Maybe<Order_By>;
  collaborator_email?: Maybe<Order_By>;
  declined_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invited_at?: Maybe<Order_By>;
  invited_by?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Collaborator_Invitations_Min_Fields = {
  __typename?: 'project_collaborator_invitations_min_fields';
  accepted_at?: Maybe<Scalars['timestamptz']>;
  collaborator_email?: Maybe<Scalars['citext']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Min_Order_By = {
  accepted_at?: Maybe<Order_By>;
  collaborator_email?: Maybe<Order_By>;
  declined_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invited_at?: Maybe<Order_By>;
  invited_by?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  resend_invitation_count?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Mutation_Response = {
  __typename?: 'project_collaborator_invitations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Collaborator_Invitations>;
};

/** on_conflict condition type for table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_On_Conflict = {
  constraint: Project_Collaborator_Invitations_Constraint;
  update_columns?: Array<Project_Collaborator_Invitations_Update_Column>;
  where?: Maybe<Project_Collaborator_Invitations_Bool_Exp>;
};

/** Ordering options when selecting data from "project_collaborator_invitations". */
export type Project_Collaborator_Invitations_Order_By = {
  accepted_at?: Maybe<Order_By>;
  collaborator_email?: Maybe<Order_By>;
  declined_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invited_at?: Maybe<Order_By>;
  invited_by?: Maybe<Order_By>;
  invited_by_user?: Maybe<Users_Order_By>;
  key?: Maybe<Order_By>;
  privileges?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_collaborator?: Maybe<Project_Collaborators_Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  resend_invitation_count?: Maybe<Order_By>;
};

/** primary key columns input for table: project_collaborator_invitations */
export type Project_Collaborator_Invitations_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Project_Collaborator_Invitations_Prepend_Input = {
  privileges?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "project_collaborator_invitations" */
export enum Project_Collaborator_Invitations_Select_Column {
  /** column name */
  AcceptedAt = 'accepted_at',
  /** column name */
  CollaboratorEmail = 'collaborator_email',
  /** column name */
  DeclinedAt = 'declined_at',
  /** column name */
  Id = 'id',
  /** column name */
  InvitedAt = 'invited_at',
  /** column name */
  InvitedBy = 'invited_by',
  /** column name */
  Key = 'key',
  /** column name */
  Privileges = 'privileges',
  /** column name */
  ProjectCollaboratorId = 'project_collaborator_id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ResendInvitationCount = 'resend_invitation_count',
}

/** input type for updating data in table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Set_Input = {
  accepted_at?: Maybe<Scalars['timestamptz']>;
  collaborator_email?: Maybe<Scalars['citext']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  privileges?: Maybe<Scalars['jsonb']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Project_Collaborator_Invitations_Stddev_Fields = {
  __typename?: 'project_collaborator_invitations_stddev_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Stddev_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Project_Collaborator_Invitations_Stddev_Pop_Fields = {
  __typename?: 'project_collaborator_invitations_stddev_pop_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Stddev_Pop_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Project_Collaborator_Invitations_Stddev_Samp_Fields = {
  __typename?: 'project_collaborator_invitations_stddev_samp_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Stddev_Samp_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** Streaming cursor of the table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Collaborator_Invitations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Collaborator_Invitations_Stream_Cursor_Value_Input = {
  accepted_at?: Maybe<Scalars['timestamptz']>;
  collaborator_email?: Maybe<Scalars['citext']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  key?: Maybe<Scalars['String']>;
  privileges?: Maybe<Scalars['jsonb']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Project_Collaborator_Invitations_Sum_Fields = {
  __typename?: 'project_collaborator_invitations_sum_fields';
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Sum_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** update columns of table "project_collaborator_invitations" */
export enum Project_Collaborator_Invitations_Update_Column {
  /** column name */
  AcceptedAt = 'accepted_at',
  /** column name */
  CollaboratorEmail = 'collaborator_email',
  /** column name */
  DeclinedAt = 'declined_at',
  /** column name */
  Id = 'id',
  /** column name */
  InvitedAt = 'invited_at',
  /** column name */
  InvitedBy = 'invited_by',
  /** column name */
  Key = 'key',
  /** column name */
  Privileges = 'privileges',
  /** column name */
  ProjectCollaboratorId = 'project_collaborator_id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ResendInvitationCount = 'resend_invitation_count',
}

export type Project_Collaborator_Invitations_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Project_Collaborator_Invitations_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Project_Collaborator_Invitations_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Project_Collaborator_Invitations_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Project_Collaborator_Invitations_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Collaborator_Invitations_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Project_Collaborator_Invitations_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Collaborator_Invitations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Collaborator_Invitations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Collaborator_Invitations_Var_Pop_Fields = {
  __typename?: 'project_collaborator_invitations_var_pop_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Var_Pop_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Project_Collaborator_Invitations_Var_Samp_Fields = {
  __typename?: 'project_collaborator_invitations_var_samp_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Var_Samp_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Project_Collaborator_Invitations_Variance_Fields = {
  __typename?: 'project_collaborator_invitations_variance_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "project_collaborator_invitations" */
export type Project_Collaborator_Invitations_Variance_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** Privileges that can be granted for collaborators of a project */
export type Project_Collaborator_Privileges = {
  __typename?: 'project_collaborator_privileges';
  granted_at: Scalars['timestamptz'];
  granted_by: Scalars['uuid'];
  privilege_slug: Scalars['String'];
  /** An object relationship */
  project_collaborator: Project_Collaborators;
  project_collaborator_id: Scalars['uuid'];
};

/** aggregated selection of "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_Aggregate = {
  __typename?: 'project_collaborator_privileges_aggregate';
  aggregate?: Maybe<Project_Collaborator_Privileges_Aggregate_Fields>;
  nodes: Array<Project_Collaborator_Privileges>;
};

export type Project_Collaborator_Privileges_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Collaborator_Privileges_Aggregate_Bool_Exp_Count>;
};

export type Project_Collaborator_Privileges_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Project_Collaborator_Privileges_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Collaborator_Privileges_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_Aggregate_Fields = {
  __typename?: 'project_collaborator_privileges_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Project_Collaborator_Privileges_Max_Fields>;
  min?: Maybe<Project_Collaborator_Privileges_Min_Fields>;
};

/** aggregate fields of "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Collaborator_Privileges_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Collaborator_Privileges_Max_Order_By>;
  min?: Maybe<Project_Collaborator_Privileges_Min_Order_By>;
};

/** input type for inserting array relation for remote table "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_Arr_Rel_Insert_Input = {
  data: Array<Project_Collaborator_Privileges_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Collaborator_Privileges_On_Conflict>;
};

/**
 * Boolean expression to filter rows from the table
 * "project_collaborator_privileges". All fields are combined with a logical 'AND'.
 */
export type Project_Collaborator_Privileges_Bool_Exp = {
  _and?: Maybe<Array<Project_Collaborator_Privileges_Bool_Exp>>;
  _not?: Maybe<Project_Collaborator_Privileges_Bool_Exp>;
  _or?: Maybe<Array<Project_Collaborator_Privileges_Bool_Exp>>;
  granted_at?: Maybe<Timestamptz_Comparison_Exp>;
  granted_by?: Maybe<Uuid_Comparison_Exp>;
  privilege_slug?: Maybe<String_Comparison_Exp>;
  project_collaborator?: Maybe<Project_Collaborators_Bool_Exp>;
  project_collaborator_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_collaborator_privileges" */
export enum Project_Collaborator_Privileges_Constraint {
  /** unique or primary key constraint on columns "project_collaborator_id", "privilege_slug" */
  ProjectCollaboratorPrivilegesPkey = 'project_collaborator_privileges_pkey',
}

/** input type for inserting data into table "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_Insert_Input = {
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  privilege_slug?: Maybe<Scalars['String']>;
  project_collaborator?: Maybe<Project_Collaborators_Obj_Rel_Insert_Input>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Project_Collaborator_Privileges_Max_Fields = {
  __typename?: 'project_collaborator_privileges_max_fields';
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  privilege_slug?: Maybe<Scalars['String']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_Max_Order_By = {
  granted_at?: Maybe<Order_By>;
  granted_by?: Maybe<Order_By>;
  privilege_slug?: Maybe<Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Collaborator_Privileges_Min_Fields = {
  __typename?: 'project_collaborator_privileges_min_fields';
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  privilege_slug?: Maybe<Scalars['String']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_Min_Order_By = {
  granted_at?: Maybe<Order_By>;
  granted_by?: Maybe<Order_By>;
  privilege_slug?: Maybe<Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_Mutation_Response = {
  __typename?: 'project_collaborator_privileges_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Collaborator_Privileges>;
};

/** on_conflict condition type for table "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_On_Conflict = {
  constraint: Project_Collaborator_Privileges_Constraint;
  update_columns?: Array<Project_Collaborator_Privileges_Update_Column>;
  where?: Maybe<Project_Collaborator_Privileges_Bool_Exp>;
};

/** Ordering options when selecting data from "project_collaborator_privileges". */
export type Project_Collaborator_Privileges_Order_By = {
  granted_at?: Maybe<Order_By>;
  granted_by?: Maybe<Order_By>;
  privilege_slug?: Maybe<Order_By>;
  project_collaborator?: Maybe<Project_Collaborators_Order_By>;
  project_collaborator_id?: Maybe<Order_By>;
};

/** primary key columns input for table: project_collaborator_privileges */
export type Project_Collaborator_Privileges_Pk_Columns_Input = {
  privilege_slug: Scalars['String'];
  project_collaborator_id: Scalars['uuid'];
};

/** select columns of table "project_collaborator_privileges" */
export enum Project_Collaborator_Privileges_Select_Column {
  /** column name */
  GrantedAt = 'granted_at',
  /** column name */
  GrantedBy = 'granted_by',
  /** column name */
  PrivilegeSlug = 'privilege_slug',
  /** column name */
  ProjectCollaboratorId = 'project_collaborator_id',
}

/** input type for updating data in table "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_Set_Input = {
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  privilege_slug?: Maybe<Scalars['String']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "project_collaborator_privileges" */
export type Project_Collaborator_Privileges_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Collaborator_Privileges_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Collaborator_Privileges_Stream_Cursor_Value_Input = {
  granted_at?: Maybe<Scalars['timestamptz']>;
  granted_by?: Maybe<Scalars['uuid']>;
  privilege_slug?: Maybe<Scalars['String']>;
  project_collaborator_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "project_collaborator_privileges" */
export enum Project_Collaborator_Privileges_Update_Column {
  /** column name */
  GrantedAt = 'granted_at',
  /** column name */
  GrantedBy = 'granted_by',
  /** column name */
  PrivilegeSlug = 'privilege_slug',
  /** column name */
  ProjectCollaboratorId = 'project_collaborator_id',
}

export type Project_Collaborator_Privileges_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Collaborator_Privileges_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Collaborator_Privileges_Bool_Exp;
};

/** Captures collaborators of a project */
export type Project_Collaborators = {
  __typename?: 'project_collaborators';
  /** An object relationship */
  collaborator?: Maybe<Users_Public>;
  collaborator_id: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  project: Projects;
  /** An array relationship */
  project_collaborator_allowed_schemas: Array<Project_Collaborator_Allowed_Schemas>;
  /** An aggregate relationship */
  project_collaborator_allowed_schemas_aggregate: Project_Collaborator_Allowed_Schemas_Aggregate;
  /** An array relationship */
  project_collaborator_privileges: Array<Project_Collaborator_Privileges>;
  /** An aggregate relationship */
  project_collaborator_privileges_aggregate: Project_Collaborator_Privileges_Aggregate;
  project_id: Scalars['uuid'];
  status: Scalars['String'];
};

/** Captures collaborators of a project */
export type Project_CollaboratorsProject_Collaborator_Allowed_SchemasArgs = {
  distinct_on?: Maybe<
    Array<Project_Collaborator_Allowed_Schemas_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Allowed_Schemas_Order_By>>;
  where?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
};

/** Captures collaborators of a project */
export type Project_CollaboratorsProject_Collaborator_Allowed_Schemas_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Project_Collaborator_Allowed_Schemas_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Collaborator_Allowed_Schemas_Order_By>>;
    where?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
  };

/** Captures collaborators of a project */
export type Project_CollaboratorsProject_Collaborator_PrivilegesArgs = {
  distinct_on?: Maybe<Array<Project_Collaborator_Privileges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Privileges_Order_By>>;
  where?: Maybe<Project_Collaborator_Privileges_Bool_Exp>;
};

/** Captures collaborators of a project */
export type Project_CollaboratorsProject_Collaborator_Privileges_AggregateArgs =
  {
    distinct_on?: Maybe<Array<Project_Collaborator_Privileges_Select_Column>>;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Collaborator_Privileges_Order_By>>;
    where?: Maybe<Project_Collaborator_Privileges_Bool_Exp>;
  };

/** aggregated selection of "project_collaborators" */
export type Project_Collaborators_Aggregate = {
  __typename?: 'project_collaborators_aggregate';
  aggregate?: Maybe<Project_Collaborators_Aggregate_Fields>;
  nodes: Array<Project_Collaborators>;
};

export type Project_Collaborators_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Collaborators_Aggregate_Bool_Exp_Count>;
};

export type Project_Collaborators_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Project_Collaborators_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Collaborators_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_collaborators" */
export type Project_Collaborators_Aggregate_Fields = {
  __typename?: 'project_collaborators_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Project_Collaborators_Max_Fields>;
  min?: Maybe<Project_Collaborators_Min_Fields>;
};

/** aggregate fields of "project_collaborators" */
export type Project_Collaborators_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Collaborators_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_collaborators" */
export type Project_Collaborators_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Collaborators_Max_Order_By>;
  min?: Maybe<Project_Collaborators_Min_Order_By>;
};

/** input type for inserting array relation for remote table "project_collaborators" */
export type Project_Collaborators_Arr_Rel_Insert_Input = {
  data: Array<Project_Collaborators_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Collaborators_On_Conflict>;
};

/** Boolean expression to filter rows from the table "project_collaborators". All fields are combined with a logical 'AND'. */
export type Project_Collaborators_Bool_Exp = {
  _and?: Maybe<Array<Project_Collaborators_Bool_Exp>>;
  _not?: Maybe<Project_Collaborators_Bool_Exp>;
  _or?: Maybe<Array<Project_Collaborators_Bool_Exp>>;
  collaborator?: Maybe<Users_Public_Bool_Exp>;
  collaborator_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_collaborator_allowed_schemas?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
  project_collaborator_allowed_schemas_aggregate?: Maybe<Project_Collaborator_Allowed_Schemas_Aggregate_Bool_Exp>;
  project_collaborator_privileges?: Maybe<Project_Collaborator_Privileges_Bool_Exp>;
  project_collaborator_privileges_aggregate?: Maybe<Project_Collaborator_Privileges_Aggregate_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_collaborators" */
export enum Project_Collaborators_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectCollaboratorsPkey = 'project_collaborators_pkey',
}

/** input type for inserting data into table "project_collaborators" */
export type Project_Collaborators_Insert_Input = {
  collaborator?: Maybe<Users_Public_Obj_Rel_Insert_Input>;
  collaborator_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_collaborator_allowed_schemas?: Maybe<Project_Collaborator_Allowed_Schemas_Arr_Rel_Insert_Input>;
  project_collaborator_privileges?: Maybe<Project_Collaborator_Privileges_Arr_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Project_Collaborators_Max_Fields = {
  __typename?: 'project_collaborators_max_fields';
  collaborator_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "project_collaborators" */
export type Project_Collaborators_Max_Order_By = {
  collaborator_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Collaborators_Min_Fields = {
  __typename?: 'project_collaborators_min_fields';
  collaborator_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "project_collaborators" */
export type Project_Collaborators_Min_Order_By = {
  collaborator_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_collaborators" */
export type Project_Collaborators_Mutation_Response = {
  __typename?: 'project_collaborators_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Collaborators>;
};

/** input type for inserting object relation for remote table "project_collaborators" */
export type Project_Collaborators_Obj_Rel_Insert_Input = {
  data: Project_Collaborators_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Project_Collaborators_On_Conflict>;
};

/** on_conflict condition type for table "project_collaborators" */
export type Project_Collaborators_On_Conflict = {
  constraint: Project_Collaborators_Constraint;
  update_columns?: Array<Project_Collaborators_Update_Column>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

/** Ordering options when selecting data from "project_collaborators". */
export type Project_Collaborators_Order_By = {
  collaborator?: Maybe<Users_Public_Order_By>;
  collaborator_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_collaborator_allowed_schemas_aggregate?: Maybe<Project_Collaborator_Allowed_Schemas_Aggregate_Order_By>;
  project_collaborator_privileges_aggregate?: Maybe<Project_Collaborator_Privileges_Aggregate_Order_By>;
  project_id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
};

/** primary key columns input for table: project_collaborators */
export type Project_Collaborators_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "project_collaborators" */
export enum Project_Collaborators_Select_Column {
  /** column name */
  CollaboratorId = 'collaborator_id',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Status = 'status',
}

/** input type for updating data in table "project_collaborators" */
export type Project_Collaborators_Set_Input = {
  collaborator_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "project_collaborators" */
export type Project_Collaborators_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Collaborators_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Collaborators_Stream_Cursor_Value_Input = {
  collaborator_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
};

/** update columns of table "project_collaborators" */
export enum Project_Collaborators_Update_Column {
  /** column name */
  CollaboratorId = 'collaborator_id',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Status = 'status',
}

export type Project_Collaborators_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Collaborators_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Collaborators_Bool_Exp;
};

/** Captures data usage of a project for billing */
export type Project_Data_Usage = {
  __typename?: 'project_data_usage';
  date: Scalars['date'];
  id: Scalars['uuid'];
  inv_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id: Scalars['uuid'];
  usage: Scalars['bigint'];
  usage_updated_at: Scalars['timestamp'];
};

/** Used as a set of table for compute_project_agg_usage function to retrieve project_ids and their aggregate usage */
export type Project_Data_Usage_Agg = {
  __typename?: 'project_data_usage_agg';
  agg_usage?: Maybe<Scalars['bigint']>;
  /** An object relationship */
  policy?: Maybe<Policies>;
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id?: Maybe<Scalars['uuid']>;
};

export type Project_Data_Usage_Agg_Aggregate = {
  __typename?: 'project_data_usage_agg_aggregate';
  aggregate?: Maybe<Project_Data_Usage_Agg_Aggregate_Fields>;
  nodes: Array<Project_Data_Usage_Agg>;
};

/** aggregate fields of "project_data_usage_agg" */
export type Project_Data_Usage_Agg_Aggregate_Fields = {
  __typename?: 'project_data_usage_agg_aggregate_fields';
  avg?: Maybe<Project_Data_Usage_Agg_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Data_Usage_Agg_Max_Fields>;
  min?: Maybe<Project_Data_Usage_Agg_Min_Fields>;
  stddev?: Maybe<Project_Data_Usage_Agg_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Data_Usage_Agg_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Data_Usage_Agg_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Data_Usage_Agg_Sum_Fields>;
  var_pop?: Maybe<Project_Data_Usage_Agg_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Data_Usage_Agg_Var_Samp_Fields>;
  variance?: Maybe<Project_Data_Usage_Agg_Variance_Fields>;
};

/** aggregate fields of "project_data_usage_agg" */
export type Project_Data_Usage_Agg_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Data_Usage_Agg_Avg_Fields = {
  __typename?: 'project_data_usage_agg_avg_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "project_data_usage_agg". All fields are combined with a logical 'AND'. */
export type Project_Data_Usage_Agg_Bool_Exp = {
  _and?: Maybe<Array<Project_Data_Usage_Agg_Bool_Exp>>;
  _not?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
  _or?: Maybe<Array<Project_Data_Usage_Agg_Bool_Exp>>;
  agg_usage?: Maybe<Bigint_Comparison_Exp>;
  policy?: Maybe<Policies_Bool_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "project_data_usage_agg" */
export type Project_Data_Usage_Agg_Inc_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "project_data_usage_agg" */
export type Project_Data_Usage_Agg_Insert_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
  policy?: Maybe<Policies_Obj_Rel_Insert_Input>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Project_Data_Usage_Agg_Max_Fields = {
  __typename?: 'project_data_usage_agg_max_fields';
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Project_Data_Usage_Agg_Min_Fields = {
  __typename?: 'project_data_usage_agg_min_fields';
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "project_data_usage_agg" */
export type Project_Data_Usage_Agg_Mutation_Response = {
  __typename?: 'project_data_usage_agg_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Data_Usage_Agg>;
};

/** Ordering options when selecting data from "project_data_usage_agg". */
export type Project_Data_Usage_Agg_Order_By = {
  agg_usage?: Maybe<Order_By>;
  policy?: Maybe<Policies_Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
};

/** select columns of table "project_data_usage_agg" */
export enum Project_Data_Usage_Agg_Select_Column {
  /** column name */
  AggUsage = 'agg_usage',
  /** column name */
  ProjectId = 'project_id',
}

/** input type for updating data in table "project_data_usage_agg" */
export type Project_Data_Usage_Agg_Set_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Project_Data_Usage_Agg_Stddev_Fields = {
  __typename?: 'project_data_usage_agg_stddev_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Data_Usage_Agg_Stddev_Pop_Fields = {
  __typename?: 'project_data_usage_agg_stddev_pop_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Data_Usage_Agg_Stddev_Samp_Fields = {
  __typename?: 'project_data_usage_agg_stddev_samp_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_data_usage_agg" */
export type Project_Data_Usage_Agg_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Data_Usage_Agg_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Data_Usage_Agg_Stream_Cursor_Value_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Project_Data_Usage_Agg_Sum_Fields = {
  __typename?: 'project_data_usage_agg_sum_fields';
  agg_usage?: Maybe<Scalars['bigint']>;
};

export type Project_Data_Usage_Agg_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Data_Usage_Agg_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Data_Usage_Agg_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Data_Usage_Agg_Bool_Exp;
};

/**
 * used as a set of table for compute_project_agg_usage_user function to retrieve
 * project_ids and their aggregate usage filtered by user_id in a particular date range
 */
export type Project_Data_Usage_Agg_User = {
  __typename?: 'project_data_usage_agg_user';
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

export type Project_Data_Usage_Agg_User_Aggregate = {
  __typename?: 'project_data_usage_agg_user_aggregate';
  aggregate?: Maybe<Project_Data_Usage_Agg_User_Aggregate_Fields>;
  nodes: Array<Project_Data_Usage_Agg_User>;
};

/** aggregate fields of "project_data_usage_agg_user" */
export type Project_Data_Usage_Agg_User_Aggregate_Fields = {
  __typename?: 'project_data_usage_agg_user_aggregate_fields';
  avg?: Maybe<Project_Data_Usage_Agg_User_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Data_Usage_Agg_User_Max_Fields>;
  min?: Maybe<Project_Data_Usage_Agg_User_Min_Fields>;
  stddev?: Maybe<Project_Data_Usage_Agg_User_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Data_Usage_Agg_User_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Data_Usage_Agg_User_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Data_Usage_Agg_User_Sum_Fields>;
  var_pop?: Maybe<Project_Data_Usage_Agg_User_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Data_Usage_Agg_User_Var_Samp_Fields>;
  variance?: Maybe<Project_Data_Usage_Agg_User_Variance_Fields>;
};

/** aggregate fields of "project_data_usage_agg_user" */
export type Project_Data_Usage_Agg_User_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Data_Usage_Agg_User_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Data_Usage_Agg_User_Avg_Fields = {
  __typename?: 'project_data_usage_agg_user_avg_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table "project_data_usage_agg_user".
 * All fields are combined with a logical 'AND'.
 */
export type Project_Data_Usage_Agg_User_Bool_Exp = {
  _and?: Maybe<Array<Project_Data_Usage_Agg_User_Bool_Exp>>;
  _not?: Maybe<Project_Data_Usage_Agg_User_Bool_Exp>;
  _or?: Maybe<Array<Project_Data_Usage_Agg_User_Bool_Exp>>;
  agg_usage?: Maybe<Bigint_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "project_data_usage_agg_user" */
export type Project_Data_Usage_Agg_User_Inc_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "project_data_usage_agg_user" */
export type Project_Data_Usage_Agg_User_Insert_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Project_Data_Usage_Agg_User_Max_Fields = {
  __typename?: 'project_data_usage_agg_user_max_fields';
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Project_Data_Usage_Agg_User_Min_Fields = {
  __typename?: 'project_data_usage_agg_user_min_fields';
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "project_data_usage_agg_user" */
export type Project_Data_Usage_Agg_User_Mutation_Response = {
  __typename?: 'project_data_usage_agg_user_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Data_Usage_Agg_User>;
};

/** Ordering options when selecting data from "project_data_usage_agg_user". */
export type Project_Data_Usage_Agg_User_Order_By = {
  agg_usage?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** select columns of table "project_data_usage_agg_user" */
export enum Project_Data_Usage_Agg_User_Select_Column {
  /** column name */
  AggUsage = 'agg_usage',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "project_data_usage_agg_user" */
export type Project_Data_Usage_Agg_User_Set_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Project_Data_Usage_Agg_User_Stddev_Fields = {
  __typename?: 'project_data_usage_agg_user_stddev_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Data_Usage_Agg_User_Stddev_Pop_Fields = {
  __typename?: 'project_data_usage_agg_user_stddev_pop_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Data_Usage_Agg_User_Stddev_Samp_Fields = {
  __typename?: 'project_data_usage_agg_user_stddev_samp_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_data_usage_agg_user" */
export type Project_Data_Usage_Agg_User_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Data_Usage_Agg_User_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Data_Usage_Agg_User_Stream_Cursor_Value_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Project_Data_Usage_Agg_User_Sum_Fields = {
  __typename?: 'project_data_usage_agg_user_sum_fields';
  agg_usage?: Maybe<Scalars['bigint']>;
};

export type Project_Data_Usage_Agg_User_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Data_Usage_Agg_User_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Data_Usage_Agg_User_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Data_Usage_Agg_User_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Data_Usage_Agg_User_Var_Pop_Fields = {
  __typename?: 'project_data_usage_agg_user_var_pop_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Data_Usage_Agg_User_Var_Samp_Fields = {
  __typename?: 'project_data_usage_agg_user_var_samp_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Data_Usage_Agg_User_Variance_Fields = {
  __typename?: 'project_data_usage_agg_user_variance_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate var_pop on columns */
export type Project_Data_Usage_Agg_Var_Pop_Fields = {
  __typename?: 'project_data_usage_agg_var_pop_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Data_Usage_Agg_Var_Samp_Fields = {
  __typename?: 'project_data_usage_agg_var_samp_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Data_Usage_Agg_Variance_Fields = {
  __typename?: 'project_data_usage_agg_variance_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregated selection of "project_data_usage" */
export type Project_Data_Usage_Aggregate = {
  __typename?: 'project_data_usage_aggregate';
  aggregate?: Maybe<Project_Data_Usage_Aggregate_Fields>;
  nodes: Array<Project_Data_Usage>;
};

export type Project_Data_Usage_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Data_Usage_Aggregate_Bool_Exp_Count>;
};

export type Project_Data_Usage_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Project_Data_Usage_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Data_Usage_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_data_usage" */
export type Project_Data_Usage_Aggregate_Fields = {
  __typename?: 'project_data_usage_aggregate_fields';
  avg?: Maybe<Project_Data_Usage_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Data_Usage_Max_Fields>;
  min?: Maybe<Project_Data_Usage_Min_Fields>;
  stddev?: Maybe<Project_Data_Usage_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Data_Usage_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Data_Usage_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Data_Usage_Sum_Fields>;
  var_pop?: Maybe<Project_Data_Usage_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Data_Usage_Var_Samp_Fields>;
  variance?: Maybe<Project_Data_Usage_Variance_Fields>;
};

/** aggregate fields of "project_data_usage" */
export type Project_Data_Usage_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Data_Usage_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_data_usage" */
export type Project_Data_Usage_Aggregate_Order_By = {
  avg?: Maybe<Project_Data_Usage_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Data_Usage_Max_Order_By>;
  min?: Maybe<Project_Data_Usage_Min_Order_By>;
  stddev?: Maybe<Project_Data_Usage_Stddev_Order_By>;
  stddev_pop?: Maybe<Project_Data_Usage_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Project_Data_Usage_Stddev_Samp_Order_By>;
  sum?: Maybe<Project_Data_Usage_Sum_Order_By>;
  var_pop?: Maybe<Project_Data_Usage_Var_Pop_Order_By>;
  var_samp?: Maybe<Project_Data_Usage_Var_Samp_Order_By>;
  variance?: Maybe<Project_Data_Usage_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "project_data_usage" */
export type Project_Data_Usage_Arr_Rel_Insert_Input = {
  data: Array<Project_Data_Usage_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Data_Usage_On_Conflict>;
};

/** aggregate avg on columns */
export type Project_Data_Usage_Avg_Fields = {
  __typename?: 'project_data_usage_avg_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "project_data_usage" */
export type Project_Data_Usage_Avg_Order_By = {
  usage?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "project_data_usage". All fields are combined with a logical 'AND'. */
export type Project_Data_Usage_Bool_Exp = {
  _and?: Maybe<Array<Project_Data_Usage_Bool_Exp>>;
  _not?: Maybe<Project_Data_Usage_Bool_Exp>;
  _or?: Maybe<Array<Project_Data_Usage_Bool_Exp>>;
  date?: Maybe<Date_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  inv_id?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  usage?: Maybe<Bigint_Comparison_Exp>;
  usage_updated_at?: Maybe<Timestamp_Comparison_Exp>;
};

/** This table captures the different components that contribute to data passthrough for projects */
export type Project_Data_Usage_Components = {
  __typename?: 'project_data_usage_components';
  date: Scalars['date'];
  hasura_action_request_bytes_total: Scalars['bigint'];
  hasura_action_response_bytes_total: Scalars['bigint'];
  hasura_event_trigger_request_bytes_total: Scalars['bigint'];
  hasura_event_trigger_response_bytes_total: Scalars['bigint'];
  hasura_http_request_bytes_total: Scalars['bigint'];
  hasura_http_response_bytes_total: Scalars['bigint'];
  hasura_scheduled_trigger_request_bytes_total: Scalars['bigint'];
  hasura_scheduled_trigger_response_bytes_total: Scalars['bigint'];
  hasura_websocket_messages_received_bytes_total: Scalars['bigint'];
  hasura_websocket_messages_sent_bytes_total: Scalars['bigint'];
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id: Scalars['uuid'];
  usage_updated_at: Scalars['timestamp'];
};

/** aggregated selection of "project_data_usage_components" */
export type Project_Data_Usage_Components_Aggregate = {
  __typename?: 'project_data_usage_components_aggregate';
  aggregate?: Maybe<Project_Data_Usage_Components_Aggregate_Fields>;
  nodes: Array<Project_Data_Usage_Components>;
};

/** aggregate fields of "project_data_usage_components" */
export type Project_Data_Usage_Components_Aggregate_Fields = {
  __typename?: 'project_data_usage_components_aggregate_fields';
  avg?: Maybe<Project_Data_Usage_Components_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Data_Usage_Components_Max_Fields>;
  min?: Maybe<Project_Data_Usage_Components_Min_Fields>;
  stddev?: Maybe<Project_Data_Usage_Components_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Data_Usage_Components_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Data_Usage_Components_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Data_Usage_Components_Sum_Fields>;
  var_pop?: Maybe<Project_Data_Usage_Components_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Data_Usage_Components_Var_Samp_Fields>;
  variance?: Maybe<Project_Data_Usage_Components_Variance_Fields>;
};

/** aggregate fields of "project_data_usage_components" */
export type Project_Data_Usage_Components_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Data_Usage_Components_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Data_Usage_Components_Avg_Fields = {
  __typename?: 'project_data_usage_components_avg_fields';
  hasura_action_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table
 * "project_data_usage_components". All fields are combined with a logical 'AND'.
 */
export type Project_Data_Usage_Components_Bool_Exp = {
  _and?: Maybe<Array<Project_Data_Usage_Components_Bool_Exp>>;
  _not?: Maybe<Project_Data_Usage_Components_Bool_Exp>;
  _or?: Maybe<Array<Project_Data_Usage_Components_Bool_Exp>>;
  date?: Maybe<Date_Comparison_Exp>;
  hasura_action_request_bytes_total?: Maybe<Bigint_Comparison_Exp>;
  hasura_action_response_bytes_total?: Maybe<Bigint_Comparison_Exp>;
  hasura_event_trigger_request_bytes_total?: Maybe<Bigint_Comparison_Exp>;
  hasura_event_trigger_response_bytes_total?: Maybe<Bigint_Comparison_Exp>;
  hasura_http_request_bytes_total?: Maybe<Bigint_Comparison_Exp>;
  hasura_http_response_bytes_total?: Maybe<Bigint_Comparison_Exp>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Bigint_Comparison_Exp>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Bigint_Comparison_Exp>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Bigint_Comparison_Exp>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Bigint_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  usage_updated_at?: Maybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_data_usage_components" */
export enum Project_Data_Usage_Components_Constraint {
  /** unique or primary key constraint on columns "date", "project_id" */
  ProjectDataUsageComponentsProjectIdDateKey = 'project_data_usage_components_project_id_date_key',
}

/** input type for incrementing numeric columns in table "project_data_usage_components" */
export type Project_Data_Usage_Components_Inc_Input = {
  hasura_action_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "project_data_usage_components" */
export type Project_Data_Usage_Components_Insert_Input = {
  date?: Maybe<Scalars['date']>;
  hasura_action_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['bigint']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Project_Data_Usage_Components_Max_Fields = {
  __typename?: 'project_data_usage_components_max_fields';
  date?: Maybe<Scalars['date']>;
  hasura_action_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type Project_Data_Usage_Components_Min_Fields = {
  __typename?: 'project_data_usage_components_min_fields';
  date?: Maybe<Scalars['date']>;
  hasura_action_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "project_data_usage_components" */
export type Project_Data_Usage_Components_Mutation_Response = {
  __typename?: 'project_data_usage_components_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Data_Usage_Components>;
};

/** input type for inserting object relation for remote table "project_data_usage_components" */
export type Project_Data_Usage_Components_Obj_Rel_Insert_Input = {
  data: Project_Data_Usage_Components_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Project_Data_Usage_Components_On_Conflict>;
};

/** on_conflict condition type for table "project_data_usage_components" */
export type Project_Data_Usage_Components_On_Conflict = {
  constraint: Project_Data_Usage_Components_Constraint;
  update_columns?: Array<Project_Data_Usage_Components_Update_Column>;
  where?: Maybe<Project_Data_Usage_Components_Bool_Exp>;
};

/** Ordering options when selecting data from "project_data_usage_components". */
export type Project_Data_Usage_Components_Order_By = {
  date?: Maybe<Order_By>;
  hasura_action_request_bytes_total?: Maybe<Order_By>;
  hasura_action_response_bytes_total?: Maybe<Order_By>;
  hasura_event_trigger_request_bytes_total?: Maybe<Order_By>;
  hasura_event_trigger_response_bytes_total?: Maybe<Order_By>;
  hasura_http_request_bytes_total?: Maybe<Order_By>;
  hasura_http_response_bytes_total?: Maybe<Order_By>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Order_By>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Order_By>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Order_By>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  usage_updated_at?: Maybe<Order_By>;
};

/** select columns of table "project_data_usage_components" */
export enum Project_Data_Usage_Components_Select_Column {
  /** column name */
  Date = 'date',
  /** column name */
  HasuraActionRequestBytesTotal = 'hasura_action_request_bytes_total',
  /** column name */
  HasuraActionResponseBytesTotal = 'hasura_action_response_bytes_total',
  /** column name */
  HasuraEventTriggerRequestBytesTotal = 'hasura_event_trigger_request_bytes_total',
  /** column name */
  HasuraEventTriggerResponseBytesTotal = 'hasura_event_trigger_response_bytes_total',
  /** column name */
  HasuraHttpRequestBytesTotal = 'hasura_http_request_bytes_total',
  /** column name */
  HasuraHttpResponseBytesTotal = 'hasura_http_response_bytes_total',
  /** column name */
  HasuraScheduledTriggerRequestBytesTotal = 'hasura_scheduled_trigger_request_bytes_total',
  /** column name */
  HasuraScheduledTriggerResponseBytesTotal = 'hasura_scheduled_trigger_response_bytes_total',
  /** column name */
  HasuraWebsocketMessagesReceivedBytesTotal = 'hasura_websocket_messages_received_bytes_total',
  /** column name */
  HasuraWebsocketMessagesSentBytesTotal = 'hasura_websocket_messages_sent_bytes_total',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UsageUpdatedAt = 'usage_updated_at',
}

/** input type for updating data in table "project_data_usage_components" */
export type Project_Data_Usage_Components_Set_Input = {
  date?: Maybe<Scalars['date']>;
  hasura_action_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Project_Data_Usage_Components_Stddev_Fields = {
  __typename?: 'project_data_usage_components_stddev_fields';
  hasura_action_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Data_Usage_Components_Stddev_Pop_Fields = {
  __typename?: 'project_data_usage_components_stddev_pop_fields';
  hasura_action_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Data_Usage_Components_Stddev_Samp_Fields = {
  __typename?: 'project_data_usage_components_stddev_samp_fields';
  hasura_action_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_data_usage_components" */
export type Project_Data_Usage_Components_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Data_Usage_Components_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Data_Usage_Components_Stream_Cursor_Value_Input = {
  date?: Maybe<Scalars['date']>;
  hasura_action_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate sum on columns */
export type Project_Data_Usage_Components_Sum_Fields = {
  __typename?: 'project_data_usage_components_sum_fields';
  hasura_action_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['bigint']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['bigint']>;
};

/** update columns of table "project_data_usage_components" */
export enum Project_Data_Usage_Components_Update_Column {
  /** column name */
  Date = 'date',
  /** column name */
  HasuraActionRequestBytesTotal = 'hasura_action_request_bytes_total',
  /** column name */
  HasuraActionResponseBytesTotal = 'hasura_action_response_bytes_total',
  /** column name */
  HasuraEventTriggerRequestBytesTotal = 'hasura_event_trigger_request_bytes_total',
  /** column name */
  HasuraEventTriggerResponseBytesTotal = 'hasura_event_trigger_response_bytes_total',
  /** column name */
  HasuraHttpRequestBytesTotal = 'hasura_http_request_bytes_total',
  /** column name */
  HasuraHttpResponseBytesTotal = 'hasura_http_response_bytes_total',
  /** column name */
  HasuraScheduledTriggerRequestBytesTotal = 'hasura_scheduled_trigger_request_bytes_total',
  /** column name */
  HasuraScheduledTriggerResponseBytesTotal = 'hasura_scheduled_trigger_response_bytes_total',
  /** column name */
  HasuraWebsocketMessagesReceivedBytesTotal = 'hasura_websocket_messages_received_bytes_total',
  /** column name */
  HasuraWebsocketMessagesSentBytesTotal = 'hasura_websocket_messages_sent_bytes_total',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UsageUpdatedAt = 'usage_updated_at',
}

export type Project_Data_Usage_Components_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Data_Usage_Components_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Data_Usage_Components_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Data_Usage_Components_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Data_Usage_Components_Var_Pop_Fields = {
  __typename?: 'project_data_usage_components_var_pop_fields';
  hasura_action_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Data_Usage_Components_Var_Samp_Fields = {
  __typename?: 'project_data_usage_components_var_samp_fields';
  hasura_action_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Data_Usage_Components_Variance_Fields = {
  __typename?: 'project_data_usage_components_variance_fields';
  hasura_action_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_action_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_event_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_http_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_request_bytes_total?: Maybe<Scalars['Float']>;
  hasura_scheduled_trigger_response_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_received_bytes_total?: Maybe<Scalars['Float']>;
  hasura_websocket_messages_sent_bytes_total?: Maybe<Scalars['Float']>;
};

/** unique or primary key constraints on table "project_data_usage" */
export enum Project_Data_Usage_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectDataUsagePkey = 'project_data_usage_pkey',
  /** unique or primary key constraint on columns "date", "project_id" */
  ProjectDataUsageProjectIdDateKey = 'project_data_usage_project_id_date_key',
}

/** input type for incrementing numeric columns in table "project_data_usage" */
export type Project_Data_Usage_Inc_Input = {
  usage?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "project_data_usage" */
export type Project_Data_Usage_Insert_Input = {
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  inv_id?: Maybe<Scalars['String']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  usage?: Maybe<Scalars['bigint']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Project_Data_Usage_Max_Fields = {
  __typename?: 'project_data_usage_max_fields';
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  inv_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage?: Maybe<Scalars['bigint']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by max() on columns of table "project_data_usage" */
export type Project_Data_Usage_Max_Order_By = {
  date?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  inv_id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  usage?: Maybe<Order_By>;
  usage_updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Data_Usage_Min_Fields = {
  __typename?: 'project_data_usage_min_fields';
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  inv_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage?: Maybe<Scalars['bigint']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by min() on columns of table "project_data_usage" */
export type Project_Data_Usage_Min_Order_By = {
  date?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  inv_id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  usage?: Maybe<Order_By>;
  usage_updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_data_usage" */
export type Project_Data_Usage_Mutation_Response = {
  __typename?: 'project_data_usage_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Data_Usage>;
};

/** on_conflict condition type for table "project_data_usage" */
export type Project_Data_Usage_On_Conflict = {
  constraint: Project_Data_Usage_Constraint;
  update_columns?: Array<Project_Data_Usage_Update_Column>;
  where?: Maybe<Project_Data_Usage_Bool_Exp>;
};

/** Ordering options when selecting data from "project_data_usage". */
export type Project_Data_Usage_Order_By = {
  date?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  inv_id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  usage?: Maybe<Order_By>;
  usage_updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: project_data_usage */
export type Project_Data_Usage_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** This table captures the data usage, for each project per day for billing, queried from Prometheus  */
export type Project_Data_Usage_Prometheus = {
  __typename?: 'project_data_usage_prometheus';
  /** An object relationship */
  data_usage_components?: Maybe<Project_Data_Usage_Components>;
  date: Scalars['date'];
  id: Scalars['uuid'];
  invoice_id?: Maybe<Scalars['String']>;
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id: Scalars['uuid'];
  usage: Scalars['bigint'];
  usage_updated_at: Scalars['timestamp'];
};

/**
 * used as a set of table for compute_project_agg_usage_prometheus_user function to
 * retrieve project_ids and their aggregate usage filtered by user_id in a
 * particular date range
 */
export type Project_Data_Usage_Prometheus_Agg_User = {
  __typename?: 'project_data_usage_prometheus_agg_user';
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

export type Project_Data_Usage_Prometheus_Agg_User_Aggregate = {
  __typename?: 'project_data_usage_prometheus_agg_user_aggregate';
  aggregate?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Aggregate_Fields>;
  nodes: Array<Project_Data_Usage_Prometheus_Agg_User>;
};

/** aggregate fields of "project_data_usage_prometheus_agg_user" */
export type Project_Data_Usage_Prometheus_Agg_User_Aggregate_Fields = {
  __typename?: 'project_data_usage_prometheus_agg_user_aggregate_fields';
  avg?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Max_Fields>;
  min?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Min_Fields>;
  stddev?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Sum_Fields>;
  var_pop?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Var_Samp_Fields>;
  variance?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Variance_Fields>;
};

/** aggregate fields of "project_data_usage_prometheus_agg_user" */
export type Project_Data_Usage_Prometheus_Agg_User_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Data_Usage_Prometheus_Agg_User_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Data_Usage_Prometheus_Agg_User_Avg_Fields = {
  __typename?: 'project_data_usage_prometheus_agg_user_avg_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table
 * "project_data_usage_prometheus_agg_user". All fields are combined with a logical 'AND'.
 */
export type Project_Data_Usage_Prometheus_Agg_User_Bool_Exp = {
  _and?: Maybe<Array<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>>;
  _not?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>;
  _or?: Maybe<Array<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>>;
  agg_usage?: Maybe<Bigint_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "project_data_usage_prometheus_agg_user" */
export type Project_Data_Usage_Prometheus_Agg_User_Inc_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "project_data_usage_prometheus_agg_user" */
export type Project_Data_Usage_Prometheus_Agg_User_Insert_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Project_Data_Usage_Prometheus_Agg_User_Max_Fields = {
  __typename?: 'project_data_usage_prometheus_agg_user_max_fields';
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Project_Data_Usage_Prometheus_Agg_User_Min_Fields = {
  __typename?: 'project_data_usage_prometheus_agg_user_min_fields';
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "project_data_usage_prometheus_agg_user" */
export type Project_Data_Usage_Prometheus_Agg_User_Mutation_Response = {
  __typename?: 'project_data_usage_prometheus_agg_user_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Data_Usage_Prometheus_Agg_User>;
};

/** Ordering options when selecting data from "project_data_usage_prometheus_agg_user". */
export type Project_Data_Usage_Prometheus_Agg_User_Order_By = {
  agg_usage?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** select columns of table "project_data_usage_prometheus_agg_user" */
export enum Project_Data_Usage_Prometheus_Agg_User_Select_Column {
  /** column name */
  AggUsage = 'agg_usage',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "project_data_usage_prometheus_agg_user" */
export type Project_Data_Usage_Prometheus_Agg_User_Set_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Project_Data_Usage_Prometheus_Agg_User_Stddev_Fields = {
  __typename?: 'project_data_usage_prometheus_agg_user_stddev_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Data_Usage_Prometheus_Agg_User_Stddev_Pop_Fields = {
  __typename?: 'project_data_usage_prometheus_agg_user_stddev_pop_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Data_Usage_Prometheus_Agg_User_Stddev_Samp_Fields = {
  __typename?: 'project_data_usage_prometheus_agg_user_stddev_samp_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_data_usage_prometheus_agg_user" */
export type Project_Data_Usage_Prometheus_Agg_User_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Data_Usage_Prometheus_Agg_User_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Data_Usage_Prometheus_Agg_User_Stream_Cursor_Value_Input = {
  agg_usage?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Project_Data_Usage_Prometheus_Agg_User_Sum_Fields = {
  __typename?: 'project_data_usage_prometheus_agg_user_sum_fields';
  agg_usage?: Maybe<Scalars['bigint']>;
};

export type Project_Data_Usage_Prometheus_Agg_User_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Data_Usage_Prometheus_Agg_User_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Data_Usage_Prometheus_Agg_User_Var_Pop_Fields = {
  __typename?: 'project_data_usage_prometheus_agg_user_var_pop_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Data_Usage_Prometheus_Agg_User_Var_Samp_Fields = {
  __typename?: 'project_data_usage_prometheus_agg_user_var_samp_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Data_Usage_Prometheus_Agg_User_Variance_Fields = {
  __typename?: 'project_data_usage_prometheus_agg_user_variance_fields';
  agg_usage?: Maybe<Scalars['Float']>;
};

/** aggregated selection of "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Aggregate = {
  __typename?: 'project_data_usage_prometheus_aggregate';
  aggregate?: Maybe<Project_Data_Usage_Prometheus_Aggregate_Fields>;
  nodes: Array<Project_Data_Usage_Prometheus>;
};

export type Project_Data_Usage_Prometheus_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Data_Usage_Prometheus_Aggregate_Bool_Exp_Count>;
};

export type Project_Data_Usage_Prometheus_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Project_Data_Usage_Prometheus_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Data_Usage_Prometheus_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Aggregate_Fields = {
  __typename?: 'project_data_usage_prometheus_aggregate_fields';
  avg?: Maybe<Project_Data_Usage_Prometheus_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Data_Usage_Prometheus_Max_Fields>;
  min?: Maybe<Project_Data_Usage_Prometheus_Min_Fields>;
  stddev?: Maybe<Project_Data_Usage_Prometheus_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Data_Usage_Prometheus_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Data_Usage_Prometheus_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Data_Usage_Prometheus_Sum_Fields>;
  var_pop?: Maybe<Project_Data_Usage_Prometheus_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Data_Usage_Prometheus_Var_Samp_Fields>;
  variance?: Maybe<Project_Data_Usage_Prometheus_Variance_Fields>;
};

/** aggregate fields of "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Data_Usage_Prometheus_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Aggregate_Order_By = {
  avg?: Maybe<Project_Data_Usage_Prometheus_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Data_Usage_Prometheus_Max_Order_By>;
  min?: Maybe<Project_Data_Usage_Prometheus_Min_Order_By>;
  stddev?: Maybe<Project_Data_Usage_Prometheus_Stddev_Order_By>;
  stddev_pop?: Maybe<Project_Data_Usage_Prometheus_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Project_Data_Usage_Prometheus_Stddev_Samp_Order_By>;
  sum?: Maybe<Project_Data_Usage_Prometheus_Sum_Order_By>;
  var_pop?: Maybe<Project_Data_Usage_Prometheus_Var_Pop_Order_By>;
  var_samp?: Maybe<Project_Data_Usage_Prometheus_Var_Samp_Order_By>;
  variance?: Maybe<Project_Data_Usage_Prometheus_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Arr_Rel_Insert_Input = {
  data: Array<Project_Data_Usage_Prometheus_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Data_Usage_Prometheus_On_Conflict>;
};

/** aggregate avg on columns */
export type Project_Data_Usage_Prometheus_Avg_Fields = {
  __typename?: 'project_data_usage_prometheus_avg_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Avg_Order_By = {
  usage?: Maybe<Order_By>;
};

/**
 * Boolean expression to filter rows from the table
 * "project_data_usage_prometheus". All fields are combined with a logical 'AND'.
 */
export type Project_Data_Usage_Prometheus_Bool_Exp = {
  _and?: Maybe<Array<Project_Data_Usage_Prometheus_Bool_Exp>>;
  _not?: Maybe<Project_Data_Usage_Prometheus_Bool_Exp>;
  _or?: Maybe<Array<Project_Data_Usage_Prometheus_Bool_Exp>>;
  data_usage_components?: Maybe<Project_Data_Usage_Components_Bool_Exp>;
  date?: Maybe<Date_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  invoice_id?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  usage?: Maybe<Bigint_Comparison_Exp>;
  usage_updated_at?: Maybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_data_usage_prometheus" */
export enum Project_Data_Usage_Prometheus_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectDataUsagePrometheusPkey = 'project_data_usage_prometheus_pkey',
  /** unique or primary key constraint on columns "date", "project_id" */
  ProjectDataUsagePrometheusProjectIdDateKey = 'project_data_usage_prometheus_project_id_date_key',
}

/** input type for incrementing numeric columns in table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Inc_Input = {
  usage?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Insert_Input = {
  data_usage_components?: Maybe<Project_Data_Usage_Components_Obj_Rel_Insert_Input>;
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  usage?: Maybe<Scalars['bigint']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Project_Data_Usage_Prometheus_Max_Fields = {
  __typename?: 'project_data_usage_prometheus_max_fields';
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage?: Maybe<Scalars['bigint']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by max() on columns of table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Max_Order_By = {
  date?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invoice_id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  usage?: Maybe<Order_By>;
  usage_updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Data_Usage_Prometheus_Min_Fields = {
  __typename?: 'project_data_usage_prometheus_min_fields';
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage?: Maybe<Scalars['bigint']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by min() on columns of table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Min_Order_By = {
  date?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invoice_id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  usage?: Maybe<Order_By>;
  usage_updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Mutation_Response = {
  __typename?: 'project_data_usage_prometheus_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Data_Usage_Prometheus>;
};

/** on_conflict condition type for table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_On_Conflict = {
  constraint: Project_Data_Usage_Prometheus_Constraint;
  update_columns?: Array<Project_Data_Usage_Prometheus_Update_Column>;
  where?: Maybe<Project_Data_Usage_Prometheus_Bool_Exp>;
};

/** Ordering options when selecting data from "project_data_usage_prometheus". */
export type Project_Data_Usage_Prometheus_Order_By = {
  data_usage_components?: Maybe<Project_Data_Usage_Components_Order_By>;
  date?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invoice_id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  usage?: Maybe<Order_By>;
  usage_updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: project_data_usage_prometheus */
export type Project_Data_Usage_Prometheus_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "project_data_usage_prometheus" */
export enum Project_Data_Usage_Prometheus_Select_Column {
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Usage = 'usage',
  /** column name */
  UsageUpdatedAt = 'usage_updated_at',
}

/** input type for updating data in table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Set_Input = {
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage?: Maybe<Scalars['bigint']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Project_Data_Usage_Prometheus_Stddev_Fields = {
  __typename?: 'project_data_usage_prometheus_stddev_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Stddev_Order_By = {
  usage?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Project_Data_Usage_Prometheus_Stddev_Pop_Fields = {
  __typename?: 'project_data_usage_prometheus_stddev_pop_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Stddev_Pop_Order_By = {
  usage?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Project_Data_Usage_Prometheus_Stddev_Samp_Fields = {
  __typename?: 'project_data_usage_prometheus_stddev_samp_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Stddev_Samp_Order_By = {
  usage?: Maybe<Order_By>;
};

/** Streaming cursor of the table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Data_Usage_Prometheus_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Data_Usage_Prometheus_Stream_Cursor_Value_Input = {
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage?: Maybe<Scalars['bigint']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate sum on columns */
export type Project_Data_Usage_Prometheus_Sum_Fields = {
  __typename?: 'project_data_usage_prometheus_sum_fields';
  usage?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Sum_Order_By = {
  usage?: Maybe<Order_By>;
};

/** update columns of table "project_data_usage_prometheus" */
export enum Project_Data_Usage_Prometheus_Update_Column {
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Usage = 'usage',
  /** column name */
  UsageUpdatedAt = 'usage_updated_at',
}

export type Project_Data_Usage_Prometheus_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Data_Usage_Prometheus_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Data_Usage_Prometheus_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Data_Usage_Prometheus_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Data_Usage_Prometheus_Var_Pop_Fields = {
  __typename?: 'project_data_usage_prometheus_var_pop_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Var_Pop_Order_By = {
  usage?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Project_Data_Usage_Prometheus_Var_Samp_Fields = {
  __typename?: 'project_data_usage_prometheus_var_samp_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Var_Samp_Order_By = {
  usage?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Project_Data_Usage_Prometheus_Variance_Fields = {
  __typename?: 'project_data_usage_prometheus_variance_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "project_data_usage_prometheus" */
export type Project_Data_Usage_Prometheus_Variance_Order_By = {
  usage?: Maybe<Order_By>;
};

/** columns and relationships of "project_data_usage_report" */
export type Project_Data_Usage_Report = {
  __typename?: 'project_data_usage_report';
  bucketname: Scalars['String'];
  created_at: Scalars['timestamptz'];
  key: Scalars['String'];
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id: Scalars['uuid'];
  report_date: Scalars['date'];
};

/** aggregated selection of "project_data_usage_report" */
export type Project_Data_Usage_Report_Aggregate = {
  __typename?: 'project_data_usage_report_aggregate';
  aggregate?: Maybe<Project_Data_Usage_Report_Aggregate_Fields>;
  nodes: Array<Project_Data_Usage_Report>;
};

export type Project_Data_Usage_Report_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Data_Usage_Report_Aggregate_Bool_Exp_Count>;
};

export type Project_Data_Usage_Report_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Project_Data_Usage_Report_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Data_Usage_Report_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_data_usage_report" */
export type Project_Data_Usage_Report_Aggregate_Fields = {
  __typename?: 'project_data_usage_report_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Project_Data_Usage_Report_Max_Fields>;
  min?: Maybe<Project_Data_Usage_Report_Min_Fields>;
};

/** aggregate fields of "project_data_usage_report" */
export type Project_Data_Usage_Report_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Data_Usage_Report_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_data_usage_report" */
export type Project_Data_Usage_Report_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Data_Usage_Report_Max_Order_By>;
  min?: Maybe<Project_Data_Usage_Report_Min_Order_By>;
};

/** input type for inserting array relation for remote table "project_data_usage_report" */
export type Project_Data_Usage_Report_Arr_Rel_Insert_Input = {
  data: Array<Project_Data_Usage_Report_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Data_Usage_Report_On_Conflict>;
};

/** Boolean expression to filter rows from the table "project_data_usage_report". All fields are combined with a logical 'AND'. */
export type Project_Data_Usage_Report_Bool_Exp = {
  _and?: Maybe<Array<Project_Data_Usage_Report_Bool_Exp>>;
  _not?: Maybe<Project_Data_Usage_Report_Bool_Exp>;
  _or?: Maybe<Array<Project_Data_Usage_Report_Bool_Exp>>;
  bucketname?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  key?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  report_date?: Maybe<Date_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_data_usage_report" */
export enum Project_Data_Usage_Report_Constraint {
  /** unique or primary key constraint on columns "project_id", "report_date" */
  ProjectDataUsageReportPkey = 'project_data_usage_report_pkey',
}

/** input type for inserting data into table "project_data_usage_report" */
export type Project_Data_Usage_Report_Insert_Input = {
  bucketname?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  report_date?: Maybe<Scalars['date']>;
};

/** aggregate max on columns */
export type Project_Data_Usage_Report_Max_Fields = {
  __typename?: 'project_data_usage_report_max_fields';
  bucketname?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  report_date?: Maybe<Scalars['date']>;
};

/** order by max() on columns of table "project_data_usage_report" */
export type Project_Data_Usage_Report_Max_Order_By = {
  bucketname?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  report_date?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Data_Usage_Report_Min_Fields = {
  __typename?: 'project_data_usage_report_min_fields';
  bucketname?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  report_date?: Maybe<Scalars['date']>;
};

/** order by min() on columns of table "project_data_usage_report" */
export type Project_Data_Usage_Report_Min_Order_By = {
  bucketname?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  report_date?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_data_usage_report" */
export type Project_Data_Usage_Report_Mutation_Response = {
  __typename?: 'project_data_usage_report_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Data_Usage_Report>;
};

/** on_conflict condition type for table "project_data_usage_report" */
export type Project_Data_Usage_Report_On_Conflict = {
  constraint: Project_Data_Usage_Report_Constraint;
  update_columns?: Array<Project_Data_Usage_Report_Update_Column>;
  where?: Maybe<Project_Data_Usage_Report_Bool_Exp>;
};

/** Ordering options when selecting data from "project_data_usage_report". */
export type Project_Data_Usage_Report_Order_By = {
  bucketname?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  report_date?: Maybe<Order_By>;
};

/** primary key columns input for table: project_data_usage_report */
export type Project_Data_Usage_Report_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
  report_date: Scalars['date'];
};

/** select columns of table "project_data_usage_report" */
export enum Project_Data_Usage_Report_Select_Column {
  /** column name */
  Bucketname = 'bucketname',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Key = 'key',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ReportDate = 'report_date',
}

/** input type for updating data in table "project_data_usage_report" */
export type Project_Data_Usage_Report_Set_Input = {
  bucketname?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  report_date?: Maybe<Scalars['date']>;
};

/** Streaming cursor of the table "project_data_usage_report" */
export type Project_Data_Usage_Report_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Data_Usage_Report_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Data_Usage_Report_Stream_Cursor_Value_Input = {
  bucketname?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  key?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  report_date?: Maybe<Scalars['date']>;
};

/** update columns of table "project_data_usage_report" */
export enum Project_Data_Usage_Report_Update_Column {
  /** column name */
  Bucketname = 'bucketname',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Key = 'key',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ReportDate = 'report_date',
}

export type Project_Data_Usage_Report_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Data_Usage_Report_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Data_Usage_Report_Bool_Exp;
};

/** select columns of table "project_data_usage" */
export enum Project_Data_Usage_Select_Column {
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  InvId = 'inv_id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Usage = 'usage',
  /** column name */
  UsageUpdatedAt = 'usage_updated_at',
}

/** input type for updating data in table "project_data_usage" */
export type Project_Data_Usage_Set_Input = {
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  inv_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage?: Maybe<Scalars['bigint']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Project_Data_Usage_Stddev_Fields = {
  __typename?: 'project_data_usage_stddev_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "project_data_usage" */
export type Project_Data_Usage_Stddev_Order_By = {
  usage?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Project_Data_Usage_Stddev_Pop_Fields = {
  __typename?: 'project_data_usage_stddev_pop_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "project_data_usage" */
export type Project_Data_Usage_Stddev_Pop_Order_By = {
  usage?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Project_Data_Usage_Stddev_Samp_Fields = {
  __typename?: 'project_data_usage_stddev_samp_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "project_data_usage" */
export type Project_Data_Usage_Stddev_Samp_Order_By = {
  usage?: Maybe<Order_By>;
};

/** Streaming cursor of the table "project_data_usage" */
export type Project_Data_Usage_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Data_Usage_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Data_Usage_Stream_Cursor_Value_Input = {
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  inv_id?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  usage?: Maybe<Scalars['bigint']>;
  usage_updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate sum on columns */
export type Project_Data_Usage_Sum_Fields = {
  __typename?: 'project_data_usage_sum_fields';
  usage?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "project_data_usage" */
export type Project_Data_Usage_Sum_Order_By = {
  usage?: Maybe<Order_By>;
};

/** update columns of table "project_data_usage" */
export enum Project_Data_Usage_Update_Column {
  /** column name */
  Date = 'date',
  /** column name */
  Id = 'id',
  /** column name */
  InvId = 'inv_id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Usage = 'usage',
  /** column name */
  UsageUpdatedAt = 'usage_updated_at',
}

export type Project_Data_Usage_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Data_Usage_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Data_Usage_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Data_Usage_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Data_Usage_Var_Pop_Fields = {
  __typename?: 'project_data_usage_var_pop_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "project_data_usage" */
export type Project_Data_Usage_Var_Pop_Order_By = {
  usage?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Project_Data_Usage_Var_Samp_Fields = {
  __typename?: 'project_data_usage_var_samp_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "project_data_usage" */
export type Project_Data_Usage_Var_Samp_Order_By = {
  usage?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Project_Data_Usage_Variance_Fields = {
  __typename?: 'project_data_usage_variance_fields';
  usage?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "project_data_usage" */
export type Project_Data_Usage_Variance_Order_By = {
  usage?: Maybe<Order_By>;
};

/** this table helps track the usage of data source for paid projects that are based on the new plans */
export type Project_Db_Usage = {
  __typename?: 'project_db_usage';
  created_at: Scalars['date'];
  id: Scalars['uuid'];
  invoice_id?: Maybe<Scalars['String']>;
  no_db_usage: Scalars['Int'];
  non_pg_usage: Scalars['Int'];
  pg_usage: Scalars['Int'];
  price: Scalars['bigint'];
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/**
 * used as a set of table for compute_project_agg_db_usage_user function to
 * retrieve project_ids and their aggregate usage filtered by user_id in a
 * particular date range
 */
export type Project_Db_Usage_Agg_User = {
  __typename?: 'project_db_usage_agg_user';
  agg_no_db_usage?: Maybe<Scalars['Int']>;
  agg_non_pg_usage?: Maybe<Scalars['Int']>;
  agg_pg_usage?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

export type Project_Db_Usage_Agg_User_Aggregate = {
  __typename?: 'project_db_usage_agg_user_aggregate';
  aggregate?: Maybe<Project_Db_Usage_Agg_User_Aggregate_Fields>;
  nodes: Array<Project_Db_Usage_Agg_User>;
};

/** aggregate fields of "project_db_usage_agg_user" */
export type Project_Db_Usage_Agg_User_Aggregate_Fields = {
  __typename?: 'project_db_usage_agg_user_aggregate_fields';
  avg?: Maybe<Project_Db_Usage_Agg_User_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Db_Usage_Agg_User_Max_Fields>;
  min?: Maybe<Project_Db_Usage_Agg_User_Min_Fields>;
  stddev?: Maybe<Project_Db_Usage_Agg_User_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Db_Usage_Agg_User_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Db_Usage_Agg_User_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Db_Usage_Agg_User_Sum_Fields>;
  var_pop?: Maybe<Project_Db_Usage_Agg_User_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Db_Usage_Agg_User_Var_Samp_Fields>;
  variance?: Maybe<Project_Db_Usage_Agg_User_Variance_Fields>;
};

/** aggregate fields of "project_db_usage_agg_user" */
export type Project_Db_Usage_Agg_User_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Db_Usage_Agg_User_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Db_Usage_Agg_User_Avg_Fields = {
  __typename?: 'project_db_usage_agg_user_avg_fields';
  agg_no_db_usage?: Maybe<Scalars['Float']>;
  agg_non_pg_usage?: Maybe<Scalars['Float']>;
  agg_pg_usage?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "project_db_usage_agg_user". All fields are combined with a logical 'AND'. */
export type Project_Db_Usage_Agg_User_Bool_Exp = {
  _and?: Maybe<Array<Project_Db_Usage_Agg_User_Bool_Exp>>;
  _not?: Maybe<Project_Db_Usage_Agg_User_Bool_Exp>;
  _or?: Maybe<Array<Project_Db_Usage_Agg_User_Bool_Exp>>;
  agg_no_db_usage?: Maybe<Int_Comparison_Exp>;
  agg_non_pg_usage?: Maybe<Int_Comparison_Exp>;
  agg_pg_usage?: Maybe<Int_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "project_db_usage_agg_user" */
export type Project_Db_Usage_Agg_User_Inc_Input = {
  agg_no_db_usage?: Maybe<Scalars['Int']>;
  agg_non_pg_usage?: Maybe<Scalars['Int']>;
  agg_pg_usage?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "project_db_usage_agg_user" */
export type Project_Db_Usage_Agg_User_Insert_Input = {
  agg_no_db_usage?: Maybe<Scalars['Int']>;
  agg_non_pg_usage?: Maybe<Scalars['Int']>;
  agg_pg_usage?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Project_Db_Usage_Agg_User_Max_Fields = {
  __typename?: 'project_db_usage_agg_user_max_fields';
  agg_no_db_usage?: Maybe<Scalars['Int']>;
  agg_non_pg_usage?: Maybe<Scalars['Int']>;
  agg_pg_usage?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Project_Db_Usage_Agg_User_Min_Fields = {
  __typename?: 'project_db_usage_agg_user_min_fields';
  agg_no_db_usage?: Maybe<Scalars['Int']>;
  agg_non_pg_usage?: Maybe<Scalars['Int']>;
  agg_pg_usage?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "project_db_usage_agg_user" */
export type Project_Db_Usage_Agg_User_Mutation_Response = {
  __typename?: 'project_db_usage_agg_user_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Db_Usage_Agg_User>;
};

/** Ordering options when selecting data from "project_db_usage_agg_user". */
export type Project_Db_Usage_Agg_User_Order_By = {
  agg_no_db_usage?: Maybe<Order_By>;
  agg_non_pg_usage?: Maybe<Order_By>;
  agg_pg_usage?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** select columns of table "project_db_usage_agg_user" */
export enum Project_Db_Usage_Agg_User_Select_Column {
  /** column name */
  AggNoDbUsage = 'agg_no_db_usage',
  /** column name */
  AggNonPgUsage = 'agg_non_pg_usage',
  /** column name */
  AggPgUsage = 'agg_pg_usage',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "project_db_usage_agg_user" */
export type Project_Db_Usage_Agg_User_Set_Input = {
  agg_no_db_usage?: Maybe<Scalars['Int']>;
  agg_non_pg_usage?: Maybe<Scalars['Int']>;
  agg_pg_usage?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Project_Db_Usage_Agg_User_Stddev_Fields = {
  __typename?: 'project_db_usage_agg_user_stddev_fields';
  agg_no_db_usage?: Maybe<Scalars['Float']>;
  agg_non_pg_usage?: Maybe<Scalars['Float']>;
  agg_pg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Db_Usage_Agg_User_Stddev_Pop_Fields = {
  __typename?: 'project_db_usage_agg_user_stddev_pop_fields';
  agg_no_db_usage?: Maybe<Scalars['Float']>;
  agg_non_pg_usage?: Maybe<Scalars['Float']>;
  agg_pg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Db_Usage_Agg_User_Stddev_Samp_Fields = {
  __typename?: 'project_db_usage_agg_user_stddev_samp_fields';
  agg_no_db_usage?: Maybe<Scalars['Float']>;
  agg_non_pg_usage?: Maybe<Scalars['Float']>;
  agg_pg_usage?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_db_usage_agg_user" */
export type Project_Db_Usage_Agg_User_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Db_Usage_Agg_User_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Db_Usage_Agg_User_Stream_Cursor_Value_Input = {
  agg_no_db_usage?: Maybe<Scalars['Int']>;
  agg_non_pg_usage?: Maybe<Scalars['Int']>;
  agg_pg_usage?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Project_Db_Usage_Agg_User_Sum_Fields = {
  __typename?: 'project_db_usage_agg_user_sum_fields';
  agg_no_db_usage?: Maybe<Scalars['Int']>;
  agg_non_pg_usage?: Maybe<Scalars['Int']>;
  agg_pg_usage?: Maybe<Scalars['Int']>;
};

export type Project_Db_Usage_Agg_User_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Db_Usage_Agg_User_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Db_Usage_Agg_User_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Db_Usage_Agg_User_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Db_Usage_Agg_User_Var_Pop_Fields = {
  __typename?: 'project_db_usage_agg_user_var_pop_fields';
  agg_no_db_usage?: Maybe<Scalars['Float']>;
  agg_non_pg_usage?: Maybe<Scalars['Float']>;
  agg_pg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Db_Usage_Agg_User_Var_Samp_Fields = {
  __typename?: 'project_db_usage_agg_user_var_samp_fields';
  agg_no_db_usage?: Maybe<Scalars['Float']>;
  agg_non_pg_usage?: Maybe<Scalars['Float']>;
  agg_pg_usage?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Db_Usage_Agg_User_Variance_Fields = {
  __typename?: 'project_db_usage_agg_user_variance_fields';
  agg_no_db_usage?: Maybe<Scalars['Float']>;
  agg_non_pg_usage?: Maybe<Scalars['Float']>;
  agg_pg_usage?: Maybe<Scalars['Float']>;
};

/** aggregated selection of "project_db_usage" */
export type Project_Db_Usage_Aggregate = {
  __typename?: 'project_db_usage_aggregate';
  aggregate?: Maybe<Project_Db_Usage_Aggregate_Fields>;
  nodes: Array<Project_Db_Usage>;
};

/** aggregate fields of "project_db_usage" */
export type Project_Db_Usage_Aggregate_Fields = {
  __typename?: 'project_db_usage_aggregate_fields';
  avg?: Maybe<Project_Db_Usage_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Db_Usage_Max_Fields>;
  min?: Maybe<Project_Db_Usage_Min_Fields>;
  stddev?: Maybe<Project_Db_Usage_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Db_Usage_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Db_Usage_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Db_Usage_Sum_Fields>;
  var_pop?: Maybe<Project_Db_Usage_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Db_Usage_Var_Samp_Fields>;
  variance?: Maybe<Project_Db_Usage_Variance_Fields>;
};

/** aggregate fields of "project_db_usage" */
export type Project_Db_Usage_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Db_Usage_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Db_Usage_Avg_Fields = {
  __typename?: 'project_db_usage_avg_fields';
  no_db_usage?: Maybe<Scalars['Float']>;
  non_pg_usage?: Maybe<Scalars['Float']>;
  pg_usage?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "project_db_usage". All fields are combined with a logical 'AND'. */
export type Project_Db_Usage_Bool_Exp = {
  _and?: Maybe<Array<Project_Db_Usage_Bool_Exp>>;
  _not?: Maybe<Project_Db_Usage_Bool_Exp>;
  _or?: Maybe<Array<Project_Db_Usage_Bool_Exp>>;
  created_at?: Maybe<Date_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  invoice_id?: Maybe<String_Comparison_Exp>;
  no_db_usage?: Maybe<Int_Comparison_Exp>;
  non_pg_usage?: Maybe<Int_Comparison_Exp>;
  pg_usage?: Maybe<Int_Comparison_Exp>;
  price?: Maybe<Bigint_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_db_usage" */
export enum Project_Db_Usage_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectDbUsagePkey = 'project_db_usage_pkey',
  /** unique or primary key constraint on columns "project_id", "created_at" */
  ProjectDbUsageProjectIdCreatedAtKey = 'project_db_usage_project_id_created_at_key',
}

/** input type for incrementing numeric columns in table "project_db_usage" */
export type Project_Db_Usage_Inc_Input = {
  no_db_usage?: Maybe<Scalars['Int']>;
  non_pg_usage?: Maybe<Scalars['Int']>;
  pg_usage?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "project_db_usage" */
export type Project_Db_Usage_Insert_Input = {
  created_at?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
  no_db_usage?: Maybe<Scalars['Int']>;
  non_pg_usage?: Maybe<Scalars['Int']>;
  pg_usage?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['bigint']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Project_Db_Usage_Max_Fields = {
  __typename?: 'project_db_usage_max_fields';
  created_at?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
  no_db_usage?: Maybe<Scalars['Int']>;
  non_pg_usage?: Maybe<Scalars['Int']>;
  pg_usage?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Project_Db_Usage_Min_Fields = {
  __typename?: 'project_db_usage_min_fields';
  created_at?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
  no_db_usage?: Maybe<Scalars['Int']>;
  non_pg_usage?: Maybe<Scalars['Int']>;
  pg_usage?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "project_db_usage" */
export type Project_Db_Usage_Mutation_Response = {
  __typename?: 'project_db_usage_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Db_Usage>;
};

/** on_conflict condition type for table "project_db_usage" */
export type Project_Db_Usage_On_Conflict = {
  constraint: Project_Db_Usage_Constraint;
  update_columns?: Array<Project_Db_Usage_Update_Column>;
  where?: Maybe<Project_Db_Usage_Bool_Exp>;
};

/** Ordering options when selecting data from "project_db_usage". */
export type Project_Db_Usage_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invoice_id?: Maybe<Order_By>;
  no_db_usage?: Maybe<Order_By>;
  non_pg_usage?: Maybe<Order_By>;
  pg_usage?: Maybe<Order_By>;
  price?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: project_db_usage */
export type Project_Db_Usage_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "project_db_usage" */
export enum Project_Db_Usage_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  NoDbUsage = 'no_db_usage',
  /** column name */
  NonPgUsage = 'non_pg_usage',
  /** column name */
  PgUsage = 'pg_usage',
  /** column name */
  Price = 'price',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "project_db_usage" */
export type Project_Db_Usage_Set_Input = {
  created_at?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
  no_db_usage?: Maybe<Scalars['Int']>;
  non_pg_usage?: Maybe<Scalars['Int']>;
  pg_usage?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Project_Db_Usage_Stddev_Fields = {
  __typename?: 'project_db_usage_stddev_fields';
  no_db_usage?: Maybe<Scalars['Float']>;
  non_pg_usage?: Maybe<Scalars['Float']>;
  pg_usage?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Db_Usage_Stddev_Pop_Fields = {
  __typename?: 'project_db_usage_stddev_pop_fields';
  no_db_usage?: Maybe<Scalars['Float']>;
  non_pg_usage?: Maybe<Scalars['Float']>;
  pg_usage?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Db_Usage_Stddev_Samp_Fields = {
  __typename?: 'project_db_usage_stddev_samp_fields';
  no_db_usage?: Maybe<Scalars['Float']>;
  non_pg_usage?: Maybe<Scalars['Float']>;
  pg_usage?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_db_usage" */
export type Project_Db_Usage_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Db_Usage_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Db_Usage_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_id?: Maybe<Scalars['String']>;
  no_db_usage?: Maybe<Scalars['Int']>;
  non_pg_usage?: Maybe<Scalars['Int']>;
  pg_usage?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['bigint']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Project_Db_Usage_Sum_Fields = {
  __typename?: 'project_db_usage_sum_fields';
  no_db_usage?: Maybe<Scalars['Int']>;
  non_pg_usage?: Maybe<Scalars['Int']>;
  pg_usage?: Maybe<Scalars['Int']>;
  price?: Maybe<Scalars['bigint']>;
};

/** update columns of table "project_db_usage" */
export enum Project_Db_Usage_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  NoDbUsage = 'no_db_usage',
  /** column name */
  NonPgUsage = 'non_pg_usage',
  /** column name */
  PgUsage = 'pg_usage',
  /** column name */
  Price = 'price',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Project_Db_Usage_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Db_Usage_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Db_Usage_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Db_Usage_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Db_Usage_Var_Pop_Fields = {
  __typename?: 'project_db_usage_var_pop_fields';
  no_db_usage?: Maybe<Scalars['Float']>;
  non_pg_usage?: Maybe<Scalars['Float']>;
  pg_usage?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Db_Usage_Var_Samp_Fields = {
  __typename?: 'project_db_usage_var_samp_fields';
  no_db_usage?: Maybe<Scalars['Float']>;
  non_pg_usage?: Maybe<Scalars['Float']>;
  pg_usage?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Db_Usage_Variance_Fields = {
  __typename?: 'project_db_usage_variance_fields';
  no_db_usage?: Maybe<Scalars['Float']>;
  non_pg_usage?: Maybe<Scalars['Float']>;
  pg_usage?: Maybe<Scalars['Float']>;
  price?: Maybe<Scalars['Float']>;
};

/**
 * Each entry in this table represents a specific project entitlement from
 * project_entitlement_catalogue that a project has access to. A project can only
 * have one version of a given type of entitlement at a time.
 */
export type Project_Entitlement_Access = {
  __typename?: 'project_entitlement_access';
  created_at: Scalars['timestamp'];
  /** An object relationship */
  entitlement: Project_Entitlement_Catalogue;
  entitlement_id: Scalars['uuid'];
  id: Scalars['uuid'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  updated_at: Scalars['timestamp'];
};

/** aggregated selection of "project_entitlement_access" */
export type Project_Entitlement_Access_Aggregate = {
  __typename?: 'project_entitlement_access_aggregate';
  aggregate?: Maybe<Project_Entitlement_Access_Aggregate_Fields>;
  nodes: Array<Project_Entitlement_Access>;
};

export type Project_Entitlement_Access_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Entitlement_Access_Aggregate_Bool_Exp_Count>;
};

export type Project_Entitlement_Access_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Project_Entitlement_Access_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Entitlement_Access_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_entitlement_access" */
export type Project_Entitlement_Access_Aggregate_Fields = {
  __typename?: 'project_entitlement_access_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Project_Entitlement_Access_Max_Fields>;
  min?: Maybe<Project_Entitlement_Access_Min_Fields>;
};

/** aggregate fields of "project_entitlement_access" */
export type Project_Entitlement_Access_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Entitlement_Access_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_entitlement_access" */
export type Project_Entitlement_Access_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Entitlement_Access_Max_Order_By>;
  min?: Maybe<Project_Entitlement_Access_Min_Order_By>;
};

/** input type for inserting array relation for remote table "project_entitlement_access" */
export type Project_Entitlement_Access_Arr_Rel_Insert_Input = {
  data: Array<Project_Entitlement_Access_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Entitlement_Access_On_Conflict>;
};

/** Boolean expression to filter rows from the table "project_entitlement_access". All fields are combined with a logical 'AND'. */
export type Project_Entitlement_Access_Bool_Exp = {
  _and?: Maybe<Array<Project_Entitlement_Access_Bool_Exp>>;
  _not?: Maybe<Project_Entitlement_Access_Bool_Exp>;
  _or?: Maybe<Array<Project_Entitlement_Access_Bool_Exp>>;
  created_at?: Maybe<Timestamp_Comparison_Exp>;
  entitlement?: Maybe<Project_Entitlement_Catalogue_Bool_Exp>;
  entitlement_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_entitlement_access" */
export enum Project_Entitlement_Access_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectEntitlementAccessPkey = 'project_entitlement_access_pkey',
}

/** input type for inserting data into table "project_entitlement_access" */
export type Project_Entitlement_Access_Insert_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement?: Maybe<Project_Entitlement_Catalogue_Obj_Rel_Insert_Input>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Project_Entitlement_Access_Max_Fields = {
  __typename?: 'project_entitlement_access_max_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by max() on columns of table "project_entitlement_access" */
export type Project_Entitlement_Access_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Entitlement_Access_Min_Fields = {
  __typename?: 'project_entitlement_access_min_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by min() on columns of table "project_entitlement_access" */
export type Project_Entitlement_Access_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_entitlement_access" */
export type Project_Entitlement_Access_Mutation_Response = {
  __typename?: 'project_entitlement_access_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Entitlement_Access>;
};

/** on_conflict condition type for table "project_entitlement_access" */
export type Project_Entitlement_Access_On_Conflict = {
  constraint: Project_Entitlement_Access_Constraint;
  update_columns?: Array<Project_Entitlement_Access_Update_Column>;
  where?: Maybe<Project_Entitlement_Access_Bool_Exp>;
};

/** Ordering options when selecting data from "project_entitlement_access". */
export type Project_Entitlement_Access_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement?: Maybe<Project_Entitlement_Catalogue_Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: project_entitlement_access */
export type Project_Entitlement_Access_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "project_entitlement_access" */
export enum Project_Entitlement_Access_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntitlementId = 'entitlement_id',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "project_entitlement_access" */
export type Project_Entitlement_Access_Set_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** Streaming cursor of the table "project_entitlement_access" */
export type Project_Entitlement_Access_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Entitlement_Access_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Entitlement_Access_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** update columns of table "project_entitlement_access" */
export enum Project_Entitlement_Access_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntitlementId = 'entitlement_id',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Project_Entitlement_Access_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Entitlement_Access_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Entitlement_Access_Bool_Exp;
};

/** Stores all versions of all types of entitlements. */
export type Project_Entitlement_Catalogue = {
  __typename?: 'project_entitlement_catalogue';
  config_is_enabled: Scalars['Boolean'];
  config_limit?: Maybe<Scalars['bigint']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at: Scalars['timestamp'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  type: Project_Entitlement_Types_Enum;
  updated_at: Scalars['timestamp'];
};

/** aggregated selection of "project_entitlement_catalogue" */
export type Project_Entitlement_Catalogue_Aggregate = {
  __typename?: 'project_entitlement_catalogue_aggregate';
  aggregate?: Maybe<Project_Entitlement_Catalogue_Aggregate_Fields>;
  nodes: Array<Project_Entitlement_Catalogue>;
};

/** aggregate fields of "project_entitlement_catalogue" */
export type Project_Entitlement_Catalogue_Aggregate_Fields = {
  __typename?: 'project_entitlement_catalogue_aggregate_fields';
  avg?: Maybe<Project_Entitlement_Catalogue_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Entitlement_Catalogue_Max_Fields>;
  min?: Maybe<Project_Entitlement_Catalogue_Min_Fields>;
  stddev?: Maybe<Project_Entitlement_Catalogue_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Entitlement_Catalogue_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Entitlement_Catalogue_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Entitlement_Catalogue_Sum_Fields>;
  var_pop?: Maybe<Project_Entitlement_Catalogue_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Entitlement_Catalogue_Var_Samp_Fields>;
  variance?: Maybe<Project_Entitlement_Catalogue_Variance_Fields>;
};

/** aggregate fields of "project_entitlement_catalogue" */
export type Project_Entitlement_Catalogue_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Entitlement_Catalogue_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Entitlement_Catalogue_Avg_Fields = {
  __typename?: 'project_entitlement_catalogue_avg_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table
 * "project_entitlement_catalogue". All fields are combined with a logical 'AND'.
 */
export type Project_Entitlement_Catalogue_Bool_Exp = {
  _and?: Maybe<Array<Project_Entitlement_Catalogue_Bool_Exp>>;
  _not?: Maybe<Project_Entitlement_Catalogue_Bool_Exp>;
  _or?: Maybe<Array<Project_Entitlement_Catalogue_Bool_Exp>>;
  config_is_enabled?: Maybe<Boolean_Comparison_Exp>;
  config_limit?: Maybe<Bigint_Comparison_Exp>;
  cost?: Maybe<Bigint_Comparison_Exp>;
  created_at?: Maybe<Timestamp_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  type?: Maybe<Project_Entitlement_Types_Enum_Comparison_Exp>;
  updated_at?: Maybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_entitlement_catalogue" */
export enum Project_Entitlement_Catalogue_Constraint {
  /** unique or primary key constraint on columns "name" */
  ProjectEntitlementCatalogueNameKey = 'project_entitlement_catalogue_name_key',
  /** unique or primary key constraint on columns "id" */
  ProjectEntitlementCataloguePkey = 'project_entitlement_catalogue_pkey',
}

/** input type for incrementing numeric columns in table "project_entitlement_catalogue" */
export type Project_Entitlement_Catalogue_Inc_Input = {
  config_limit?: Maybe<Scalars['bigint']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "project_entitlement_catalogue" */
export type Project_Entitlement_Catalogue_Insert_Input = {
  config_is_enabled?: Maybe<Scalars['Boolean']>;
  config_limit?: Maybe<Scalars['bigint']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Project_Entitlement_Types_Enum>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Project_Entitlement_Catalogue_Max_Fields = {
  __typename?: 'project_entitlement_catalogue_max_fields';
  config_limit?: Maybe<Scalars['bigint']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type Project_Entitlement_Catalogue_Min_Fields = {
  __typename?: 'project_entitlement_catalogue_min_fields';
  config_limit?: Maybe<Scalars['bigint']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "project_entitlement_catalogue" */
export type Project_Entitlement_Catalogue_Mutation_Response = {
  __typename?: 'project_entitlement_catalogue_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Entitlement_Catalogue>;
};

/** input type for inserting object relation for remote table "project_entitlement_catalogue" */
export type Project_Entitlement_Catalogue_Obj_Rel_Insert_Input = {
  data: Project_Entitlement_Catalogue_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Project_Entitlement_Catalogue_On_Conflict>;
};

/** on_conflict condition type for table "project_entitlement_catalogue" */
export type Project_Entitlement_Catalogue_On_Conflict = {
  constraint: Project_Entitlement_Catalogue_Constraint;
  update_columns?: Array<Project_Entitlement_Catalogue_Update_Column>;
  where?: Maybe<Project_Entitlement_Catalogue_Bool_Exp>;
};

/** Ordering options when selecting data from "project_entitlement_catalogue". */
export type Project_Entitlement_Catalogue_Order_By = {
  config_is_enabled?: Maybe<Order_By>;
  config_limit?: Maybe<Order_By>;
  cost?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: project_entitlement_catalogue */
export type Project_Entitlement_Catalogue_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "project_entitlement_catalogue" */
export enum Project_Entitlement_Catalogue_Select_Column {
  /** column name */
  ConfigIsEnabled = 'config_is_enabled',
  /** column name */
  ConfigLimit = 'config_limit',
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "project_entitlement_catalogue" */
export type Project_Entitlement_Catalogue_Set_Input = {
  config_is_enabled?: Maybe<Scalars['Boolean']>;
  config_limit?: Maybe<Scalars['bigint']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Project_Entitlement_Types_Enum>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Project_Entitlement_Catalogue_Stddev_Fields = {
  __typename?: 'project_entitlement_catalogue_stddev_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Entitlement_Catalogue_Stddev_Pop_Fields = {
  __typename?: 'project_entitlement_catalogue_stddev_pop_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Entitlement_Catalogue_Stddev_Samp_Fields = {
  __typename?: 'project_entitlement_catalogue_stddev_samp_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_entitlement_catalogue" */
export type Project_Entitlement_Catalogue_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Entitlement_Catalogue_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Entitlement_Catalogue_Stream_Cursor_Value_Input = {
  config_is_enabled?: Maybe<Scalars['Boolean']>;
  config_limit?: Maybe<Scalars['bigint']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<Project_Entitlement_Types_Enum>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate sum on columns */
export type Project_Entitlement_Catalogue_Sum_Fields = {
  __typename?: 'project_entitlement_catalogue_sum_fields';
  config_limit?: Maybe<Scalars['bigint']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
};

/** update columns of table "project_entitlement_catalogue" */
export enum Project_Entitlement_Catalogue_Update_Column {
  /** column name */
  ConfigIsEnabled = 'config_is_enabled',
  /** column name */
  ConfigLimit = 'config_limit',
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Project_Entitlement_Catalogue_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Entitlement_Catalogue_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Entitlement_Catalogue_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Entitlement_Catalogue_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Entitlement_Catalogue_Var_Pop_Fields = {
  __typename?: 'project_entitlement_catalogue_var_pop_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Entitlement_Catalogue_Var_Samp_Fields = {
  __typename?: 'project_entitlement_catalogue_var_samp_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Entitlement_Catalogue_Variance_Fields = {
  __typename?: 'project_entitlement_catalogue_variance_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** Enums to represent all types of entitlements a project can have. */
export type Project_Entitlement_Types = {
  __typename?: 'project_entitlement_types';
  comment: Scalars['String'];
  value: Scalars['String'];
};

/** aggregated selection of "project_entitlement_types" */
export type Project_Entitlement_Types_Aggregate = {
  __typename?: 'project_entitlement_types_aggregate';
  aggregate?: Maybe<Project_Entitlement_Types_Aggregate_Fields>;
  nodes: Array<Project_Entitlement_Types>;
};

/** aggregate fields of "project_entitlement_types" */
export type Project_Entitlement_Types_Aggregate_Fields = {
  __typename?: 'project_entitlement_types_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Project_Entitlement_Types_Max_Fields>;
  min?: Maybe<Project_Entitlement_Types_Min_Fields>;
};

/** aggregate fields of "project_entitlement_types" */
export type Project_Entitlement_Types_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Entitlement_Types_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "project_entitlement_types". All fields are combined with a logical 'AND'. */
export type Project_Entitlement_Types_Bool_Exp = {
  _and?: Maybe<Array<Project_Entitlement_Types_Bool_Exp>>;
  _not?: Maybe<Project_Entitlement_Types_Bool_Exp>;
  _or?: Maybe<Array<Project_Entitlement_Types_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_entitlement_types" */
export enum Project_Entitlement_Types_Constraint {
  /** unique or primary key constraint on columns "value" */
  ProjectEntitlementTypesPkey = 'project_entitlement_types_pkey',
}

export enum Project_Entitlement_Types_Enum {
  /** Azure Monitor APM integration: export a project's logs and metrics to Azure Monitor. */
  ApmIntegrationAzuremonitor = 'apm_integration_azuremonitor',
  /** Datadog APM integration: export a project's logs and metrics to Datadog. */
  ApmIntegrationDatadog = 'apm_integration_datadog',
  /** New Relic APM integration: export a project's logs and metrics to New Relic. */
  ApmIntegrationNewrelic = 'apm_integration_newrelic',
  /** Opentelemetry APM integration: export a project's logs and metrics to Opentelemetry. */
  ApmIntegrationOpentelemetry = 'apm_integration_opentelemetry',
  /** Prometheus APM integration: provides an endpoint to fetch project's metrics for ingestion into Prometheus server. */
  ApmIntegrationPrometheus = 'apm_integration_prometheus',
  /** Maximum number of collaborators that can be added to a project */
  CollaboratorLimit = 'collaborator_limit',
  /** Allow to add a collaborator to the project with admin privilege. */
  CollaboratorPrivilegeAdmin = 'collaborator_privilege_admin',
  /** Allow to add a collaborator to the project with graphql_admin privilege. */
  CollaboratorPrivilegeGraphqlAdmin = 'collaborator_privilege_graphql_admin',
  /** Allow to add a collaborator to the project with view_metrics privilege. */
  CollaboratorPrivilegeViewMetrics = 'collaborator_privilege_view_metrics',
  /** Configure access to the metrics tab on the project's HGE console. */
  ConsoleMetricsTab = 'console_metrics_tab',
  /** Configure custom domains for projects. */
  CustomDomainLimit = 'custom_domain_limit',
  /** Maximum amount of data passthrough allowed for a project per month. Unit is bytes. */
  DataPassthroughLimit = 'data_passthrough_limit',
  /** Maximum number of databases that can be connected to a project */
  DbLimit = 'db_limit',
  /** Configure Graphql allow lists for a project */
  GqlAllowLists = 'gql_allow_lists',
  /** Configure multiple admin secrets for a project */
  MultipleAdminSecrets = 'multiple_admin_secrets',
  /** Configure multiple JWT secrets for a project */
  MultipleJwt = 'multiple_jwt',
  /** Cost per hour if the project is not connected to any database. */
  NoDb = 'no_db',
  /** Cost and access to connecting a non Postgres databases to a project. */
  NonPgDb = 'non_pg_db',
  /** Configure access and limit for read replicas */
  ReadReplicas = 'read_replicas',
  /** Move a project between cloud host regions */
  RegionMigration = 'region_migration',
  /** Configure access to the metrics endpoint on tenant */
  ServerMetricsEndpoint = 'server_metrics_endpoint',
  /** Cost and access to connecting a Vanilla Postgres databases to a project. */
  VanillaPgDb = 'vanilla_pg_db',
}

/** Boolean expression to compare columns of type "project_entitlement_types_enum". All fields are combined with logical 'AND'. */
export type Project_Entitlement_Types_Enum_Comparison_Exp = {
  _eq?: Maybe<Project_Entitlement_Types_Enum>;
  _in?: Maybe<Array<Project_Entitlement_Types_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Project_Entitlement_Types_Enum>;
  _nin?: Maybe<Array<Project_Entitlement_Types_Enum>>;
};

/** input type for inserting data into table "project_entitlement_types" */
export type Project_Entitlement_Types_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Project_Entitlement_Types_Max_Fields = {
  __typename?: 'project_entitlement_types_max_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Project_Entitlement_Types_Min_Fields = {
  __typename?: 'project_entitlement_types_min_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "project_entitlement_types" */
export type Project_Entitlement_Types_Mutation_Response = {
  __typename?: 'project_entitlement_types_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Entitlement_Types>;
};

/** on_conflict condition type for table "project_entitlement_types" */
export type Project_Entitlement_Types_On_Conflict = {
  constraint: Project_Entitlement_Types_Constraint;
  update_columns?: Array<Project_Entitlement_Types_Update_Column>;
  where?: Maybe<Project_Entitlement_Types_Bool_Exp>;
};

/** Ordering options when selecting data from "project_entitlement_types". */
export type Project_Entitlement_Types_Order_By = {
  comment?: Maybe<Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: project_entitlement_types */
export type Project_Entitlement_Types_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "project_entitlement_types" */
export enum Project_Entitlement_Types_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value',
}

/** input type for updating data in table "project_entitlement_types" */
export type Project_Entitlement_Types_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "project_entitlement_types" */
export type Project_Entitlement_Types_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Entitlement_Types_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Entitlement_Types_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "project_entitlement_types" */
export enum Project_Entitlement_Types_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value',
}

export type Project_Entitlement_Types_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Entitlement_Types_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Entitlement_Types_Bool_Exp;
};

/** Labels that can be created per project */
export type Project_Labels = {
  __typename?: 'project_labels';
  added_at: Scalars['timetz'];
  /** An object relationship */
  label: Label;
  label_id: Scalars['uuid'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
};

/** aggregated selection of "project_labels" */
export type Project_Labels_Aggregate = {
  __typename?: 'project_labels_aggregate';
  aggregate?: Maybe<Project_Labels_Aggregate_Fields>;
  nodes: Array<Project_Labels>;
};

export type Project_Labels_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Labels_Aggregate_Bool_Exp_Count>;
};

export type Project_Labels_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Project_Labels_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Labels_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_labels" */
export type Project_Labels_Aggregate_Fields = {
  __typename?: 'project_labels_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Project_Labels_Max_Fields>;
  min?: Maybe<Project_Labels_Min_Fields>;
};

/** aggregate fields of "project_labels" */
export type Project_Labels_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Labels_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_labels" */
export type Project_Labels_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Labels_Max_Order_By>;
  min?: Maybe<Project_Labels_Min_Order_By>;
};

/** input type for inserting array relation for remote table "project_labels" */
export type Project_Labels_Arr_Rel_Insert_Input = {
  data: Array<Project_Labels_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Labels_On_Conflict>;
};

/** Boolean expression to filter rows from the table "project_labels". All fields are combined with a logical 'AND'. */
export type Project_Labels_Bool_Exp = {
  _and?: Maybe<Array<Project_Labels_Bool_Exp>>;
  _not?: Maybe<Project_Labels_Bool_Exp>;
  _or?: Maybe<Array<Project_Labels_Bool_Exp>>;
  added_at?: Maybe<Timetz_Comparison_Exp>;
  label?: Maybe<Label_Bool_Exp>;
  label_id?: Maybe<Uuid_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_labels" */
export enum Project_Labels_Constraint {
  /** unique or primary key constraint on columns "label_id", "project_id" */
  ProjectTagsPkey = 'project_tags_pkey',
}

/** input type for inserting data into table "project_labels" */
export type Project_Labels_Insert_Input = {
  added_at?: Maybe<Scalars['timetz']>;
  label?: Maybe<Label_Obj_Rel_Insert_Input>;
  label_id?: Maybe<Scalars['uuid']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Project_Labels_Max_Fields = {
  __typename?: 'project_labels_max_fields';
  added_at?: Maybe<Scalars['timetz']>;
  label_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "project_labels" */
export type Project_Labels_Max_Order_By = {
  added_at?: Maybe<Order_By>;
  label_id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Labels_Min_Fields = {
  __typename?: 'project_labels_min_fields';
  added_at?: Maybe<Scalars['timetz']>;
  label_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "project_labels" */
export type Project_Labels_Min_Order_By = {
  added_at?: Maybe<Order_By>;
  label_id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_labels" */
export type Project_Labels_Mutation_Response = {
  __typename?: 'project_labels_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Labels>;
};

/** on_conflict condition type for table "project_labels" */
export type Project_Labels_On_Conflict = {
  constraint: Project_Labels_Constraint;
  update_columns?: Array<Project_Labels_Update_Column>;
  where?: Maybe<Project_Labels_Bool_Exp>;
};

/** Ordering options when selecting data from "project_labels". */
export type Project_Labels_Order_By = {
  added_at?: Maybe<Order_By>;
  label?: Maybe<Label_Order_By>;
  label_id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
};

/** primary key columns input for table: project_labels */
export type Project_Labels_Pk_Columns_Input = {
  label_id: Scalars['uuid'];
  project_id: Scalars['uuid'];
};

/** select columns of table "project_labels" */
export enum Project_Labels_Select_Column {
  /** column name */
  AddedAt = 'added_at',
  /** column name */
  LabelId = 'label_id',
  /** column name */
  ProjectId = 'project_id',
}

/** input type for updating data in table "project_labels" */
export type Project_Labels_Set_Input = {
  added_at?: Maybe<Scalars['timetz']>;
  label_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "project_labels" */
export type Project_Labels_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Labels_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Labels_Stream_Cursor_Value_Input = {
  added_at?: Maybe<Scalars['timetz']>;
  label_id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "project_labels" */
export enum Project_Labels_Update_Column {
  /** column name */
  AddedAt = 'added_at',
  /** column name */
  LabelId = 'label_id',
  /** column name */
  ProjectId = 'project_id',
}

export type Project_Labels_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Labels_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Labels_Bool_Exp;
};

/** Metadata of a project (e.g. Heroku app connection) */
export type Project_Metadata = {
  __typename?: 'project_metadata';
  connected_heroku_app_name?: Maybe<Scalars['String']>;
  environment_color?: Maybe<Scalars['String']>;
  environment_name?: Maybe<Scalars['String']>;
  heroku_managed_mode: Scalars['Boolean'];
  metrics_flags?: Maybe<Scalars['_text']>;
  num_read_replicas: Scalars['Int'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  webhook_id?: Maybe<Scalars['String']>;
};

/** aggregated selection of "project_metadata" */
export type Project_Metadata_Aggregate = {
  __typename?: 'project_metadata_aggregate';
  aggregate?: Maybe<Project_Metadata_Aggregate_Fields>;
  nodes: Array<Project_Metadata>;
};

/** aggregate fields of "project_metadata" */
export type Project_Metadata_Aggregate_Fields = {
  __typename?: 'project_metadata_aggregate_fields';
  avg?: Maybe<Project_Metadata_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Metadata_Max_Fields>;
  min?: Maybe<Project_Metadata_Min_Fields>;
  stddev?: Maybe<Project_Metadata_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Metadata_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Metadata_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Metadata_Sum_Fields>;
  var_pop?: Maybe<Project_Metadata_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Metadata_Var_Samp_Fields>;
  variance?: Maybe<Project_Metadata_Variance_Fields>;
};

/** aggregate fields of "project_metadata" */
export type Project_Metadata_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Metadata_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Metadata_Avg_Fields = {
  __typename?: 'project_metadata_avg_fields';
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "project_metadata". All fields are combined with a logical 'AND'. */
export type Project_Metadata_Bool_Exp = {
  _and?: Maybe<Array<Project_Metadata_Bool_Exp>>;
  _not?: Maybe<Project_Metadata_Bool_Exp>;
  _or?: Maybe<Array<Project_Metadata_Bool_Exp>>;
  connected_heroku_app_name?: Maybe<String_Comparison_Exp>;
  environment_color?: Maybe<String_Comparison_Exp>;
  environment_name?: Maybe<String_Comparison_Exp>;
  heroku_managed_mode?: Maybe<Boolean_Comparison_Exp>;
  metrics_flags?: Maybe<_Text_Comparison_Exp>;
  num_read_replicas?: Maybe<Int_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  webhook_id?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_metadata" */
export enum Project_Metadata_Constraint {
  /** unique or primary key constraint on columns "project_id" */
  ProjectMetadataPkey = 'project_metadata_pkey',
}

/** input type for incrementing numeric columns in table "project_metadata" */
export type Project_Metadata_Inc_Input = {
  num_read_replicas?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "project_metadata" */
export type Project_Metadata_Insert_Input = {
  connected_heroku_app_name?: Maybe<Scalars['String']>;
  environment_color?: Maybe<Scalars['String']>;
  environment_name?: Maybe<Scalars['String']>;
  heroku_managed_mode?: Maybe<Scalars['Boolean']>;
  metrics_flags?: Maybe<Scalars['_text']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  webhook_id?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Project_Metadata_Max_Fields = {
  __typename?: 'project_metadata_max_fields';
  connected_heroku_app_name?: Maybe<Scalars['String']>;
  environment_color?: Maybe<Scalars['String']>;
  environment_name?: Maybe<Scalars['String']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  webhook_id?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Project_Metadata_Min_Fields = {
  __typename?: 'project_metadata_min_fields';
  connected_heroku_app_name?: Maybe<Scalars['String']>;
  environment_color?: Maybe<Scalars['String']>;
  environment_name?: Maybe<Scalars['String']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  webhook_id?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "project_metadata" */
export type Project_Metadata_Mutation_Response = {
  __typename?: 'project_metadata_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Metadata>;
};

/** input type for inserting object relation for remote table "project_metadata" */
export type Project_Metadata_Obj_Rel_Insert_Input = {
  data: Project_Metadata_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Project_Metadata_On_Conflict>;
};

/** on_conflict condition type for table "project_metadata" */
export type Project_Metadata_On_Conflict = {
  constraint: Project_Metadata_Constraint;
  update_columns?: Array<Project_Metadata_Update_Column>;
  where?: Maybe<Project_Metadata_Bool_Exp>;
};

/** Ordering options when selecting data from "project_metadata". */
export type Project_Metadata_Order_By = {
  connected_heroku_app_name?: Maybe<Order_By>;
  environment_color?: Maybe<Order_By>;
  environment_name?: Maybe<Order_By>;
  heroku_managed_mode?: Maybe<Order_By>;
  metrics_flags?: Maybe<Order_By>;
  num_read_replicas?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  webhook_id?: Maybe<Order_By>;
};

/** primary key columns input for table: project_metadata */
export type Project_Metadata_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
};

/** select columns of table "project_metadata" */
export enum Project_Metadata_Select_Column {
  /** column name */
  ConnectedHerokuAppName = 'connected_heroku_app_name',
  /** column name */
  EnvironmentColor = 'environment_color',
  /** column name */
  EnvironmentName = 'environment_name',
  /** column name */
  HerokuManagedMode = 'heroku_managed_mode',
  /** column name */
  MetricsFlags = 'metrics_flags',
  /** column name */
  NumReadReplicas = 'num_read_replicas',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  WebhookId = 'webhook_id',
}

/** input type for updating data in table "project_metadata" */
export type Project_Metadata_Set_Input = {
  connected_heroku_app_name?: Maybe<Scalars['String']>;
  environment_color?: Maybe<Scalars['String']>;
  environment_name?: Maybe<Scalars['String']>;
  heroku_managed_mode?: Maybe<Scalars['Boolean']>;
  metrics_flags?: Maybe<Scalars['_text']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  webhook_id?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Project_Metadata_Stddev_Fields = {
  __typename?: 'project_metadata_stddev_fields';
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Metadata_Stddev_Pop_Fields = {
  __typename?: 'project_metadata_stddev_pop_fields';
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Metadata_Stddev_Samp_Fields = {
  __typename?: 'project_metadata_stddev_samp_fields';
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_metadata" */
export type Project_Metadata_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Metadata_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Metadata_Stream_Cursor_Value_Input = {
  connected_heroku_app_name?: Maybe<Scalars['String']>;
  environment_color?: Maybe<Scalars['String']>;
  environment_name?: Maybe<Scalars['String']>;
  heroku_managed_mode?: Maybe<Scalars['Boolean']>;
  metrics_flags?: Maybe<Scalars['_text']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  webhook_id?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Project_Metadata_Sum_Fields = {
  __typename?: 'project_metadata_sum_fields';
  num_read_replicas?: Maybe<Scalars['Int']>;
};

/** update columns of table "project_metadata" */
export enum Project_Metadata_Update_Column {
  /** column name */
  ConnectedHerokuAppName = 'connected_heroku_app_name',
  /** column name */
  EnvironmentColor = 'environment_color',
  /** column name */
  EnvironmentName = 'environment_name',
  /** column name */
  HerokuManagedMode = 'heroku_managed_mode',
  /** column name */
  MetricsFlags = 'metrics_flags',
  /** column name */
  NumReadReplicas = 'num_read_replicas',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  WebhookId = 'webhook_id',
}

export type Project_Metadata_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Metadata_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Metadata_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Metadata_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Metadata_Var_Pop_Fields = {
  __typename?: 'project_metadata_var_pop_fields';
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Metadata_Var_Samp_Fields = {
  __typename?: 'project_metadata_var_samp_fields';
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Metadata_Variance_Fields = {
  __typename?: 'project_metadata_variance_fields';
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** Notifications that can be triggered per project */
export type Project_Notification = {
  __typename?: 'project_notification';
  created_at: Scalars['timestamptz'];
  has_notified: Scalars['Boolean'];
  meta: Scalars['jsonb'];
  month: Scalars['Int'];
  project_id: Scalars['uuid'];
  type: Scalars['reminder_type_enum'];
  updated_at: Scalars['timestamptz'];
  year: Scalars['Int'];
};

/** Notifications that can be triggered per project */
export type Project_NotificationMetaArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "project_notification" */
export type Project_Notification_Aggregate = {
  __typename?: 'project_notification_aggregate';
  aggregate?: Maybe<Project_Notification_Aggregate_Fields>;
  nodes: Array<Project_Notification>;
};

/** aggregate fields of "project_notification" */
export type Project_Notification_Aggregate_Fields = {
  __typename?: 'project_notification_aggregate_fields';
  avg?: Maybe<Project_Notification_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Notification_Max_Fields>;
  min?: Maybe<Project_Notification_Min_Fields>;
  stddev?: Maybe<Project_Notification_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Notification_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Notification_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Notification_Sum_Fields>;
  var_pop?: Maybe<Project_Notification_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Notification_Var_Samp_Fields>;
  variance?: Maybe<Project_Notification_Variance_Fields>;
};

/** aggregate fields of "project_notification" */
export type Project_Notification_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Notification_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Project_Notification_Append_Input = {
  meta?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Project_Notification_Avg_Fields = {
  __typename?: 'project_notification_avg_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "project_notification". All fields are combined with a logical 'AND'. */
export type Project_Notification_Bool_Exp = {
  _and?: Maybe<Array<Project_Notification_Bool_Exp>>;
  _not?: Maybe<Project_Notification_Bool_Exp>;
  _or?: Maybe<Array<Project_Notification_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  has_notified?: Maybe<Boolean_Comparison_Exp>;
  meta?: Maybe<Jsonb_Comparison_Exp>;
  month?: Maybe<Int_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  type?: Maybe<Reminder_Type_Enum_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  year?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_notification" */
export enum Project_Notification_Constraint {
  /** unique or primary key constraint on columns "year", "type", "project_id", "month" */
  ProjectNotificationPkey = 'project_notification_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Project_Notification_Delete_At_Path_Input = {
  meta?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Project_Notification_Delete_Elem_Input = {
  meta?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Project_Notification_Delete_Key_Input = {
  meta?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "project_notification" */
export type Project_Notification_Inc_Input = {
  month?: Maybe<Scalars['Int']>;
  year?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "project_notification" */
export type Project_Notification_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  has_notified?: Maybe<Scalars['Boolean']>;
  meta?: Maybe<Scalars['jsonb']>;
  month?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['reminder_type_enum']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  year?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Project_Notification_Max_Fields = {
  __typename?: 'project_notification_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  month?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['reminder_type_enum']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  year?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Project_Notification_Min_Fields = {
  __typename?: 'project_notification_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  month?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['reminder_type_enum']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  year?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "project_notification" */
export type Project_Notification_Mutation_Response = {
  __typename?: 'project_notification_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Notification>;
};

/** on_conflict condition type for table "project_notification" */
export type Project_Notification_On_Conflict = {
  constraint: Project_Notification_Constraint;
  update_columns?: Array<Project_Notification_Update_Column>;
  where?: Maybe<Project_Notification_Bool_Exp>;
};

/** Ordering options when selecting data from "project_notification". */
export type Project_Notification_Order_By = {
  created_at?: Maybe<Order_By>;
  has_notified?: Maybe<Order_By>;
  meta?: Maybe<Order_By>;
  month?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  year?: Maybe<Order_By>;
};

/** primary key columns input for table: project_notification */
export type Project_Notification_Pk_Columns_Input = {
  month: Scalars['Int'];
  project_id: Scalars['uuid'];
  type: Scalars['reminder_type_enum'];
  year: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Project_Notification_Prepend_Input = {
  meta?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "project_notification" */
export enum Project_Notification_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HasNotified = 'has_notified',
  /** column name */
  Meta = 'meta',
  /** column name */
  Month = 'month',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Year = 'year',
}

/** input type for updating data in table "project_notification" */
export type Project_Notification_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  has_notified?: Maybe<Scalars['Boolean']>;
  meta?: Maybe<Scalars['jsonb']>;
  month?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['reminder_type_enum']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  year?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Project_Notification_Stddev_Fields = {
  __typename?: 'project_notification_stddev_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Notification_Stddev_Pop_Fields = {
  __typename?: 'project_notification_stddev_pop_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Notification_Stddev_Samp_Fields = {
  __typename?: 'project_notification_stddev_samp_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_notification" */
export type Project_Notification_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Notification_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Notification_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  has_notified?: Maybe<Scalars['Boolean']>;
  meta?: Maybe<Scalars['jsonb']>;
  month?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['reminder_type_enum']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  year?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Project_Notification_Sum_Fields = {
  __typename?: 'project_notification_sum_fields';
  month?: Maybe<Scalars['Int']>;
  year?: Maybe<Scalars['Int']>;
};

/** update columns of table "project_notification" */
export enum Project_Notification_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HasNotified = 'has_notified',
  /** column name */
  Meta = 'meta',
  /** column name */
  Month = 'month',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Year = 'year',
}

export type Project_Notification_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Project_Notification_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Project_Notification_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Project_Notification_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Project_Notification_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Notification_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Project_Notification_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Notification_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Notification_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Notification_Var_Pop_Fields = {
  __typename?: 'project_notification_var_pop_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Notification_Var_Samp_Fields = {
  __typename?: 'project_notification_var_samp_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Notification_Variance_Fields = {
  __typename?: 'project_notification_variance_fields';
  month?: Maybe<Scalars['Float']>;
  year?: Maybe<Scalars['Float']>;
};

/** Information about ownership transfer invitations for all projects */
export type Project_Ownership_Transfer_Invitations = {
  __typename?: 'project_ownership_transfer_invitations';
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  invited_at: Scalars['timestamptz'];
  invited_by: Scalars['uuid'];
  /** An object relationship */
  invited_by_user?: Maybe<Users>;
  /** An object relationship */
  invitee?: Maybe<Users>;
  invitee_email: Scalars['String'];
  key: Scalars['String'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  resend_invitation_count: Scalars['Int'];
};

/** aggregated selection of "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Aggregate = {
  __typename?: 'project_ownership_transfer_invitations_aggregate';
  aggregate?: Maybe<Project_Ownership_Transfer_Invitations_Aggregate_Fields>;
  nodes: Array<Project_Ownership_Transfer_Invitations>;
};

export type Project_Ownership_Transfer_Invitations_Aggregate_Bool_Exp = {
  count?: Maybe<Project_Ownership_Transfer_Invitations_Aggregate_Bool_Exp_Count>;
};

export type Project_Ownership_Transfer_Invitations_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<
    Array<Project_Ownership_Transfer_Invitations_Select_Column>
  >;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Project_Ownership_Transfer_Invitations_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Aggregate_Fields = {
  __typename?: 'project_ownership_transfer_invitations_aggregate_fields';
  avg?: Maybe<Project_Ownership_Transfer_Invitations_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Ownership_Transfer_Invitations_Max_Fields>;
  min?: Maybe<Project_Ownership_Transfer_Invitations_Min_Fields>;
  stddev?: Maybe<Project_Ownership_Transfer_Invitations_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Ownership_Transfer_Invitations_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Ownership_Transfer_Invitations_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Ownership_Transfer_Invitations_Sum_Fields>;
  var_pop?: Maybe<Project_Ownership_Transfer_Invitations_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Ownership_Transfer_Invitations_Var_Samp_Fields>;
  variance?: Maybe<Project_Ownership_Transfer_Invitations_Variance_Fields>;
};

/** aggregate fields of "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Ownership_Transfer_Invitations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Aggregate_Order_By = {
  avg?: Maybe<Project_Ownership_Transfer_Invitations_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Project_Ownership_Transfer_Invitations_Max_Order_By>;
  min?: Maybe<Project_Ownership_Transfer_Invitations_Min_Order_By>;
  stddev?: Maybe<Project_Ownership_Transfer_Invitations_Stddev_Order_By>;
  stddev_pop?: Maybe<Project_Ownership_Transfer_Invitations_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Project_Ownership_Transfer_Invitations_Stddev_Samp_Order_By>;
  sum?: Maybe<Project_Ownership_Transfer_Invitations_Sum_Order_By>;
  var_pop?: Maybe<Project_Ownership_Transfer_Invitations_Var_Pop_Order_By>;
  var_samp?: Maybe<Project_Ownership_Transfer_Invitations_Var_Samp_Order_By>;
  variance?: Maybe<Project_Ownership_Transfer_Invitations_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Arr_Rel_Insert_Input = {
  data: Array<Project_Ownership_Transfer_Invitations_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Project_Ownership_Transfer_Invitations_On_Conflict>;
};

/** aggregate avg on columns */
export type Project_Ownership_Transfer_Invitations_Avg_Fields = {
  __typename?: 'project_ownership_transfer_invitations_avg_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Avg_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/**
 * Boolean expression to filter rows from the table
 * "project_ownership_transfer_invitations". All fields are combined with a logical 'AND'.
 */
export type Project_Ownership_Transfer_Invitations_Bool_Exp = {
  _and?: Maybe<Array<Project_Ownership_Transfer_Invitations_Bool_Exp>>;
  _not?: Maybe<Project_Ownership_Transfer_Invitations_Bool_Exp>;
  _or?: Maybe<Array<Project_Ownership_Transfer_Invitations_Bool_Exp>>;
  accepted_at?: Maybe<Timestamptz_Comparison_Exp>;
  declined_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  invited_at?: Maybe<Timestamptz_Comparison_Exp>;
  invited_by?: Maybe<Uuid_Comparison_Exp>;
  invited_by_user?: Maybe<Users_Bool_Exp>;
  invitee?: Maybe<Users_Bool_Exp>;
  invitee_email?: Maybe<String_Comparison_Exp>;
  key?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  resend_invitation_count?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_ownership_transfer_invitations" */
export enum Project_Ownership_Transfer_Invitations_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectOwnershipChangeInvitationPkey = 'project_ownership_change_invitation_pkey',
  /** unique or primary key constraint on columns "key" */
  ProjectOwnershipTransferInvitationsKeyKey = 'project_ownership_transfer_invitations_key_key',
}

/** input type for incrementing numeric columns in table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Inc_Input = {
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Insert_Input = {
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  invited_by_user?: Maybe<Users_Obj_Rel_Insert_Input>;
  invitee?: Maybe<Users_Obj_Rel_Insert_Input>;
  invitee_email?: Maybe<Scalars['String']>;
  key?: Maybe<Scalars['String']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Project_Ownership_Transfer_Invitations_Max_Fields = {
  __typename?: 'project_ownership_transfer_invitations_max_fields';
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  invitee_email?: Maybe<Scalars['String']>;
  key?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Max_Order_By = {
  accepted_at?: Maybe<Order_By>;
  declined_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invited_at?: Maybe<Order_By>;
  invited_by?: Maybe<Order_By>;
  invitee_email?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Project_Ownership_Transfer_Invitations_Min_Fields = {
  __typename?: 'project_ownership_transfer_invitations_min_fields';
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  invitee_email?: Maybe<Scalars['String']>;
  key?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Min_Order_By = {
  accepted_at?: Maybe<Order_By>;
  declined_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invited_at?: Maybe<Order_By>;
  invited_by?: Maybe<Order_By>;
  invitee_email?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  resend_invitation_count?: Maybe<Order_By>;
};

/** response of any mutation on the table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Mutation_Response = {
  __typename?: 'project_ownership_transfer_invitations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Ownership_Transfer_Invitations>;
};

/** on_conflict condition type for table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_On_Conflict = {
  constraint: Project_Ownership_Transfer_Invitations_Constraint;
  update_columns?: Array<Project_Ownership_Transfer_Invitations_Update_Column>;
  where?: Maybe<Project_Ownership_Transfer_Invitations_Bool_Exp>;
};

/** Ordering options when selecting data from "project_ownership_transfer_invitations". */
export type Project_Ownership_Transfer_Invitations_Order_By = {
  accepted_at?: Maybe<Order_By>;
  declined_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invited_at?: Maybe<Order_By>;
  invited_by?: Maybe<Order_By>;
  invited_by_user?: Maybe<Users_Order_By>;
  invitee?: Maybe<Users_Order_By>;
  invitee_email?: Maybe<Order_By>;
  key?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  resend_invitation_count?: Maybe<Order_By>;
};

/** primary key columns input for table: project_ownership_transfer_invitations */
export type Project_Ownership_Transfer_Invitations_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "project_ownership_transfer_invitations" */
export enum Project_Ownership_Transfer_Invitations_Select_Column {
  /** column name */
  AcceptedAt = 'accepted_at',
  /** column name */
  DeclinedAt = 'declined_at',
  /** column name */
  Id = 'id',
  /** column name */
  InvitedAt = 'invited_at',
  /** column name */
  InvitedBy = 'invited_by',
  /** column name */
  InviteeEmail = 'invitee_email',
  /** column name */
  Key = 'key',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ResendInvitationCount = 'resend_invitation_count',
}

/** input type for updating data in table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Set_Input = {
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  invitee_email?: Maybe<Scalars['String']>;
  key?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Project_Ownership_Transfer_Invitations_Stddev_Fields = {
  __typename?: 'project_ownership_transfer_invitations_stddev_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Stddev_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Project_Ownership_Transfer_Invitations_Stddev_Pop_Fields = {
  __typename?: 'project_ownership_transfer_invitations_stddev_pop_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Stddev_Pop_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Project_Ownership_Transfer_Invitations_Stddev_Samp_Fields = {
  __typename?: 'project_ownership_transfer_invitations_stddev_samp_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Stddev_Samp_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** Streaming cursor of the table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Ownership_Transfer_Invitations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Ownership_Transfer_Invitations_Stream_Cursor_Value_Input = {
  accepted_at?: Maybe<Scalars['timestamptz']>;
  declined_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  invited_at?: Maybe<Scalars['timestamptz']>;
  invited_by?: Maybe<Scalars['uuid']>;
  invitee_email?: Maybe<Scalars['String']>;
  key?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type Project_Ownership_Transfer_Invitations_Sum_Fields = {
  __typename?: 'project_ownership_transfer_invitations_sum_fields';
  resend_invitation_count?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Sum_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** update columns of table "project_ownership_transfer_invitations" */
export enum Project_Ownership_Transfer_Invitations_Update_Column {
  /** column name */
  AcceptedAt = 'accepted_at',
  /** column name */
  DeclinedAt = 'declined_at',
  /** column name */
  Id = 'id',
  /** column name */
  InvitedAt = 'invited_at',
  /** column name */
  InvitedBy = 'invited_by',
  /** column name */
  InviteeEmail = 'invitee_email',
  /** column name */
  Key = 'key',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  ResendInvitationCount = 'resend_invitation_count',
}

export type Project_Ownership_Transfer_Invitations_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Ownership_Transfer_Invitations_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Ownership_Transfer_Invitations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Ownership_Transfer_Invitations_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Ownership_Transfer_Invitations_Var_Pop_Fields = {
  __typename?: 'project_ownership_transfer_invitations_var_pop_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Var_Pop_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Project_Ownership_Transfer_Invitations_Var_Samp_Fields = {
  __typename?: 'project_ownership_transfer_invitations_var_samp_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Var_Samp_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Project_Ownership_Transfer_Invitations_Variance_Fields = {
  __typename?: 'project_ownership_transfer_invitations_variance_fields';
  resend_invitation_count?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "project_ownership_transfer_invitations" */
export type Project_Ownership_Transfer_Invitations_Variance_Order_By = {
  resend_invitation_count?: Maybe<Order_By>;
};

/** columns and relationships of "project_pool_current_status" */
export type Project_Pool_Current_Status = {
  __typename?: 'project_pool_current_status';
  cloud?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['bigint']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
};

/** aggregated selection of "project_pool_current_status" */
export type Project_Pool_Current_Status_Aggregate = {
  __typename?: 'project_pool_current_status_aggregate';
  aggregate?: Maybe<Project_Pool_Current_Status_Aggregate_Fields>;
  nodes: Array<Project_Pool_Current_Status>;
};

/** aggregate fields of "project_pool_current_status" */
export type Project_Pool_Current_Status_Aggregate_Fields = {
  __typename?: 'project_pool_current_status_aggregate_fields';
  avg?: Maybe<Project_Pool_Current_Status_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Pool_Current_Status_Max_Fields>;
  min?: Maybe<Project_Pool_Current_Status_Min_Fields>;
  stddev?: Maybe<Project_Pool_Current_Status_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Pool_Current_Status_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Pool_Current_Status_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Pool_Current_Status_Sum_Fields>;
  var_pop?: Maybe<Project_Pool_Current_Status_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Pool_Current_Status_Var_Samp_Fields>;
  variance?: Maybe<Project_Pool_Current_Status_Variance_Fields>;
};

/** aggregate fields of "project_pool_current_status" */
export type Project_Pool_Current_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Pool_Current_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Pool_Current_Status_Avg_Fields = {
  __typename?: 'project_pool_current_status_avg_fields';
  count?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table "project_pool_current_status".
 * All fields are combined with a logical 'AND'.
 */
export type Project_Pool_Current_Status_Bool_Exp = {
  _and?: Maybe<Array<Project_Pool_Current_Status_Bool_Exp>>;
  _not?: Maybe<Project_Pool_Current_Status_Bool_Exp>;
  _or?: Maybe<Array<Project_Pool_Current_Status_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  count?: Maybe<Bigint_Comparison_Exp>;
  plan_name?: Maybe<String_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "project_pool_current_status" */
export type Project_Pool_Current_Status_Insert_Input = {
  cloud?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['bigint']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Project_Pool_Current_Status_Max_Fields = {
  __typename?: 'project_pool_current_status_max_fields';
  cloud?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['bigint']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Project_Pool_Current_Status_Min_Fields = {
  __typename?: 'project_pool_current_status_min_fields';
  cloud?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['bigint']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
};

/** input type for inserting object relation for remote table "project_pool_current_status" */
export type Project_Pool_Current_Status_Obj_Rel_Insert_Input = {
  data: Project_Pool_Current_Status_Insert_Input;
};

/** Ordering options when selecting data from "project_pool_current_status". */
export type Project_Pool_Current_Status_Order_By = {
  cloud?: Maybe<Order_By>;
  count?: Maybe<Order_By>;
  plan_name?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
};

/** select columns of table "project_pool_current_status" */
export enum Project_Pool_Current_Status_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  Count = 'count',
  /** column name */
  PlanName = 'plan_name',
  /** column name */
  Region = 'region',
}

/** aggregate stddev on columns */
export type Project_Pool_Current_Status_Stddev_Fields = {
  __typename?: 'project_pool_current_status_stddev_fields';
  count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Pool_Current_Status_Stddev_Pop_Fields = {
  __typename?: 'project_pool_current_status_stddev_pop_fields';
  count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Pool_Current_Status_Stddev_Samp_Fields = {
  __typename?: 'project_pool_current_status_stddev_samp_fields';
  count?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_pool_current_status" */
export type Project_Pool_Current_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Pool_Current_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Pool_Current_Status_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  count?: Maybe<Scalars['bigint']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Project_Pool_Current_Status_Sum_Fields = {
  __typename?: 'project_pool_current_status_sum_fields';
  count?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Project_Pool_Current_Status_Var_Pop_Fields = {
  __typename?: 'project_pool_current_status_var_pop_fields';
  count?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Pool_Current_Status_Var_Samp_Fields = {
  __typename?: 'project_pool_current_status_var_samp_fields';
  count?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Pool_Current_Status_Variance_Fields = {
  __typename?: 'project_pool_current_status_variance_fields';
  count?: Maybe<Scalars['Float']>;
};

/** table to help store all relevant request count metric data from prometheus for all projects */
export type Project_Requests_Count = {
  __typename?: 'project_requests_count';
  created_at: Scalars['date'];
  hasura_graphql_requests_total: Scalars['bigint'];
  id: Scalars['uuid'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "project_requests_count" */
export type Project_Requests_Count_Aggregate = {
  __typename?: 'project_requests_count_aggregate';
  aggregate?: Maybe<Project_Requests_Count_Aggregate_Fields>;
  nodes: Array<Project_Requests_Count>;
};

/** aggregate fields of "project_requests_count" */
export type Project_Requests_Count_Aggregate_Fields = {
  __typename?: 'project_requests_count_aggregate_fields';
  avg?: Maybe<Project_Requests_Count_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Requests_Count_Max_Fields>;
  min?: Maybe<Project_Requests_Count_Min_Fields>;
  stddev?: Maybe<Project_Requests_Count_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Requests_Count_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Requests_Count_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Requests_Count_Sum_Fields>;
  var_pop?: Maybe<Project_Requests_Count_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Requests_Count_Var_Samp_Fields>;
  variance?: Maybe<Project_Requests_Count_Variance_Fields>;
};

/** aggregate fields of "project_requests_count" */
export type Project_Requests_Count_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Requests_Count_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Requests_Count_Avg_Fields = {
  __typename?: 'project_requests_count_avg_fields';
  hasura_graphql_requests_total?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "project_requests_count". All fields are combined with a logical 'AND'. */
export type Project_Requests_Count_Bool_Exp = {
  _and?: Maybe<Array<Project_Requests_Count_Bool_Exp>>;
  _not?: Maybe<Project_Requests_Count_Bool_Exp>;
  _or?: Maybe<Array<Project_Requests_Count_Bool_Exp>>;
  created_at?: Maybe<Date_Comparison_Exp>;
  hasura_graphql_requests_total?: Maybe<Bigint_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_requests_count" */
export enum Project_Requests_Count_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectRequestsCountPkey = 'project_requests_count_pkey',
  /** unique or primary key constraint on columns "project_id", "created_at" */
  ProjectRequestsCountProjectIdCreatedAtKey = 'project_requests_count_project_id_created_at_key',
}

/** input type for incrementing numeric columns in table "project_requests_count" */
export type Project_Requests_Count_Inc_Input = {
  hasura_graphql_requests_total?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "project_requests_count" */
export type Project_Requests_Count_Insert_Input = {
  created_at?: Maybe<Scalars['date']>;
  hasura_graphql_requests_total?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Project_Requests_Count_Max_Fields = {
  __typename?: 'project_requests_count_max_fields';
  created_at?: Maybe<Scalars['date']>;
  hasura_graphql_requests_total?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Project_Requests_Count_Min_Fields = {
  __typename?: 'project_requests_count_min_fields';
  created_at?: Maybe<Scalars['date']>;
  hasura_graphql_requests_total?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "project_requests_count" */
export type Project_Requests_Count_Mutation_Response = {
  __typename?: 'project_requests_count_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Requests_Count>;
};

/** on_conflict condition type for table "project_requests_count" */
export type Project_Requests_Count_On_Conflict = {
  constraint: Project_Requests_Count_Constraint;
  update_columns?: Array<Project_Requests_Count_Update_Column>;
  where?: Maybe<Project_Requests_Count_Bool_Exp>;
};

/** Ordering options when selecting data from "project_requests_count". */
export type Project_Requests_Count_Order_By = {
  created_at?: Maybe<Order_By>;
  hasura_graphql_requests_total?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: project_requests_count */
export type Project_Requests_Count_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "project_requests_count" */
export enum Project_Requests_Count_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HasuraGraphqlRequestsTotal = 'hasura_graphql_requests_total',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "project_requests_count" */
export type Project_Requests_Count_Set_Input = {
  created_at?: Maybe<Scalars['date']>;
  hasura_graphql_requests_total?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Project_Requests_Count_Stddev_Fields = {
  __typename?: 'project_requests_count_stddev_fields';
  hasura_graphql_requests_total?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Requests_Count_Stddev_Pop_Fields = {
  __typename?: 'project_requests_count_stddev_pop_fields';
  hasura_graphql_requests_total?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Requests_Count_Stddev_Samp_Fields = {
  __typename?: 'project_requests_count_stddev_samp_fields';
  hasura_graphql_requests_total?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_requests_count" */
export type Project_Requests_Count_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Requests_Count_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Requests_Count_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['date']>;
  hasura_graphql_requests_total?: Maybe<Scalars['bigint']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Project_Requests_Count_Sum_Fields = {
  __typename?: 'project_requests_count_sum_fields';
  hasura_graphql_requests_total?: Maybe<Scalars['bigint']>;
};

/** update columns of table "project_requests_count" */
export enum Project_Requests_Count_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HasuraGraphqlRequestsTotal = 'hasura_graphql_requests_total',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Project_Requests_Count_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Requests_Count_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Requests_Count_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Requests_Count_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Requests_Count_Var_Pop_Fields = {
  __typename?: 'project_requests_count_var_pop_fields';
  hasura_graphql_requests_total?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Requests_Count_Var_Samp_Fields = {
  __typename?: 'project_requests_count_var_samp_fields';
  hasura_graphql_requests_total?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Requests_Count_Variance_Fields = {
  __typename?: 'project_requests_count_variance_fields';
  hasura_graphql_requests_total?: Maybe<Scalars['Float']>;
};

/** Project statistics used to send to metabase */
export type Project_Stats = {
  __typename?: 'project_stats';
  cache_size_usage: Scalars['bigint'];
  date: Scalars['date'];
  has_cached_query: Scalars['Boolean'];
  has_mutation: Scalars['Boolean'];
  has_query: Scalars['Boolean'];
  has_subscription: Scalars['Boolean'];
  id: Scalars['uuid'];
  last_console_access?: Maybe<Scalars['timestamptz']>;
  last_login?: Maybe<Scalars['timestamptz']>;
  num_allow_list_operations: Scalars['Int'];
  num_collaborators: Scalars['Int'];
  num_login_sessions: Scalars['Int'];
  num_rate_limits: Scalars['Int'];
  num_read_replicas: Scalars['Int'];
  num_test_runs: Scalars['Int'];
  num_test_suite_operations: Scalars['Int'];
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id: Scalars['uuid'];
  rate_limit_depths: Scalars['Int'];
  total_metadata_requests: Scalars['bigint'];
  total_requests: Scalars['bigint'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "project_stats" */
export type Project_Stats_Aggregate = {
  __typename?: 'project_stats_aggregate';
  aggregate?: Maybe<Project_Stats_Aggregate_Fields>;
  nodes: Array<Project_Stats>;
};

/** aggregate fields of "project_stats" */
export type Project_Stats_Aggregate_Fields = {
  __typename?: 'project_stats_aggregate_fields';
  avg?: Maybe<Project_Stats_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Stats_Max_Fields>;
  min?: Maybe<Project_Stats_Min_Fields>;
  stddev?: Maybe<Project_Stats_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Stats_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Stats_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Stats_Sum_Fields>;
  var_pop?: Maybe<Project_Stats_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Stats_Var_Samp_Fields>;
  variance?: Maybe<Project_Stats_Variance_Fields>;
};

/** aggregate fields of "project_stats" */
export type Project_Stats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Stats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Stats_Avg_Fields = {
  __typename?: 'project_stats_avg_fields';
  cache_size_usage?: Maybe<Scalars['Float']>;
  num_allow_list_operations?: Maybe<Scalars['Float']>;
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_rate_limits?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
  num_test_runs?: Maybe<Scalars['Float']>;
  num_test_suite_operations?: Maybe<Scalars['Float']>;
  rate_limit_depths?: Maybe<Scalars['Float']>;
  total_metadata_requests?: Maybe<Scalars['Float']>;
  total_requests?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "project_stats". All fields are combined with a logical 'AND'. */
export type Project_Stats_Bool_Exp = {
  _and?: Maybe<Array<Project_Stats_Bool_Exp>>;
  _not?: Maybe<Project_Stats_Bool_Exp>;
  _or?: Maybe<Array<Project_Stats_Bool_Exp>>;
  cache_size_usage?: Maybe<Bigint_Comparison_Exp>;
  date?: Maybe<Date_Comparison_Exp>;
  has_cached_query?: Maybe<Boolean_Comparison_Exp>;
  has_mutation?: Maybe<Boolean_Comparison_Exp>;
  has_query?: Maybe<Boolean_Comparison_Exp>;
  has_subscription?: Maybe<Boolean_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  last_console_access?: Maybe<Timestamptz_Comparison_Exp>;
  last_login?: Maybe<Timestamptz_Comparison_Exp>;
  num_allow_list_operations?: Maybe<Int_Comparison_Exp>;
  num_collaborators?: Maybe<Int_Comparison_Exp>;
  num_login_sessions?: Maybe<Int_Comparison_Exp>;
  num_rate_limits?: Maybe<Int_Comparison_Exp>;
  num_read_replicas?: Maybe<Int_Comparison_Exp>;
  num_test_runs?: Maybe<Int_Comparison_Exp>;
  num_test_suite_operations?: Maybe<Int_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  rate_limit_depths?: Maybe<Int_Comparison_Exp>;
  total_metadata_requests?: Maybe<Bigint_Comparison_Exp>;
  total_requests?: Maybe<Bigint_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "project_stats" */
export enum Project_Stats_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectStatsPkey = 'project_stats_pkey',
  /** unique or primary key constraint on columns "date", "project_id" */
  ProjectStatsProjectIdDateKey = 'project_stats_project_id_date_key',
}

/** input type for incrementing numeric columns in table "project_stats" */
export type Project_Stats_Inc_Input = {
  cache_size_usage?: Maybe<Scalars['bigint']>;
  num_allow_list_operations?: Maybe<Scalars['Int']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_rate_limits?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  num_test_runs?: Maybe<Scalars['Int']>;
  num_test_suite_operations?: Maybe<Scalars['Int']>;
  rate_limit_depths?: Maybe<Scalars['Int']>;
  total_metadata_requests?: Maybe<Scalars['bigint']>;
  total_requests?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "project_stats" */
export type Project_Stats_Insert_Input = {
  cache_size_usage?: Maybe<Scalars['bigint']>;
  date?: Maybe<Scalars['date']>;
  has_cached_query?: Maybe<Scalars['Boolean']>;
  has_mutation?: Maybe<Scalars['Boolean']>;
  has_query?: Maybe<Scalars['Boolean']>;
  has_subscription?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  last_console_access?: Maybe<Scalars['timestamptz']>;
  last_login?: Maybe<Scalars['timestamptz']>;
  num_allow_list_operations?: Maybe<Scalars['Int']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_rate_limits?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  num_test_runs?: Maybe<Scalars['Int']>;
  num_test_suite_operations?: Maybe<Scalars['Int']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  rate_limit_depths?: Maybe<Scalars['Int']>;
  total_metadata_requests?: Maybe<Scalars['bigint']>;
  total_requests?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Project_Stats_Max_Fields = {
  __typename?: 'project_stats_max_fields';
  cache_size_usage?: Maybe<Scalars['bigint']>;
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  last_console_access?: Maybe<Scalars['timestamptz']>;
  last_login?: Maybe<Scalars['timestamptz']>;
  num_allow_list_operations?: Maybe<Scalars['Int']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_rate_limits?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  num_test_runs?: Maybe<Scalars['Int']>;
  num_test_suite_operations?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  rate_limit_depths?: Maybe<Scalars['Int']>;
  total_metadata_requests?: Maybe<Scalars['bigint']>;
  total_requests?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Project_Stats_Min_Fields = {
  __typename?: 'project_stats_min_fields';
  cache_size_usage?: Maybe<Scalars['bigint']>;
  date?: Maybe<Scalars['date']>;
  id?: Maybe<Scalars['uuid']>;
  last_console_access?: Maybe<Scalars['timestamptz']>;
  last_login?: Maybe<Scalars['timestamptz']>;
  num_allow_list_operations?: Maybe<Scalars['Int']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_rate_limits?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  num_test_runs?: Maybe<Scalars['Int']>;
  num_test_suite_operations?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  rate_limit_depths?: Maybe<Scalars['Int']>;
  total_metadata_requests?: Maybe<Scalars['bigint']>;
  total_requests?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "project_stats" */
export type Project_Stats_Mutation_Response = {
  __typename?: 'project_stats_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Stats>;
};

/** on_conflict condition type for table "project_stats" */
export type Project_Stats_On_Conflict = {
  constraint: Project_Stats_Constraint;
  update_columns?: Array<Project_Stats_Update_Column>;
  where?: Maybe<Project_Stats_Bool_Exp>;
};

/** Ordering options when selecting data from "project_stats". */
export type Project_Stats_Order_By = {
  cache_size_usage?: Maybe<Order_By>;
  date?: Maybe<Order_By>;
  has_cached_query?: Maybe<Order_By>;
  has_mutation?: Maybe<Order_By>;
  has_query?: Maybe<Order_By>;
  has_subscription?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last_console_access?: Maybe<Order_By>;
  last_login?: Maybe<Order_By>;
  num_allow_list_operations?: Maybe<Order_By>;
  num_collaborators?: Maybe<Order_By>;
  num_login_sessions?: Maybe<Order_By>;
  num_rate_limits?: Maybe<Order_By>;
  num_read_replicas?: Maybe<Order_By>;
  num_test_runs?: Maybe<Order_By>;
  num_test_suite_operations?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  rate_limit_depths?: Maybe<Order_By>;
  total_metadata_requests?: Maybe<Order_By>;
  total_requests?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: project_stats */
export type Project_Stats_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "project_stats" */
export enum Project_Stats_Select_Column {
  /** column name */
  CacheSizeUsage = 'cache_size_usage',
  /** column name */
  Date = 'date',
  /** column name */
  HasCachedQuery = 'has_cached_query',
  /** column name */
  HasMutation = 'has_mutation',
  /** column name */
  HasQuery = 'has_query',
  /** column name */
  HasSubscription = 'has_subscription',
  /** column name */
  Id = 'id',
  /** column name */
  LastConsoleAccess = 'last_console_access',
  /** column name */
  LastLogin = 'last_login',
  /** column name */
  NumAllowListOperations = 'num_allow_list_operations',
  /** column name */
  NumCollaborators = 'num_collaborators',
  /** column name */
  NumLoginSessions = 'num_login_sessions',
  /** column name */
  NumRateLimits = 'num_rate_limits',
  /** column name */
  NumReadReplicas = 'num_read_replicas',
  /** column name */
  NumTestRuns = 'num_test_runs',
  /** column name */
  NumTestSuiteOperations = 'num_test_suite_operations',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  RateLimitDepths = 'rate_limit_depths',
  /** column name */
  TotalMetadataRequests = 'total_metadata_requests',
  /** column name */
  TotalRequests = 'total_requests',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "project_stats" */
export type Project_Stats_Set_Input = {
  cache_size_usage?: Maybe<Scalars['bigint']>;
  date?: Maybe<Scalars['date']>;
  has_cached_query?: Maybe<Scalars['Boolean']>;
  has_mutation?: Maybe<Scalars['Boolean']>;
  has_query?: Maybe<Scalars['Boolean']>;
  has_subscription?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  last_console_access?: Maybe<Scalars['timestamptz']>;
  last_login?: Maybe<Scalars['timestamptz']>;
  num_allow_list_operations?: Maybe<Scalars['Int']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_rate_limits?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  num_test_runs?: Maybe<Scalars['Int']>;
  num_test_suite_operations?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  rate_limit_depths?: Maybe<Scalars['Int']>;
  total_metadata_requests?: Maybe<Scalars['bigint']>;
  total_requests?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Project_Stats_Stddev_Fields = {
  __typename?: 'project_stats_stddev_fields';
  cache_size_usage?: Maybe<Scalars['Float']>;
  num_allow_list_operations?: Maybe<Scalars['Float']>;
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_rate_limits?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
  num_test_runs?: Maybe<Scalars['Float']>;
  num_test_suite_operations?: Maybe<Scalars['Float']>;
  rate_limit_depths?: Maybe<Scalars['Float']>;
  total_metadata_requests?: Maybe<Scalars['Float']>;
  total_requests?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Stats_Stddev_Pop_Fields = {
  __typename?: 'project_stats_stddev_pop_fields';
  cache_size_usage?: Maybe<Scalars['Float']>;
  num_allow_list_operations?: Maybe<Scalars['Float']>;
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_rate_limits?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
  num_test_runs?: Maybe<Scalars['Float']>;
  num_test_suite_operations?: Maybe<Scalars['Float']>;
  rate_limit_depths?: Maybe<Scalars['Float']>;
  total_metadata_requests?: Maybe<Scalars['Float']>;
  total_requests?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Stats_Stddev_Samp_Fields = {
  __typename?: 'project_stats_stddev_samp_fields';
  cache_size_usage?: Maybe<Scalars['Float']>;
  num_allow_list_operations?: Maybe<Scalars['Float']>;
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_rate_limits?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
  num_test_runs?: Maybe<Scalars['Float']>;
  num_test_suite_operations?: Maybe<Scalars['Float']>;
  rate_limit_depths?: Maybe<Scalars['Float']>;
  total_metadata_requests?: Maybe<Scalars['Float']>;
  total_requests?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_stats" */
export type Project_Stats_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Stats_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Stats_Stream_Cursor_Value_Input = {
  cache_size_usage?: Maybe<Scalars['bigint']>;
  date?: Maybe<Scalars['date']>;
  has_cached_query?: Maybe<Scalars['Boolean']>;
  has_mutation?: Maybe<Scalars['Boolean']>;
  has_query?: Maybe<Scalars['Boolean']>;
  has_subscription?: Maybe<Scalars['Boolean']>;
  id?: Maybe<Scalars['uuid']>;
  last_console_access?: Maybe<Scalars['timestamptz']>;
  last_login?: Maybe<Scalars['timestamptz']>;
  num_allow_list_operations?: Maybe<Scalars['Int']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_rate_limits?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  num_test_runs?: Maybe<Scalars['Int']>;
  num_test_suite_operations?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  rate_limit_depths?: Maybe<Scalars['Int']>;
  total_metadata_requests?: Maybe<Scalars['bigint']>;
  total_requests?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Project_Stats_Sum_Fields = {
  __typename?: 'project_stats_sum_fields';
  cache_size_usage?: Maybe<Scalars['bigint']>;
  num_allow_list_operations?: Maybe<Scalars['Int']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_rate_limits?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  num_test_runs?: Maybe<Scalars['Int']>;
  num_test_suite_operations?: Maybe<Scalars['Int']>;
  rate_limit_depths?: Maybe<Scalars['Int']>;
  total_metadata_requests?: Maybe<Scalars['bigint']>;
  total_requests?: Maybe<Scalars['bigint']>;
};

/** update columns of table "project_stats" */
export enum Project_Stats_Update_Column {
  /** column name */
  CacheSizeUsage = 'cache_size_usage',
  /** column name */
  Date = 'date',
  /** column name */
  HasCachedQuery = 'has_cached_query',
  /** column name */
  HasMutation = 'has_mutation',
  /** column name */
  HasQuery = 'has_query',
  /** column name */
  HasSubscription = 'has_subscription',
  /** column name */
  Id = 'id',
  /** column name */
  LastConsoleAccess = 'last_console_access',
  /** column name */
  LastLogin = 'last_login',
  /** column name */
  NumAllowListOperations = 'num_allow_list_operations',
  /** column name */
  NumCollaborators = 'num_collaborators',
  /** column name */
  NumLoginSessions = 'num_login_sessions',
  /** column name */
  NumRateLimits = 'num_rate_limits',
  /** column name */
  NumReadReplicas = 'num_read_replicas',
  /** column name */
  NumTestRuns = 'num_test_runs',
  /** column name */
  NumTestSuiteOperations = 'num_test_suite_operations',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  RateLimitDepths = 'rate_limit_depths',
  /** column name */
  TotalMetadataRequests = 'total_metadata_requests',
  /** column name */
  TotalRequests = 'total_requests',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Project_Stats_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Stats_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Stats_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Stats_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Stats_Var_Pop_Fields = {
  __typename?: 'project_stats_var_pop_fields';
  cache_size_usage?: Maybe<Scalars['Float']>;
  num_allow_list_operations?: Maybe<Scalars['Float']>;
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_rate_limits?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
  num_test_runs?: Maybe<Scalars['Float']>;
  num_test_suite_operations?: Maybe<Scalars['Float']>;
  rate_limit_depths?: Maybe<Scalars['Float']>;
  total_metadata_requests?: Maybe<Scalars['Float']>;
  total_requests?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Stats_Var_Samp_Fields = {
  __typename?: 'project_stats_var_samp_fields';
  cache_size_usage?: Maybe<Scalars['Float']>;
  num_allow_list_operations?: Maybe<Scalars['Float']>;
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_rate_limits?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
  num_test_runs?: Maybe<Scalars['Float']>;
  num_test_suite_operations?: Maybe<Scalars['Float']>;
  rate_limit_depths?: Maybe<Scalars['Float']>;
  total_metadata_requests?: Maybe<Scalars['Float']>;
  total_requests?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Stats_Variance_Fields = {
  __typename?: 'project_stats_variance_fields';
  cache_size_usage?: Maybe<Scalars['Float']>;
  num_allow_list_operations?: Maybe<Scalars['Float']>;
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_rate_limits?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
  num_test_runs?: Maybe<Scalars['Float']>;
  num_test_suite_operations?: Maybe<Scalars['Float']>;
  rate_limit_depths?: Maybe<Scalars['Float']>;
  total_metadata_requests?: Maybe<Scalars['Float']>;
  total_requests?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "project_total_db_usage_agg" */
export type Project_Total_Db_Usage_Agg = {
  __typename?: 'project_total_db_usage_agg';
  project_id?: Maybe<Scalars['uuid']>;
  total_no_db_usage?: Maybe<Scalars['Int']>;
  total_non_pg_usage?: Maybe<Scalars['Int']>;
  total_pg_usage?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['bigint']>;
};

export type Project_Total_Db_Usage_Agg_Aggregate = {
  __typename?: 'project_total_db_usage_agg_aggregate';
  aggregate?: Maybe<Project_Total_Db_Usage_Agg_Aggregate_Fields>;
  nodes: Array<Project_Total_Db_Usage_Agg>;
};

/** aggregate fields of "project_total_db_usage_agg" */
export type Project_Total_Db_Usage_Agg_Aggregate_Fields = {
  __typename?: 'project_total_db_usage_agg_aggregate_fields';
  avg?: Maybe<Project_Total_Db_Usage_Agg_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Project_Total_Db_Usage_Agg_Max_Fields>;
  min?: Maybe<Project_Total_Db_Usage_Agg_Min_Fields>;
  stddev?: Maybe<Project_Total_Db_Usage_Agg_Stddev_Fields>;
  stddev_pop?: Maybe<Project_Total_Db_Usage_Agg_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Project_Total_Db_Usage_Agg_Stddev_Samp_Fields>;
  sum?: Maybe<Project_Total_Db_Usage_Agg_Sum_Fields>;
  var_pop?: Maybe<Project_Total_Db_Usage_Agg_Var_Pop_Fields>;
  var_samp?: Maybe<Project_Total_Db_Usage_Agg_Var_Samp_Fields>;
  variance?: Maybe<Project_Total_Db_Usage_Agg_Variance_Fields>;
};

/** aggregate fields of "project_total_db_usage_agg" */
export type Project_Total_Db_Usage_Agg_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Project_Total_Db_Usage_Agg_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Project_Total_Db_Usage_Agg_Avg_Fields = {
  __typename?: 'project_total_db_usage_agg_avg_fields';
  total_no_db_usage?: Maybe<Scalars['Float']>;
  total_non_pg_usage?: Maybe<Scalars['Float']>;
  total_pg_usage?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "project_total_db_usage_agg". All fields are combined with a logical 'AND'. */
export type Project_Total_Db_Usage_Agg_Bool_Exp = {
  _and?: Maybe<Array<Project_Total_Db_Usage_Agg_Bool_Exp>>;
  _not?: Maybe<Project_Total_Db_Usage_Agg_Bool_Exp>;
  _or?: Maybe<Array<Project_Total_Db_Usage_Agg_Bool_Exp>>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  total_no_db_usage?: Maybe<Int_Comparison_Exp>;
  total_non_pg_usage?: Maybe<Int_Comparison_Exp>;
  total_pg_usage?: Maybe<Int_Comparison_Exp>;
  total_price?: Maybe<Bigint_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "project_total_db_usage_agg" */
export type Project_Total_Db_Usage_Agg_Inc_Input = {
  total_no_db_usage?: Maybe<Scalars['Int']>;
  total_non_pg_usage?: Maybe<Scalars['Int']>;
  total_pg_usage?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "project_total_db_usage_agg" */
export type Project_Total_Db_Usage_Agg_Insert_Input = {
  project_id?: Maybe<Scalars['uuid']>;
  total_no_db_usage?: Maybe<Scalars['Int']>;
  total_non_pg_usage?: Maybe<Scalars['Int']>;
  total_pg_usage?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Project_Total_Db_Usage_Agg_Max_Fields = {
  __typename?: 'project_total_db_usage_agg_max_fields';
  project_id?: Maybe<Scalars['uuid']>;
  total_no_db_usage?: Maybe<Scalars['Int']>;
  total_non_pg_usage?: Maybe<Scalars['Int']>;
  total_pg_usage?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Project_Total_Db_Usage_Agg_Min_Fields = {
  __typename?: 'project_total_db_usage_agg_min_fields';
  project_id?: Maybe<Scalars['uuid']>;
  total_no_db_usage?: Maybe<Scalars['Int']>;
  total_non_pg_usage?: Maybe<Scalars['Int']>;
  total_pg_usage?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "project_total_db_usage_agg" */
export type Project_Total_Db_Usage_Agg_Mutation_Response = {
  __typename?: 'project_total_db_usage_agg_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Project_Total_Db_Usage_Agg>;
};

/** Ordering options when selecting data from "project_total_db_usage_agg". */
export type Project_Total_Db_Usage_Agg_Order_By = {
  project_id?: Maybe<Order_By>;
  total_no_db_usage?: Maybe<Order_By>;
  total_non_pg_usage?: Maybe<Order_By>;
  total_pg_usage?: Maybe<Order_By>;
  total_price?: Maybe<Order_By>;
};

/** select columns of table "project_total_db_usage_agg" */
export enum Project_Total_Db_Usage_Agg_Select_Column {
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  TotalNoDbUsage = 'total_no_db_usage',
  /** column name */
  TotalNonPgUsage = 'total_non_pg_usage',
  /** column name */
  TotalPgUsage = 'total_pg_usage',
  /** column name */
  TotalPrice = 'total_price',
}

/** input type for updating data in table "project_total_db_usage_agg" */
export type Project_Total_Db_Usage_Agg_Set_Input = {
  project_id?: Maybe<Scalars['uuid']>;
  total_no_db_usage?: Maybe<Scalars['Int']>;
  total_non_pg_usage?: Maybe<Scalars['Int']>;
  total_pg_usage?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Project_Total_Db_Usage_Agg_Stddev_Fields = {
  __typename?: 'project_total_db_usage_agg_stddev_fields';
  total_no_db_usage?: Maybe<Scalars['Float']>;
  total_non_pg_usage?: Maybe<Scalars['Float']>;
  total_pg_usage?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Project_Total_Db_Usage_Agg_Stddev_Pop_Fields = {
  __typename?: 'project_total_db_usage_agg_stddev_pop_fields';
  total_no_db_usage?: Maybe<Scalars['Float']>;
  total_non_pg_usage?: Maybe<Scalars['Float']>;
  total_pg_usage?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Project_Total_Db_Usage_Agg_Stddev_Samp_Fields = {
  __typename?: 'project_total_db_usage_agg_stddev_samp_fields';
  total_no_db_usage?: Maybe<Scalars['Float']>;
  total_non_pg_usage?: Maybe<Scalars['Float']>;
  total_pg_usage?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "project_total_db_usage_agg" */
export type Project_Total_Db_Usage_Agg_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Project_Total_Db_Usage_Agg_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Project_Total_Db_Usage_Agg_Stream_Cursor_Value_Input = {
  project_id?: Maybe<Scalars['uuid']>;
  total_no_db_usage?: Maybe<Scalars['Int']>;
  total_non_pg_usage?: Maybe<Scalars['Int']>;
  total_pg_usage?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Project_Total_Db_Usage_Agg_Sum_Fields = {
  __typename?: 'project_total_db_usage_agg_sum_fields';
  total_no_db_usage?: Maybe<Scalars['Int']>;
  total_non_pg_usage?: Maybe<Scalars['Int']>;
  total_pg_usage?: Maybe<Scalars['Int']>;
  total_price?: Maybe<Scalars['bigint']>;
};

export type Project_Total_Db_Usage_Agg_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Project_Total_Db_Usage_Agg_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Project_Total_Db_Usage_Agg_Set_Input>;
  /** filter the rows which have to be updated */
  where: Project_Total_Db_Usage_Agg_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Project_Total_Db_Usage_Agg_Var_Pop_Fields = {
  __typename?: 'project_total_db_usage_agg_var_pop_fields';
  total_no_db_usage?: Maybe<Scalars['Float']>;
  total_non_pg_usage?: Maybe<Scalars['Float']>;
  total_pg_usage?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Project_Total_Db_Usage_Agg_Var_Samp_Fields = {
  __typename?: 'project_total_db_usage_agg_var_samp_fields';
  total_no_db_usage?: Maybe<Scalars['Float']>;
  total_non_pg_usage?: Maybe<Scalars['Float']>;
  total_pg_usage?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Project_Total_Db_Usage_Agg_Variance_Fields = {
  __typename?: 'project_total_db_usage_agg_variance_fields';
  total_no_db_usage?: Maybe<Scalars['Float']>;
  total_non_pg_usage?: Maybe<Scalars['Float']>;
  total_pg_usage?: Maybe<Scalars['Float']>;
  total_price?: Maybe<Scalars['Float']>;
};

export type ProjectCollaboratorInvitation = {
  __typename?: 'ProjectCollaboratorInvitation';
  collaborator_email: Scalars['String'];
  id: Scalars['uuid'];
  invited_at: Scalars['String'];
  invited_by: Scalars['uuid'];
  key: Scalars['String'];
  privileges: Array<Scalars['String']>;
  project_id: Scalars['uuid'];
};

export type ProjectDbUsage = {
  __typename?: 'ProjectDBUsage';
  amount: Scalars['Int'];
  type: Scalars['String'];
  usage: Scalars['Int'];
};

export type ProjectMigrationStatus = {
  __typename?: 'ProjectMigrationStatus';
  datasource: Scalars['String'];
  migration: Scalars['String'];
};

export type ProjectMigrationStatusInput = {
  project_id: Scalars['String'];
};

export type ProjectMiscMetadata = {
  herokuAppName?: Maybe<Scalars['String']>;
};

export type ProjectOptions = {
  cloud: Scalars['String'];
  envVars?: Maybe<Array<Maybe<UpdateEnvsObject>>>;
  name: Scalars['String'];
  plan?: Maybe<Scalars['String']>;
  region: Scalars['String'];
};

export type ProjectOwnershipInvitation = {
  __typename?: 'ProjectOwnershipInvitation';
  id: Scalars['uuid'];
  invitedAt: Scalars['String'];
  invitedBy: Scalars['String'];
  isBillable: Scalars['Boolean'];
  isBillingManager: Scalars['Boolean'];
  key: Scalars['String'];
  projectName: Scalars['String'];
  projectPlan: Scalars['String'];
};

export type ProjectOwnershipTransferInvitation = {
  __typename?: 'ProjectOwnershipTransferInvitation';
  id: Scalars['uuid'];
  invited_at: Scalars['String'];
  invited_by: Scalars['uuid'];
  invitee_email: Scalars['String'];
  key: Scalars['String'];
  project_id: Scalars['uuid'];
};

export type ProjectReactivationResponse = {
  __typename?: 'ProjectReactivationResponse';
  project?: Maybe<Projects>;
  projectId: Scalars['uuid'];
  success: Scalars['Boolean'];
};

/** Hasura projects */
export type Projects = {
  __typename?: 'projects';
  /** An array relationship */
  activities: Array<Project_Activity>;
  /** An aggregate relationship */
  activities_aggregate: Project_Activity_Aggregate;
  /** An object relationship */
  alert_config?: Maybe<Alert_Config>;
  assigned_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  azuremonitor_config?: Maybe<Azuremonitor_Config>;
  /** An object relationship */
  billing_manager?: Maybe<Users_Public>;
  billing_manager_id: Scalars['uuid'];
  /**
   * billing_plan_name reflects whether this project is payable or not. This is a
   * derived columm from the last plan_change activity in the project_activity
   * table corresponding to this project. This is different from the plan_name
   * column because it also takes into consideration the active/deactive state of the project.
   */
  billing_plan_name?: Maybe<Scalars['String']>;
  /** An array relationship */
  collaborators: Array<Project_Collaborators>;
  /** An aggregate relationship */
  collaborators_aggregate: Project_Collaborators_Aggregate;
  console_oauth_id: Scalars['String'];
  created_at: Scalars['timestamptz'];
  /** This computed field returns the data usage for the project in the current month, computed from Prometheus. */
  current_month_data_usage?: Maybe<Scalars['bigint']>;
  /** An object relationship */
  datadog_config?: Maybe<Datadog_Config>;
  endpoint: Scalars['String'];
  /** An object relationship */
  enterprise_users?: Maybe<Enterprise_Users>;
  /** An array relationship */
  entitlements: Array<Project_Entitlement_Access>;
  /** An aggregate relationship */
  entitlements_aggregate: Project_Entitlement_Access_Aggregate;
  /** An array relationship */
  heroku_integrations: Array<Heroku_Integrations>;
  /** An aggregate relationship */
  heroku_integrations_aggregate: Heroku_Integrations_Aggregate;
  id: Scalars['uuid'];
  /** An array relationship */
  invitations: Array<Project_Collaborator_Invitations>;
  /** An aggregate relationship */
  invitations_aggregate: Project_Collaborator_Invitations_Aggregate;
  /** invoice attempt count if exists */
  invoice_attempt_count?: Maybe<Scalars['Int']>;
  /** latest invoice payement status if exists */
  invoice_status?: Maybe<Scalars['String']>;
  /** An array relationship */
  jobs: Array<Jobs>;
  /** An aggregate relationship */
  jobs_aggregate: Jobs_Aggregate;
  /** An array relationship */
  labels: Array<Project_Labels>;
  /** An aggregate relationship */
  labels_aggregate: Project_Labels_Aggregate;
  /** An object relationship */
  metadata?: Maybe<Project_Metadata>;
  name: Scalars['String'];
  /** An object relationship */
  newrelic_config?: Maybe<Newrelic_Config>;
  /** A computed field, executes function "get_requests_per_month_for_project" */
  number_of_requests_this_month?: Maybe<Scalars['bigint']>;
  /** An object relationship */
  opentelemetry_config?: Maybe<Opentelemetry_Config>;
  /** An object relationship */
  owner?: Maybe<Users_Public>;
  /** An object relationship */
  owner_entitlements?: Maybe<User_Entitlement_Access>;
  owner_id: Scalars['uuid'];
  /** An array relationship */
  ownership_transfer_invites: Array<Project_Ownership_Transfer_Invitations>;
  /** An aggregate relationship */
  ownership_transfer_invites_aggregate: Project_Ownership_Transfer_Invitations_Aggregate;
  plan_name?: Maybe<Scalars['String']>;
  /** An array relationship */
  policies: Array<Policies>;
  /** An aggregate relationship */
  policies_aggregate: Policies_Aggregate;
  /** An array relationship */
  pro_key_generations: Array<Projects_Pro_Key_Generations>;
  /** An aggregate relationship */
  pro_key_generations_aggregate: Projects_Pro_Key_Generations_Aggregate;
  /** An array relationship */
  project_billing_manager_invitations: Array<Project_Billing_Manager_Invitations>;
  /** An aggregate relationship */
  project_billing_manager_invitations_aggregate: Project_Billing_Manager_Invitations_Aggregate;
  /** An array relationship */
  project_usage_prometheus: Array<Project_Data_Usage_Prometheus>;
  /** An aggregate relationship */
  project_usage_prometheus_aggregate: Project_Data_Usage_Prometheus_Aggregate;
  /** An array relationship */
  project_usages: Array<Project_Data_Usage>;
  /** An aggregate relationship */
  project_usages_aggregate: Project_Data_Usage_Aggregate;
  /** An object relationship */
  prometheus_config?: Maybe<Prometheus_Config>;
  server_oauth_id: Scalars['String'];
  /** An object relationship */
  tenant?: Maybe<Tenant>;
  updated_at: Scalars['timestamptz'];
  /** An array relationship */
  usage_reports: Array<Project_Data_Usage_Report>;
  /** An aggregate relationship */
  usage_reports_aggregate: Project_Data_Usage_Report_Aggregate;
  /** An array relationship */
  vercel_integration_connections: Array<Vercel_Integration_Connections>;
  /** An aggregate relationship */
  vercel_integration_connections_aggregate: Vercel_Integration_Connections_Aggregate;
};

/** Hasura projects */
export type ProjectsActivitiesArgs = {
  distinct_on?: Maybe<Array<Project_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Activity_Order_By>>;
  where?: Maybe<Project_Activity_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsActivities_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Activity_Order_By>>;
  where?: Maybe<Project_Activity_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsCollaboratorsArgs = {
  distinct_on?: Maybe<Array<Project_Collaborators_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborators_Order_By>>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsCollaborators_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Collaborators_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborators_Order_By>>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsEntitlementsArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Project_Entitlement_Access_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsEntitlements_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Project_Entitlement_Access_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsHeroku_IntegrationsArgs = {
  distinct_on?: Maybe<Array<Heroku_Integrations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Heroku_Integrations_Order_By>>;
  where?: Maybe<Heroku_Integrations_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsHeroku_Integrations_AggregateArgs = {
  distinct_on?: Maybe<Array<Heroku_Integrations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Heroku_Integrations_Order_By>>;
  where?: Maybe<Heroku_Integrations_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsInvitationsArgs = {
  distinct_on?: Maybe<Array<Project_Collaborator_Invitations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Invitations_Order_By>>;
  where?: Maybe<Project_Collaborator_Invitations_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsInvitations_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Collaborator_Invitations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Invitations_Order_By>>;
  where?: Maybe<Project_Collaborator_Invitations_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsJobsArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsJobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsLabelsArgs = {
  distinct_on?: Maybe<Array<Project_Labels_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Labels_Order_By>>;
  where?: Maybe<Project_Labels_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsLabels_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Labels_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Labels_Order_By>>;
  where?: Maybe<Project_Labels_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsOwnership_Transfer_InvitesArgs = {
  distinct_on?: Maybe<
    Array<Project_Ownership_Transfer_Invitations_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Ownership_Transfer_Invitations_Order_By>>;
  where?: Maybe<Project_Ownership_Transfer_Invitations_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsOwnership_Transfer_Invites_AggregateArgs = {
  distinct_on?: Maybe<
    Array<Project_Ownership_Transfer_Invitations_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Ownership_Transfer_Invitations_Order_By>>;
  where?: Maybe<Project_Ownership_Transfer_Invitations_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsPoliciesArgs = {
  distinct_on?: Maybe<Array<Policies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Policies_Order_By>>;
  where?: Maybe<Policies_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsPolicies_AggregateArgs = {
  distinct_on?: Maybe<Array<Policies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Policies_Order_By>>;
  where?: Maybe<Policies_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsPro_Key_GenerationsArgs = {
  distinct_on?: Maybe<Array<Projects_Pro_Key_Generations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Pro_Key_Generations_Order_By>>;
  where?: Maybe<Projects_Pro_Key_Generations_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsPro_Key_Generations_AggregateArgs = {
  distinct_on?: Maybe<Array<Projects_Pro_Key_Generations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Pro_Key_Generations_Order_By>>;
  where?: Maybe<Projects_Pro_Key_Generations_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsProject_Billing_Manager_InvitationsArgs = {
  distinct_on?: Maybe<Array<Project_Billing_Manager_Invitations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Billing_Manager_Invitations_Order_By>>;
  where?: Maybe<Project_Billing_Manager_Invitations_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsProject_Billing_Manager_Invitations_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Billing_Manager_Invitations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Billing_Manager_Invitations_Order_By>>;
  where?: Maybe<Project_Billing_Manager_Invitations_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsProject_Usage_PrometheusArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Prometheus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Order_By>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsProject_Usage_Prometheus_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Prometheus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Order_By>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsProject_UsagesArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Order_By>>;
  where?: Maybe<Project_Data_Usage_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsProject_Usages_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Order_By>>;
  where?: Maybe<Project_Data_Usage_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsUsage_ReportsArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Report_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Report_Order_By>>;
  where?: Maybe<Project_Data_Usage_Report_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsUsage_Reports_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Report_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Report_Order_By>>;
  where?: Maybe<Project_Data_Usage_Report_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsVercel_Integration_ConnectionsArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Connections_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Connections_Order_By>>;
  where?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
};

/** Hasura projects */
export type ProjectsVercel_Integration_Connections_AggregateArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Connections_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Connections_Order_By>>;
  where?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
};

/** aggregated selection of "projects" */
export type Projects_Aggregate = {
  __typename?: 'projects_aggregate';
  aggregate?: Maybe<Projects_Aggregate_Fields>;
  nodes: Array<Projects>;
};

export type Projects_Aggregate_Bool_Exp = {
  count?: Maybe<Projects_Aggregate_Bool_Exp_Count>;
};

export type Projects_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Projects_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Projects_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "projects" */
export type Projects_Aggregate_Fields = {
  __typename?: 'projects_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Projects_Max_Fields>;
  min?: Maybe<Projects_Min_Fields>;
};

/** aggregate fields of "projects" */
export type Projects_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Projects_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "projects" */
export type Projects_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Projects_Max_Order_By>;
  min?: Maybe<Projects_Min_Order_By>;
};

/** input type for inserting array relation for remote table "projects" */
export type Projects_Arr_Rel_Insert_Input = {
  data: Array<Projects_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Projects_On_Conflict>;
};

/** Boolean expression to filter rows from the table "projects". All fields are combined with a logical 'AND'. */
export type Projects_Bool_Exp = {
  _and?: Maybe<Array<Projects_Bool_Exp>>;
  _not?: Maybe<Projects_Bool_Exp>;
  _or?: Maybe<Array<Projects_Bool_Exp>>;
  activities?: Maybe<Project_Activity_Bool_Exp>;
  activities_aggregate?: Maybe<Project_Activity_Aggregate_Bool_Exp>;
  alert_config?: Maybe<Alert_Config_Bool_Exp>;
  assigned_at?: Maybe<Timestamptz_Comparison_Exp>;
  azuremonitor_config?: Maybe<Azuremonitor_Config_Bool_Exp>;
  billing_manager?: Maybe<Users_Public_Bool_Exp>;
  billing_manager_id?: Maybe<Uuid_Comparison_Exp>;
  billing_plan_name?: Maybe<String_Comparison_Exp>;
  collaborators?: Maybe<Project_Collaborators_Bool_Exp>;
  collaborators_aggregate?: Maybe<Project_Collaborators_Aggregate_Bool_Exp>;
  console_oauth_id?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  current_month_data_usage?: Maybe<Bigint_Comparison_Exp>;
  datadog_config?: Maybe<Datadog_Config_Bool_Exp>;
  endpoint?: Maybe<String_Comparison_Exp>;
  enterprise_users?: Maybe<Enterprise_Users_Bool_Exp>;
  entitlements?: Maybe<Project_Entitlement_Access_Bool_Exp>;
  entitlements_aggregate?: Maybe<Project_Entitlement_Access_Aggregate_Bool_Exp>;
  heroku_integrations?: Maybe<Heroku_Integrations_Bool_Exp>;
  heroku_integrations_aggregate?: Maybe<Heroku_Integrations_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  invitations?: Maybe<Project_Collaborator_Invitations_Bool_Exp>;
  invitations_aggregate?: Maybe<Project_Collaborator_Invitations_Aggregate_Bool_Exp>;
  invoice_attempt_count?: Maybe<Int_Comparison_Exp>;
  invoice_status?: Maybe<String_Comparison_Exp>;
  jobs?: Maybe<Jobs_Bool_Exp>;
  jobs_aggregate?: Maybe<Jobs_Aggregate_Bool_Exp>;
  labels?: Maybe<Project_Labels_Bool_Exp>;
  labels_aggregate?: Maybe<Project_Labels_Aggregate_Bool_Exp>;
  metadata?: Maybe<Project_Metadata_Bool_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  newrelic_config?: Maybe<Newrelic_Config_Bool_Exp>;
  number_of_requests_this_month?: Maybe<Bigint_Comparison_Exp>;
  opentelemetry_config?: Maybe<Opentelemetry_Config_Bool_Exp>;
  owner?: Maybe<Users_Public_Bool_Exp>;
  owner_entitlements?: Maybe<User_Entitlement_Access_Bool_Exp>;
  owner_id?: Maybe<Uuid_Comparison_Exp>;
  ownership_transfer_invites?: Maybe<Project_Ownership_Transfer_Invitations_Bool_Exp>;
  ownership_transfer_invites_aggregate?: Maybe<Project_Ownership_Transfer_Invitations_Aggregate_Bool_Exp>;
  plan_name?: Maybe<String_Comparison_Exp>;
  policies?: Maybe<Policies_Bool_Exp>;
  policies_aggregate?: Maybe<Policies_Aggregate_Bool_Exp>;
  pro_key_generations?: Maybe<Projects_Pro_Key_Generations_Bool_Exp>;
  pro_key_generations_aggregate?: Maybe<Projects_Pro_Key_Generations_Aggregate_Bool_Exp>;
  project_billing_manager_invitations?: Maybe<Project_Billing_Manager_Invitations_Bool_Exp>;
  project_billing_manager_invitations_aggregate?: Maybe<Project_Billing_Manager_Invitations_Aggregate_Bool_Exp>;
  project_usage_prometheus?: Maybe<Project_Data_Usage_Prometheus_Bool_Exp>;
  project_usage_prometheus_aggregate?: Maybe<Project_Data_Usage_Prometheus_Aggregate_Bool_Exp>;
  project_usages?: Maybe<Project_Data_Usage_Bool_Exp>;
  project_usages_aggregate?: Maybe<Project_Data_Usage_Aggregate_Bool_Exp>;
  prometheus_config?: Maybe<Prometheus_Config_Bool_Exp>;
  server_oauth_id?: Maybe<String_Comparison_Exp>;
  tenant?: Maybe<Tenant_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  usage_reports?: Maybe<Project_Data_Usage_Report_Bool_Exp>;
  usage_reports_aggregate?: Maybe<Project_Data_Usage_Report_Aggregate_Bool_Exp>;
  vercel_integration_connections?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
  vercel_integration_connections_aggregate?: Maybe<Vercel_Integration_Connections_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "projects" */
export enum Projects_Constraint {
  /** unique or primary key constraint on columns "console_oauth_id" */
  ProjectsConsoleOauthIdKey = 'projects_console_oauth_id_key',
  /** unique or primary key constraint on columns "id" */
  ProjectsPkey = 'projects_pkey',
  /** unique or primary key constraint on columns "server_oauth_id" */
  ProjectsServerOauthIdKey = 'projects_server_oauth_id_key',
}

/** input type for inserting data into table "projects" */
export type Projects_Insert_Input = {
  activities?: Maybe<Project_Activity_Arr_Rel_Insert_Input>;
  alert_config?: Maybe<Alert_Config_Obj_Rel_Insert_Input>;
  assigned_at?: Maybe<Scalars['timestamptz']>;
  azuremonitor_config?: Maybe<Azuremonitor_Config_Obj_Rel_Insert_Input>;
  billing_manager?: Maybe<Users_Public_Obj_Rel_Insert_Input>;
  billing_manager_id?: Maybe<Scalars['uuid']>;
  collaborators?: Maybe<Project_Collaborators_Arr_Rel_Insert_Input>;
  console_oauth_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  datadog_config?: Maybe<Datadog_Config_Obj_Rel_Insert_Input>;
  endpoint?: Maybe<Scalars['String']>;
  enterprise_users?: Maybe<Enterprise_Users_Obj_Rel_Insert_Input>;
  entitlements?: Maybe<Project_Entitlement_Access_Arr_Rel_Insert_Input>;
  heroku_integrations?: Maybe<Heroku_Integrations_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  invitations?: Maybe<Project_Collaborator_Invitations_Arr_Rel_Insert_Input>;
  jobs?: Maybe<Jobs_Arr_Rel_Insert_Input>;
  labels?: Maybe<Project_Labels_Arr_Rel_Insert_Input>;
  metadata?: Maybe<Project_Metadata_Obj_Rel_Insert_Input>;
  name?: Maybe<Scalars['String']>;
  newrelic_config?: Maybe<Newrelic_Config_Obj_Rel_Insert_Input>;
  opentelemetry_config?: Maybe<Opentelemetry_Config_Obj_Rel_Insert_Input>;
  owner?: Maybe<Users_Public_Obj_Rel_Insert_Input>;
  owner_entitlements?: Maybe<User_Entitlement_Access_Obj_Rel_Insert_Input>;
  owner_id?: Maybe<Scalars['uuid']>;
  ownership_transfer_invites?: Maybe<Project_Ownership_Transfer_Invitations_Arr_Rel_Insert_Input>;
  plan_name?: Maybe<Scalars['String']>;
  policies?: Maybe<Policies_Arr_Rel_Insert_Input>;
  pro_key_generations?: Maybe<Projects_Pro_Key_Generations_Arr_Rel_Insert_Input>;
  project_billing_manager_invitations?: Maybe<Project_Billing_Manager_Invitations_Arr_Rel_Insert_Input>;
  project_usage_prometheus?: Maybe<Project_Data_Usage_Prometheus_Arr_Rel_Insert_Input>;
  project_usages?: Maybe<Project_Data_Usage_Arr_Rel_Insert_Input>;
  prometheus_config?: Maybe<Prometheus_Config_Obj_Rel_Insert_Input>;
  server_oauth_id?: Maybe<Scalars['String']>;
  tenant?: Maybe<Tenant_Obj_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  usage_reports?: Maybe<Project_Data_Usage_Report_Arr_Rel_Insert_Input>;
  vercel_integration_connections?: Maybe<Vercel_Integration_Connections_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Projects_Max_Fields = {
  __typename?: 'projects_max_fields';
  assigned_at?: Maybe<Scalars['timestamptz']>;
  billing_manager_id?: Maybe<Scalars['uuid']>;
  console_oauth_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  endpoint?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  owner_id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  server_oauth_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "projects" */
export type Projects_Max_Order_By = {
  assigned_at?: Maybe<Order_By>;
  billing_manager_id?: Maybe<Order_By>;
  console_oauth_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  endpoint?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  owner_id?: Maybe<Order_By>;
  plan_name?: Maybe<Order_By>;
  server_oauth_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Projects_Min_Fields = {
  __typename?: 'projects_min_fields';
  assigned_at?: Maybe<Scalars['timestamptz']>;
  billing_manager_id?: Maybe<Scalars['uuid']>;
  console_oauth_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  endpoint?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  owner_id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  server_oauth_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "projects" */
export type Projects_Min_Order_By = {
  assigned_at?: Maybe<Order_By>;
  billing_manager_id?: Maybe<Order_By>;
  console_oauth_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  endpoint?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  owner_id?: Maybe<Order_By>;
  plan_name?: Maybe<Order_By>;
  server_oauth_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "projects" */
export type Projects_Mutation_Response = {
  __typename?: 'projects_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Projects>;
};

/** input type for inserting object relation for remote table "projects" */
export type Projects_Obj_Rel_Insert_Input = {
  data: Projects_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Projects_On_Conflict>;
};

/** on_conflict condition type for table "projects" */
export type Projects_On_Conflict = {
  constraint: Projects_Constraint;
  update_columns?: Array<Projects_Update_Column>;
  where?: Maybe<Projects_Bool_Exp>;
};

/** Ordering options when selecting data from "projects". */
export type Projects_Order_By = {
  activities_aggregate?: Maybe<Project_Activity_Aggregate_Order_By>;
  alert_config?: Maybe<Alert_Config_Order_By>;
  assigned_at?: Maybe<Order_By>;
  azuremonitor_config?: Maybe<Azuremonitor_Config_Order_By>;
  billing_manager?: Maybe<Users_Public_Order_By>;
  billing_manager_id?: Maybe<Order_By>;
  billing_plan_name?: Maybe<Order_By>;
  collaborators_aggregate?: Maybe<Project_Collaborators_Aggregate_Order_By>;
  console_oauth_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  current_month_data_usage?: Maybe<Order_By>;
  datadog_config?: Maybe<Datadog_Config_Order_By>;
  endpoint?: Maybe<Order_By>;
  enterprise_users?: Maybe<Enterprise_Users_Order_By>;
  entitlements_aggregate?: Maybe<Project_Entitlement_Access_Aggregate_Order_By>;
  heroku_integrations_aggregate?: Maybe<Heroku_Integrations_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  invitations_aggregate?: Maybe<Project_Collaborator_Invitations_Aggregate_Order_By>;
  invoice_attempt_count?: Maybe<Order_By>;
  invoice_status?: Maybe<Order_By>;
  jobs_aggregate?: Maybe<Jobs_Aggregate_Order_By>;
  labels_aggregate?: Maybe<Project_Labels_Aggregate_Order_By>;
  metadata?: Maybe<Project_Metadata_Order_By>;
  name?: Maybe<Order_By>;
  newrelic_config?: Maybe<Newrelic_Config_Order_By>;
  number_of_requests_this_month?: Maybe<Order_By>;
  opentelemetry_config?: Maybe<Opentelemetry_Config_Order_By>;
  owner?: Maybe<Users_Public_Order_By>;
  owner_entitlements?: Maybe<User_Entitlement_Access_Order_By>;
  owner_id?: Maybe<Order_By>;
  ownership_transfer_invites_aggregate?: Maybe<Project_Ownership_Transfer_Invitations_Aggregate_Order_By>;
  plan_name?: Maybe<Order_By>;
  policies_aggregate?: Maybe<Policies_Aggregate_Order_By>;
  pro_key_generations_aggregate?: Maybe<Projects_Pro_Key_Generations_Aggregate_Order_By>;
  project_billing_manager_invitations_aggregate?: Maybe<Project_Billing_Manager_Invitations_Aggregate_Order_By>;
  project_usage_prometheus_aggregate?: Maybe<Project_Data_Usage_Prometheus_Aggregate_Order_By>;
  project_usages_aggregate?: Maybe<Project_Data_Usage_Aggregate_Order_By>;
  prometheus_config?: Maybe<Prometheus_Config_Order_By>;
  server_oauth_id?: Maybe<Order_By>;
  tenant?: Maybe<Tenant_Order_By>;
  updated_at?: Maybe<Order_By>;
  usage_reports_aggregate?: Maybe<Project_Data_Usage_Report_Aggregate_Order_By>;
  vercel_integration_connections_aggregate?: Maybe<Vercel_Integration_Connections_Aggregate_Order_By>;
};

/** primary key columns input for table: projects */
export type Projects_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** columns and relationships of "projects_pool_config" */
export type Projects_Pool_Config = {
  __typename?: 'projects_pool_config';
  cloud: Scalars['String'];
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  current_status?: Maybe<Project_Pool_Current_Status>;
  plan_name: Scalars['String'];
  region: Scalars['String'];
  size: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "projects_pool_config" */
export type Projects_Pool_Config_Aggregate = {
  __typename?: 'projects_pool_config_aggregate';
  aggregate?: Maybe<Projects_Pool_Config_Aggregate_Fields>;
  nodes: Array<Projects_Pool_Config>;
};

/** aggregate fields of "projects_pool_config" */
export type Projects_Pool_Config_Aggregate_Fields = {
  __typename?: 'projects_pool_config_aggregate_fields';
  avg?: Maybe<Projects_Pool_Config_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Projects_Pool_Config_Max_Fields>;
  min?: Maybe<Projects_Pool_Config_Min_Fields>;
  stddev?: Maybe<Projects_Pool_Config_Stddev_Fields>;
  stddev_pop?: Maybe<Projects_Pool_Config_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Projects_Pool_Config_Stddev_Samp_Fields>;
  sum?: Maybe<Projects_Pool_Config_Sum_Fields>;
  var_pop?: Maybe<Projects_Pool_Config_Var_Pop_Fields>;
  var_samp?: Maybe<Projects_Pool_Config_Var_Samp_Fields>;
  variance?: Maybe<Projects_Pool_Config_Variance_Fields>;
};

/** aggregate fields of "projects_pool_config" */
export type Projects_Pool_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Projects_Pool_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Projects_Pool_Config_Avg_Fields = {
  __typename?: 'projects_pool_config_avg_fields';
  size?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "projects_pool_config". All fields are combined with a logical 'AND'. */
export type Projects_Pool_Config_Bool_Exp = {
  _and?: Maybe<Array<Projects_Pool_Config_Bool_Exp>>;
  _not?: Maybe<Projects_Pool_Config_Bool_Exp>;
  _or?: Maybe<Array<Projects_Pool_Config_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  current_status?: Maybe<Project_Pool_Current_Status_Bool_Exp>;
  plan_name?: Maybe<String_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  size?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "projects_pool_config" */
export enum Projects_Pool_Config_Constraint {
  /** unique or primary key constraint on columns "cloud", "region", "plan_name" */
  ProjectsPoolConfigPkey = 'projects_pool_config_pkey',
}

/** input type for incrementing numeric columns in table "projects_pool_config" */
export type Projects_Pool_Config_Inc_Input = {
  size?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "projects_pool_config" */
export type Projects_Pool_Config_Insert_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  current_status?: Maybe<Project_Pool_Current_Status_Obj_Rel_Insert_Input>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Projects_Pool_Config_Max_Fields = {
  __typename?: 'projects_pool_config_max_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Projects_Pool_Config_Min_Fields = {
  __typename?: 'projects_pool_config_min_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "projects_pool_config" */
export type Projects_Pool_Config_Mutation_Response = {
  __typename?: 'projects_pool_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Projects_Pool_Config>;
};

/** on_conflict condition type for table "projects_pool_config" */
export type Projects_Pool_Config_On_Conflict = {
  constraint: Projects_Pool_Config_Constraint;
  update_columns?: Array<Projects_Pool_Config_Update_Column>;
  where?: Maybe<Projects_Pool_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "projects_pool_config". */
export type Projects_Pool_Config_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  current_status?: Maybe<Project_Pool_Current_Status_Order_By>;
  plan_name?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  size?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: projects_pool_config */
export type Projects_Pool_Config_Pk_Columns_Input = {
  cloud: Scalars['String'];
  plan_name: Scalars['String'];
  region: Scalars['String'];
};

/** select columns of table "projects_pool_config" */
export enum Projects_Pool_Config_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  PlanName = 'plan_name',
  /** column name */
  Region = 'region',
  /** column name */
  Size = 'size',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "projects_pool_config" */
export type Projects_Pool_Config_Set_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Projects_Pool_Config_Stddev_Fields = {
  __typename?: 'projects_pool_config_stddev_fields';
  size?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Projects_Pool_Config_Stddev_Pop_Fields = {
  __typename?: 'projects_pool_config_stddev_pop_fields';
  size?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Projects_Pool_Config_Stddev_Samp_Fields = {
  __typename?: 'projects_pool_config_stddev_samp_fields';
  size?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "projects_pool_config" */
export type Projects_Pool_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Projects_Pool_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Projects_Pool_Config_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  size?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Projects_Pool_Config_Sum_Fields = {
  __typename?: 'projects_pool_config_sum_fields';
  size?: Maybe<Scalars['Int']>;
};

/** update columns of table "projects_pool_config" */
export enum Projects_Pool_Config_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  PlanName = 'plan_name',
  /** column name */
  Region = 'region',
  /** column name */
  Size = 'size',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Projects_Pool_Config_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Projects_Pool_Config_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Projects_Pool_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Projects_Pool_Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Projects_Pool_Config_Var_Pop_Fields = {
  __typename?: 'projects_pool_config_var_pop_fields';
  size?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Projects_Pool_Config_Var_Samp_Fields = {
  __typename?: 'projects_pool_config_var_samp_fields';
  size?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Projects_Pool_Config_Variance_Fields = {
  __typename?: 'projects_pool_config_variance_fields';
  size?: Maybe<Scalars['Float']>;
};

/** Captures pro keys for a project */
export type Projects_Pro_Key_Generations = {
  __typename?: 'projects_pro_key_generations';
  generated_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
};

/** aggregated selection of "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_Aggregate = {
  __typename?: 'projects_pro_key_generations_aggregate';
  aggregate?: Maybe<Projects_Pro_Key_Generations_Aggregate_Fields>;
  nodes: Array<Projects_Pro_Key_Generations>;
};

export type Projects_Pro_Key_Generations_Aggregate_Bool_Exp = {
  count?: Maybe<Projects_Pro_Key_Generations_Aggregate_Bool_Exp_Count>;
};

export type Projects_Pro_Key_Generations_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Projects_Pro_Key_Generations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Projects_Pro_Key_Generations_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_Aggregate_Fields = {
  __typename?: 'projects_pro_key_generations_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Projects_Pro_Key_Generations_Max_Fields>;
  min?: Maybe<Projects_Pro_Key_Generations_Min_Fields>;
};

/** aggregate fields of "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Projects_Pro_Key_Generations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Projects_Pro_Key_Generations_Max_Order_By>;
  min?: Maybe<Projects_Pro_Key_Generations_Min_Order_By>;
};

/** input type for inserting array relation for remote table "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_Arr_Rel_Insert_Input = {
  data: Array<Projects_Pro_Key_Generations_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Projects_Pro_Key_Generations_On_Conflict>;
};

/**
 * Boolean expression to filter rows from the table "projects_pro_key_generations".
 * All fields are combined with a logical 'AND'.
 */
export type Projects_Pro_Key_Generations_Bool_Exp = {
  _and?: Maybe<Array<Projects_Pro_Key_Generations_Bool_Exp>>;
  _not?: Maybe<Projects_Pro_Key_Generations_Bool_Exp>;
  _or?: Maybe<Array<Projects_Pro_Key_Generations_Bool_Exp>>;
  generated_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "projects_pro_key_generations" */
export enum Projects_Pro_Key_Generations_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProjectsProKeyGenerationsPkey = 'projects_pro_key_generations_pkey',
}

/** input type for inserting data into table "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_Insert_Input = {
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Projects_Pro_Key_Generations_Max_Fields = {
  __typename?: 'projects_pro_key_generations_max_fields';
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_Max_Order_By = {
  generated_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Projects_Pro_Key_Generations_Min_Fields = {
  __typename?: 'projects_pro_key_generations_min_fields';
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_Min_Order_By = {
  generated_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_Mutation_Response = {
  __typename?: 'projects_pro_key_generations_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Projects_Pro_Key_Generations>;
};

/** on_conflict condition type for table "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_On_Conflict = {
  constraint: Projects_Pro_Key_Generations_Constraint;
  update_columns?: Array<Projects_Pro_Key_Generations_Update_Column>;
  where?: Maybe<Projects_Pro_Key_Generations_Bool_Exp>;
};

/** Ordering options when selecting data from "projects_pro_key_generations". */
export type Projects_Pro_Key_Generations_Order_By = {
  generated_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
};

/** primary key columns input for table: projects_pro_key_generations */
export type Projects_Pro_Key_Generations_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "projects_pro_key_generations" */
export enum Projects_Pro_Key_Generations_Select_Column {
  /** column name */
  GeneratedAt = 'generated_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
}

/** input type for updating data in table "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_Set_Input = {
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "projects_pro_key_generations" */
export type Projects_Pro_Key_Generations_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Projects_Pro_Key_Generations_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Projects_Pro_Key_Generations_Stream_Cursor_Value_Input = {
  generated_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "projects_pro_key_generations" */
export enum Projects_Pro_Key_Generations_Update_Column {
  /** column name */
  GeneratedAt = 'generated_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
}

export type Projects_Pro_Key_Generations_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Projects_Pro_Key_Generations_Set_Input>;
  /** filter the rows which have to be updated */
  where: Projects_Pro_Key_Generations_Bool_Exp;
};

/** select columns of table "projects" */
export enum Projects_Select_Column {
  /** column name */
  AssignedAt = 'assigned_at',
  /** column name */
  BillingManagerId = 'billing_manager_id',
  /** column name */
  ConsoleOauthId = 'console_oauth_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  PlanName = 'plan_name',
  /** column name */
  ServerOauthId = 'server_oauth_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "projects" */
export type Projects_Set_Input = {
  assigned_at?: Maybe<Scalars['timestamptz']>;
  billing_manager_id?: Maybe<Scalars['uuid']>;
  console_oauth_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  endpoint?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  owner_id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  server_oauth_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "projects" */
export type Projects_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Projects_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Projects_Stream_Cursor_Value_Input = {
  assigned_at?: Maybe<Scalars['timestamptz']>;
  billing_manager_id?: Maybe<Scalars['uuid']>;
  console_oauth_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  endpoint?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  owner_id?: Maybe<Scalars['uuid']>;
  plan_name?: Maybe<Scalars['String']>;
  server_oauth_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "projects" */
export enum Projects_Update_Column {
  /** column name */
  AssignedAt = 'assigned_at',
  /** column name */
  BillingManagerId = 'billing_manager_id',
  /** column name */
  ConsoleOauthId = 'console_oauth_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'owner_id',
  /** column name */
  PlanName = 'plan_name',
  /** column name */
  ServerOauthId = 'server_oauth_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Projects_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Projects_Set_Input>;
  /** filter the rows which have to be updated */
  where: Projects_Bool_Exp;
};

/** columns and relationships of "projects_with_no_running_deployments" */
export type Projects_With_No_Running_Deployments = {
  __typename?: 'projects_with_no_running_deployments';
  /** An array relationship */
  jobs: Array<Jobs>;
  /** An aggregate relationship */
  jobs_aggregate: Jobs_Aggregate;
  project_id?: Maybe<Scalars['uuid']>;
};

/** columns and relationships of "projects_with_no_running_deployments" */
export type Projects_With_No_Running_DeploymentsJobsArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};

/** columns and relationships of "projects_with_no_running_deployments" */
export type Projects_With_No_Running_DeploymentsJobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};

/** aggregated selection of "projects_with_no_running_deployments" */
export type Projects_With_No_Running_Deployments_Aggregate = {
  __typename?: 'projects_with_no_running_deployments_aggregate';
  aggregate?: Maybe<Projects_With_No_Running_Deployments_Aggregate_Fields>;
  nodes: Array<Projects_With_No_Running_Deployments>;
};

/** aggregate fields of "projects_with_no_running_deployments" */
export type Projects_With_No_Running_Deployments_Aggregate_Fields = {
  __typename?: 'projects_with_no_running_deployments_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Projects_With_No_Running_Deployments_Max_Fields>;
  min?: Maybe<Projects_With_No_Running_Deployments_Min_Fields>;
};

/** aggregate fields of "projects_with_no_running_deployments" */
export type Projects_With_No_Running_Deployments_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Projects_With_No_Running_Deployments_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/**
 * Boolean expression to filter rows from the table
 * "projects_with_no_running_deployments". All fields are combined with a logical 'AND'.
 */
export type Projects_With_No_Running_Deployments_Bool_Exp = {
  _and?: Maybe<Array<Projects_With_No_Running_Deployments_Bool_Exp>>;
  _not?: Maybe<Projects_With_No_Running_Deployments_Bool_Exp>;
  _or?: Maybe<Array<Projects_With_No_Running_Deployments_Bool_Exp>>;
  jobs?: Maybe<Jobs_Bool_Exp>;
  jobs_aggregate?: Maybe<Jobs_Aggregate_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
};

/** aggregate max on columns */
export type Projects_With_No_Running_Deployments_Max_Fields = {
  __typename?: 'projects_with_no_running_deployments_max_fields';
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Projects_With_No_Running_Deployments_Min_Fields = {
  __typename?: 'projects_with_no_running_deployments_min_fields';
  project_id?: Maybe<Scalars['uuid']>;
};

/** Ordering options when selecting data from "projects_with_no_running_deployments". */
export type Projects_With_No_Running_Deployments_Order_By = {
  jobs_aggregate?: Maybe<Jobs_Aggregate_Order_By>;
  project_id?: Maybe<Order_By>;
};

/** select columns of table "projects_with_no_running_deployments" */
export enum Projects_With_No_Running_Deployments_Select_Column {
  /** column name */
  ProjectId = 'project_id',
}

/** Streaming cursor of the table "projects_with_no_running_deployments" */
export type Projects_With_No_Running_Deployments_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Projects_With_No_Running_Deployments_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Projects_With_No_Running_Deployments_Stream_Cursor_Value_Input = {
  project_id?: Maybe<Scalars['uuid']>;
};

/** columns and relationships of "projects_with_no_running_preview_app" */
export type Projects_With_No_Running_Preview_App = {
  __typename?: 'projects_with_no_running_preview_app';
  /** An array relationship */
  jobs: Array<Jobs>;
  /** An aggregate relationship */
  jobs_aggregate: Jobs_Aggregate;
  project_name?: Maybe<Scalars['String']>;
};

/** columns and relationships of "projects_with_no_running_preview_app" */
export type Projects_With_No_Running_Preview_AppJobsArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};

/** columns and relationships of "projects_with_no_running_preview_app" */
export type Projects_With_No_Running_Preview_AppJobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};

/** aggregated selection of "projects_with_no_running_preview_app" */
export type Projects_With_No_Running_Preview_App_Aggregate = {
  __typename?: 'projects_with_no_running_preview_app_aggregate';
  aggregate?: Maybe<Projects_With_No_Running_Preview_App_Aggregate_Fields>;
  nodes: Array<Projects_With_No_Running_Preview_App>;
};

/** aggregate fields of "projects_with_no_running_preview_app" */
export type Projects_With_No_Running_Preview_App_Aggregate_Fields = {
  __typename?: 'projects_with_no_running_preview_app_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Projects_With_No_Running_Preview_App_Max_Fields>;
  min?: Maybe<Projects_With_No_Running_Preview_App_Min_Fields>;
};

/** aggregate fields of "projects_with_no_running_preview_app" */
export type Projects_With_No_Running_Preview_App_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Projects_With_No_Running_Preview_App_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/**
 * Boolean expression to filter rows from the table
 * "projects_with_no_running_preview_app". All fields are combined with a logical 'AND'.
 */
export type Projects_With_No_Running_Preview_App_Bool_Exp = {
  _and?: Maybe<Array<Projects_With_No_Running_Preview_App_Bool_Exp>>;
  _not?: Maybe<Projects_With_No_Running_Preview_App_Bool_Exp>;
  _or?: Maybe<Array<Projects_With_No_Running_Preview_App_Bool_Exp>>;
  jobs?: Maybe<Jobs_Bool_Exp>;
  jobs_aggregate?: Maybe<Jobs_Aggregate_Bool_Exp>;
  project_name?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Projects_With_No_Running_Preview_App_Max_Fields = {
  __typename?: 'projects_with_no_running_preview_app_max_fields';
  project_name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Projects_With_No_Running_Preview_App_Min_Fields = {
  __typename?: 'projects_with_no_running_preview_app_min_fields';
  project_name?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "projects_with_no_running_preview_app". */
export type Projects_With_No_Running_Preview_App_Order_By = {
  jobs_aggregate?: Maybe<Jobs_Aggregate_Order_By>;
  project_name?: Maybe<Order_By>;
};

/** select columns of table "projects_with_no_running_preview_app" */
export enum Projects_With_No_Running_Preview_App_Select_Column {
  /** column name */
  ProjectName = 'project_name',
}

/** Streaming cursor of the table "projects_with_no_running_preview_app" */
export type Projects_With_No_Running_Preview_App_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Projects_With_No_Running_Preview_App_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Projects_With_No_Running_Preview_App_Stream_Cursor_Value_Input = {
  project_name?: Maybe<Scalars['String']>;
};

export type ProjectUsage = {
  __typename?: 'ProjectUsage';
  additional_data_usage: Scalars['Int'];
  approx_cost: Scalars['Int'];
  downgrade_dates: Array<Scalars['Int']>;
  no_pay_days: Scalars['Int'];
  project_id: Scalars['uuid'];
  project_name: Scalars['String'];
  tier_at_month_start: Scalars['String'];
  upgrade_dates: Array<Scalars['Int']>;
  usage: Scalars['Int'];
};

export type ProjectUsageInput = {
  from_date?: Maybe<Scalars['timetz']>;
  to_date?: Maybe<Scalars['timetz']>;
  user_id: Scalars['uuid'];
};

/** Prometheus Exporter Config */
export type Prometheus_Config = {
  __typename?: 'prometheus_config';
  access_token: Scalars['String'];
  created_at: Scalars['timestamptz'];
  labels: Scalars['jsonb'];
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  namespace?: Maybe<Scalars['String']>;
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
};

/** Prometheus Exporter Config */
export type Prometheus_ConfigLabelsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "prometheus_config" */
export type Prometheus_Config_Aggregate = {
  __typename?: 'prometheus_config_aggregate';
  aggregate?: Maybe<Prometheus_Config_Aggregate_Fields>;
  nodes: Array<Prometheus_Config>;
};

/** aggregate fields of "prometheus_config" */
export type Prometheus_Config_Aggregate_Fields = {
  __typename?: 'prometheus_config_aggregate_fields';
  avg?: Maybe<Prometheus_Config_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Prometheus_Config_Max_Fields>;
  min?: Maybe<Prometheus_Config_Min_Fields>;
  stddev?: Maybe<Prometheus_Config_Stddev_Fields>;
  stddev_pop?: Maybe<Prometheus_Config_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Prometheus_Config_Stddev_Samp_Fields>;
  sum?: Maybe<Prometheus_Config_Sum_Fields>;
  var_pop?: Maybe<Prometheus_Config_Var_Pop_Fields>;
  var_samp?: Maybe<Prometheus_Config_Var_Samp_Fields>;
  variance?: Maybe<Prometheus_Config_Variance_Fields>;
};

/** aggregate fields of "prometheus_config" */
export type Prometheus_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Prometheus_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Prometheus_Config_Append_Input = {
  labels?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Prometheus_Config_Avg_Fields = {
  __typename?: 'prometheus_config_avg_fields';
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "prometheus_config". All fields are combined with a logical 'AND'. */
export type Prometheus_Config_Bool_Exp = {
  _and?: Maybe<Array<Prometheus_Config_Bool_Exp>>;
  _not?: Maybe<Prometheus_Config_Bool_Exp>;
  _or?: Maybe<Array<Prometheus_Config_Bool_Exp>>;
  access_token?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  labels?: Maybe<Jsonb_Comparison_Exp>;
  metrics_last_logged?: Maybe<Timestamptz_Comparison_Exp>;
  metrics_response_code?: Maybe<Int_Comparison_Exp>;
  namespace?: Maybe<String_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "prometheus_config" */
export enum Prometheus_Config_Constraint {
  /** unique or primary key constraint on columns "project_id" */
  PrometheusConfigPkey = 'prometheus_config_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Prometheus_Config_Delete_At_Path_Input = {
  labels?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Prometheus_Config_Delete_Elem_Input = {
  labels?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Prometheus_Config_Delete_Key_Input = {
  labels?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "prometheus_config" */
export type Prometheus_Config_Inc_Input = {
  metrics_response_code?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "prometheus_config" */
export type Prometheus_Config_Insert_Input = {
  access_token?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  labels?: Maybe<Scalars['jsonb']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  namespace?: Maybe<Scalars['String']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Prometheus_Config_Max_Fields = {
  __typename?: 'prometheus_config_max_fields';
  access_token?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  namespace?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Prometheus_Config_Min_Fields = {
  __typename?: 'prometheus_config_min_fields';
  access_token?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  namespace?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "prometheus_config" */
export type Prometheus_Config_Mutation_Response = {
  __typename?: 'prometheus_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Prometheus_Config>;
};

/** input type for inserting object relation for remote table "prometheus_config" */
export type Prometheus_Config_Obj_Rel_Insert_Input = {
  data: Prometheus_Config_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Prometheus_Config_On_Conflict>;
};

/** on_conflict condition type for table "prometheus_config" */
export type Prometheus_Config_On_Conflict = {
  constraint: Prometheus_Config_Constraint;
  update_columns?: Array<Prometheus_Config_Update_Column>;
  where?: Maybe<Prometheus_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "prometheus_config". */
export type Prometheus_Config_Order_By = {
  access_token?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  labels?: Maybe<Order_By>;
  metrics_last_logged?: Maybe<Order_By>;
  metrics_response_code?: Maybe<Order_By>;
  namespace?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
};

/** primary key columns input for table: prometheus_config */
export type Prometheus_Config_Pk_Columns_Input = {
  project_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Prometheus_Config_Prepend_Input = {
  labels?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "prometheus_config" */
export enum Prometheus_Config_Select_Column {
  /** column name */
  AccessToken = 'access_token',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Labels = 'labels',
  /** column name */
  MetricsLastLogged = 'metrics_last_logged',
  /** column name */
  MetricsResponseCode = 'metrics_response_code',
  /** column name */
  Namespace = 'namespace',
  /** column name */
  ProjectId = 'project_id',
}

/** input type for updating data in table "prometheus_config" */
export type Prometheus_Config_Set_Input = {
  access_token?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  labels?: Maybe<Scalars['jsonb']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  namespace?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Prometheus_Config_Stddev_Fields = {
  __typename?: 'prometheus_config_stddev_fields';
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Prometheus_Config_Stddev_Pop_Fields = {
  __typename?: 'prometheus_config_stddev_pop_fields';
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Prometheus_Config_Stddev_Samp_Fields = {
  __typename?: 'prometheus_config_stddev_samp_fields';
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "prometheus_config" */
export type Prometheus_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Prometheus_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Prometheus_Config_Stream_Cursor_Value_Input = {
  access_token?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  labels?: Maybe<Scalars['jsonb']>;
  metrics_last_logged?: Maybe<Scalars['timestamptz']>;
  metrics_response_code?: Maybe<Scalars['Int']>;
  namespace?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Prometheus_Config_Sum_Fields = {
  __typename?: 'prometheus_config_sum_fields';
  metrics_response_code?: Maybe<Scalars['Int']>;
};

/** update columns of table "prometheus_config" */
export enum Prometheus_Config_Update_Column {
  /** column name */
  AccessToken = 'access_token',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Labels = 'labels',
  /** column name */
  MetricsLastLogged = 'metrics_last_logged',
  /** column name */
  MetricsResponseCode = 'metrics_response_code',
  /** column name */
  Namespace = 'namespace',
  /** column name */
  ProjectId = 'project_id',
}

export type Prometheus_Config_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Prometheus_Config_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Prometheus_Config_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Prometheus_Config_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Prometheus_Config_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Prometheus_Config_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Prometheus_Config_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Prometheus_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Prometheus_Config_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Prometheus_Config_Var_Pop_Fields = {
  __typename?: 'prometheus_config_var_pop_fields';
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Prometheus_Config_Var_Samp_Fields = {
  __typename?: 'prometheus_config_var_samp_fields';
  metrics_response_code?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Prometheus_Config_Variance_Fields = {
  __typename?: 'prometheus_config_variance_fields';
  metrics_response_code?: Maybe<Scalars['Float']>;
};

export type PrometheusConfigResponse = {
  __typename?: 'PrometheusConfigResponse';
  access_token?: Maybe<Scalars['String']>;
  project_id: Scalars['uuid'];
};

export type PrometheusQueryBetween = {
  end: Scalars['timestamptz'];
  start: Scalars['timestamptz'];
};

export type PrometheusQueryTime = {
  between?: Maybe<PrometheusQueryBetween>;
  last?: Maybe<PrometheusTimeDuration>;
};

export type PrometheusTimeDuration = {
  number: Scalars['Int'];
  unit: PrometheusTimeDurationUnit;
};

export enum PrometheusTimeDurationUnit {
  D = 'd',
  H = 'h',
  M = 'm',
  Ms = 'ms',
  S = 's',
  W = 'w',
  Y = 'y',
}

/** Captures oauth2 integration */
export type Providers = {
  __typename?: 'providers';
  id: Scalars['Int'];
  oauth2_access_token: Scalars['String'];
  oauth2_expiry: Scalars['timestamptz'];
  oauth2_provider: Scalars['String'];
  oauth2_refresh_token: Scalars['String'];
  oauth2_uid: Scalars['String'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['uuid'];
};

/** aggregated selection of "providers" */
export type Providers_Aggregate = {
  __typename?: 'providers_aggregate';
  aggregate?: Maybe<Providers_Aggregate_Fields>;
  nodes: Array<Providers>;
};

export type Providers_Aggregate_Bool_Exp = {
  count?: Maybe<Providers_Aggregate_Bool_Exp_Count>;
};

export type Providers_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Providers_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Providers_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "providers" */
export type Providers_Aggregate_Fields = {
  __typename?: 'providers_aggregate_fields';
  avg?: Maybe<Providers_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Providers_Max_Fields>;
  min?: Maybe<Providers_Min_Fields>;
  stddev?: Maybe<Providers_Stddev_Fields>;
  stddev_pop?: Maybe<Providers_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Providers_Stddev_Samp_Fields>;
  sum?: Maybe<Providers_Sum_Fields>;
  var_pop?: Maybe<Providers_Var_Pop_Fields>;
  var_samp?: Maybe<Providers_Var_Samp_Fields>;
  variance?: Maybe<Providers_Variance_Fields>;
};

/** aggregate fields of "providers" */
export type Providers_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Providers_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "providers" */
export type Providers_Aggregate_Order_By = {
  avg?: Maybe<Providers_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Providers_Max_Order_By>;
  min?: Maybe<Providers_Min_Order_By>;
  stddev?: Maybe<Providers_Stddev_Order_By>;
  stddev_pop?: Maybe<Providers_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Providers_Stddev_Samp_Order_By>;
  sum?: Maybe<Providers_Sum_Order_By>;
  var_pop?: Maybe<Providers_Var_Pop_Order_By>;
  var_samp?: Maybe<Providers_Var_Samp_Order_By>;
  variance?: Maybe<Providers_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "providers" */
export type Providers_Arr_Rel_Insert_Input = {
  data: Array<Providers_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Providers_On_Conflict>;
};

/** aggregate avg on columns */
export type Providers_Avg_Fields = {
  __typename?: 'providers_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "providers" */
export type Providers_Avg_Order_By = {
  id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "providers". All fields are combined with a logical 'AND'. */
export type Providers_Bool_Exp = {
  _and?: Maybe<Array<Providers_Bool_Exp>>;
  _not?: Maybe<Providers_Bool_Exp>;
  _or?: Maybe<Array<Providers_Bool_Exp>>;
  id?: Maybe<Int_Comparison_Exp>;
  oauth2_access_token?: Maybe<String_Comparison_Exp>;
  oauth2_expiry?: Maybe<Timestamptz_Comparison_Exp>;
  oauth2_provider?: Maybe<String_Comparison_Exp>;
  oauth2_refresh_token?: Maybe<String_Comparison_Exp>;
  oauth2_uid?: Maybe<String_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "providers" */
export enum Providers_Constraint {
  /** unique or primary key constraint on columns "id" */
  ProvidersPkey = 'providers_pkey',
  /** unique or primary key constraint on columns "oauth2_provider", "user_id" */
  ProvidersUserIdOauth2ProviderKey = 'providers_user_id_oauth2_provider_key',
}

/** input type for incrementing numeric columns in table "providers" */
export type Providers_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "providers" */
export type Providers_Insert_Input = {
  id?: Maybe<Scalars['Int']>;
  oauth2_access_token?: Maybe<Scalars['String']>;
  oauth2_expiry?: Maybe<Scalars['timestamptz']>;
  oauth2_provider?: Maybe<Scalars['String']>;
  oauth2_refresh_token?: Maybe<Scalars['String']>;
  oauth2_uid?: Maybe<Scalars['String']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Providers_Max_Fields = {
  __typename?: 'providers_max_fields';
  id?: Maybe<Scalars['Int']>;
  oauth2_access_token?: Maybe<Scalars['String']>;
  oauth2_expiry?: Maybe<Scalars['timestamptz']>;
  oauth2_provider?: Maybe<Scalars['String']>;
  oauth2_refresh_token?: Maybe<Scalars['String']>;
  oauth2_uid?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "providers" */
export type Providers_Max_Order_By = {
  id?: Maybe<Order_By>;
  oauth2_access_token?: Maybe<Order_By>;
  oauth2_expiry?: Maybe<Order_By>;
  oauth2_provider?: Maybe<Order_By>;
  oauth2_refresh_token?: Maybe<Order_By>;
  oauth2_uid?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Providers_Min_Fields = {
  __typename?: 'providers_min_fields';
  id?: Maybe<Scalars['Int']>;
  oauth2_access_token?: Maybe<Scalars['String']>;
  oauth2_expiry?: Maybe<Scalars['timestamptz']>;
  oauth2_provider?: Maybe<Scalars['String']>;
  oauth2_refresh_token?: Maybe<Scalars['String']>;
  oauth2_uid?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "providers" */
export type Providers_Min_Order_By = {
  id?: Maybe<Order_By>;
  oauth2_access_token?: Maybe<Order_By>;
  oauth2_expiry?: Maybe<Order_By>;
  oauth2_provider?: Maybe<Order_By>;
  oauth2_refresh_token?: Maybe<Order_By>;
  oauth2_uid?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "providers" */
export type Providers_Mutation_Response = {
  __typename?: 'providers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Providers>;
};

/** on_conflict condition type for table "providers" */
export type Providers_On_Conflict = {
  constraint: Providers_Constraint;
  update_columns?: Array<Providers_Update_Column>;
  where?: Maybe<Providers_Bool_Exp>;
};

/** Ordering options when selecting data from "providers". */
export type Providers_Order_By = {
  id?: Maybe<Order_By>;
  oauth2_access_token?: Maybe<Order_By>;
  oauth2_expiry?: Maybe<Order_By>;
  oauth2_provider?: Maybe<Order_By>;
  oauth2_refresh_token?: Maybe<Order_By>;
  oauth2_uid?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: providers */
export type Providers_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "providers" */
export enum Providers_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Oauth2AccessToken = 'oauth2_access_token',
  /** column name */
  Oauth2Expiry = 'oauth2_expiry',
  /** column name */
  Oauth2Provider = 'oauth2_provider',
  /** column name */
  Oauth2RefreshToken = 'oauth2_refresh_token',
  /** column name */
  Oauth2Uid = 'oauth2_uid',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "providers" */
export type Providers_Set_Input = {
  id?: Maybe<Scalars['Int']>;
  oauth2_access_token?: Maybe<Scalars['String']>;
  oauth2_expiry?: Maybe<Scalars['timestamptz']>;
  oauth2_provider?: Maybe<Scalars['String']>;
  oauth2_refresh_token?: Maybe<Scalars['String']>;
  oauth2_uid?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Providers_Stddev_Fields = {
  __typename?: 'providers_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "providers" */
export type Providers_Stddev_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Providers_Stddev_Pop_Fields = {
  __typename?: 'providers_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "providers" */
export type Providers_Stddev_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Providers_Stddev_Samp_Fields = {
  __typename?: 'providers_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "providers" */
export type Providers_Stddev_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** Streaming cursor of the table "providers" */
export type Providers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Providers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Providers_Stream_Cursor_Value_Input = {
  id?: Maybe<Scalars['Int']>;
  oauth2_access_token?: Maybe<Scalars['String']>;
  oauth2_expiry?: Maybe<Scalars['timestamptz']>;
  oauth2_provider?: Maybe<Scalars['String']>;
  oauth2_refresh_token?: Maybe<Scalars['String']>;
  oauth2_uid?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Providers_Sum_Fields = {
  __typename?: 'providers_sum_fields';
  id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "providers" */
export type Providers_Sum_Order_By = {
  id?: Maybe<Order_By>;
};

/** update columns of table "providers" */
export enum Providers_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  Oauth2AccessToken = 'oauth2_access_token',
  /** column name */
  Oauth2Expiry = 'oauth2_expiry',
  /** column name */
  Oauth2Provider = 'oauth2_provider',
  /** column name */
  Oauth2RefreshToken = 'oauth2_refresh_token',
  /** column name */
  Oauth2Uid = 'oauth2_uid',
  /** column name */
  UserId = 'user_id',
}

export type Providers_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Providers_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Providers_Set_Input>;
  /** filter the rows which have to be updated */
  where: Providers_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Providers_Var_Pop_Fields = {
  __typename?: 'providers_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "providers" */
export type Providers_Var_Pop_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Providers_Var_Samp_Fields = {
  __typename?: 'providers_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "providers" */
export type Providers_Var_Samp_Order_By = {
  id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Providers_Variance_Fields = {
  __typename?: 'providers_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "providers" */
export type Providers_Variance_Order_By = {
  id?: Maybe<Order_By>;
};

/** Different provisioning options for cloud resources */
export type Provisioning = {
  __typename?: 'provisioning';
  description: Scalars['String'];
  provisioning: Scalars['String'];
};

/** aggregated selection of "provisioning" */
export type Provisioning_Aggregate = {
  __typename?: 'provisioning_aggregate';
  aggregate?: Maybe<Provisioning_Aggregate_Fields>;
  nodes: Array<Provisioning>;
};

/** aggregate fields of "provisioning" */
export type Provisioning_Aggregate_Fields = {
  __typename?: 'provisioning_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Provisioning_Max_Fields>;
  min?: Maybe<Provisioning_Min_Fields>;
};

/** aggregate fields of "provisioning" */
export type Provisioning_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Provisioning_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "provisioning". All fields are combined with a logical 'AND'. */
export type Provisioning_Bool_Exp = {
  _and?: Maybe<Array<Provisioning_Bool_Exp>>;
  _not?: Maybe<Provisioning_Bool_Exp>;
  _or?: Maybe<Array<Provisioning_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  provisioning?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "provisioning" */
export enum Provisioning_Constraint {
  /** unique or primary key constraint on columns "provisioning" */
  ProvisioningPkey = 'provisioning_pkey',
}

export enum Provisioning_Enum {
  /** Manual provisioning of resources. The event-trigger/taskq should skip execution if the provisioning is marked as manual */
  Manual = 'manual',
  /** Provisioning is done by event-triggers/taskq */
  SelfServe = 'self_serve',
}

/** Boolean expression to compare columns of type "provisioning_enum". All fields are combined with logical 'AND'. */
export type Provisioning_Enum_Comparison_Exp = {
  _eq?: Maybe<Provisioning_Enum>;
  _in?: Maybe<Array<Provisioning_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Provisioning_Enum>;
  _nin?: Maybe<Array<Provisioning_Enum>>;
};

/** input type for inserting data into table "provisioning" */
export type Provisioning_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  provisioning?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Provisioning_Max_Fields = {
  __typename?: 'provisioning_max_fields';
  description?: Maybe<Scalars['String']>;
  provisioning?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Provisioning_Min_Fields = {
  __typename?: 'provisioning_min_fields';
  description?: Maybe<Scalars['String']>;
  provisioning?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "provisioning" */
export type Provisioning_Mutation_Response = {
  __typename?: 'provisioning_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Provisioning>;
};

/** on_conflict condition type for table "provisioning" */
export type Provisioning_On_Conflict = {
  constraint: Provisioning_Constraint;
  update_columns?: Array<Provisioning_Update_Column>;
  where?: Maybe<Provisioning_Bool_Exp>;
};

/** Ordering options when selecting data from "provisioning". */
export type Provisioning_Order_By = {
  description?: Maybe<Order_By>;
  provisioning?: Maybe<Order_By>;
};

/** primary key columns input for table: provisioning */
export type Provisioning_Pk_Columns_Input = {
  provisioning: Scalars['String'];
};

/** select columns of table "provisioning" */
export enum Provisioning_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Provisioning = 'provisioning',
}

/** input type for updating data in table "provisioning" */
export type Provisioning_Set_Input = {
  description?: Maybe<Scalars['String']>;
  provisioning?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "provisioning" */
export type Provisioning_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Provisioning_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Provisioning_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  provisioning?: Maybe<Scalars['String']>;
};

/** update columns of table "provisioning" */
export enum Provisioning_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Provisioning = 'provisioning',
}

export type Provisioning_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Provisioning_Set_Input>;
  /** filter the rows which have to be updated */
  where: Provisioning_Bool_Exp;
};

export enum PulumiMode {
  Destroy = 'destroy',
  Preview = 'preview',
  Refresh = 'refresh',
  Up = 'up',
}

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "alert_config" */
  alert_config: Array<Alert_Config>;
  /** fetch aggregated fields from the table: "alert_config" */
  alert_config_aggregate: Alert_Config_Aggregate;
  /** fetch data from the table: "alert_config_alert_type" */
  alert_config_alert_type: Array<Alert_Config_Alert_Type>;
  /** fetch aggregated fields from the table: "alert_config_alert_type" */
  alert_config_alert_type_aggregate: Alert_Config_Alert_Type_Aggregate;
  /** fetch data from the table: "alert_config_alert_type" using primary key columns */
  alert_config_alert_type_by_pk?: Maybe<Alert_Config_Alert_Type>;
  /** fetch data from the table: "alert_config" using primary key columns */
  alert_config_by_pk?: Maybe<Alert_Config>;
  /** fetch data from the table: "alert_config_service" */
  alert_config_service: Array<Alert_Config_Service>;
  /** fetch aggregated fields from the table: "alert_config_service" */
  alert_config_service_aggregate: Alert_Config_Service_Aggregate;
  /** fetch data from the table: "alert_config_service" using primary key columns */
  alert_config_service_by_pk?: Maybe<Alert_Config_Service>;
  /** fetch data from the table: "alert_service_type" */
  alert_service_type: Array<Alert_Service_Type>;
  /** fetch aggregated fields from the table: "alert_service_type" */
  alert_service_type_aggregate: Alert_Service_Type_Aggregate;
  /** fetch data from the table: "alert_service_type" using primary key columns */
  alert_service_type_by_pk?: Maybe<Alert_Service_Type>;
  /** fetch data from the table: "alert_type" */
  alert_type: Array<Alert_Type>;
  /** fetch aggregated fields from the table: "alert_type" */
  alert_type_aggregate: Alert_Type_Aggregate;
  /** fetch data from the table: "alert_type" using primary key columns */
  alert_type_by_pk?: Maybe<Alert_Type>;
  /** fetch data from the table: "azuremonitor_config" */
  azuremonitor_config: Array<Azuremonitor_Config>;
  /** fetch aggregated fields from the table: "azuremonitor_config" */
  azuremonitor_config_aggregate: Azuremonitor_Config_Aggregate;
  /** fetch data from the table: "azuremonitor_config" using primary key columns */
  azuremonitor_config_by_pk?: Maybe<Azuremonitor_Config>;
  /** fetch data from the table: "billing_address" */
  billing_address: Array<Billing_Address>;
  /** fetch aggregated fields from the table: "billing_address" */
  billing_address_aggregate: Billing_Address_Aggregate;
  /** fetch data from the table: "billing_address" using primary key columns */
  billing_address_by_pk?: Maybe<Billing_Address>;
  /** fetch data from the table: "central_cloud" */
  central_cloud: Array<Central_Cloud>;
  /** fetch aggregated fields from the table: "central_cloud" */
  central_cloud_aggregate: Central_Cloud_Aggregate;
  /** fetch data from the table: "central_cloud" using primary key columns */
  central_cloud_by_pk?: Maybe<Central_Cloud>;
  /** fetch data from the table: "change_email_request" */
  change_email_request: Array<Change_Email_Request>;
  /** fetch aggregated fields from the table: "change_email_request" */
  change_email_request_aggregate: Change_Email_Request_Aggregate;
  /** fetch data from the table: "change_email_request" using primary key columns */
  change_email_request_by_pk?: Maybe<Change_Email_Request>;
  /** fetch data from the table: "cicd.deployment_pipeline_config" */
  cicd_deployment_pipeline_config: Array<Cicd_Deployment_Pipeline_Config>;
  /** fetch aggregated fields from the table: "cicd.deployment_pipeline_config" */
  cicd_deployment_pipeline_config_aggregate: Cicd_Deployment_Pipeline_Config_Aggregate;
  /** fetch data from the table: "cicd.deployment_pipeline_config" using primary key columns */
  cicd_deployment_pipeline_config_by_pk?: Maybe<Cicd_Deployment_Pipeline_Config>;
  /** fetch data from the table: "cicd.deployment_pool" */
  cicd_deployment_pool: Array<Cicd_Deployment_Pool>;
  /** fetch aggregated fields from the table: "cicd.deployment_pool" */
  cicd_deployment_pool_aggregate: Cicd_Deployment_Pool_Aggregate;
  /** fetch data from the table: "cicd.deployment_pool_member" */
  cicd_deployment_pool_member: Array<Cicd_Deployment_Pool_Member>;
  /** fetch aggregated fields from the table: "cicd.deployment_pool_member" */
  cicd_deployment_pool_member_aggregate: Cicd_Deployment_Pool_Member_Aggregate;
  /** execute function "cicd.get_matching_pipeline_config" which returns "cicd.deployment_pipeline_config" */
  cicd_get_matching_pipeline_config: Array<Cicd_Deployment_Pipeline_Config>;
  /**
   * execute function "cicd.get_matching_pipeline_config" and query aggregates on
   * result of table type "cicd.deployment_pipeline_config"
   */
  cicd_get_matching_pipeline_config_aggregate: Cicd_Deployment_Pipeline_Config_Aggregate;
  /** fetch data from the table: "cloud" */
  cloud: Array<Cloud>;
  /** fetch aggregated fields from the table: "cloud" */
  cloud_aggregate: Cloud_Aggregate;
  /** fetch data from the table: "cloud" using primary key columns */
  cloud_by_pk?: Maybe<Cloud>;
  /** fetch data from the table: "cloud_metadata" */
  cloud_metadata: Array<Cloud_Metadata>;
  /** fetch aggregated fields from the table: "cloud_metadata" */
  cloud_metadata_aggregate: Cloud_Metadata_Aggregate;
  /** fetch data from the table: "cloud_metadata" using primary key columns */
  cloud_metadata_by_pk?: Maybe<Cloud_Metadata>;
  /** fetch data from the table: "cloud_regions_by_plan" */
  cloud_regions_by_plan: Array<Cloud_Regions_By_Plan>;
  /** fetch aggregated fields from the table: "cloud_regions_by_plan" */
  cloud_regions_by_plan_aggregate: Cloud_Regions_By_Plan_Aggregate;
  /** execute function "compute_project_agg_db_usage_user" which returns "project_db_usage_agg_user" */
  compute_project_agg_db_usage_user: Array<Project_Db_Usage_Agg_User>;
  /**
   * execute function "compute_project_agg_db_usage_user" and query aggregates on
   * result of table type "project_db_usage_agg_user"
   */
  compute_project_agg_db_usage_user_aggregate: Project_Db_Usage_Agg_User_Aggregate;
  /** execute function "compute_project_agg_usage" which returns "project_data_usage_agg" */
  compute_project_agg_usage: Array<Project_Data_Usage_Agg>;
  /** execute function "compute_project_agg_usage" and query aggregates on result of table type "project_data_usage_agg" */
  compute_project_agg_usage_aggregate: Project_Data_Usage_Agg_Aggregate;
  /** execute function "compute_project_agg_usage_prometheus" which returns "project_data_usage_agg" */
  compute_project_agg_usage_prometheus: Array<Project_Data_Usage_Agg>;
  /**
   * execute function "compute_project_agg_usage_prometheus" and query aggregates
   * on result of table type "project_data_usage_agg"
   */
  compute_project_agg_usage_prometheus_aggregate: Project_Data_Usage_Agg_Aggregate;
  /** execute function "compute_project_agg_usage_prometheus_user" which returns "project_data_usage_prometheus_agg_user" */
  compute_project_agg_usage_prometheus_user: Array<Project_Data_Usage_Prometheus_Agg_User>;
  /**
   * execute function "compute_project_agg_usage_prometheus_user" and query
   * aggregates on result of table type "project_data_usage_prometheus_agg_user"
   */
  compute_project_agg_usage_prometheus_user_aggregate: Project_Data_Usage_Prometheus_Agg_User_Aggregate;
  /** execute function "compute_project_agg_usage_user" which returns "project_data_usage_agg_user" */
  compute_project_agg_usage_user: Array<Project_Data_Usage_Agg_User>;
  /**
   * execute function "compute_project_agg_usage_user" and query aggregates on
   * result of table type "project_data_usage_agg_user"
   */
  compute_project_agg_usage_user_aggregate: Project_Data_Usage_Agg_User_Aggregate;
  /** fetch data from the table: "compute_unit_config" */
  compute_unit_config: Array<Compute_Unit_Config>;
  /** fetch aggregated fields from the table: "compute_unit_config" */
  compute_unit_config_aggregate: Compute_Unit_Config_Aggregate;
  /** fetch data from the table: "compute_unit_config" using primary key columns */
  compute_unit_config_by_pk?: Maybe<Compute_Unit_Config>;
  /** fetch data from the table: "config" */
  config: Array<Config>;
  /** fetch aggregated fields from the table: "config" */
  config_aggregate: Config_Aggregate;
  /** fetch data from the table: "config" using primary key columns */
  config_by_pk?: Maybe<Config>;
  /** fetch data from the table: "config_status" */
  config_status: Array<Config_Status>;
  /** fetch aggregated fields from the table: "config_status" */
  config_status_aggregate: Config_Status_Aggregate;
  /** fetch data from the table: "config_status" using primary key columns */
  config_status_by_pk?: Maybe<Config_Status>;
  /** fetch data from the table: "connector_config" */
  connector_config: Array<Connector_Config>;
  /** fetch aggregated fields from the table: "connector_config" */
  connector_config_aggregate: Connector_Config_Aggregate;
  /** fetch data from the table: "connector_config" using primary key columns */
  connector_config_by_pk?: Maybe<Connector_Config>;
  /** fetch data from the table: "connector_deployment" */
  connector_connector_deployment: Array<Connector_Connector_Deployment>;
  /** fetch aggregated fields from the table: "connector_deployment" */
  connector_connector_deployment_aggregate: Connector_Connector_Deployment_Aggregate;
  /** fetch data from the table: "connector_deployment" using primary key columns */
  connector_connector_deployment_by_pk?: Maybe<Connector_Connector_Deployment>;
  /** fetch data from the table: "connector_deployments" */
  connector_deployments: Array<Connector_Deployments>;
  /** fetch aggregated fields from the table: "connector_deployments" */
  connector_deployments_aggregate: Connector_Deployments_Aggregate;
  /** fetch data from the table: "connector_deployments" using primary key columns */
  connector_deployments_by_pk?: Maybe<Connector_Deployments>;
  /** fetch data from the table: "coupon" */
  coupon: Array<Coupon>;
  /** fetch aggregated fields from the table: "coupon" */
  coupon_aggregate: Coupon_Aggregate;
  /** fetch data from the table: "coupon" using primary key columns */
  coupon_by_pk?: Maybe<Coupon>;
  /** fetch data from the table: "coupon_duration" */
  coupon_duration: Array<Coupon_Duration>;
  /** fetch aggregated fields from the table: "coupon_duration" */
  coupon_duration_aggregate: Coupon_Duration_Aggregate;
  /** fetch data from the table: "coupon_duration" using primary key columns */
  coupon_duration_by_pk?: Maybe<Coupon_Duration>;
  /** fetch data from the table: "coupon_type" */
  coupon_type: Array<Coupon_Type>;
  /** fetch aggregated fields from the table: "coupon_type" */
  coupon_type_aggregate: Coupon_Type_Aggregate;
  /** fetch data from the table: "coupon_type" using primary key columns */
  coupon_type_by_pk?: Maybe<Coupon_Type>;
  /** fetch data from the table: "custom_domain" */
  custom_domain: Array<Custom_Domain>;
  /** fetch aggregated fields from the table: "custom_domain" */
  custom_domain_aggregate: Custom_Domain_Aggregate;
  /** fetch data from the table: "custom_domain" using primary key columns */
  custom_domain_by_pk?: Maybe<Custom_Domain>;
  /** fetch data from the table: "custom_domain_cloudflare" */
  custom_domain_cloudflare: Array<Custom_Domain_Cloudflare>;
  /** fetch aggregated fields from the table: "custom_domain_cloudflare" */
  custom_domain_cloudflare_aggregate: Custom_Domain_Cloudflare_Aggregate;
  /** fetch data from the table: "custom_domain_cloudflare" using primary key columns */
  custom_domain_cloudflare_by_pk?: Maybe<Custom_Domain_Cloudflare>;
  /** fetch data from the table: "custom_domain_cloudflare_dns" */
  custom_domain_cloudflare_dns: Array<Custom_Domain_Cloudflare_Dns>;
  /** fetch aggregated fields from the table: "custom_domain_cloudflare_dns" */
  custom_domain_cloudflare_dns_aggregate: Custom_Domain_Cloudflare_Dns_Aggregate;
  /** fetch data from the table: "custom_domain_cloudflare_dns" using primary key columns */
  custom_domain_cloudflare_dns_by_pk?: Maybe<Custom_Domain_Cloudflare_Dns>;
  /** fetch data from the table: "customer_usage" */
  customer_usage: Array<Customer_Usage>;
  /** fetch aggregated fields from the table: "customer_usage" */
  customer_usage_aggregate: Customer_Usage_Aggregate;
  /** fetch data from the table: "customer_usage" using primary key columns */
  customer_usage_by_pk?: Maybe<Customer_Usage>;
  /** fetch data from the table: "data_connector_type" */
  data_connector_type: Array<Data_Connector_Type>;
  /** fetch aggregated fields from the table: "data_connector_type" */
  data_connector_type_aggregate: Data_Connector_Type_Aggregate;
  /** fetch data from the table: "data_connector_type" using primary key columns */
  data_connector_type_by_pk?: Maybe<Data_Connector_Type>;
  /** fetch data from the table: "datadog_config" */
  datadog_config: Array<Datadog_Config>;
  /** fetch aggregated fields from the table: "datadog_config" */
  datadog_config_aggregate: Datadog_Config_Aggregate;
  /** fetch data from the table: "datadog_config" using primary key columns */
  datadog_config_by_pk?: Maybe<Datadog_Config>;
  /** fetch data from the table: "db_latency" */
  db_latency: Array<Db_Latency>;
  /** fetch aggregated fields from the table: "db_latency" */
  db_latency_aggregate: Db_Latency_Aggregate;
  /** fetch data from the table: "db_latency" using primary key columns */
  db_latency_by_pk?: Maybe<Db_Latency>;
  /** fetch data from the table: "ddn.build" */
  ddn_build: Array<Ddn_Build>;
  /** fetch aggregated fields from the table: "ddn.build" */
  ddn_build_aggregate: Ddn_Build_Aggregate;
  /** fetch data from the table: "ddn.build" using primary key columns */
  ddn_build_by_pk?: Maybe<Ddn_Build>;
  /** fetch data from the table: "ddn.build_sync_status" */
  ddn_build_sync_status: Array<Ddn_Build_Sync_Status>;
  /** fetch aggregated fields from the table: "ddn.build_sync_status" */
  ddn_build_sync_status_aggregate: Ddn_Build_Sync_Status_Aggregate;
  /** fetch data from the table: "ddn.build_sync_status" using primary key columns */
  ddn_build_sync_status_by_pk?: Maybe<Ddn_Build_Sync_Status>;
  /** fetch data from the table: "ddn.build_sync_worker" */
  ddn_build_sync_worker: Array<Ddn_Build_Sync_Worker>;
  /** fetch aggregated fields from the table: "ddn.build_sync_worker" */
  ddn_build_sync_worker_aggregate: Ddn_Build_Sync_Worker_Aggregate;
  /** fetch data from the table: "ddn.build_sync_worker" using primary key columns */
  ddn_build_sync_worker_by_pk?: Maybe<Ddn_Build_Sync_Worker>;
  /** fetch data from the table: "ddn.environment" */
  ddn_environment: Array<Ddn_Environment>;
  /** fetch aggregated fields from the table: "ddn.environment" */
  ddn_environment_aggregate: Ddn_Environment_Aggregate;
  /** fetch data from the table: "ddn.environment" using primary key columns */
  ddn_environment_by_pk?: Maybe<Ddn_Environment>;
  /** fetch data from the table: "ddn.project_entitlement_access" */
  ddn_project_entitlement_access: Array<Ddn_Project_Entitlement_Access>;
  /** fetch aggregated fields from the table: "ddn.project_entitlement_access" */
  ddn_project_entitlement_access_aggregate: Ddn_Project_Entitlement_Access_Aggregate;
  /** fetch data from the table: "ddn.project_entitlement_access" using primary key columns */
  ddn_project_entitlement_access_by_pk?: Maybe<Ddn_Project_Entitlement_Access>;
  /** fetch data from the table: "ddn.project_entitlement_catalogue" */
  ddn_project_entitlement_catalogue: Array<Ddn_Project_Entitlement_Catalogue>;
  /** fetch aggregated fields from the table: "ddn.project_entitlement_catalogue" */
  ddn_project_entitlement_catalogue_aggregate: Ddn_Project_Entitlement_Catalogue_Aggregate;
  /** fetch data from the table: "ddn.project_entitlement_catalogue" using primary key columns */
  ddn_project_entitlement_catalogue_by_pk?: Maybe<Ddn_Project_Entitlement_Catalogue>;
  /** fetch data from the table: "ddn.project_entitlement_types" */
  ddn_project_entitlement_types: Array<Ddn_Project_Entitlement_Types>;
  /** fetch aggregated fields from the table: "ddn.project_entitlement_types" */
  ddn_project_entitlement_types_aggregate: Ddn_Project_Entitlement_Types_Aggregate;
  /** fetch data from the table: "ddn.project_entitlement_types" using primary key columns */
  ddn_project_entitlement_types_by_pk?: Maybe<Ddn_Project_Entitlement_Types>;
  /** fetch data from the table: "ddn.projects" */
  ddn_projects: Array<Ddn_Projects>;
  /** fetch aggregated fields from the table: "ddn.projects" */
  ddn_projects_aggregate: Ddn_Projects_Aggregate;
  /** fetch data from the table: "ddn.projects" using primary key columns */
  ddn_projects_by_pk?: Maybe<Ddn_Projects>;
  /** fetch data from the table: "ddn.tunnel" */
  ddn_tunnel: Array<Ddn_Tunnel>;
  /** fetch aggregated fields from the table: "ddn.tunnel" */
  ddn_tunnel_aggregate: Ddn_Tunnel_Aggregate;
  /** fetch data from the table: "ddn.tunnel" using primary key columns */
  ddn_tunnel_by_pk?: Maybe<Ddn_Tunnel>;
  /** fetch data from the table: "ddn.tunnel_cluster" */
  ddn_tunnel_cluster: Array<Ddn_Tunnel_Cluster>;
  /** fetch aggregated fields from the table: "ddn.tunnel_cluster" */
  ddn_tunnel_cluster_aggregate: Ddn_Tunnel_Cluster_Aggregate;
  /** fetch data from the table: "ddn.tunnel_cluster" using primary key columns */
  ddn_tunnel_cluster_by_pk?: Maybe<Ddn_Tunnel_Cluster>;
  /** fetch data from the table: "dedicated_cloud_bills" */
  dedicated_cloud_bills: Array<Dedicated_Cloud_Bills>;
  /** fetch aggregated fields from the table: "dedicated_cloud_bills" */
  dedicated_cloud_bills_aggregate: Dedicated_Cloud_Bills_Aggregate;
  /** fetch data from the table: "dedicated_cloud_bills" using primary key columns */
  dedicated_cloud_bills_by_pk?: Maybe<Dedicated_Cloud_Bills>;
  /** fetch data from the table: "dedicated_cloud_bills_details" */
  dedicated_cloud_bills_details: Array<Dedicated_Cloud_Bills_Details>;
  /** fetch aggregated fields from the table: "dedicated_cloud_bills_details" */
  dedicated_cloud_bills_details_aggregate: Dedicated_Cloud_Bills_Details_Aggregate;
  /** fetch data from the table: "dedicated_cloud_bills_details" using primary key columns */
  dedicated_cloud_bills_details_by_pk?: Maybe<Dedicated_Cloud_Bills_Details>;
  /** fetch data from the table: "dedicated_cloud_commitments" */
  dedicated_cloud_commitments: Array<Dedicated_Cloud_Commitments>;
  /** fetch aggregated fields from the table: "dedicated_cloud_commitments" */
  dedicated_cloud_commitments_aggregate: Dedicated_Cloud_Commitments_Aggregate;
  /** fetch data from the table: "dedicated_cloud_commitments" using primary key columns */
  dedicated_cloud_commitments_by_pk?: Maybe<Dedicated_Cloud_Commitments>;
  /** fetch data from the table: "dedicated_vpc" */
  dedicated_vpc: Array<Dedicated_Vpc>;
  /** fetch aggregated fields from the table: "dedicated_vpc" */
  dedicated_vpc_aggregate: Dedicated_Vpc_Aggregate;
  /** fetch data from the table: "dedicated_vpc" using primary key columns */
  dedicated_vpc_by_pk?: Maybe<Dedicated_Vpc>;
  /** fetch data from the table: "delete_user" */
  delete_user: Array<Delete_User>;
  /** fetch aggregated fields from the table: "delete_user" */
  delete_user_aggregate: Delete_User_Aggregate;
  /** fetch data from the table: "delete_user" using primary key columns */
  delete_user_by_pk?: Maybe<Delete_User>;
  /** fetch data from the table: "delete_user_status" */
  delete_user_status: Array<Delete_User_Status>;
  /** fetch aggregated fields from the table: "delete_user_status" */
  delete_user_status_aggregate: Delete_User_Status_Aggregate;
  /** fetch data from the table: "delete_user_status" using primary key columns */
  delete_user_status_by_pk?: Maybe<Delete_User_Status>;
  /** fetch data from the table: "delete_user_tasks" */
  delete_user_tasks: Array<Delete_User_Tasks>;
  /** fetch aggregated fields from the table: "delete_user_tasks" */
  delete_user_tasks_aggregate: Delete_User_Tasks_Aggregate;
  /** fetch data from the table: "delete_user_tasks" using primary key columns */
  delete_user_tasks_by_pk?: Maybe<Delete_User_Tasks>;
  /** fetch data from the table: "email_log" */
  email_log: Array<Email_Log>;
  /** fetch aggregated fields from the table: "email_log" */
  email_log_aggregate: Email_Log_Aggregate;
  /** fetch data from the table: "email_log" using primary key columns */
  email_log_by_pk?: Maybe<Email_Log>;
  /** fetch data from the table: "enterprise_users" */
  enterprise_users: Array<Enterprise_Users>;
  /** fetch aggregated fields from the table: "enterprise_users" */
  enterprise_users_aggregate: Enterprise_Users_Aggregate;
  /** fetch data from the table: "enterprise_users" using primary key columns */
  enterprise_users_by_pk?: Maybe<Enterprise_Users>;
  /** fetch data from the table: "experiments" */
  experiments: Array<Experiments>;
  /** fetch aggregated fields from the table: "experiments" */
  experiments_aggregate: Experiments_Aggregate;
  /** fetch data from the table: "experiments" using primary key columns */
  experiments_by_pk?: Maybe<Experiments>;
  /** fetch data from the table: "experiments_cohort" */
  experiments_cohort: Array<Experiments_Cohort>;
  /** fetch aggregated fields from the table: "experiments_cohort" */
  experiments_cohort_aggregate: Experiments_Cohort_Aggregate;
  /** fetch data from the table: "experiments_cohort" using primary key columns */
  experiments_cohort_by_pk?: Maybe<Experiments_Cohort>;
  /** fetch data from the table: "experiments_config" */
  experiments_config: Array<Experiments_Config>;
  /** fetch aggregated fields from the table: "experiments_config" */
  experiments_config_aggregate: Experiments_Config_Aggregate;
  /** fetch data from the table: "experiments_config" using primary key columns */
  experiments_config_by_pk?: Maybe<Experiments_Config>;
  /** fetch data from the table: "feature" */
  feature: Array<Feature>;
  /** fetch data from the table: "feature_access" */
  feature_access: Array<Feature_Access>;
  /** fetch aggregated fields from the table: "feature_access" */
  feature_access_aggregate: Feature_Access_Aggregate;
  /** fetch data from the table: "feature_access" using primary key columns */
  feature_access_by_pk?: Maybe<Feature_Access>;
  /** fetch aggregated fields from the table: "feature" */
  feature_aggregate: Feature_Aggregate;
  /** fetch data from the table: "feature" using primary key columns */
  feature_by_pk?: Maybe<Feature>;
  /** fetch data from the table: "feature_config" */
  feature_config: Array<Feature_Config>;
  /** fetch aggregated fields from the table: "feature_config" */
  feature_config_aggregate: Feature_Config_Aggregate;
  /** fetch data from the table: "feature_config" using primary key columns */
  feature_config_by_pk?: Maybe<Feature_Config>;
  fetchDedicatedCloudClusterBills?: Maybe<
    Array<DedicatedCloudClusterBillsOutput>
  >;
  fetchPendingInvitations: Array<UserInvitation>;
  fetchPendingOwnershipInvitations: Array<ProjectOwnershipInvitation>;
  fetchUserSupportTicketDetails?: Maybe<Array<SupportTicketDetails>>;
  /** fetch data from the table: "gateway_ami" */
  gateway_ami: Array<Gateway_Ami>;
  /** fetch aggregated fields from the table: "gateway_ami" */
  gateway_ami_aggregate: Gateway_Ami_Aggregate;
  /** fetch data from the table: "gateway_ami" using primary key columns */
  gateway_ami_by_pk?: Maybe<Gateway_Ami>;
  /** fetch data from the table: "gateway_cluster" */
  gateway_cluster: Array<Gateway_Cluster>;
  /** fetch aggregated fields from the table: "gateway_cluster" */
  gateway_cluster_aggregate: Gateway_Cluster_Aggregate;
  /** fetch data from the table: "gateway_cluster" using primary key columns */
  gateway_cluster_by_pk?: Maybe<Gateway_Cluster>;
  /** fetch data from the table: "gateway_cluster_tenants" */
  gateway_cluster_tenants: Array<Gateway_Cluster_Tenants>;
  /** fetch aggregated fields from the table: "gateway_cluster_tenants" */
  gateway_cluster_tenants_aggregate: Gateway_Cluster_Tenants_Aggregate;
  /** fetch data from the table: "gateway_worker" */
  gateway_worker: Array<Gateway_Worker>;
  /** fetch aggregated fields from the table: "gateway_worker" */
  gateway_worker_aggregate: Gateway_Worker_Aggregate;
  /** fetch data from the table: "gateway_worker" using primary key columns */
  gateway_worker_by_pk?: Maybe<Gateway_Worker>;
  /** execute function "get_aggregated_cost_for_project_on_shared_plan" which returns "project_total_db_usage_agg" */
  get_aggregated_cost_for_project_on_shared_plan?: Maybe<Project_Total_Db_Usage_Agg>;
  /**
   * execute function "get_aggregated_cost_for_project_on_shared_plan" and query
   * aggregates on result of table type "project_total_db_usage_agg"
   */
  get_aggregated_cost_for_project_on_shared_plan_aggregate: Project_Total_Db_Usage_Agg_Aggregate;
  getBuildVersion: BuildVersion;
  getComputeUnitAllocation?: Maybe<ComputeUnitCountResponse>;
  getComputeUnitUsage?: Maybe<ComputeUnitUsageResponse>;
  getIntercomHash?: Maybe<IntercomHashResponse>;
  /** gets invoice and receipt URLs from Stripe */
  getInvoiceAndReceiptURLs?: Maybe<InvoiceAndReceiptUrLsResponse>;
  getLetsEncryptStatus?: Maybe<LetsEncryptStatus>;
  /**
   * This action helps fetch the number of data sources connected to a project that
   * is using the new pricing plans (cloud_free_v2 & cloud_shared)
   */
  getNumberOfConnectedSources?: Maybe<NumberOfConnectedSourcesOutput>;
  getProjectMigrationStatus?: Maybe<Array<Maybe<ProjectMigrationStatus>>>;
  getReportURL?: Maybe<GetReportUrlResponse>;
  getTenantEnv?: Maybe<TenantEnv>;
  getTenantEnvConfigInfo?: Maybe<TenantEnvConfigInfo>;
  /** fetch data from the table: "github_email_type" */
  github_email_type: Array<Github_Email_Type>;
  /** fetch aggregated fields from the table: "github_email_type" */
  github_email_type_aggregate: Github_Email_Type_Aggregate;
  /** fetch data from the table: "github_email_type" using primary key columns */
  github_email_type_by_pk?: Maybe<Github_Email_Type>;
  /** fetch data from the table: "github_integration_config" */
  github_integration_config: Array<Github_Integration_Config>;
  /** fetch aggregated fields from the table: "github_integration_config" */
  github_integration_config_aggregate: Github_Integration_Config_Aggregate;
  /** fetch data from the table: "github_integration_config" using primary key columns */
  github_integration_config_by_pk?: Maybe<Github_Integration_Config>;
  /** fetch data from the table: "github_integration_mode" */
  github_integration_mode: Array<Github_Integration_Mode>;
  /** fetch aggregated fields from the table: "github_integration_mode" */
  github_integration_mode_aggregate: Github_Integration_Mode_Aggregate;
  /** fetch data from the table: "github_integration_mode" using primary key columns */
  github_integration_mode_by_pk?: Maybe<Github_Integration_Mode>;
  /** fetch data from the table: "github_push_event" */
  github_push_event: Array<Github_Push_Event>;
  /** fetch aggregated fields from the table: "github_push_event" */
  github_push_event_aggregate: Github_Push_Event_Aggregate;
  /** fetch data from the table: "github_push_event" using primary key columns */
  github_push_event_by_pk?: Maybe<Github_Push_Event>;
  /** fetch data from the table: "github_push_event_job" */
  github_push_event_job: Array<Github_Push_Event_Job>;
  /** fetch aggregated fields from the table: "github_push_event_job" */
  github_push_event_job_aggregate: Github_Push_Event_Job_Aggregate;
  /** fetch data from the table: "github_push_event_job" using primary key columns */
  github_push_event_job_by_pk?: Maybe<Github_Push_Event_Job>;
  /** fetch data from the table: "hasura_ami" */
  hasura_ami: Array<Hasura_Ami>;
  /** fetch aggregated fields from the table: "hasura_ami" */
  hasura_ami_aggregate: Hasura_Ami_Aggregate;
  /** fetch data from the table: "hasura_ami" using primary key columns */
  hasura_ami_by_pk?: Maybe<Hasura_Ami>;
  /** fetch data from the table: "hasura_cluster" */
  hasura_cluster: Array<Hasura_Cluster>;
  /** fetch aggregated fields from the table: "hasura_cluster" */
  hasura_cluster_aggregate: Hasura_Cluster_Aggregate;
  /** fetch data from the table: "hasura_cluster" using primary key columns */
  hasura_cluster_by_pk?: Maybe<Hasura_Cluster>;
  /** fetch data from the table: "hasura_worker" */
  hasura_worker: Array<Hasura_Worker>;
  /** fetch aggregated fields from the table: "hasura_worker" */
  hasura_worker_aggregate: Hasura_Worker_Aggregate;
  /** fetch data from the table: "hasura_worker" using primary key columns */
  hasura_worker_by_pk?: Maybe<Hasura_Worker>;
  /** fetch data from the table: "hasura_worker_tenants" */
  hasura_worker_tenants: Array<Hasura_Worker_Tenants>;
  /** fetch aggregated fields from the table: "hasura_worker_tenants" */
  hasura_worker_tenants_aggregate: Hasura_Worker_Tenants_Aggregate;
  /** An array relationship */
  heroku_integrations: Array<Heroku_Integrations>;
  /** An aggregate relationship */
  heroku_integrations_aggregate: Heroku_Integrations_Aggregate;
  /** fetch data from the table: "heroku_integrations" using primary key columns */
  heroku_integrations_by_pk?: Maybe<Heroku_Integrations>;
  /** fetch data from the table: "inactive_project_exclusions" */
  inactive_project_exclusions: Array<Inactive_Project_Exclusions>;
  /** fetch aggregated fields from the table: "inactive_project_exclusions" */
  inactive_project_exclusions_aggregate: Inactive_Project_Exclusions_Aggregate;
  /** fetch data from the table: "inactive_project_exclusions" using primary key columns */
  inactive_project_exclusions_by_pk?: Maybe<Inactive_Project_Exclusions>;
  /** fetch data from the table: "inactive_project_notifications" */
  inactive_project_notifications: Array<Inactive_Project_Notifications>;
  /** fetch aggregated fields from the table: "inactive_project_notifications" */
  inactive_project_notifications_aggregate: Inactive_Project_Notifications_Aggregate;
  /** fetch data from the table: "inactive_project_notifications" using primary key columns */
  inactive_project_notifications_by_pk?: Maybe<Inactive_Project_Notifications>;
  /** fetch data from the table: "inactive_project_suspension_config" */
  inactive_project_suspension_config: Array<Inactive_Project_Suspension_Config>;
  /** fetch aggregated fields from the table: "inactive_project_suspension_config" */
  inactive_project_suspension_config_aggregate: Inactive_Project_Suspension_Config_Aggregate;
  /** fetch data from the table: "inactive_projects" */
  inactive_projects: Array<Inactive_Projects>;
  /** fetch aggregated fields from the table: "inactive_projects" */
  inactive_projects_aggregate: Inactive_Projects_Aggregate;
  /** fetch data from the table: "infra_status" */
  infra_status: Array<Infra_Status>;
  /** fetch aggregated fields from the table: "infra_status" */
  infra_status_aggregate: Infra_Status_Aggregate;
  /** fetch data from the table: "infra_status" using primary key columns */
  infra_status_by_pk?: Maybe<Infra_Status>;
  /** fetch data from the table: "invoice" */
  invoice: Array<Invoice>;
  /** fetch aggregated fields from the table: "invoice" */
  invoice_aggregate: Invoice_Aggregate;
  /** fetch data from the table: "invoice" using primary key columns */
  invoice_by_pk?: Maybe<Invoice>;
  /** fetch data from the table: "invoice_coupon_discount" */
  invoice_coupon_discount: Array<Invoice_Coupon_Discount>;
  /** fetch aggregated fields from the table: "invoice_coupon_discount" */
  invoice_coupon_discount_aggregate: Invoice_Coupon_Discount_Aggregate;
  /** fetch data from the table: "invoice_coupon_discount" using primary key columns */
  invoice_coupon_discount_by_pk?: Maybe<Invoice_Coupon_Discount>;
  /** fetch data from the table: "invoice_item" */
  invoice_item: Array<Invoice_Item>;
  /** fetch aggregated fields from the table: "invoice_item" */
  invoice_item_aggregate: Invoice_Item_Aggregate;
  /** fetch data from the table: "invoice_item" using primary key columns */
  invoice_item_by_pk?: Maybe<Invoice_Item>;
  /** An array relationship */
  jobs: Array<Jobs>;
  /** An aggregate relationship */
  jobs_aggregate: Jobs_Aggregate;
  /** fetch data from the table: "jobs" using primary key columns */
  jobs_by_pk?: Maybe<Jobs>;
  /** fetch data from the table: "label" */
  label: Array<Label>;
  /** fetch aggregated fields from the table: "label" */
  label_aggregate: Label_Aggregate;
  /** fetch data from the table: "label" using primary key columns */
  label_by_pk?: Maybe<Label>;
  /** fetch data from the table: "letsencrypt_status" */
  letsencrypt_status: Array<Letsencrypt_Status>;
  /** fetch aggregated fields from the table: "letsencrypt_status" */
  letsencrypt_status_aggregate: Letsencrypt_Status_Aggregate;
  /** fetch data from the table: "letsencrypt_status" using primary key columns */
  letsencrypt_status_by_pk?: Maybe<Letsencrypt_Status>;
  /** fetch data from the table: "license_activity" */
  license_activity: Array<License_Activity>;
  /** fetch aggregated fields from the table: "license_activity" */
  license_activity_aggregate: License_Activity_Aggregate;
  /** fetch data from the table: "license_activity" using primary key columns */
  license_activity_by_pk?: Maybe<License_Activity>;
  /** fetch data from the table: "license_instance" */
  license_instance: Array<License_Instance>;
  /** fetch aggregated fields from the table: "license_instance" */
  license_instance_aggregate: License_Instance_Aggregate;
  /** fetch data from the table: "license_instance" using primary key columns */
  license_instance_by_pk?: Maybe<License_Instance>;
  /** fetch data from the table: "license_type" */
  license_type: Array<License_Type>;
  /** fetch aggregated fields from the table: "license_type" */
  license_type_aggregate: License_Type_Aggregate;
  /** fetch data from the table: "license_type" using primary key columns */
  license_type_by_pk?: Maybe<License_Type>;
  /** fetch data from the table: "licenses" */
  licenses: Array<Licenses>;
  /** fetch aggregated fields from the table: "licenses" */
  licenses_aggregate: Licenses_Aggregate;
  /** fetch data from the table: "licenses" using primary key columns */
  licenses_by_pk?: Maybe<Licenses>;
  /** An array relationship */
  lux_proxy: Array<Lux_Proxy>;
  /** An aggregate relationship */
  lux_proxy_aggregate: Lux_Proxy_Aggregate;
  /** fetch data from the table: "lux_proxy_ami" */
  lux_proxy_ami: Array<Lux_Proxy_Ami>;
  /** fetch aggregated fields from the table: "lux_proxy_ami" */
  lux_proxy_ami_aggregate: Lux_Proxy_Ami_Aggregate;
  /** fetch data from the table: "lux_proxy_ami" using primary key columns */
  lux_proxy_ami_by_pk?: Maybe<Lux_Proxy_Ami>;
  /** fetch data from the table: "lux_proxy" using primary key columns */
  lux_proxy_by_pk?: Maybe<Lux_Proxy>;
  /** fetch data from the table: "neon_db_integration" */
  neon_db_integration: Array<Neon_Db_Integration>;
  /** fetch aggregated fields from the table: "neon_db_integration" */
  neon_db_integration_aggregate: Neon_Db_Integration_Aggregate;
  /** fetch data from the table: "neon_db_integration" using primary key columns */
  neon_db_integration_by_pk?: Maybe<Neon_Db_Integration>;
  /** Gets Neon user info of the logged-in with Neon */
  neonGetUserInfo?: Maybe<NeonGetUserInfoResponse>;
  /** fetch data from the table: "newrelic_config" */
  newrelic_config: Array<Newrelic_Config>;
  /** fetch aggregated fields from the table: "newrelic_config" */
  newrelic_config_aggregate: Newrelic_Config_Aggregate;
  /** fetch data from the table: "newrelic_config" using primary key columns */
  newrelic_config_by_pk?: Maybe<Newrelic_Config>;
  /** fetch data from the table: "node_pool_type" */
  node_pool_type: Array<Node_Pool_Type>;
  /** fetch aggregated fields from the table: "node_pool_type" */
  node_pool_type_aggregate: Node_Pool_Type_Aggregate;
  /** fetch data from the table: "node_pool_type" using primary key columns */
  node_pool_type_by_pk?: Maybe<Node_Pool_Type>;
  /** fetch data from the table: "node_pools" */
  node_pools: Array<Node_Pools>;
  /** fetch aggregated fields from the table: "node_pools" */
  node_pools_aggregate: Node_Pools_Aggregate;
  /** fetch data from the table: "node_pools" using primary key columns */
  node_pools_by_pk?: Maybe<Node_Pools>;
  /** fetch data from the table: "notification" */
  notification: Array<Notification>;
  /** fetch aggregated fields from the table: "notification" */
  notification_aggregate: Notification_Aggregate;
  /** fetch data from the table: "notification" using primary key columns */
  notification_by_pk?: Maybe<Notification>;
  /** fetch data from the table: "notification_type" */
  notification_type: Array<Notification_Type>;
  /** fetch aggregated fields from the table: "notification_type" */
  notification_type_aggregate: Notification_Type_Aggregate;
  /** fetch data from the table: "notification_type" using primary key columns */
  notification_type_by_pk?: Maybe<Notification_Type>;
  /** fetch data from the table: "onboarding_sample_db_cohort" */
  onboarding_sample_db_cohort: Array<Onboarding_Sample_Db_Cohort>;
  /** fetch aggregated fields from the table: "onboarding_sample_db_cohort" */
  onboarding_sample_db_cohort_aggregate: Onboarding_Sample_Db_Cohort_Aggregate;
  /** fetch data from the table: "onboarding_sample_db_cohort" using primary key columns */
  onboarding_sample_db_cohort_by_pk?: Maybe<Onboarding_Sample_Db_Cohort>;
  /** fetch data from the table: "onboarding_sample_db_config" */
  onboarding_sample_db_config: Array<Onboarding_Sample_Db_Config>;
  /** fetch aggregated fields from the table: "onboarding_sample_db_config" */
  onboarding_sample_db_config_aggregate: Onboarding_Sample_Db_Config_Aggregate;
  /** fetch data from the table: "onboarding_sample_db_config" using primary key columns */
  onboarding_sample_db_config_by_pk?: Maybe<Onboarding_Sample_Db_Config>;
  /** fetch data from the table: "one_click_deployment" */
  one_click_deployment: Array<One_Click_Deployment>;
  /** fetch aggregated fields from the table: "one_click_deployment" */
  one_click_deployment_aggregate: One_Click_Deployment_Aggregate;
  /** fetch data from the table: "one_click_deployment" using primary key columns */
  one_click_deployment_by_pk?: Maybe<One_Click_Deployment>;
  /** fetch data from the table: "one_click_deployment_sample_apps" */
  one_click_deployment_sample_apps: Array<One_Click_Deployment_Sample_Apps>;
  /** fetch aggregated fields from the table: "one_click_deployment_sample_apps" */
  one_click_deployment_sample_apps_aggregate: One_Click_Deployment_Sample_Apps_Aggregate;
  /** fetch data from the table: "one_click_deployment_sample_apps" using primary key columns */
  one_click_deployment_sample_apps_by_pk?: Maybe<One_Click_Deployment_Sample_Apps>;
  /** fetch data from the table: "one_click_deployment_state_log" */
  one_click_deployment_state_log: Array<One_Click_Deployment_State_Log>;
  /** fetch aggregated fields from the table: "one_click_deployment_state_log" */
  one_click_deployment_state_log_aggregate: One_Click_Deployment_State_Log_Aggregate;
  /** fetch data from the table: "one_click_deployment_state_log" using primary key columns */
  one_click_deployment_state_log_by_pk?: Maybe<One_Click_Deployment_State_Log>;
  /** fetch data from the table: "one_click_deployment_states" */
  one_click_deployment_states: Array<One_Click_Deployment_States>;
  /** fetch aggregated fields from the table: "one_click_deployment_states" */
  one_click_deployment_states_aggregate: One_Click_Deployment_States_Aggregate;
  /** fetch data from the table: "one_click_deployment_states" using primary key columns */
  one_click_deployment_states_by_pk?: Maybe<One_Click_Deployment_States>;
  /** fetch data from the table: "opentelemetry_config" */
  opentelemetry_config: Array<Opentelemetry_Config>;
  /** fetch aggregated fields from the table: "opentelemetry_config" */
  opentelemetry_config_aggregate: Opentelemetry_Config_Aggregate;
  /** fetch data from the table: "opentelemetry_config" using primary key columns */
  opentelemetry_config_by_pk?: Maybe<Opentelemetry_Config>;
  /** fetch data from the table: "operations.delete_free_plan_dns_records_nov_2021" */
  operations_delete_free_plan_dns_records_nov_2021: Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021>;
  /** fetch aggregated fields from the table: "operations.delete_free_plan_dns_records_nov_2021" */
  operations_delete_free_plan_dns_records_nov_2021_aggregate: Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Aggregate;
  /** fetch data from the table: "operations.delete_free_plan_dns_records_nov_2021" using primary key columns */
  operations_delete_free_plan_dns_records_nov_2021_by_pk?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021>;
  /** fetch data from the table: "operations.tenant" */
  operations_tenant: Array<Operations_Tenant>;
  /** fetch aggregated fields from the table: "operations.tenant" */
  operations_tenant_aggregate: Operations_Tenant_Aggregate;
  /** execute function "operations.to_delete_free_plan_dns_records" which returns "operations.tenant" */
  operations_to_delete_free_plan_dns_records: Array<Operations_Tenant>;
  /**
   * execute function "operations.to_delete_free_plan_dns_records" and query
   * aggregates on result of table type "operations.tenant"
   */
  operations_to_delete_free_plan_dns_records_aggregate: Operations_Tenant_Aggregate;
  /** fetch data from the table: "payment_method" */
  payment_method: Array<Payment_Method>;
  /** fetch aggregated fields from the table: "payment_method" */
  payment_method_aggregate: Payment_Method_Aggregate;
  /** fetch data from the table: "payment_method" using primary key columns */
  payment_method_by_pk?: Maybe<Payment_Method>;
  /** fetch data from the table: "plan_entitlements" */
  plan_entitlements: Array<Plan_Entitlements>;
  /** fetch aggregated fields from the table: "plan_entitlements" */
  plan_entitlements_aggregate: Plan_Entitlements_Aggregate;
  /** fetch data from the table: "plan_entitlements" using primary key columns */
  plan_entitlements_by_pk?: Maybe<Plan_Entitlements>;
  /** fetch data from the table: "plans" */
  plans: Array<Plans>;
  /** fetch aggregated fields from the table: "plans" */
  plans_aggregate: Plans_Aggregate;
  /** fetch data from the table: "plans" using primary key columns */
  plans_by_pk?: Maybe<Plans>;
  /** An array relationship */
  policies: Array<Policies>;
  /** An aggregate relationship */
  policies_aggregate: Policies_Aggregate;
  /** fetch data from the table: "policies" using primary key columns */
  policies_by_pk?: Maybe<Policies>;
  privilegedProjects?: Maybe<Array<AllowedProjectResponse>>;
  /** fetch data from the table: "privileges" */
  privileges: Array<Privileges>;
  /** fetch aggregated fields from the table: "privileges" */
  privileges_aggregate: Privileges_Aggregate;
  /** fetch data from the table: "privileges" using primary key columns */
  privileges_by_pk?: Maybe<Privileges>;
  /** fetch data from the table: "pro_license_keys" */
  pro_license_keys: Array<Pro_License_Keys>;
  /** fetch aggregated fields from the table: "pro_license_keys" */
  pro_license_keys_aggregate: Pro_License_Keys_Aggregate;
  /** fetch data from the table: "pro_license_keys" using primary key columns */
  pro_license_keys_by_pk?: Maybe<Pro_License_Keys>;
  /** fetch data from the table: "project_activity" */
  project_activity: Array<Project_Activity>;
  /** fetch aggregated fields from the table: "project_activity" */
  project_activity_aggregate: Project_Activity_Aggregate;
  /** fetch data from the table: "project_activity" using primary key columns */
  project_activity_by_pk?: Maybe<Project_Activity>;
  /** An array relationship */
  project_billing_manager_invitations: Array<Project_Billing_Manager_Invitations>;
  /** An aggregate relationship */
  project_billing_manager_invitations_aggregate: Project_Billing_Manager_Invitations_Aggregate;
  /** fetch data from the table: "project_billing_manager_invitations" using primary key columns */
  project_billing_manager_invitations_by_pk?: Maybe<Project_Billing_Manager_Invitations>;
  /** fetch data from the table: "project_collaborator_allowed_schema_tables" */
  project_collaborator_allowed_schema_tables: Array<Project_Collaborator_Allowed_Schema_Tables>;
  /** fetch aggregated fields from the table: "project_collaborator_allowed_schema_tables" */
  project_collaborator_allowed_schema_tables_aggregate: Project_Collaborator_Allowed_Schema_Tables_Aggregate;
  /** fetch data from the table: "project_collaborator_allowed_schema_tables" using primary key columns */
  project_collaborator_allowed_schema_tables_by_pk?: Maybe<Project_Collaborator_Allowed_Schema_Tables>;
  /** An array relationship */
  project_collaborator_allowed_schemas: Array<Project_Collaborator_Allowed_Schemas>;
  /** An aggregate relationship */
  project_collaborator_allowed_schemas_aggregate: Project_Collaborator_Allowed_Schemas_Aggregate;
  /** fetch data from the table: "project_collaborator_allowed_schemas" using primary key columns */
  project_collaborator_allowed_schemas_by_pk?: Maybe<Project_Collaborator_Allowed_Schemas>;
  /** fetch data from the table: "project_collaborator_invitations" */
  project_collaborator_invitations: Array<Project_Collaborator_Invitations>;
  /** fetch aggregated fields from the table: "project_collaborator_invitations" */
  project_collaborator_invitations_aggregate: Project_Collaborator_Invitations_Aggregate;
  /** fetch data from the table: "project_collaborator_invitations" using primary key columns */
  project_collaborator_invitations_by_pk?: Maybe<Project_Collaborator_Invitations>;
  /** An array relationship */
  project_collaborator_privileges: Array<Project_Collaborator_Privileges>;
  /** An aggregate relationship */
  project_collaborator_privileges_aggregate: Project_Collaborator_Privileges_Aggregate;
  /** fetch data from the table: "project_collaborator_privileges" using primary key columns */
  project_collaborator_privileges_by_pk?: Maybe<Project_Collaborator_Privileges>;
  /** fetch data from the table: "project_collaborators" */
  project_collaborators: Array<Project_Collaborators>;
  /** fetch aggregated fields from the table: "project_collaborators" */
  project_collaborators_aggregate: Project_Collaborators_Aggregate;
  /** fetch data from the table: "project_collaborators" using primary key columns */
  project_collaborators_by_pk?: Maybe<Project_Collaborators>;
  /** fetch data from the table: "project_data_usage" */
  project_data_usage: Array<Project_Data_Usage>;
  /** fetch data from the table: "project_data_usage_agg" */
  project_data_usage_agg: Array<Project_Data_Usage_Agg>;
  /** fetch aggregated fields from the table: "project_data_usage_agg" */
  project_data_usage_agg_aggregate: Project_Data_Usage_Agg_Aggregate;
  /** fetch data from the table: "project_data_usage_agg_user" */
  project_data_usage_agg_user: Array<Project_Data_Usage_Agg_User>;
  /** fetch aggregated fields from the table: "project_data_usage_agg_user" */
  project_data_usage_agg_user_aggregate: Project_Data_Usage_Agg_User_Aggregate;
  /** fetch aggregated fields from the table: "project_data_usage" */
  project_data_usage_aggregate: Project_Data_Usage_Aggregate;
  /** fetch data from the table: "project_data_usage" using primary key columns */
  project_data_usage_by_pk?: Maybe<Project_Data_Usage>;
  /** fetch data from the table: "project_data_usage_components" */
  project_data_usage_components: Array<Project_Data_Usage_Components>;
  /** fetch aggregated fields from the table: "project_data_usage_components" */
  project_data_usage_components_aggregate: Project_Data_Usage_Components_Aggregate;
  /** fetch data from the table: "project_data_usage_prometheus" */
  project_data_usage_prometheus: Array<Project_Data_Usage_Prometheus>;
  /** fetch data from the table: "project_data_usage_prometheus_agg_user" */
  project_data_usage_prometheus_agg_user: Array<Project_Data_Usage_Prometheus_Agg_User>;
  /** fetch aggregated fields from the table: "project_data_usage_prometheus_agg_user" */
  project_data_usage_prometheus_agg_user_aggregate: Project_Data_Usage_Prometheus_Agg_User_Aggregate;
  /** fetch aggregated fields from the table: "project_data_usage_prometheus" */
  project_data_usage_prometheus_aggregate: Project_Data_Usage_Prometheus_Aggregate;
  /** fetch data from the table: "project_data_usage_prometheus" using primary key columns */
  project_data_usage_prometheus_by_pk?: Maybe<Project_Data_Usage_Prometheus>;
  /** fetch data from the table: "project_data_usage_report" */
  project_data_usage_report: Array<Project_Data_Usage_Report>;
  /** fetch aggregated fields from the table: "project_data_usage_report" */
  project_data_usage_report_aggregate: Project_Data_Usage_Report_Aggregate;
  /** fetch data from the table: "project_data_usage_report" using primary key columns */
  project_data_usage_report_by_pk?: Maybe<Project_Data_Usage_Report>;
  /** fetch data from the table: "project_db_usage" */
  project_db_usage: Array<Project_Db_Usage>;
  /** fetch data from the table: "project_db_usage_agg_user" */
  project_db_usage_agg_user: Array<Project_Db_Usage_Agg_User>;
  /** fetch aggregated fields from the table: "project_db_usage_agg_user" */
  project_db_usage_agg_user_aggregate: Project_Db_Usage_Agg_User_Aggregate;
  /** fetch aggregated fields from the table: "project_db_usage" */
  project_db_usage_aggregate: Project_Db_Usage_Aggregate;
  /** fetch data from the table: "project_db_usage" using primary key columns */
  project_db_usage_by_pk?: Maybe<Project_Db_Usage>;
  /** fetch data from the table: "project_entitlement_access" */
  project_entitlement_access: Array<Project_Entitlement_Access>;
  /** fetch aggregated fields from the table: "project_entitlement_access" */
  project_entitlement_access_aggregate: Project_Entitlement_Access_Aggregate;
  /** fetch data from the table: "project_entitlement_access" using primary key columns */
  project_entitlement_access_by_pk?: Maybe<Project_Entitlement_Access>;
  /** fetch data from the table: "project_entitlement_catalogue" */
  project_entitlement_catalogue: Array<Project_Entitlement_Catalogue>;
  /** fetch aggregated fields from the table: "project_entitlement_catalogue" */
  project_entitlement_catalogue_aggregate: Project_Entitlement_Catalogue_Aggregate;
  /** fetch data from the table: "project_entitlement_catalogue" using primary key columns */
  project_entitlement_catalogue_by_pk?: Maybe<Project_Entitlement_Catalogue>;
  /** fetch data from the table: "project_entitlement_types" */
  project_entitlement_types: Array<Project_Entitlement_Types>;
  /** fetch aggregated fields from the table: "project_entitlement_types" */
  project_entitlement_types_aggregate: Project_Entitlement_Types_Aggregate;
  /** fetch data from the table: "project_entitlement_types" using primary key columns */
  project_entitlement_types_by_pk?: Maybe<Project_Entitlement_Types>;
  /** An array relationship */
  project_labels: Array<Project_Labels>;
  /** An aggregate relationship */
  project_labels_aggregate: Project_Labels_Aggregate;
  /** fetch data from the table: "project_labels" using primary key columns */
  project_labels_by_pk?: Maybe<Project_Labels>;
  /** fetch data from the table: "project_metadata" */
  project_metadata: Array<Project_Metadata>;
  /** fetch aggregated fields from the table: "project_metadata" */
  project_metadata_aggregate: Project_Metadata_Aggregate;
  /** fetch data from the table: "project_metadata" using primary key columns */
  project_metadata_by_pk?: Maybe<Project_Metadata>;
  /** fetch data from the table: "project_notification" */
  project_notification: Array<Project_Notification>;
  /** fetch aggregated fields from the table: "project_notification" */
  project_notification_aggregate: Project_Notification_Aggregate;
  /** fetch data from the table: "project_notification" using primary key columns */
  project_notification_by_pk?: Maybe<Project_Notification>;
  /** fetch data from the table: "project_ownership_transfer_invitations" */
  project_ownership_transfer_invitations: Array<Project_Ownership_Transfer_Invitations>;
  /** fetch aggregated fields from the table: "project_ownership_transfer_invitations" */
  project_ownership_transfer_invitations_aggregate: Project_Ownership_Transfer_Invitations_Aggregate;
  /** fetch data from the table: "project_ownership_transfer_invitations" using primary key columns */
  project_ownership_transfer_invitations_by_pk?: Maybe<Project_Ownership_Transfer_Invitations>;
  /** fetch data from the table: "project_pool_current_status" */
  project_pool_current_status: Array<Project_Pool_Current_Status>;
  /** fetch aggregated fields from the table: "project_pool_current_status" */
  project_pool_current_status_aggregate: Project_Pool_Current_Status_Aggregate;
  /** fetch data from the table: "project_requests_count" */
  project_requests_count: Array<Project_Requests_Count>;
  /** fetch aggregated fields from the table: "project_requests_count" */
  project_requests_count_aggregate: Project_Requests_Count_Aggregate;
  /** fetch data from the table: "project_requests_count" using primary key columns */
  project_requests_count_by_pk?: Maybe<Project_Requests_Count>;
  /** fetch data from the table: "project_stats" */
  project_stats: Array<Project_Stats>;
  /** fetch aggregated fields from the table: "project_stats" */
  project_stats_aggregate: Project_Stats_Aggregate;
  /** fetch data from the table: "project_stats" using primary key columns */
  project_stats_by_pk?: Maybe<Project_Stats>;
  /** fetch data from the table: "project_total_db_usage_agg" */
  project_total_db_usage_agg: Array<Project_Total_Db_Usage_Agg>;
  /** fetch aggregated fields from the table: "project_total_db_usage_agg" */
  project_total_db_usage_agg_aggregate: Project_Total_Db_Usage_Agg_Aggregate;
  /** An array relationship */
  projects: Array<Projects>;
  /** An aggregate relationship */
  projects_aggregate: Projects_Aggregate;
  /** fetch data from the table: "projects" using primary key columns */
  projects_by_pk?: Maybe<Projects>;
  /** fetch data from the table: "projects_pool_config" */
  projects_pool_config: Array<Projects_Pool_Config>;
  /** fetch aggregated fields from the table: "projects_pool_config" */
  projects_pool_config_aggregate: Projects_Pool_Config_Aggregate;
  /** fetch data from the table: "projects_pool_config" using primary key columns */
  projects_pool_config_by_pk?: Maybe<Projects_Pool_Config>;
  /** fetch data from the table: "projects_pro_key_generations" */
  projects_pro_key_generations: Array<Projects_Pro_Key_Generations>;
  /** fetch aggregated fields from the table: "projects_pro_key_generations" */
  projects_pro_key_generations_aggregate: Projects_Pro_Key_Generations_Aggregate;
  /** fetch data from the table: "projects_pro_key_generations" using primary key columns */
  projects_pro_key_generations_by_pk?: Maybe<Projects_Pro_Key_Generations>;
  /** fetch data from the table: "projects_with_no_running_deployments" */
  projects_with_no_running_deployments: Array<Projects_With_No_Running_Deployments>;
  /** fetch aggregated fields from the table: "projects_with_no_running_deployments" */
  projects_with_no_running_deployments_aggregate: Projects_With_No_Running_Deployments_Aggregate;
  /** fetch data from the table: "projects_with_no_running_preview_app" */
  projects_with_no_running_preview_app: Array<Projects_With_No_Running_Preview_App>;
  /** fetch aggregated fields from the table: "projects_with_no_running_preview_app" */
  projects_with_no_running_preview_app_aggregate: Projects_With_No_Running_Preview_App_Aggregate;
  /** fetch data from the table: "prometheus_config" */
  prometheus_config: Array<Prometheus_Config>;
  /** fetch aggregated fields from the table: "prometheus_config" */
  prometheus_config_aggregate: Prometheus_Config_Aggregate;
  /** fetch data from the table: "prometheus_config" using primary key columns */
  prometheus_config_by_pk?: Maybe<Prometheus_Config>;
  /** An array relationship */
  providers: Array<Providers>;
  /** An aggregate relationship */
  providers_aggregate: Providers_Aggregate;
  /** fetch data from the table: "providers" using primary key columns */
  providers_by_pk?: Maybe<Providers>;
  /** fetch data from the table: "provisioning" */
  provisioning: Array<Provisioning>;
  /** fetch aggregated fields from the table: "provisioning" */
  provisioning_aggregate: Provisioning_Aggregate;
  /** fetch data from the table: "provisioning" using primary key columns */
  provisioning_by_pk?: Maybe<Provisioning>;
  /** fetch data from the table: "region" */
  region: Array<Region>;
  /** fetch aggregated fields from the table: "region" */
  region_aggregate: Region_Aggregate;
  /** fetch data from the table: "region" using primary key columns */
  region_by_pk?: Maybe<Region>;
  /** fetch data from the table: "region_v2" */
  region_v2: Array<Region_V2>;
  /** fetch aggregated fields from the table: "region_v2" */
  region_v2_aggregate: Region_V2_Aggregate;
  /** fetch data from the table: "regional_data_connectors" */
  regional_data_connectors: Array<Regional_Data_Connectors>;
  /** fetch aggregated fields from the table: "regional_data_connectors" */
  regional_data_connectors_aggregate: Regional_Data_Connectors_Aggregate;
  /** fetch data from the table: "regional_data_connectors" using primary key columns */
  regional_data_connectors_by_pk?: Maybe<Regional_Data_Connectors>;
  /** An array relationship */
  regional_metrics: Array<Regional_Metrics>;
  /** An aggregate relationship */
  regional_metrics_aggregate: Regional_Metrics_Aggregate;
  /** fetch data from the table: "regional_metrics" using primary key columns */
  regional_metrics_by_pk?: Maybe<Regional_Metrics>;
  /** fetch data from the table: "saml_idp" */
  saml_idp: Array<Saml_Idp>;
  /** fetch aggregated fields from the table: "saml_idp" */
  saml_idp_aggregate: Saml_Idp_Aggregate;
  /** fetch data from the table: "saml_idp" using primary key columns */
  saml_idp_by_pk?: Maybe<Saml_Idp>;
  /** execute function "search_project_login_status" which returns "search_project_login_status_results" */
  search_project_login_status: Array<Search_Project_Login_Status_Results>;
  /**
   * execute function "search_project_login_status" and query aggregates on result
   * of table type "search_project_login_status_results"
   */
  search_project_login_status_aggregate: Search_Project_Login_Status_Results_Aggregate;
  /** fetch data from the table: "search_project_login_status_results" */
  search_project_login_status_results: Array<Search_Project_Login_Status_Results>;
  /** fetch aggregated fields from the table: "search_project_login_status_results" */
  search_project_login_status_results_aggregate: Search_Project_Login_Status_Results_Aggregate;
  /** execute function "search_tenant_group_has_least_members" which returns "tenant_group" */
  search_tenant_group_has_least_members: Array<Tenant_Group>;
  /** execute function "search_tenant_group_has_least_members" and query aggregates on result of table type "tenant_group" */
  search_tenant_group_has_least_members_aggregate: Tenant_Group_Aggregate;
  /** fetch data from the table: "slack_config" */
  slack_config: Array<Slack_Config>;
  /** fetch aggregated fields from the table: "slack_config" */
  slack_config_aggregate: Slack_Config_Aggregate;
  /** fetch data from the table: "slack_config" using primary key columns */
  slack_config_by_pk?: Maybe<Slack_Config>;
  status: Scalars['String'];
  /** fetch data from the table: "stripe_subscription" */
  stripe_subscription: Array<Stripe_Subscription>;
  /** fetch aggregated fields from the table: "stripe_subscription" */
  stripe_subscription_aggregate: Stripe_Subscription_Aggregate;
  /** fetch data from the table: "stripe_subscription" using primary key columns */
  stripe_subscription_by_pk?: Maybe<Stripe_Subscription>;
  /** fetch data from the table: "stripe_webhook_events" */
  stripe_webhook_events: Array<Stripe_Webhook_Events>;
  /** fetch aggregated fields from the table: "stripe_webhook_events" */
  stripe_webhook_events_aggregate: Stripe_Webhook_Events_Aggregate;
  /** fetch data from the table: "stripe_webhook_events" using primary key columns */
  stripe_webhook_events_by_pk?: Maybe<Stripe_Webhook_Events>;
  /** fetch data from the table: "super_connector_types" */
  super_connector_types: Array<Super_Connector_Types>;
  /** fetch aggregated fields from the table: "super_connector_types" */
  super_connector_types_aggregate: Super_Connector_Types_Aggregate;
  /** fetch data from the table: "super_connector_types" using primary key columns */
  super_connector_types_by_pk?: Maybe<Super_Connector_Types>;
  /** fetch data from the table: "support_plan_types" */
  support_plan_types: Array<Support_Plan_Types>;
  /** fetch aggregated fields from the table: "support_plan_types" */
  support_plan_types_aggregate: Support_Plan_Types_Aggregate;
  /** fetch data from the table: "support_plan_types" using primary key columns */
  support_plan_types_by_pk?: Maybe<Support_Plan_Types>;
  /** fetch data from the table: "survey" */
  survey: Array<Survey>;
  /** fetch aggregated fields from the table: "survey" */
  survey_aggregate: Survey_Aggregate;
  /** fetch data from the table: "survey" using primary key columns */
  survey_by_pk?: Maybe<Survey>;
  /** fetch data from the table: "survey_question" */
  survey_question: Array<Survey_Question>;
  /** fetch aggregated fields from the table: "survey_question" */
  survey_question_aggregate: Survey_Question_Aggregate;
  /** fetch data from the table: "survey_question_answer_option" */
  survey_question_answer_option: Array<Survey_Question_Answer_Option>;
  /** fetch aggregated fields from the table: "survey_question_answer_option" */
  survey_question_answer_option_aggregate: Survey_Question_Answer_Option_Aggregate;
  /** fetch data from the table: "survey_question_answer_option" using primary key columns */
  survey_question_answer_option_by_pk?: Maybe<Survey_Question_Answer_Option>;
  /** fetch data from the table: "survey_question_answers" */
  survey_question_answers: Array<Survey_Question_Answers>;
  /** fetch aggregated fields from the table: "survey_question_answers" */
  survey_question_answers_aggregate: Survey_Question_Answers_Aggregate;
  /** fetch data from the table: "survey_question_answers" using primary key columns */
  survey_question_answers_by_pk?: Maybe<Survey_Question_Answers>;
  /** fetch data from the table: "survey_question" using primary key columns */
  survey_question_by_pk?: Maybe<Survey_Question>;
  /** fetch data from the table: "survey_question_kind" */
  survey_question_kind: Array<Survey_Question_Kind>;
  /** fetch aggregated fields from the table: "survey_question_kind" */
  survey_question_kind_aggregate: Survey_Question_Kind_Aggregate;
  /** fetch data from the table: "survey_question_kind" using primary key columns */
  survey_question_kind_by_pk?: Maybe<Survey_Question_Kind>;
  /** An array relationship */
  survey_question_options: Array<Survey_Question_Options>;
  /** An aggregate relationship */
  survey_question_options_aggregate: Survey_Question_Options_Aggregate;
  /** fetch data from the table: "survey_question_options" using primary key columns */
  survey_question_options_by_pk?: Maybe<Survey_Question_Options>;
  /** fetch data from the table: "survey_v2" */
  survey_v2: Array<Survey_V2>;
  /** fetch aggregated fields from the table: "survey_v2" */
  survey_v2_aggregate: Survey_V2_Aggregate;
  /** fetch data from the table: "survey_v2" using primary key columns */
  survey_v2_by_pk?: Maybe<Survey_V2>;
  /** fetch data from the table: "survey_v2_question" */
  survey_v2_question: Array<Survey_V2_Question>;
  /** fetch aggregated fields from the table: "survey_v2_question" */
  survey_v2_question_aggregate: Survey_V2_Question_Aggregate;
  /** fetch data from the table: "survey_v2_question" using primary key columns */
  survey_v2_question_by_pk?: Maybe<Survey_V2_Question>;
  /** fetch data from the table: "survey_v2_question_kind" */
  survey_v2_question_kind: Array<Survey_V2_Question_Kind>;
  /** fetch aggregated fields from the table: "survey_v2_question_kind" */
  survey_v2_question_kind_aggregate: Survey_V2_Question_Kind_Aggregate;
  /** fetch data from the table: "survey_v2_question_kind" using primary key columns */
  survey_v2_question_kind_by_pk?: Maybe<Survey_V2_Question_Kind>;
  /** fetch data from the table: "survey_v2_question_option" */
  survey_v2_question_option: Array<Survey_V2_Question_Option>;
  /** fetch data from the table: "survey_v2_question_option_additional_info_config" */
  survey_v2_question_option_additional_info_config: Array<Survey_V2_Question_Option_Additional_Info_Config>;
  /** fetch aggregated fields from the table: "survey_v2_question_option_additional_info_config" */
  survey_v2_question_option_additional_info_config_aggregate: Survey_V2_Question_Option_Additional_Info_Config_Aggregate;
  /** fetch data from the table: "survey_v2_question_option_additional_info_config" using primary key columns */
  survey_v2_question_option_additional_info_config_by_pk?: Maybe<Survey_V2_Question_Option_Additional_Info_Config>;
  /** fetch aggregated fields from the table: "survey_v2_question_option" */
  survey_v2_question_option_aggregate: Survey_V2_Question_Option_Aggregate;
  /** fetch data from the table: "survey_v2_question_option" using primary key columns */
  survey_v2_question_option_by_pk?: Maybe<Survey_V2_Question_Option>;
  /** fetch data from the table: "survey_v2_response" */
  survey_v2_response: Array<Survey_V2_Response>;
  /** fetch aggregated fields from the table: "survey_v2_response" */
  survey_v2_response_aggregate: Survey_V2_Response_Aggregate;
  /** fetch data from the table: "survey_v2_response_answer" */
  survey_v2_response_answer: Array<Survey_V2_Response_Answer>;
  /** fetch aggregated fields from the table: "survey_v2_response_answer" */
  survey_v2_response_answer_aggregate: Survey_V2_Response_Answer_Aggregate;
  /** fetch data from the table: "survey_v2_response_answer" using primary key columns */
  survey_v2_response_answer_by_pk?: Maybe<Survey_V2_Response_Answer>;
  /** fetch data from the table: "survey_v2_response_answer_option" */
  survey_v2_response_answer_option: Array<Survey_V2_Response_Answer_Option>;
  /** fetch aggregated fields from the table: "survey_v2_response_answer_option" */
  survey_v2_response_answer_option_aggregate: Survey_V2_Response_Answer_Option_Aggregate;
  /** fetch data from the table: "survey_v2_response_answer_option" using primary key columns */
  survey_v2_response_answer_option_by_pk?: Maybe<Survey_V2_Response_Answer_Option>;
  /** fetch data from the table: "survey_v2_response" using primary key columns */
  survey_v2_response_by_pk?: Maybe<Survey_V2_Response>;
  /** fetch data from the table: "task_event" */
  task_event: Array<Task_Event>;
  /** fetch aggregated fields from the table: "task_event" */
  task_event_aggregate: Task_Event_Aggregate;
  /** fetch data from the table: "task_event" using primary key columns */
  task_event_by_pk?: Maybe<Task_Event>;
  /** fetch data from the table: "taskq_worker_event_latest" */
  taskq_worker_event_latest: Array<Taskq_Worker_Event_Latest>;
  /** fetch aggregated fields from the table: "taskq_worker_event_latest" */
  taskq_worker_event_latest_aggregate: Taskq_Worker_Event_Latest_Aggregate;
  /** An array relationship */
  tasks: Array<Tasks>;
  /** An aggregate relationship */
  tasks_aggregate: Tasks_Aggregate;
  /** fetch data from the table: "tasks" using primary key columns */
  tasks_by_pk?: Maybe<Tasks>;
  /** fetch data from the table: "tenant" */
  tenant: Array<Tenant>;
  /** fetch data from the table: "tenant_active_status_reason" */
  tenant_active_status_reason: Array<Tenant_Active_Status_Reason>;
  /** fetch aggregated fields from the table: "tenant_active_status_reason" */
  tenant_active_status_reason_aggregate: Tenant_Active_Status_Reason_Aggregate;
  /** fetch data from the table: "tenant_active_status_reason" using primary key columns */
  tenant_active_status_reason_by_pk?: Maybe<Tenant_Active_Status_Reason>;
  /** fetch aggregated fields from the table: "tenant" */
  tenant_aggregate: Tenant_Aggregate;
  /** fetch data from the table: "tenant" using primary key columns */
  tenant_by_pk?: Maybe<Tenant>;
  /** fetch data from the table: "tenant_group" */
  tenant_group: Array<Tenant_Group>;
  /** fetch aggregated fields from the table: "tenant_group" */
  tenant_group_aggregate: Tenant_Group_Aggregate;
  /** fetch data from the table: "tenant_group" using primary key columns */
  tenant_group_by_pk?: Maybe<Tenant_Group>;
  /** fetch data from the table: "tenant_group_member" */
  tenant_group_member: Array<Tenant_Group_Member>;
  /** fetch aggregated fields from the table: "tenant_group_member" */
  tenant_group_member_aggregate: Tenant_Group_Member_Aggregate;
  /** fetch data from the table: "tenant_group_member" using primary key columns */
  tenant_group_member_by_pk?: Maybe<Tenant_Group_Member>;
  /** An array relationship */
  tenant_public_status: Array<Tenant_Public_Status>;
  /** An aggregate relationship */
  tenant_public_status_aggregate: Tenant_Public_Status_Aggregate;
  /** fetch data from the table: "tenant_public_status" using primary key columns */
  tenant_public_status_by_pk?: Maybe<Tenant_Public_Status>;
  /** fetch data from the table: "tenant_status" */
  tenant_status: Array<Tenant_Status>;
  /** fetch aggregated fields from the table: "tenant_status" */
  tenant_status_aggregate: Tenant_Status_Aggregate;
  /** fetch data from the table: "tenant_status" using primary key columns */
  tenant_status_by_pk?: Maybe<Tenant_Status>;
  /** fetch data from the table: "trial_leads" */
  trial_leads: Array<Trial_Leads>;
  /** fetch aggregated fields from the table: "trial_leads" */
  trial_leads_aggregate: Trial_Leads_Aggregate;
  /** fetch data from the table: "trial_leads" using primary key columns */
  trial_leads_by_pk?: Maybe<Trial_Leads>;
  /** fetch data from the table: "ua_audit_logs" */
  ua_audit_logs: Array<Ua_Audit_Logs>;
  /** fetch aggregated fields from the table: "ua_audit_logs" */
  ua_audit_logs_aggregate: Ua_Audit_Logs_Aggregate;
  /** fetch data from the table: "ua_audit_logs" using primary key columns */
  ua_audit_logs_by_pk?: Maybe<Ua_Audit_Logs>;
  /** fetch data from the table: "user_activity" */
  user_activity: Array<User_Activity>;
  /** fetch aggregated fields from the table: "user_activity" */
  user_activity_aggregate: User_Activity_Aggregate;
  /** fetch data from the table: "user_activity" using primary key columns */
  user_activity_by_pk?: Maybe<User_Activity>;
  /** fetch data from the table: "user_coupon" */
  user_coupon: Array<User_Coupon>;
  /** fetch aggregated fields from the table: "user_coupon" */
  user_coupon_aggregate: User_Coupon_Aggregate;
  /** fetch data from the table: "user_coupon" using primary key columns */
  user_coupon_by_pk?: Maybe<User_Coupon>;
  /** fetch data from the table: "user_entitlement_access" */
  user_entitlement_access: Array<User_Entitlement_Access>;
  /** fetch aggregated fields from the table: "user_entitlement_access" */
  user_entitlement_access_aggregate: User_Entitlement_Access_Aggregate;
  /** fetch data from the table: "user_entitlement_access" using primary key columns */
  user_entitlement_access_by_pk?: Maybe<User_Entitlement_Access>;
  /** fetch data from the table: "user_entitlement_catalogue" */
  user_entitlement_catalogue: Array<User_Entitlement_Catalogue>;
  /** fetch aggregated fields from the table: "user_entitlement_catalogue" */
  user_entitlement_catalogue_aggregate: User_Entitlement_Catalogue_Aggregate;
  /** fetch data from the table: "user_entitlement_catalogue" using primary key columns */
  user_entitlement_catalogue_by_pk?: Maybe<User_Entitlement_Catalogue>;
  /** fetch data from the table: "user_entitlement_types" */
  user_entitlement_types: Array<User_Entitlement_Types>;
  /** fetch aggregated fields from the table: "user_entitlement_types" */
  user_entitlement_types_aggregate: User_Entitlement_Types_Aggregate;
  /** fetch data from the table: "user_entitlement_types" using primary key columns */
  user_entitlement_types_by_pk?: Maybe<User_Entitlement_Types>;
  /** fetch data from the table: "user_onboarding" */
  user_onboarding: Array<User_Onboarding>;
  /** fetch aggregated fields from the table: "user_onboarding" */
  user_onboarding_aggregate: User_Onboarding_Aggregate;
  /** fetch data from the table: "user_onboarding" using primary key columns */
  user_onboarding_by_pk?: Maybe<User_Onboarding>;
  /** fetch data from the table: "user_personal_access_tokens" */
  user_personal_access_tokens: Array<User_Personal_Access_Tokens>;
  /** fetch aggregated fields from the table: "user_personal_access_tokens" */
  user_personal_access_tokens_aggregate: User_Personal_Access_Tokens_Aggregate;
  /** fetch data from the table: "user_personal_access_tokens" using primary key columns */
  user_personal_access_tokens_by_pk?: Maybe<User_Personal_Access_Tokens>;
  /** fetch data from the table: "user_profile" */
  user_profile: Array<User_Profile>;
  /** fetch aggregated fields from the table: "user_profile" */
  user_profile_aggregate: User_Profile_Aggregate;
  /** fetch data from the table: "user_profile" using primary key columns */
  user_profile_by_pk?: Maybe<User_Profile>;
  /** fetch data from the table: "user_project_map" */
  user_project_map: Array<User_Project_Map>;
  /** fetch aggregated fields from the table: "user_project_map" */
  user_project_map_aggregate: User_Project_Map_Aggregate;
  /** fetch data from the table: "user_roles" */
  user_roles: Array<User_Roles>;
  /** fetch aggregated fields from the table: "user_roles" */
  user_roles_aggregate: User_Roles_Aggregate;
  /** fetch data from the table: "user_roles" using primary key columns */
  user_roles_by_pk?: Maybe<User_Roles>;
  /** fetch data from the table: "user_vpc_policy" */
  user_vpc_policy: Array<User_Vpc_Policy>;
  /** fetch aggregated fields from the table: "user_vpc_policy" */
  user_vpc_policy_aggregate: User_Vpc_Policy_Aggregate;
  /** fetch data from the table: "user_vpc_policy" using primary key columns */
  user_vpc_policy_by_pk?: Maybe<User_Vpc_Policy>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
  /** fetch data from the table: "users_public" */
  users_public: Array<Users_Public>;
  /** fetch aggregated fields from the table: "users_public" */
  users_public_aggregate: Users_Public_Aggregate;
  validTenantName?: Maybe<ValidTenantNameResponse>;
  /** fetch data from the table: "vercel_integration" */
  vercel_integration: Array<Vercel_Integration>;
  /** fetch aggregated fields from the table: "vercel_integration" */
  vercel_integration_aggregate: Vercel_Integration_Aggregate;
  /** fetch data from the table: "vercel_integration" using primary key columns */
  vercel_integration_by_pk?: Maybe<Vercel_Integration>;
  /** An array relationship */
  vercel_integration_connections: Array<Vercel_Integration_Connections>;
  /** An aggregate relationship */
  vercel_integration_connections_aggregate: Vercel_Integration_Connections_Aggregate;
  /** fetch data from the table: "vercel_integration_connections" using primary key columns */
  vercel_integration_connections_by_pk?: Maybe<Vercel_Integration_Connections>;
  vercelGetProjects?: Maybe<VercelGetProjectsOutput>;
  /** fetch data from the table: "vpc_peering" */
  vpc_peering: Array<Vpc_Peering>;
  /** fetch aggregated fields from the table: "vpc_peering" */
  vpc_peering_aggregate: Vpc_Peering_Aggregate;
  /** fetch data from the table: "vpc_peering" using primary key columns */
  vpc_peering_by_pk?: Maybe<Vpc_Peering>;
  /** fetch data from the table: "vpc_peering_direction" */
  vpc_peering_direction: Array<Vpc_Peering_Direction>;
  /** fetch aggregated fields from the table: "vpc_peering_direction" */
  vpc_peering_direction_aggregate: Vpc_Peering_Direction_Aggregate;
  /** fetch data from the table: "vpc_peering_direction" using primary key columns */
  vpc_peering_direction_by_pk?: Maybe<Vpc_Peering_Direction>;
  /** fetch data from the table: "vpc_status" */
  vpc_status: Array<Vpc_Status>;
  /** fetch aggregated fields from the table: "vpc_status" */
  vpc_status_aggregate: Vpc_Status_Aggregate;
  /** fetch data from the table: "vpc_status" using primary key columns */
  vpc_status_by_pk?: Maybe<Vpc_Status>;
  /** fetch data from the table: "zendesk_support_category" */
  zendesk_support_category: Array<Zendesk_Support_Category>;
  /** fetch aggregated fields from the table: "zendesk_support_category" */
  zendesk_support_category_aggregate: Zendesk_Support_Category_Aggregate;
  /** fetch data from the table: "zendesk_support_category" using primary key columns */
  zendesk_support_category_by_pk?: Maybe<Zendesk_Support_Category>;
  /** fetch data from the table: "zendesk_support_tickets" */
  zendesk_support_tickets: Array<Zendesk_Support_Tickets>;
  /** fetch aggregated fields from the table: "zendesk_support_tickets" */
  zendesk_support_tickets_aggregate: Zendesk_Support_Tickets_Aggregate;
  /** fetch data from the table: "zendesk_support_tickets" using primary key columns */
  zendesk_support_tickets_by_pk?: Maybe<Zendesk_Support_Tickets>;
};

export type Query_RootAlert_ConfigArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Order_By>>;
  where?: Maybe<Alert_Config_Bool_Exp>;
};

export type Query_RootAlert_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Order_By>>;
  where?: Maybe<Alert_Config_Bool_Exp>;
};

export type Query_RootAlert_Config_Alert_TypeArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Alert_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Alert_Type_Order_By>>;
  where?: Maybe<Alert_Config_Alert_Type_Bool_Exp>;
};

export type Query_RootAlert_Config_Alert_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Alert_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Alert_Type_Order_By>>;
  where?: Maybe<Alert_Config_Alert_Type_Bool_Exp>;
};

export type Query_RootAlert_Config_Alert_Type_By_PkArgs = {
  project_id: Scalars['uuid'];
  type: Scalars['String'];
};

export type Query_RootAlert_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Query_RootAlert_Config_ServiceArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Service_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Service_Order_By>>;
  where?: Maybe<Alert_Config_Service_Bool_Exp>;
};

export type Query_RootAlert_Config_Service_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Service_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Service_Order_By>>;
  where?: Maybe<Alert_Config_Service_Bool_Exp>;
};

export type Query_RootAlert_Config_Service_By_PkArgs = {
  project_id: Scalars['uuid'];
  type: Alert_Service_Type_Enum;
};

export type Query_RootAlert_Service_TypeArgs = {
  distinct_on?: Maybe<Array<Alert_Service_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Service_Type_Order_By>>;
  where?: Maybe<Alert_Service_Type_Bool_Exp>;
};

export type Query_RootAlert_Service_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Service_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Service_Type_Order_By>>;
  where?: Maybe<Alert_Service_Type_Bool_Exp>;
};

export type Query_RootAlert_Service_Type_By_PkArgs = {
  name: Scalars['String'];
};

export type Query_RootAlert_TypeArgs = {
  distinct_on?: Maybe<Array<Alert_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Type_Order_By>>;
  where?: Maybe<Alert_Type_Bool_Exp>;
};

export type Query_RootAlert_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Type_Order_By>>;
  where?: Maybe<Alert_Type_Bool_Exp>;
};

export type Query_RootAlert_Type_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootAzuremonitor_ConfigArgs = {
  distinct_on?: Maybe<Array<Azuremonitor_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Azuremonitor_Config_Order_By>>;
  where?: Maybe<Azuremonitor_Config_Bool_Exp>;
};

export type Query_RootAzuremonitor_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Azuremonitor_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Azuremonitor_Config_Order_By>>;
  where?: Maybe<Azuremonitor_Config_Bool_Exp>;
};

export type Query_RootAzuremonitor_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Query_RootBilling_AddressArgs = {
  distinct_on?: Maybe<Array<Billing_Address_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Billing_Address_Order_By>>;
  where?: Maybe<Billing_Address_Bool_Exp>;
};

export type Query_RootBilling_Address_AggregateArgs = {
  distinct_on?: Maybe<Array<Billing_Address_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Billing_Address_Order_By>>;
  where?: Maybe<Billing_Address_Bool_Exp>;
};

export type Query_RootBilling_Address_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootCentral_CloudArgs = {
  distinct_on?: Maybe<Array<Central_Cloud_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Central_Cloud_Order_By>>;
  where?: Maybe<Central_Cloud_Bool_Exp>;
};

export type Query_RootCentral_Cloud_AggregateArgs = {
  distinct_on?: Maybe<Array<Central_Cloud_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Central_Cloud_Order_By>>;
  where?: Maybe<Central_Cloud_Bool_Exp>;
};

export type Query_RootCentral_Cloud_By_PkArgs = {
  cloud: Cloud_Enum;
};

export type Query_RootChange_Email_RequestArgs = {
  distinct_on?: Maybe<Array<Change_Email_Request_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Change_Email_Request_Order_By>>;
  where?: Maybe<Change_Email_Request_Bool_Exp>;
};

export type Query_RootChange_Email_Request_AggregateArgs = {
  distinct_on?: Maybe<Array<Change_Email_Request_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Change_Email_Request_Order_By>>;
  where?: Maybe<Change_Email_Request_Bool_Exp>;
};

export type Query_RootChange_Email_Request_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootCicd_Deployment_Pipeline_ConfigArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pipeline_Config_Bool_Exp>;
};

export type Query_RootCicd_Deployment_Pipeline_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pipeline_Config_Bool_Exp>;
};

export type Query_RootCicd_Deployment_Pipeline_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootCicd_Deployment_PoolArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Bool_Exp>;
};

export type Query_RootCicd_Deployment_Pool_AggregateArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Bool_Exp>;
};

export type Query_RootCicd_Deployment_Pool_MemberArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Member_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
};

export type Query_RootCicd_Deployment_Pool_Member_AggregateArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Member_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
};

export type Query_RootCicd_Get_Matching_Pipeline_ConfigArgs = {
  args: Cicd_Get_Matching_Pipeline_Config_Args;
  distinct_on?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pipeline_Config_Bool_Exp>;
};

export type Query_RootCicd_Get_Matching_Pipeline_Config_AggregateArgs = {
  args: Cicd_Get_Matching_Pipeline_Config_Args;
  distinct_on?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pipeline_Config_Bool_Exp>;
};

export type Query_RootCloudArgs = {
  distinct_on?: Maybe<Array<Cloud_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Order_By>>;
  where?: Maybe<Cloud_Bool_Exp>;
};

export type Query_RootCloud_AggregateArgs = {
  distinct_on?: Maybe<Array<Cloud_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Order_By>>;
  where?: Maybe<Cloud_Bool_Exp>;
};

export type Query_RootCloud_By_PkArgs = {
  name: Scalars['String'];
};

export type Query_RootCloud_MetadataArgs = {
  distinct_on?: Maybe<Array<Cloud_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Metadata_Order_By>>;
  where?: Maybe<Cloud_Metadata_Bool_Exp>;
};

export type Query_RootCloud_Metadata_AggregateArgs = {
  distinct_on?: Maybe<Array<Cloud_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Metadata_Order_By>>;
  where?: Maybe<Cloud_Metadata_Bool_Exp>;
};

export type Query_RootCloud_Metadata_By_PkArgs = {
  cloud: Cloud_Enum;
};

export type Query_RootCloud_Regions_By_PlanArgs = {
  distinct_on?: Maybe<Array<Cloud_Regions_By_Plan_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Regions_By_Plan_Order_By>>;
  where?: Maybe<Cloud_Regions_By_Plan_Bool_Exp>;
};

export type Query_RootCloud_Regions_By_Plan_AggregateArgs = {
  distinct_on?: Maybe<Array<Cloud_Regions_By_Plan_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Regions_By_Plan_Order_By>>;
  where?: Maybe<Cloud_Regions_By_Plan_Bool_Exp>;
};

export type Query_RootCompute_Project_Agg_Db_Usage_UserArgs = {
  args: Compute_Project_Agg_Db_Usage_User_Args;
  distinct_on?: Maybe<Array<Project_Db_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Db_Usage_Agg_User_Bool_Exp>;
};

export type Query_RootCompute_Project_Agg_Db_Usage_User_AggregateArgs = {
  args: Compute_Project_Agg_Db_Usage_User_Args;
  distinct_on?: Maybe<Array<Project_Db_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Db_Usage_Agg_User_Bool_Exp>;
};

export type Query_RootCompute_Project_Agg_UsageArgs = {
  args: Compute_Project_Agg_Usage_Args;
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Query_RootCompute_Project_Agg_Usage_AggregateArgs = {
  args: Compute_Project_Agg_Usage_Args;
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Query_RootCompute_Project_Agg_Usage_PrometheusArgs = {
  args: Compute_Project_Agg_Usage_Prometheus_Args;
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Query_RootCompute_Project_Agg_Usage_Prometheus_AggregateArgs = {
  args: Compute_Project_Agg_Usage_Prometheus_Args;
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Query_RootCompute_Project_Agg_Usage_Prometheus_UserArgs = {
  args: Compute_Project_Agg_Usage_Prometheus_User_Args;
  distinct_on?: Maybe<
    Array<Project_Data_Usage_Prometheus_Agg_User_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>;
};

export type Query_RootCompute_Project_Agg_Usage_Prometheus_User_AggregateArgs =
  {
    args: Compute_Project_Agg_Usage_Prometheus_User_Args;
    distinct_on?: Maybe<
      Array<Project_Data_Usage_Prometheus_Agg_User_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Agg_User_Order_By>>;
    where?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>;
  };

export type Query_RootCompute_Project_Agg_Usage_UserArgs = {
  args: Compute_Project_Agg_Usage_User_Args;
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_User_Bool_Exp>;
};

export type Query_RootCompute_Project_Agg_Usage_User_AggregateArgs = {
  args: Compute_Project_Agg_Usage_User_Args;
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_User_Bool_Exp>;
};

export type Query_RootCompute_Unit_ConfigArgs = {
  distinct_on?: Maybe<Array<Compute_Unit_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Compute_Unit_Config_Order_By>>;
  where?: Maybe<Compute_Unit_Config_Bool_Exp>;
};

export type Query_RootCompute_Unit_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Compute_Unit_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Compute_Unit_Config_Order_By>>;
  where?: Maybe<Compute_Unit_Config_Bool_Exp>;
};

export type Query_RootCompute_Unit_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootConfigArgs = {
  distinct_on?: Maybe<Array<Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Order_By>>;
  where?: Maybe<Config_Bool_Exp>;
};

export type Query_RootConfig_AggregateArgs = {
  distinct_on?: Maybe<Array<Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Order_By>>;
  where?: Maybe<Config_Bool_Exp>;
};

export type Query_RootConfig_By_PkArgs = {
  tenant_id: Scalars['uuid'];
};

export type Query_RootConfig_StatusArgs = {
  distinct_on?: Maybe<Array<Config_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Status_Order_By>>;
  where?: Maybe<Config_Status_Bool_Exp>;
};

export type Query_RootConfig_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Config_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Status_Order_By>>;
  where?: Maybe<Config_Status_Bool_Exp>;
};

export type Query_RootConfig_Status_By_PkArgs = {
  hash: Scalars['String'];
  tenant_id: Scalars['uuid'];
  worker_id: Scalars['uuid'];
};

export type Query_RootConnector_ConfigArgs = {
  distinct_on?: Maybe<Array<Connector_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Config_Order_By>>;
  where?: Maybe<Connector_Config_Bool_Exp>;
};

export type Query_RootConnector_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Connector_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Config_Order_By>>;
  where?: Maybe<Connector_Config_Bool_Exp>;
};

export type Query_RootConnector_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootConnector_Connector_DeploymentArgs = {
  distinct_on?: Maybe<Array<Connector_Connector_Deployment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Connector_Deployment_Order_By>>;
  where?: Maybe<Connector_Connector_Deployment_Bool_Exp>;
};

export type Query_RootConnector_Connector_Deployment_AggregateArgs = {
  distinct_on?: Maybe<Array<Connector_Connector_Deployment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Connector_Deployment_Order_By>>;
  where?: Maybe<Connector_Connector_Deployment_Bool_Exp>;
};

export type Query_RootConnector_Connector_Deployment_By_PkArgs = {
  id: Scalars['connector_uuid'];
};

export type Query_RootConnector_DeploymentsArgs = {
  distinct_on?: Maybe<Array<Connector_Deployments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Deployments_Order_By>>;
  where?: Maybe<Connector_Deployments_Bool_Exp>;
};

export type Query_RootConnector_Deployments_AggregateArgs = {
  distinct_on?: Maybe<Array<Connector_Deployments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Deployments_Order_By>>;
  where?: Maybe<Connector_Deployments_Bool_Exp>;
};

export type Query_RootConnector_Deployments_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootCouponArgs = {
  distinct_on?: Maybe<Array<Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Order_By>>;
  where?: Maybe<Coupon_Bool_Exp>;
};

export type Query_RootCoupon_AggregateArgs = {
  distinct_on?: Maybe<Array<Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Order_By>>;
  where?: Maybe<Coupon_Bool_Exp>;
};

export type Query_RootCoupon_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootCoupon_DurationArgs = {
  distinct_on?: Maybe<Array<Coupon_Duration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Duration_Order_By>>;
  where?: Maybe<Coupon_Duration_Bool_Exp>;
};

export type Query_RootCoupon_Duration_AggregateArgs = {
  distinct_on?: Maybe<Array<Coupon_Duration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Duration_Order_By>>;
  where?: Maybe<Coupon_Duration_Bool_Exp>;
};

export type Query_RootCoupon_Duration_By_PkArgs = {
  duration: Scalars['String'];
};

export type Query_RootCoupon_TypeArgs = {
  distinct_on?: Maybe<Array<Coupon_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Type_Order_By>>;
  where?: Maybe<Coupon_Type_Bool_Exp>;
};

export type Query_RootCoupon_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Coupon_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Type_Order_By>>;
  where?: Maybe<Coupon_Type_Bool_Exp>;
};

export type Query_RootCoupon_Type_By_PkArgs = {
  type: Scalars['String'];
};

export type Query_RootCustom_DomainArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Order_By>>;
  where?: Maybe<Custom_Domain_Bool_Exp>;
};

export type Query_RootCustom_Domain_AggregateArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Order_By>>;
  where?: Maybe<Custom_Domain_Bool_Exp>;
};

export type Query_RootCustom_Domain_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootCustom_Domain_CloudflareArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Cloudflare_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Cloudflare_Order_By>>;
  where?: Maybe<Custom_Domain_Cloudflare_Bool_Exp>;
};

export type Query_RootCustom_Domain_Cloudflare_AggregateArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Cloudflare_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Cloudflare_Order_By>>;
  where?: Maybe<Custom_Domain_Cloudflare_Bool_Exp>;
};

export type Query_RootCustom_Domain_Cloudflare_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootCustom_Domain_Cloudflare_DnsArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Cloudflare_Dns_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Cloudflare_Dns_Order_By>>;
  where?: Maybe<Custom_Domain_Cloudflare_Dns_Bool_Exp>;
};

export type Query_RootCustom_Domain_Cloudflare_Dns_AggregateArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Cloudflare_Dns_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Cloudflare_Dns_Order_By>>;
  where?: Maybe<Custom_Domain_Cloudflare_Dns_Bool_Exp>;
};

export type Query_RootCustom_Domain_Cloudflare_Dns_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootCustomer_UsageArgs = {
  distinct_on?: Maybe<Array<Customer_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Usage_Order_By>>;
  where?: Maybe<Customer_Usage_Bool_Exp>;
};

export type Query_RootCustomer_Usage_AggregateArgs = {
  distinct_on?: Maybe<Array<Customer_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Usage_Order_By>>;
  where?: Maybe<Customer_Usage_Bool_Exp>;
};

export type Query_RootCustomer_Usage_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootData_Connector_TypeArgs = {
  distinct_on?: Maybe<Array<Data_Connector_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Data_Connector_Type_Order_By>>;
  where?: Maybe<Data_Connector_Type_Bool_Exp>;
};

export type Query_RootData_Connector_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Data_Connector_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Data_Connector_Type_Order_By>>;
  where?: Maybe<Data_Connector_Type_Bool_Exp>;
};

export type Query_RootData_Connector_Type_By_PkArgs = {
  name: Scalars['String'];
};

export type Query_RootDatadog_ConfigArgs = {
  distinct_on?: Maybe<Array<Datadog_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Datadog_Config_Order_By>>;
  where?: Maybe<Datadog_Config_Bool_Exp>;
};

export type Query_RootDatadog_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Datadog_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Datadog_Config_Order_By>>;
  where?: Maybe<Datadog_Config_Bool_Exp>;
};

export type Query_RootDatadog_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Query_RootDb_LatencyArgs = {
  distinct_on?: Maybe<Array<Db_Latency_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Db_Latency_Order_By>>;
  where?: Maybe<Db_Latency_Bool_Exp>;
};

export type Query_RootDb_Latency_AggregateArgs = {
  distinct_on?: Maybe<Array<Db_Latency_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Db_Latency_Order_By>>;
  where?: Maybe<Db_Latency_Bool_Exp>;
};

export type Query_RootDb_Latency_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDdn_BuildArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Order_By>>;
  where?: Maybe<Ddn_Build_Bool_Exp>;
};

export type Query_RootDdn_Build_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Order_By>>;
  where?: Maybe<Ddn_Build_Bool_Exp>;
};

export type Query_RootDdn_Build_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDdn_Build_Sync_StatusArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Status_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

export type Query_RootDdn_Build_Sync_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Status_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

export type Query_RootDdn_Build_Sync_Status_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDdn_Build_Sync_WorkerArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Worker_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Worker_Bool_Exp>;
};

export type Query_RootDdn_Build_Sync_Worker_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Worker_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Worker_Bool_Exp>;
};

export type Query_RootDdn_Build_Sync_Worker_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDdn_EnvironmentArgs = {
  distinct_on?: Maybe<Array<Ddn_Environment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Environment_Order_By>>;
  where?: Maybe<Ddn_Environment_Bool_Exp>;
};

export type Query_RootDdn_Environment_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Environment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Environment_Order_By>>;
  where?: Maybe<Ddn_Environment_Bool_Exp>;
};

export type Query_RootDdn_Environment_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDdn_Project_Entitlement_AccessArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Access_Bool_Exp>;
};

export type Query_RootDdn_Project_Entitlement_Access_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Access_Bool_Exp>;
};

export type Query_RootDdn_Project_Entitlement_Access_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDdn_Project_Entitlement_CatalogueArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Catalogue_Bool_Exp>;
};

export type Query_RootDdn_Project_Entitlement_Catalogue_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Catalogue_Bool_Exp>;
};

export type Query_RootDdn_Project_Entitlement_Catalogue_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDdn_Project_Entitlement_TypesArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Types_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Types_Bool_Exp>;
};

export type Query_RootDdn_Project_Entitlement_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Types_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Types_Bool_Exp>;
};

export type Query_RootDdn_Project_Entitlement_Types_By_PkArgs = {
  value: Scalars['String'];
};

export type Query_RootDdn_ProjectsArgs = {
  distinct_on?: Maybe<Array<Ddn_Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Projects_Order_By>>;
  where?: Maybe<Ddn_Projects_Bool_Exp>;
};

export type Query_RootDdn_Projects_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Projects_Order_By>>;
  where?: Maybe<Ddn_Projects_Bool_Exp>;
};

export type Query_RootDdn_Projects_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDdn_TunnelArgs = {
  distinct_on?: Maybe<Array<Ddn_Tunnel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Tunnel_Order_By>>;
  where?: Maybe<Ddn_Tunnel_Bool_Exp>;
};

export type Query_RootDdn_Tunnel_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Tunnel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Tunnel_Order_By>>;
  where?: Maybe<Ddn_Tunnel_Bool_Exp>;
};

export type Query_RootDdn_Tunnel_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDdn_Tunnel_ClusterArgs = {
  distinct_on?: Maybe<Array<Ddn_Tunnel_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Tunnel_Cluster_Order_By>>;
  where?: Maybe<Ddn_Tunnel_Cluster_Bool_Exp>;
};

export type Query_RootDdn_Tunnel_Cluster_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Tunnel_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Tunnel_Cluster_Order_By>>;
  where?: Maybe<Ddn_Tunnel_Cluster_Bool_Exp>;
};

export type Query_RootDdn_Tunnel_Cluster_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDedicated_Cloud_BillsArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
};

export type Query_RootDedicated_Cloud_Bills_AggregateArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
};

export type Query_RootDedicated_Cloud_Bills_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDedicated_Cloud_Bills_DetailsArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Details_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Details_Bool_Exp>;
};

export type Query_RootDedicated_Cloud_Bills_Details_AggregateArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Details_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Details_Bool_Exp>;
};

export type Query_RootDedicated_Cloud_Bills_Details_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDedicated_Cloud_CommitmentsArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Commitments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Commitments_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Commitments_Bool_Exp>;
};

export type Query_RootDedicated_Cloud_Commitments_AggregateArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Commitments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Commitments_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Commitments_Bool_Exp>;
};

export type Query_RootDedicated_Cloud_Commitments_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDedicated_VpcArgs = {
  distinct_on?: Maybe<Array<Dedicated_Vpc_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Vpc_Order_By>>;
  where?: Maybe<Dedicated_Vpc_Bool_Exp>;
};

export type Query_RootDedicated_Vpc_AggregateArgs = {
  distinct_on?: Maybe<Array<Dedicated_Vpc_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Vpc_Order_By>>;
  where?: Maybe<Dedicated_Vpc_Bool_Exp>;
};

export type Query_RootDedicated_Vpc_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootDelete_UserArgs = {
  distinct_on?: Maybe<Array<Delete_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Order_By>>;
  where?: Maybe<Delete_User_Bool_Exp>;
};

export type Query_RootDelete_User_AggregateArgs = {
  distinct_on?: Maybe<Array<Delete_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Order_By>>;
  where?: Maybe<Delete_User_Bool_Exp>;
};

export type Query_RootDelete_User_By_PkArgs = {
  user_id: Scalars['uuid'];
};

export type Query_RootDelete_User_StatusArgs = {
  distinct_on?: Maybe<Array<Delete_User_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Status_Order_By>>;
  where?: Maybe<Delete_User_Status_Bool_Exp>;
};

export type Query_RootDelete_User_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Delete_User_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Status_Order_By>>;
  where?: Maybe<Delete_User_Status_Bool_Exp>;
};

export type Query_RootDelete_User_Status_By_PkArgs = {
  status: Scalars['String'];
};

export type Query_RootDelete_User_TasksArgs = {
  distinct_on?: Maybe<Array<Delete_User_Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Tasks_Order_By>>;
  where?: Maybe<Delete_User_Tasks_Bool_Exp>;
};

export type Query_RootDelete_User_Tasks_AggregateArgs = {
  distinct_on?: Maybe<Array<Delete_User_Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Tasks_Order_By>>;
  where?: Maybe<Delete_User_Tasks_Bool_Exp>;
};

export type Query_RootDelete_User_Tasks_By_PkArgs = {
  task_name: Scalars['String'];
  user_id: Scalars['uuid'];
};

export type Query_RootEmail_LogArgs = {
  distinct_on?: Maybe<Array<Email_Log_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Email_Log_Order_By>>;
  where?: Maybe<Email_Log_Bool_Exp>;
};

export type Query_RootEmail_Log_AggregateArgs = {
  distinct_on?: Maybe<Array<Email_Log_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Email_Log_Order_By>>;
  where?: Maybe<Email_Log_Bool_Exp>;
};

export type Query_RootEmail_Log_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootEnterprise_UsersArgs = {
  distinct_on?: Maybe<Array<Enterprise_Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Enterprise_Users_Order_By>>;
  where?: Maybe<Enterprise_Users_Bool_Exp>;
};

export type Query_RootEnterprise_Users_AggregateArgs = {
  distinct_on?: Maybe<Array<Enterprise_Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Enterprise_Users_Order_By>>;
  where?: Maybe<Enterprise_Users_Bool_Exp>;
};

export type Query_RootEnterprise_Users_By_PkArgs = {
  customer_email: Scalars['citext'];
};

export type Query_RootExperimentsArgs = {
  distinct_on?: Maybe<Array<Experiments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Order_By>>;
  where?: Maybe<Experiments_Bool_Exp>;
};

export type Query_RootExperiments_AggregateArgs = {
  distinct_on?: Maybe<Array<Experiments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Order_By>>;
  where?: Maybe<Experiments_Bool_Exp>;
};

export type Query_RootExperiments_By_PkArgs = {
  experiment: Scalars['String'];
};

export type Query_RootExperiments_CohortArgs = {
  distinct_on?: Maybe<Array<Experiments_Cohort_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Cohort_Order_By>>;
  where?: Maybe<Experiments_Cohort_Bool_Exp>;
};

export type Query_RootExperiments_Cohort_AggregateArgs = {
  distinct_on?: Maybe<Array<Experiments_Cohort_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Cohort_Order_By>>;
  where?: Maybe<Experiments_Cohort_Bool_Exp>;
};

export type Query_RootExperiments_Cohort_By_PkArgs = {
  experiment: Experiments_Enum;
  user_id: Scalars['uuid'];
};

export type Query_RootExperiments_ConfigArgs = {
  distinct_on?: Maybe<Array<Experiments_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Config_Order_By>>;
  where?: Maybe<Experiments_Config_Bool_Exp>;
};

export type Query_RootExperiments_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Experiments_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Config_Order_By>>;
  where?: Maybe<Experiments_Config_Bool_Exp>;
};

export type Query_RootExperiments_Config_By_PkArgs = {
  experiment: Experiments_Enum;
};

export type Query_RootFeatureArgs = {
  distinct_on?: Maybe<Array<Feature_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Order_By>>;
  where?: Maybe<Feature_Bool_Exp>;
};

export type Query_RootFeature_AccessArgs = {
  distinct_on?: Maybe<Array<Feature_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Access_Order_By>>;
  where?: Maybe<Feature_Access_Bool_Exp>;
};

export type Query_RootFeature_Access_AggregateArgs = {
  distinct_on?: Maybe<Array<Feature_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Access_Order_By>>;
  where?: Maybe<Feature_Access_Bool_Exp>;
};

export type Query_RootFeature_Access_By_PkArgs = {
  email: Scalars['String'];
  feature: Feature_Enum;
};

export type Query_RootFeature_AggregateArgs = {
  distinct_on?: Maybe<Array<Feature_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Order_By>>;
  where?: Maybe<Feature_Bool_Exp>;
};

export type Query_RootFeature_By_PkArgs = {
  name: Scalars['String'];
};

export type Query_RootFeature_ConfigArgs = {
  distinct_on?: Maybe<Array<Feature_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Config_Order_By>>;
  where?: Maybe<Feature_Config_Bool_Exp>;
};

export type Query_RootFeature_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Feature_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Config_Order_By>>;
  where?: Maybe<Feature_Config_Bool_Exp>;
};

export type Query_RootFeature_Config_By_PkArgs = {
  feature: Feature_Enum;
};

export type Query_RootFetchDedicatedCloudClusterBillsArgs = {
  month: Scalars['Int'];
  user_id: Scalars['uuid'];
  year: Scalars['Int'];
};

export type Query_RootFetchUserSupportTicketDetailsArgs = {
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
};

export type Query_RootGateway_AmiArgs = {
  distinct_on?: Maybe<Array<Gateway_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Ami_Order_By>>;
  where?: Maybe<Gateway_Ami_Bool_Exp>;
};

export type Query_RootGateway_Ami_AggregateArgs = {
  distinct_on?: Maybe<Array<Gateway_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Ami_Order_By>>;
  where?: Maybe<Gateway_Ami_Bool_Exp>;
};

export type Query_RootGateway_Ami_By_PkArgs = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

export type Query_RootGateway_ClusterArgs = {
  distinct_on?: Maybe<Array<Gateway_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Cluster_Order_By>>;
  where?: Maybe<Gateway_Cluster_Bool_Exp>;
};

export type Query_RootGateway_Cluster_AggregateArgs = {
  distinct_on?: Maybe<Array<Gateway_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Cluster_Order_By>>;
  where?: Maybe<Gateway_Cluster_Bool_Exp>;
};

export type Query_RootGateway_Cluster_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootGateway_Cluster_TenantsArgs = {
  distinct_on?: Maybe<Array<Gateway_Cluster_Tenants_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Cluster_Tenants_Order_By>>;
  where?: Maybe<Gateway_Cluster_Tenants_Bool_Exp>;
};

export type Query_RootGateway_Cluster_Tenants_AggregateArgs = {
  distinct_on?: Maybe<Array<Gateway_Cluster_Tenants_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Cluster_Tenants_Order_By>>;
  where?: Maybe<Gateway_Cluster_Tenants_Bool_Exp>;
};

export type Query_RootGateway_WorkerArgs = {
  distinct_on?: Maybe<Array<Gateway_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Worker_Order_By>>;
  where?: Maybe<Gateway_Worker_Bool_Exp>;
};

export type Query_RootGateway_Worker_AggregateArgs = {
  distinct_on?: Maybe<Array<Gateway_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Worker_Order_By>>;
  where?: Maybe<Gateway_Worker_Bool_Exp>;
};

export type Query_RootGateway_Worker_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootGet_Aggregated_Cost_For_Project_On_Shared_PlanArgs = {
  args: Get_Aggregated_Cost_For_Project_On_Shared_Plan_Args;
  distinct_on?: Maybe<Array<Project_Total_Db_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Total_Db_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Total_Db_Usage_Agg_Bool_Exp>;
};

export type Query_RootGet_Aggregated_Cost_For_Project_On_Shared_Plan_AggregateArgs =
  {
    args: Get_Aggregated_Cost_For_Project_On_Shared_Plan_Args;
    distinct_on?: Maybe<Array<Project_Total_Db_Usage_Agg_Select_Column>>;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Total_Db_Usage_Agg_Order_By>>;
    where?: Maybe<Project_Total_Db_Usage_Agg_Bool_Exp>;
  };

export type Query_RootGetComputeUnitAllocationArgs = {
  cloud: CloudProvider;
  cluster_id: Scalars['String'];
  query_time: PrometheusQueryTime;
  roll_up_duration: PrometheusTimeDuration;
};

export type Query_RootGetComputeUnitUsageArgs = {
  cloud: CloudProvider;
  cluster_id: Scalars['String'];
  query_time: PrometheusQueryTime;
  roll_up_duration: PrometheusTimeDuration;
};

export type Query_RootGetInvoiceAndReceiptUrLsArgs = {
  invoice_id: Scalars['String'];
};

export type Query_RootGetLetsEncryptStatusArgs = {
  fqdn: Scalars['String'];
};

export type Query_RootGetNumberOfConnectedSourcesArgs = {
  projectId: Scalars['uuid'];
};

export type Query_RootGetProjectMigrationStatusArgs = {
  payload: ProjectMigrationStatusInput;
};

export type Query_RootGetReportUrlArgs = {
  key: Scalars['String'];
};

export type Query_RootGetTenantEnvArgs = {
  tenantId: Scalars['uuid'];
};

export type Query_RootGetTenantEnvConfigInfoArgs = {
  tenantId: Scalars['uuid'];
};

export type Query_RootGithub_Email_TypeArgs = {
  distinct_on?: Maybe<Array<Github_Email_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Email_Type_Order_By>>;
  where?: Maybe<Github_Email_Type_Bool_Exp>;
};

export type Query_RootGithub_Email_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Email_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Email_Type_Order_By>>;
  where?: Maybe<Github_Email_Type_Bool_Exp>;
};

export type Query_RootGithub_Email_Type_By_PkArgs = {
  email_type: Scalars['String'];
};

export type Query_RootGithub_Integration_ConfigArgs = {
  distinct_on?: Maybe<Array<Github_Integration_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Integration_Config_Order_By>>;
  where?: Maybe<Github_Integration_Config_Bool_Exp>;
};

export type Query_RootGithub_Integration_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Integration_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Integration_Config_Order_By>>;
  where?: Maybe<Github_Integration_Config_Bool_Exp>;
};

export type Query_RootGithub_Integration_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootGithub_Integration_ModeArgs = {
  distinct_on?: Maybe<Array<Github_Integration_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Integration_Mode_Order_By>>;
  where?: Maybe<Github_Integration_Mode_Bool_Exp>;
};

export type Query_RootGithub_Integration_Mode_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Integration_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Integration_Mode_Order_By>>;
  where?: Maybe<Github_Integration_Mode_Bool_Exp>;
};

export type Query_RootGithub_Integration_Mode_By_PkArgs = {
  mode: Scalars['String'];
};

export type Query_RootGithub_Push_EventArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Order_By>>;
  where?: Maybe<Github_Push_Event_Bool_Exp>;
};

export type Query_RootGithub_Push_Event_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Order_By>>;
  where?: Maybe<Github_Push_Event_Bool_Exp>;
};

export type Query_RootGithub_Push_Event_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootGithub_Push_Event_JobArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Job_Order_By>>;
  where?: Maybe<Github_Push_Event_Job_Bool_Exp>;
};

export type Query_RootGithub_Push_Event_Job_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Job_Order_By>>;
  where?: Maybe<Github_Push_Event_Job_Bool_Exp>;
};

export type Query_RootGithub_Push_Event_Job_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootHasura_AmiArgs = {
  distinct_on?: Maybe<Array<Hasura_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Ami_Order_By>>;
  where?: Maybe<Hasura_Ami_Bool_Exp>;
};

export type Query_RootHasura_Ami_AggregateArgs = {
  distinct_on?: Maybe<Array<Hasura_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Ami_Order_By>>;
  where?: Maybe<Hasura_Ami_Bool_Exp>;
};

export type Query_RootHasura_Ami_By_PkArgs = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

export type Query_RootHasura_ClusterArgs = {
  distinct_on?: Maybe<Array<Hasura_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Cluster_Order_By>>;
  where?: Maybe<Hasura_Cluster_Bool_Exp>;
};

export type Query_RootHasura_Cluster_AggregateArgs = {
  distinct_on?: Maybe<Array<Hasura_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Cluster_Order_By>>;
  where?: Maybe<Hasura_Cluster_Bool_Exp>;
};

export type Query_RootHasura_Cluster_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootHasura_WorkerArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Order_By>>;
  where?: Maybe<Hasura_Worker_Bool_Exp>;
};

export type Query_RootHasura_Worker_AggregateArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Order_By>>;
  where?: Maybe<Hasura_Worker_Bool_Exp>;
};

export type Query_RootHasura_Worker_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootHasura_Worker_TenantsArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Tenants_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Tenants_Order_By>>;
  where?: Maybe<Hasura_Worker_Tenants_Bool_Exp>;
};

export type Query_RootHasura_Worker_Tenants_AggregateArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Tenants_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Tenants_Order_By>>;
  where?: Maybe<Hasura_Worker_Tenants_Bool_Exp>;
};

export type Query_RootHeroku_IntegrationsArgs = {
  distinct_on?: Maybe<Array<Heroku_Integrations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Heroku_Integrations_Order_By>>;
  where?: Maybe<Heroku_Integrations_Bool_Exp>;
};

export type Query_RootHeroku_Integrations_AggregateArgs = {
  distinct_on?: Maybe<Array<Heroku_Integrations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Heroku_Integrations_Order_By>>;
  where?: Maybe<Heroku_Integrations_Bool_Exp>;
};

export type Query_RootHeroku_Integrations_By_PkArgs = {
  project_id: Scalars['uuid'];
  var_name: Scalars['String'];
};

export type Query_RootInactive_Project_ExclusionsArgs = {
  distinct_on?: Maybe<Array<Inactive_Project_Exclusions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Project_Exclusions_Order_By>>;
  where?: Maybe<Inactive_Project_Exclusions_Bool_Exp>;
};

export type Query_RootInactive_Project_Exclusions_AggregateArgs = {
  distinct_on?: Maybe<Array<Inactive_Project_Exclusions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Project_Exclusions_Order_By>>;
  where?: Maybe<Inactive_Project_Exclusions_Bool_Exp>;
};

export type Query_RootInactive_Project_Exclusions_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Query_RootInactive_Project_NotificationsArgs = {
  distinct_on?: Maybe<Array<Inactive_Project_Notifications_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Project_Notifications_Order_By>>;
  where?: Maybe<Inactive_Project_Notifications_Bool_Exp>;
};

export type Query_RootInactive_Project_Notifications_AggregateArgs = {
  distinct_on?: Maybe<Array<Inactive_Project_Notifications_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Project_Notifications_Order_By>>;
  where?: Maybe<Inactive_Project_Notifications_Bool_Exp>;
};

export type Query_RootInactive_Project_Notifications_By_PkArgs = {
  id: Scalars['Int'];
};

export type Query_RootInactive_Project_Suspension_ConfigArgs = {
  distinct_on?: Maybe<Array<Inactive_Project_Suspension_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Project_Suspension_Config_Order_By>>;
  where?: Maybe<Inactive_Project_Suspension_Config_Bool_Exp>;
};

export type Query_RootInactive_Project_Suspension_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Inactive_Project_Suspension_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Project_Suspension_Config_Order_By>>;
  where?: Maybe<Inactive_Project_Suspension_Config_Bool_Exp>;
};

export type Query_RootInactive_ProjectsArgs = {
  distinct_on?: Maybe<Array<Inactive_Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Projects_Order_By>>;
  where?: Maybe<Inactive_Projects_Bool_Exp>;
};

export type Query_RootInactive_Projects_AggregateArgs = {
  distinct_on?: Maybe<Array<Inactive_Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Projects_Order_By>>;
  where?: Maybe<Inactive_Projects_Bool_Exp>;
};

export type Query_RootInfra_StatusArgs = {
  distinct_on?: Maybe<Array<Infra_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Infra_Status_Order_By>>;
  where?: Maybe<Infra_Status_Bool_Exp>;
};

export type Query_RootInfra_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Infra_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Infra_Status_Order_By>>;
  where?: Maybe<Infra_Status_Bool_Exp>;
};

export type Query_RootInfra_Status_By_PkArgs = {
  status: Scalars['String'];
};

export type Query_RootInvoiceArgs = {
  distinct_on?: Maybe<Array<Invoice_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Order_By>>;
  where?: Maybe<Invoice_Bool_Exp>;
};

export type Query_RootInvoice_AggregateArgs = {
  distinct_on?: Maybe<Array<Invoice_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Order_By>>;
  where?: Maybe<Invoice_Bool_Exp>;
};

export type Query_RootInvoice_By_PkArgs = {
  stripe_invoice_id: Scalars['String'];
};

export type Query_RootInvoice_Coupon_DiscountArgs = {
  distinct_on?: Maybe<Array<Invoice_Coupon_Discount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Coupon_Discount_Order_By>>;
  where?: Maybe<Invoice_Coupon_Discount_Bool_Exp>;
};

export type Query_RootInvoice_Coupon_Discount_AggregateArgs = {
  distinct_on?: Maybe<Array<Invoice_Coupon_Discount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Coupon_Discount_Order_By>>;
  where?: Maybe<Invoice_Coupon_Discount_Bool_Exp>;
};

export type Query_RootInvoice_Coupon_Discount_By_PkArgs = {
  inv_id: Scalars['String'];
};

export type Query_RootInvoice_ItemArgs = {
  distinct_on?: Maybe<Array<Invoice_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Item_Order_By>>;
  where?: Maybe<Invoice_Item_Bool_Exp>;
};

export type Query_RootInvoice_Item_AggregateArgs = {
  distinct_on?: Maybe<Array<Invoice_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Item_Order_By>>;
  where?: Maybe<Invoice_Item_Bool_Exp>;
};

export type Query_RootInvoice_Item_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootJobsArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};

export type Query_RootJobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};

export type Query_RootJobs_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootLabelArgs = {
  distinct_on?: Maybe<Array<Label_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Label_Order_By>>;
  where?: Maybe<Label_Bool_Exp>;
};

export type Query_RootLabel_AggregateArgs = {
  distinct_on?: Maybe<Array<Label_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Label_Order_By>>;
  where?: Maybe<Label_Bool_Exp>;
};

export type Query_RootLabel_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootLetsencrypt_StatusArgs = {
  distinct_on?: Maybe<Array<Letsencrypt_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Letsencrypt_Status_Order_By>>;
  where?: Maybe<Letsencrypt_Status_Bool_Exp>;
};

export type Query_RootLetsencrypt_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Letsencrypt_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Letsencrypt_Status_Order_By>>;
  where?: Maybe<Letsencrypt_Status_Bool_Exp>;
};

export type Query_RootLetsencrypt_Status_By_PkArgs = {
  fqdn: Scalars['String'];
};

export type Query_RootLicense_ActivityArgs = {
  distinct_on?: Maybe<Array<License_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Activity_Order_By>>;
  where?: Maybe<License_Activity_Bool_Exp>;
};

export type Query_RootLicense_Activity_AggregateArgs = {
  distinct_on?: Maybe<Array<License_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Activity_Order_By>>;
  where?: Maybe<License_Activity_Bool_Exp>;
};

export type Query_RootLicense_Activity_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootLicense_InstanceArgs = {
  distinct_on?: Maybe<Array<License_Instance_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Instance_Order_By>>;
  where?: Maybe<License_Instance_Bool_Exp>;
};

export type Query_RootLicense_Instance_AggregateArgs = {
  distinct_on?: Maybe<Array<License_Instance_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Instance_Order_By>>;
  where?: Maybe<License_Instance_Bool_Exp>;
};

export type Query_RootLicense_Instance_By_PkArgs = {
  metadata_db_id: Scalars['uuid'];
};

export type Query_RootLicense_TypeArgs = {
  distinct_on?: Maybe<Array<License_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Type_Order_By>>;
  where?: Maybe<License_Type_Bool_Exp>;
};

export type Query_RootLicense_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<License_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Type_Order_By>>;
  where?: Maybe<License_Type_Bool_Exp>;
};

export type Query_RootLicense_Type_By_PkArgs = {
  name: Scalars['String'];
};

export type Query_RootLicensesArgs = {
  distinct_on?: Maybe<Array<Licenses_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Licenses_Order_By>>;
  where?: Maybe<Licenses_Bool_Exp>;
};

export type Query_RootLicenses_AggregateArgs = {
  distinct_on?: Maybe<Array<Licenses_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Licenses_Order_By>>;
  where?: Maybe<Licenses_Bool_Exp>;
};

export type Query_RootLicenses_By_PkArgs = {
  email: Scalars['String'];
};

export type Query_RootLux_ProxyArgs = {
  distinct_on?: Maybe<Array<Lux_Proxy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Lux_Proxy_Order_By>>;
  where?: Maybe<Lux_Proxy_Bool_Exp>;
};

export type Query_RootLux_Proxy_AggregateArgs = {
  distinct_on?: Maybe<Array<Lux_Proxy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Lux_Proxy_Order_By>>;
  where?: Maybe<Lux_Proxy_Bool_Exp>;
};

export type Query_RootLux_Proxy_AmiArgs = {
  distinct_on?: Maybe<Array<Lux_Proxy_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Lux_Proxy_Ami_Order_By>>;
  where?: Maybe<Lux_Proxy_Ami_Bool_Exp>;
};

export type Query_RootLux_Proxy_Ami_AggregateArgs = {
  distinct_on?: Maybe<Array<Lux_Proxy_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Lux_Proxy_Ami_Order_By>>;
  where?: Maybe<Lux_Proxy_Ami_Bool_Exp>;
};

export type Query_RootLux_Proxy_Ami_By_PkArgs = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

export type Query_RootLux_Proxy_By_PkArgs = {
  cloud: Scalars['String'];
  region: Scalars['String'];
};

export type Query_RootNeon_Db_IntegrationArgs = {
  distinct_on?: Maybe<Array<Neon_Db_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Neon_Db_Integration_Order_By>>;
  where?: Maybe<Neon_Db_Integration_Bool_Exp>;
};

export type Query_RootNeon_Db_Integration_AggregateArgs = {
  distinct_on?: Maybe<Array<Neon_Db_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Neon_Db_Integration_Order_By>>;
  where?: Maybe<Neon_Db_Integration_Bool_Exp>;
};

export type Query_RootNeon_Db_Integration_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootNewrelic_ConfigArgs = {
  distinct_on?: Maybe<Array<Newrelic_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Newrelic_Config_Order_By>>;
  where?: Maybe<Newrelic_Config_Bool_Exp>;
};

export type Query_RootNewrelic_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Newrelic_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Newrelic_Config_Order_By>>;
  where?: Maybe<Newrelic_Config_Bool_Exp>;
};

export type Query_RootNewrelic_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Query_RootNode_Pool_TypeArgs = {
  distinct_on?: Maybe<Array<Node_Pool_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Node_Pool_Type_Order_By>>;
  where?: Maybe<Node_Pool_Type_Bool_Exp>;
};

export type Query_RootNode_Pool_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Node_Pool_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Node_Pool_Type_Order_By>>;
  where?: Maybe<Node_Pool_Type_Bool_Exp>;
};

export type Query_RootNode_Pool_Type_By_PkArgs = {
  name: Scalars['String'];
};

export type Query_RootNode_PoolsArgs = {
  distinct_on?: Maybe<Array<Node_Pools_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Node_Pools_Order_By>>;
  where?: Maybe<Node_Pools_Bool_Exp>;
};

export type Query_RootNode_Pools_AggregateArgs = {
  distinct_on?: Maybe<Array<Node_Pools_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Node_Pools_Order_By>>;
  where?: Maybe<Node_Pools_Bool_Exp>;
};

export type Query_RootNode_Pools_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootNotificationArgs = {
  distinct_on?: Maybe<Array<Notification_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Notification_Order_By>>;
  where?: Maybe<Notification_Bool_Exp>;
};

export type Query_RootNotification_AggregateArgs = {
  distinct_on?: Maybe<Array<Notification_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Notification_Order_By>>;
  where?: Maybe<Notification_Bool_Exp>;
};

export type Query_RootNotification_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootNotification_TypeArgs = {
  distinct_on?: Maybe<Array<Notification_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Notification_Type_Order_By>>;
  where?: Maybe<Notification_Type_Bool_Exp>;
};

export type Query_RootNotification_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Notification_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Notification_Type_Order_By>>;
  where?: Maybe<Notification_Type_Bool_Exp>;
};

export type Query_RootNotification_Type_By_PkArgs = {
  type: Scalars['String'];
};

export type Query_RootOnboarding_Sample_Db_CohortArgs = {
  distinct_on?: Maybe<Array<Onboarding_Sample_Db_Cohort_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Sample_Db_Cohort_Order_By>>;
  where?: Maybe<Onboarding_Sample_Db_Cohort_Bool_Exp>;
};

export type Query_RootOnboarding_Sample_Db_Cohort_AggregateArgs = {
  distinct_on?: Maybe<Array<Onboarding_Sample_Db_Cohort_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Sample_Db_Cohort_Order_By>>;
  where?: Maybe<Onboarding_Sample_Db_Cohort_Bool_Exp>;
};

export type Query_RootOnboarding_Sample_Db_Cohort_By_PkArgs = {
  user_id: Scalars['uuid'];
};

export type Query_RootOnboarding_Sample_Db_ConfigArgs = {
  distinct_on?: Maybe<Array<Onboarding_Sample_Db_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Sample_Db_Config_Order_By>>;
  where?: Maybe<Onboarding_Sample_Db_Config_Bool_Exp>;
};

export type Query_RootOnboarding_Sample_Db_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Onboarding_Sample_Db_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Sample_Db_Config_Order_By>>;
  where?: Maybe<Onboarding_Sample_Db_Config_Bool_Exp>;
};

export type Query_RootOnboarding_Sample_Db_Config_By_PkArgs = {
  created_at: Scalars['timestamptz'];
};

export type Query_RootOne_Click_DeploymentArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_Order_By>>;
  where?: Maybe<One_Click_Deployment_Bool_Exp>;
};

export type Query_RootOne_Click_Deployment_AggregateArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_Order_By>>;
  where?: Maybe<One_Click_Deployment_Bool_Exp>;
};

export type Query_RootOne_Click_Deployment_By_PkArgs = {
  id: Scalars['bigint'];
};

export type Query_RootOne_Click_Deployment_Sample_AppsArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_Sample_Apps_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_Sample_Apps_Order_By>>;
  where?: Maybe<One_Click_Deployment_Sample_Apps_Bool_Exp>;
};

export type Query_RootOne_Click_Deployment_Sample_Apps_AggregateArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_Sample_Apps_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_Sample_Apps_Order_By>>;
  where?: Maybe<One_Click_Deployment_Sample_Apps_Bool_Exp>;
};

export type Query_RootOne_Click_Deployment_Sample_Apps_By_PkArgs = {
  git_repository_branch: Scalars['String'];
  git_repository_url: Scalars['String'];
  hasura_directory: Scalars['String'];
};

export type Query_RootOne_Click_Deployment_State_LogArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_State_Log_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_State_Log_Order_By>>;
  where?: Maybe<One_Click_Deployment_State_Log_Bool_Exp>;
};

export type Query_RootOne_Click_Deployment_State_Log_AggregateArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_State_Log_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_State_Log_Order_By>>;
  where?: Maybe<One_Click_Deployment_State_Log_Bool_Exp>;
};

export type Query_RootOne_Click_Deployment_State_Log_By_PkArgs = {
  id: Scalars['bigint'];
};

export type Query_RootOne_Click_Deployment_StatesArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_States_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_States_Order_By>>;
  where?: Maybe<One_Click_Deployment_States_Bool_Exp>;
};

export type Query_RootOne_Click_Deployment_States_AggregateArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_States_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_States_Order_By>>;
  where?: Maybe<One_Click_Deployment_States_Bool_Exp>;
};

export type Query_RootOne_Click_Deployment_States_By_PkArgs = {
  name: Scalars['String'];
};

export type Query_RootOpentelemetry_ConfigArgs = {
  distinct_on?: Maybe<Array<Opentelemetry_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Opentelemetry_Config_Order_By>>;
  where?: Maybe<Opentelemetry_Config_Bool_Exp>;
};

export type Query_RootOpentelemetry_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Opentelemetry_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Opentelemetry_Config_Order_By>>;
  where?: Maybe<Opentelemetry_Config_Bool_Exp>;
};

export type Query_RootOpentelemetry_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Query_RootOperations_Delete_Free_Plan_Dns_Records_Nov_2021Args = {
  distinct_on?: Maybe<
    Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<
    Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Order_By>
  >;
  where?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp>;
};

export type Query_RootOperations_Delete_Free_Plan_Dns_Records_Nov_2021_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<
      Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Order_By>
    >;
    where?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp>;
  };

export type Query_RootOperations_Delete_Free_Plan_Dns_Records_Nov_2021_By_PkArgs =
  {
    tenant_id: Scalars['uuid'];
  };

export type Query_RootOperations_TenantArgs = {
  distinct_on?: Maybe<Array<Operations_Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Operations_Tenant_Order_By>>;
  where?: Maybe<Operations_Tenant_Bool_Exp>;
};

export type Query_RootOperations_Tenant_AggregateArgs = {
  distinct_on?: Maybe<Array<Operations_Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Operations_Tenant_Order_By>>;
  where?: Maybe<Operations_Tenant_Bool_Exp>;
};

export type Query_RootOperations_To_Delete_Free_Plan_Dns_RecordsArgs = {
  args: Operations_To_Delete_Free_Plan_Dns_Records_Args;
  distinct_on?: Maybe<Array<Operations_Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Operations_Tenant_Order_By>>;
  where?: Maybe<Operations_Tenant_Bool_Exp>;
};

export type Query_RootOperations_To_Delete_Free_Plan_Dns_Records_AggregateArgs =
  {
    args: Operations_To_Delete_Free_Plan_Dns_Records_Args;
    distinct_on?: Maybe<Array<Operations_Tenant_Select_Column>>;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Operations_Tenant_Order_By>>;
    where?: Maybe<Operations_Tenant_Bool_Exp>;
  };

export type Query_RootPayment_MethodArgs = {
  distinct_on?: Maybe<Array<Payment_Method_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payment_Method_Order_By>>;
  where?: Maybe<Payment_Method_Bool_Exp>;
};

export type Query_RootPayment_Method_AggregateArgs = {
  distinct_on?: Maybe<Array<Payment_Method_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payment_Method_Order_By>>;
  where?: Maybe<Payment_Method_Bool_Exp>;
};

export type Query_RootPayment_Method_By_PkArgs = {
  id: Scalars['String'];
};

export type Query_RootPlan_EntitlementsArgs = {
  distinct_on?: Maybe<Array<Plan_Entitlements_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Plan_Entitlements_Order_By>>;
  where?: Maybe<Plan_Entitlements_Bool_Exp>;
};

export type Query_RootPlan_Entitlements_AggregateArgs = {
  distinct_on?: Maybe<Array<Plan_Entitlements_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Plan_Entitlements_Order_By>>;
  where?: Maybe<Plan_Entitlements_Bool_Exp>;
};

export type Query_RootPlan_Entitlements_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootPlansArgs = {
  distinct_on?: Maybe<Array<Plans_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Plans_Order_By>>;
  where?: Maybe<Plans_Bool_Exp>;
};

export type Query_RootPlans_AggregateArgs = {
  distinct_on?: Maybe<Array<Plans_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Plans_Order_By>>;
  where?: Maybe<Plans_Bool_Exp>;
};

export type Query_RootPlans_By_PkArgs = {
  name: Scalars['String'];
};

export type Query_RootPoliciesArgs = {
  distinct_on?: Maybe<Array<Policies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Policies_Order_By>>;
  where?: Maybe<Policies_Bool_Exp>;
};

export type Query_RootPolicies_AggregateArgs = {
  distinct_on?: Maybe<Array<Policies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Policies_Order_By>>;
  where?: Maybe<Policies_Bool_Exp>;
};

export type Query_RootPolicies_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Query_RootPrivilegedProjectsArgs = {
  where?: Maybe<PrivilegedProjectInput>;
};

export type Query_RootPrivilegesArgs = {
  distinct_on?: Maybe<Array<Privileges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Privileges_Order_By>>;
  where?: Maybe<Privileges_Bool_Exp>;
};

export type Query_RootPrivileges_AggregateArgs = {
  distinct_on?: Maybe<Array<Privileges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Privileges_Order_By>>;
  where?: Maybe<Privileges_Bool_Exp>;
};

export type Query_RootPrivileges_By_PkArgs = {
  slug: Scalars['String'];
};

export type Query_RootPro_License_KeysArgs = {
  distinct_on?: Maybe<Array<Pro_License_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pro_License_Keys_Order_By>>;
  where?: Maybe<Pro_License_Keys_Bool_Exp>;
};

export type Query_RootPro_License_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Pro_License_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pro_License_Keys_Order_By>>;
  where?: Maybe<Pro_License_Keys_Bool_Exp>;
};

export type Query_RootPro_License_Keys_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_ActivityArgs = {
  distinct_on?: Maybe<Array<Project_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Activity_Order_By>>;
  where?: Maybe<Project_Activity_Bool_Exp>;
};

export type Query_RootProject_Activity_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Activity_Order_By>>;
  where?: Maybe<Project_Activity_Bool_Exp>;
};

export type Query_RootProject_Activity_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_Billing_Manager_InvitationsArgs = {
  distinct_on?: Maybe<Array<Project_Billing_Manager_Invitations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Billing_Manager_Invitations_Order_By>>;
  where?: Maybe<Project_Billing_Manager_Invitations_Bool_Exp>;
};

export type Query_RootProject_Billing_Manager_Invitations_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Billing_Manager_Invitations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Billing_Manager_Invitations_Order_By>>;
  where?: Maybe<Project_Billing_Manager_Invitations_Bool_Exp>;
};

export type Query_RootProject_Billing_Manager_Invitations_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_Collaborator_Allowed_Schema_TablesArgs = {
  distinct_on?: Maybe<
    Array<Project_Collaborator_Allowed_Schema_Tables_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Allowed_Schema_Tables_Order_By>>;
  where?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>;
};

export type Query_RootProject_Collaborator_Allowed_Schema_Tables_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Project_Collaborator_Allowed_Schema_Tables_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<
      Array<Project_Collaborator_Allowed_Schema_Tables_Order_By>
    >;
    where?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>;
  };

export type Query_RootProject_Collaborator_Allowed_Schema_Tables_By_PkArgs = {
  project_collaborator_id: Scalars['uuid'];
  schema: Scalars['String'];
  table_name: Scalars['String'];
};

export type Query_RootProject_Collaborator_Allowed_SchemasArgs = {
  distinct_on?: Maybe<
    Array<Project_Collaborator_Allowed_Schemas_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Allowed_Schemas_Order_By>>;
  where?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
};

export type Query_RootProject_Collaborator_Allowed_Schemas_AggregateArgs = {
  distinct_on?: Maybe<
    Array<Project_Collaborator_Allowed_Schemas_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Allowed_Schemas_Order_By>>;
  where?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
};

export type Query_RootProject_Collaborator_Allowed_Schemas_By_PkArgs = {
  project_collaborator_id: Scalars['uuid'];
  schema: Scalars['String'];
};

export type Query_RootProject_Collaborator_InvitationsArgs = {
  distinct_on?: Maybe<Array<Project_Collaborator_Invitations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Invitations_Order_By>>;
  where?: Maybe<Project_Collaborator_Invitations_Bool_Exp>;
};

export type Query_RootProject_Collaborator_Invitations_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Collaborator_Invitations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Invitations_Order_By>>;
  where?: Maybe<Project_Collaborator_Invitations_Bool_Exp>;
};

export type Query_RootProject_Collaborator_Invitations_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_Collaborator_PrivilegesArgs = {
  distinct_on?: Maybe<Array<Project_Collaborator_Privileges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Privileges_Order_By>>;
  where?: Maybe<Project_Collaborator_Privileges_Bool_Exp>;
};

export type Query_RootProject_Collaborator_Privileges_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Collaborator_Privileges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Privileges_Order_By>>;
  where?: Maybe<Project_Collaborator_Privileges_Bool_Exp>;
};

export type Query_RootProject_Collaborator_Privileges_By_PkArgs = {
  privilege_slug: Scalars['String'];
  project_collaborator_id: Scalars['uuid'];
};

export type Query_RootProject_CollaboratorsArgs = {
  distinct_on?: Maybe<Array<Project_Collaborators_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborators_Order_By>>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

export type Query_RootProject_Collaborators_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Collaborators_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborators_Order_By>>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

export type Query_RootProject_Collaborators_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_Data_UsageArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Order_By>>;
  where?: Maybe<Project_Data_Usage_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_AggArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_Agg_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_Agg_UserArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_User_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_Agg_User_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_User_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Order_By>>;
  where?: Maybe<Project_Data_Usage_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_Data_Usage_ComponentsArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Components_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Components_Order_By>>;
  where?: Maybe<Project_Data_Usage_Components_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_Components_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Components_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Components_Order_By>>;
  where?: Maybe<Project_Data_Usage_Components_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_PrometheusArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Prometheus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Order_By>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_Prometheus_Agg_UserArgs = {
  distinct_on?: Maybe<
    Array<Project_Data_Usage_Prometheus_Agg_User_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_Prometheus_Agg_User_AggregateArgs = {
  distinct_on?: Maybe<
    Array<Project_Data_Usage_Prometheus_Agg_User_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_Prometheus_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Prometheus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Order_By>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_Prometheus_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_Data_Usage_ReportArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Report_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Report_Order_By>>;
  where?: Maybe<Project_Data_Usage_Report_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_Report_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Report_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Report_Order_By>>;
  where?: Maybe<Project_Data_Usage_Report_Bool_Exp>;
};

export type Query_RootProject_Data_Usage_Report_By_PkArgs = {
  project_id: Scalars['uuid'];
  report_date: Scalars['date'];
};

export type Query_RootProject_Db_UsageArgs = {
  distinct_on?: Maybe<Array<Project_Db_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Order_By>>;
  where?: Maybe<Project_Db_Usage_Bool_Exp>;
};

export type Query_RootProject_Db_Usage_Agg_UserArgs = {
  distinct_on?: Maybe<Array<Project_Db_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Db_Usage_Agg_User_Bool_Exp>;
};

export type Query_RootProject_Db_Usage_Agg_User_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Db_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Db_Usage_Agg_User_Bool_Exp>;
};

export type Query_RootProject_Db_Usage_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Db_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Order_By>>;
  where?: Maybe<Project_Db_Usage_Bool_Exp>;
};

export type Query_RootProject_Db_Usage_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_Entitlement_AccessArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Project_Entitlement_Access_Bool_Exp>;
};

export type Query_RootProject_Entitlement_Access_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Project_Entitlement_Access_Bool_Exp>;
};

export type Query_RootProject_Entitlement_Access_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_Entitlement_CatalogueArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<Project_Entitlement_Catalogue_Bool_Exp>;
};

export type Query_RootProject_Entitlement_Catalogue_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<Project_Entitlement_Catalogue_Bool_Exp>;
};

export type Query_RootProject_Entitlement_Catalogue_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_Entitlement_TypesArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Types_Order_By>>;
  where?: Maybe<Project_Entitlement_Types_Bool_Exp>;
};

export type Query_RootProject_Entitlement_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Types_Order_By>>;
  where?: Maybe<Project_Entitlement_Types_Bool_Exp>;
};

export type Query_RootProject_Entitlement_Types_By_PkArgs = {
  value: Scalars['String'];
};

export type Query_RootProject_LabelsArgs = {
  distinct_on?: Maybe<Array<Project_Labels_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Labels_Order_By>>;
  where?: Maybe<Project_Labels_Bool_Exp>;
};

export type Query_RootProject_Labels_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Labels_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Labels_Order_By>>;
  where?: Maybe<Project_Labels_Bool_Exp>;
};

export type Query_RootProject_Labels_By_PkArgs = {
  label_id: Scalars['uuid'];
  project_id: Scalars['uuid'];
};

export type Query_RootProject_MetadataArgs = {
  distinct_on?: Maybe<Array<Project_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Metadata_Order_By>>;
  where?: Maybe<Project_Metadata_Bool_Exp>;
};

export type Query_RootProject_Metadata_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Metadata_Order_By>>;
  where?: Maybe<Project_Metadata_Bool_Exp>;
};

export type Query_RootProject_Metadata_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Query_RootProject_NotificationArgs = {
  distinct_on?: Maybe<Array<Project_Notification_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Notification_Order_By>>;
  where?: Maybe<Project_Notification_Bool_Exp>;
};

export type Query_RootProject_Notification_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Notification_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Notification_Order_By>>;
  where?: Maybe<Project_Notification_Bool_Exp>;
};

export type Query_RootProject_Notification_By_PkArgs = {
  month: Scalars['Int'];
  project_id: Scalars['uuid'];
  type: Scalars['reminder_type_enum'];
  year: Scalars['Int'];
};

export type Query_RootProject_Ownership_Transfer_InvitationsArgs = {
  distinct_on?: Maybe<
    Array<Project_Ownership_Transfer_Invitations_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Ownership_Transfer_Invitations_Order_By>>;
  where?: Maybe<Project_Ownership_Transfer_Invitations_Bool_Exp>;
};

export type Query_RootProject_Ownership_Transfer_Invitations_AggregateArgs = {
  distinct_on?: Maybe<
    Array<Project_Ownership_Transfer_Invitations_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Ownership_Transfer_Invitations_Order_By>>;
  where?: Maybe<Project_Ownership_Transfer_Invitations_Bool_Exp>;
};

export type Query_RootProject_Ownership_Transfer_Invitations_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_Pool_Current_StatusArgs = {
  distinct_on?: Maybe<Array<Project_Pool_Current_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Pool_Current_Status_Order_By>>;
  where?: Maybe<Project_Pool_Current_Status_Bool_Exp>;
};

export type Query_RootProject_Pool_Current_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Pool_Current_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Pool_Current_Status_Order_By>>;
  where?: Maybe<Project_Pool_Current_Status_Bool_Exp>;
};

export type Query_RootProject_Requests_CountArgs = {
  distinct_on?: Maybe<Array<Project_Requests_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Requests_Count_Order_By>>;
  where?: Maybe<Project_Requests_Count_Bool_Exp>;
};

export type Query_RootProject_Requests_Count_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Requests_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Requests_Count_Order_By>>;
  where?: Maybe<Project_Requests_Count_Bool_Exp>;
};

export type Query_RootProject_Requests_Count_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_StatsArgs = {
  distinct_on?: Maybe<Array<Project_Stats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Stats_Order_By>>;
  where?: Maybe<Project_Stats_Bool_Exp>;
};

export type Query_RootProject_Stats_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Stats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Stats_Order_By>>;
  where?: Maybe<Project_Stats_Bool_Exp>;
};

export type Query_RootProject_Stats_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProject_Total_Db_Usage_AggArgs = {
  distinct_on?: Maybe<Array<Project_Total_Db_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Total_Db_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Total_Db_Usage_Agg_Bool_Exp>;
};

export type Query_RootProject_Total_Db_Usage_Agg_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Total_Db_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Total_Db_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Total_Db_Usage_Agg_Bool_Exp>;
};

export type Query_RootProjectsArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

export type Query_RootProjects_AggregateArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

export type Query_RootProjects_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProjects_Pool_ConfigArgs = {
  distinct_on?: Maybe<Array<Projects_Pool_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Pool_Config_Order_By>>;
  where?: Maybe<Projects_Pool_Config_Bool_Exp>;
};

export type Query_RootProjects_Pool_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Projects_Pool_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Pool_Config_Order_By>>;
  where?: Maybe<Projects_Pool_Config_Bool_Exp>;
};

export type Query_RootProjects_Pool_Config_By_PkArgs = {
  cloud: Scalars['String'];
  plan_name: Scalars['String'];
  region: Scalars['String'];
};

export type Query_RootProjects_Pro_Key_GenerationsArgs = {
  distinct_on?: Maybe<Array<Projects_Pro_Key_Generations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Pro_Key_Generations_Order_By>>;
  where?: Maybe<Projects_Pro_Key_Generations_Bool_Exp>;
};

export type Query_RootProjects_Pro_Key_Generations_AggregateArgs = {
  distinct_on?: Maybe<Array<Projects_Pro_Key_Generations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Pro_Key_Generations_Order_By>>;
  where?: Maybe<Projects_Pro_Key_Generations_Bool_Exp>;
};

export type Query_RootProjects_Pro_Key_Generations_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootProjects_With_No_Running_DeploymentsArgs = {
  distinct_on?: Maybe<
    Array<Projects_With_No_Running_Deployments_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_With_No_Running_Deployments_Order_By>>;
  where?: Maybe<Projects_With_No_Running_Deployments_Bool_Exp>;
};

export type Query_RootProjects_With_No_Running_Deployments_AggregateArgs = {
  distinct_on?: Maybe<
    Array<Projects_With_No_Running_Deployments_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_With_No_Running_Deployments_Order_By>>;
  where?: Maybe<Projects_With_No_Running_Deployments_Bool_Exp>;
};

export type Query_RootProjects_With_No_Running_Preview_AppArgs = {
  distinct_on?: Maybe<
    Array<Projects_With_No_Running_Preview_App_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_With_No_Running_Preview_App_Order_By>>;
  where?: Maybe<Projects_With_No_Running_Preview_App_Bool_Exp>;
};

export type Query_RootProjects_With_No_Running_Preview_App_AggregateArgs = {
  distinct_on?: Maybe<
    Array<Projects_With_No_Running_Preview_App_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_With_No_Running_Preview_App_Order_By>>;
  where?: Maybe<Projects_With_No_Running_Preview_App_Bool_Exp>;
};

export type Query_RootPrometheus_ConfigArgs = {
  distinct_on?: Maybe<Array<Prometheus_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Prometheus_Config_Order_By>>;
  where?: Maybe<Prometheus_Config_Bool_Exp>;
};

export type Query_RootPrometheus_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Prometheus_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Prometheus_Config_Order_By>>;
  where?: Maybe<Prometheus_Config_Bool_Exp>;
};

export type Query_RootPrometheus_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Query_RootProvidersArgs = {
  distinct_on?: Maybe<Array<Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Providers_Order_By>>;
  where?: Maybe<Providers_Bool_Exp>;
};

export type Query_RootProviders_AggregateArgs = {
  distinct_on?: Maybe<Array<Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Providers_Order_By>>;
  where?: Maybe<Providers_Bool_Exp>;
};

export type Query_RootProviders_By_PkArgs = {
  id: Scalars['Int'];
};

export type Query_RootProvisioningArgs = {
  distinct_on?: Maybe<Array<Provisioning_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Provisioning_Order_By>>;
  where?: Maybe<Provisioning_Bool_Exp>;
};

export type Query_RootProvisioning_AggregateArgs = {
  distinct_on?: Maybe<Array<Provisioning_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Provisioning_Order_By>>;
  where?: Maybe<Provisioning_Bool_Exp>;
};

export type Query_RootProvisioning_By_PkArgs = {
  provisioning: Scalars['String'];
};

export type Query_RootRegionArgs = {
  distinct_on?: Maybe<Array<Region_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Region_Order_By>>;
  where?: Maybe<Region_Bool_Exp>;
};

export type Query_RootRegion_AggregateArgs = {
  distinct_on?: Maybe<Array<Region_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Region_Order_By>>;
  where?: Maybe<Region_Bool_Exp>;
};

export type Query_RootRegion_By_PkArgs = {
  cloud: Cloud_Enum;
  name: Scalars['String'];
};

export type Query_RootRegion_V2Args = {
  distinct_on?: Maybe<Array<Region_V2_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Region_V2_Order_By>>;
  where?: Maybe<Region_V2_Bool_Exp>;
};

export type Query_RootRegion_V2_AggregateArgs = {
  distinct_on?: Maybe<Array<Region_V2_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Region_V2_Order_By>>;
  where?: Maybe<Region_V2_Bool_Exp>;
};

export type Query_RootRegional_Data_ConnectorsArgs = {
  distinct_on?: Maybe<Array<Regional_Data_Connectors_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Regional_Data_Connectors_Order_By>>;
  where?: Maybe<Regional_Data_Connectors_Bool_Exp>;
};

export type Query_RootRegional_Data_Connectors_AggregateArgs = {
  distinct_on?: Maybe<Array<Regional_Data_Connectors_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Regional_Data_Connectors_Order_By>>;
  where?: Maybe<Regional_Data_Connectors_Bool_Exp>;
};

export type Query_RootRegional_Data_Connectors_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootRegional_MetricsArgs = {
  distinct_on?: Maybe<Array<Regional_Metrics_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Regional_Metrics_Order_By>>;
  where?: Maybe<Regional_Metrics_Bool_Exp>;
};

export type Query_RootRegional_Metrics_AggregateArgs = {
  distinct_on?: Maybe<Array<Regional_Metrics_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Regional_Metrics_Order_By>>;
  where?: Maybe<Regional_Metrics_Bool_Exp>;
};

export type Query_RootRegional_Metrics_By_PkArgs = {
  cloud: Scalars['String'];
  region: Scalars['String'];
};

export type Query_RootSaml_IdpArgs = {
  distinct_on?: Maybe<Array<Saml_Idp_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Saml_Idp_Order_By>>;
  where?: Maybe<Saml_Idp_Bool_Exp>;
};

export type Query_RootSaml_Idp_AggregateArgs = {
  distinct_on?: Maybe<Array<Saml_Idp_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Saml_Idp_Order_By>>;
  where?: Maybe<Saml_Idp_Bool_Exp>;
};

export type Query_RootSaml_Idp_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootSearch_Project_Login_StatusArgs = {
  args: Search_Project_Login_Status_Args;
  distinct_on?: Maybe<Array<Search_Project_Login_Status_Results_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Search_Project_Login_Status_Results_Order_By>>;
  where?: Maybe<Search_Project_Login_Status_Results_Bool_Exp>;
};

export type Query_RootSearch_Project_Login_Status_AggregateArgs = {
  args: Search_Project_Login_Status_Args;
  distinct_on?: Maybe<Array<Search_Project_Login_Status_Results_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Search_Project_Login_Status_Results_Order_By>>;
  where?: Maybe<Search_Project_Login_Status_Results_Bool_Exp>;
};

export type Query_RootSearch_Project_Login_Status_ResultsArgs = {
  distinct_on?: Maybe<Array<Search_Project_Login_Status_Results_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Search_Project_Login_Status_Results_Order_By>>;
  where?: Maybe<Search_Project_Login_Status_Results_Bool_Exp>;
};

export type Query_RootSearch_Project_Login_Status_Results_AggregateArgs = {
  distinct_on?: Maybe<Array<Search_Project_Login_Status_Results_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Search_Project_Login_Status_Results_Order_By>>;
  where?: Maybe<Search_Project_Login_Status_Results_Bool_Exp>;
};

export type Query_RootSearch_Tenant_Group_Has_Least_MembersArgs = {
  args: Search_Tenant_Group_Has_Least_Members_Args;
  distinct_on?: Maybe<Array<Tenant_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Order_By>>;
  where?: Maybe<Tenant_Group_Bool_Exp>;
};

export type Query_RootSearch_Tenant_Group_Has_Least_Members_AggregateArgs = {
  args: Search_Tenant_Group_Has_Least_Members_Args;
  distinct_on?: Maybe<Array<Tenant_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Order_By>>;
  where?: Maybe<Tenant_Group_Bool_Exp>;
};

export type Query_RootSlack_ConfigArgs = {
  distinct_on?: Maybe<Array<Slack_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Slack_Config_Order_By>>;
  where?: Maybe<Slack_Config_Bool_Exp>;
};

export type Query_RootSlack_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Slack_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Slack_Config_Order_By>>;
  where?: Maybe<Slack_Config_Bool_Exp>;
};

export type Query_RootSlack_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootStripe_SubscriptionArgs = {
  distinct_on?: Maybe<Array<Stripe_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stripe_Subscription_Order_By>>;
  where?: Maybe<Stripe_Subscription_Bool_Exp>;
};

export type Query_RootStripe_Subscription_AggregateArgs = {
  distinct_on?: Maybe<Array<Stripe_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stripe_Subscription_Order_By>>;
  where?: Maybe<Stripe_Subscription_Bool_Exp>;
};

export type Query_RootStripe_Subscription_By_PkArgs = {
  customer_id: Scalars['String'];
  subscription_id: Scalars['String'];
};

export type Query_RootStripe_Webhook_EventsArgs = {
  distinct_on?: Maybe<Array<Stripe_Webhook_Events_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stripe_Webhook_Events_Order_By>>;
  where?: Maybe<Stripe_Webhook_Events_Bool_Exp>;
};

export type Query_RootStripe_Webhook_Events_AggregateArgs = {
  distinct_on?: Maybe<Array<Stripe_Webhook_Events_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stripe_Webhook_Events_Order_By>>;
  where?: Maybe<Stripe_Webhook_Events_Bool_Exp>;
};

export type Query_RootStripe_Webhook_Events_By_PkArgs = {
  stripe_event_id: Scalars['String'];
};

export type Query_RootSuper_Connector_TypesArgs = {
  distinct_on?: Maybe<Array<Super_Connector_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Super_Connector_Types_Order_By>>;
  where?: Maybe<Super_Connector_Types_Bool_Exp>;
};

export type Query_RootSuper_Connector_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Super_Connector_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Super_Connector_Types_Order_By>>;
  where?: Maybe<Super_Connector_Types_Bool_Exp>;
};

export type Query_RootSuper_Connector_Types_By_PkArgs = {
  type: Scalars['String'];
};

export type Query_RootSupport_Plan_TypesArgs = {
  distinct_on?: Maybe<Array<Support_Plan_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Support_Plan_Types_Order_By>>;
  where?: Maybe<Support_Plan_Types_Bool_Exp>;
};

export type Query_RootSupport_Plan_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Support_Plan_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Support_Plan_Types_Order_By>>;
  where?: Maybe<Support_Plan_Types_Bool_Exp>;
};

export type Query_RootSupport_Plan_Types_By_PkArgs = {
  value: Scalars['String'];
};

export type Query_RootSurveyArgs = {
  distinct_on?: Maybe<Array<Survey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Order_By>>;
  where?: Maybe<Survey_Bool_Exp>;
};

export type Query_RootSurvey_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Order_By>>;
  where?: Maybe<Survey_Bool_Exp>;
};

export type Query_RootSurvey_By_PkArgs = {
  survey_name: Scalars['String'];
};

export type Query_RootSurvey_QuestionArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Order_By>>;
  where?: Maybe<Survey_Question_Bool_Exp>;
};

export type Query_RootSurvey_Question_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Order_By>>;
  where?: Maybe<Survey_Question_Bool_Exp>;
};

export type Query_RootSurvey_Question_Answer_OptionArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Answer_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Answer_Option_Order_By>>;
  where?: Maybe<Survey_Question_Answer_Option_Bool_Exp>;
};

export type Query_RootSurvey_Question_Answer_Option_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Answer_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Answer_Option_Order_By>>;
  where?: Maybe<Survey_Question_Answer_Option_Bool_Exp>;
};

export type Query_RootSurvey_Question_Answer_Option_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootSurvey_Question_AnswersArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Answers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Answers_Order_By>>;
  where?: Maybe<Survey_Question_Answers_Bool_Exp>;
};

export type Query_RootSurvey_Question_Answers_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Answers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Answers_Order_By>>;
  where?: Maybe<Survey_Question_Answers_Bool_Exp>;
};

export type Query_RootSurvey_Question_Answers_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootSurvey_Question_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootSurvey_Question_KindArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Kind_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Kind_Order_By>>;
  where?: Maybe<Survey_Question_Kind_Bool_Exp>;
};

export type Query_RootSurvey_Question_Kind_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Kind_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Kind_Order_By>>;
  where?: Maybe<Survey_Question_Kind_Bool_Exp>;
};

export type Query_RootSurvey_Question_Kind_By_PkArgs = {
  kind: Scalars['String'];
};

export type Query_RootSurvey_Question_OptionsArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Options_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Options_Order_By>>;
  where?: Maybe<Survey_Question_Options_Bool_Exp>;
};

export type Query_RootSurvey_Question_Options_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Options_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Options_Order_By>>;
  where?: Maybe<Survey_Question_Options_Bool_Exp>;
};

export type Query_RootSurvey_Question_Options_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootSurvey_V2Args = {
  distinct_on?: Maybe<Array<Survey_V2_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Order_By>>;
  where?: Maybe<Survey_V2_Bool_Exp>;
};

export type Query_RootSurvey_V2_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Order_By>>;
  where?: Maybe<Survey_V2_Bool_Exp>;
};

export type Query_RootSurvey_V2_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootSurvey_V2_QuestionArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Order_By>>;
  where?: Maybe<Survey_V2_Question_Bool_Exp>;
};

export type Query_RootSurvey_V2_Question_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Order_By>>;
  where?: Maybe<Survey_V2_Question_Bool_Exp>;
};

export type Query_RootSurvey_V2_Question_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootSurvey_V2_Question_KindArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Kind_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Kind_Order_By>>;
  where?: Maybe<Survey_V2_Question_Kind_Bool_Exp>;
};

export type Query_RootSurvey_V2_Question_Kind_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Kind_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Kind_Order_By>>;
  where?: Maybe<Survey_V2_Question_Kind_Bool_Exp>;
};

export type Query_RootSurvey_V2_Question_Kind_By_PkArgs = {
  kind: Scalars['String'];
};

export type Query_RootSurvey_V2_Question_OptionArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Option_Order_By>>;
  where?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
};

export type Query_RootSurvey_V2_Question_Option_Additional_Info_ConfigArgs = {
  distinct_on?: Maybe<
    Array<Survey_V2_Question_Option_Additional_Info_Config_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<
    Array<Survey_V2_Question_Option_Additional_Info_Config_Order_By>
  >;
  where?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp>;
};

export type Query_RootSurvey_V2_Question_Option_Additional_Info_Config_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Survey_V2_Question_Option_Additional_Info_Config_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<
      Array<Survey_V2_Question_Option_Additional_Info_Config_Order_By>
    >;
    where?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp>;
  };

export type Query_RootSurvey_V2_Question_Option_Additional_Info_Config_By_PkArgs =
  {
    id: Scalars['uuid'];
  };

export type Query_RootSurvey_V2_Question_Option_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Option_Order_By>>;
  where?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
};

export type Query_RootSurvey_V2_Question_Option_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootSurvey_V2_ResponseArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Order_By>>;
  where?: Maybe<Survey_V2_Response_Bool_Exp>;
};

export type Query_RootSurvey_V2_Response_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Order_By>>;
  where?: Maybe<Survey_V2_Response_Bool_Exp>;
};

export type Query_RootSurvey_V2_Response_AnswerArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
};

export type Query_RootSurvey_V2_Response_Answer_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
};

export type Query_RootSurvey_V2_Response_Answer_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootSurvey_V2_Response_Answer_OptionArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Option_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Option_Bool_Exp>;
};

export type Query_RootSurvey_V2_Response_Answer_Option_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Option_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Option_Bool_Exp>;
};

export type Query_RootSurvey_V2_Response_Answer_Option_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootSurvey_V2_Response_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootTask_EventArgs = {
  distinct_on?: Maybe<Array<Task_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Task_Event_Order_By>>;
  where?: Maybe<Task_Event_Bool_Exp>;
};

export type Query_RootTask_Event_AggregateArgs = {
  distinct_on?: Maybe<Array<Task_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Task_Event_Order_By>>;
  where?: Maybe<Task_Event_Bool_Exp>;
};

export type Query_RootTask_Event_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootTaskq_Worker_Event_LatestArgs = {
  distinct_on?: Maybe<Array<Taskq_Worker_Event_Latest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Taskq_Worker_Event_Latest_Order_By>>;
  where?: Maybe<Taskq_Worker_Event_Latest_Bool_Exp>;
};

export type Query_RootTaskq_Worker_Event_Latest_AggregateArgs = {
  distinct_on?: Maybe<Array<Taskq_Worker_Event_Latest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Taskq_Worker_Event_Latest_Order_By>>;
  where?: Maybe<Taskq_Worker_Event_Latest_Bool_Exp>;
};

export type Query_RootTasksArgs = {
  distinct_on?: Maybe<Array<Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tasks_Order_By>>;
  where?: Maybe<Tasks_Bool_Exp>;
};

export type Query_RootTasks_AggregateArgs = {
  distinct_on?: Maybe<Array<Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tasks_Order_By>>;
  where?: Maybe<Tasks_Bool_Exp>;
};

export type Query_RootTasks_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootTenantArgs = {
  distinct_on?: Maybe<Array<Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Order_By>>;
  where?: Maybe<Tenant_Bool_Exp>;
};

export type Query_RootTenant_Active_Status_ReasonArgs = {
  distinct_on?: Maybe<Array<Tenant_Active_Status_Reason_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Active_Status_Reason_Order_By>>;
  where?: Maybe<Tenant_Active_Status_Reason_Bool_Exp>;
};

export type Query_RootTenant_Active_Status_Reason_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Active_Status_Reason_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Active_Status_Reason_Order_By>>;
  where?: Maybe<Tenant_Active_Status_Reason_Bool_Exp>;
};

export type Query_RootTenant_Active_Status_Reason_By_PkArgs = {
  name: Scalars['String'];
};

export type Query_RootTenant_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Order_By>>;
  where?: Maybe<Tenant_Bool_Exp>;
};

export type Query_RootTenant_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootTenant_GroupArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Order_By>>;
  where?: Maybe<Tenant_Group_Bool_Exp>;
};

export type Query_RootTenant_Group_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Order_By>>;
  where?: Maybe<Tenant_Group_Bool_Exp>;
};

export type Query_RootTenant_Group_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootTenant_Group_MemberArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Member_Order_By>>;
  where?: Maybe<Tenant_Group_Member_Bool_Exp>;
};

export type Query_RootTenant_Group_Member_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Member_Order_By>>;
  where?: Maybe<Tenant_Group_Member_Bool_Exp>;
};

export type Query_RootTenant_Group_Member_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootTenant_Public_StatusArgs = {
  distinct_on?: Maybe<Array<Tenant_Public_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Public_Status_Order_By>>;
  where?: Maybe<Tenant_Public_Status_Bool_Exp>;
};

export type Query_RootTenant_Public_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Public_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Public_Status_Order_By>>;
  where?: Maybe<Tenant_Public_Status_Bool_Exp>;
};

export type Query_RootTenant_Public_Status_By_PkArgs = {
  endpoint: Scalars['String'];
  tenant_id: Scalars['uuid'];
};

export type Query_RootTenant_StatusArgs = {
  distinct_on?: Maybe<Array<Tenant_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Status_Order_By>>;
  where?: Maybe<Tenant_Status_Bool_Exp>;
};

export type Query_RootTenant_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Status_Order_By>>;
  where?: Maybe<Tenant_Status_Bool_Exp>;
};

export type Query_RootTenant_Status_By_PkArgs = {
  tenant_id: Scalars['uuid'];
  worker_id: Scalars['uuid'];
};

export type Query_RootTrial_LeadsArgs = {
  distinct_on?: Maybe<Array<Trial_Leads_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Trial_Leads_Order_By>>;
  where?: Maybe<Trial_Leads_Bool_Exp>;
};

export type Query_RootTrial_Leads_AggregateArgs = {
  distinct_on?: Maybe<Array<Trial_Leads_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Trial_Leads_Order_By>>;
  where?: Maybe<Trial_Leads_Bool_Exp>;
};

export type Query_RootTrial_Leads_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootUa_Audit_LogsArgs = {
  distinct_on?: Maybe<Array<Ua_Audit_Logs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ua_Audit_Logs_Order_By>>;
  where?: Maybe<Ua_Audit_Logs_Bool_Exp>;
};

export type Query_RootUa_Audit_Logs_AggregateArgs = {
  distinct_on?: Maybe<Array<Ua_Audit_Logs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ua_Audit_Logs_Order_By>>;
  where?: Maybe<Ua_Audit_Logs_Bool_Exp>;
};

export type Query_RootUa_Audit_Logs_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootUser_ActivityArgs = {
  distinct_on?: Maybe<Array<User_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Activity_Order_By>>;
  where?: Maybe<User_Activity_Bool_Exp>;
};

export type Query_RootUser_Activity_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Activity_Order_By>>;
  where?: Maybe<User_Activity_Bool_Exp>;
};

export type Query_RootUser_Activity_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootUser_CouponArgs = {
  distinct_on?: Maybe<Array<User_Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Coupon_Order_By>>;
  where?: Maybe<User_Coupon_Bool_Exp>;
};

export type Query_RootUser_Coupon_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Coupon_Order_By>>;
  where?: Maybe<User_Coupon_Bool_Exp>;
};

export type Query_RootUser_Coupon_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootUser_Entitlement_AccessArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Access_Order_By>>;
  where?: Maybe<User_Entitlement_Access_Bool_Exp>;
};

export type Query_RootUser_Entitlement_Access_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Access_Order_By>>;
  where?: Maybe<User_Entitlement_Access_Bool_Exp>;
};

export type Query_RootUser_Entitlement_Access_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootUser_Entitlement_CatalogueArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<User_Entitlement_Catalogue_Bool_Exp>;
};

export type Query_RootUser_Entitlement_Catalogue_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<User_Entitlement_Catalogue_Bool_Exp>;
};

export type Query_RootUser_Entitlement_Catalogue_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootUser_Entitlement_TypesArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Types_Order_By>>;
  where?: Maybe<User_Entitlement_Types_Bool_Exp>;
};

export type Query_RootUser_Entitlement_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Types_Order_By>>;
  where?: Maybe<User_Entitlement_Types_Bool_Exp>;
};

export type Query_RootUser_Entitlement_Types_By_PkArgs = {
  value: Scalars['String'];
};

export type Query_RootUser_OnboardingArgs = {
  distinct_on?: Maybe<Array<User_Onboarding_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Onboarding_Order_By>>;
  where?: Maybe<User_Onboarding_Bool_Exp>;
};

export type Query_RootUser_Onboarding_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Onboarding_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Onboarding_Order_By>>;
  where?: Maybe<User_Onboarding_Bool_Exp>;
};

export type Query_RootUser_Onboarding_By_PkArgs = {
  target: Scalars['String'];
  user_id: Scalars['uuid'];
};

export type Query_RootUser_Personal_Access_TokensArgs = {
  distinct_on?: Maybe<Array<User_Personal_Access_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Personal_Access_Tokens_Order_By>>;
  where?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
};

export type Query_RootUser_Personal_Access_Tokens_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Personal_Access_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Personal_Access_Tokens_Order_By>>;
  where?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
};

export type Query_RootUser_Personal_Access_Tokens_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootUser_ProfileArgs = {
  distinct_on?: Maybe<Array<User_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Profile_Order_By>>;
  where?: Maybe<User_Profile_Bool_Exp>;
};

export type Query_RootUser_Profile_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Profile_Order_By>>;
  where?: Maybe<User_Profile_Bool_Exp>;
};

export type Query_RootUser_Profile_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootUser_Project_MapArgs = {
  distinct_on?: Maybe<Array<User_Project_Map_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Project_Map_Order_By>>;
  where?: Maybe<User_Project_Map_Bool_Exp>;
};

export type Query_RootUser_Project_Map_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Project_Map_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Project_Map_Order_By>>;
  where?: Maybe<User_Project_Map_Bool_Exp>;
};

export type Query_RootUser_RolesArgs = {
  distinct_on?: Maybe<Array<User_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Roles_Order_By>>;
  where?: Maybe<User_Roles_Bool_Exp>;
};

export type Query_RootUser_Roles_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Roles_Order_By>>;
  where?: Maybe<User_Roles_Bool_Exp>;
};

export type Query_RootUser_Roles_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootUser_Vpc_PolicyArgs = {
  distinct_on?: Maybe<Array<User_Vpc_Policy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Vpc_Policy_Order_By>>;
  where?: Maybe<User_Vpc_Policy_Bool_Exp>;
};

export type Query_RootUser_Vpc_Policy_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Vpc_Policy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Vpc_Policy_Order_By>>;
  where?: Maybe<User_Vpc_Policy_Bool_Exp>;
};

export type Query_RootUser_Vpc_Policy_By_PkArgs = {
  id: Scalars['Int'];
};

export type Query_RootUsersArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};

export type Query_RootUsers_AggregateArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};

export type Query_RootUsers_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootUsers_PublicArgs = {
  distinct_on?: Maybe<Array<Users_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Public_Order_By>>;
  where?: Maybe<Users_Public_Bool_Exp>;
};

export type Query_RootUsers_Public_AggregateArgs = {
  distinct_on?: Maybe<Array<Users_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Public_Order_By>>;
  where?: Maybe<Users_Public_Bool_Exp>;
};

export type Query_RootValidTenantNameArgs = {
  name: Scalars['String'];
  tenantId?: Maybe<Scalars['uuid']>;
};

export type Query_RootVercel_IntegrationArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Order_By>>;
  where?: Maybe<Vercel_Integration_Bool_Exp>;
};

export type Query_RootVercel_Integration_AggregateArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Order_By>>;
  where?: Maybe<Vercel_Integration_Bool_Exp>;
};

export type Query_RootVercel_Integration_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootVercel_Integration_ConnectionsArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Connections_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Connections_Order_By>>;
  where?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
};

export type Query_RootVercel_Integration_Connections_AggregateArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Connections_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Connections_Order_By>>;
  where?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
};

export type Query_RootVercel_Integration_Connections_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootVercelGetProjectsArgs = {
  configuration_id: Scalars['String'];
  team_id?: Maybe<Scalars['String']>;
};

export type Query_RootVpc_PeeringArgs = {
  distinct_on?: Maybe<Array<Vpc_Peering_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Peering_Order_By>>;
  where?: Maybe<Vpc_Peering_Bool_Exp>;
};

export type Query_RootVpc_Peering_AggregateArgs = {
  distinct_on?: Maybe<Array<Vpc_Peering_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Peering_Order_By>>;
  where?: Maybe<Vpc_Peering_Bool_Exp>;
};

export type Query_RootVpc_Peering_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Query_RootVpc_Peering_DirectionArgs = {
  distinct_on?: Maybe<Array<Vpc_Peering_Direction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Peering_Direction_Order_By>>;
  where?: Maybe<Vpc_Peering_Direction_Bool_Exp>;
};

export type Query_RootVpc_Peering_Direction_AggregateArgs = {
  distinct_on?: Maybe<Array<Vpc_Peering_Direction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Peering_Direction_Order_By>>;
  where?: Maybe<Vpc_Peering_Direction_Bool_Exp>;
};

export type Query_RootVpc_Peering_Direction_By_PkArgs = {
  direction: Scalars['String'];
};

export type Query_RootVpc_StatusArgs = {
  distinct_on?: Maybe<Array<Vpc_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Status_Order_By>>;
  where?: Maybe<Vpc_Status_Bool_Exp>;
};

export type Query_RootVpc_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Vpc_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Status_Order_By>>;
  where?: Maybe<Vpc_Status_Bool_Exp>;
};

export type Query_RootVpc_Status_By_PkArgs = {
  status: Scalars['String'];
};

export type Query_RootZendesk_Support_CategoryArgs = {
  distinct_on?: Maybe<Array<Zendesk_Support_Category_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Zendesk_Support_Category_Order_By>>;
  where?: Maybe<Zendesk_Support_Category_Bool_Exp>;
};

export type Query_RootZendesk_Support_Category_AggregateArgs = {
  distinct_on?: Maybe<Array<Zendesk_Support_Category_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Zendesk_Support_Category_Order_By>>;
  where?: Maybe<Zendesk_Support_Category_Bool_Exp>;
};

export type Query_RootZendesk_Support_Category_By_PkArgs = {
  name: Scalars['String'];
};

export type Query_RootZendesk_Support_TicketsArgs = {
  distinct_on?: Maybe<Array<Zendesk_Support_Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Zendesk_Support_Tickets_Order_By>>;
  where?: Maybe<Zendesk_Support_Tickets_Bool_Exp>;
};

export type Query_RootZendesk_Support_Tickets_AggregateArgs = {
  distinct_on?: Maybe<Array<Zendesk_Support_Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Zendesk_Support_Tickets_Order_By>>;
  where?: Maybe<Zendesk_Support_Tickets_Bool_Exp>;
};

export type Query_RootZendesk_Support_Tickets_By_PkArgs = {
  id: Scalars['uuid'];
};

export type QuestionAnswers = {
  answer?: Maybe<Scalars['String']>;
  optionsSelected?: Maybe<Array<Maybe<Scalars['uuid']>>>;
  question_id: Scalars['uuid'];
};

export type RegenerateKeyInput = {
  id: Scalars['uuid'];
};

/** Region that can be assigned to a cloud provider */
export type Region = {
  __typename?: 'region';
  cloud: Cloud_Enum;
  disable_infra_auto_apply: Scalars['Boolean'];
  hasura_worker_security_group_id?: Maybe<Scalars['String']>;
  healthcheck_variables?: Maybe<Scalars['jsonb']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables: Scalars['jsonb'];
  is_active: Scalars['Boolean'];
  legacy_metrics_fqdn?: Maybe<Scalars['String']>;
  /** An array relationship */
  lux_proxy: Array<Lux_Proxy>;
  /** An aggregate relationship */
  lux_proxy_aggregate: Lux_Proxy_Aggregate;
  /** Get security group of id for the Lux proxy endpoint interface */
  lux_proxy_security_group_id?: Maybe<Scalars['jsonb']>;
  /** Get the service name of the VPC endpoint service of Lux proxy */
  lux_proxy_service_name?: Maybe<Scalars['jsonb']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  metrics_fqdn_v2?: Maybe<Scalars['String']>;
  metrics_ips?: Maybe<Scalars['jsonb']>;
  metrics_security_group_id?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  nat_ip?: Maybe<Scalars['String']>;
  nat_ips?: Maybe<Scalars['json']>;
  operator_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  regional_metrics: Array<Regional_Metrics>;
  /** An aggregate relationship */
  regional_metrics_aggregate: Regional_Metrics_Aggregate;
  /** VPC id for the region */
  vpc_id?: Maybe<Scalars['String']>;
};

/** Region that can be assigned to a cloud provider */
export type RegionHealthcheck_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Region that can be assigned to a cloud provider */
export type RegionInput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Region that can be assigned to a cloud provider */
export type RegionLux_ProxyArgs = {
  distinct_on?: Maybe<Array<Lux_Proxy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Lux_Proxy_Order_By>>;
  where?: Maybe<Lux_Proxy_Bool_Exp>;
};

/** Region that can be assigned to a cloud provider */
export type RegionLux_Proxy_AggregateArgs = {
  distinct_on?: Maybe<Array<Lux_Proxy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Lux_Proxy_Order_By>>;
  where?: Maybe<Lux_Proxy_Bool_Exp>;
};

/** Region that can be assigned to a cloud provider */
export type RegionLux_Proxy_Security_Group_IdArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Region that can be assigned to a cloud provider */
export type RegionLux_Proxy_Service_NameArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Region that can be assigned to a cloud provider */
export type RegionMetrics_IpsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Region that can be assigned to a cloud provider */
export type RegionNat_IpsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Region that can be assigned to a cloud provider */
export type RegionOperator_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Region that can be assigned to a cloud provider */
export type RegionOutput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Region that can be assigned to a cloud provider */
export type RegionRegional_MetricsArgs = {
  distinct_on?: Maybe<Array<Regional_Metrics_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Regional_Metrics_Order_By>>;
  where?: Maybe<Regional_Metrics_Bool_Exp>;
};

/** Region that can be assigned to a cloud provider */
export type RegionRegional_Metrics_AggregateArgs = {
  distinct_on?: Maybe<Array<Regional_Metrics_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Regional_Metrics_Order_By>>;
  where?: Maybe<Regional_Metrics_Bool_Exp>;
};

/** aggregated selection of "region" */
export type Region_Aggregate = {
  __typename?: 'region_aggregate';
  aggregate?: Maybe<Region_Aggregate_Fields>;
  nodes: Array<Region>;
};

/** aggregate fields of "region" */
export type Region_Aggregate_Fields = {
  __typename?: 'region_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Region_Max_Fields>;
  min?: Maybe<Region_Min_Fields>;
};

/** aggregate fields of "region" */
export type Region_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Region_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Region_Append_Input = {
  healthcheck_variables?: Maybe<Scalars['jsonb']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  operator_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "region". All fields are combined with a logical 'AND'. */
export type Region_Bool_Exp = {
  _and?: Maybe<Array<Region_Bool_Exp>>;
  _not?: Maybe<Region_Bool_Exp>;
  _or?: Maybe<Array<Region_Bool_Exp>>;
  cloud?: Maybe<Cloud_Enum_Comparison_Exp>;
  disable_infra_auto_apply?: Maybe<Boolean_Comparison_Exp>;
  hasura_worker_security_group_id?: Maybe<String_Comparison_Exp>;
  healthcheck_variables?: Maybe<Jsonb_Comparison_Exp>;
  infra_status?: Maybe<Infra_Status_Enum_Comparison_Exp>;
  input_variables?: Maybe<Jsonb_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  legacy_metrics_fqdn?: Maybe<String_Comparison_Exp>;
  lux_proxy?: Maybe<Lux_Proxy_Bool_Exp>;
  lux_proxy_aggregate?: Maybe<Lux_Proxy_Aggregate_Bool_Exp>;
  lux_proxy_security_group_id?: Maybe<Jsonb_Comparison_Exp>;
  lux_proxy_service_name?: Maybe<Jsonb_Comparison_Exp>;
  metrics_fqdn?: Maybe<String_Comparison_Exp>;
  metrics_fqdn_v2?: Maybe<String_Comparison_Exp>;
  metrics_ips?: Maybe<Jsonb_Comparison_Exp>;
  metrics_security_group_id?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  nat_ip?: Maybe<String_Comparison_Exp>;
  nat_ips?: Maybe<Json_Comparison_Exp>;
  operator_variables?: Maybe<Jsonb_Comparison_Exp>;
  output_variables?: Maybe<Jsonb_Comparison_Exp>;
  regional_metrics?: Maybe<Regional_Metrics_Bool_Exp>;
  regional_metrics_aggregate?: Maybe<Regional_Metrics_Aggregate_Bool_Exp>;
  vpc_id?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "region" */
export enum Region_Constraint {
  /** unique or primary key constraint on columns "name", "cloud" */
  RegionPkey = 'region_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Region_Delete_At_Path_Input = {
  healthcheck_variables?: Maybe<Array<Scalars['String']>>;
  input_variables?: Maybe<Array<Scalars['String']>>;
  operator_variables?: Maybe<Array<Scalars['String']>>;
  output_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Region_Delete_Elem_Input = {
  healthcheck_variables?: Maybe<Scalars['Int']>;
  input_variables?: Maybe<Scalars['Int']>;
  operator_variables?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Region_Delete_Key_Input = {
  healthcheck_variables?: Maybe<Scalars['String']>;
  input_variables?: Maybe<Scalars['String']>;
  operator_variables?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "region" */
export type Region_Insert_Input = {
  cloud?: Maybe<Cloud_Enum>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  healthcheck_variables?: Maybe<Scalars['jsonb']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  is_active?: Maybe<Scalars['Boolean']>;
  legacy_metrics_fqdn?: Maybe<Scalars['String']>;
  lux_proxy?: Maybe<Lux_Proxy_Arr_Rel_Insert_Input>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  metrics_fqdn_v2?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  operator_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  regional_metrics?: Maybe<Regional_Metrics_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Region_Max_Fields = {
  __typename?: 'region_max_fields';
  legacy_metrics_fqdn?: Maybe<Scalars['String']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  metrics_fqdn_v2?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Region_Min_Fields = {
  __typename?: 'region_min_fields';
  legacy_metrics_fqdn?: Maybe<Scalars['String']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  metrics_fqdn_v2?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "region" */
export type Region_Mutation_Response = {
  __typename?: 'region_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Region>;
};

/** input type for inserting object relation for remote table "region" */
export type Region_Obj_Rel_Insert_Input = {
  data: Region_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Region_On_Conflict>;
};

/** on_conflict condition type for table "region" */
export type Region_On_Conflict = {
  constraint: Region_Constraint;
  update_columns?: Array<Region_Update_Column>;
  where?: Maybe<Region_Bool_Exp>;
};

/** Ordering options when selecting data from "region". */
export type Region_Order_By = {
  cloud?: Maybe<Order_By>;
  disable_infra_auto_apply?: Maybe<Order_By>;
  hasura_worker_security_group_id?: Maybe<Order_By>;
  healthcheck_variables?: Maybe<Order_By>;
  infra_status?: Maybe<Order_By>;
  input_variables?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  legacy_metrics_fqdn?: Maybe<Order_By>;
  lux_proxy_aggregate?: Maybe<Lux_Proxy_Aggregate_Order_By>;
  lux_proxy_security_group_id?: Maybe<Order_By>;
  lux_proxy_service_name?: Maybe<Order_By>;
  metrics_fqdn?: Maybe<Order_By>;
  metrics_fqdn_v2?: Maybe<Order_By>;
  metrics_ips?: Maybe<Order_By>;
  metrics_security_group_id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  nat_ip?: Maybe<Order_By>;
  nat_ips?: Maybe<Order_By>;
  operator_variables?: Maybe<Order_By>;
  output_variables?: Maybe<Order_By>;
  regional_metrics_aggregate?: Maybe<Regional_Metrics_Aggregate_Order_By>;
  vpc_id?: Maybe<Order_By>;
};

/** primary key columns input for table: region */
export type Region_Pk_Columns_Input = {
  cloud: Cloud_Enum;
  name: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Region_Prepend_Input = {
  healthcheck_variables?: Maybe<Scalars['jsonb']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  operator_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "region" */
export enum Region_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  HealthcheckVariables = 'healthcheck_variables',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  LegacyMetricsFqdn = 'legacy_metrics_fqdn',
  /** column name */
  MetricsFqdn = 'metrics_fqdn',
  /** column name */
  MetricsFqdnV2 = 'metrics_fqdn_v2',
  /** column name */
  Name = 'name',
  /** column name */
  NatIp = 'nat_ip',
  /** column name */
  OperatorVariables = 'operator_variables',
  /** column name */
  OutputVariables = 'output_variables',
}

/** input type for updating data in table "region" */
export type Region_Set_Input = {
  cloud?: Maybe<Cloud_Enum>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  healthcheck_variables?: Maybe<Scalars['jsonb']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  is_active?: Maybe<Scalars['Boolean']>;
  legacy_metrics_fqdn?: Maybe<Scalars['String']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  metrics_fqdn_v2?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  operator_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** Streaming cursor of the table "region" */
export type Region_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Region_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Region_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Cloud_Enum>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  healthcheck_variables?: Maybe<Scalars['jsonb']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  is_active?: Maybe<Scalars['Boolean']>;
  legacy_metrics_fqdn?: Maybe<Scalars['String']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  metrics_fqdn_v2?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  operator_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "region" */
export enum Region_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  HealthcheckVariables = 'healthcheck_variables',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  LegacyMetricsFqdn = 'legacy_metrics_fqdn',
  /** column name */
  MetricsFqdn = 'metrics_fqdn',
  /** column name */
  MetricsFqdnV2 = 'metrics_fqdn_v2',
  /** column name */
  Name = 'name',
  /** column name */
  NatIp = 'nat_ip',
  /** column name */
  OperatorVariables = 'operator_variables',
  /** column name */
  OutputVariables = 'output_variables',
}

export type Region_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Region_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Region_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Region_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Region_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Region_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Region_Set_Input>;
  /** filter the rows which have to be updated */
  where: Region_Bool_Exp;
};

/** View to capture version 2 of regions */
export type Region_V2 = {
  __typename?: 'region_v2';
  cloud?: Maybe<Scalars['String']>;
  infra_status?: Maybe<Scalars['String']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  is_active?: Maybe<Scalars['Boolean']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  region?: Maybe<Region>;
};

/** View to capture version 2 of regions */
export type Region_V2Input_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** View to capture version 2 of regions */
export type Region_V2Output_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "region_v2" */
export type Region_V2_Aggregate = {
  __typename?: 'region_v2_aggregate';
  aggregate?: Maybe<Region_V2_Aggregate_Fields>;
  nodes: Array<Region_V2>;
};

/** aggregate fields of "region_v2" */
export type Region_V2_Aggregate_Fields = {
  __typename?: 'region_v2_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Region_V2_Max_Fields>;
  min?: Maybe<Region_V2_Min_Fields>;
};

/** aggregate fields of "region_v2" */
export type Region_V2_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Region_V2_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Region_V2_Append_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "region_v2". All fields are combined with a logical 'AND'. */
export type Region_V2_Bool_Exp = {
  _and?: Maybe<Array<Region_V2_Bool_Exp>>;
  _not?: Maybe<Region_V2_Bool_Exp>;
  _or?: Maybe<Array<Region_V2_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  infra_status?: Maybe<String_Comparison_Exp>;
  input_variables?: Maybe<Jsonb_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  metrics_fqdn?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  nat_ip?: Maybe<String_Comparison_Exp>;
  output_variables?: Maybe<Jsonb_Comparison_Exp>;
  region?: Maybe<Region_Bool_Exp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Region_V2_Delete_At_Path_Input = {
  input_variables?: Maybe<Array<Scalars['String']>>;
  output_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Region_V2_Delete_Elem_Input = {
  input_variables?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Region_V2_Delete_Key_Input = {
  input_variables?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "region_v2" */
export type Region_V2_Insert_Input = {
  cloud?: Maybe<Scalars['String']>;
  infra_status?: Maybe<Scalars['String']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  is_active?: Maybe<Scalars['Boolean']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Region_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Region_V2_Max_Fields = {
  __typename?: 'region_v2_max_fields';
  cloud?: Maybe<Scalars['String']>;
  infra_status?: Maybe<Scalars['String']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Region_V2_Min_Fields = {
  __typename?: 'region_v2_min_fields';
  cloud?: Maybe<Scalars['String']>;
  infra_status?: Maybe<Scalars['String']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "region_v2" */
export type Region_V2_Mutation_Response = {
  __typename?: 'region_v2_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Region_V2>;
};

/** Ordering options when selecting data from "region_v2". */
export type Region_V2_Order_By = {
  cloud?: Maybe<Order_By>;
  infra_status?: Maybe<Order_By>;
  input_variables?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  metrics_fqdn?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  nat_ip?: Maybe<Order_By>;
  output_variables?: Maybe<Order_By>;
  region?: Maybe<Region_Order_By>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Region_V2_Prepend_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "region_v2" */
export enum Region_V2_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  MetricsFqdn = 'metrics_fqdn',
  /** column name */
  Name = 'name',
  /** column name */
  NatIp = 'nat_ip',
  /** column name */
  OutputVariables = 'output_variables',
}

/** input type for updating data in table "region_v2" */
export type Region_V2_Set_Input = {
  cloud?: Maybe<Scalars['String']>;
  infra_status?: Maybe<Scalars['String']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  is_active?: Maybe<Scalars['Boolean']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** Streaming cursor of the table "region_v2" */
export type Region_V2_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Region_V2_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Region_V2_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  infra_status?: Maybe<Scalars['String']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  is_active?: Maybe<Scalars['Boolean']>;
  metrics_fqdn?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  nat_ip?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

export type Region_V2_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Region_V2_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Region_V2_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Region_V2_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Region_V2_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Region_V2_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Region_V2_Set_Input>;
  /** filter the rows which have to be updated */
  where: Region_V2_Bool_Exp;
};

/** set of data connectors running in a region */
export type Regional_Data_Connectors = {
  __typename?: 'regional_data_connectors';
  cloud: Scalars['String'];
  created_at: Scalars['timestamptz'];
  data_connector_type: Data_Connector_Type_Enum;
  id: Scalars['uuid'];
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** set of data connectors running in a region */
export type Regional_Data_ConnectorsInput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** set of data connectors running in a region */
export type Regional_Data_ConnectorsOutput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "regional_data_connectors" */
export type Regional_Data_Connectors_Aggregate = {
  __typename?: 'regional_data_connectors_aggregate';
  aggregate?: Maybe<Regional_Data_Connectors_Aggregate_Fields>;
  nodes: Array<Regional_Data_Connectors>;
};

/** aggregate fields of "regional_data_connectors" */
export type Regional_Data_Connectors_Aggregate_Fields = {
  __typename?: 'regional_data_connectors_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Regional_Data_Connectors_Max_Fields>;
  min?: Maybe<Regional_Data_Connectors_Min_Fields>;
};

/** aggregate fields of "regional_data_connectors" */
export type Regional_Data_Connectors_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Regional_Data_Connectors_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Regional_Data_Connectors_Append_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "regional_data_connectors". All fields are combined with a logical 'AND'. */
export type Regional_Data_Connectors_Bool_Exp = {
  _and?: Maybe<Array<Regional_Data_Connectors_Bool_Exp>>;
  _not?: Maybe<Regional_Data_Connectors_Bool_Exp>;
  _or?: Maybe<Array<Regional_Data_Connectors_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  data_connector_type?: Maybe<Data_Connector_Type_Enum_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  input_variables?: Maybe<Jsonb_Comparison_Exp>;
  output_variables?: Maybe<Jsonb_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "regional_data_connectors" */
export enum Regional_Data_Connectors_Constraint {
  /** unique or primary key constraint on columns "id" */
  RegionalDataConnectorsPkey = 'regional_data_connectors_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Regional_Data_Connectors_Delete_At_Path_Input = {
  input_variables?: Maybe<Array<Scalars['String']>>;
  output_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Regional_Data_Connectors_Delete_Elem_Input = {
  input_variables?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Regional_Data_Connectors_Delete_Key_Input = {
  input_variables?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "regional_data_connectors" */
export type Regional_Data_Connectors_Insert_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_connector_type?: Maybe<Data_Connector_Type_Enum>;
  id?: Maybe<Scalars['uuid']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Regional_Data_Connectors_Max_Fields = {
  __typename?: 'regional_data_connectors_max_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Regional_Data_Connectors_Min_Fields = {
  __typename?: 'regional_data_connectors_min_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "regional_data_connectors" */
export type Regional_Data_Connectors_Mutation_Response = {
  __typename?: 'regional_data_connectors_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Regional_Data_Connectors>;
};

/** on_conflict condition type for table "regional_data_connectors" */
export type Regional_Data_Connectors_On_Conflict = {
  constraint: Regional_Data_Connectors_Constraint;
  update_columns?: Array<Regional_Data_Connectors_Update_Column>;
  where?: Maybe<Regional_Data_Connectors_Bool_Exp>;
};

/** Ordering options when selecting data from "regional_data_connectors". */
export type Regional_Data_Connectors_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  data_connector_type?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  input_variables?: Maybe<Order_By>;
  output_variables?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: regional_data_connectors */
export type Regional_Data_Connectors_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Regional_Data_Connectors_Prepend_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "regional_data_connectors" */
export enum Regional_Data_Connectors_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataConnectorType = 'data_connector_type',
  /** column name */
  Id = 'id',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "regional_data_connectors" */
export type Regional_Data_Connectors_Set_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_connector_type?: Maybe<Data_Connector_Type_Enum>;
  id?: Maybe<Scalars['uuid']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "regional_data_connectors" */
export type Regional_Data_Connectors_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Regional_Data_Connectors_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Regional_Data_Connectors_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  data_connector_type?: Maybe<Data_Connector_Type_Enum>;
  id?: Maybe<Scalars['uuid']>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "regional_data_connectors" */
export enum Regional_Data_Connectors_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DataConnectorType = 'data_connector_type',
  /** column name */
  Id = 'id',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Regional_Data_Connectors_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Regional_Data_Connectors_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Regional_Data_Connectors_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Regional_Data_Connectors_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Regional_Data_Connectors_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Regional_Data_Connectors_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Regional_Data_Connectors_Set_Input>;
  /** filter the rows which have to be updated */
  where: Regional_Data_Connectors_Bool_Exp;
};

/** Metrics captures on a regional level for cloud and region */
export type Regional_Metrics = {
  __typename?: 'regional_metrics';
  cloud: Scalars['String'];
  created_at: Scalars['timestamptz'];
  disable_infra_auto_apply: Scalars['Boolean'];
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  metrics_ips?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region: Scalars['String'];
  /** An object relationship */
  region_info?: Maybe<Region>;
  updated_at: Scalars['timestamptz'];
};

/** Metrics captures on a regional level for cloud and region */
export type Regional_MetricsInput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Metrics captures on a regional level for cloud and region */
export type Regional_MetricsMetrics_IpsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Metrics captures on a regional level for cloud and region */
export type Regional_MetricsOutput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "regional_metrics" */
export type Regional_Metrics_Aggregate = {
  __typename?: 'regional_metrics_aggregate';
  aggregate?: Maybe<Regional_Metrics_Aggregate_Fields>;
  nodes: Array<Regional_Metrics>;
};

export type Regional_Metrics_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Regional_Metrics_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Regional_Metrics_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Regional_Metrics_Aggregate_Bool_Exp_Count>;
};

export type Regional_Metrics_Aggregate_Bool_Exp_Bool_And = {
  arguments: Regional_Metrics_Select_Column_Regional_Metrics_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Regional_Metrics_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Regional_Metrics_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Regional_Metrics_Select_Column_Regional_Metrics_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Regional_Metrics_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Regional_Metrics_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Regional_Metrics_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Regional_Metrics_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "regional_metrics" */
export type Regional_Metrics_Aggregate_Fields = {
  __typename?: 'regional_metrics_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Regional_Metrics_Max_Fields>;
  min?: Maybe<Regional_Metrics_Min_Fields>;
};

/** aggregate fields of "regional_metrics" */
export type Regional_Metrics_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Regional_Metrics_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "regional_metrics" */
export type Regional_Metrics_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Regional_Metrics_Max_Order_By>;
  min?: Maybe<Regional_Metrics_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Regional_Metrics_Append_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "regional_metrics" */
export type Regional_Metrics_Arr_Rel_Insert_Input = {
  data: Array<Regional_Metrics_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Regional_Metrics_On_Conflict>;
};

/** Boolean expression to filter rows from the table "regional_metrics". All fields are combined with a logical 'AND'. */
export type Regional_Metrics_Bool_Exp = {
  _and?: Maybe<Array<Regional_Metrics_Bool_Exp>>;
  _not?: Maybe<Regional_Metrics_Bool_Exp>;
  _or?: Maybe<Array<Regional_Metrics_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  disable_infra_auto_apply?: Maybe<Boolean_Comparison_Exp>;
  infra_status?: Maybe<Infra_Status_Enum_Comparison_Exp>;
  input_variables?: Maybe<Jsonb_Comparison_Exp>;
  metrics_ips?: Maybe<Jsonb_Comparison_Exp>;
  output_variables?: Maybe<Jsonb_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  region_info?: Maybe<Region_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "regional_metrics" */
export enum Regional_Metrics_Constraint {
  /** unique or primary key constraint on columns "cloud", "region" */
  RegionalMetricsPkey = 'regional_metrics_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Regional_Metrics_Delete_At_Path_Input = {
  input_variables?: Maybe<Array<Scalars['String']>>;
  output_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Regional_Metrics_Delete_Elem_Input = {
  input_variables?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Regional_Metrics_Delete_Key_Input = {
  input_variables?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "regional_metrics" */
export type Regional_Metrics_Insert_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  region_info?: Maybe<Region_Obj_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Regional_Metrics_Max_Fields = {
  __typename?: 'regional_metrics_max_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "regional_metrics" */
export type Regional_Metrics_Max_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Regional_Metrics_Min_Fields = {
  __typename?: 'regional_metrics_min_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "regional_metrics" */
export type Regional_Metrics_Min_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "regional_metrics" */
export type Regional_Metrics_Mutation_Response = {
  __typename?: 'regional_metrics_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Regional_Metrics>;
};

/** on_conflict condition type for table "regional_metrics" */
export type Regional_Metrics_On_Conflict = {
  constraint: Regional_Metrics_Constraint;
  update_columns?: Array<Regional_Metrics_Update_Column>;
  where?: Maybe<Regional_Metrics_Bool_Exp>;
};

/** Ordering options when selecting data from "regional_metrics". */
export type Regional_Metrics_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  disable_infra_auto_apply?: Maybe<Order_By>;
  infra_status?: Maybe<Order_By>;
  input_variables?: Maybe<Order_By>;
  metrics_ips?: Maybe<Order_By>;
  output_variables?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  region_info?: Maybe<Region_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: regional_metrics */
export type Regional_Metrics_Pk_Columns_Input = {
  cloud: Scalars['String'];
  region: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Regional_Metrics_Prepend_Input = {
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "regional_metrics" */
export enum Regional_Metrics_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** select "regional_metrics_aggregate_bool_exp_bool_and_arguments_columns" columns of table "regional_metrics" */
export enum Regional_Metrics_Select_Column_Regional_Metrics_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
}

/** select "regional_metrics_aggregate_bool_exp_bool_or_arguments_columns" columns of table "regional_metrics" */
export enum Regional_Metrics_Select_Column_Regional_Metrics_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
}

/** input type for updating data in table "regional_metrics" */
export type Regional_Metrics_Set_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "regional_metrics" */
export type Regional_Metrics_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Regional_Metrics_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Regional_Metrics_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  input_variables?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "regional_metrics" */
export enum Regional_Metrics_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  InputVariables = 'input_variables',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Regional_Metrics_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Regional_Metrics_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Regional_Metrics_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Regional_Metrics_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Regional_Metrics_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Regional_Metrics_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Regional_Metrics_Set_Input>;
  /** filter the rows which have to be updated */
  where: Regional_Metrics_Bool_Exp;
};

/** Boolean expression to compare columns of type "reminder_type_enum". All fields are combined with logical 'AND'. */
export type Reminder_Type_Enum_Comparison_Exp = {
  _eq?: Maybe<Scalars['reminder_type_enum']>;
  _gt?: Maybe<Scalars['reminder_type_enum']>;
  _gte?: Maybe<Scalars['reminder_type_enum']>;
  _in?: Maybe<Array<Scalars['reminder_type_enum']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['reminder_type_enum']>;
  _lte?: Maybe<Scalars['reminder_type_enum']>;
  _neq?: Maybe<Scalars['reminder_type_enum']>;
  _nin?: Maybe<Array<Scalars['reminder_type_enum']>>;
};

export type ResendInvitationRequest = {
  collaborator_email: Scalars['String'];
  project_id: Scalars['uuid'];
};

export type ResendTransferOwnershipInvitationRequest = {
  invitee_email: Scalars['String'];
  project_id: Scalars['uuid'];
};

/** columns and relationships of "saml_idp" */
export type Saml_Idp = {
  __typename?: 'saml_idp';
  /** Boolean field to enable or disable SP Assertion Request Signing */
  disable_request_signing: Scalars['Boolean'];
  domain: Scalars['String'];
  id: Scalars['uuid'];
  idp_metadata_url?: Maybe<Scalars['String']>;
  idp_metadata_xml?: Maybe<Scalars['String']>;
  provider: Scalars['String'];
};

/** aggregated selection of "saml_idp" */
export type Saml_Idp_Aggregate = {
  __typename?: 'saml_idp_aggregate';
  aggregate?: Maybe<Saml_Idp_Aggregate_Fields>;
  nodes: Array<Saml_Idp>;
};

/** aggregate fields of "saml_idp" */
export type Saml_Idp_Aggregate_Fields = {
  __typename?: 'saml_idp_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Saml_Idp_Max_Fields>;
  min?: Maybe<Saml_Idp_Min_Fields>;
};

/** aggregate fields of "saml_idp" */
export type Saml_Idp_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Saml_Idp_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "saml_idp". All fields are combined with a logical 'AND'. */
export type Saml_Idp_Bool_Exp = {
  _and?: Maybe<Array<Saml_Idp_Bool_Exp>>;
  _not?: Maybe<Saml_Idp_Bool_Exp>;
  _or?: Maybe<Array<Saml_Idp_Bool_Exp>>;
  disable_request_signing?: Maybe<Boolean_Comparison_Exp>;
  domain?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  idp_metadata_url?: Maybe<String_Comparison_Exp>;
  idp_metadata_xml?: Maybe<String_Comparison_Exp>;
  provider?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "saml_idp" */
export enum Saml_Idp_Constraint {
  /** unique or primary key constraint on columns "domain" */
  SamlIdpDomainKey = 'saml_idp_domain_key',
  /** unique or primary key constraint on columns "id" */
  SamlIdpPkey = 'saml_idp_pkey',
}

/** input type for inserting data into table "saml_idp" */
export type Saml_Idp_Insert_Input = {
  /** Boolean field to enable or disable SP Assertion Request Signing */
  disable_request_signing?: Maybe<Scalars['Boolean']>;
  domain?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  idp_metadata_url?: Maybe<Scalars['String']>;
  idp_metadata_xml?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Saml_Idp_Max_Fields = {
  __typename?: 'saml_idp_max_fields';
  domain?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  idp_metadata_url?: Maybe<Scalars['String']>;
  idp_metadata_xml?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Saml_Idp_Min_Fields = {
  __typename?: 'saml_idp_min_fields';
  domain?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  idp_metadata_url?: Maybe<Scalars['String']>;
  idp_metadata_xml?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "saml_idp" */
export type Saml_Idp_Mutation_Response = {
  __typename?: 'saml_idp_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Saml_Idp>;
};

/** on_conflict condition type for table "saml_idp" */
export type Saml_Idp_On_Conflict = {
  constraint: Saml_Idp_Constraint;
  update_columns?: Array<Saml_Idp_Update_Column>;
  where?: Maybe<Saml_Idp_Bool_Exp>;
};

/** Ordering options when selecting data from "saml_idp". */
export type Saml_Idp_Order_By = {
  disable_request_signing?: Maybe<Order_By>;
  domain?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  idp_metadata_url?: Maybe<Order_By>;
  idp_metadata_xml?: Maybe<Order_By>;
  provider?: Maybe<Order_By>;
};

/** primary key columns input for table: saml_idp */
export type Saml_Idp_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "saml_idp" */
export enum Saml_Idp_Select_Column {
  /** column name */
  DisableRequestSigning = 'disable_request_signing',
  /** column name */
  Domain = 'domain',
  /** column name */
  Id = 'id',
  /** column name */
  IdpMetadataUrl = 'idp_metadata_url',
  /** column name */
  IdpMetadataXml = 'idp_metadata_xml',
  /** column name */
  Provider = 'provider',
}

/** input type for updating data in table "saml_idp" */
export type Saml_Idp_Set_Input = {
  /** Boolean field to enable or disable SP Assertion Request Signing */
  disable_request_signing?: Maybe<Scalars['Boolean']>;
  domain?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  idp_metadata_url?: Maybe<Scalars['String']>;
  idp_metadata_xml?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "saml_idp" */
export type Saml_Idp_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Saml_Idp_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Saml_Idp_Stream_Cursor_Value_Input = {
  /** Boolean field to enable or disable SP Assertion Request Signing */
  disable_request_signing?: Maybe<Scalars['Boolean']>;
  domain?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  idp_metadata_url?: Maybe<Scalars['String']>;
  idp_metadata_xml?: Maybe<Scalars['String']>;
  provider?: Maybe<Scalars['String']>;
};

/** update columns of table "saml_idp" */
export enum Saml_Idp_Update_Column {
  /** column name */
  DisableRequestSigning = 'disable_request_signing',
  /** column name */
  Domain = 'domain',
  /** column name */
  Id = 'id',
  /** column name */
  IdpMetadataUrl = 'idp_metadata_url',
  /** column name */
  IdpMetadataXml = 'idp_metadata_xml',
  /** column name */
  Provider = 'provider',
}

export type Saml_Idp_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Saml_Idp_Set_Input>;
  /** filter the rows which have to be updated */
  where: Saml_Idp_Bool_Exp;
};

export type SaveSurveyAnswerV2Payload = {
  projectID?: Maybe<Scalars['uuid']>;
  responses: Array<Maybe<SurveyResponseV2>>;
  surveyName: Scalars['String'];
};

export type Search_Project_Login_Status_Args = {
  from_time?: Maybe<Scalars['timestamptz']>;
  project_ids?: Maybe<Scalars['_uuid']>;
  to_time?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "search_project_login_status_results" */
export type Search_Project_Login_Status_Results = {
  __typename?: 'search_project_login_status_results';
  last_login?: Maybe<Scalars['timestamptz']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
};

export type Search_Project_Login_Status_Results_Aggregate = {
  __typename?: 'search_project_login_status_results_aggregate';
  aggregate?: Maybe<Search_Project_Login_Status_Results_Aggregate_Fields>;
  nodes: Array<Search_Project_Login_Status_Results>;
};

/** aggregate fields of "search_project_login_status_results" */
export type Search_Project_Login_Status_Results_Aggregate_Fields = {
  __typename?: 'search_project_login_status_results_aggregate_fields';
  avg?: Maybe<Search_Project_Login_Status_Results_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Search_Project_Login_Status_Results_Max_Fields>;
  min?: Maybe<Search_Project_Login_Status_Results_Min_Fields>;
  stddev?: Maybe<Search_Project_Login_Status_Results_Stddev_Fields>;
  stddev_pop?: Maybe<Search_Project_Login_Status_Results_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Search_Project_Login_Status_Results_Stddev_Samp_Fields>;
  sum?: Maybe<Search_Project_Login_Status_Results_Sum_Fields>;
  var_pop?: Maybe<Search_Project_Login_Status_Results_Var_Pop_Fields>;
  var_samp?: Maybe<Search_Project_Login_Status_Results_Var_Samp_Fields>;
  variance?: Maybe<Search_Project_Login_Status_Results_Variance_Fields>;
};

/** aggregate fields of "search_project_login_status_results" */
export type Search_Project_Login_Status_Results_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Search_Project_Login_Status_Results_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Search_Project_Login_Status_Results_Avg_Fields = {
  __typename?: 'search_project_login_status_results_avg_fields';
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/**
 * Boolean expression to filter rows from the table
 * "search_project_login_status_results". All fields are combined with a logical 'AND'.
 */
export type Search_Project_Login_Status_Results_Bool_Exp = {
  _and?: Maybe<Array<Search_Project_Login_Status_Results_Bool_Exp>>;
  _not?: Maybe<Search_Project_Login_Status_Results_Bool_Exp>;
  _or?: Maybe<Array<Search_Project_Login_Status_Results_Bool_Exp>>;
  last_login?: Maybe<Timestamptz_Comparison_Exp>;
  num_collaborators?: Maybe<Int_Comparison_Exp>;
  num_login_sessions?: Maybe<Int_Comparison_Exp>;
  num_read_replicas?: Maybe<Int_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "search_project_login_status_results" */
export type Search_Project_Login_Status_Results_Inc_Input = {
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "search_project_login_status_results" */
export type Search_Project_Login_Status_Results_Insert_Input = {
  last_login?: Maybe<Scalars['timestamptz']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Search_Project_Login_Status_Results_Max_Fields = {
  __typename?: 'search_project_login_status_results_max_fields';
  last_login?: Maybe<Scalars['timestamptz']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Search_Project_Login_Status_Results_Min_Fields = {
  __typename?: 'search_project_login_status_results_min_fields';
  last_login?: Maybe<Scalars['timestamptz']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "search_project_login_status_results" */
export type Search_Project_Login_Status_Results_Mutation_Response = {
  __typename?: 'search_project_login_status_results_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Search_Project_Login_Status_Results>;
};

/** Ordering options when selecting data from "search_project_login_status_results". */
export type Search_Project_Login_Status_Results_Order_By = {
  last_login?: Maybe<Order_By>;
  num_collaborators?: Maybe<Order_By>;
  num_login_sessions?: Maybe<Order_By>;
  num_read_replicas?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
};

/** select columns of table "search_project_login_status_results" */
export enum Search_Project_Login_Status_Results_Select_Column {
  /** column name */
  LastLogin = 'last_login',
  /** column name */
  NumCollaborators = 'num_collaborators',
  /** column name */
  NumLoginSessions = 'num_login_sessions',
  /** column name */
  NumReadReplicas = 'num_read_replicas',
  /** column name */
  ProjectId = 'project_id',
}

/** input type for updating data in table "search_project_login_status_results" */
export type Search_Project_Login_Status_Results_Set_Input = {
  last_login?: Maybe<Scalars['timestamptz']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Search_Project_Login_Status_Results_Stddev_Fields = {
  __typename?: 'search_project_login_status_results_stddev_fields';
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Search_Project_Login_Status_Results_Stddev_Pop_Fields = {
  __typename?: 'search_project_login_status_results_stddev_pop_fields';
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Search_Project_Login_Status_Results_Stddev_Samp_Fields = {
  __typename?: 'search_project_login_status_results_stddev_samp_fields';
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "search_project_login_status_results" */
export type Search_Project_Login_Status_Results_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Search_Project_Login_Status_Results_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Search_Project_Login_Status_Results_Stream_Cursor_Value_Input = {
  last_login?: Maybe<Scalars['timestamptz']>;
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Search_Project_Login_Status_Results_Sum_Fields = {
  __typename?: 'search_project_login_status_results_sum_fields';
  num_collaborators?: Maybe<Scalars['Int']>;
  num_login_sessions?: Maybe<Scalars['Int']>;
  num_read_replicas?: Maybe<Scalars['Int']>;
};

export type Search_Project_Login_Status_Results_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Search_Project_Login_Status_Results_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Search_Project_Login_Status_Results_Set_Input>;
  /** filter the rows which have to be updated */
  where: Search_Project_Login_Status_Results_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Search_Project_Login_Status_Results_Var_Pop_Fields = {
  __typename?: 'search_project_login_status_results_var_pop_fields';
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Search_Project_Login_Status_Results_Var_Samp_Fields = {
  __typename?: 'search_project_login_status_results_var_samp_fields';
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Search_Project_Login_Status_Results_Variance_Fields = {
  __typename?: 'search_project_login_status_results_variance_fields';
  num_collaborators?: Maybe<Scalars['Float']>;
  num_login_sessions?: Maybe<Scalars['Float']>;
  num_read_replicas?: Maybe<Scalars['Float']>;
};

export type Search_Tenant_Group_Has_Least_Members_Args = {
  allocation_policies?: Maybe<Scalars['_text']>;
  clouds?: Maybe<Scalars['_text']>;
  dedicated_vpc_ids?: Maybe<Scalars['_uuid']>;
  ids?: Maybe<Scalars['_uuid']>;
  major_versions?: Maybe<Scalars['_int4']>;
  plan_names?: Maybe<Scalars['_text']>;
  regions?: Maybe<Scalars['_text']>;
};

export type SetVercelIntegrationInput = {
  configuration_id: Scalars['String'];
  connections: Array<VercelIntegrationConnectionsInput>;
  team_id?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['String']>;
};

export type SetVercelIntegrationOutput = {
  __typename?: 'SetVercelIntegrationOutput';
  id: Scalars['String'];
};

/** stores the configuration for slack which user has configured */
export type Slack_Config = {
  __typename?: 'slack_config';
  /** An object relationship */
  alert_config?: Maybe<Alert_Config>;
  channel_id?: Maybe<Scalars['String']>;
  channel_name?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  project_id: Scalars['uuid'];
  slack_team_id?: Maybe<Scalars['String']>;
  team_name?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  webhook_url: Scalars['String'];
};

/** aggregated selection of "slack_config" */
export type Slack_Config_Aggregate = {
  __typename?: 'slack_config_aggregate';
  aggregate?: Maybe<Slack_Config_Aggregate_Fields>;
  nodes: Array<Slack_Config>;
};

export type Slack_Config_Aggregate_Bool_Exp = {
  count?: Maybe<Slack_Config_Aggregate_Bool_Exp_Count>;
};

export type Slack_Config_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Slack_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Slack_Config_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "slack_config" */
export type Slack_Config_Aggregate_Fields = {
  __typename?: 'slack_config_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Slack_Config_Max_Fields>;
  min?: Maybe<Slack_Config_Min_Fields>;
};

/** aggregate fields of "slack_config" */
export type Slack_Config_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Slack_Config_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "slack_config" */
export type Slack_Config_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Slack_Config_Max_Order_By>;
  min?: Maybe<Slack_Config_Min_Order_By>;
};

/** input type for inserting array relation for remote table "slack_config" */
export type Slack_Config_Arr_Rel_Insert_Input = {
  data: Array<Slack_Config_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Slack_Config_On_Conflict>;
};

/** Boolean expression to filter rows from the table "slack_config". All fields are combined with a logical 'AND'. */
export type Slack_Config_Bool_Exp = {
  _and?: Maybe<Array<Slack_Config_Bool_Exp>>;
  _not?: Maybe<Slack_Config_Bool_Exp>;
  _or?: Maybe<Array<Slack_Config_Bool_Exp>>;
  alert_config?: Maybe<Alert_Config_Bool_Exp>;
  channel_id?: Maybe<String_Comparison_Exp>;
  channel_name?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  slack_team_id?: Maybe<String_Comparison_Exp>;
  team_name?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  webhook_url?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "slack_config" */
export enum Slack_Config_Constraint {
  /** unique or primary key constraint on columns "id" */
  SlackConfigPkey = 'slack_config_pkey',
  /** unique or primary key constraint on columns "project_id" */
  SlackConfigProjectIdKey = 'slack_config_project_id_key',
}

/** input type for inserting data into table "slack_config" */
export type Slack_Config_Insert_Input = {
  alert_config?: Maybe<Alert_Config_Obj_Rel_Insert_Input>;
  channel_id?: Maybe<Scalars['String']>;
  channel_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  slack_team_id?: Maybe<Scalars['String']>;
  team_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  webhook_url?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Slack_Config_Max_Fields = {
  __typename?: 'slack_config_max_fields';
  channel_id?: Maybe<Scalars['String']>;
  channel_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  slack_team_id?: Maybe<Scalars['String']>;
  team_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  webhook_url?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "slack_config" */
export type Slack_Config_Max_Order_By = {
  channel_id?: Maybe<Order_By>;
  channel_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  slack_team_id?: Maybe<Order_By>;
  team_name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  webhook_url?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Slack_Config_Min_Fields = {
  __typename?: 'slack_config_min_fields';
  channel_id?: Maybe<Scalars['String']>;
  channel_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  slack_team_id?: Maybe<Scalars['String']>;
  team_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  webhook_url?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "slack_config" */
export type Slack_Config_Min_Order_By = {
  channel_id?: Maybe<Order_By>;
  channel_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  slack_team_id?: Maybe<Order_By>;
  team_name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  webhook_url?: Maybe<Order_By>;
};

/** response of any mutation on the table "slack_config" */
export type Slack_Config_Mutation_Response = {
  __typename?: 'slack_config_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Slack_Config>;
};

/** input type for inserting object relation for remote table "slack_config" */
export type Slack_Config_Obj_Rel_Insert_Input = {
  data: Slack_Config_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Slack_Config_On_Conflict>;
};

/** on_conflict condition type for table "slack_config" */
export type Slack_Config_On_Conflict = {
  constraint: Slack_Config_Constraint;
  update_columns?: Array<Slack_Config_Update_Column>;
  where?: Maybe<Slack_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "slack_config". */
export type Slack_Config_Order_By = {
  alert_config?: Maybe<Alert_Config_Order_By>;
  channel_id?: Maybe<Order_By>;
  channel_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  slack_team_id?: Maybe<Order_By>;
  team_name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  webhook_url?: Maybe<Order_By>;
};

/** primary key columns input for table: slack_config */
export type Slack_Config_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "slack_config" */
export enum Slack_Config_Select_Column {
  /** column name */
  ChannelId = 'channel_id',
  /** column name */
  ChannelName = 'channel_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  SlackTeamId = 'slack_team_id',
  /** column name */
  TeamName = 'team_name',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WebhookUrl = 'webhook_url',
}

/** input type for updating data in table "slack_config" */
export type Slack_Config_Set_Input = {
  channel_id?: Maybe<Scalars['String']>;
  channel_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  slack_team_id?: Maybe<Scalars['String']>;
  team_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  webhook_url?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "slack_config" */
export type Slack_Config_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Slack_Config_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Slack_Config_Stream_Cursor_Value_Input = {
  channel_id?: Maybe<Scalars['String']>;
  channel_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  slack_team_id?: Maybe<Scalars['String']>;
  team_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  webhook_url?: Maybe<Scalars['String']>;
};

/** update columns of table "slack_config" */
export enum Slack_Config_Update_Column {
  /** column name */
  ChannelId = 'channel_id',
  /** column name */
  ChannelName = 'channel_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  SlackTeamId = 'slack_team_id',
  /** column name */
  TeamName = 'team_name',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WebhookUrl = 'webhook_url',
}

export type Slack_Config_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Slack_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Slack_Config_Bool_Exp;
};

export type SlackExchangeTokenResponse = {
  __typename?: 'SlackExchangeTokenResponse';
  channel_name: Scalars['String'];
  team_name: Scalars['String'];
};

/** Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'. */
export type Smallint_Comparison_Exp = {
  _eq?: Maybe<Scalars['smallint']>;
  _gt?: Maybe<Scalars['smallint']>;
  _gte?: Maybe<Scalars['smallint']>;
  _in?: Maybe<Array<Scalars['smallint']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['smallint']>;
  _lte?: Maybe<Scalars['smallint']>;
  _neq?: Maybe<Scalars['smallint']>;
  _nin?: Maybe<Array<Scalars['smallint']>>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: Maybe<Scalars['String']>;
  _gt?: Maybe<Scalars['String']>;
  _gte?: Maybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: Maybe<Scalars['String']>;
  _in?: Maybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: Maybe<Scalars['String']>;
  _is_null?: Maybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: Maybe<Scalars['String']>;
  _lt?: Maybe<Scalars['String']>;
  _lte?: Maybe<Scalars['String']>;
  _neq?: Maybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: Maybe<Scalars['String']>;
  _nin?: Maybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: Maybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: Maybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: Maybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: Maybe<Scalars['String']>;
};

/** Stripe subscription per customer */
export type Stripe_Subscription = {
  __typename?: 'stripe_subscription';
  collection_method: Scalars['String'];
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  customer?: Maybe<Users>;
  customer_id: Scalars['String'];
  /** An object relationship */
  payment_method: Payment_Method;
  payment_method_id: Scalars['String'];
  remarks: Scalars['String'];
  status: Scalars['String'];
  subscription_id: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "stripe_subscription" */
export type Stripe_Subscription_Aggregate = {
  __typename?: 'stripe_subscription_aggregate';
  aggregate?: Maybe<Stripe_Subscription_Aggregate_Fields>;
  nodes: Array<Stripe_Subscription>;
};

/** aggregate fields of "stripe_subscription" */
export type Stripe_Subscription_Aggregate_Fields = {
  __typename?: 'stripe_subscription_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Stripe_Subscription_Max_Fields>;
  min?: Maybe<Stripe_Subscription_Min_Fields>;
};

/** aggregate fields of "stripe_subscription" */
export type Stripe_Subscription_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Stripe_Subscription_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "stripe_subscription". All fields are combined with a logical 'AND'. */
export type Stripe_Subscription_Bool_Exp = {
  _and?: Maybe<Array<Stripe_Subscription_Bool_Exp>>;
  _not?: Maybe<Stripe_Subscription_Bool_Exp>;
  _or?: Maybe<Array<Stripe_Subscription_Bool_Exp>>;
  collection_method?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customer?: Maybe<Users_Bool_Exp>;
  customer_id?: Maybe<String_Comparison_Exp>;
  payment_method?: Maybe<Payment_Method_Bool_Exp>;
  payment_method_id?: Maybe<String_Comparison_Exp>;
  remarks?: Maybe<String_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  subscription_id?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "stripe_subscription" */
export enum Stripe_Subscription_Constraint {
  /** unique or primary key constraint on columns "subscription_id", "customer_id" */
  StripeSubscriptionPkey = 'stripe_subscription_pkey',
}

/** input type for inserting data into table "stripe_subscription" */
export type Stripe_Subscription_Insert_Input = {
  collection_method?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer?: Maybe<Users_Obj_Rel_Insert_Input>;
  customer_id?: Maybe<Scalars['String']>;
  payment_method?: Maybe<Payment_Method_Obj_Rel_Insert_Input>;
  payment_method_id?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  subscription_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Stripe_Subscription_Max_Fields = {
  __typename?: 'stripe_subscription_max_fields';
  collection_method?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  payment_method_id?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  subscription_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Stripe_Subscription_Min_Fields = {
  __typename?: 'stripe_subscription_min_fields';
  collection_method?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  payment_method_id?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  subscription_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "stripe_subscription" */
export type Stripe_Subscription_Mutation_Response = {
  __typename?: 'stripe_subscription_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Stripe_Subscription>;
};

/** on_conflict condition type for table "stripe_subscription" */
export type Stripe_Subscription_On_Conflict = {
  constraint: Stripe_Subscription_Constraint;
  update_columns?: Array<Stripe_Subscription_Update_Column>;
  where?: Maybe<Stripe_Subscription_Bool_Exp>;
};

/** Ordering options when selecting data from "stripe_subscription". */
export type Stripe_Subscription_Order_By = {
  collection_method?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer?: Maybe<Users_Order_By>;
  customer_id?: Maybe<Order_By>;
  payment_method?: Maybe<Payment_Method_Order_By>;
  payment_method_id?: Maybe<Order_By>;
  remarks?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  subscription_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: stripe_subscription */
export type Stripe_Subscription_Pk_Columns_Input = {
  customer_id: Scalars['String'];
  subscription_id: Scalars['String'];
};

/** select columns of table "stripe_subscription" */
export enum Stripe_Subscription_Select_Column {
  /** column name */
  CollectionMethod = 'collection_method',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  PaymentMethodId = 'payment_method_id',
  /** column name */
  Remarks = 'remarks',
  /** column name */
  Status = 'status',
  /** column name */
  SubscriptionId = 'subscription_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "stripe_subscription" */
export type Stripe_Subscription_Set_Input = {
  collection_method?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  payment_method_id?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  subscription_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "stripe_subscription" */
export type Stripe_Subscription_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Stripe_Subscription_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Stripe_Subscription_Stream_Cursor_Value_Input = {
  collection_method?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  payment_method_id?: Maybe<Scalars['String']>;
  remarks?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  subscription_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "stripe_subscription" */
export enum Stripe_Subscription_Update_Column {
  /** column name */
  CollectionMethod = 'collection_method',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  PaymentMethodId = 'payment_method_id',
  /** column name */
  Remarks = 'remarks',
  /** column name */
  Status = 'status',
  /** column name */
  SubscriptionId = 'subscription_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Stripe_Subscription_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Stripe_Subscription_Set_Input>;
  /** filter the rows which have to be updated */
  where: Stripe_Subscription_Bool_Exp;
};

/**
 * This table stores only those events received from Stripe that need to be acted
 * on. (eg - for sending mails, delete user tasks)
 */
export type Stripe_Webhook_Events = {
  __typename?: 'stripe_webhook_events';
  created_at: Scalars['timestamptz'];
  error?: Maybe<Scalars['String']>;
  event_type: Scalars['String'];
  /** An object relationship */
  invoice?: Maybe<Invoice>;
  invoice_id: Scalars['String'];
  is_handled: Scalars['Boolean'];
  request_body_invoice_object: Scalars['jsonb'];
  stripe_event_id: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/**
 * This table stores only those events received from Stripe that need to be acted
 * on. (eg - for sending mails, delete user tasks)
 */
export type Stripe_Webhook_EventsRequest_Body_Invoice_ObjectArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "stripe_webhook_events" */
export type Stripe_Webhook_Events_Aggregate = {
  __typename?: 'stripe_webhook_events_aggregate';
  aggregate?: Maybe<Stripe_Webhook_Events_Aggregate_Fields>;
  nodes: Array<Stripe_Webhook_Events>;
};

/** aggregate fields of "stripe_webhook_events" */
export type Stripe_Webhook_Events_Aggregate_Fields = {
  __typename?: 'stripe_webhook_events_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Stripe_Webhook_Events_Max_Fields>;
  min?: Maybe<Stripe_Webhook_Events_Min_Fields>;
};

/** aggregate fields of "stripe_webhook_events" */
export type Stripe_Webhook_Events_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Stripe_Webhook_Events_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Stripe_Webhook_Events_Append_Input = {
  request_body_invoice_object?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "stripe_webhook_events". All fields are combined with a logical 'AND'. */
export type Stripe_Webhook_Events_Bool_Exp = {
  _and?: Maybe<Array<Stripe_Webhook_Events_Bool_Exp>>;
  _not?: Maybe<Stripe_Webhook_Events_Bool_Exp>;
  _or?: Maybe<Array<Stripe_Webhook_Events_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  error?: Maybe<String_Comparison_Exp>;
  event_type?: Maybe<String_Comparison_Exp>;
  invoice?: Maybe<Invoice_Bool_Exp>;
  invoice_id?: Maybe<String_Comparison_Exp>;
  is_handled?: Maybe<Boolean_Comparison_Exp>;
  request_body_invoice_object?: Maybe<Jsonb_Comparison_Exp>;
  stripe_event_id?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "stripe_webhook_events" */
export enum Stripe_Webhook_Events_Constraint {
  /** unique or primary key constraint on columns "stripe_event_id" */
  StripeWebhookEventsPkey = 'stripe_webhook_events_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Stripe_Webhook_Events_Delete_At_Path_Input = {
  request_body_invoice_object?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Stripe_Webhook_Events_Delete_Elem_Input = {
  request_body_invoice_object?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Stripe_Webhook_Events_Delete_Key_Input = {
  request_body_invoice_object?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "stripe_webhook_events" */
export type Stripe_Webhook_Events_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  error?: Maybe<Scalars['String']>;
  event_type?: Maybe<Scalars['String']>;
  invoice?: Maybe<Invoice_Obj_Rel_Insert_Input>;
  invoice_id?: Maybe<Scalars['String']>;
  is_handled?: Maybe<Scalars['Boolean']>;
  request_body_invoice_object?: Maybe<Scalars['jsonb']>;
  stripe_event_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Stripe_Webhook_Events_Max_Fields = {
  __typename?: 'stripe_webhook_events_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  error?: Maybe<Scalars['String']>;
  event_type?: Maybe<Scalars['String']>;
  invoice_id?: Maybe<Scalars['String']>;
  stripe_event_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Stripe_Webhook_Events_Min_Fields = {
  __typename?: 'stripe_webhook_events_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  error?: Maybe<Scalars['String']>;
  event_type?: Maybe<Scalars['String']>;
  invoice_id?: Maybe<Scalars['String']>;
  stripe_event_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "stripe_webhook_events" */
export type Stripe_Webhook_Events_Mutation_Response = {
  __typename?: 'stripe_webhook_events_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Stripe_Webhook_Events>;
};

/** on_conflict condition type for table "stripe_webhook_events" */
export type Stripe_Webhook_Events_On_Conflict = {
  constraint: Stripe_Webhook_Events_Constraint;
  update_columns?: Array<Stripe_Webhook_Events_Update_Column>;
  where?: Maybe<Stripe_Webhook_Events_Bool_Exp>;
};

/** Ordering options when selecting data from "stripe_webhook_events". */
export type Stripe_Webhook_Events_Order_By = {
  created_at?: Maybe<Order_By>;
  error?: Maybe<Order_By>;
  event_type?: Maybe<Order_By>;
  invoice?: Maybe<Invoice_Order_By>;
  invoice_id?: Maybe<Order_By>;
  is_handled?: Maybe<Order_By>;
  request_body_invoice_object?: Maybe<Order_By>;
  stripe_event_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: stripe_webhook_events */
export type Stripe_Webhook_Events_Pk_Columns_Input = {
  stripe_event_id: Scalars['String'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Stripe_Webhook_Events_Prepend_Input = {
  request_body_invoice_object?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "stripe_webhook_events" */
export enum Stripe_Webhook_Events_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Error = 'error',
  /** column name */
  EventType = 'event_type',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  IsHandled = 'is_handled',
  /** column name */
  RequestBodyInvoiceObject = 'request_body_invoice_object',
  /** column name */
  StripeEventId = 'stripe_event_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "stripe_webhook_events" */
export type Stripe_Webhook_Events_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  error?: Maybe<Scalars['String']>;
  event_type?: Maybe<Scalars['String']>;
  invoice_id?: Maybe<Scalars['String']>;
  is_handled?: Maybe<Scalars['Boolean']>;
  request_body_invoice_object?: Maybe<Scalars['jsonb']>;
  stripe_event_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "stripe_webhook_events" */
export type Stripe_Webhook_Events_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Stripe_Webhook_Events_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Stripe_Webhook_Events_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  error?: Maybe<Scalars['String']>;
  event_type?: Maybe<Scalars['String']>;
  invoice_id?: Maybe<Scalars['String']>;
  is_handled?: Maybe<Scalars['Boolean']>;
  request_body_invoice_object?: Maybe<Scalars['jsonb']>;
  stripe_event_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "stripe_webhook_events" */
export enum Stripe_Webhook_Events_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Error = 'error',
  /** column name */
  EventType = 'event_type',
  /** column name */
  InvoiceId = 'invoice_id',
  /** column name */
  IsHandled = 'is_handled',
  /** column name */
  RequestBodyInvoiceObject = 'request_body_invoice_object',
  /** column name */
  StripeEventId = 'stripe_event_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Stripe_Webhook_Events_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Stripe_Webhook_Events_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Stripe_Webhook_Events_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Stripe_Webhook_Events_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Stripe_Webhook_Events_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Stripe_Webhook_Events_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Stripe_Webhook_Events_Set_Input>;
  /** filter the rows which have to be updated */
  where: Stripe_Webhook_Events_Bool_Exp;
};

export type StripeCardResponse = {
  __typename?: 'StripeCardResponse';
  id: Scalars['String'];
  status: Scalars['String'];
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "alert_config" */
  alert_config: Array<Alert_Config>;
  /** fetch aggregated fields from the table: "alert_config" */
  alert_config_aggregate: Alert_Config_Aggregate;
  /** fetch data from the table: "alert_config_alert_type" */
  alert_config_alert_type: Array<Alert_Config_Alert_Type>;
  /** fetch aggregated fields from the table: "alert_config_alert_type" */
  alert_config_alert_type_aggregate: Alert_Config_Alert_Type_Aggregate;
  /** fetch data from the table: "alert_config_alert_type" using primary key columns */
  alert_config_alert_type_by_pk?: Maybe<Alert_Config_Alert_Type>;
  /** fetch data from the table in a streaming manner: "alert_config_alert_type" */
  alert_config_alert_type_stream: Array<Alert_Config_Alert_Type>;
  /** fetch data from the table: "alert_config" using primary key columns */
  alert_config_by_pk?: Maybe<Alert_Config>;
  /** fetch data from the table: "alert_config_service" */
  alert_config_service: Array<Alert_Config_Service>;
  /** fetch aggregated fields from the table: "alert_config_service" */
  alert_config_service_aggregate: Alert_Config_Service_Aggregate;
  /** fetch data from the table: "alert_config_service" using primary key columns */
  alert_config_service_by_pk?: Maybe<Alert_Config_Service>;
  /** fetch data from the table in a streaming manner: "alert_config_service" */
  alert_config_service_stream: Array<Alert_Config_Service>;
  /** fetch data from the table in a streaming manner: "alert_config" */
  alert_config_stream: Array<Alert_Config>;
  /** fetch data from the table: "alert_service_type" */
  alert_service_type: Array<Alert_Service_Type>;
  /** fetch aggregated fields from the table: "alert_service_type" */
  alert_service_type_aggregate: Alert_Service_Type_Aggregate;
  /** fetch data from the table: "alert_service_type" using primary key columns */
  alert_service_type_by_pk?: Maybe<Alert_Service_Type>;
  /** fetch data from the table in a streaming manner: "alert_service_type" */
  alert_service_type_stream: Array<Alert_Service_Type>;
  /** fetch data from the table: "alert_type" */
  alert_type: Array<Alert_Type>;
  /** fetch aggregated fields from the table: "alert_type" */
  alert_type_aggregate: Alert_Type_Aggregate;
  /** fetch data from the table: "alert_type" using primary key columns */
  alert_type_by_pk?: Maybe<Alert_Type>;
  /** fetch data from the table in a streaming manner: "alert_type" */
  alert_type_stream: Array<Alert_Type>;
  /** fetch data from the table: "azuremonitor_config" */
  azuremonitor_config: Array<Azuremonitor_Config>;
  /** fetch aggregated fields from the table: "azuremonitor_config" */
  azuremonitor_config_aggregate: Azuremonitor_Config_Aggregate;
  /** fetch data from the table: "azuremonitor_config" using primary key columns */
  azuremonitor_config_by_pk?: Maybe<Azuremonitor_Config>;
  /** fetch data from the table in a streaming manner: "azuremonitor_config" */
  azuremonitor_config_stream: Array<Azuremonitor_Config>;
  /** fetch data from the table: "billing_address" */
  billing_address: Array<Billing_Address>;
  /** fetch aggregated fields from the table: "billing_address" */
  billing_address_aggregate: Billing_Address_Aggregate;
  /** fetch data from the table: "billing_address" using primary key columns */
  billing_address_by_pk?: Maybe<Billing_Address>;
  /** fetch data from the table in a streaming manner: "billing_address" */
  billing_address_stream: Array<Billing_Address>;
  /** fetch data from the table: "central_cloud" */
  central_cloud: Array<Central_Cloud>;
  /** fetch aggregated fields from the table: "central_cloud" */
  central_cloud_aggregate: Central_Cloud_Aggregate;
  /** fetch data from the table: "central_cloud" using primary key columns */
  central_cloud_by_pk?: Maybe<Central_Cloud>;
  /** fetch data from the table in a streaming manner: "central_cloud" */
  central_cloud_stream: Array<Central_Cloud>;
  /** fetch data from the table: "change_email_request" */
  change_email_request: Array<Change_Email_Request>;
  /** fetch aggregated fields from the table: "change_email_request" */
  change_email_request_aggregate: Change_Email_Request_Aggregate;
  /** fetch data from the table: "change_email_request" using primary key columns */
  change_email_request_by_pk?: Maybe<Change_Email_Request>;
  /** fetch data from the table in a streaming manner: "change_email_request" */
  change_email_request_stream: Array<Change_Email_Request>;
  /** fetch data from the table: "cicd.deployment_pipeline_config" */
  cicd_deployment_pipeline_config: Array<Cicd_Deployment_Pipeline_Config>;
  /** fetch aggregated fields from the table: "cicd.deployment_pipeline_config" */
  cicd_deployment_pipeline_config_aggregate: Cicd_Deployment_Pipeline_Config_Aggregate;
  /** fetch data from the table: "cicd.deployment_pipeline_config" using primary key columns */
  cicd_deployment_pipeline_config_by_pk?: Maybe<Cicd_Deployment_Pipeline_Config>;
  /** fetch data from the table in a streaming manner: "cicd.deployment_pipeline_config" */
  cicd_deployment_pipeline_config_stream: Array<Cicd_Deployment_Pipeline_Config>;
  /** fetch data from the table: "cicd.deployment_pool" */
  cicd_deployment_pool: Array<Cicd_Deployment_Pool>;
  /** fetch aggregated fields from the table: "cicd.deployment_pool" */
  cicd_deployment_pool_aggregate: Cicd_Deployment_Pool_Aggregate;
  /** fetch data from the table: "cicd.deployment_pool_member" */
  cicd_deployment_pool_member: Array<Cicd_Deployment_Pool_Member>;
  /** fetch aggregated fields from the table: "cicd.deployment_pool_member" */
  cicd_deployment_pool_member_aggregate: Cicd_Deployment_Pool_Member_Aggregate;
  /** fetch data from the table in a streaming manner: "cicd.deployment_pool_member" */
  cicd_deployment_pool_member_stream: Array<Cicd_Deployment_Pool_Member>;
  /** fetch data from the table in a streaming manner: "cicd.deployment_pool" */
  cicd_deployment_pool_stream: Array<Cicd_Deployment_Pool>;
  /** execute function "cicd.get_matching_pipeline_config" which returns "cicd.deployment_pipeline_config" */
  cicd_get_matching_pipeline_config: Array<Cicd_Deployment_Pipeline_Config>;
  /**
   * execute function "cicd.get_matching_pipeline_config" and query aggregates on
   * result of table type "cicd.deployment_pipeline_config"
   */
  cicd_get_matching_pipeline_config_aggregate: Cicd_Deployment_Pipeline_Config_Aggregate;
  /** fetch data from the table: "cloud" */
  cloud: Array<Cloud>;
  /** fetch aggregated fields from the table: "cloud" */
  cloud_aggregate: Cloud_Aggregate;
  /** fetch data from the table: "cloud" using primary key columns */
  cloud_by_pk?: Maybe<Cloud>;
  /** fetch data from the table: "cloud_metadata" */
  cloud_metadata: Array<Cloud_Metadata>;
  /** fetch aggregated fields from the table: "cloud_metadata" */
  cloud_metadata_aggregate: Cloud_Metadata_Aggregate;
  /** fetch data from the table: "cloud_metadata" using primary key columns */
  cloud_metadata_by_pk?: Maybe<Cloud_Metadata>;
  /** fetch data from the table in a streaming manner: "cloud_metadata" */
  cloud_metadata_stream: Array<Cloud_Metadata>;
  /** fetch data from the table: "cloud_regions_by_plan" */
  cloud_regions_by_plan: Array<Cloud_Regions_By_Plan>;
  /** fetch aggregated fields from the table: "cloud_regions_by_plan" */
  cloud_regions_by_plan_aggregate: Cloud_Regions_By_Plan_Aggregate;
  /** fetch data from the table in a streaming manner: "cloud_regions_by_plan" */
  cloud_regions_by_plan_stream: Array<Cloud_Regions_By_Plan>;
  /** fetch data from the table in a streaming manner: "cloud" */
  cloud_stream: Array<Cloud>;
  /** execute function "compute_project_agg_db_usage_user" which returns "project_db_usage_agg_user" */
  compute_project_agg_db_usage_user: Array<Project_Db_Usage_Agg_User>;
  /**
   * execute function "compute_project_agg_db_usage_user" and query aggregates on
   * result of table type "project_db_usage_agg_user"
   */
  compute_project_agg_db_usage_user_aggregate: Project_Db_Usage_Agg_User_Aggregate;
  /** execute function "compute_project_agg_usage" which returns "project_data_usage_agg" */
  compute_project_agg_usage: Array<Project_Data_Usage_Agg>;
  /** execute function "compute_project_agg_usage" and query aggregates on result of table type "project_data_usage_agg" */
  compute_project_agg_usage_aggregate: Project_Data_Usage_Agg_Aggregate;
  /** execute function "compute_project_agg_usage_prometheus" which returns "project_data_usage_agg" */
  compute_project_agg_usage_prometheus: Array<Project_Data_Usage_Agg>;
  /**
   * execute function "compute_project_agg_usage_prometheus" and query aggregates
   * on result of table type "project_data_usage_agg"
   */
  compute_project_agg_usage_prometheus_aggregate: Project_Data_Usage_Agg_Aggregate;
  /** execute function "compute_project_agg_usage_prometheus_user" which returns "project_data_usage_prometheus_agg_user" */
  compute_project_agg_usage_prometheus_user: Array<Project_Data_Usage_Prometheus_Agg_User>;
  /**
   * execute function "compute_project_agg_usage_prometheus_user" and query
   * aggregates on result of table type "project_data_usage_prometheus_agg_user"
   */
  compute_project_agg_usage_prometheus_user_aggregate: Project_Data_Usage_Prometheus_Agg_User_Aggregate;
  /** execute function "compute_project_agg_usage_user" which returns "project_data_usage_agg_user" */
  compute_project_agg_usage_user: Array<Project_Data_Usage_Agg_User>;
  /**
   * execute function "compute_project_agg_usage_user" and query aggregates on
   * result of table type "project_data_usage_agg_user"
   */
  compute_project_agg_usage_user_aggregate: Project_Data_Usage_Agg_User_Aggregate;
  /** fetch data from the table: "compute_unit_config" */
  compute_unit_config: Array<Compute_Unit_Config>;
  /** fetch aggregated fields from the table: "compute_unit_config" */
  compute_unit_config_aggregate: Compute_Unit_Config_Aggregate;
  /** fetch data from the table: "compute_unit_config" using primary key columns */
  compute_unit_config_by_pk?: Maybe<Compute_Unit_Config>;
  /** fetch data from the table in a streaming manner: "compute_unit_config" */
  compute_unit_config_stream: Array<Compute_Unit_Config>;
  /** fetch data from the table: "config" */
  config: Array<Config>;
  /** fetch aggregated fields from the table: "config" */
  config_aggregate: Config_Aggregate;
  /** fetch data from the table: "config" using primary key columns */
  config_by_pk?: Maybe<Config>;
  /** fetch data from the table: "config_status" */
  config_status: Array<Config_Status>;
  /** fetch aggregated fields from the table: "config_status" */
  config_status_aggregate: Config_Status_Aggregate;
  /** fetch data from the table: "config_status" using primary key columns */
  config_status_by_pk?: Maybe<Config_Status>;
  /** fetch data from the table in a streaming manner: "config_status" */
  config_status_stream: Array<Config_Status>;
  /** fetch data from the table in a streaming manner: "config" */
  config_stream: Array<Config>;
  /** fetch data from the table: "connector_config" */
  connector_config: Array<Connector_Config>;
  /** fetch aggregated fields from the table: "connector_config" */
  connector_config_aggregate: Connector_Config_Aggregate;
  /** fetch data from the table: "connector_config" using primary key columns */
  connector_config_by_pk?: Maybe<Connector_Config>;
  /** fetch data from the table in a streaming manner: "connector_config" */
  connector_config_stream: Array<Connector_Config>;
  /** fetch data from the table: "connector_deployment" */
  connector_deployment: Array<Connector_Connector_Deployment>;
  /** fetch aggregated fields from the table: "connector_deployment" */
  connector_deployment_aggregate: Connector_Connector_Deployment_Aggregate;
  /** fetch data from the table: "connector_deployment" using primary key columns */
  connector_deployment_by_pk?: Maybe<Connector_Connector_Deployment>;
  /** fetch data from the table in a streaming manner: "connector_deployment" */
  connector_deployment_stream: Array<Connector_Connector_Deployment>;
  /** fetch data from the table: "connector_deployments" */
  connector_deployments: Array<Connector_Deployments>;
  /** fetch aggregated fields from the table: "connector_deployments" */
  connector_deployments_aggregate: Connector_Deployments_Aggregate;
  /** fetch data from the table: "connector_deployments" using primary key columns */
  connector_deployments_by_pk?: Maybe<Connector_Deployments>;
  /** fetch data from the table in a streaming manner: "connector_deployments" */
  connector_deployments_stream: Array<Connector_Deployments>;
  /** fetch data from the table: "coupon" */
  coupon: Array<Coupon>;
  /** fetch aggregated fields from the table: "coupon" */
  coupon_aggregate: Coupon_Aggregate;
  /** fetch data from the table: "coupon" using primary key columns */
  coupon_by_pk?: Maybe<Coupon>;
  /** fetch data from the table: "coupon_duration" */
  coupon_duration: Array<Coupon_Duration>;
  /** fetch aggregated fields from the table: "coupon_duration" */
  coupon_duration_aggregate: Coupon_Duration_Aggregate;
  /** fetch data from the table: "coupon_duration" using primary key columns */
  coupon_duration_by_pk?: Maybe<Coupon_Duration>;
  /** fetch data from the table in a streaming manner: "coupon_duration" */
  coupon_duration_stream: Array<Coupon_Duration>;
  /** fetch data from the table in a streaming manner: "coupon" */
  coupon_stream: Array<Coupon>;
  /** fetch data from the table: "coupon_type" */
  coupon_type: Array<Coupon_Type>;
  /** fetch aggregated fields from the table: "coupon_type" */
  coupon_type_aggregate: Coupon_Type_Aggregate;
  /** fetch data from the table: "coupon_type" using primary key columns */
  coupon_type_by_pk?: Maybe<Coupon_Type>;
  /** fetch data from the table in a streaming manner: "coupon_type" */
  coupon_type_stream: Array<Coupon_Type>;
  /** fetch data from the table: "custom_domain" */
  custom_domain: Array<Custom_Domain>;
  /** fetch aggregated fields from the table: "custom_domain" */
  custom_domain_aggregate: Custom_Domain_Aggregate;
  /** fetch data from the table: "custom_domain" using primary key columns */
  custom_domain_by_pk?: Maybe<Custom_Domain>;
  /** fetch data from the table: "custom_domain_cloudflare" */
  custom_domain_cloudflare: Array<Custom_Domain_Cloudflare>;
  /** fetch aggregated fields from the table: "custom_domain_cloudflare" */
  custom_domain_cloudflare_aggregate: Custom_Domain_Cloudflare_Aggregate;
  /** fetch data from the table: "custom_domain_cloudflare" using primary key columns */
  custom_domain_cloudflare_by_pk?: Maybe<Custom_Domain_Cloudflare>;
  /** fetch data from the table: "custom_domain_cloudflare_dns" */
  custom_domain_cloudflare_dns: Array<Custom_Domain_Cloudflare_Dns>;
  /** fetch aggregated fields from the table: "custom_domain_cloudflare_dns" */
  custom_domain_cloudflare_dns_aggregate: Custom_Domain_Cloudflare_Dns_Aggregate;
  /** fetch data from the table: "custom_domain_cloudflare_dns" using primary key columns */
  custom_domain_cloudflare_dns_by_pk?: Maybe<Custom_Domain_Cloudflare_Dns>;
  /** fetch data from the table in a streaming manner: "custom_domain_cloudflare_dns" */
  custom_domain_cloudflare_dns_stream: Array<Custom_Domain_Cloudflare_Dns>;
  /** fetch data from the table in a streaming manner: "custom_domain_cloudflare" */
  custom_domain_cloudflare_stream: Array<Custom_Domain_Cloudflare>;
  /** fetch data from the table in a streaming manner: "custom_domain" */
  custom_domain_stream: Array<Custom_Domain>;
  /** fetch data from the table: "customer_usage" */
  customer_usage: Array<Customer_Usage>;
  /** fetch aggregated fields from the table: "customer_usage" */
  customer_usage_aggregate: Customer_Usage_Aggregate;
  /** fetch data from the table: "customer_usage" using primary key columns */
  customer_usage_by_pk?: Maybe<Customer_Usage>;
  /** fetch data from the table in a streaming manner: "customer_usage" */
  customer_usage_stream: Array<Customer_Usage>;
  /** fetch data from the table: "data_connector_type" */
  data_connector_type: Array<Data_Connector_Type>;
  /** fetch aggregated fields from the table: "data_connector_type" */
  data_connector_type_aggregate: Data_Connector_Type_Aggregate;
  /** fetch data from the table: "data_connector_type" using primary key columns */
  data_connector_type_by_pk?: Maybe<Data_Connector_Type>;
  /** fetch data from the table in a streaming manner: "data_connector_type" */
  data_connector_type_stream: Array<Data_Connector_Type>;
  /** fetch data from the table: "datadog_config" */
  datadog_config: Array<Datadog_Config>;
  /** fetch aggregated fields from the table: "datadog_config" */
  datadog_config_aggregate: Datadog_Config_Aggregate;
  /** fetch data from the table: "datadog_config" using primary key columns */
  datadog_config_by_pk?: Maybe<Datadog_Config>;
  /** fetch data from the table in a streaming manner: "datadog_config" */
  datadog_config_stream: Array<Datadog_Config>;
  /** fetch data from the table: "db_latency" */
  db_latency: Array<Db_Latency>;
  /** fetch aggregated fields from the table: "db_latency" */
  db_latency_aggregate: Db_Latency_Aggregate;
  /** fetch data from the table: "db_latency" using primary key columns */
  db_latency_by_pk?: Maybe<Db_Latency>;
  /** fetch data from the table in a streaming manner: "db_latency" */
  db_latency_stream: Array<Db_Latency>;
  /** fetch data from the table: "ddn.build" */
  ddn_build: Array<Ddn_Build>;
  /** fetch aggregated fields from the table: "ddn.build" */
  ddn_build_aggregate: Ddn_Build_Aggregate;
  /** fetch data from the table: "ddn.build" using primary key columns */
  ddn_build_by_pk?: Maybe<Ddn_Build>;
  /** fetch data from the table in a streaming manner: "ddn.build" */
  ddn_build_stream: Array<Ddn_Build>;
  /** fetch data from the table: "ddn.build_sync_status" */
  ddn_build_sync_status: Array<Ddn_Build_Sync_Status>;
  /** fetch aggregated fields from the table: "ddn.build_sync_status" */
  ddn_build_sync_status_aggregate: Ddn_Build_Sync_Status_Aggregate;
  /** fetch data from the table: "ddn.build_sync_status" using primary key columns */
  ddn_build_sync_status_by_pk?: Maybe<Ddn_Build_Sync_Status>;
  /** fetch data from the table in a streaming manner: "ddn.build_sync_status" */
  ddn_build_sync_status_stream: Array<Ddn_Build_Sync_Status>;
  /** fetch data from the table: "ddn.build_sync_worker" */
  ddn_build_sync_worker: Array<Ddn_Build_Sync_Worker>;
  /** fetch aggregated fields from the table: "ddn.build_sync_worker" */
  ddn_build_sync_worker_aggregate: Ddn_Build_Sync_Worker_Aggregate;
  /** fetch data from the table: "ddn.build_sync_worker" using primary key columns */
  ddn_build_sync_worker_by_pk?: Maybe<Ddn_Build_Sync_Worker>;
  /** fetch data from the table in a streaming manner: "ddn.build_sync_worker" */
  ddn_build_sync_worker_stream: Array<Ddn_Build_Sync_Worker>;
  /** fetch data from the table: "ddn.environment" */
  ddn_environment: Array<Ddn_Environment>;
  /** fetch aggregated fields from the table: "ddn.environment" */
  ddn_environment_aggregate: Ddn_Environment_Aggregate;
  /** fetch data from the table: "ddn.environment" using primary key columns */
  ddn_environment_by_pk?: Maybe<Ddn_Environment>;
  /** fetch data from the table in a streaming manner: "ddn.environment" */
  ddn_environment_stream: Array<Ddn_Environment>;
  /** fetch data from the table: "ddn.project_entitlement_access" */
  ddn_project_entitlement_access: Array<Ddn_Project_Entitlement_Access>;
  /** fetch aggregated fields from the table: "ddn.project_entitlement_access" */
  ddn_project_entitlement_access_aggregate: Ddn_Project_Entitlement_Access_Aggregate;
  /** fetch data from the table: "ddn.project_entitlement_access" using primary key columns */
  ddn_project_entitlement_access_by_pk?: Maybe<Ddn_Project_Entitlement_Access>;
  /** fetch data from the table in a streaming manner: "ddn.project_entitlement_access" */
  ddn_project_entitlement_access_stream: Array<Ddn_Project_Entitlement_Access>;
  /** fetch data from the table: "ddn.project_entitlement_catalogue" */
  ddn_project_entitlement_catalogue: Array<Ddn_Project_Entitlement_Catalogue>;
  /** fetch aggregated fields from the table: "ddn.project_entitlement_catalogue" */
  ddn_project_entitlement_catalogue_aggregate: Ddn_Project_Entitlement_Catalogue_Aggregate;
  /** fetch data from the table: "ddn.project_entitlement_catalogue" using primary key columns */
  ddn_project_entitlement_catalogue_by_pk?: Maybe<Ddn_Project_Entitlement_Catalogue>;
  /** fetch data from the table in a streaming manner: "ddn.project_entitlement_catalogue" */
  ddn_project_entitlement_catalogue_stream: Array<Ddn_Project_Entitlement_Catalogue>;
  /** fetch data from the table: "ddn.project_entitlement_types" */
  ddn_project_entitlement_types: Array<Ddn_Project_Entitlement_Types>;
  /** fetch aggregated fields from the table: "ddn.project_entitlement_types" */
  ddn_project_entitlement_types_aggregate: Ddn_Project_Entitlement_Types_Aggregate;
  /** fetch data from the table: "ddn.project_entitlement_types" using primary key columns */
  ddn_project_entitlement_types_by_pk?: Maybe<Ddn_Project_Entitlement_Types>;
  /** fetch data from the table in a streaming manner: "ddn.project_entitlement_types" */
  ddn_project_entitlement_types_stream: Array<Ddn_Project_Entitlement_Types>;
  /** fetch data from the table: "ddn.projects" */
  ddn_projects: Array<Ddn_Projects>;
  /** fetch aggregated fields from the table: "ddn.projects" */
  ddn_projects_aggregate: Ddn_Projects_Aggregate;
  /** fetch data from the table: "ddn.projects" using primary key columns */
  ddn_projects_by_pk?: Maybe<Ddn_Projects>;
  /** fetch data from the table in a streaming manner: "ddn.projects" */
  ddn_projects_stream: Array<Ddn_Projects>;
  /** fetch data from the table: "ddn.tunnel" */
  ddn_tunnel: Array<Ddn_Tunnel>;
  /** fetch aggregated fields from the table: "ddn.tunnel" */
  ddn_tunnel_aggregate: Ddn_Tunnel_Aggregate;
  /** fetch data from the table: "ddn.tunnel" using primary key columns */
  ddn_tunnel_by_pk?: Maybe<Ddn_Tunnel>;
  /** fetch data from the table: "ddn.tunnel_cluster" */
  ddn_tunnel_cluster: Array<Ddn_Tunnel_Cluster>;
  /** fetch aggregated fields from the table: "ddn.tunnel_cluster" */
  ddn_tunnel_cluster_aggregate: Ddn_Tunnel_Cluster_Aggregate;
  /** fetch data from the table: "ddn.tunnel_cluster" using primary key columns */
  ddn_tunnel_cluster_by_pk?: Maybe<Ddn_Tunnel_Cluster>;
  /** fetch data from the table in a streaming manner: "ddn.tunnel_cluster" */
  ddn_tunnel_cluster_stream: Array<Ddn_Tunnel_Cluster>;
  /** fetch data from the table in a streaming manner: "ddn.tunnel" */
  ddn_tunnel_stream: Array<Ddn_Tunnel>;
  /** fetch data from the table: "dedicated_cloud_bills" */
  dedicated_cloud_bills: Array<Dedicated_Cloud_Bills>;
  /** fetch aggregated fields from the table: "dedicated_cloud_bills" */
  dedicated_cloud_bills_aggregate: Dedicated_Cloud_Bills_Aggregate;
  /** fetch data from the table: "dedicated_cloud_bills" using primary key columns */
  dedicated_cloud_bills_by_pk?: Maybe<Dedicated_Cloud_Bills>;
  /** fetch data from the table: "dedicated_cloud_bills_details" */
  dedicated_cloud_bills_details: Array<Dedicated_Cloud_Bills_Details>;
  /** fetch aggregated fields from the table: "dedicated_cloud_bills_details" */
  dedicated_cloud_bills_details_aggregate: Dedicated_Cloud_Bills_Details_Aggregate;
  /** fetch data from the table: "dedicated_cloud_bills_details" using primary key columns */
  dedicated_cloud_bills_details_by_pk?: Maybe<Dedicated_Cloud_Bills_Details>;
  /** fetch data from the table in a streaming manner: "dedicated_cloud_bills_details" */
  dedicated_cloud_bills_details_stream: Array<Dedicated_Cloud_Bills_Details>;
  /** fetch data from the table in a streaming manner: "dedicated_cloud_bills" */
  dedicated_cloud_bills_stream: Array<Dedicated_Cloud_Bills>;
  /** fetch data from the table: "dedicated_cloud_commitments" */
  dedicated_cloud_commitments: Array<Dedicated_Cloud_Commitments>;
  /** fetch aggregated fields from the table: "dedicated_cloud_commitments" */
  dedicated_cloud_commitments_aggregate: Dedicated_Cloud_Commitments_Aggregate;
  /** fetch data from the table: "dedicated_cloud_commitments" using primary key columns */
  dedicated_cloud_commitments_by_pk?: Maybe<Dedicated_Cloud_Commitments>;
  /** fetch data from the table in a streaming manner: "dedicated_cloud_commitments" */
  dedicated_cloud_commitments_stream: Array<Dedicated_Cloud_Commitments>;
  /** fetch data from the table: "dedicated_vpc" */
  dedicated_vpc: Array<Dedicated_Vpc>;
  /** fetch aggregated fields from the table: "dedicated_vpc" */
  dedicated_vpc_aggregate: Dedicated_Vpc_Aggregate;
  /** fetch data from the table: "dedicated_vpc" using primary key columns */
  dedicated_vpc_by_pk?: Maybe<Dedicated_Vpc>;
  /** fetch data from the table in a streaming manner: "dedicated_vpc" */
  dedicated_vpc_stream: Array<Dedicated_Vpc>;
  /** fetch data from the table: "delete_user" */
  delete_user: Array<Delete_User>;
  /** fetch aggregated fields from the table: "delete_user" */
  delete_user_aggregate: Delete_User_Aggregate;
  /** fetch data from the table: "delete_user" using primary key columns */
  delete_user_by_pk?: Maybe<Delete_User>;
  /** fetch data from the table: "delete_user_status" */
  delete_user_status: Array<Delete_User_Status>;
  /** fetch aggregated fields from the table: "delete_user_status" */
  delete_user_status_aggregate: Delete_User_Status_Aggregate;
  /** fetch data from the table: "delete_user_status" using primary key columns */
  delete_user_status_by_pk?: Maybe<Delete_User_Status>;
  /** fetch data from the table in a streaming manner: "delete_user_status" */
  delete_user_status_stream: Array<Delete_User_Status>;
  /** fetch data from the table in a streaming manner: "delete_user" */
  delete_user_stream: Array<Delete_User>;
  /** fetch data from the table: "delete_user_tasks" */
  delete_user_tasks: Array<Delete_User_Tasks>;
  /** fetch aggregated fields from the table: "delete_user_tasks" */
  delete_user_tasks_aggregate: Delete_User_Tasks_Aggregate;
  /** fetch data from the table: "delete_user_tasks" using primary key columns */
  delete_user_tasks_by_pk?: Maybe<Delete_User_Tasks>;
  /** fetch data from the table in a streaming manner: "delete_user_tasks" */
  delete_user_tasks_stream: Array<Delete_User_Tasks>;
  /** fetch data from the table: "email_log" */
  email_log: Array<Email_Log>;
  /** fetch aggregated fields from the table: "email_log" */
  email_log_aggregate: Email_Log_Aggregate;
  /** fetch data from the table: "email_log" using primary key columns */
  email_log_by_pk?: Maybe<Email_Log>;
  /** fetch data from the table in a streaming manner: "email_log" */
  email_log_stream: Array<Email_Log>;
  /** fetch data from the table: "enterprise_users" */
  enterprise_users: Array<Enterprise_Users>;
  /** fetch aggregated fields from the table: "enterprise_users" */
  enterprise_users_aggregate: Enterprise_Users_Aggregate;
  /** fetch data from the table: "enterprise_users" using primary key columns */
  enterprise_users_by_pk?: Maybe<Enterprise_Users>;
  /** fetch data from the table in a streaming manner: "enterprise_users" */
  enterprise_users_stream: Array<Enterprise_Users>;
  /** fetch data from the table: "experiments" */
  experiments: Array<Experiments>;
  /** fetch aggregated fields from the table: "experiments" */
  experiments_aggregate: Experiments_Aggregate;
  /** fetch data from the table: "experiments" using primary key columns */
  experiments_by_pk?: Maybe<Experiments>;
  /** fetch data from the table: "experiments_cohort" */
  experiments_cohort: Array<Experiments_Cohort>;
  /** fetch aggregated fields from the table: "experiments_cohort" */
  experiments_cohort_aggregate: Experiments_Cohort_Aggregate;
  /** fetch data from the table: "experiments_cohort" using primary key columns */
  experiments_cohort_by_pk?: Maybe<Experiments_Cohort>;
  /** fetch data from the table in a streaming manner: "experiments_cohort" */
  experiments_cohort_stream: Array<Experiments_Cohort>;
  /** fetch data from the table: "experiments_config" */
  experiments_config: Array<Experiments_Config>;
  /** fetch aggregated fields from the table: "experiments_config" */
  experiments_config_aggregate: Experiments_Config_Aggregate;
  /** fetch data from the table: "experiments_config" using primary key columns */
  experiments_config_by_pk?: Maybe<Experiments_Config>;
  /** fetch data from the table in a streaming manner: "experiments_config" */
  experiments_config_stream: Array<Experiments_Config>;
  /** fetch data from the table in a streaming manner: "experiments" */
  experiments_stream: Array<Experiments>;
  /** fetch data from the table: "feature" */
  feature: Array<Feature>;
  /** fetch data from the table: "feature_access" */
  feature_access: Array<Feature_Access>;
  /** fetch aggregated fields from the table: "feature_access" */
  feature_access_aggregate: Feature_Access_Aggregate;
  /** fetch data from the table: "feature_access" using primary key columns */
  feature_access_by_pk?: Maybe<Feature_Access>;
  /** fetch data from the table in a streaming manner: "feature_access" */
  feature_access_stream: Array<Feature_Access>;
  /** fetch aggregated fields from the table: "feature" */
  feature_aggregate: Feature_Aggregate;
  /** fetch data from the table: "feature" using primary key columns */
  feature_by_pk?: Maybe<Feature>;
  /** fetch data from the table: "feature_config" */
  feature_config: Array<Feature_Config>;
  /** fetch aggregated fields from the table: "feature_config" */
  feature_config_aggregate: Feature_Config_Aggregate;
  /** fetch data from the table: "feature_config" using primary key columns */
  feature_config_by_pk?: Maybe<Feature_Config>;
  /** fetch data from the table in a streaming manner: "feature_config" */
  feature_config_stream: Array<Feature_Config>;
  /** fetch data from the table in a streaming manner: "feature" */
  feature_stream: Array<Feature>;
  /** fetch data from the table: "gateway_ami" */
  gateway_ami: Array<Gateway_Ami>;
  /** fetch aggregated fields from the table: "gateway_ami" */
  gateway_ami_aggregate: Gateway_Ami_Aggregate;
  /** fetch data from the table: "gateway_ami" using primary key columns */
  gateway_ami_by_pk?: Maybe<Gateway_Ami>;
  /** fetch data from the table in a streaming manner: "gateway_ami" */
  gateway_ami_stream: Array<Gateway_Ami>;
  /** fetch data from the table: "gateway_cluster" */
  gateway_cluster: Array<Gateway_Cluster>;
  /** fetch aggregated fields from the table: "gateway_cluster" */
  gateway_cluster_aggregate: Gateway_Cluster_Aggregate;
  /** fetch data from the table: "gateway_cluster" using primary key columns */
  gateway_cluster_by_pk?: Maybe<Gateway_Cluster>;
  /** fetch data from the table in a streaming manner: "gateway_cluster" */
  gateway_cluster_stream: Array<Gateway_Cluster>;
  /** fetch data from the table: "gateway_cluster_tenants" */
  gateway_cluster_tenants: Array<Gateway_Cluster_Tenants>;
  /** fetch aggregated fields from the table: "gateway_cluster_tenants" */
  gateway_cluster_tenants_aggregate: Gateway_Cluster_Tenants_Aggregate;
  /** fetch data from the table in a streaming manner: "gateway_cluster_tenants" */
  gateway_cluster_tenants_stream: Array<Gateway_Cluster_Tenants>;
  /** fetch data from the table: "gateway_worker" */
  gateway_worker: Array<Gateway_Worker>;
  /** fetch aggregated fields from the table: "gateway_worker" */
  gateway_worker_aggregate: Gateway_Worker_Aggregate;
  /** fetch data from the table: "gateway_worker" using primary key columns */
  gateway_worker_by_pk?: Maybe<Gateway_Worker>;
  /** fetch data from the table in a streaming manner: "gateway_worker" */
  gateway_worker_stream: Array<Gateway_Worker>;
  /** execute function "get_aggregated_cost_for_project_on_shared_plan" which returns "project_total_db_usage_agg" */
  get_aggregated_cost_for_project_on_shared_plan?: Maybe<Project_Total_Db_Usage_Agg>;
  /**
   * execute function "get_aggregated_cost_for_project_on_shared_plan" and query
   * aggregates on result of table type "project_total_db_usage_agg"
   */
  get_aggregated_cost_for_project_on_shared_plan_aggregate: Project_Total_Db_Usage_Agg_Aggregate;
  /** fetch data from the table: "github_email_type" */
  github_email_type: Array<Github_Email_Type>;
  /** fetch aggregated fields from the table: "github_email_type" */
  github_email_type_aggregate: Github_Email_Type_Aggregate;
  /** fetch data from the table: "github_email_type" using primary key columns */
  github_email_type_by_pk?: Maybe<Github_Email_Type>;
  /** fetch data from the table in a streaming manner: "github_email_type" */
  github_email_type_stream: Array<Github_Email_Type>;
  /** fetch data from the table: "github_integration_config" */
  github_integration_config: Array<Github_Integration_Config>;
  /** fetch aggregated fields from the table: "github_integration_config" */
  github_integration_config_aggregate: Github_Integration_Config_Aggregate;
  /** fetch data from the table: "github_integration_config" using primary key columns */
  github_integration_config_by_pk?: Maybe<Github_Integration_Config>;
  /** fetch data from the table in a streaming manner: "github_integration_config" */
  github_integration_config_stream: Array<Github_Integration_Config>;
  /** fetch data from the table: "github_integration_mode" */
  github_integration_mode: Array<Github_Integration_Mode>;
  /** fetch aggregated fields from the table: "github_integration_mode" */
  github_integration_mode_aggregate: Github_Integration_Mode_Aggregate;
  /** fetch data from the table: "github_integration_mode" using primary key columns */
  github_integration_mode_by_pk?: Maybe<Github_Integration_Mode>;
  /** fetch data from the table in a streaming manner: "github_integration_mode" */
  github_integration_mode_stream: Array<Github_Integration_Mode>;
  /** fetch data from the table: "github_push_event" */
  github_push_event: Array<Github_Push_Event>;
  /** fetch aggregated fields from the table: "github_push_event" */
  github_push_event_aggregate: Github_Push_Event_Aggregate;
  /** fetch data from the table: "github_push_event" using primary key columns */
  github_push_event_by_pk?: Maybe<Github_Push_Event>;
  /** fetch data from the table: "github_push_event_job" */
  github_push_event_job: Array<Github_Push_Event_Job>;
  /** fetch aggregated fields from the table: "github_push_event_job" */
  github_push_event_job_aggregate: Github_Push_Event_Job_Aggregate;
  /** fetch data from the table: "github_push_event_job" using primary key columns */
  github_push_event_job_by_pk?: Maybe<Github_Push_Event_Job>;
  /** fetch data from the table in a streaming manner: "github_push_event_job" */
  github_push_event_job_stream: Array<Github_Push_Event_Job>;
  /** fetch data from the table in a streaming manner: "github_push_event" */
  github_push_event_stream: Array<Github_Push_Event>;
  /** fetch data from the table: "hasura_ami" */
  hasura_ami: Array<Hasura_Ami>;
  /** fetch aggregated fields from the table: "hasura_ami" */
  hasura_ami_aggregate: Hasura_Ami_Aggregate;
  /** fetch data from the table: "hasura_ami" using primary key columns */
  hasura_ami_by_pk?: Maybe<Hasura_Ami>;
  /** fetch data from the table in a streaming manner: "hasura_ami" */
  hasura_ami_stream: Array<Hasura_Ami>;
  /** fetch data from the table: "hasura_cluster" */
  hasura_cluster: Array<Hasura_Cluster>;
  /** fetch aggregated fields from the table: "hasura_cluster" */
  hasura_cluster_aggregate: Hasura_Cluster_Aggregate;
  /** fetch data from the table: "hasura_cluster" using primary key columns */
  hasura_cluster_by_pk?: Maybe<Hasura_Cluster>;
  /** fetch data from the table in a streaming manner: "hasura_cluster" */
  hasura_cluster_stream: Array<Hasura_Cluster>;
  /** fetch data from the table: "hasura_worker" */
  hasura_worker: Array<Hasura_Worker>;
  /** fetch aggregated fields from the table: "hasura_worker" */
  hasura_worker_aggregate: Hasura_Worker_Aggregate;
  /** fetch data from the table: "hasura_worker" using primary key columns */
  hasura_worker_by_pk?: Maybe<Hasura_Worker>;
  /** fetch data from the table in a streaming manner: "hasura_worker" */
  hasura_worker_stream: Array<Hasura_Worker>;
  /** fetch data from the table: "hasura_worker_tenants" */
  hasura_worker_tenants: Array<Hasura_Worker_Tenants>;
  /** fetch aggregated fields from the table: "hasura_worker_tenants" */
  hasura_worker_tenants_aggregate: Hasura_Worker_Tenants_Aggregate;
  /** fetch data from the table in a streaming manner: "hasura_worker_tenants" */
  hasura_worker_tenants_stream: Array<Hasura_Worker_Tenants>;
  /** An array relationship */
  heroku_integrations: Array<Heroku_Integrations>;
  /** An aggregate relationship */
  heroku_integrations_aggregate: Heroku_Integrations_Aggregate;
  /** fetch data from the table: "heroku_integrations" using primary key columns */
  heroku_integrations_by_pk?: Maybe<Heroku_Integrations>;
  /** fetch data from the table in a streaming manner: "heroku_integrations" */
  heroku_integrations_stream: Array<Heroku_Integrations>;
  /** fetch data from the table: "inactive_project_exclusions" */
  inactive_project_exclusions: Array<Inactive_Project_Exclusions>;
  /** fetch aggregated fields from the table: "inactive_project_exclusions" */
  inactive_project_exclusions_aggregate: Inactive_Project_Exclusions_Aggregate;
  /** fetch data from the table: "inactive_project_exclusions" using primary key columns */
  inactive_project_exclusions_by_pk?: Maybe<Inactive_Project_Exclusions>;
  /** fetch data from the table in a streaming manner: "inactive_project_exclusions" */
  inactive_project_exclusions_stream: Array<Inactive_Project_Exclusions>;
  /** fetch data from the table: "inactive_project_notifications" */
  inactive_project_notifications: Array<Inactive_Project_Notifications>;
  /** fetch aggregated fields from the table: "inactive_project_notifications" */
  inactive_project_notifications_aggregate: Inactive_Project_Notifications_Aggregate;
  /** fetch data from the table: "inactive_project_notifications" using primary key columns */
  inactive_project_notifications_by_pk?: Maybe<Inactive_Project_Notifications>;
  /** fetch data from the table in a streaming manner: "inactive_project_notifications" */
  inactive_project_notifications_stream: Array<Inactive_Project_Notifications>;
  /** fetch data from the table: "inactive_project_suspension_config" */
  inactive_project_suspension_config: Array<Inactive_Project_Suspension_Config>;
  /** fetch aggregated fields from the table: "inactive_project_suspension_config" */
  inactive_project_suspension_config_aggregate: Inactive_Project_Suspension_Config_Aggregate;
  /** fetch data from the table in a streaming manner: "inactive_project_suspension_config" */
  inactive_project_suspension_config_stream: Array<Inactive_Project_Suspension_Config>;
  /** fetch data from the table: "inactive_projects" */
  inactive_projects: Array<Inactive_Projects>;
  /** fetch aggregated fields from the table: "inactive_projects" */
  inactive_projects_aggregate: Inactive_Projects_Aggregate;
  /** fetch data from the table in a streaming manner: "inactive_projects" */
  inactive_projects_stream: Array<Inactive_Projects>;
  /** fetch data from the table: "infra_status" */
  infra_status: Array<Infra_Status>;
  /** fetch aggregated fields from the table: "infra_status" */
  infra_status_aggregate: Infra_Status_Aggregate;
  /** fetch data from the table: "infra_status" using primary key columns */
  infra_status_by_pk?: Maybe<Infra_Status>;
  /** fetch data from the table in a streaming manner: "infra_status" */
  infra_status_stream: Array<Infra_Status>;
  /** fetch data from the table: "invoice" */
  invoice: Array<Invoice>;
  /** fetch aggregated fields from the table: "invoice" */
  invoice_aggregate: Invoice_Aggregate;
  /** fetch data from the table: "invoice" using primary key columns */
  invoice_by_pk?: Maybe<Invoice>;
  /** fetch data from the table: "invoice_coupon_discount" */
  invoice_coupon_discount: Array<Invoice_Coupon_Discount>;
  /** fetch aggregated fields from the table: "invoice_coupon_discount" */
  invoice_coupon_discount_aggregate: Invoice_Coupon_Discount_Aggregate;
  /** fetch data from the table: "invoice_coupon_discount" using primary key columns */
  invoice_coupon_discount_by_pk?: Maybe<Invoice_Coupon_Discount>;
  /** fetch data from the table in a streaming manner: "invoice_coupon_discount" */
  invoice_coupon_discount_stream: Array<Invoice_Coupon_Discount>;
  /** fetch data from the table: "invoice_item" */
  invoice_item: Array<Invoice_Item>;
  /** fetch aggregated fields from the table: "invoice_item" */
  invoice_item_aggregate: Invoice_Item_Aggregate;
  /** fetch data from the table: "invoice_item" using primary key columns */
  invoice_item_by_pk?: Maybe<Invoice_Item>;
  /** fetch data from the table in a streaming manner: "invoice_item" */
  invoice_item_stream: Array<Invoice_Item>;
  /** fetch data from the table in a streaming manner: "invoice" */
  invoice_stream: Array<Invoice>;
  /** An array relationship */
  jobs: Array<Jobs>;
  /** An aggregate relationship */
  jobs_aggregate: Jobs_Aggregate;
  /** fetch data from the table: "jobs" using primary key columns */
  jobs_by_pk?: Maybe<Jobs>;
  /** fetch data from the table in a streaming manner: "jobs" */
  jobs_stream: Array<Jobs>;
  /** fetch data from the table: "label" */
  label: Array<Label>;
  /** fetch aggregated fields from the table: "label" */
  label_aggregate: Label_Aggregate;
  /** fetch data from the table: "label" using primary key columns */
  label_by_pk?: Maybe<Label>;
  /** fetch data from the table in a streaming manner: "label" */
  label_stream: Array<Label>;
  /** fetch data from the table: "letsencrypt_status" */
  letsencrypt_status: Array<Letsencrypt_Status>;
  /** fetch aggregated fields from the table: "letsencrypt_status" */
  letsencrypt_status_aggregate: Letsencrypt_Status_Aggregate;
  /** fetch data from the table: "letsencrypt_status" using primary key columns */
  letsencrypt_status_by_pk?: Maybe<Letsencrypt_Status>;
  /** fetch data from the table in a streaming manner: "letsencrypt_status" */
  letsencrypt_status_stream: Array<Letsencrypt_Status>;
  /** fetch data from the table: "license_activity" */
  license_activity: Array<License_Activity>;
  /** fetch aggregated fields from the table: "license_activity" */
  license_activity_aggregate: License_Activity_Aggregate;
  /** fetch data from the table: "license_activity" using primary key columns */
  license_activity_by_pk?: Maybe<License_Activity>;
  /** fetch data from the table in a streaming manner: "license_activity" */
  license_activity_stream: Array<License_Activity>;
  /** fetch data from the table: "license_instance" */
  license_instance: Array<License_Instance>;
  /** fetch aggregated fields from the table: "license_instance" */
  license_instance_aggregate: License_Instance_Aggregate;
  /** fetch data from the table: "license_instance" using primary key columns */
  license_instance_by_pk?: Maybe<License_Instance>;
  /** fetch data from the table in a streaming manner: "license_instance" */
  license_instance_stream: Array<License_Instance>;
  /** fetch data from the table: "license_type" */
  license_type: Array<License_Type>;
  /** fetch aggregated fields from the table: "license_type" */
  license_type_aggregate: License_Type_Aggregate;
  /** fetch data from the table: "license_type" using primary key columns */
  license_type_by_pk?: Maybe<License_Type>;
  /** fetch data from the table in a streaming manner: "license_type" */
  license_type_stream: Array<License_Type>;
  /** fetch data from the table: "licenses" */
  licenses: Array<Licenses>;
  /** fetch aggregated fields from the table: "licenses" */
  licenses_aggregate: Licenses_Aggregate;
  /** fetch data from the table: "licenses" using primary key columns */
  licenses_by_pk?: Maybe<Licenses>;
  /** fetch data from the table in a streaming manner: "licenses" */
  licenses_stream: Array<Licenses>;
  /** An array relationship */
  lux_proxy: Array<Lux_Proxy>;
  /** An aggregate relationship */
  lux_proxy_aggregate: Lux_Proxy_Aggregate;
  /** fetch data from the table: "lux_proxy_ami" */
  lux_proxy_ami: Array<Lux_Proxy_Ami>;
  /** fetch aggregated fields from the table: "lux_proxy_ami" */
  lux_proxy_ami_aggregate: Lux_Proxy_Ami_Aggregate;
  /** fetch data from the table: "lux_proxy_ami" using primary key columns */
  lux_proxy_ami_by_pk?: Maybe<Lux_Proxy_Ami>;
  /** fetch data from the table in a streaming manner: "lux_proxy_ami" */
  lux_proxy_ami_stream: Array<Lux_Proxy_Ami>;
  /** fetch data from the table: "lux_proxy" using primary key columns */
  lux_proxy_by_pk?: Maybe<Lux_Proxy>;
  /** fetch data from the table in a streaming manner: "lux_proxy" */
  lux_proxy_stream: Array<Lux_Proxy>;
  /** fetch data from the table: "neon_db_integration" */
  neon_db_integration: Array<Neon_Db_Integration>;
  /** fetch aggregated fields from the table: "neon_db_integration" */
  neon_db_integration_aggregate: Neon_Db_Integration_Aggregate;
  /** fetch data from the table: "neon_db_integration" using primary key columns */
  neon_db_integration_by_pk?: Maybe<Neon_Db_Integration>;
  /** fetch data from the table in a streaming manner: "neon_db_integration" */
  neon_db_integration_stream: Array<Neon_Db_Integration>;
  /** fetch data from the table: "newrelic_config" */
  newrelic_config: Array<Newrelic_Config>;
  /** fetch aggregated fields from the table: "newrelic_config" */
  newrelic_config_aggregate: Newrelic_Config_Aggregate;
  /** fetch data from the table: "newrelic_config" using primary key columns */
  newrelic_config_by_pk?: Maybe<Newrelic_Config>;
  /** fetch data from the table in a streaming manner: "newrelic_config" */
  newrelic_config_stream: Array<Newrelic_Config>;
  /** fetch data from the table: "node_pool_type" */
  node_pool_type: Array<Node_Pool_Type>;
  /** fetch aggregated fields from the table: "node_pool_type" */
  node_pool_type_aggregate: Node_Pool_Type_Aggregate;
  /** fetch data from the table: "node_pool_type" using primary key columns */
  node_pool_type_by_pk?: Maybe<Node_Pool_Type>;
  /** fetch data from the table in a streaming manner: "node_pool_type" */
  node_pool_type_stream: Array<Node_Pool_Type>;
  /** fetch data from the table: "node_pools" */
  node_pools: Array<Node_Pools>;
  /** fetch aggregated fields from the table: "node_pools" */
  node_pools_aggregate: Node_Pools_Aggregate;
  /** fetch data from the table: "node_pools" using primary key columns */
  node_pools_by_pk?: Maybe<Node_Pools>;
  /** fetch data from the table in a streaming manner: "node_pools" */
  node_pools_stream: Array<Node_Pools>;
  /** fetch data from the table: "notification" */
  notification: Array<Notification>;
  /** fetch aggregated fields from the table: "notification" */
  notification_aggregate: Notification_Aggregate;
  /** fetch data from the table: "notification" using primary key columns */
  notification_by_pk?: Maybe<Notification>;
  /** fetch data from the table in a streaming manner: "notification" */
  notification_stream: Array<Notification>;
  /** fetch data from the table: "notification_type" */
  notification_type: Array<Notification_Type>;
  /** fetch aggregated fields from the table: "notification_type" */
  notification_type_aggregate: Notification_Type_Aggregate;
  /** fetch data from the table: "notification_type" using primary key columns */
  notification_type_by_pk?: Maybe<Notification_Type>;
  /** fetch data from the table in a streaming manner: "notification_type" */
  notification_type_stream: Array<Notification_Type>;
  /** fetch data from the table: "onboarding_sample_db_cohort" */
  onboarding_sample_db_cohort: Array<Onboarding_Sample_Db_Cohort>;
  /** fetch aggregated fields from the table: "onboarding_sample_db_cohort" */
  onboarding_sample_db_cohort_aggregate: Onboarding_Sample_Db_Cohort_Aggregate;
  /** fetch data from the table: "onboarding_sample_db_cohort" using primary key columns */
  onboarding_sample_db_cohort_by_pk?: Maybe<Onboarding_Sample_Db_Cohort>;
  /** fetch data from the table in a streaming manner: "onboarding_sample_db_cohort" */
  onboarding_sample_db_cohort_stream: Array<Onboarding_Sample_Db_Cohort>;
  /** fetch data from the table: "onboarding_sample_db_config" */
  onboarding_sample_db_config: Array<Onboarding_Sample_Db_Config>;
  /** fetch aggregated fields from the table: "onboarding_sample_db_config" */
  onboarding_sample_db_config_aggregate: Onboarding_Sample_Db_Config_Aggregate;
  /** fetch data from the table: "onboarding_sample_db_config" using primary key columns */
  onboarding_sample_db_config_by_pk?: Maybe<Onboarding_Sample_Db_Config>;
  /** fetch data from the table in a streaming manner: "onboarding_sample_db_config" */
  onboarding_sample_db_config_stream: Array<Onboarding_Sample_Db_Config>;
  /** fetch data from the table: "one_click_deployment" */
  one_click_deployment: Array<One_Click_Deployment>;
  /** fetch aggregated fields from the table: "one_click_deployment" */
  one_click_deployment_aggregate: One_Click_Deployment_Aggregate;
  /** fetch data from the table: "one_click_deployment" using primary key columns */
  one_click_deployment_by_pk?: Maybe<One_Click_Deployment>;
  /** fetch data from the table: "one_click_deployment_sample_apps" */
  one_click_deployment_sample_apps: Array<One_Click_Deployment_Sample_Apps>;
  /** fetch aggregated fields from the table: "one_click_deployment_sample_apps" */
  one_click_deployment_sample_apps_aggregate: One_Click_Deployment_Sample_Apps_Aggregate;
  /** fetch data from the table: "one_click_deployment_sample_apps" using primary key columns */
  one_click_deployment_sample_apps_by_pk?: Maybe<One_Click_Deployment_Sample_Apps>;
  /** fetch data from the table in a streaming manner: "one_click_deployment_sample_apps" */
  one_click_deployment_sample_apps_stream: Array<One_Click_Deployment_Sample_Apps>;
  /** fetch data from the table: "one_click_deployment_state_log" */
  one_click_deployment_state_log: Array<One_Click_Deployment_State_Log>;
  /** fetch aggregated fields from the table: "one_click_deployment_state_log" */
  one_click_deployment_state_log_aggregate: One_Click_Deployment_State_Log_Aggregate;
  /** fetch data from the table: "one_click_deployment_state_log" using primary key columns */
  one_click_deployment_state_log_by_pk?: Maybe<One_Click_Deployment_State_Log>;
  /** fetch data from the table in a streaming manner: "one_click_deployment_state_log" */
  one_click_deployment_state_log_stream: Array<One_Click_Deployment_State_Log>;
  /** fetch data from the table: "one_click_deployment_states" */
  one_click_deployment_states: Array<One_Click_Deployment_States>;
  /** fetch aggregated fields from the table: "one_click_deployment_states" */
  one_click_deployment_states_aggregate: One_Click_Deployment_States_Aggregate;
  /** fetch data from the table: "one_click_deployment_states" using primary key columns */
  one_click_deployment_states_by_pk?: Maybe<One_Click_Deployment_States>;
  /** fetch data from the table in a streaming manner: "one_click_deployment_states" */
  one_click_deployment_states_stream: Array<One_Click_Deployment_States>;
  /** fetch data from the table in a streaming manner: "one_click_deployment" */
  one_click_deployment_stream: Array<One_Click_Deployment>;
  /** fetch data from the table: "opentelemetry_config" */
  opentelemetry_config: Array<Opentelemetry_Config>;
  /** fetch aggregated fields from the table: "opentelemetry_config" */
  opentelemetry_config_aggregate: Opentelemetry_Config_Aggregate;
  /** fetch data from the table: "opentelemetry_config" using primary key columns */
  opentelemetry_config_by_pk?: Maybe<Opentelemetry_Config>;
  /** fetch data from the table in a streaming manner: "opentelemetry_config" */
  opentelemetry_config_stream: Array<Opentelemetry_Config>;
  /** fetch data from the table: "operations.delete_free_plan_dns_records_nov_2021" */
  operations_delete_free_plan_dns_records_nov_2021: Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021>;
  /** fetch aggregated fields from the table: "operations.delete_free_plan_dns_records_nov_2021" */
  operations_delete_free_plan_dns_records_nov_2021_aggregate: Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Aggregate;
  /** fetch data from the table: "operations.delete_free_plan_dns_records_nov_2021" using primary key columns */
  operations_delete_free_plan_dns_records_nov_2021_by_pk?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021>;
  /** fetch data from the table in a streaming manner: "operations.delete_free_plan_dns_records_nov_2021" */
  operations_delete_free_plan_dns_records_nov_2021_stream: Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021>;
  /** fetch data from the table: "operations.tenant" */
  operations_tenant: Array<Operations_Tenant>;
  /** fetch aggregated fields from the table: "operations.tenant" */
  operations_tenant_aggregate: Operations_Tenant_Aggregate;
  /** fetch data from the table in a streaming manner: "operations.tenant" */
  operations_tenant_stream: Array<Operations_Tenant>;
  /** execute function "operations.to_delete_free_plan_dns_records" which returns "operations.tenant" */
  operations_to_delete_free_plan_dns_records: Array<Operations_Tenant>;
  /**
   * execute function "operations.to_delete_free_plan_dns_records" and query
   * aggregates on result of table type "operations.tenant"
   */
  operations_to_delete_free_plan_dns_records_aggregate: Operations_Tenant_Aggregate;
  /** fetch data from the table: "payment_method" */
  payment_method: Array<Payment_Method>;
  /** fetch aggregated fields from the table: "payment_method" */
  payment_method_aggregate: Payment_Method_Aggregate;
  /** fetch data from the table: "payment_method" using primary key columns */
  payment_method_by_pk?: Maybe<Payment_Method>;
  /** fetch data from the table in a streaming manner: "payment_method" */
  payment_method_stream: Array<Payment_Method>;
  /** fetch data from the table: "plan_entitlements" */
  plan_entitlements: Array<Plan_Entitlements>;
  /** fetch aggregated fields from the table: "plan_entitlements" */
  plan_entitlements_aggregate: Plan_Entitlements_Aggregate;
  /** fetch data from the table: "plan_entitlements" using primary key columns */
  plan_entitlements_by_pk?: Maybe<Plan_Entitlements>;
  /** fetch data from the table in a streaming manner: "plan_entitlements" */
  plan_entitlements_stream: Array<Plan_Entitlements>;
  /** fetch data from the table: "plans" */
  plans: Array<Plans>;
  /** fetch aggregated fields from the table: "plans" */
  plans_aggregate: Plans_Aggregate;
  /** fetch data from the table: "plans" using primary key columns */
  plans_by_pk?: Maybe<Plans>;
  /** fetch data from the table in a streaming manner: "plans" */
  plans_stream: Array<Plans>;
  /** An array relationship */
  policies: Array<Policies>;
  /** An aggregate relationship */
  policies_aggregate: Policies_Aggregate;
  /** fetch data from the table: "policies" using primary key columns */
  policies_by_pk?: Maybe<Policies>;
  /** fetch data from the table in a streaming manner: "policies" */
  policies_stream: Array<Policies>;
  /** fetch data from the table: "privileges" */
  privileges: Array<Privileges>;
  /** fetch aggregated fields from the table: "privileges" */
  privileges_aggregate: Privileges_Aggregate;
  /** fetch data from the table: "privileges" using primary key columns */
  privileges_by_pk?: Maybe<Privileges>;
  /** fetch data from the table in a streaming manner: "privileges" */
  privileges_stream: Array<Privileges>;
  /** fetch data from the table: "pro_license_keys" */
  pro_license_keys: Array<Pro_License_Keys>;
  /** fetch aggregated fields from the table: "pro_license_keys" */
  pro_license_keys_aggregate: Pro_License_Keys_Aggregate;
  /** fetch data from the table: "pro_license_keys" using primary key columns */
  pro_license_keys_by_pk?: Maybe<Pro_License_Keys>;
  /** fetch data from the table in a streaming manner: "pro_license_keys" */
  pro_license_keys_stream: Array<Pro_License_Keys>;
  /** fetch data from the table: "project_activity" */
  project_activity: Array<Project_Activity>;
  /** fetch aggregated fields from the table: "project_activity" */
  project_activity_aggregate: Project_Activity_Aggregate;
  /** fetch data from the table: "project_activity" using primary key columns */
  project_activity_by_pk?: Maybe<Project_Activity>;
  /** fetch data from the table in a streaming manner: "project_activity" */
  project_activity_stream: Array<Project_Activity>;
  /** An array relationship */
  project_billing_manager_invitations: Array<Project_Billing_Manager_Invitations>;
  /** An aggregate relationship */
  project_billing_manager_invitations_aggregate: Project_Billing_Manager_Invitations_Aggregate;
  /** fetch data from the table: "project_billing_manager_invitations" using primary key columns */
  project_billing_manager_invitations_by_pk?: Maybe<Project_Billing_Manager_Invitations>;
  /** fetch data from the table in a streaming manner: "project_billing_manager_invitations" */
  project_billing_manager_invitations_stream: Array<Project_Billing_Manager_Invitations>;
  /** fetch data from the table: "project_collaborator_allowed_schema_tables" */
  project_collaborator_allowed_schema_tables: Array<Project_Collaborator_Allowed_Schema_Tables>;
  /** fetch aggregated fields from the table: "project_collaborator_allowed_schema_tables" */
  project_collaborator_allowed_schema_tables_aggregate: Project_Collaborator_Allowed_Schema_Tables_Aggregate;
  /** fetch data from the table: "project_collaborator_allowed_schema_tables" using primary key columns */
  project_collaborator_allowed_schema_tables_by_pk?: Maybe<Project_Collaborator_Allowed_Schema_Tables>;
  /** fetch data from the table in a streaming manner: "project_collaborator_allowed_schema_tables" */
  project_collaborator_allowed_schema_tables_stream: Array<Project_Collaborator_Allowed_Schema_Tables>;
  /** An array relationship */
  project_collaborator_allowed_schemas: Array<Project_Collaborator_Allowed_Schemas>;
  /** An aggregate relationship */
  project_collaborator_allowed_schemas_aggregate: Project_Collaborator_Allowed_Schemas_Aggregate;
  /** fetch data from the table: "project_collaborator_allowed_schemas" using primary key columns */
  project_collaborator_allowed_schemas_by_pk?: Maybe<Project_Collaborator_Allowed_Schemas>;
  /** fetch data from the table in a streaming manner: "project_collaborator_allowed_schemas" */
  project_collaborator_allowed_schemas_stream: Array<Project_Collaborator_Allowed_Schemas>;
  /** fetch data from the table: "project_collaborator_invitations" */
  project_collaborator_invitations: Array<Project_Collaborator_Invitations>;
  /** fetch aggregated fields from the table: "project_collaborator_invitations" */
  project_collaborator_invitations_aggregate: Project_Collaborator_Invitations_Aggregate;
  /** fetch data from the table: "project_collaborator_invitations" using primary key columns */
  project_collaborator_invitations_by_pk?: Maybe<Project_Collaborator_Invitations>;
  /** fetch data from the table in a streaming manner: "project_collaborator_invitations" */
  project_collaborator_invitations_stream: Array<Project_Collaborator_Invitations>;
  /** An array relationship */
  project_collaborator_privileges: Array<Project_Collaborator_Privileges>;
  /** An aggregate relationship */
  project_collaborator_privileges_aggregate: Project_Collaborator_Privileges_Aggregate;
  /** fetch data from the table: "project_collaborator_privileges" using primary key columns */
  project_collaborator_privileges_by_pk?: Maybe<Project_Collaborator_Privileges>;
  /** fetch data from the table in a streaming manner: "project_collaborator_privileges" */
  project_collaborator_privileges_stream: Array<Project_Collaborator_Privileges>;
  /** fetch data from the table: "project_collaborators" */
  project_collaborators: Array<Project_Collaborators>;
  /** fetch aggregated fields from the table: "project_collaborators" */
  project_collaborators_aggregate: Project_Collaborators_Aggregate;
  /** fetch data from the table: "project_collaborators" using primary key columns */
  project_collaborators_by_pk?: Maybe<Project_Collaborators>;
  /** fetch data from the table in a streaming manner: "project_collaborators" */
  project_collaborators_stream: Array<Project_Collaborators>;
  /** fetch data from the table: "project_data_usage" */
  project_data_usage: Array<Project_Data_Usage>;
  /** fetch data from the table: "project_data_usage_agg" */
  project_data_usage_agg: Array<Project_Data_Usage_Agg>;
  /** fetch aggregated fields from the table: "project_data_usage_agg" */
  project_data_usage_agg_aggregate: Project_Data_Usage_Agg_Aggregate;
  /** fetch data from the table in a streaming manner: "project_data_usage_agg" */
  project_data_usage_agg_stream: Array<Project_Data_Usage_Agg>;
  /** fetch data from the table: "project_data_usage_agg_user" */
  project_data_usage_agg_user: Array<Project_Data_Usage_Agg_User>;
  /** fetch aggregated fields from the table: "project_data_usage_agg_user" */
  project_data_usage_agg_user_aggregate: Project_Data_Usage_Agg_User_Aggregate;
  /** fetch data from the table in a streaming manner: "project_data_usage_agg_user" */
  project_data_usage_agg_user_stream: Array<Project_Data_Usage_Agg_User>;
  /** fetch aggregated fields from the table: "project_data_usage" */
  project_data_usage_aggregate: Project_Data_Usage_Aggregate;
  /** fetch data from the table: "project_data_usage" using primary key columns */
  project_data_usage_by_pk?: Maybe<Project_Data_Usage>;
  /** fetch data from the table: "project_data_usage_components" */
  project_data_usage_components: Array<Project_Data_Usage_Components>;
  /** fetch aggregated fields from the table: "project_data_usage_components" */
  project_data_usage_components_aggregate: Project_Data_Usage_Components_Aggregate;
  /** fetch data from the table in a streaming manner: "project_data_usage_components" */
  project_data_usage_components_stream: Array<Project_Data_Usage_Components>;
  /** fetch data from the table: "project_data_usage_prometheus" */
  project_data_usage_prometheus: Array<Project_Data_Usage_Prometheus>;
  /** fetch data from the table: "project_data_usage_prometheus_agg_user" */
  project_data_usage_prometheus_agg_user: Array<Project_Data_Usage_Prometheus_Agg_User>;
  /** fetch aggregated fields from the table: "project_data_usage_prometheus_agg_user" */
  project_data_usage_prometheus_agg_user_aggregate: Project_Data_Usage_Prometheus_Agg_User_Aggregate;
  /** fetch data from the table in a streaming manner: "project_data_usage_prometheus_agg_user" */
  project_data_usage_prometheus_agg_user_stream: Array<Project_Data_Usage_Prometheus_Agg_User>;
  /** fetch aggregated fields from the table: "project_data_usage_prometheus" */
  project_data_usage_prometheus_aggregate: Project_Data_Usage_Prometheus_Aggregate;
  /** fetch data from the table: "project_data_usage_prometheus" using primary key columns */
  project_data_usage_prometheus_by_pk?: Maybe<Project_Data_Usage_Prometheus>;
  /** fetch data from the table in a streaming manner: "project_data_usage_prometheus" */
  project_data_usage_prometheus_stream: Array<Project_Data_Usage_Prometheus>;
  /** fetch data from the table: "project_data_usage_report" */
  project_data_usage_report: Array<Project_Data_Usage_Report>;
  /** fetch aggregated fields from the table: "project_data_usage_report" */
  project_data_usage_report_aggregate: Project_Data_Usage_Report_Aggregate;
  /** fetch data from the table: "project_data_usage_report" using primary key columns */
  project_data_usage_report_by_pk?: Maybe<Project_Data_Usage_Report>;
  /** fetch data from the table in a streaming manner: "project_data_usage_report" */
  project_data_usage_report_stream: Array<Project_Data_Usage_Report>;
  /** fetch data from the table in a streaming manner: "project_data_usage" */
  project_data_usage_stream: Array<Project_Data_Usage>;
  /** fetch data from the table: "project_db_usage" */
  project_db_usage: Array<Project_Db_Usage>;
  /** fetch data from the table: "project_db_usage_agg_user" */
  project_db_usage_agg_user: Array<Project_Db_Usage_Agg_User>;
  /** fetch aggregated fields from the table: "project_db_usage_agg_user" */
  project_db_usage_agg_user_aggregate: Project_Db_Usage_Agg_User_Aggregate;
  /** fetch data from the table in a streaming manner: "project_db_usage_agg_user" */
  project_db_usage_agg_user_stream: Array<Project_Db_Usage_Agg_User>;
  /** fetch aggregated fields from the table: "project_db_usage" */
  project_db_usage_aggregate: Project_Db_Usage_Aggregate;
  /** fetch data from the table: "project_db_usage" using primary key columns */
  project_db_usage_by_pk?: Maybe<Project_Db_Usage>;
  /** fetch data from the table in a streaming manner: "project_db_usage" */
  project_db_usage_stream: Array<Project_Db_Usage>;
  /** fetch data from the table: "project_entitlement_access" */
  project_entitlement_access: Array<Project_Entitlement_Access>;
  /** fetch aggregated fields from the table: "project_entitlement_access" */
  project_entitlement_access_aggregate: Project_Entitlement_Access_Aggregate;
  /** fetch data from the table: "project_entitlement_access" using primary key columns */
  project_entitlement_access_by_pk?: Maybe<Project_Entitlement_Access>;
  /** fetch data from the table in a streaming manner: "project_entitlement_access" */
  project_entitlement_access_stream: Array<Project_Entitlement_Access>;
  /** fetch data from the table: "project_entitlement_catalogue" */
  project_entitlement_catalogue: Array<Project_Entitlement_Catalogue>;
  /** fetch aggregated fields from the table: "project_entitlement_catalogue" */
  project_entitlement_catalogue_aggregate: Project_Entitlement_Catalogue_Aggregate;
  /** fetch data from the table: "project_entitlement_catalogue" using primary key columns */
  project_entitlement_catalogue_by_pk?: Maybe<Project_Entitlement_Catalogue>;
  /** fetch data from the table in a streaming manner: "project_entitlement_catalogue" */
  project_entitlement_catalogue_stream: Array<Project_Entitlement_Catalogue>;
  /** fetch data from the table: "project_entitlement_types" */
  project_entitlement_types: Array<Project_Entitlement_Types>;
  /** fetch aggregated fields from the table: "project_entitlement_types" */
  project_entitlement_types_aggregate: Project_Entitlement_Types_Aggregate;
  /** fetch data from the table: "project_entitlement_types" using primary key columns */
  project_entitlement_types_by_pk?: Maybe<Project_Entitlement_Types>;
  /** fetch data from the table in a streaming manner: "project_entitlement_types" */
  project_entitlement_types_stream: Array<Project_Entitlement_Types>;
  /** An array relationship */
  project_labels: Array<Project_Labels>;
  /** An aggregate relationship */
  project_labels_aggregate: Project_Labels_Aggregate;
  /** fetch data from the table: "project_labels" using primary key columns */
  project_labels_by_pk?: Maybe<Project_Labels>;
  /** fetch data from the table in a streaming manner: "project_labels" */
  project_labels_stream: Array<Project_Labels>;
  /** fetch data from the table: "project_metadata" */
  project_metadata: Array<Project_Metadata>;
  /** fetch aggregated fields from the table: "project_metadata" */
  project_metadata_aggregate: Project_Metadata_Aggregate;
  /** fetch data from the table: "project_metadata" using primary key columns */
  project_metadata_by_pk?: Maybe<Project_Metadata>;
  /** fetch data from the table in a streaming manner: "project_metadata" */
  project_metadata_stream: Array<Project_Metadata>;
  /** fetch data from the table: "project_notification" */
  project_notification: Array<Project_Notification>;
  /** fetch aggregated fields from the table: "project_notification" */
  project_notification_aggregate: Project_Notification_Aggregate;
  /** fetch data from the table: "project_notification" using primary key columns */
  project_notification_by_pk?: Maybe<Project_Notification>;
  /** fetch data from the table in a streaming manner: "project_notification" */
  project_notification_stream: Array<Project_Notification>;
  /** fetch data from the table: "project_ownership_transfer_invitations" */
  project_ownership_transfer_invitations: Array<Project_Ownership_Transfer_Invitations>;
  /** fetch aggregated fields from the table: "project_ownership_transfer_invitations" */
  project_ownership_transfer_invitations_aggregate: Project_Ownership_Transfer_Invitations_Aggregate;
  /** fetch data from the table: "project_ownership_transfer_invitations" using primary key columns */
  project_ownership_transfer_invitations_by_pk?: Maybe<Project_Ownership_Transfer_Invitations>;
  /** fetch data from the table in a streaming manner: "project_ownership_transfer_invitations" */
  project_ownership_transfer_invitations_stream: Array<Project_Ownership_Transfer_Invitations>;
  /** fetch data from the table: "project_pool_current_status" */
  project_pool_current_status: Array<Project_Pool_Current_Status>;
  /** fetch aggregated fields from the table: "project_pool_current_status" */
  project_pool_current_status_aggregate: Project_Pool_Current_Status_Aggregate;
  /** fetch data from the table in a streaming manner: "project_pool_current_status" */
  project_pool_current_status_stream: Array<Project_Pool_Current_Status>;
  /** fetch data from the table: "project_requests_count" */
  project_requests_count: Array<Project_Requests_Count>;
  /** fetch aggregated fields from the table: "project_requests_count" */
  project_requests_count_aggregate: Project_Requests_Count_Aggregate;
  /** fetch data from the table: "project_requests_count" using primary key columns */
  project_requests_count_by_pk?: Maybe<Project_Requests_Count>;
  /** fetch data from the table in a streaming manner: "project_requests_count" */
  project_requests_count_stream: Array<Project_Requests_Count>;
  /** fetch data from the table: "project_stats" */
  project_stats: Array<Project_Stats>;
  /** fetch aggregated fields from the table: "project_stats" */
  project_stats_aggregate: Project_Stats_Aggregate;
  /** fetch data from the table: "project_stats" using primary key columns */
  project_stats_by_pk?: Maybe<Project_Stats>;
  /** fetch data from the table in a streaming manner: "project_stats" */
  project_stats_stream: Array<Project_Stats>;
  /** fetch data from the table: "project_total_db_usage_agg" */
  project_total_db_usage_agg: Array<Project_Total_Db_Usage_Agg>;
  /** fetch aggregated fields from the table: "project_total_db_usage_agg" */
  project_total_db_usage_agg_aggregate: Project_Total_Db_Usage_Agg_Aggregate;
  /** fetch data from the table in a streaming manner: "project_total_db_usage_agg" */
  project_total_db_usage_agg_stream: Array<Project_Total_Db_Usage_Agg>;
  /** An array relationship */
  projects: Array<Projects>;
  /** An aggregate relationship */
  projects_aggregate: Projects_Aggregate;
  /** fetch data from the table: "projects" using primary key columns */
  projects_by_pk?: Maybe<Projects>;
  /** fetch data from the table: "projects_pool_config" */
  projects_pool_config: Array<Projects_Pool_Config>;
  /** fetch aggregated fields from the table: "projects_pool_config" */
  projects_pool_config_aggregate: Projects_Pool_Config_Aggregate;
  /** fetch data from the table: "projects_pool_config" using primary key columns */
  projects_pool_config_by_pk?: Maybe<Projects_Pool_Config>;
  /** fetch data from the table in a streaming manner: "projects_pool_config" */
  projects_pool_config_stream: Array<Projects_Pool_Config>;
  /** fetch data from the table: "projects_pro_key_generations" */
  projects_pro_key_generations: Array<Projects_Pro_Key_Generations>;
  /** fetch aggregated fields from the table: "projects_pro_key_generations" */
  projects_pro_key_generations_aggregate: Projects_Pro_Key_Generations_Aggregate;
  /** fetch data from the table: "projects_pro_key_generations" using primary key columns */
  projects_pro_key_generations_by_pk?: Maybe<Projects_Pro_Key_Generations>;
  /** fetch data from the table in a streaming manner: "projects_pro_key_generations" */
  projects_pro_key_generations_stream: Array<Projects_Pro_Key_Generations>;
  /** fetch data from the table in a streaming manner: "projects" */
  projects_stream: Array<Projects>;
  /** fetch data from the table: "projects_with_no_running_deployments" */
  projects_with_no_running_deployments: Array<Projects_With_No_Running_Deployments>;
  /** fetch aggregated fields from the table: "projects_with_no_running_deployments" */
  projects_with_no_running_deployments_aggregate: Projects_With_No_Running_Deployments_Aggregate;
  /** fetch data from the table in a streaming manner: "projects_with_no_running_deployments" */
  projects_with_no_running_deployments_stream: Array<Projects_With_No_Running_Deployments>;
  /** fetch data from the table: "projects_with_no_running_preview_app" */
  projects_with_no_running_preview_app: Array<Projects_With_No_Running_Preview_App>;
  /** fetch aggregated fields from the table: "projects_with_no_running_preview_app" */
  projects_with_no_running_preview_app_aggregate: Projects_With_No_Running_Preview_App_Aggregate;
  /** fetch data from the table in a streaming manner: "projects_with_no_running_preview_app" */
  projects_with_no_running_preview_app_stream: Array<Projects_With_No_Running_Preview_App>;
  /** fetch data from the table: "prometheus_config" */
  prometheus_config: Array<Prometheus_Config>;
  /** fetch aggregated fields from the table: "prometheus_config" */
  prometheus_config_aggregate: Prometheus_Config_Aggregate;
  /** fetch data from the table: "prometheus_config" using primary key columns */
  prometheus_config_by_pk?: Maybe<Prometheus_Config>;
  /** fetch data from the table in a streaming manner: "prometheus_config" */
  prometheus_config_stream: Array<Prometheus_Config>;
  /** An array relationship */
  providers: Array<Providers>;
  /** An aggregate relationship */
  providers_aggregate: Providers_Aggregate;
  /** fetch data from the table: "providers" using primary key columns */
  providers_by_pk?: Maybe<Providers>;
  /** fetch data from the table in a streaming manner: "providers" */
  providers_stream: Array<Providers>;
  /** fetch data from the table: "provisioning" */
  provisioning: Array<Provisioning>;
  /** fetch aggregated fields from the table: "provisioning" */
  provisioning_aggregate: Provisioning_Aggregate;
  /** fetch data from the table: "provisioning" using primary key columns */
  provisioning_by_pk?: Maybe<Provisioning>;
  /** fetch data from the table in a streaming manner: "provisioning" */
  provisioning_stream: Array<Provisioning>;
  /** fetch data from the table: "region" */
  region: Array<Region>;
  /** fetch aggregated fields from the table: "region" */
  region_aggregate: Region_Aggregate;
  /** fetch data from the table: "region" using primary key columns */
  region_by_pk?: Maybe<Region>;
  /** fetch data from the table in a streaming manner: "region" */
  region_stream: Array<Region>;
  /** fetch data from the table: "region_v2" */
  region_v2: Array<Region_V2>;
  /** fetch aggregated fields from the table: "region_v2" */
  region_v2_aggregate: Region_V2_Aggregate;
  /** fetch data from the table in a streaming manner: "region_v2" */
  region_v2_stream: Array<Region_V2>;
  /** fetch data from the table: "regional_data_connectors" */
  regional_data_connectors: Array<Regional_Data_Connectors>;
  /** fetch aggregated fields from the table: "regional_data_connectors" */
  regional_data_connectors_aggregate: Regional_Data_Connectors_Aggregate;
  /** fetch data from the table: "regional_data_connectors" using primary key columns */
  regional_data_connectors_by_pk?: Maybe<Regional_Data_Connectors>;
  /** fetch data from the table in a streaming manner: "regional_data_connectors" */
  regional_data_connectors_stream: Array<Regional_Data_Connectors>;
  /** An array relationship */
  regional_metrics: Array<Regional_Metrics>;
  /** An aggregate relationship */
  regional_metrics_aggregate: Regional_Metrics_Aggregate;
  /** fetch data from the table: "regional_metrics" using primary key columns */
  regional_metrics_by_pk?: Maybe<Regional_Metrics>;
  /** fetch data from the table in a streaming manner: "regional_metrics" */
  regional_metrics_stream: Array<Regional_Metrics>;
  /** fetch data from the table: "saml_idp" */
  saml_idp: Array<Saml_Idp>;
  /** fetch aggregated fields from the table: "saml_idp" */
  saml_idp_aggregate: Saml_Idp_Aggregate;
  /** fetch data from the table: "saml_idp" using primary key columns */
  saml_idp_by_pk?: Maybe<Saml_Idp>;
  /** fetch data from the table in a streaming manner: "saml_idp" */
  saml_idp_stream: Array<Saml_Idp>;
  /** execute function "search_project_login_status" which returns "search_project_login_status_results" */
  search_project_login_status: Array<Search_Project_Login_Status_Results>;
  /**
   * execute function "search_project_login_status" and query aggregates on result
   * of table type "search_project_login_status_results"
   */
  search_project_login_status_aggregate: Search_Project_Login_Status_Results_Aggregate;
  /** fetch data from the table: "search_project_login_status_results" */
  search_project_login_status_results: Array<Search_Project_Login_Status_Results>;
  /** fetch aggregated fields from the table: "search_project_login_status_results" */
  search_project_login_status_results_aggregate: Search_Project_Login_Status_Results_Aggregate;
  /** fetch data from the table in a streaming manner: "search_project_login_status_results" */
  search_project_login_status_results_stream: Array<Search_Project_Login_Status_Results>;
  /** execute function "search_tenant_group_has_least_members" which returns "tenant_group" */
  search_tenant_group_has_least_members: Array<Tenant_Group>;
  /** execute function "search_tenant_group_has_least_members" and query aggregates on result of table type "tenant_group" */
  search_tenant_group_has_least_members_aggregate: Tenant_Group_Aggregate;
  /** fetch data from the table: "slack_config" */
  slack_config: Array<Slack_Config>;
  /** fetch aggregated fields from the table: "slack_config" */
  slack_config_aggregate: Slack_Config_Aggregate;
  /** fetch data from the table: "slack_config" using primary key columns */
  slack_config_by_pk?: Maybe<Slack_Config>;
  /** fetch data from the table in a streaming manner: "slack_config" */
  slack_config_stream: Array<Slack_Config>;
  /** fetch data from the table: "stripe_subscription" */
  stripe_subscription: Array<Stripe_Subscription>;
  /** fetch aggregated fields from the table: "stripe_subscription" */
  stripe_subscription_aggregate: Stripe_Subscription_Aggregate;
  /** fetch data from the table: "stripe_subscription" using primary key columns */
  stripe_subscription_by_pk?: Maybe<Stripe_Subscription>;
  /** fetch data from the table in a streaming manner: "stripe_subscription" */
  stripe_subscription_stream: Array<Stripe_Subscription>;
  /** fetch data from the table: "stripe_webhook_events" */
  stripe_webhook_events: Array<Stripe_Webhook_Events>;
  /** fetch aggregated fields from the table: "stripe_webhook_events" */
  stripe_webhook_events_aggregate: Stripe_Webhook_Events_Aggregate;
  /** fetch data from the table: "stripe_webhook_events" using primary key columns */
  stripe_webhook_events_by_pk?: Maybe<Stripe_Webhook_Events>;
  /** fetch data from the table in a streaming manner: "stripe_webhook_events" */
  stripe_webhook_events_stream: Array<Stripe_Webhook_Events>;
  /** fetch data from the table: "super_connector_types" */
  super_connector_types: Array<Super_Connector_Types>;
  /** fetch aggregated fields from the table: "super_connector_types" */
  super_connector_types_aggregate: Super_Connector_Types_Aggregate;
  /** fetch data from the table: "super_connector_types" using primary key columns */
  super_connector_types_by_pk?: Maybe<Super_Connector_Types>;
  /** fetch data from the table in a streaming manner: "super_connector_types" */
  super_connector_types_stream: Array<Super_Connector_Types>;
  /** fetch data from the table: "support_plan_types" */
  support_plan_types: Array<Support_Plan_Types>;
  /** fetch aggregated fields from the table: "support_plan_types" */
  support_plan_types_aggregate: Support_Plan_Types_Aggregate;
  /** fetch data from the table: "support_plan_types" using primary key columns */
  support_plan_types_by_pk?: Maybe<Support_Plan_Types>;
  /** fetch data from the table in a streaming manner: "support_plan_types" */
  support_plan_types_stream: Array<Support_Plan_Types>;
  /** fetch data from the table: "survey" */
  survey: Array<Survey>;
  /** fetch aggregated fields from the table: "survey" */
  survey_aggregate: Survey_Aggregate;
  /** fetch data from the table: "survey" using primary key columns */
  survey_by_pk?: Maybe<Survey>;
  /** fetch data from the table: "survey_question" */
  survey_question: Array<Survey_Question>;
  /** fetch aggregated fields from the table: "survey_question" */
  survey_question_aggregate: Survey_Question_Aggregate;
  /** fetch data from the table: "survey_question_answer_option" */
  survey_question_answer_option: Array<Survey_Question_Answer_Option>;
  /** fetch aggregated fields from the table: "survey_question_answer_option" */
  survey_question_answer_option_aggregate: Survey_Question_Answer_Option_Aggregate;
  /** fetch data from the table: "survey_question_answer_option" using primary key columns */
  survey_question_answer_option_by_pk?: Maybe<Survey_Question_Answer_Option>;
  /** fetch data from the table in a streaming manner: "survey_question_answer_option" */
  survey_question_answer_option_stream: Array<Survey_Question_Answer_Option>;
  /** fetch data from the table: "survey_question_answers" */
  survey_question_answers: Array<Survey_Question_Answers>;
  /** fetch aggregated fields from the table: "survey_question_answers" */
  survey_question_answers_aggregate: Survey_Question_Answers_Aggregate;
  /** fetch data from the table: "survey_question_answers" using primary key columns */
  survey_question_answers_by_pk?: Maybe<Survey_Question_Answers>;
  /** fetch data from the table in a streaming manner: "survey_question_answers" */
  survey_question_answers_stream: Array<Survey_Question_Answers>;
  /** fetch data from the table: "survey_question" using primary key columns */
  survey_question_by_pk?: Maybe<Survey_Question>;
  /** fetch data from the table: "survey_question_kind" */
  survey_question_kind: Array<Survey_Question_Kind>;
  /** fetch aggregated fields from the table: "survey_question_kind" */
  survey_question_kind_aggregate: Survey_Question_Kind_Aggregate;
  /** fetch data from the table: "survey_question_kind" using primary key columns */
  survey_question_kind_by_pk?: Maybe<Survey_Question_Kind>;
  /** fetch data from the table in a streaming manner: "survey_question_kind" */
  survey_question_kind_stream: Array<Survey_Question_Kind>;
  /** An array relationship */
  survey_question_options: Array<Survey_Question_Options>;
  /** An aggregate relationship */
  survey_question_options_aggregate: Survey_Question_Options_Aggregate;
  /** fetch data from the table: "survey_question_options" using primary key columns */
  survey_question_options_by_pk?: Maybe<Survey_Question_Options>;
  /** fetch data from the table in a streaming manner: "survey_question_options" */
  survey_question_options_stream: Array<Survey_Question_Options>;
  /** fetch data from the table in a streaming manner: "survey_question" */
  survey_question_stream: Array<Survey_Question>;
  /** fetch data from the table in a streaming manner: "survey" */
  survey_stream: Array<Survey>;
  /** fetch data from the table: "survey_v2" */
  survey_v2: Array<Survey_V2>;
  /** fetch aggregated fields from the table: "survey_v2" */
  survey_v2_aggregate: Survey_V2_Aggregate;
  /** fetch data from the table: "survey_v2" using primary key columns */
  survey_v2_by_pk?: Maybe<Survey_V2>;
  /** fetch data from the table: "survey_v2_question" */
  survey_v2_question: Array<Survey_V2_Question>;
  /** fetch aggregated fields from the table: "survey_v2_question" */
  survey_v2_question_aggregate: Survey_V2_Question_Aggregate;
  /** fetch data from the table: "survey_v2_question" using primary key columns */
  survey_v2_question_by_pk?: Maybe<Survey_V2_Question>;
  /** fetch data from the table: "survey_v2_question_kind" */
  survey_v2_question_kind: Array<Survey_V2_Question_Kind>;
  /** fetch aggregated fields from the table: "survey_v2_question_kind" */
  survey_v2_question_kind_aggregate: Survey_V2_Question_Kind_Aggregate;
  /** fetch data from the table: "survey_v2_question_kind" using primary key columns */
  survey_v2_question_kind_by_pk?: Maybe<Survey_V2_Question_Kind>;
  /** fetch data from the table in a streaming manner: "survey_v2_question_kind" */
  survey_v2_question_kind_stream: Array<Survey_V2_Question_Kind>;
  /** fetch data from the table: "survey_v2_question_option" */
  survey_v2_question_option: Array<Survey_V2_Question_Option>;
  /** fetch data from the table: "survey_v2_question_option_additional_info_config" */
  survey_v2_question_option_additional_info_config: Array<Survey_V2_Question_Option_Additional_Info_Config>;
  /** fetch aggregated fields from the table: "survey_v2_question_option_additional_info_config" */
  survey_v2_question_option_additional_info_config_aggregate: Survey_V2_Question_Option_Additional_Info_Config_Aggregate;
  /** fetch data from the table: "survey_v2_question_option_additional_info_config" using primary key columns */
  survey_v2_question_option_additional_info_config_by_pk?: Maybe<Survey_V2_Question_Option_Additional_Info_Config>;
  /** fetch data from the table in a streaming manner: "survey_v2_question_option_additional_info_config" */
  survey_v2_question_option_additional_info_config_stream: Array<Survey_V2_Question_Option_Additional_Info_Config>;
  /** fetch aggregated fields from the table: "survey_v2_question_option" */
  survey_v2_question_option_aggregate: Survey_V2_Question_Option_Aggregate;
  /** fetch data from the table: "survey_v2_question_option" using primary key columns */
  survey_v2_question_option_by_pk?: Maybe<Survey_V2_Question_Option>;
  /** fetch data from the table in a streaming manner: "survey_v2_question_option" */
  survey_v2_question_option_stream: Array<Survey_V2_Question_Option>;
  /** fetch data from the table in a streaming manner: "survey_v2_question" */
  survey_v2_question_stream: Array<Survey_V2_Question>;
  /** fetch data from the table: "survey_v2_response" */
  survey_v2_response: Array<Survey_V2_Response>;
  /** fetch aggregated fields from the table: "survey_v2_response" */
  survey_v2_response_aggregate: Survey_V2_Response_Aggregate;
  /** fetch data from the table: "survey_v2_response_answer" */
  survey_v2_response_answer: Array<Survey_V2_Response_Answer>;
  /** fetch aggregated fields from the table: "survey_v2_response_answer" */
  survey_v2_response_answer_aggregate: Survey_V2_Response_Answer_Aggregate;
  /** fetch data from the table: "survey_v2_response_answer" using primary key columns */
  survey_v2_response_answer_by_pk?: Maybe<Survey_V2_Response_Answer>;
  /** fetch data from the table: "survey_v2_response_answer_option" */
  survey_v2_response_answer_option: Array<Survey_V2_Response_Answer_Option>;
  /** fetch aggregated fields from the table: "survey_v2_response_answer_option" */
  survey_v2_response_answer_option_aggregate: Survey_V2_Response_Answer_Option_Aggregate;
  /** fetch data from the table: "survey_v2_response_answer_option" using primary key columns */
  survey_v2_response_answer_option_by_pk?: Maybe<Survey_V2_Response_Answer_Option>;
  /** fetch data from the table in a streaming manner: "survey_v2_response_answer_option" */
  survey_v2_response_answer_option_stream: Array<Survey_V2_Response_Answer_Option>;
  /** fetch data from the table in a streaming manner: "survey_v2_response_answer" */
  survey_v2_response_answer_stream: Array<Survey_V2_Response_Answer>;
  /** fetch data from the table: "survey_v2_response" using primary key columns */
  survey_v2_response_by_pk?: Maybe<Survey_V2_Response>;
  /** fetch data from the table in a streaming manner: "survey_v2_response" */
  survey_v2_response_stream: Array<Survey_V2_Response>;
  /** fetch data from the table in a streaming manner: "survey_v2" */
  survey_v2_stream: Array<Survey_V2>;
  /** fetch data from the table: "task_event" */
  task_event: Array<Task_Event>;
  /** fetch aggregated fields from the table: "task_event" */
  task_event_aggregate: Task_Event_Aggregate;
  /** fetch data from the table: "task_event" using primary key columns */
  task_event_by_pk?: Maybe<Task_Event>;
  /** fetch data from the table in a streaming manner: "task_event" */
  task_event_stream: Array<Task_Event>;
  /** fetch data from the table: "taskq_worker_event_latest" */
  taskq_worker_event_latest: Array<Taskq_Worker_Event_Latest>;
  /** fetch aggregated fields from the table: "taskq_worker_event_latest" */
  taskq_worker_event_latest_aggregate: Taskq_Worker_Event_Latest_Aggregate;
  /** fetch data from the table in a streaming manner: "taskq_worker_event_latest" */
  taskq_worker_event_latest_stream: Array<Taskq_Worker_Event_Latest>;
  /** An array relationship */
  tasks: Array<Tasks>;
  /** An aggregate relationship */
  tasks_aggregate: Tasks_Aggregate;
  /** fetch data from the table: "tasks" using primary key columns */
  tasks_by_pk?: Maybe<Tasks>;
  /** fetch data from the table in a streaming manner: "tasks" */
  tasks_stream: Array<Tasks>;
  /** fetch data from the table: "tenant" */
  tenant: Array<Tenant>;
  /** fetch data from the table: "tenant_active_status_reason" */
  tenant_active_status_reason: Array<Tenant_Active_Status_Reason>;
  /** fetch aggregated fields from the table: "tenant_active_status_reason" */
  tenant_active_status_reason_aggregate: Tenant_Active_Status_Reason_Aggregate;
  /** fetch data from the table: "tenant_active_status_reason" using primary key columns */
  tenant_active_status_reason_by_pk?: Maybe<Tenant_Active_Status_Reason>;
  /** fetch data from the table in a streaming manner: "tenant_active_status_reason" */
  tenant_active_status_reason_stream: Array<Tenant_Active_Status_Reason>;
  /** fetch aggregated fields from the table: "tenant" */
  tenant_aggregate: Tenant_Aggregate;
  /** fetch data from the table: "tenant" using primary key columns */
  tenant_by_pk?: Maybe<Tenant>;
  /** fetch data from the table: "tenant_group" */
  tenant_group: Array<Tenant_Group>;
  /** fetch aggregated fields from the table: "tenant_group" */
  tenant_group_aggregate: Tenant_Group_Aggregate;
  /** fetch data from the table: "tenant_group" using primary key columns */
  tenant_group_by_pk?: Maybe<Tenant_Group>;
  /** fetch data from the table: "tenant_group_member" */
  tenant_group_member: Array<Tenant_Group_Member>;
  /** fetch aggregated fields from the table: "tenant_group_member" */
  tenant_group_member_aggregate: Tenant_Group_Member_Aggregate;
  /** fetch data from the table: "tenant_group_member" using primary key columns */
  tenant_group_member_by_pk?: Maybe<Tenant_Group_Member>;
  /** fetch data from the table in a streaming manner: "tenant_group_member" */
  tenant_group_member_stream: Array<Tenant_Group_Member>;
  /** fetch data from the table in a streaming manner: "tenant_group" */
  tenant_group_stream: Array<Tenant_Group>;
  /** An array relationship */
  tenant_public_status: Array<Tenant_Public_Status>;
  /** An aggregate relationship */
  tenant_public_status_aggregate: Tenant_Public_Status_Aggregate;
  /** fetch data from the table: "tenant_public_status" using primary key columns */
  tenant_public_status_by_pk?: Maybe<Tenant_Public_Status>;
  /** fetch data from the table in a streaming manner: "tenant_public_status" */
  tenant_public_status_stream: Array<Tenant_Public_Status>;
  /** fetch data from the table: "tenant_status" */
  tenant_status: Array<Tenant_Status>;
  /** fetch aggregated fields from the table: "tenant_status" */
  tenant_status_aggregate: Tenant_Status_Aggregate;
  /** fetch data from the table: "tenant_status" using primary key columns */
  tenant_status_by_pk?: Maybe<Tenant_Status>;
  /** fetch data from the table in a streaming manner: "tenant_status" */
  tenant_status_stream: Array<Tenant_Status>;
  /** fetch data from the table in a streaming manner: "tenant" */
  tenant_stream: Array<Tenant>;
  /** fetch data from the table: "trial_leads" */
  trial_leads: Array<Trial_Leads>;
  /** fetch aggregated fields from the table: "trial_leads" */
  trial_leads_aggregate: Trial_Leads_Aggregate;
  /** fetch data from the table: "trial_leads" using primary key columns */
  trial_leads_by_pk?: Maybe<Trial_Leads>;
  /** fetch data from the table in a streaming manner: "trial_leads" */
  trial_leads_stream: Array<Trial_Leads>;
  /** fetch data from the table: "ua_audit_logs" */
  ua_audit_logs: Array<Ua_Audit_Logs>;
  /** fetch aggregated fields from the table: "ua_audit_logs" */
  ua_audit_logs_aggregate: Ua_Audit_Logs_Aggregate;
  /** fetch data from the table: "ua_audit_logs" using primary key columns */
  ua_audit_logs_by_pk?: Maybe<Ua_Audit_Logs>;
  /** fetch data from the table in a streaming manner: "ua_audit_logs" */
  ua_audit_logs_stream: Array<Ua_Audit_Logs>;
  /** fetch data from the table: "user_activity" */
  user_activity: Array<User_Activity>;
  /** fetch aggregated fields from the table: "user_activity" */
  user_activity_aggregate: User_Activity_Aggregate;
  /** fetch data from the table: "user_activity" using primary key columns */
  user_activity_by_pk?: Maybe<User_Activity>;
  /** fetch data from the table in a streaming manner: "user_activity" */
  user_activity_stream: Array<User_Activity>;
  /** fetch data from the table: "user_coupon" */
  user_coupon: Array<User_Coupon>;
  /** fetch aggregated fields from the table: "user_coupon" */
  user_coupon_aggregate: User_Coupon_Aggregate;
  /** fetch data from the table: "user_coupon" using primary key columns */
  user_coupon_by_pk?: Maybe<User_Coupon>;
  /** fetch data from the table in a streaming manner: "user_coupon" */
  user_coupon_stream: Array<User_Coupon>;
  /** fetch data from the table: "user_entitlement_access" */
  user_entitlement_access: Array<User_Entitlement_Access>;
  /** fetch aggregated fields from the table: "user_entitlement_access" */
  user_entitlement_access_aggregate: User_Entitlement_Access_Aggregate;
  /** fetch data from the table: "user_entitlement_access" using primary key columns */
  user_entitlement_access_by_pk?: Maybe<User_Entitlement_Access>;
  /** fetch data from the table in a streaming manner: "user_entitlement_access" */
  user_entitlement_access_stream: Array<User_Entitlement_Access>;
  /** fetch data from the table: "user_entitlement_catalogue" */
  user_entitlement_catalogue: Array<User_Entitlement_Catalogue>;
  /** fetch aggregated fields from the table: "user_entitlement_catalogue" */
  user_entitlement_catalogue_aggregate: User_Entitlement_Catalogue_Aggregate;
  /** fetch data from the table: "user_entitlement_catalogue" using primary key columns */
  user_entitlement_catalogue_by_pk?: Maybe<User_Entitlement_Catalogue>;
  /** fetch data from the table in a streaming manner: "user_entitlement_catalogue" */
  user_entitlement_catalogue_stream: Array<User_Entitlement_Catalogue>;
  /** fetch data from the table: "user_entitlement_types" */
  user_entitlement_types: Array<User_Entitlement_Types>;
  /** fetch aggregated fields from the table: "user_entitlement_types" */
  user_entitlement_types_aggregate: User_Entitlement_Types_Aggregate;
  /** fetch data from the table: "user_entitlement_types" using primary key columns */
  user_entitlement_types_by_pk?: Maybe<User_Entitlement_Types>;
  /** fetch data from the table in a streaming manner: "user_entitlement_types" */
  user_entitlement_types_stream: Array<User_Entitlement_Types>;
  /** fetch data from the table: "user_onboarding" */
  user_onboarding: Array<User_Onboarding>;
  /** fetch aggregated fields from the table: "user_onboarding" */
  user_onboarding_aggregate: User_Onboarding_Aggregate;
  /** fetch data from the table: "user_onboarding" using primary key columns */
  user_onboarding_by_pk?: Maybe<User_Onboarding>;
  /** fetch data from the table in a streaming manner: "user_onboarding" */
  user_onboarding_stream: Array<User_Onboarding>;
  /** fetch data from the table: "user_personal_access_tokens" */
  user_personal_access_tokens: Array<User_Personal_Access_Tokens>;
  /** fetch aggregated fields from the table: "user_personal_access_tokens" */
  user_personal_access_tokens_aggregate: User_Personal_Access_Tokens_Aggregate;
  /** fetch data from the table: "user_personal_access_tokens" using primary key columns */
  user_personal_access_tokens_by_pk?: Maybe<User_Personal_Access_Tokens>;
  /** fetch data from the table in a streaming manner: "user_personal_access_tokens" */
  user_personal_access_tokens_stream: Array<User_Personal_Access_Tokens>;
  /** fetch data from the table: "user_profile" */
  user_profile: Array<User_Profile>;
  /** fetch aggregated fields from the table: "user_profile" */
  user_profile_aggregate: User_Profile_Aggregate;
  /** fetch data from the table: "user_profile" using primary key columns */
  user_profile_by_pk?: Maybe<User_Profile>;
  /** fetch data from the table in a streaming manner: "user_profile" */
  user_profile_stream: Array<User_Profile>;
  /** fetch data from the table: "user_project_map" */
  user_project_map: Array<User_Project_Map>;
  /** fetch aggregated fields from the table: "user_project_map" */
  user_project_map_aggregate: User_Project_Map_Aggregate;
  /** fetch data from the table in a streaming manner: "user_project_map" */
  user_project_map_stream: Array<User_Project_Map>;
  /** fetch data from the table: "user_roles" */
  user_roles: Array<User_Roles>;
  /** fetch aggregated fields from the table: "user_roles" */
  user_roles_aggregate: User_Roles_Aggregate;
  /** fetch data from the table: "user_roles" using primary key columns */
  user_roles_by_pk?: Maybe<User_Roles>;
  /** fetch data from the table in a streaming manner: "user_roles" */
  user_roles_stream: Array<User_Roles>;
  /** fetch data from the table: "user_vpc_policy" */
  user_vpc_policy: Array<User_Vpc_Policy>;
  /** fetch aggregated fields from the table: "user_vpc_policy" */
  user_vpc_policy_aggregate: User_Vpc_Policy_Aggregate;
  /** fetch data from the table: "user_vpc_policy" using primary key columns */
  user_vpc_policy_by_pk?: Maybe<User_Vpc_Policy>;
  /** fetch data from the table in a streaming manner: "user_vpc_policy" */
  user_vpc_policy_stream: Array<User_Vpc_Policy>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
  /** fetch data from the table: "users_public" */
  users_public: Array<Users_Public>;
  /** fetch aggregated fields from the table: "users_public" */
  users_public_aggregate: Users_Public_Aggregate;
  /** fetch data from the table in a streaming manner: "users_public" */
  users_public_stream: Array<Users_Public>;
  /** fetch data from the table in a streaming manner: "users" */
  users_stream: Array<Users>;
  /** fetch data from the table: "vercel_integration" */
  vercel_integration: Array<Vercel_Integration>;
  /** fetch aggregated fields from the table: "vercel_integration" */
  vercel_integration_aggregate: Vercel_Integration_Aggregate;
  /** fetch data from the table: "vercel_integration" using primary key columns */
  vercel_integration_by_pk?: Maybe<Vercel_Integration>;
  /** An array relationship */
  vercel_integration_connections: Array<Vercel_Integration_Connections>;
  /** An aggregate relationship */
  vercel_integration_connections_aggregate: Vercel_Integration_Connections_Aggregate;
  /** fetch data from the table: "vercel_integration_connections" using primary key columns */
  vercel_integration_connections_by_pk?: Maybe<Vercel_Integration_Connections>;
  /** fetch data from the table in a streaming manner: "vercel_integration_connections" */
  vercel_integration_connections_stream: Array<Vercel_Integration_Connections>;
  /** fetch data from the table in a streaming manner: "vercel_integration" */
  vercel_integration_stream: Array<Vercel_Integration>;
  /** fetch data from the table: "vpc_peering" */
  vpc_peering: Array<Vpc_Peering>;
  /** fetch aggregated fields from the table: "vpc_peering" */
  vpc_peering_aggregate: Vpc_Peering_Aggregate;
  /** fetch data from the table: "vpc_peering" using primary key columns */
  vpc_peering_by_pk?: Maybe<Vpc_Peering>;
  /** fetch data from the table: "vpc_peering_direction" */
  vpc_peering_direction: Array<Vpc_Peering_Direction>;
  /** fetch aggregated fields from the table: "vpc_peering_direction" */
  vpc_peering_direction_aggregate: Vpc_Peering_Direction_Aggregate;
  /** fetch data from the table: "vpc_peering_direction" using primary key columns */
  vpc_peering_direction_by_pk?: Maybe<Vpc_Peering_Direction>;
  /** fetch data from the table in a streaming manner: "vpc_peering_direction" */
  vpc_peering_direction_stream: Array<Vpc_Peering_Direction>;
  /** fetch data from the table in a streaming manner: "vpc_peering" */
  vpc_peering_stream: Array<Vpc_Peering>;
  /** fetch data from the table: "vpc_status" */
  vpc_status: Array<Vpc_Status>;
  /** fetch aggregated fields from the table: "vpc_status" */
  vpc_status_aggregate: Vpc_Status_Aggregate;
  /** fetch data from the table: "vpc_status" using primary key columns */
  vpc_status_by_pk?: Maybe<Vpc_Status>;
  /** fetch data from the table in a streaming manner: "vpc_status" */
  vpc_status_stream: Array<Vpc_Status>;
  /** fetch data from the table: "zendesk_support_category" */
  zendesk_support_category: Array<Zendesk_Support_Category>;
  /** fetch aggregated fields from the table: "zendesk_support_category" */
  zendesk_support_category_aggregate: Zendesk_Support_Category_Aggregate;
  /** fetch data from the table: "zendesk_support_category" using primary key columns */
  zendesk_support_category_by_pk?: Maybe<Zendesk_Support_Category>;
  /** fetch data from the table in a streaming manner: "zendesk_support_category" */
  zendesk_support_category_stream: Array<Zendesk_Support_Category>;
  /** fetch data from the table: "zendesk_support_tickets" */
  zendesk_support_tickets: Array<Zendesk_Support_Tickets>;
  /** fetch aggregated fields from the table: "zendesk_support_tickets" */
  zendesk_support_tickets_aggregate: Zendesk_Support_Tickets_Aggregate;
  /** fetch data from the table: "zendesk_support_tickets" using primary key columns */
  zendesk_support_tickets_by_pk?: Maybe<Zendesk_Support_Tickets>;
  /** fetch data from the table in a streaming manner: "zendesk_support_tickets" */
  zendesk_support_tickets_stream: Array<Zendesk_Support_Tickets>;
};

export type Subscription_RootAlert_ConfigArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Order_By>>;
  where?: Maybe<Alert_Config_Bool_Exp>;
};

export type Subscription_RootAlert_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Order_By>>;
  where?: Maybe<Alert_Config_Bool_Exp>;
};

export type Subscription_RootAlert_Config_Alert_TypeArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Alert_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Alert_Type_Order_By>>;
  where?: Maybe<Alert_Config_Alert_Type_Bool_Exp>;
};

export type Subscription_RootAlert_Config_Alert_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Alert_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Alert_Type_Order_By>>;
  where?: Maybe<Alert_Config_Alert_Type_Bool_Exp>;
};

export type Subscription_RootAlert_Config_Alert_Type_By_PkArgs = {
  project_id: Scalars['uuid'];
  type: Scalars['String'];
};

export type Subscription_RootAlert_Config_Alert_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Alert_Config_Alert_Type_Stream_Cursor_Input>>;
  where?: Maybe<Alert_Config_Alert_Type_Bool_Exp>;
};

export type Subscription_RootAlert_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Subscription_RootAlert_Config_ServiceArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Service_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Service_Order_By>>;
  where?: Maybe<Alert_Config_Service_Bool_Exp>;
};

export type Subscription_RootAlert_Config_Service_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Config_Service_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Config_Service_Order_By>>;
  where?: Maybe<Alert_Config_Service_Bool_Exp>;
};

export type Subscription_RootAlert_Config_Service_By_PkArgs = {
  project_id: Scalars['uuid'];
  type: Alert_Service_Type_Enum;
};

export type Subscription_RootAlert_Config_Service_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Alert_Config_Service_Stream_Cursor_Input>>;
  where?: Maybe<Alert_Config_Service_Bool_Exp>;
};

export type Subscription_RootAlert_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Alert_Config_Stream_Cursor_Input>>;
  where?: Maybe<Alert_Config_Bool_Exp>;
};

export type Subscription_RootAlert_Service_TypeArgs = {
  distinct_on?: Maybe<Array<Alert_Service_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Service_Type_Order_By>>;
  where?: Maybe<Alert_Service_Type_Bool_Exp>;
};

export type Subscription_RootAlert_Service_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Service_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Service_Type_Order_By>>;
  where?: Maybe<Alert_Service_Type_Bool_Exp>;
};

export type Subscription_RootAlert_Service_Type_By_PkArgs = {
  name: Scalars['String'];
};

export type Subscription_RootAlert_Service_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Alert_Service_Type_Stream_Cursor_Input>>;
  where?: Maybe<Alert_Service_Type_Bool_Exp>;
};

export type Subscription_RootAlert_TypeArgs = {
  distinct_on?: Maybe<Array<Alert_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Type_Order_By>>;
  where?: Maybe<Alert_Type_Bool_Exp>;
};

export type Subscription_RootAlert_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Alert_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Alert_Type_Order_By>>;
  where?: Maybe<Alert_Type_Bool_Exp>;
};

export type Subscription_RootAlert_Type_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootAlert_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Alert_Type_Stream_Cursor_Input>>;
  where?: Maybe<Alert_Type_Bool_Exp>;
};

export type Subscription_RootAzuremonitor_ConfigArgs = {
  distinct_on?: Maybe<Array<Azuremonitor_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Azuremonitor_Config_Order_By>>;
  where?: Maybe<Azuremonitor_Config_Bool_Exp>;
};

export type Subscription_RootAzuremonitor_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Azuremonitor_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Azuremonitor_Config_Order_By>>;
  where?: Maybe<Azuremonitor_Config_Bool_Exp>;
};

export type Subscription_RootAzuremonitor_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Subscription_RootAzuremonitor_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Azuremonitor_Config_Stream_Cursor_Input>>;
  where?: Maybe<Azuremonitor_Config_Bool_Exp>;
};

export type Subscription_RootBilling_AddressArgs = {
  distinct_on?: Maybe<Array<Billing_Address_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Billing_Address_Order_By>>;
  where?: Maybe<Billing_Address_Bool_Exp>;
};

export type Subscription_RootBilling_Address_AggregateArgs = {
  distinct_on?: Maybe<Array<Billing_Address_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Billing_Address_Order_By>>;
  where?: Maybe<Billing_Address_Bool_Exp>;
};

export type Subscription_RootBilling_Address_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootBilling_Address_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Billing_Address_Stream_Cursor_Input>>;
  where?: Maybe<Billing_Address_Bool_Exp>;
};

export type Subscription_RootCentral_CloudArgs = {
  distinct_on?: Maybe<Array<Central_Cloud_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Central_Cloud_Order_By>>;
  where?: Maybe<Central_Cloud_Bool_Exp>;
};

export type Subscription_RootCentral_Cloud_AggregateArgs = {
  distinct_on?: Maybe<Array<Central_Cloud_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Central_Cloud_Order_By>>;
  where?: Maybe<Central_Cloud_Bool_Exp>;
};

export type Subscription_RootCentral_Cloud_By_PkArgs = {
  cloud: Cloud_Enum;
};

export type Subscription_RootCentral_Cloud_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Central_Cloud_Stream_Cursor_Input>>;
  where?: Maybe<Central_Cloud_Bool_Exp>;
};

export type Subscription_RootChange_Email_RequestArgs = {
  distinct_on?: Maybe<Array<Change_Email_Request_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Change_Email_Request_Order_By>>;
  where?: Maybe<Change_Email_Request_Bool_Exp>;
};

export type Subscription_RootChange_Email_Request_AggregateArgs = {
  distinct_on?: Maybe<Array<Change_Email_Request_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Change_Email_Request_Order_By>>;
  where?: Maybe<Change_Email_Request_Bool_Exp>;
};

export type Subscription_RootChange_Email_Request_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootChange_Email_Request_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Change_Email_Request_Stream_Cursor_Input>>;
  where?: Maybe<Change_Email_Request_Bool_Exp>;
};

export type Subscription_RootCicd_Deployment_Pipeline_ConfigArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pipeline_Config_Bool_Exp>;
};

export type Subscription_RootCicd_Deployment_Pipeline_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pipeline_Config_Bool_Exp>;
};

export type Subscription_RootCicd_Deployment_Pipeline_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootCicd_Deployment_Pipeline_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Cicd_Deployment_Pipeline_Config_Stream_Cursor_Input>>;
  where?: Maybe<Cicd_Deployment_Pipeline_Config_Bool_Exp>;
};

export type Subscription_RootCicd_Deployment_PoolArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Bool_Exp>;
};

export type Subscription_RootCicd_Deployment_Pool_AggregateArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Bool_Exp>;
};

export type Subscription_RootCicd_Deployment_Pool_MemberArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Member_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
};

export type Subscription_RootCicd_Deployment_Pool_Member_AggregateArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Member_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
};

export type Subscription_RootCicd_Deployment_Pool_Member_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Cicd_Deployment_Pool_Member_Stream_Cursor_Input>>;
  where?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
};

export type Subscription_RootCicd_Deployment_Pool_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Cicd_Deployment_Pool_Stream_Cursor_Input>>;
  where?: Maybe<Cicd_Deployment_Pool_Bool_Exp>;
};

export type Subscription_RootCicd_Get_Matching_Pipeline_ConfigArgs = {
  args: Cicd_Get_Matching_Pipeline_Config_Args;
  distinct_on?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pipeline_Config_Bool_Exp>;
};

export type Subscription_RootCicd_Get_Matching_Pipeline_Config_AggregateArgs = {
  args: Cicd_Get_Matching_Pipeline_Config_Args;
  distinct_on?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pipeline_Config_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pipeline_Config_Bool_Exp>;
};

export type Subscription_RootCloudArgs = {
  distinct_on?: Maybe<Array<Cloud_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Order_By>>;
  where?: Maybe<Cloud_Bool_Exp>;
};

export type Subscription_RootCloud_AggregateArgs = {
  distinct_on?: Maybe<Array<Cloud_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Order_By>>;
  where?: Maybe<Cloud_Bool_Exp>;
};

export type Subscription_RootCloud_By_PkArgs = {
  name: Scalars['String'];
};

export type Subscription_RootCloud_MetadataArgs = {
  distinct_on?: Maybe<Array<Cloud_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Metadata_Order_By>>;
  where?: Maybe<Cloud_Metadata_Bool_Exp>;
};

export type Subscription_RootCloud_Metadata_AggregateArgs = {
  distinct_on?: Maybe<Array<Cloud_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Metadata_Order_By>>;
  where?: Maybe<Cloud_Metadata_Bool_Exp>;
};

export type Subscription_RootCloud_Metadata_By_PkArgs = {
  cloud: Cloud_Enum;
};

export type Subscription_RootCloud_Metadata_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Cloud_Metadata_Stream_Cursor_Input>>;
  where?: Maybe<Cloud_Metadata_Bool_Exp>;
};

export type Subscription_RootCloud_Regions_By_PlanArgs = {
  distinct_on?: Maybe<Array<Cloud_Regions_By_Plan_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Regions_By_Plan_Order_By>>;
  where?: Maybe<Cloud_Regions_By_Plan_Bool_Exp>;
};

export type Subscription_RootCloud_Regions_By_Plan_AggregateArgs = {
  distinct_on?: Maybe<Array<Cloud_Regions_By_Plan_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cloud_Regions_By_Plan_Order_By>>;
  where?: Maybe<Cloud_Regions_By_Plan_Bool_Exp>;
};

export type Subscription_RootCloud_Regions_By_Plan_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Cloud_Regions_By_Plan_Stream_Cursor_Input>>;
  where?: Maybe<Cloud_Regions_By_Plan_Bool_Exp>;
};

export type Subscription_RootCloud_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Cloud_Stream_Cursor_Input>>;
  where?: Maybe<Cloud_Bool_Exp>;
};

export type Subscription_RootCompute_Project_Agg_Db_Usage_UserArgs = {
  args: Compute_Project_Agg_Db_Usage_User_Args;
  distinct_on?: Maybe<Array<Project_Db_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Db_Usage_Agg_User_Bool_Exp>;
};

export type Subscription_RootCompute_Project_Agg_Db_Usage_User_AggregateArgs = {
  args: Compute_Project_Agg_Db_Usage_User_Args;
  distinct_on?: Maybe<Array<Project_Db_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Db_Usage_Agg_User_Bool_Exp>;
};

export type Subscription_RootCompute_Project_Agg_UsageArgs = {
  args: Compute_Project_Agg_Usage_Args;
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Subscription_RootCompute_Project_Agg_Usage_AggregateArgs = {
  args: Compute_Project_Agg_Usage_Args;
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Subscription_RootCompute_Project_Agg_Usage_PrometheusArgs = {
  args: Compute_Project_Agg_Usage_Prometheus_Args;
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Subscription_RootCompute_Project_Agg_Usage_Prometheus_AggregateArgs =
  {
    args: Compute_Project_Agg_Usage_Prometheus_Args;
    distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
    where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
  };

export type Subscription_RootCompute_Project_Agg_Usage_Prometheus_UserArgs = {
  args: Compute_Project_Agg_Usage_Prometheus_User_Args;
  distinct_on?: Maybe<
    Array<Project_Data_Usage_Prometheus_Agg_User_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>;
};

export type Subscription_RootCompute_Project_Agg_Usage_Prometheus_User_AggregateArgs =
  {
    args: Compute_Project_Agg_Usage_Prometheus_User_Args;
    distinct_on?: Maybe<
      Array<Project_Data_Usage_Prometheus_Agg_User_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Agg_User_Order_By>>;
    where?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>;
  };

export type Subscription_RootCompute_Project_Agg_Usage_UserArgs = {
  args: Compute_Project_Agg_Usage_User_Args;
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_User_Bool_Exp>;
};

export type Subscription_RootCompute_Project_Agg_Usage_User_AggregateArgs = {
  args: Compute_Project_Agg_Usage_User_Args;
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_User_Bool_Exp>;
};

export type Subscription_RootCompute_Unit_ConfigArgs = {
  distinct_on?: Maybe<Array<Compute_Unit_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Compute_Unit_Config_Order_By>>;
  where?: Maybe<Compute_Unit_Config_Bool_Exp>;
};

export type Subscription_RootCompute_Unit_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Compute_Unit_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Compute_Unit_Config_Order_By>>;
  where?: Maybe<Compute_Unit_Config_Bool_Exp>;
};

export type Subscription_RootCompute_Unit_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootCompute_Unit_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Compute_Unit_Config_Stream_Cursor_Input>>;
  where?: Maybe<Compute_Unit_Config_Bool_Exp>;
};

export type Subscription_RootConfigArgs = {
  distinct_on?: Maybe<Array<Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Order_By>>;
  where?: Maybe<Config_Bool_Exp>;
};

export type Subscription_RootConfig_AggregateArgs = {
  distinct_on?: Maybe<Array<Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Order_By>>;
  where?: Maybe<Config_Bool_Exp>;
};

export type Subscription_RootConfig_By_PkArgs = {
  tenant_id: Scalars['uuid'];
};

export type Subscription_RootConfig_StatusArgs = {
  distinct_on?: Maybe<Array<Config_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Status_Order_By>>;
  where?: Maybe<Config_Status_Bool_Exp>;
};

export type Subscription_RootConfig_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Config_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Config_Status_Order_By>>;
  where?: Maybe<Config_Status_Bool_Exp>;
};

export type Subscription_RootConfig_Status_By_PkArgs = {
  hash: Scalars['String'];
  tenant_id: Scalars['uuid'];
  worker_id: Scalars['uuid'];
};

export type Subscription_RootConfig_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Config_Status_Stream_Cursor_Input>>;
  where?: Maybe<Config_Status_Bool_Exp>;
};

export type Subscription_RootConfig_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Config_Stream_Cursor_Input>>;
  where?: Maybe<Config_Bool_Exp>;
};

export type Subscription_RootConnector_ConfigArgs = {
  distinct_on?: Maybe<Array<Connector_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Config_Order_By>>;
  where?: Maybe<Connector_Config_Bool_Exp>;
};

export type Subscription_RootConnector_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Connector_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Config_Order_By>>;
  where?: Maybe<Connector_Config_Bool_Exp>;
};

export type Subscription_RootConnector_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootConnector_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Connector_Config_Stream_Cursor_Input>>;
  where?: Maybe<Connector_Config_Bool_Exp>;
};

export type Subscription_RootConnector_DeploymentArgs = {
  distinct_on?: Maybe<Array<Connector_Connector_Deployment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Connector_Deployment_Order_By>>;
  where?: Maybe<Connector_Connector_Deployment_Bool_Exp>;
};

export type Subscription_RootConnector_Deployment_AggregateArgs = {
  distinct_on?: Maybe<Array<Connector_Connector_Deployment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Connector_Deployment_Order_By>>;
  where?: Maybe<Connector_Connector_Deployment_Bool_Exp>;
};

export type Subscription_RootConnector_Deployment_By_PkArgs = {
  id: Scalars['connector_uuid'];
};

export type Subscription_RootConnector_Deployment_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Connector_Connector_Deployment_Stream_Cursor_Input>>;
  where?: Maybe<Connector_Connector_Deployment_Bool_Exp>;
};

export type Subscription_RootConnector_DeploymentsArgs = {
  distinct_on?: Maybe<Array<Connector_Deployments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Deployments_Order_By>>;
  where?: Maybe<Connector_Deployments_Bool_Exp>;
};

export type Subscription_RootConnector_Deployments_AggregateArgs = {
  distinct_on?: Maybe<Array<Connector_Deployments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Connector_Deployments_Order_By>>;
  where?: Maybe<Connector_Deployments_Bool_Exp>;
};

export type Subscription_RootConnector_Deployments_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootConnector_Deployments_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Connector_Deployments_Stream_Cursor_Input>>;
  where?: Maybe<Connector_Deployments_Bool_Exp>;
};

export type Subscription_RootCouponArgs = {
  distinct_on?: Maybe<Array<Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Order_By>>;
  where?: Maybe<Coupon_Bool_Exp>;
};

export type Subscription_RootCoupon_AggregateArgs = {
  distinct_on?: Maybe<Array<Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Order_By>>;
  where?: Maybe<Coupon_Bool_Exp>;
};

export type Subscription_RootCoupon_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootCoupon_DurationArgs = {
  distinct_on?: Maybe<Array<Coupon_Duration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Duration_Order_By>>;
  where?: Maybe<Coupon_Duration_Bool_Exp>;
};

export type Subscription_RootCoupon_Duration_AggregateArgs = {
  distinct_on?: Maybe<Array<Coupon_Duration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Duration_Order_By>>;
  where?: Maybe<Coupon_Duration_Bool_Exp>;
};

export type Subscription_RootCoupon_Duration_By_PkArgs = {
  duration: Scalars['String'];
};

export type Subscription_RootCoupon_Duration_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Coupon_Duration_Stream_Cursor_Input>>;
  where?: Maybe<Coupon_Duration_Bool_Exp>;
};

export type Subscription_RootCoupon_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Coupon_Stream_Cursor_Input>>;
  where?: Maybe<Coupon_Bool_Exp>;
};

export type Subscription_RootCoupon_TypeArgs = {
  distinct_on?: Maybe<Array<Coupon_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Type_Order_By>>;
  where?: Maybe<Coupon_Type_Bool_Exp>;
};

export type Subscription_RootCoupon_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Coupon_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Coupon_Type_Order_By>>;
  where?: Maybe<Coupon_Type_Bool_Exp>;
};

export type Subscription_RootCoupon_Type_By_PkArgs = {
  type: Scalars['String'];
};

export type Subscription_RootCoupon_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Coupon_Type_Stream_Cursor_Input>>;
  where?: Maybe<Coupon_Type_Bool_Exp>;
};

export type Subscription_RootCustom_DomainArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Order_By>>;
  where?: Maybe<Custom_Domain_Bool_Exp>;
};

export type Subscription_RootCustom_Domain_AggregateArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Order_By>>;
  where?: Maybe<Custom_Domain_Bool_Exp>;
};

export type Subscription_RootCustom_Domain_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootCustom_Domain_CloudflareArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Cloudflare_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Cloudflare_Order_By>>;
  where?: Maybe<Custom_Domain_Cloudflare_Bool_Exp>;
};

export type Subscription_RootCustom_Domain_Cloudflare_AggregateArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Cloudflare_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Cloudflare_Order_By>>;
  where?: Maybe<Custom_Domain_Cloudflare_Bool_Exp>;
};

export type Subscription_RootCustom_Domain_Cloudflare_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootCustom_Domain_Cloudflare_DnsArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Cloudflare_Dns_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Cloudflare_Dns_Order_By>>;
  where?: Maybe<Custom_Domain_Cloudflare_Dns_Bool_Exp>;
};

export type Subscription_RootCustom_Domain_Cloudflare_Dns_AggregateArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Cloudflare_Dns_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Cloudflare_Dns_Order_By>>;
  where?: Maybe<Custom_Domain_Cloudflare_Dns_Bool_Exp>;
};

export type Subscription_RootCustom_Domain_Cloudflare_Dns_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootCustom_Domain_Cloudflare_Dns_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Custom_Domain_Cloudflare_Dns_Stream_Cursor_Input>>;
  where?: Maybe<Custom_Domain_Cloudflare_Dns_Bool_Exp>;
};

export type Subscription_RootCustom_Domain_Cloudflare_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Custom_Domain_Cloudflare_Stream_Cursor_Input>>;
  where?: Maybe<Custom_Domain_Cloudflare_Bool_Exp>;
};

export type Subscription_RootCustom_Domain_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Custom_Domain_Stream_Cursor_Input>>;
  where?: Maybe<Custom_Domain_Bool_Exp>;
};

export type Subscription_RootCustomer_UsageArgs = {
  distinct_on?: Maybe<Array<Customer_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Usage_Order_By>>;
  where?: Maybe<Customer_Usage_Bool_Exp>;
};

export type Subscription_RootCustomer_Usage_AggregateArgs = {
  distinct_on?: Maybe<Array<Customer_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Usage_Order_By>>;
  where?: Maybe<Customer_Usage_Bool_Exp>;
};

export type Subscription_RootCustomer_Usage_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootCustomer_Usage_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Customer_Usage_Stream_Cursor_Input>>;
  where?: Maybe<Customer_Usage_Bool_Exp>;
};

export type Subscription_RootData_Connector_TypeArgs = {
  distinct_on?: Maybe<Array<Data_Connector_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Data_Connector_Type_Order_By>>;
  where?: Maybe<Data_Connector_Type_Bool_Exp>;
};

export type Subscription_RootData_Connector_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Data_Connector_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Data_Connector_Type_Order_By>>;
  where?: Maybe<Data_Connector_Type_Bool_Exp>;
};

export type Subscription_RootData_Connector_Type_By_PkArgs = {
  name: Scalars['String'];
};

export type Subscription_RootData_Connector_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Data_Connector_Type_Stream_Cursor_Input>>;
  where?: Maybe<Data_Connector_Type_Bool_Exp>;
};

export type Subscription_RootDatadog_ConfigArgs = {
  distinct_on?: Maybe<Array<Datadog_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Datadog_Config_Order_By>>;
  where?: Maybe<Datadog_Config_Bool_Exp>;
};

export type Subscription_RootDatadog_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Datadog_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Datadog_Config_Order_By>>;
  where?: Maybe<Datadog_Config_Bool_Exp>;
};

export type Subscription_RootDatadog_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Subscription_RootDatadog_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Datadog_Config_Stream_Cursor_Input>>;
  where?: Maybe<Datadog_Config_Bool_Exp>;
};

export type Subscription_RootDb_LatencyArgs = {
  distinct_on?: Maybe<Array<Db_Latency_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Db_Latency_Order_By>>;
  where?: Maybe<Db_Latency_Bool_Exp>;
};

export type Subscription_RootDb_Latency_AggregateArgs = {
  distinct_on?: Maybe<Array<Db_Latency_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Db_Latency_Order_By>>;
  where?: Maybe<Db_Latency_Bool_Exp>;
};

export type Subscription_RootDb_Latency_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDb_Latency_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Db_Latency_Stream_Cursor_Input>>;
  where?: Maybe<Db_Latency_Bool_Exp>;
};

export type Subscription_RootDdn_BuildArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Order_By>>;
  where?: Maybe<Ddn_Build_Bool_Exp>;
};

export type Subscription_RootDdn_Build_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Order_By>>;
  where?: Maybe<Ddn_Build_Bool_Exp>;
};

export type Subscription_RootDdn_Build_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDdn_Build_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Ddn_Build_Stream_Cursor_Input>>;
  where?: Maybe<Ddn_Build_Bool_Exp>;
};

export type Subscription_RootDdn_Build_Sync_StatusArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Status_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

export type Subscription_RootDdn_Build_Sync_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Status_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

export type Subscription_RootDdn_Build_Sync_Status_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDdn_Build_Sync_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Ddn_Build_Sync_Status_Stream_Cursor_Input>>;
  where?: Maybe<Ddn_Build_Sync_Status_Bool_Exp>;
};

export type Subscription_RootDdn_Build_Sync_WorkerArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Worker_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Worker_Bool_Exp>;
};

export type Subscription_RootDdn_Build_Sync_Worker_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Build_Sync_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Build_Sync_Worker_Order_By>>;
  where?: Maybe<Ddn_Build_Sync_Worker_Bool_Exp>;
};

export type Subscription_RootDdn_Build_Sync_Worker_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDdn_Build_Sync_Worker_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Ddn_Build_Sync_Worker_Stream_Cursor_Input>>;
  where?: Maybe<Ddn_Build_Sync_Worker_Bool_Exp>;
};

export type Subscription_RootDdn_EnvironmentArgs = {
  distinct_on?: Maybe<Array<Ddn_Environment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Environment_Order_By>>;
  where?: Maybe<Ddn_Environment_Bool_Exp>;
};

export type Subscription_RootDdn_Environment_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Environment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Environment_Order_By>>;
  where?: Maybe<Ddn_Environment_Bool_Exp>;
};

export type Subscription_RootDdn_Environment_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDdn_Environment_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Ddn_Environment_Stream_Cursor_Input>>;
  where?: Maybe<Ddn_Environment_Bool_Exp>;
};

export type Subscription_RootDdn_Project_Entitlement_AccessArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Access_Bool_Exp>;
};

export type Subscription_RootDdn_Project_Entitlement_Access_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Access_Bool_Exp>;
};

export type Subscription_RootDdn_Project_Entitlement_Access_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDdn_Project_Entitlement_Access_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Ddn_Project_Entitlement_Access_Stream_Cursor_Input>>;
  where?: Maybe<Ddn_Project_Entitlement_Access_Bool_Exp>;
};

export type Subscription_RootDdn_Project_Entitlement_CatalogueArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Catalogue_Bool_Exp>;
};

export type Subscription_RootDdn_Project_Entitlement_Catalogue_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Catalogue_Bool_Exp>;
};

export type Subscription_RootDdn_Project_Entitlement_Catalogue_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDdn_Project_Entitlement_Catalogue_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Ddn_Project_Entitlement_Catalogue_Stream_Cursor_Input>>;
  where?: Maybe<Ddn_Project_Entitlement_Catalogue_Bool_Exp>;
};

export type Subscription_RootDdn_Project_Entitlement_TypesArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Types_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Types_Bool_Exp>;
};

export type Subscription_RootDdn_Project_Entitlement_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Project_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Project_Entitlement_Types_Order_By>>;
  where?: Maybe<Ddn_Project_Entitlement_Types_Bool_Exp>;
};

export type Subscription_RootDdn_Project_Entitlement_Types_By_PkArgs = {
  value: Scalars['String'];
};

export type Subscription_RootDdn_Project_Entitlement_Types_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Ddn_Project_Entitlement_Types_Stream_Cursor_Input>>;
  where?: Maybe<Ddn_Project_Entitlement_Types_Bool_Exp>;
};

export type Subscription_RootDdn_ProjectsArgs = {
  distinct_on?: Maybe<Array<Ddn_Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Projects_Order_By>>;
  where?: Maybe<Ddn_Projects_Bool_Exp>;
};

export type Subscription_RootDdn_Projects_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Projects_Order_By>>;
  where?: Maybe<Ddn_Projects_Bool_Exp>;
};

export type Subscription_RootDdn_Projects_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDdn_Projects_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Ddn_Projects_Stream_Cursor_Input>>;
  where?: Maybe<Ddn_Projects_Bool_Exp>;
};

export type Subscription_RootDdn_TunnelArgs = {
  distinct_on?: Maybe<Array<Ddn_Tunnel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Tunnel_Order_By>>;
  where?: Maybe<Ddn_Tunnel_Bool_Exp>;
};

export type Subscription_RootDdn_Tunnel_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Tunnel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Tunnel_Order_By>>;
  where?: Maybe<Ddn_Tunnel_Bool_Exp>;
};

export type Subscription_RootDdn_Tunnel_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDdn_Tunnel_ClusterArgs = {
  distinct_on?: Maybe<Array<Ddn_Tunnel_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Tunnel_Cluster_Order_By>>;
  where?: Maybe<Ddn_Tunnel_Cluster_Bool_Exp>;
};

export type Subscription_RootDdn_Tunnel_Cluster_AggregateArgs = {
  distinct_on?: Maybe<Array<Ddn_Tunnel_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ddn_Tunnel_Cluster_Order_By>>;
  where?: Maybe<Ddn_Tunnel_Cluster_Bool_Exp>;
};

export type Subscription_RootDdn_Tunnel_Cluster_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDdn_Tunnel_Cluster_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Ddn_Tunnel_Cluster_Stream_Cursor_Input>>;
  where?: Maybe<Ddn_Tunnel_Cluster_Bool_Exp>;
};

export type Subscription_RootDdn_Tunnel_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Ddn_Tunnel_Stream_Cursor_Input>>;
  where?: Maybe<Ddn_Tunnel_Bool_Exp>;
};

export type Subscription_RootDedicated_Cloud_BillsArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
};

export type Subscription_RootDedicated_Cloud_Bills_AggregateArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
};

export type Subscription_RootDedicated_Cloud_Bills_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDedicated_Cloud_Bills_DetailsArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Details_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Details_Bool_Exp>;
};

export type Subscription_RootDedicated_Cloud_Bills_Details_AggregateArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Bills_Details_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Bills_Details_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Bills_Details_Bool_Exp>;
};

export type Subscription_RootDedicated_Cloud_Bills_Details_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDedicated_Cloud_Bills_Details_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Dedicated_Cloud_Bills_Details_Stream_Cursor_Input>>;
  where?: Maybe<Dedicated_Cloud_Bills_Details_Bool_Exp>;
};

export type Subscription_RootDedicated_Cloud_Bills_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Dedicated_Cloud_Bills_Stream_Cursor_Input>>;
  where?: Maybe<Dedicated_Cloud_Bills_Bool_Exp>;
};

export type Subscription_RootDedicated_Cloud_CommitmentsArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Commitments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Commitments_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Commitments_Bool_Exp>;
};

export type Subscription_RootDedicated_Cloud_Commitments_AggregateArgs = {
  distinct_on?: Maybe<Array<Dedicated_Cloud_Commitments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Cloud_Commitments_Order_By>>;
  where?: Maybe<Dedicated_Cloud_Commitments_Bool_Exp>;
};

export type Subscription_RootDedicated_Cloud_Commitments_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDedicated_Cloud_Commitments_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Dedicated_Cloud_Commitments_Stream_Cursor_Input>>;
  where?: Maybe<Dedicated_Cloud_Commitments_Bool_Exp>;
};

export type Subscription_RootDedicated_VpcArgs = {
  distinct_on?: Maybe<Array<Dedicated_Vpc_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Vpc_Order_By>>;
  where?: Maybe<Dedicated_Vpc_Bool_Exp>;
};

export type Subscription_RootDedicated_Vpc_AggregateArgs = {
  distinct_on?: Maybe<Array<Dedicated_Vpc_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Dedicated_Vpc_Order_By>>;
  where?: Maybe<Dedicated_Vpc_Bool_Exp>;
};

export type Subscription_RootDedicated_Vpc_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootDedicated_Vpc_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Dedicated_Vpc_Stream_Cursor_Input>>;
  where?: Maybe<Dedicated_Vpc_Bool_Exp>;
};

export type Subscription_RootDelete_UserArgs = {
  distinct_on?: Maybe<Array<Delete_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Order_By>>;
  where?: Maybe<Delete_User_Bool_Exp>;
};

export type Subscription_RootDelete_User_AggregateArgs = {
  distinct_on?: Maybe<Array<Delete_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Order_By>>;
  where?: Maybe<Delete_User_Bool_Exp>;
};

export type Subscription_RootDelete_User_By_PkArgs = {
  user_id: Scalars['uuid'];
};

export type Subscription_RootDelete_User_StatusArgs = {
  distinct_on?: Maybe<Array<Delete_User_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Status_Order_By>>;
  where?: Maybe<Delete_User_Status_Bool_Exp>;
};

export type Subscription_RootDelete_User_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Delete_User_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Status_Order_By>>;
  where?: Maybe<Delete_User_Status_Bool_Exp>;
};

export type Subscription_RootDelete_User_Status_By_PkArgs = {
  status: Scalars['String'];
};

export type Subscription_RootDelete_User_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Delete_User_Status_Stream_Cursor_Input>>;
  where?: Maybe<Delete_User_Status_Bool_Exp>;
};

export type Subscription_RootDelete_User_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Delete_User_Stream_Cursor_Input>>;
  where?: Maybe<Delete_User_Bool_Exp>;
};

export type Subscription_RootDelete_User_TasksArgs = {
  distinct_on?: Maybe<Array<Delete_User_Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Tasks_Order_By>>;
  where?: Maybe<Delete_User_Tasks_Bool_Exp>;
};

export type Subscription_RootDelete_User_Tasks_AggregateArgs = {
  distinct_on?: Maybe<Array<Delete_User_Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Delete_User_Tasks_Order_By>>;
  where?: Maybe<Delete_User_Tasks_Bool_Exp>;
};

export type Subscription_RootDelete_User_Tasks_By_PkArgs = {
  task_name: Scalars['String'];
  user_id: Scalars['uuid'];
};

export type Subscription_RootDelete_User_Tasks_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Delete_User_Tasks_Stream_Cursor_Input>>;
  where?: Maybe<Delete_User_Tasks_Bool_Exp>;
};

export type Subscription_RootEmail_LogArgs = {
  distinct_on?: Maybe<Array<Email_Log_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Email_Log_Order_By>>;
  where?: Maybe<Email_Log_Bool_Exp>;
};

export type Subscription_RootEmail_Log_AggregateArgs = {
  distinct_on?: Maybe<Array<Email_Log_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Email_Log_Order_By>>;
  where?: Maybe<Email_Log_Bool_Exp>;
};

export type Subscription_RootEmail_Log_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootEmail_Log_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Email_Log_Stream_Cursor_Input>>;
  where?: Maybe<Email_Log_Bool_Exp>;
};

export type Subscription_RootEnterprise_UsersArgs = {
  distinct_on?: Maybe<Array<Enterprise_Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Enterprise_Users_Order_By>>;
  where?: Maybe<Enterprise_Users_Bool_Exp>;
};

export type Subscription_RootEnterprise_Users_AggregateArgs = {
  distinct_on?: Maybe<Array<Enterprise_Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Enterprise_Users_Order_By>>;
  where?: Maybe<Enterprise_Users_Bool_Exp>;
};

export type Subscription_RootEnterprise_Users_By_PkArgs = {
  customer_email: Scalars['citext'];
};

export type Subscription_RootEnterprise_Users_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Enterprise_Users_Stream_Cursor_Input>>;
  where?: Maybe<Enterprise_Users_Bool_Exp>;
};

export type Subscription_RootExperimentsArgs = {
  distinct_on?: Maybe<Array<Experiments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Order_By>>;
  where?: Maybe<Experiments_Bool_Exp>;
};

export type Subscription_RootExperiments_AggregateArgs = {
  distinct_on?: Maybe<Array<Experiments_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Order_By>>;
  where?: Maybe<Experiments_Bool_Exp>;
};

export type Subscription_RootExperiments_By_PkArgs = {
  experiment: Scalars['String'];
};

export type Subscription_RootExperiments_CohortArgs = {
  distinct_on?: Maybe<Array<Experiments_Cohort_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Cohort_Order_By>>;
  where?: Maybe<Experiments_Cohort_Bool_Exp>;
};

export type Subscription_RootExperiments_Cohort_AggregateArgs = {
  distinct_on?: Maybe<Array<Experiments_Cohort_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Cohort_Order_By>>;
  where?: Maybe<Experiments_Cohort_Bool_Exp>;
};

export type Subscription_RootExperiments_Cohort_By_PkArgs = {
  experiment: Experiments_Enum;
  user_id: Scalars['uuid'];
};

export type Subscription_RootExperiments_Cohort_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Experiments_Cohort_Stream_Cursor_Input>>;
  where?: Maybe<Experiments_Cohort_Bool_Exp>;
};

export type Subscription_RootExperiments_ConfigArgs = {
  distinct_on?: Maybe<Array<Experiments_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Config_Order_By>>;
  where?: Maybe<Experiments_Config_Bool_Exp>;
};

export type Subscription_RootExperiments_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Experiments_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Experiments_Config_Order_By>>;
  where?: Maybe<Experiments_Config_Bool_Exp>;
};

export type Subscription_RootExperiments_Config_By_PkArgs = {
  experiment: Experiments_Enum;
};

export type Subscription_RootExperiments_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Experiments_Config_Stream_Cursor_Input>>;
  where?: Maybe<Experiments_Config_Bool_Exp>;
};

export type Subscription_RootExperiments_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Experiments_Stream_Cursor_Input>>;
  where?: Maybe<Experiments_Bool_Exp>;
};

export type Subscription_RootFeatureArgs = {
  distinct_on?: Maybe<Array<Feature_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Order_By>>;
  where?: Maybe<Feature_Bool_Exp>;
};

export type Subscription_RootFeature_AccessArgs = {
  distinct_on?: Maybe<Array<Feature_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Access_Order_By>>;
  where?: Maybe<Feature_Access_Bool_Exp>;
};

export type Subscription_RootFeature_Access_AggregateArgs = {
  distinct_on?: Maybe<Array<Feature_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Access_Order_By>>;
  where?: Maybe<Feature_Access_Bool_Exp>;
};

export type Subscription_RootFeature_Access_By_PkArgs = {
  email: Scalars['String'];
  feature: Feature_Enum;
};

export type Subscription_RootFeature_Access_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Feature_Access_Stream_Cursor_Input>>;
  where?: Maybe<Feature_Access_Bool_Exp>;
};

export type Subscription_RootFeature_AggregateArgs = {
  distinct_on?: Maybe<Array<Feature_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Order_By>>;
  where?: Maybe<Feature_Bool_Exp>;
};

export type Subscription_RootFeature_By_PkArgs = {
  name: Scalars['String'];
};

export type Subscription_RootFeature_ConfigArgs = {
  distinct_on?: Maybe<Array<Feature_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Config_Order_By>>;
  where?: Maybe<Feature_Config_Bool_Exp>;
};

export type Subscription_RootFeature_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Feature_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Config_Order_By>>;
  where?: Maybe<Feature_Config_Bool_Exp>;
};

export type Subscription_RootFeature_Config_By_PkArgs = {
  feature: Feature_Enum;
};

export type Subscription_RootFeature_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Feature_Config_Stream_Cursor_Input>>;
  where?: Maybe<Feature_Config_Bool_Exp>;
};

export type Subscription_RootFeature_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Feature_Stream_Cursor_Input>>;
  where?: Maybe<Feature_Bool_Exp>;
};

export type Subscription_RootGateway_AmiArgs = {
  distinct_on?: Maybe<Array<Gateway_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Ami_Order_By>>;
  where?: Maybe<Gateway_Ami_Bool_Exp>;
};

export type Subscription_RootGateway_Ami_AggregateArgs = {
  distinct_on?: Maybe<Array<Gateway_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Ami_Order_By>>;
  where?: Maybe<Gateway_Ami_Bool_Exp>;
};

export type Subscription_RootGateway_Ami_By_PkArgs = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

export type Subscription_RootGateway_Ami_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Gateway_Ami_Stream_Cursor_Input>>;
  where?: Maybe<Gateway_Ami_Bool_Exp>;
};

export type Subscription_RootGateway_ClusterArgs = {
  distinct_on?: Maybe<Array<Gateway_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Cluster_Order_By>>;
  where?: Maybe<Gateway_Cluster_Bool_Exp>;
};

export type Subscription_RootGateway_Cluster_AggregateArgs = {
  distinct_on?: Maybe<Array<Gateway_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Cluster_Order_By>>;
  where?: Maybe<Gateway_Cluster_Bool_Exp>;
};

export type Subscription_RootGateway_Cluster_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootGateway_Cluster_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Gateway_Cluster_Stream_Cursor_Input>>;
  where?: Maybe<Gateway_Cluster_Bool_Exp>;
};

export type Subscription_RootGateway_Cluster_TenantsArgs = {
  distinct_on?: Maybe<Array<Gateway_Cluster_Tenants_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Cluster_Tenants_Order_By>>;
  where?: Maybe<Gateway_Cluster_Tenants_Bool_Exp>;
};

export type Subscription_RootGateway_Cluster_Tenants_AggregateArgs = {
  distinct_on?: Maybe<Array<Gateway_Cluster_Tenants_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Cluster_Tenants_Order_By>>;
  where?: Maybe<Gateway_Cluster_Tenants_Bool_Exp>;
};

export type Subscription_RootGateway_Cluster_Tenants_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Gateway_Cluster_Tenants_Stream_Cursor_Input>>;
  where?: Maybe<Gateway_Cluster_Tenants_Bool_Exp>;
};

export type Subscription_RootGateway_WorkerArgs = {
  distinct_on?: Maybe<Array<Gateway_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Worker_Order_By>>;
  where?: Maybe<Gateway_Worker_Bool_Exp>;
};

export type Subscription_RootGateway_Worker_AggregateArgs = {
  distinct_on?: Maybe<Array<Gateway_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Gateway_Worker_Order_By>>;
  where?: Maybe<Gateway_Worker_Bool_Exp>;
};

export type Subscription_RootGateway_Worker_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootGateway_Worker_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Gateway_Worker_Stream_Cursor_Input>>;
  where?: Maybe<Gateway_Worker_Bool_Exp>;
};

export type Subscription_RootGet_Aggregated_Cost_For_Project_On_Shared_PlanArgs =
  {
    args: Get_Aggregated_Cost_For_Project_On_Shared_Plan_Args;
    distinct_on?: Maybe<Array<Project_Total_Db_Usage_Agg_Select_Column>>;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Total_Db_Usage_Agg_Order_By>>;
    where?: Maybe<Project_Total_Db_Usage_Agg_Bool_Exp>;
  };

export type Subscription_RootGet_Aggregated_Cost_For_Project_On_Shared_Plan_AggregateArgs =
  {
    args: Get_Aggregated_Cost_For_Project_On_Shared_Plan_Args;
    distinct_on?: Maybe<Array<Project_Total_Db_Usage_Agg_Select_Column>>;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Total_Db_Usage_Agg_Order_By>>;
    where?: Maybe<Project_Total_Db_Usage_Agg_Bool_Exp>;
  };

export type Subscription_RootGithub_Email_TypeArgs = {
  distinct_on?: Maybe<Array<Github_Email_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Email_Type_Order_By>>;
  where?: Maybe<Github_Email_Type_Bool_Exp>;
};

export type Subscription_RootGithub_Email_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Email_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Email_Type_Order_By>>;
  where?: Maybe<Github_Email_Type_Bool_Exp>;
};

export type Subscription_RootGithub_Email_Type_By_PkArgs = {
  email_type: Scalars['String'];
};

export type Subscription_RootGithub_Email_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Github_Email_Type_Stream_Cursor_Input>>;
  where?: Maybe<Github_Email_Type_Bool_Exp>;
};

export type Subscription_RootGithub_Integration_ConfigArgs = {
  distinct_on?: Maybe<Array<Github_Integration_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Integration_Config_Order_By>>;
  where?: Maybe<Github_Integration_Config_Bool_Exp>;
};

export type Subscription_RootGithub_Integration_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Integration_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Integration_Config_Order_By>>;
  where?: Maybe<Github_Integration_Config_Bool_Exp>;
};

export type Subscription_RootGithub_Integration_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootGithub_Integration_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Github_Integration_Config_Stream_Cursor_Input>>;
  where?: Maybe<Github_Integration_Config_Bool_Exp>;
};

export type Subscription_RootGithub_Integration_ModeArgs = {
  distinct_on?: Maybe<Array<Github_Integration_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Integration_Mode_Order_By>>;
  where?: Maybe<Github_Integration_Mode_Bool_Exp>;
};

export type Subscription_RootGithub_Integration_Mode_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Integration_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Integration_Mode_Order_By>>;
  where?: Maybe<Github_Integration_Mode_Bool_Exp>;
};

export type Subscription_RootGithub_Integration_Mode_By_PkArgs = {
  mode: Scalars['String'];
};

export type Subscription_RootGithub_Integration_Mode_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Github_Integration_Mode_Stream_Cursor_Input>>;
  where?: Maybe<Github_Integration_Mode_Bool_Exp>;
};

export type Subscription_RootGithub_Push_EventArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Order_By>>;
  where?: Maybe<Github_Push_Event_Bool_Exp>;
};

export type Subscription_RootGithub_Push_Event_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Order_By>>;
  where?: Maybe<Github_Push_Event_Bool_Exp>;
};

export type Subscription_RootGithub_Push_Event_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootGithub_Push_Event_JobArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Job_Order_By>>;
  where?: Maybe<Github_Push_Event_Job_Bool_Exp>;
};

export type Subscription_RootGithub_Push_Event_Job_AggregateArgs = {
  distinct_on?: Maybe<Array<Github_Push_Event_Job_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Github_Push_Event_Job_Order_By>>;
  where?: Maybe<Github_Push_Event_Job_Bool_Exp>;
};

export type Subscription_RootGithub_Push_Event_Job_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootGithub_Push_Event_Job_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Github_Push_Event_Job_Stream_Cursor_Input>>;
  where?: Maybe<Github_Push_Event_Job_Bool_Exp>;
};

export type Subscription_RootGithub_Push_Event_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Github_Push_Event_Stream_Cursor_Input>>;
  where?: Maybe<Github_Push_Event_Bool_Exp>;
};

export type Subscription_RootHasura_AmiArgs = {
  distinct_on?: Maybe<Array<Hasura_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Ami_Order_By>>;
  where?: Maybe<Hasura_Ami_Bool_Exp>;
};

export type Subscription_RootHasura_Ami_AggregateArgs = {
  distinct_on?: Maybe<Array<Hasura_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Ami_Order_By>>;
  where?: Maybe<Hasura_Ami_Bool_Exp>;
};

export type Subscription_RootHasura_Ami_By_PkArgs = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

export type Subscription_RootHasura_Ami_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Hasura_Ami_Stream_Cursor_Input>>;
  where?: Maybe<Hasura_Ami_Bool_Exp>;
};

export type Subscription_RootHasura_ClusterArgs = {
  distinct_on?: Maybe<Array<Hasura_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Cluster_Order_By>>;
  where?: Maybe<Hasura_Cluster_Bool_Exp>;
};

export type Subscription_RootHasura_Cluster_AggregateArgs = {
  distinct_on?: Maybe<Array<Hasura_Cluster_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Cluster_Order_By>>;
  where?: Maybe<Hasura_Cluster_Bool_Exp>;
};

export type Subscription_RootHasura_Cluster_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootHasura_Cluster_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Hasura_Cluster_Stream_Cursor_Input>>;
  where?: Maybe<Hasura_Cluster_Bool_Exp>;
};

export type Subscription_RootHasura_WorkerArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Order_By>>;
  where?: Maybe<Hasura_Worker_Bool_Exp>;
};

export type Subscription_RootHasura_Worker_AggregateArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Order_By>>;
  where?: Maybe<Hasura_Worker_Bool_Exp>;
};

export type Subscription_RootHasura_Worker_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootHasura_Worker_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Hasura_Worker_Stream_Cursor_Input>>;
  where?: Maybe<Hasura_Worker_Bool_Exp>;
};

export type Subscription_RootHasura_Worker_TenantsArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Tenants_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Tenants_Order_By>>;
  where?: Maybe<Hasura_Worker_Tenants_Bool_Exp>;
};

export type Subscription_RootHasura_Worker_Tenants_AggregateArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Tenants_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Tenants_Order_By>>;
  where?: Maybe<Hasura_Worker_Tenants_Bool_Exp>;
};

export type Subscription_RootHasura_Worker_Tenants_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Hasura_Worker_Tenants_Stream_Cursor_Input>>;
  where?: Maybe<Hasura_Worker_Tenants_Bool_Exp>;
};

export type Subscription_RootHeroku_IntegrationsArgs = {
  distinct_on?: Maybe<Array<Heroku_Integrations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Heroku_Integrations_Order_By>>;
  where?: Maybe<Heroku_Integrations_Bool_Exp>;
};

export type Subscription_RootHeroku_Integrations_AggregateArgs = {
  distinct_on?: Maybe<Array<Heroku_Integrations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Heroku_Integrations_Order_By>>;
  where?: Maybe<Heroku_Integrations_Bool_Exp>;
};

export type Subscription_RootHeroku_Integrations_By_PkArgs = {
  project_id: Scalars['uuid'];
  var_name: Scalars['String'];
};

export type Subscription_RootHeroku_Integrations_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Heroku_Integrations_Stream_Cursor_Input>>;
  where?: Maybe<Heroku_Integrations_Bool_Exp>;
};

export type Subscription_RootInactive_Project_ExclusionsArgs = {
  distinct_on?: Maybe<Array<Inactive_Project_Exclusions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Project_Exclusions_Order_By>>;
  where?: Maybe<Inactive_Project_Exclusions_Bool_Exp>;
};

export type Subscription_RootInactive_Project_Exclusions_AggregateArgs = {
  distinct_on?: Maybe<Array<Inactive_Project_Exclusions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Project_Exclusions_Order_By>>;
  where?: Maybe<Inactive_Project_Exclusions_Bool_Exp>;
};

export type Subscription_RootInactive_Project_Exclusions_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Subscription_RootInactive_Project_Exclusions_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Inactive_Project_Exclusions_Stream_Cursor_Input>>;
  where?: Maybe<Inactive_Project_Exclusions_Bool_Exp>;
};

export type Subscription_RootInactive_Project_NotificationsArgs = {
  distinct_on?: Maybe<Array<Inactive_Project_Notifications_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Project_Notifications_Order_By>>;
  where?: Maybe<Inactive_Project_Notifications_Bool_Exp>;
};

export type Subscription_RootInactive_Project_Notifications_AggregateArgs = {
  distinct_on?: Maybe<Array<Inactive_Project_Notifications_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Project_Notifications_Order_By>>;
  where?: Maybe<Inactive_Project_Notifications_Bool_Exp>;
};

export type Subscription_RootInactive_Project_Notifications_By_PkArgs = {
  id: Scalars['Int'];
};

export type Subscription_RootInactive_Project_Notifications_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Inactive_Project_Notifications_Stream_Cursor_Input>>;
  where?: Maybe<Inactive_Project_Notifications_Bool_Exp>;
};

export type Subscription_RootInactive_Project_Suspension_ConfigArgs = {
  distinct_on?: Maybe<Array<Inactive_Project_Suspension_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Project_Suspension_Config_Order_By>>;
  where?: Maybe<Inactive_Project_Suspension_Config_Bool_Exp>;
};

export type Subscription_RootInactive_Project_Suspension_Config_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Inactive_Project_Suspension_Config_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Inactive_Project_Suspension_Config_Order_By>>;
    where?: Maybe<Inactive_Project_Suspension_Config_Bool_Exp>;
  };

export type Subscription_RootInactive_Project_Suspension_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Inactive_Project_Suspension_Config_Stream_Cursor_Input>>;
  where?: Maybe<Inactive_Project_Suspension_Config_Bool_Exp>;
};

export type Subscription_RootInactive_ProjectsArgs = {
  distinct_on?: Maybe<Array<Inactive_Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Projects_Order_By>>;
  where?: Maybe<Inactive_Projects_Bool_Exp>;
};

export type Subscription_RootInactive_Projects_AggregateArgs = {
  distinct_on?: Maybe<Array<Inactive_Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Inactive_Projects_Order_By>>;
  where?: Maybe<Inactive_Projects_Bool_Exp>;
};

export type Subscription_RootInactive_Projects_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Inactive_Projects_Stream_Cursor_Input>>;
  where?: Maybe<Inactive_Projects_Bool_Exp>;
};

export type Subscription_RootInfra_StatusArgs = {
  distinct_on?: Maybe<Array<Infra_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Infra_Status_Order_By>>;
  where?: Maybe<Infra_Status_Bool_Exp>;
};

export type Subscription_RootInfra_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Infra_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Infra_Status_Order_By>>;
  where?: Maybe<Infra_Status_Bool_Exp>;
};

export type Subscription_RootInfra_Status_By_PkArgs = {
  status: Scalars['String'];
};

export type Subscription_RootInfra_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Infra_Status_Stream_Cursor_Input>>;
  where?: Maybe<Infra_Status_Bool_Exp>;
};

export type Subscription_RootInvoiceArgs = {
  distinct_on?: Maybe<Array<Invoice_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Order_By>>;
  where?: Maybe<Invoice_Bool_Exp>;
};

export type Subscription_RootInvoice_AggregateArgs = {
  distinct_on?: Maybe<Array<Invoice_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Order_By>>;
  where?: Maybe<Invoice_Bool_Exp>;
};

export type Subscription_RootInvoice_By_PkArgs = {
  stripe_invoice_id: Scalars['String'];
};

export type Subscription_RootInvoice_Coupon_DiscountArgs = {
  distinct_on?: Maybe<Array<Invoice_Coupon_Discount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Coupon_Discount_Order_By>>;
  where?: Maybe<Invoice_Coupon_Discount_Bool_Exp>;
};

export type Subscription_RootInvoice_Coupon_Discount_AggregateArgs = {
  distinct_on?: Maybe<Array<Invoice_Coupon_Discount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Coupon_Discount_Order_By>>;
  where?: Maybe<Invoice_Coupon_Discount_Bool_Exp>;
};

export type Subscription_RootInvoice_Coupon_Discount_By_PkArgs = {
  inv_id: Scalars['String'];
};

export type Subscription_RootInvoice_Coupon_Discount_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Invoice_Coupon_Discount_Stream_Cursor_Input>>;
  where?: Maybe<Invoice_Coupon_Discount_Bool_Exp>;
};

export type Subscription_RootInvoice_ItemArgs = {
  distinct_on?: Maybe<Array<Invoice_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Item_Order_By>>;
  where?: Maybe<Invoice_Item_Bool_Exp>;
};

export type Subscription_RootInvoice_Item_AggregateArgs = {
  distinct_on?: Maybe<Array<Invoice_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Item_Order_By>>;
  where?: Maybe<Invoice_Item_Bool_Exp>;
};

export type Subscription_RootInvoice_Item_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootInvoice_Item_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Invoice_Item_Stream_Cursor_Input>>;
  where?: Maybe<Invoice_Item_Bool_Exp>;
};

export type Subscription_RootInvoice_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Invoice_Stream_Cursor_Input>>;
  where?: Maybe<Invoice_Bool_Exp>;
};

export type Subscription_RootJobsArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};

export type Subscription_RootJobs_AggregateArgs = {
  distinct_on?: Maybe<Array<Jobs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Jobs_Order_By>>;
  where?: Maybe<Jobs_Bool_Exp>;
};

export type Subscription_RootJobs_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootJobs_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Jobs_Stream_Cursor_Input>>;
  where?: Maybe<Jobs_Bool_Exp>;
};

export type Subscription_RootLabelArgs = {
  distinct_on?: Maybe<Array<Label_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Label_Order_By>>;
  where?: Maybe<Label_Bool_Exp>;
};

export type Subscription_RootLabel_AggregateArgs = {
  distinct_on?: Maybe<Array<Label_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Label_Order_By>>;
  where?: Maybe<Label_Bool_Exp>;
};

export type Subscription_RootLabel_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootLabel_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Label_Stream_Cursor_Input>>;
  where?: Maybe<Label_Bool_Exp>;
};

export type Subscription_RootLetsencrypt_StatusArgs = {
  distinct_on?: Maybe<Array<Letsencrypt_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Letsencrypt_Status_Order_By>>;
  where?: Maybe<Letsencrypt_Status_Bool_Exp>;
};

export type Subscription_RootLetsencrypt_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Letsencrypt_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Letsencrypt_Status_Order_By>>;
  where?: Maybe<Letsencrypt_Status_Bool_Exp>;
};

export type Subscription_RootLetsencrypt_Status_By_PkArgs = {
  fqdn: Scalars['String'];
};

export type Subscription_RootLetsencrypt_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Letsencrypt_Status_Stream_Cursor_Input>>;
  where?: Maybe<Letsencrypt_Status_Bool_Exp>;
};

export type Subscription_RootLicense_ActivityArgs = {
  distinct_on?: Maybe<Array<License_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Activity_Order_By>>;
  where?: Maybe<License_Activity_Bool_Exp>;
};

export type Subscription_RootLicense_Activity_AggregateArgs = {
  distinct_on?: Maybe<Array<License_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Activity_Order_By>>;
  where?: Maybe<License_Activity_Bool_Exp>;
};

export type Subscription_RootLicense_Activity_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootLicense_Activity_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<License_Activity_Stream_Cursor_Input>>;
  where?: Maybe<License_Activity_Bool_Exp>;
};

export type Subscription_RootLicense_InstanceArgs = {
  distinct_on?: Maybe<Array<License_Instance_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Instance_Order_By>>;
  where?: Maybe<License_Instance_Bool_Exp>;
};

export type Subscription_RootLicense_Instance_AggregateArgs = {
  distinct_on?: Maybe<Array<License_Instance_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Instance_Order_By>>;
  where?: Maybe<License_Instance_Bool_Exp>;
};

export type Subscription_RootLicense_Instance_By_PkArgs = {
  metadata_db_id: Scalars['uuid'];
};

export type Subscription_RootLicense_Instance_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<License_Instance_Stream_Cursor_Input>>;
  where?: Maybe<License_Instance_Bool_Exp>;
};

export type Subscription_RootLicense_TypeArgs = {
  distinct_on?: Maybe<Array<License_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Type_Order_By>>;
  where?: Maybe<License_Type_Bool_Exp>;
};

export type Subscription_RootLicense_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<License_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<License_Type_Order_By>>;
  where?: Maybe<License_Type_Bool_Exp>;
};

export type Subscription_RootLicense_Type_By_PkArgs = {
  name: Scalars['String'];
};

export type Subscription_RootLicense_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<License_Type_Stream_Cursor_Input>>;
  where?: Maybe<License_Type_Bool_Exp>;
};

export type Subscription_RootLicensesArgs = {
  distinct_on?: Maybe<Array<Licenses_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Licenses_Order_By>>;
  where?: Maybe<Licenses_Bool_Exp>;
};

export type Subscription_RootLicenses_AggregateArgs = {
  distinct_on?: Maybe<Array<Licenses_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Licenses_Order_By>>;
  where?: Maybe<Licenses_Bool_Exp>;
};

export type Subscription_RootLicenses_By_PkArgs = {
  email: Scalars['String'];
};

export type Subscription_RootLicenses_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Licenses_Stream_Cursor_Input>>;
  where?: Maybe<Licenses_Bool_Exp>;
};

export type Subscription_RootLux_ProxyArgs = {
  distinct_on?: Maybe<Array<Lux_Proxy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Lux_Proxy_Order_By>>;
  where?: Maybe<Lux_Proxy_Bool_Exp>;
};

export type Subscription_RootLux_Proxy_AggregateArgs = {
  distinct_on?: Maybe<Array<Lux_Proxy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Lux_Proxy_Order_By>>;
  where?: Maybe<Lux_Proxy_Bool_Exp>;
};

export type Subscription_RootLux_Proxy_AmiArgs = {
  distinct_on?: Maybe<Array<Lux_Proxy_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Lux_Proxy_Ami_Order_By>>;
  where?: Maybe<Lux_Proxy_Ami_Bool_Exp>;
};

export type Subscription_RootLux_Proxy_Ami_AggregateArgs = {
  distinct_on?: Maybe<Array<Lux_Proxy_Ami_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Lux_Proxy_Ami_Order_By>>;
  where?: Maybe<Lux_Proxy_Ami_Bool_Exp>;
};

export type Subscription_RootLux_Proxy_Ami_By_PkArgs = {
  ami_id: Scalars['String'];
  cloud: Scalars['String'];
  region: Scalars['String'];
};

export type Subscription_RootLux_Proxy_Ami_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Lux_Proxy_Ami_Stream_Cursor_Input>>;
  where?: Maybe<Lux_Proxy_Ami_Bool_Exp>;
};

export type Subscription_RootLux_Proxy_By_PkArgs = {
  cloud: Scalars['String'];
  region: Scalars['String'];
};

export type Subscription_RootLux_Proxy_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Lux_Proxy_Stream_Cursor_Input>>;
  where?: Maybe<Lux_Proxy_Bool_Exp>;
};

export type Subscription_RootNeon_Db_IntegrationArgs = {
  distinct_on?: Maybe<Array<Neon_Db_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Neon_Db_Integration_Order_By>>;
  where?: Maybe<Neon_Db_Integration_Bool_Exp>;
};

export type Subscription_RootNeon_Db_Integration_AggregateArgs = {
  distinct_on?: Maybe<Array<Neon_Db_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Neon_Db_Integration_Order_By>>;
  where?: Maybe<Neon_Db_Integration_Bool_Exp>;
};

export type Subscription_RootNeon_Db_Integration_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootNeon_Db_Integration_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Neon_Db_Integration_Stream_Cursor_Input>>;
  where?: Maybe<Neon_Db_Integration_Bool_Exp>;
};

export type Subscription_RootNewrelic_ConfigArgs = {
  distinct_on?: Maybe<Array<Newrelic_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Newrelic_Config_Order_By>>;
  where?: Maybe<Newrelic_Config_Bool_Exp>;
};

export type Subscription_RootNewrelic_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Newrelic_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Newrelic_Config_Order_By>>;
  where?: Maybe<Newrelic_Config_Bool_Exp>;
};

export type Subscription_RootNewrelic_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Subscription_RootNewrelic_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Newrelic_Config_Stream_Cursor_Input>>;
  where?: Maybe<Newrelic_Config_Bool_Exp>;
};

export type Subscription_RootNode_Pool_TypeArgs = {
  distinct_on?: Maybe<Array<Node_Pool_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Node_Pool_Type_Order_By>>;
  where?: Maybe<Node_Pool_Type_Bool_Exp>;
};

export type Subscription_RootNode_Pool_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Node_Pool_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Node_Pool_Type_Order_By>>;
  where?: Maybe<Node_Pool_Type_Bool_Exp>;
};

export type Subscription_RootNode_Pool_Type_By_PkArgs = {
  name: Scalars['String'];
};

export type Subscription_RootNode_Pool_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Node_Pool_Type_Stream_Cursor_Input>>;
  where?: Maybe<Node_Pool_Type_Bool_Exp>;
};

export type Subscription_RootNode_PoolsArgs = {
  distinct_on?: Maybe<Array<Node_Pools_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Node_Pools_Order_By>>;
  where?: Maybe<Node_Pools_Bool_Exp>;
};

export type Subscription_RootNode_Pools_AggregateArgs = {
  distinct_on?: Maybe<Array<Node_Pools_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Node_Pools_Order_By>>;
  where?: Maybe<Node_Pools_Bool_Exp>;
};

export type Subscription_RootNode_Pools_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootNode_Pools_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Node_Pools_Stream_Cursor_Input>>;
  where?: Maybe<Node_Pools_Bool_Exp>;
};

export type Subscription_RootNotificationArgs = {
  distinct_on?: Maybe<Array<Notification_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Notification_Order_By>>;
  where?: Maybe<Notification_Bool_Exp>;
};

export type Subscription_RootNotification_AggregateArgs = {
  distinct_on?: Maybe<Array<Notification_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Notification_Order_By>>;
  where?: Maybe<Notification_Bool_Exp>;
};

export type Subscription_RootNotification_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootNotification_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Notification_Stream_Cursor_Input>>;
  where?: Maybe<Notification_Bool_Exp>;
};

export type Subscription_RootNotification_TypeArgs = {
  distinct_on?: Maybe<Array<Notification_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Notification_Type_Order_By>>;
  where?: Maybe<Notification_Type_Bool_Exp>;
};

export type Subscription_RootNotification_Type_AggregateArgs = {
  distinct_on?: Maybe<Array<Notification_Type_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Notification_Type_Order_By>>;
  where?: Maybe<Notification_Type_Bool_Exp>;
};

export type Subscription_RootNotification_Type_By_PkArgs = {
  type: Scalars['String'];
};

export type Subscription_RootNotification_Type_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Notification_Type_Stream_Cursor_Input>>;
  where?: Maybe<Notification_Type_Bool_Exp>;
};

export type Subscription_RootOnboarding_Sample_Db_CohortArgs = {
  distinct_on?: Maybe<Array<Onboarding_Sample_Db_Cohort_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Sample_Db_Cohort_Order_By>>;
  where?: Maybe<Onboarding_Sample_Db_Cohort_Bool_Exp>;
};

export type Subscription_RootOnboarding_Sample_Db_Cohort_AggregateArgs = {
  distinct_on?: Maybe<Array<Onboarding_Sample_Db_Cohort_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Sample_Db_Cohort_Order_By>>;
  where?: Maybe<Onboarding_Sample_Db_Cohort_Bool_Exp>;
};

export type Subscription_RootOnboarding_Sample_Db_Cohort_By_PkArgs = {
  user_id: Scalars['uuid'];
};

export type Subscription_RootOnboarding_Sample_Db_Cohort_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Onboarding_Sample_Db_Cohort_Stream_Cursor_Input>>;
  where?: Maybe<Onboarding_Sample_Db_Cohort_Bool_Exp>;
};

export type Subscription_RootOnboarding_Sample_Db_ConfigArgs = {
  distinct_on?: Maybe<Array<Onboarding_Sample_Db_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Sample_Db_Config_Order_By>>;
  where?: Maybe<Onboarding_Sample_Db_Config_Bool_Exp>;
};

export type Subscription_RootOnboarding_Sample_Db_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Onboarding_Sample_Db_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Onboarding_Sample_Db_Config_Order_By>>;
  where?: Maybe<Onboarding_Sample_Db_Config_Bool_Exp>;
};

export type Subscription_RootOnboarding_Sample_Db_Config_By_PkArgs = {
  created_at: Scalars['timestamptz'];
};

export type Subscription_RootOnboarding_Sample_Db_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Onboarding_Sample_Db_Config_Stream_Cursor_Input>>;
  where?: Maybe<Onboarding_Sample_Db_Config_Bool_Exp>;
};

export type Subscription_RootOne_Click_DeploymentArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_Order_By>>;
  where?: Maybe<One_Click_Deployment_Bool_Exp>;
};

export type Subscription_RootOne_Click_Deployment_AggregateArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_Order_By>>;
  where?: Maybe<One_Click_Deployment_Bool_Exp>;
};

export type Subscription_RootOne_Click_Deployment_By_PkArgs = {
  id: Scalars['bigint'];
};

export type Subscription_RootOne_Click_Deployment_Sample_AppsArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_Sample_Apps_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_Sample_Apps_Order_By>>;
  where?: Maybe<One_Click_Deployment_Sample_Apps_Bool_Exp>;
};

export type Subscription_RootOne_Click_Deployment_Sample_Apps_AggregateArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_Sample_Apps_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_Sample_Apps_Order_By>>;
  where?: Maybe<One_Click_Deployment_Sample_Apps_Bool_Exp>;
};

export type Subscription_RootOne_Click_Deployment_Sample_Apps_By_PkArgs = {
  git_repository_branch: Scalars['String'];
  git_repository_url: Scalars['String'];
  hasura_directory: Scalars['String'];
};

export type Subscription_RootOne_Click_Deployment_Sample_Apps_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<One_Click_Deployment_Sample_Apps_Stream_Cursor_Input>>;
  where?: Maybe<One_Click_Deployment_Sample_Apps_Bool_Exp>;
};

export type Subscription_RootOne_Click_Deployment_State_LogArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_State_Log_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_State_Log_Order_By>>;
  where?: Maybe<One_Click_Deployment_State_Log_Bool_Exp>;
};

export type Subscription_RootOne_Click_Deployment_State_Log_AggregateArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_State_Log_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_State_Log_Order_By>>;
  where?: Maybe<One_Click_Deployment_State_Log_Bool_Exp>;
};

export type Subscription_RootOne_Click_Deployment_State_Log_By_PkArgs = {
  id: Scalars['bigint'];
};

export type Subscription_RootOne_Click_Deployment_State_Log_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<One_Click_Deployment_State_Log_Stream_Cursor_Input>>;
  where?: Maybe<One_Click_Deployment_State_Log_Bool_Exp>;
};

export type Subscription_RootOne_Click_Deployment_StatesArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_States_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_States_Order_By>>;
  where?: Maybe<One_Click_Deployment_States_Bool_Exp>;
};

export type Subscription_RootOne_Click_Deployment_States_AggregateArgs = {
  distinct_on?: Maybe<Array<One_Click_Deployment_States_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<One_Click_Deployment_States_Order_By>>;
  where?: Maybe<One_Click_Deployment_States_Bool_Exp>;
};

export type Subscription_RootOne_Click_Deployment_States_By_PkArgs = {
  name: Scalars['String'];
};

export type Subscription_RootOne_Click_Deployment_States_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<One_Click_Deployment_States_Stream_Cursor_Input>>;
  where?: Maybe<One_Click_Deployment_States_Bool_Exp>;
};

export type Subscription_RootOne_Click_Deployment_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<One_Click_Deployment_Stream_Cursor_Input>>;
  where?: Maybe<One_Click_Deployment_Bool_Exp>;
};

export type Subscription_RootOpentelemetry_ConfigArgs = {
  distinct_on?: Maybe<Array<Opentelemetry_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Opentelemetry_Config_Order_By>>;
  where?: Maybe<Opentelemetry_Config_Bool_Exp>;
};

export type Subscription_RootOpentelemetry_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Opentelemetry_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Opentelemetry_Config_Order_By>>;
  where?: Maybe<Opentelemetry_Config_Bool_Exp>;
};

export type Subscription_RootOpentelemetry_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Subscription_RootOpentelemetry_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Opentelemetry_Config_Stream_Cursor_Input>>;
  where?: Maybe<Opentelemetry_Config_Bool_Exp>;
};

export type Subscription_RootOperations_Delete_Free_Plan_Dns_Records_Nov_2021Args =
  {
    distinct_on?: Maybe<
      Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<
      Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Order_By>
    >;
    where?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp>;
  };

export type Subscription_RootOperations_Delete_Free_Plan_Dns_Records_Nov_2021_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<
      Array<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Order_By>
    >;
    where?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp>;
  };

export type Subscription_RootOperations_Delete_Free_Plan_Dns_Records_Nov_2021_By_PkArgs =
  {
    tenant_id: Scalars['uuid'];
  };

export type Subscription_RootOperations_Delete_Free_Plan_Dns_Records_Nov_2021_StreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Stream_Cursor_Input>
    >;
    where?: Maybe<Operations_Delete_Free_Plan_Dns_Records_Nov_2021_Bool_Exp>;
  };

export type Subscription_RootOperations_TenantArgs = {
  distinct_on?: Maybe<Array<Operations_Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Operations_Tenant_Order_By>>;
  where?: Maybe<Operations_Tenant_Bool_Exp>;
};

export type Subscription_RootOperations_Tenant_AggregateArgs = {
  distinct_on?: Maybe<Array<Operations_Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Operations_Tenant_Order_By>>;
  where?: Maybe<Operations_Tenant_Bool_Exp>;
};

export type Subscription_RootOperations_Tenant_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Operations_Tenant_Stream_Cursor_Input>>;
  where?: Maybe<Operations_Tenant_Bool_Exp>;
};

export type Subscription_RootOperations_To_Delete_Free_Plan_Dns_RecordsArgs = {
  args: Operations_To_Delete_Free_Plan_Dns_Records_Args;
  distinct_on?: Maybe<Array<Operations_Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Operations_Tenant_Order_By>>;
  where?: Maybe<Operations_Tenant_Bool_Exp>;
};

export type Subscription_RootOperations_To_Delete_Free_Plan_Dns_Records_AggregateArgs =
  {
    args: Operations_To_Delete_Free_Plan_Dns_Records_Args;
    distinct_on?: Maybe<Array<Operations_Tenant_Select_Column>>;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Operations_Tenant_Order_By>>;
    where?: Maybe<Operations_Tenant_Bool_Exp>;
  };

export type Subscription_RootPayment_MethodArgs = {
  distinct_on?: Maybe<Array<Payment_Method_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payment_Method_Order_By>>;
  where?: Maybe<Payment_Method_Bool_Exp>;
};

export type Subscription_RootPayment_Method_AggregateArgs = {
  distinct_on?: Maybe<Array<Payment_Method_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payment_Method_Order_By>>;
  where?: Maybe<Payment_Method_Bool_Exp>;
};

export type Subscription_RootPayment_Method_By_PkArgs = {
  id: Scalars['String'];
};

export type Subscription_RootPayment_Method_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Payment_Method_Stream_Cursor_Input>>;
  where?: Maybe<Payment_Method_Bool_Exp>;
};

export type Subscription_RootPlan_EntitlementsArgs = {
  distinct_on?: Maybe<Array<Plan_Entitlements_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Plan_Entitlements_Order_By>>;
  where?: Maybe<Plan_Entitlements_Bool_Exp>;
};

export type Subscription_RootPlan_Entitlements_AggregateArgs = {
  distinct_on?: Maybe<Array<Plan_Entitlements_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Plan_Entitlements_Order_By>>;
  where?: Maybe<Plan_Entitlements_Bool_Exp>;
};

export type Subscription_RootPlan_Entitlements_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootPlan_Entitlements_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Plan_Entitlements_Stream_Cursor_Input>>;
  where?: Maybe<Plan_Entitlements_Bool_Exp>;
};

export type Subscription_RootPlansArgs = {
  distinct_on?: Maybe<Array<Plans_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Plans_Order_By>>;
  where?: Maybe<Plans_Bool_Exp>;
};

export type Subscription_RootPlans_AggregateArgs = {
  distinct_on?: Maybe<Array<Plans_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Plans_Order_By>>;
  where?: Maybe<Plans_Bool_Exp>;
};

export type Subscription_RootPlans_By_PkArgs = {
  name: Scalars['String'];
};

export type Subscription_RootPlans_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Plans_Stream_Cursor_Input>>;
  where?: Maybe<Plans_Bool_Exp>;
};

export type Subscription_RootPoliciesArgs = {
  distinct_on?: Maybe<Array<Policies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Policies_Order_By>>;
  where?: Maybe<Policies_Bool_Exp>;
};

export type Subscription_RootPolicies_AggregateArgs = {
  distinct_on?: Maybe<Array<Policies_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Policies_Order_By>>;
  where?: Maybe<Policies_Bool_Exp>;
};

export type Subscription_RootPolicies_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Subscription_RootPolicies_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Policies_Stream_Cursor_Input>>;
  where?: Maybe<Policies_Bool_Exp>;
};

export type Subscription_RootPrivilegesArgs = {
  distinct_on?: Maybe<Array<Privileges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Privileges_Order_By>>;
  where?: Maybe<Privileges_Bool_Exp>;
};

export type Subscription_RootPrivileges_AggregateArgs = {
  distinct_on?: Maybe<Array<Privileges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Privileges_Order_By>>;
  where?: Maybe<Privileges_Bool_Exp>;
};

export type Subscription_RootPrivileges_By_PkArgs = {
  slug: Scalars['String'];
};

export type Subscription_RootPrivileges_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Privileges_Stream_Cursor_Input>>;
  where?: Maybe<Privileges_Bool_Exp>;
};

export type Subscription_RootPro_License_KeysArgs = {
  distinct_on?: Maybe<Array<Pro_License_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pro_License_Keys_Order_By>>;
  where?: Maybe<Pro_License_Keys_Bool_Exp>;
};

export type Subscription_RootPro_License_Keys_AggregateArgs = {
  distinct_on?: Maybe<Array<Pro_License_Keys_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Pro_License_Keys_Order_By>>;
  where?: Maybe<Pro_License_Keys_Bool_Exp>;
};

export type Subscription_RootPro_License_Keys_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootPro_License_Keys_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Pro_License_Keys_Stream_Cursor_Input>>;
  where?: Maybe<Pro_License_Keys_Bool_Exp>;
};

export type Subscription_RootProject_ActivityArgs = {
  distinct_on?: Maybe<Array<Project_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Activity_Order_By>>;
  where?: Maybe<Project_Activity_Bool_Exp>;
};

export type Subscription_RootProject_Activity_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Activity_Order_By>>;
  where?: Maybe<Project_Activity_Bool_Exp>;
};

export type Subscription_RootProject_Activity_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProject_Activity_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Activity_Stream_Cursor_Input>>;
  where?: Maybe<Project_Activity_Bool_Exp>;
};

export type Subscription_RootProject_Billing_Manager_InvitationsArgs = {
  distinct_on?: Maybe<Array<Project_Billing_Manager_Invitations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Billing_Manager_Invitations_Order_By>>;
  where?: Maybe<Project_Billing_Manager_Invitations_Bool_Exp>;
};

export type Subscription_RootProject_Billing_Manager_Invitations_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Project_Billing_Manager_Invitations_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Billing_Manager_Invitations_Order_By>>;
    where?: Maybe<Project_Billing_Manager_Invitations_Bool_Exp>;
  };

export type Subscription_RootProject_Billing_Manager_Invitations_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProject_Billing_Manager_Invitations_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Billing_Manager_Invitations_Stream_Cursor_Input>>;
  where?: Maybe<Project_Billing_Manager_Invitations_Bool_Exp>;
};

export type Subscription_RootProject_Collaborator_Allowed_Schema_TablesArgs = {
  distinct_on?: Maybe<
    Array<Project_Collaborator_Allowed_Schema_Tables_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Allowed_Schema_Tables_Order_By>>;
  where?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>;
};

export type Subscription_RootProject_Collaborator_Allowed_Schema_Tables_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Project_Collaborator_Allowed_Schema_Tables_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<
      Array<Project_Collaborator_Allowed_Schema_Tables_Order_By>
    >;
    where?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>;
  };

export type Subscription_RootProject_Collaborator_Allowed_Schema_Tables_By_PkArgs =
  {
    project_collaborator_id: Scalars['uuid'];
    schema: Scalars['String'];
    table_name: Scalars['String'];
  };

export type Subscription_RootProject_Collaborator_Allowed_Schema_Tables_StreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      Maybe<Project_Collaborator_Allowed_Schema_Tables_Stream_Cursor_Input>
    >;
    where?: Maybe<Project_Collaborator_Allowed_Schema_Tables_Bool_Exp>;
  };

export type Subscription_RootProject_Collaborator_Allowed_SchemasArgs = {
  distinct_on?: Maybe<
    Array<Project_Collaborator_Allowed_Schemas_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Allowed_Schemas_Order_By>>;
  where?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
};

export type Subscription_RootProject_Collaborator_Allowed_Schemas_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Project_Collaborator_Allowed_Schemas_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Collaborator_Allowed_Schemas_Order_By>>;
    where?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
  };

export type Subscription_RootProject_Collaborator_Allowed_Schemas_By_PkArgs = {
  project_collaborator_id: Scalars['uuid'];
  schema: Scalars['String'];
};

export type Subscription_RootProject_Collaborator_Allowed_Schemas_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<
    Maybe<Project_Collaborator_Allowed_Schemas_Stream_Cursor_Input>
  >;
  where?: Maybe<Project_Collaborator_Allowed_Schemas_Bool_Exp>;
};

export type Subscription_RootProject_Collaborator_InvitationsArgs = {
  distinct_on?: Maybe<Array<Project_Collaborator_Invitations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Invitations_Order_By>>;
  where?: Maybe<Project_Collaborator_Invitations_Bool_Exp>;
};

export type Subscription_RootProject_Collaborator_Invitations_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Collaborator_Invitations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Invitations_Order_By>>;
  where?: Maybe<Project_Collaborator_Invitations_Bool_Exp>;
};

export type Subscription_RootProject_Collaborator_Invitations_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProject_Collaborator_Invitations_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Collaborator_Invitations_Stream_Cursor_Input>>;
  where?: Maybe<Project_Collaborator_Invitations_Bool_Exp>;
};

export type Subscription_RootProject_Collaborator_PrivilegesArgs = {
  distinct_on?: Maybe<Array<Project_Collaborator_Privileges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Privileges_Order_By>>;
  where?: Maybe<Project_Collaborator_Privileges_Bool_Exp>;
};

export type Subscription_RootProject_Collaborator_Privileges_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Collaborator_Privileges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborator_Privileges_Order_By>>;
  where?: Maybe<Project_Collaborator_Privileges_Bool_Exp>;
};

export type Subscription_RootProject_Collaborator_Privileges_By_PkArgs = {
  privilege_slug: Scalars['String'];
  project_collaborator_id: Scalars['uuid'];
};

export type Subscription_RootProject_Collaborator_Privileges_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Collaborator_Privileges_Stream_Cursor_Input>>;
  where?: Maybe<Project_Collaborator_Privileges_Bool_Exp>;
};

export type Subscription_RootProject_CollaboratorsArgs = {
  distinct_on?: Maybe<Array<Project_Collaborators_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborators_Order_By>>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

export type Subscription_RootProject_Collaborators_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Collaborators_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborators_Order_By>>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

export type Subscription_RootProject_Collaborators_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProject_Collaborators_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Collaborators_Stream_Cursor_Input>>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

export type Subscription_RootProject_Data_UsageArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Order_By>>;
  where?: Maybe<Project_Data_Usage_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_AggArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Agg_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Agg_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Data_Usage_Agg_Stream_Cursor_Input>>;
  where?: Maybe<Project_Data_Usage_Agg_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Agg_UserArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_User_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Agg_User_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Agg_User_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Agg_User_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Data_Usage_Agg_User_Stream_Cursor_Input>>;
  where?: Maybe<Project_Data_Usage_Agg_User_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Order_By>>;
  where?: Maybe<Project_Data_Usage_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProject_Data_Usage_ComponentsArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Components_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Components_Order_By>>;
  where?: Maybe<Project_Data_Usage_Components_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Components_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Components_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Components_Order_By>>;
  where?: Maybe<Project_Data_Usage_Components_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Components_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Data_Usage_Components_Stream_Cursor_Input>>;
  where?: Maybe<Project_Data_Usage_Components_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_PrometheusArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Prometheus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Order_By>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Prometheus_Agg_UserArgs = {
  distinct_on?: Maybe<
    Array<Project_Data_Usage_Prometheus_Agg_User_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Agg_User_Order_By>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Prometheus_Agg_User_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Project_Data_Usage_Prometheus_Agg_User_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Agg_User_Order_By>>;
    where?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>;
  };

export type Subscription_RootProject_Data_Usage_Prometheus_Agg_User_StreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      Maybe<Project_Data_Usage_Prometheus_Agg_User_Stream_Cursor_Input>
    >;
    where?: Maybe<Project_Data_Usage_Prometheus_Agg_User_Bool_Exp>;
  };

export type Subscription_RootProject_Data_Usage_Prometheus_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Prometheus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Prometheus_Order_By>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Prometheus_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProject_Data_Usage_Prometheus_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Data_Usage_Prometheus_Stream_Cursor_Input>>;
  where?: Maybe<Project_Data_Usage_Prometheus_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_ReportArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Report_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Report_Order_By>>;
  where?: Maybe<Project_Data_Usage_Report_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Report_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Data_Usage_Report_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Data_Usage_Report_Order_By>>;
  where?: Maybe<Project_Data_Usage_Report_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_Report_By_PkArgs = {
  project_id: Scalars['uuid'];
  report_date: Scalars['date'];
};

export type Subscription_RootProject_Data_Usage_Report_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Data_Usage_Report_Stream_Cursor_Input>>;
  where?: Maybe<Project_Data_Usage_Report_Bool_Exp>;
};

export type Subscription_RootProject_Data_Usage_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Data_Usage_Stream_Cursor_Input>>;
  where?: Maybe<Project_Data_Usage_Bool_Exp>;
};

export type Subscription_RootProject_Db_UsageArgs = {
  distinct_on?: Maybe<Array<Project_Db_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Order_By>>;
  where?: Maybe<Project_Db_Usage_Bool_Exp>;
};

export type Subscription_RootProject_Db_Usage_Agg_UserArgs = {
  distinct_on?: Maybe<Array<Project_Db_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Db_Usage_Agg_User_Bool_Exp>;
};

export type Subscription_RootProject_Db_Usage_Agg_User_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Db_Usage_Agg_User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Agg_User_Order_By>>;
  where?: Maybe<Project_Db_Usage_Agg_User_Bool_Exp>;
};

export type Subscription_RootProject_Db_Usage_Agg_User_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Db_Usage_Agg_User_Stream_Cursor_Input>>;
  where?: Maybe<Project_Db_Usage_Agg_User_Bool_Exp>;
};

export type Subscription_RootProject_Db_Usage_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Db_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Db_Usage_Order_By>>;
  where?: Maybe<Project_Db_Usage_Bool_Exp>;
};

export type Subscription_RootProject_Db_Usage_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProject_Db_Usage_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Db_Usage_Stream_Cursor_Input>>;
  where?: Maybe<Project_Db_Usage_Bool_Exp>;
};

export type Subscription_RootProject_Entitlement_AccessArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Project_Entitlement_Access_Bool_Exp>;
};

export type Subscription_RootProject_Entitlement_Access_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Access_Order_By>>;
  where?: Maybe<Project_Entitlement_Access_Bool_Exp>;
};

export type Subscription_RootProject_Entitlement_Access_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProject_Entitlement_Access_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Entitlement_Access_Stream_Cursor_Input>>;
  where?: Maybe<Project_Entitlement_Access_Bool_Exp>;
};

export type Subscription_RootProject_Entitlement_CatalogueArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<Project_Entitlement_Catalogue_Bool_Exp>;
};

export type Subscription_RootProject_Entitlement_Catalogue_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<Project_Entitlement_Catalogue_Bool_Exp>;
};

export type Subscription_RootProject_Entitlement_Catalogue_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProject_Entitlement_Catalogue_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Entitlement_Catalogue_Stream_Cursor_Input>>;
  where?: Maybe<Project_Entitlement_Catalogue_Bool_Exp>;
};

export type Subscription_RootProject_Entitlement_TypesArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Types_Order_By>>;
  where?: Maybe<Project_Entitlement_Types_Bool_Exp>;
};

export type Subscription_RootProject_Entitlement_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Entitlement_Types_Order_By>>;
  where?: Maybe<Project_Entitlement_Types_Bool_Exp>;
};

export type Subscription_RootProject_Entitlement_Types_By_PkArgs = {
  value: Scalars['String'];
};

export type Subscription_RootProject_Entitlement_Types_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Entitlement_Types_Stream_Cursor_Input>>;
  where?: Maybe<Project_Entitlement_Types_Bool_Exp>;
};

export type Subscription_RootProject_LabelsArgs = {
  distinct_on?: Maybe<Array<Project_Labels_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Labels_Order_By>>;
  where?: Maybe<Project_Labels_Bool_Exp>;
};

export type Subscription_RootProject_Labels_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Labels_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Labels_Order_By>>;
  where?: Maybe<Project_Labels_Bool_Exp>;
};

export type Subscription_RootProject_Labels_By_PkArgs = {
  label_id: Scalars['uuid'];
  project_id: Scalars['uuid'];
};

export type Subscription_RootProject_Labels_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Labels_Stream_Cursor_Input>>;
  where?: Maybe<Project_Labels_Bool_Exp>;
};

export type Subscription_RootProject_MetadataArgs = {
  distinct_on?: Maybe<Array<Project_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Metadata_Order_By>>;
  where?: Maybe<Project_Metadata_Bool_Exp>;
};

export type Subscription_RootProject_Metadata_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Metadata_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Metadata_Order_By>>;
  where?: Maybe<Project_Metadata_Bool_Exp>;
};

export type Subscription_RootProject_Metadata_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Subscription_RootProject_Metadata_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Metadata_Stream_Cursor_Input>>;
  where?: Maybe<Project_Metadata_Bool_Exp>;
};

export type Subscription_RootProject_NotificationArgs = {
  distinct_on?: Maybe<Array<Project_Notification_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Notification_Order_By>>;
  where?: Maybe<Project_Notification_Bool_Exp>;
};

export type Subscription_RootProject_Notification_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Notification_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Notification_Order_By>>;
  where?: Maybe<Project_Notification_Bool_Exp>;
};

export type Subscription_RootProject_Notification_By_PkArgs = {
  month: Scalars['Int'];
  project_id: Scalars['uuid'];
  type: Scalars['reminder_type_enum'];
  year: Scalars['Int'];
};

export type Subscription_RootProject_Notification_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Notification_Stream_Cursor_Input>>;
  where?: Maybe<Project_Notification_Bool_Exp>;
};

export type Subscription_RootProject_Ownership_Transfer_InvitationsArgs = {
  distinct_on?: Maybe<
    Array<Project_Ownership_Transfer_Invitations_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Ownership_Transfer_Invitations_Order_By>>;
  where?: Maybe<Project_Ownership_Transfer_Invitations_Bool_Exp>;
};

export type Subscription_RootProject_Ownership_Transfer_Invitations_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Project_Ownership_Transfer_Invitations_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Project_Ownership_Transfer_Invitations_Order_By>>;
    where?: Maybe<Project_Ownership_Transfer_Invitations_Bool_Exp>;
  };

export type Subscription_RootProject_Ownership_Transfer_Invitations_By_PkArgs =
  {
    id: Scalars['uuid'];
  };

export type Subscription_RootProject_Ownership_Transfer_Invitations_StreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      Maybe<Project_Ownership_Transfer_Invitations_Stream_Cursor_Input>
    >;
    where?: Maybe<Project_Ownership_Transfer_Invitations_Bool_Exp>;
  };

export type Subscription_RootProject_Pool_Current_StatusArgs = {
  distinct_on?: Maybe<Array<Project_Pool_Current_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Pool_Current_Status_Order_By>>;
  where?: Maybe<Project_Pool_Current_Status_Bool_Exp>;
};

export type Subscription_RootProject_Pool_Current_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Pool_Current_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Pool_Current_Status_Order_By>>;
  where?: Maybe<Project_Pool_Current_Status_Bool_Exp>;
};

export type Subscription_RootProject_Pool_Current_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Pool_Current_Status_Stream_Cursor_Input>>;
  where?: Maybe<Project_Pool_Current_Status_Bool_Exp>;
};

export type Subscription_RootProject_Requests_CountArgs = {
  distinct_on?: Maybe<Array<Project_Requests_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Requests_Count_Order_By>>;
  where?: Maybe<Project_Requests_Count_Bool_Exp>;
};

export type Subscription_RootProject_Requests_Count_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Requests_Count_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Requests_Count_Order_By>>;
  where?: Maybe<Project_Requests_Count_Bool_Exp>;
};

export type Subscription_RootProject_Requests_Count_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProject_Requests_Count_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Requests_Count_Stream_Cursor_Input>>;
  where?: Maybe<Project_Requests_Count_Bool_Exp>;
};

export type Subscription_RootProject_StatsArgs = {
  distinct_on?: Maybe<Array<Project_Stats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Stats_Order_By>>;
  where?: Maybe<Project_Stats_Bool_Exp>;
};

export type Subscription_RootProject_Stats_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Stats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Stats_Order_By>>;
  where?: Maybe<Project_Stats_Bool_Exp>;
};

export type Subscription_RootProject_Stats_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProject_Stats_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Stats_Stream_Cursor_Input>>;
  where?: Maybe<Project_Stats_Bool_Exp>;
};

export type Subscription_RootProject_Total_Db_Usage_AggArgs = {
  distinct_on?: Maybe<Array<Project_Total_Db_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Total_Db_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Total_Db_Usage_Agg_Bool_Exp>;
};

export type Subscription_RootProject_Total_Db_Usage_Agg_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Total_Db_Usage_Agg_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Total_Db_Usage_Agg_Order_By>>;
  where?: Maybe<Project_Total_Db_Usage_Agg_Bool_Exp>;
};

export type Subscription_RootProject_Total_Db_Usage_Agg_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Project_Total_Db_Usage_Agg_Stream_Cursor_Input>>;
  where?: Maybe<Project_Total_Db_Usage_Agg_Bool_Exp>;
};

export type Subscription_RootProjectsArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

export type Subscription_RootProjects_AggregateArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

export type Subscription_RootProjects_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProjects_Pool_ConfigArgs = {
  distinct_on?: Maybe<Array<Projects_Pool_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Pool_Config_Order_By>>;
  where?: Maybe<Projects_Pool_Config_Bool_Exp>;
};

export type Subscription_RootProjects_Pool_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Projects_Pool_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Pool_Config_Order_By>>;
  where?: Maybe<Projects_Pool_Config_Bool_Exp>;
};

export type Subscription_RootProjects_Pool_Config_By_PkArgs = {
  cloud: Scalars['String'];
  plan_name: Scalars['String'];
  region: Scalars['String'];
};

export type Subscription_RootProjects_Pool_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Projects_Pool_Config_Stream_Cursor_Input>>;
  where?: Maybe<Projects_Pool_Config_Bool_Exp>;
};

export type Subscription_RootProjects_Pro_Key_GenerationsArgs = {
  distinct_on?: Maybe<Array<Projects_Pro_Key_Generations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Pro_Key_Generations_Order_By>>;
  where?: Maybe<Projects_Pro_Key_Generations_Bool_Exp>;
};

export type Subscription_RootProjects_Pro_Key_Generations_AggregateArgs = {
  distinct_on?: Maybe<Array<Projects_Pro_Key_Generations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Pro_Key_Generations_Order_By>>;
  where?: Maybe<Projects_Pro_Key_Generations_Bool_Exp>;
};

export type Subscription_RootProjects_Pro_Key_Generations_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootProjects_Pro_Key_Generations_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Projects_Pro_Key_Generations_Stream_Cursor_Input>>;
  where?: Maybe<Projects_Pro_Key_Generations_Bool_Exp>;
};

export type Subscription_RootProjects_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Projects_Stream_Cursor_Input>>;
  where?: Maybe<Projects_Bool_Exp>;
};

export type Subscription_RootProjects_With_No_Running_DeploymentsArgs = {
  distinct_on?: Maybe<
    Array<Projects_With_No_Running_Deployments_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_With_No_Running_Deployments_Order_By>>;
  where?: Maybe<Projects_With_No_Running_Deployments_Bool_Exp>;
};

export type Subscription_RootProjects_With_No_Running_Deployments_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Projects_With_No_Running_Deployments_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Projects_With_No_Running_Deployments_Order_By>>;
    where?: Maybe<Projects_With_No_Running_Deployments_Bool_Exp>;
  };

export type Subscription_RootProjects_With_No_Running_Deployments_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<
    Maybe<Projects_With_No_Running_Deployments_Stream_Cursor_Input>
  >;
  where?: Maybe<Projects_With_No_Running_Deployments_Bool_Exp>;
};

export type Subscription_RootProjects_With_No_Running_Preview_AppArgs = {
  distinct_on?: Maybe<
    Array<Projects_With_No_Running_Preview_App_Select_Column>
  >;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_With_No_Running_Preview_App_Order_By>>;
  where?: Maybe<Projects_With_No_Running_Preview_App_Bool_Exp>;
};

export type Subscription_RootProjects_With_No_Running_Preview_App_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Projects_With_No_Running_Preview_App_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Projects_With_No_Running_Preview_App_Order_By>>;
    where?: Maybe<Projects_With_No_Running_Preview_App_Bool_Exp>;
  };

export type Subscription_RootProjects_With_No_Running_Preview_App_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<
    Maybe<Projects_With_No_Running_Preview_App_Stream_Cursor_Input>
  >;
  where?: Maybe<Projects_With_No_Running_Preview_App_Bool_Exp>;
};

export type Subscription_RootPrometheus_ConfigArgs = {
  distinct_on?: Maybe<Array<Prometheus_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Prometheus_Config_Order_By>>;
  where?: Maybe<Prometheus_Config_Bool_Exp>;
};

export type Subscription_RootPrometheus_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Prometheus_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Prometheus_Config_Order_By>>;
  where?: Maybe<Prometheus_Config_Bool_Exp>;
};

export type Subscription_RootPrometheus_Config_By_PkArgs = {
  project_id: Scalars['uuid'];
};

export type Subscription_RootPrometheus_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Prometheus_Config_Stream_Cursor_Input>>;
  where?: Maybe<Prometheus_Config_Bool_Exp>;
};

export type Subscription_RootProvidersArgs = {
  distinct_on?: Maybe<Array<Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Providers_Order_By>>;
  where?: Maybe<Providers_Bool_Exp>;
};

export type Subscription_RootProviders_AggregateArgs = {
  distinct_on?: Maybe<Array<Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Providers_Order_By>>;
  where?: Maybe<Providers_Bool_Exp>;
};

export type Subscription_RootProviders_By_PkArgs = {
  id: Scalars['Int'];
};

export type Subscription_RootProviders_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Providers_Stream_Cursor_Input>>;
  where?: Maybe<Providers_Bool_Exp>;
};

export type Subscription_RootProvisioningArgs = {
  distinct_on?: Maybe<Array<Provisioning_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Provisioning_Order_By>>;
  where?: Maybe<Provisioning_Bool_Exp>;
};

export type Subscription_RootProvisioning_AggregateArgs = {
  distinct_on?: Maybe<Array<Provisioning_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Provisioning_Order_By>>;
  where?: Maybe<Provisioning_Bool_Exp>;
};

export type Subscription_RootProvisioning_By_PkArgs = {
  provisioning: Scalars['String'];
};

export type Subscription_RootProvisioning_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Provisioning_Stream_Cursor_Input>>;
  where?: Maybe<Provisioning_Bool_Exp>;
};

export type Subscription_RootRegionArgs = {
  distinct_on?: Maybe<Array<Region_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Region_Order_By>>;
  where?: Maybe<Region_Bool_Exp>;
};

export type Subscription_RootRegion_AggregateArgs = {
  distinct_on?: Maybe<Array<Region_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Region_Order_By>>;
  where?: Maybe<Region_Bool_Exp>;
};

export type Subscription_RootRegion_By_PkArgs = {
  cloud: Cloud_Enum;
  name: Scalars['String'];
};

export type Subscription_RootRegion_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Region_Stream_Cursor_Input>>;
  where?: Maybe<Region_Bool_Exp>;
};

export type Subscription_RootRegion_V2Args = {
  distinct_on?: Maybe<Array<Region_V2_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Region_V2_Order_By>>;
  where?: Maybe<Region_V2_Bool_Exp>;
};

export type Subscription_RootRegion_V2_AggregateArgs = {
  distinct_on?: Maybe<Array<Region_V2_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Region_V2_Order_By>>;
  where?: Maybe<Region_V2_Bool_Exp>;
};

export type Subscription_RootRegion_V2_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Region_V2_Stream_Cursor_Input>>;
  where?: Maybe<Region_V2_Bool_Exp>;
};

export type Subscription_RootRegional_Data_ConnectorsArgs = {
  distinct_on?: Maybe<Array<Regional_Data_Connectors_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Regional_Data_Connectors_Order_By>>;
  where?: Maybe<Regional_Data_Connectors_Bool_Exp>;
};

export type Subscription_RootRegional_Data_Connectors_AggregateArgs = {
  distinct_on?: Maybe<Array<Regional_Data_Connectors_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Regional_Data_Connectors_Order_By>>;
  where?: Maybe<Regional_Data_Connectors_Bool_Exp>;
};

export type Subscription_RootRegional_Data_Connectors_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootRegional_Data_Connectors_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Regional_Data_Connectors_Stream_Cursor_Input>>;
  where?: Maybe<Regional_Data_Connectors_Bool_Exp>;
};

export type Subscription_RootRegional_MetricsArgs = {
  distinct_on?: Maybe<Array<Regional_Metrics_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Regional_Metrics_Order_By>>;
  where?: Maybe<Regional_Metrics_Bool_Exp>;
};

export type Subscription_RootRegional_Metrics_AggregateArgs = {
  distinct_on?: Maybe<Array<Regional_Metrics_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Regional_Metrics_Order_By>>;
  where?: Maybe<Regional_Metrics_Bool_Exp>;
};

export type Subscription_RootRegional_Metrics_By_PkArgs = {
  cloud: Scalars['String'];
  region: Scalars['String'];
};

export type Subscription_RootRegional_Metrics_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Regional_Metrics_Stream_Cursor_Input>>;
  where?: Maybe<Regional_Metrics_Bool_Exp>;
};

export type Subscription_RootSaml_IdpArgs = {
  distinct_on?: Maybe<Array<Saml_Idp_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Saml_Idp_Order_By>>;
  where?: Maybe<Saml_Idp_Bool_Exp>;
};

export type Subscription_RootSaml_Idp_AggregateArgs = {
  distinct_on?: Maybe<Array<Saml_Idp_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Saml_Idp_Order_By>>;
  where?: Maybe<Saml_Idp_Bool_Exp>;
};

export type Subscription_RootSaml_Idp_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSaml_Idp_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Saml_Idp_Stream_Cursor_Input>>;
  where?: Maybe<Saml_Idp_Bool_Exp>;
};

export type Subscription_RootSearch_Project_Login_StatusArgs = {
  args: Search_Project_Login_Status_Args;
  distinct_on?: Maybe<Array<Search_Project_Login_Status_Results_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Search_Project_Login_Status_Results_Order_By>>;
  where?: Maybe<Search_Project_Login_Status_Results_Bool_Exp>;
};

export type Subscription_RootSearch_Project_Login_Status_AggregateArgs = {
  args: Search_Project_Login_Status_Args;
  distinct_on?: Maybe<Array<Search_Project_Login_Status_Results_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Search_Project_Login_Status_Results_Order_By>>;
  where?: Maybe<Search_Project_Login_Status_Results_Bool_Exp>;
};

export type Subscription_RootSearch_Project_Login_Status_ResultsArgs = {
  distinct_on?: Maybe<Array<Search_Project_Login_Status_Results_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Search_Project_Login_Status_Results_Order_By>>;
  where?: Maybe<Search_Project_Login_Status_Results_Bool_Exp>;
};

export type Subscription_RootSearch_Project_Login_Status_Results_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Search_Project_Login_Status_Results_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Search_Project_Login_Status_Results_Order_By>>;
    where?: Maybe<Search_Project_Login_Status_Results_Bool_Exp>;
  };

export type Subscription_RootSearch_Project_Login_Status_Results_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Search_Project_Login_Status_Results_Stream_Cursor_Input>>;
  where?: Maybe<Search_Project_Login_Status_Results_Bool_Exp>;
};

export type Subscription_RootSearch_Tenant_Group_Has_Least_MembersArgs = {
  args: Search_Tenant_Group_Has_Least_Members_Args;
  distinct_on?: Maybe<Array<Tenant_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Order_By>>;
  where?: Maybe<Tenant_Group_Bool_Exp>;
};

export type Subscription_RootSearch_Tenant_Group_Has_Least_Members_AggregateArgs =
  {
    args: Search_Tenant_Group_Has_Least_Members_Args;
    distinct_on?: Maybe<Array<Tenant_Group_Select_Column>>;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Tenant_Group_Order_By>>;
    where?: Maybe<Tenant_Group_Bool_Exp>;
  };

export type Subscription_RootSlack_ConfigArgs = {
  distinct_on?: Maybe<Array<Slack_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Slack_Config_Order_By>>;
  where?: Maybe<Slack_Config_Bool_Exp>;
};

export type Subscription_RootSlack_Config_AggregateArgs = {
  distinct_on?: Maybe<Array<Slack_Config_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Slack_Config_Order_By>>;
  where?: Maybe<Slack_Config_Bool_Exp>;
};

export type Subscription_RootSlack_Config_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSlack_Config_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Slack_Config_Stream_Cursor_Input>>;
  where?: Maybe<Slack_Config_Bool_Exp>;
};

export type Subscription_RootStripe_SubscriptionArgs = {
  distinct_on?: Maybe<Array<Stripe_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stripe_Subscription_Order_By>>;
  where?: Maybe<Stripe_Subscription_Bool_Exp>;
};

export type Subscription_RootStripe_Subscription_AggregateArgs = {
  distinct_on?: Maybe<Array<Stripe_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stripe_Subscription_Order_By>>;
  where?: Maybe<Stripe_Subscription_Bool_Exp>;
};

export type Subscription_RootStripe_Subscription_By_PkArgs = {
  customer_id: Scalars['String'];
  subscription_id: Scalars['String'];
};

export type Subscription_RootStripe_Subscription_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Stripe_Subscription_Stream_Cursor_Input>>;
  where?: Maybe<Stripe_Subscription_Bool_Exp>;
};

export type Subscription_RootStripe_Webhook_EventsArgs = {
  distinct_on?: Maybe<Array<Stripe_Webhook_Events_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stripe_Webhook_Events_Order_By>>;
  where?: Maybe<Stripe_Webhook_Events_Bool_Exp>;
};

export type Subscription_RootStripe_Webhook_Events_AggregateArgs = {
  distinct_on?: Maybe<Array<Stripe_Webhook_Events_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Stripe_Webhook_Events_Order_By>>;
  where?: Maybe<Stripe_Webhook_Events_Bool_Exp>;
};

export type Subscription_RootStripe_Webhook_Events_By_PkArgs = {
  stripe_event_id: Scalars['String'];
};

export type Subscription_RootStripe_Webhook_Events_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Stripe_Webhook_Events_Stream_Cursor_Input>>;
  where?: Maybe<Stripe_Webhook_Events_Bool_Exp>;
};

export type Subscription_RootSuper_Connector_TypesArgs = {
  distinct_on?: Maybe<Array<Super_Connector_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Super_Connector_Types_Order_By>>;
  where?: Maybe<Super_Connector_Types_Bool_Exp>;
};

export type Subscription_RootSuper_Connector_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Super_Connector_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Super_Connector_Types_Order_By>>;
  where?: Maybe<Super_Connector_Types_Bool_Exp>;
};

export type Subscription_RootSuper_Connector_Types_By_PkArgs = {
  type: Scalars['String'];
};

export type Subscription_RootSuper_Connector_Types_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Super_Connector_Types_Stream_Cursor_Input>>;
  where?: Maybe<Super_Connector_Types_Bool_Exp>;
};

export type Subscription_RootSupport_Plan_TypesArgs = {
  distinct_on?: Maybe<Array<Support_Plan_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Support_Plan_Types_Order_By>>;
  where?: Maybe<Support_Plan_Types_Bool_Exp>;
};

export type Subscription_RootSupport_Plan_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<Support_Plan_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Support_Plan_Types_Order_By>>;
  where?: Maybe<Support_Plan_Types_Bool_Exp>;
};

export type Subscription_RootSupport_Plan_Types_By_PkArgs = {
  value: Scalars['String'];
};

export type Subscription_RootSupport_Plan_Types_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Support_Plan_Types_Stream_Cursor_Input>>;
  where?: Maybe<Support_Plan_Types_Bool_Exp>;
};

export type Subscription_RootSurveyArgs = {
  distinct_on?: Maybe<Array<Survey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Order_By>>;
  where?: Maybe<Survey_Bool_Exp>;
};

export type Subscription_RootSurvey_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Order_By>>;
  where?: Maybe<Survey_Bool_Exp>;
};

export type Subscription_RootSurvey_By_PkArgs = {
  survey_name: Scalars['String'];
};

export type Subscription_RootSurvey_QuestionArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Order_By>>;
  where?: Maybe<Survey_Question_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Order_By>>;
  where?: Maybe<Survey_Question_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_Answer_OptionArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Answer_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Answer_Option_Order_By>>;
  where?: Maybe<Survey_Question_Answer_Option_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_Answer_Option_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Answer_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Answer_Option_Order_By>>;
  where?: Maybe<Survey_Question_Answer_Option_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_Answer_Option_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSurvey_Question_Answer_Option_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_Question_Answer_Option_Stream_Cursor_Input>>;
  where?: Maybe<Survey_Question_Answer_Option_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_AnswersArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Answers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Answers_Order_By>>;
  where?: Maybe<Survey_Question_Answers_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_Answers_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Answers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Answers_Order_By>>;
  where?: Maybe<Survey_Question_Answers_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_Answers_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSurvey_Question_Answers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_Question_Answers_Stream_Cursor_Input>>;
  where?: Maybe<Survey_Question_Answers_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSurvey_Question_KindArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Kind_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Kind_Order_By>>;
  where?: Maybe<Survey_Question_Kind_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_Kind_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Kind_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Kind_Order_By>>;
  where?: Maybe<Survey_Question_Kind_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_Kind_By_PkArgs = {
  kind: Scalars['String'];
};

export type Subscription_RootSurvey_Question_Kind_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_Question_Kind_Stream_Cursor_Input>>;
  where?: Maybe<Survey_Question_Kind_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_OptionsArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Options_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Options_Order_By>>;
  where?: Maybe<Survey_Question_Options_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_Options_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Options_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Options_Order_By>>;
  where?: Maybe<Survey_Question_Options_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_Options_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSurvey_Question_Options_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_Question_Options_Stream_Cursor_Input>>;
  where?: Maybe<Survey_Question_Options_Bool_Exp>;
};

export type Subscription_RootSurvey_Question_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_Question_Stream_Cursor_Input>>;
  where?: Maybe<Survey_Question_Bool_Exp>;
};

export type Subscription_RootSurvey_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_Stream_Cursor_Input>>;
  where?: Maybe<Survey_Bool_Exp>;
};

export type Subscription_RootSurvey_V2Args = {
  distinct_on?: Maybe<Array<Survey_V2_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Order_By>>;
  where?: Maybe<Survey_V2_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Order_By>>;
  where?: Maybe<Survey_V2_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSurvey_V2_QuestionArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Order_By>>;
  where?: Maybe<Survey_V2_Question_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Question_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Order_By>>;
  where?: Maybe<Survey_V2_Question_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Question_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSurvey_V2_Question_KindArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Kind_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Kind_Order_By>>;
  where?: Maybe<Survey_V2_Question_Kind_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Question_Kind_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Kind_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Kind_Order_By>>;
  where?: Maybe<Survey_V2_Question_Kind_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Question_Kind_By_PkArgs = {
  kind: Scalars['String'];
};

export type Subscription_RootSurvey_V2_Question_Kind_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_V2_Question_Kind_Stream_Cursor_Input>>;
  where?: Maybe<Survey_V2_Question_Kind_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Question_OptionArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Option_Order_By>>;
  where?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Question_Option_Additional_Info_ConfigArgs =
  {
    distinct_on?: Maybe<
      Array<Survey_V2_Question_Option_Additional_Info_Config_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<
      Array<Survey_V2_Question_Option_Additional_Info_Config_Order_By>
    >;
    where?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp>;
  };

export type Subscription_RootSurvey_V2_Question_Option_Additional_Info_Config_AggregateArgs =
  {
    distinct_on?: Maybe<
      Array<Survey_V2_Question_Option_Additional_Info_Config_Select_Column>
    >;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<
      Array<Survey_V2_Question_Option_Additional_Info_Config_Order_By>
    >;
    where?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp>;
  };

export type Subscription_RootSurvey_V2_Question_Option_Additional_Info_Config_By_PkArgs =
  {
    id: Scalars['uuid'];
  };

export type Subscription_RootSurvey_V2_Question_Option_Additional_Info_Config_StreamArgs =
  {
    batch_size: Scalars['Int'];
    cursor: Array<
      Maybe<Survey_V2_Question_Option_Additional_Info_Config_Stream_Cursor_Input>
    >;
    where?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp>;
  };

export type Subscription_RootSurvey_V2_Question_Option_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Option_Order_By>>;
  where?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Question_Option_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSurvey_V2_Question_Option_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_V2_Question_Option_Stream_Cursor_Input>>;
  where?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Question_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_V2_Question_Stream_Cursor_Input>>;
  where?: Maybe<Survey_V2_Question_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_ResponseArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Order_By>>;
  where?: Maybe<Survey_V2_Response_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Response_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Order_By>>;
  where?: Maybe<Survey_V2_Response_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Response_AnswerArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Response_Answer_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Response_Answer_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSurvey_V2_Response_Answer_OptionArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Option_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Option_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Response_Answer_Option_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Option_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Option_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Response_Answer_Option_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSurvey_V2_Response_Answer_Option_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_V2_Response_Answer_Option_Stream_Cursor_Input>>;
  where?: Maybe<Survey_V2_Response_Answer_Option_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Response_Answer_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_V2_Response_Answer_Stream_Cursor_Input>>;
  where?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_Response_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootSurvey_V2_Response_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_V2_Response_Stream_Cursor_Input>>;
  where?: Maybe<Survey_V2_Response_Bool_Exp>;
};

export type Subscription_RootSurvey_V2_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Survey_V2_Stream_Cursor_Input>>;
  where?: Maybe<Survey_V2_Bool_Exp>;
};

export type Subscription_RootTask_EventArgs = {
  distinct_on?: Maybe<Array<Task_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Task_Event_Order_By>>;
  where?: Maybe<Task_Event_Bool_Exp>;
};

export type Subscription_RootTask_Event_AggregateArgs = {
  distinct_on?: Maybe<Array<Task_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Task_Event_Order_By>>;
  where?: Maybe<Task_Event_Bool_Exp>;
};

export type Subscription_RootTask_Event_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootTask_Event_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Task_Event_Stream_Cursor_Input>>;
  where?: Maybe<Task_Event_Bool_Exp>;
};

export type Subscription_RootTaskq_Worker_Event_LatestArgs = {
  distinct_on?: Maybe<Array<Taskq_Worker_Event_Latest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Taskq_Worker_Event_Latest_Order_By>>;
  where?: Maybe<Taskq_Worker_Event_Latest_Bool_Exp>;
};

export type Subscription_RootTaskq_Worker_Event_Latest_AggregateArgs = {
  distinct_on?: Maybe<Array<Taskq_Worker_Event_Latest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Taskq_Worker_Event_Latest_Order_By>>;
  where?: Maybe<Taskq_Worker_Event_Latest_Bool_Exp>;
};

export type Subscription_RootTaskq_Worker_Event_Latest_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Taskq_Worker_Event_Latest_Stream_Cursor_Input>>;
  where?: Maybe<Taskq_Worker_Event_Latest_Bool_Exp>;
};

export type Subscription_RootTasksArgs = {
  distinct_on?: Maybe<Array<Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tasks_Order_By>>;
  where?: Maybe<Tasks_Bool_Exp>;
};

export type Subscription_RootTasks_AggregateArgs = {
  distinct_on?: Maybe<Array<Tasks_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tasks_Order_By>>;
  where?: Maybe<Tasks_Bool_Exp>;
};

export type Subscription_RootTasks_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootTasks_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Tasks_Stream_Cursor_Input>>;
  where?: Maybe<Tasks_Bool_Exp>;
};

export type Subscription_RootTenantArgs = {
  distinct_on?: Maybe<Array<Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Order_By>>;
  where?: Maybe<Tenant_Bool_Exp>;
};

export type Subscription_RootTenant_Active_Status_ReasonArgs = {
  distinct_on?: Maybe<Array<Tenant_Active_Status_Reason_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Active_Status_Reason_Order_By>>;
  where?: Maybe<Tenant_Active_Status_Reason_Bool_Exp>;
};

export type Subscription_RootTenant_Active_Status_Reason_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Active_Status_Reason_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Active_Status_Reason_Order_By>>;
  where?: Maybe<Tenant_Active_Status_Reason_Bool_Exp>;
};

export type Subscription_RootTenant_Active_Status_Reason_By_PkArgs = {
  name: Scalars['String'];
};

export type Subscription_RootTenant_Active_Status_Reason_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Tenant_Active_Status_Reason_Stream_Cursor_Input>>;
  where?: Maybe<Tenant_Active_Status_Reason_Bool_Exp>;
};

export type Subscription_RootTenant_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Order_By>>;
  where?: Maybe<Tenant_Bool_Exp>;
};

export type Subscription_RootTenant_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootTenant_GroupArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Order_By>>;
  where?: Maybe<Tenant_Group_Bool_Exp>;
};

export type Subscription_RootTenant_Group_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Order_By>>;
  where?: Maybe<Tenant_Group_Bool_Exp>;
};

export type Subscription_RootTenant_Group_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootTenant_Group_MemberArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Member_Order_By>>;
  where?: Maybe<Tenant_Group_Member_Bool_Exp>;
};

export type Subscription_RootTenant_Group_Member_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Member_Order_By>>;
  where?: Maybe<Tenant_Group_Member_Bool_Exp>;
};

export type Subscription_RootTenant_Group_Member_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootTenant_Group_Member_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Tenant_Group_Member_Stream_Cursor_Input>>;
  where?: Maybe<Tenant_Group_Member_Bool_Exp>;
};

export type Subscription_RootTenant_Group_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Tenant_Group_Stream_Cursor_Input>>;
  where?: Maybe<Tenant_Group_Bool_Exp>;
};

export type Subscription_RootTenant_Public_StatusArgs = {
  distinct_on?: Maybe<Array<Tenant_Public_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Public_Status_Order_By>>;
  where?: Maybe<Tenant_Public_Status_Bool_Exp>;
};

export type Subscription_RootTenant_Public_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Public_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Public_Status_Order_By>>;
  where?: Maybe<Tenant_Public_Status_Bool_Exp>;
};

export type Subscription_RootTenant_Public_Status_By_PkArgs = {
  endpoint: Scalars['String'];
  tenant_id: Scalars['uuid'];
};

export type Subscription_RootTenant_Public_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Tenant_Public_Status_Stream_Cursor_Input>>;
  where?: Maybe<Tenant_Public_Status_Bool_Exp>;
};

export type Subscription_RootTenant_StatusArgs = {
  distinct_on?: Maybe<Array<Tenant_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Status_Order_By>>;
  where?: Maybe<Tenant_Status_Bool_Exp>;
};

export type Subscription_RootTenant_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Status_Order_By>>;
  where?: Maybe<Tenant_Status_Bool_Exp>;
};

export type Subscription_RootTenant_Status_By_PkArgs = {
  tenant_id: Scalars['uuid'];
  worker_id: Scalars['uuid'];
};

export type Subscription_RootTenant_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Tenant_Status_Stream_Cursor_Input>>;
  where?: Maybe<Tenant_Status_Bool_Exp>;
};

export type Subscription_RootTenant_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Tenant_Stream_Cursor_Input>>;
  where?: Maybe<Tenant_Bool_Exp>;
};

export type Subscription_RootTrial_LeadsArgs = {
  distinct_on?: Maybe<Array<Trial_Leads_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Trial_Leads_Order_By>>;
  where?: Maybe<Trial_Leads_Bool_Exp>;
};

export type Subscription_RootTrial_Leads_AggregateArgs = {
  distinct_on?: Maybe<Array<Trial_Leads_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Trial_Leads_Order_By>>;
  where?: Maybe<Trial_Leads_Bool_Exp>;
};

export type Subscription_RootTrial_Leads_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootTrial_Leads_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Trial_Leads_Stream_Cursor_Input>>;
  where?: Maybe<Trial_Leads_Bool_Exp>;
};

export type Subscription_RootUa_Audit_LogsArgs = {
  distinct_on?: Maybe<Array<Ua_Audit_Logs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ua_Audit_Logs_Order_By>>;
  where?: Maybe<Ua_Audit_Logs_Bool_Exp>;
};

export type Subscription_RootUa_Audit_Logs_AggregateArgs = {
  distinct_on?: Maybe<Array<Ua_Audit_Logs_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Ua_Audit_Logs_Order_By>>;
  where?: Maybe<Ua_Audit_Logs_Bool_Exp>;
};

export type Subscription_RootUa_Audit_Logs_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootUa_Audit_Logs_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Ua_Audit_Logs_Stream_Cursor_Input>>;
  where?: Maybe<Ua_Audit_Logs_Bool_Exp>;
};

export type Subscription_RootUser_ActivityArgs = {
  distinct_on?: Maybe<Array<User_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Activity_Order_By>>;
  where?: Maybe<User_Activity_Bool_Exp>;
};

export type Subscription_RootUser_Activity_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Activity_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Activity_Order_By>>;
  where?: Maybe<User_Activity_Bool_Exp>;
};

export type Subscription_RootUser_Activity_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootUser_Activity_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Activity_Stream_Cursor_Input>>;
  where?: Maybe<User_Activity_Bool_Exp>;
};

export type Subscription_RootUser_CouponArgs = {
  distinct_on?: Maybe<Array<User_Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Coupon_Order_By>>;
  where?: Maybe<User_Coupon_Bool_Exp>;
};

export type Subscription_RootUser_Coupon_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Coupon_Order_By>>;
  where?: Maybe<User_Coupon_Bool_Exp>;
};

export type Subscription_RootUser_Coupon_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootUser_Coupon_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Coupon_Stream_Cursor_Input>>;
  where?: Maybe<User_Coupon_Bool_Exp>;
};

export type Subscription_RootUser_Entitlement_AccessArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Access_Order_By>>;
  where?: Maybe<User_Entitlement_Access_Bool_Exp>;
};

export type Subscription_RootUser_Entitlement_Access_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Access_Order_By>>;
  where?: Maybe<User_Entitlement_Access_Bool_Exp>;
};

export type Subscription_RootUser_Entitlement_Access_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootUser_Entitlement_Access_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Entitlement_Access_Stream_Cursor_Input>>;
  where?: Maybe<User_Entitlement_Access_Bool_Exp>;
};

export type Subscription_RootUser_Entitlement_CatalogueArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<User_Entitlement_Catalogue_Bool_Exp>;
};

export type Subscription_RootUser_Entitlement_Catalogue_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Catalogue_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Catalogue_Order_By>>;
  where?: Maybe<User_Entitlement_Catalogue_Bool_Exp>;
};

export type Subscription_RootUser_Entitlement_Catalogue_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootUser_Entitlement_Catalogue_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Entitlement_Catalogue_Stream_Cursor_Input>>;
  where?: Maybe<User_Entitlement_Catalogue_Bool_Exp>;
};

export type Subscription_RootUser_Entitlement_TypesArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Types_Order_By>>;
  where?: Maybe<User_Entitlement_Types_Bool_Exp>;
};

export type Subscription_RootUser_Entitlement_Types_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Types_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Types_Order_By>>;
  where?: Maybe<User_Entitlement_Types_Bool_Exp>;
};

export type Subscription_RootUser_Entitlement_Types_By_PkArgs = {
  value: Scalars['String'];
};

export type Subscription_RootUser_Entitlement_Types_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Entitlement_Types_Stream_Cursor_Input>>;
  where?: Maybe<User_Entitlement_Types_Bool_Exp>;
};

export type Subscription_RootUser_OnboardingArgs = {
  distinct_on?: Maybe<Array<User_Onboarding_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Onboarding_Order_By>>;
  where?: Maybe<User_Onboarding_Bool_Exp>;
};

export type Subscription_RootUser_Onboarding_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Onboarding_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Onboarding_Order_By>>;
  where?: Maybe<User_Onboarding_Bool_Exp>;
};

export type Subscription_RootUser_Onboarding_By_PkArgs = {
  target: Scalars['String'];
  user_id: Scalars['uuid'];
};

export type Subscription_RootUser_Onboarding_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Onboarding_Stream_Cursor_Input>>;
  where?: Maybe<User_Onboarding_Bool_Exp>;
};

export type Subscription_RootUser_Personal_Access_TokensArgs = {
  distinct_on?: Maybe<Array<User_Personal_Access_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Personal_Access_Tokens_Order_By>>;
  where?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
};

export type Subscription_RootUser_Personal_Access_Tokens_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Personal_Access_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Personal_Access_Tokens_Order_By>>;
  where?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
};

export type Subscription_RootUser_Personal_Access_Tokens_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootUser_Personal_Access_Tokens_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Personal_Access_Tokens_Stream_Cursor_Input>>;
  where?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
};

export type Subscription_RootUser_ProfileArgs = {
  distinct_on?: Maybe<Array<User_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Profile_Order_By>>;
  where?: Maybe<User_Profile_Bool_Exp>;
};

export type Subscription_RootUser_Profile_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Profile_Order_By>>;
  where?: Maybe<User_Profile_Bool_Exp>;
};

export type Subscription_RootUser_Profile_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootUser_Profile_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Profile_Stream_Cursor_Input>>;
  where?: Maybe<User_Profile_Bool_Exp>;
};

export type Subscription_RootUser_Project_MapArgs = {
  distinct_on?: Maybe<Array<User_Project_Map_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Project_Map_Order_By>>;
  where?: Maybe<User_Project_Map_Bool_Exp>;
};

export type Subscription_RootUser_Project_Map_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Project_Map_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Project_Map_Order_By>>;
  where?: Maybe<User_Project_Map_Bool_Exp>;
};

export type Subscription_RootUser_Project_Map_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Project_Map_Stream_Cursor_Input>>;
  where?: Maybe<User_Project_Map_Bool_Exp>;
};

export type Subscription_RootUser_RolesArgs = {
  distinct_on?: Maybe<Array<User_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Roles_Order_By>>;
  where?: Maybe<User_Roles_Bool_Exp>;
};

export type Subscription_RootUser_Roles_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Roles_Order_By>>;
  where?: Maybe<User_Roles_Bool_Exp>;
};

export type Subscription_RootUser_Roles_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootUser_Roles_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Roles_Stream_Cursor_Input>>;
  where?: Maybe<User_Roles_Bool_Exp>;
};

export type Subscription_RootUser_Vpc_PolicyArgs = {
  distinct_on?: Maybe<Array<User_Vpc_Policy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Vpc_Policy_Order_By>>;
  where?: Maybe<User_Vpc_Policy_Bool_Exp>;
};

export type Subscription_RootUser_Vpc_Policy_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Vpc_Policy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Vpc_Policy_Order_By>>;
  where?: Maybe<User_Vpc_Policy_Bool_Exp>;
};

export type Subscription_RootUser_Vpc_Policy_By_PkArgs = {
  id: Scalars['Int'];
};

export type Subscription_RootUser_Vpc_Policy_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<User_Vpc_Policy_Stream_Cursor_Input>>;
  where?: Maybe<User_Vpc_Policy_Bool_Exp>;
};

export type Subscription_RootUsersArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};

export type Subscription_RootUsers_AggregateArgs = {
  distinct_on?: Maybe<Array<Users_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Order_By>>;
  where?: Maybe<Users_Bool_Exp>;
};

export type Subscription_RootUsers_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootUsers_PublicArgs = {
  distinct_on?: Maybe<Array<Users_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Public_Order_By>>;
  where?: Maybe<Users_Public_Bool_Exp>;
};

export type Subscription_RootUsers_Public_AggregateArgs = {
  distinct_on?: Maybe<Array<Users_Public_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Users_Public_Order_By>>;
  where?: Maybe<Users_Public_Bool_Exp>;
};

export type Subscription_RootUsers_Public_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Users_Public_Stream_Cursor_Input>>;
  where?: Maybe<Users_Public_Bool_Exp>;
};

export type Subscription_RootUsers_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Users_Stream_Cursor_Input>>;
  where?: Maybe<Users_Bool_Exp>;
};

export type Subscription_RootVercel_IntegrationArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Order_By>>;
  where?: Maybe<Vercel_Integration_Bool_Exp>;
};

export type Subscription_RootVercel_Integration_AggregateArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Order_By>>;
  where?: Maybe<Vercel_Integration_Bool_Exp>;
};

export type Subscription_RootVercel_Integration_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootVercel_Integration_ConnectionsArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Connections_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Connections_Order_By>>;
  where?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
};

export type Subscription_RootVercel_Integration_Connections_AggregateArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Connections_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Connections_Order_By>>;
  where?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
};

export type Subscription_RootVercel_Integration_Connections_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootVercel_Integration_Connections_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Vercel_Integration_Connections_Stream_Cursor_Input>>;
  where?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
};

export type Subscription_RootVercel_Integration_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Vercel_Integration_Stream_Cursor_Input>>;
  where?: Maybe<Vercel_Integration_Bool_Exp>;
};

export type Subscription_RootVpc_PeeringArgs = {
  distinct_on?: Maybe<Array<Vpc_Peering_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Peering_Order_By>>;
  where?: Maybe<Vpc_Peering_Bool_Exp>;
};

export type Subscription_RootVpc_Peering_AggregateArgs = {
  distinct_on?: Maybe<Array<Vpc_Peering_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Peering_Order_By>>;
  where?: Maybe<Vpc_Peering_Bool_Exp>;
};

export type Subscription_RootVpc_Peering_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootVpc_Peering_DirectionArgs = {
  distinct_on?: Maybe<Array<Vpc_Peering_Direction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Peering_Direction_Order_By>>;
  where?: Maybe<Vpc_Peering_Direction_Bool_Exp>;
};

export type Subscription_RootVpc_Peering_Direction_AggregateArgs = {
  distinct_on?: Maybe<Array<Vpc_Peering_Direction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Peering_Direction_Order_By>>;
  where?: Maybe<Vpc_Peering_Direction_Bool_Exp>;
};

export type Subscription_RootVpc_Peering_Direction_By_PkArgs = {
  direction: Scalars['String'];
};

export type Subscription_RootVpc_Peering_Direction_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Vpc_Peering_Direction_Stream_Cursor_Input>>;
  where?: Maybe<Vpc_Peering_Direction_Bool_Exp>;
};

export type Subscription_RootVpc_Peering_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Vpc_Peering_Stream_Cursor_Input>>;
  where?: Maybe<Vpc_Peering_Bool_Exp>;
};

export type Subscription_RootVpc_StatusArgs = {
  distinct_on?: Maybe<Array<Vpc_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Status_Order_By>>;
  where?: Maybe<Vpc_Status_Bool_Exp>;
};

export type Subscription_RootVpc_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Vpc_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vpc_Status_Order_By>>;
  where?: Maybe<Vpc_Status_Bool_Exp>;
};

export type Subscription_RootVpc_Status_By_PkArgs = {
  status: Scalars['String'];
};

export type Subscription_RootVpc_Status_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Vpc_Status_Stream_Cursor_Input>>;
  where?: Maybe<Vpc_Status_Bool_Exp>;
};

export type Subscription_RootZendesk_Support_CategoryArgs = {
  distinct_on?: Maybe<Array<Zendesk_Support_Category_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Zendesk_Support_Category_Order_By>>;
  where?: Maybe<Zendesk_Support_Category_Bool_Exp>;
};

export type Subscription_RootZendesk_Support_Category_AggregateArgs = {
  distinct_on?: Maybe<Array<Zendesk_Support_Category_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Zendesk_Support_Category_Order_By>>;
  where?: Maybe<Zendesk_Support_Category_Bool_Exp>;
};

export type Subscription_RootZendesk_Support_Category_By_PkArgs = {
  name: Scalars['String'];
};

export type Subscription_RootZendesk_Support_Category_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Zendesk_Support_Category_Stream_Cursor_Input>>;
  where?: Maybe<Zendesk_Support_Category_Bool_Exp>;
};

export type Subscription_RootZendesk_Support_TicketsArgs = {
  distinct_on?: Maybe<Array<Zendesk_Support_Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Zendesk_Support_Tickets_Order_By>>;
  where?: Maybe<Zendesk_Support_Tickets_Bool_Exp>;
};

export type Subscription_RootZendesk_Support_Tickets_AggregateArgs = {
  distinct_on?: Maybe<Array<Zendesk_Support_Tickets_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Zendesk_Support_Tickets_Order_By>>;
  where?: Maybe<Zendesk_Support_Tickets_Bool_Exp>;
};

export type Subscription_RootZendesk_Support_Tickets_By_PkArgs = {
  id: Scalars['uuid'];
};

export type Subscription_RootZendesk_Support_Tickets_StreamArgs = {
  batch_size: Scalars['Int'];
  cursor: Array<Maybe<Zendesk_Support_Tickets_Stream_Cursor_Input>>;
  where?: Maybe<Zendesk_Support_Tickets_Bool_Exp>;
};

export type SuccessOrError = {
  __typename?: 'SuccessOrError';
  status: Scalars['String'];
};

/** Hasua enum to capture different super connector types  in infra */
export type Super_Connector_Types = {
  __typename?: 'super_connector_types';
  description: Scalars['String'];
  type: Scalars['String'];
};

/** aggregated selection of "super_connector_types" */
export type Super_Connector_Types_Aggregate = {
  __typename?: 'super_connector_types_aggregate';
  aggregate?: Maybe<Super_Connector_Types_Aggregate_Fields>;
  nodes: Array<Super_Connector_Types>;
};

/** aggregate fields of "super_connector_types" */
export type Super_Connector_Types_Aggregate_Fields = {
  __typename?: 'super_connector_types_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Super_Connector_Types_Max_Fields>;
  min?: Maybe<Super_Connector_Types_Min_Fields>;
};

/** aggregate fields of "super_connector_types" */
export type Super_Connector_Types_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Super_Connector_Types_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "super_connector_types". All fields are combined with a logical 'AND'. */
export type Super_Connector_Types_Bool_Exp = {
  _and?: Maybe<Array<Super_Connector_Types_Bool_Exp>>;
  _not?: Maybe<Super_Connector_Types_Bool_Exp>;
  _or?: Maybe<Array<Super_Connector_Types_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "super_connector_types" */
export enum Super_Connector_Types_Constraint {
  /** unique or primary key constraint on columns "type" */
  SuperConnectorTypesPkey = 'super_connector_types_pkey',
}

export enum Super_Connector_Types_Enum {
  /** Connect to super connector which is run along side graphql-engine-multitenant */
  Local = 'local',
}

/** Boolean expression to compare columns of type "super_connector_types_enum". All fields are combined with logical 'AND'. */
export type Super_Connector_Types_Enum_Comparison_Exp = {
  _eq?: Maybe<Super_Connector_Types_Enum>;
  _in?: Maybe<Array<Super_Connector_Types_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Super_Connector_Types_Enum>;
  _nin?: Maybe<Array<Super_Connector_Types_Enum>>;
};

/** input type for inserting data into table "super_connector_types" */
export type Super_Connector_Types_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Super_Connector_Types_Max_Fields = {
  __typename?: 'super_connector_types_max_fields';
  description?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Super_Connector_Types_Min_Fields = {
  __typename?: 'super_connector_types_min_fields';
  description?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "super_connector_types" */
export type Super_Connector_Types_Mutation_Response = {
  __typename?: 'super_connector_types_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Super_Connector_Types>;
};

/** on_conflict condition type for table "super_connector_types" */
export type Super_Connector_Types_On_Conflict = {
  constraint: Super_Connector_Types_Constraint;
  update_columns?: Array<Super_Connector_Types_Update_Column>;
  where?: Maybe<Super_Connector_Types_Bool_Exp>;
};

/** Ordering options when selecting data from "super_connector_types". */
export type Super_Connector_Types_Order_By = {
  description?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
};

/** primary key columns input for table: super_connector_types */
export type Super_Connector_Types_Pk_Columns_Input = {
  type: Scalars['String'];
};

/** select columns of table "super_connector_types" */
export enum Super_Connector_Types_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Type = 'type',
}

/** input type for updating data in table "super_connector_types" */
export type Super_Connector_Types_Set_Input = {
  description?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "super_connector_types" */
export type Super_Connector_Types_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Super_Connector_Types_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Super_Connector_Types_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  type?: Maybe<Scalars['String']>;
};

/** update columns of table "super_connector_types" */
export enum Super_Connector_Types_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Type = 'type',
}

export type Super_Connector_Types_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Super_Connector_Types_Set_Input>;
  /** filter the rows which have to be updated */
  where: Super_Connector_Types_Bool_Exp;
};

/** Enum to represent all support plan Hasura offers.  */
export type Support_Plan_Types = {
  __typename?: 'support_plan_types';
  comment: Scalars['String'];
  value: Scalars['String'];
};

/** aggregated selection of "support_plan_types" */
export type Support_Plan_Types_Aggregate = {
  __typename?: 'support_plan_types_aggregate';
  aggregate?: Maybe<Support_Plan_Types_Aggregate_Fields>;
  nodes: Array<Support_Plan_Types>;
};

/** aggregate fields of "support_plan_types" */
export type Support_Plan_Types_Aggregate_Fields = {
  __typename?: 'support_plan_types_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Support_Plan_Types_Max_Fields>;
  min?: Maybe<Support_Plan_Types_Min_Fields>;
};

/** aggregate fields of "support_plan_types" */
export type Support_Plan_Types_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Support_Plan_Types_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "support_plan_types". All fields are combined with a logical 'AND'. */
export type Support_Plan_Types_Bool_Exp = {
  _and?: Maybe<Array<Support_Plan_Types_Bool_Exp>>;
  _not?: Maybe<Support_Plan_Types_Bool_Exp>;
  _or?: Maybe<Array<Support_Plan_Types_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "support_plan_types" */
export enum Support_Plan_Types_Constraint {
  /** unique or primary key constraint on columns "value" */
  SupportPlanTypesPkey = 'support_plan_types_pkey',
}

export enum Support_Plan_Types_Enum {
  /** Bronze Support Plan for Cloud Dedicated users. */
  BronzeSupportTier = 'bronze_support_tier',
  /** Gold Support Plan for Cloud Dedicated users. */
  GoldSupportTier = 'gold_support_tier',
  /** Platinum Support Plan for Cloud Dedicated users. */
  PlatinumSupportTier = 'platinum_support_tier',
  /** Silver Support Plan for Cloud Dedicated users. */
  SilverSupportTier = 'silver_support_tier',
}

/** Boolean expression to compare columns of type "support_plan_types_enum". All fields are combined with logical 'AND'. */
export type Support_Plan_Types_Enum_Comparison_Exp = {
  _eq?: Maybe<Support_Plan_Types_Enum>;
  _in?: Maybe<Array<Support_Plan_Types_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Support_Plan_Types_Enum>;
  _nin?: Maybe<Array<Support_Plan_Types_Enum>>;
};

/** input type for inserting data into table "support_plan_types" */
export type Support_Plan_Types_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Support_Plan_Types_Max_Fields = {
  __typename?: 'support_plan_types_max_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Support_Plan_Types_Min_Fields = {
  __typename?: 'support_plan_types_min_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "support_plan_types" */
export type Support_Plan_Types_Mutation_Response = {
  __typename?: 'support_plan_types_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Support_Plan_Types>;
};

/** on_conflict condition type for table "support_plan_types" */
export type Support_Plan_Types_On_Conflict = {
  constraint: Support_Plan_Types_Constraint;
  update_columns?: Array<Support_Plan_Types_Update_Column>;
  where?: Maybe<Support_Plan_Types_Bool_Exp>;
};

/** Ordering options when selecting data from "support_plan_types". */
export type Support_Plan_Types_Order_By = {
  comment?: Maybe<Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: support_plan_types */
export type Support_Plan_Types_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "support_plan_types" */
export enum Support_Plan_Types_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value',
}

/** input type for updating data in table "support_plan_types" */
export type Support_Plan_Types_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "support_plan_types" */
export type Support_Plan_Types_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Support_Plan_Types_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Support_Plan_Types_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "support_plan_types" */
export enum Support_Plan_Types_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value',
}

export type Support_Plan_Types_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Support_Plan_Types_Set_Input>;
  /** filter the rows which have to be updated */
  where: Support_Plan_Types_Bool_Exp;
};

export type SupportTicketDetails = {
  __typename?: 'SupportTicketDetails';
  body: Scalars['String'];
  created_at: Scalars['String'];
  id: Scalars['Int'];
  project_id?: Maybe<Scalars['uuid']>;
  project_name?: Maybe<Scalars['String']>;
  status: Scalars['String'];
  subject: Scalars['String'];
  total_tickets: Scalars['Int'];
  zendesk_link: Scalars['String'];
};

export enum SupportTicketPriority {
  High = 'HIGH',
  Low = 'LOW',
  Normal = 'NORMAL',
  Urgent = 'URGENT',
}

/** information on a survey being conducted  */
export type Survey = {
  __typename?: 'survey';
  created_at: Scalars['timestamptz'];
  ended_at?: Maybe<Scalars['timestamptz']>;
  requested_by: Scalars['String'];
  started_at: Scalars['timestamptz'];
  survey_description?: Maybe<Scalars['String']>;
  survey_header?: Maybe<Scalars['String']>;
  survey_name: Scalars['String'];
  /** An array relationship */
  survey_questions: Array<Survey_Question>;
  /** An aggregate relationship */
  survey_questions_aggregate: Survey_Question_Aggregate;
  updated_at: Scalars['timestamptz'];
  updated_by?: Maybe<Scalars['String']>;
};

/** information on a survey being conducted  */
export type SurveySurvey_QuestionsArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Order_By>>;
  where?: Maybe<Survey_Question_Bool_Exp>;
};

/** information on a survey being conducted  */
export type SurveySurvey_Questions_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Order_By>>;
  where?: Maybe<Survey_Question_Bool_Exp>;
};

/** aggregated selection of "survey" */
export type Survey_Aggregate = {
  __typename?: 'survey_aggregate';
  aggregate?: Maybe<Survey_Aggregate_Fields>;
  nodes: Array<Survey>;
};

/** aggregate fields of "survey" */
export type Survey_Aggregate_Fields = {
  __typename?: 'survey_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Survey_Max_Fields>;
  min?: Maybe<Survey_Min_Fields>;
};

/** aggregate fields of "survey" */
export type Survey_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "survey". All fields are combined with a logical 'AND'. */
export type Survey_Bool_Exp = {
  _and?: Maybe<Array<Survey_Bool_Exp>>;
  _not?: Maybe<Survey_Bool_Exp>;
  _or?: Maybe<Array<Survey_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  ended_at?: Maybe<Timestamptz_Comparison_Exp>;
  requested_by?: Maybe<String_Comparison_Exp>;
  started_at?: Maybe<Timestamptz_Comparison_Exp>;
  survey_description?: Maybe<String_Comparison_Exp>;
  survey_header?: Maybe<String_Comparison_Exp>;
  survey_name?: Maybe<String_Comparison_Exp>;
  survey_questions?: Maybe<Survey_Question_Bool_Exp>;
  survey_questions_aggregate?: Maybe<Survey_Question_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  updated_by?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey" */
export enum Survey_Constraint {
  /** unique or primary key constraint on columns "survey_name" */
  SurveyPkey = 'survey_pkey',
}

/** input type for inserting data into table "survey" */
export type Survey_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  requested_by?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_description?: Maybe<Scalars['String']>;
  survey_header?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  survey_questions?: Maybe<Survey_Question_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  updated_by?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Survey_Max_Fields = {
  __typename?: 'survey_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  requested_by?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_description?: Maybe<Scalars['String']>;
  survey_header?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  updated_by?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Survey_Min_Fields = {
  __typename?: 'survey_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  requested_by?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_description?: Maybe<Scalars['String']>;
  survey_header?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  updated_by?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "survey" */
export type Survey_Mutation_Response = {
  __typename?: 'survey_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey>;
};

/** input type for inserting object relation for remote table "survey" */
export type Survey_Obj_Rel_Insert_Input = {
  data: Survey_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Survey_On_Conflict>;
};

/** on_conflict condition type for table "survey" */
export type Survey_On_Conflict = {
  constraint: Survey_Constraint;
  update_columns?: Array<Survey_Update_Column>;
  where?: Maybe<Survey_Bool_Exp>;
};

/** Ordering options when selecting data from "survey". */
export type Survey_Order_By = {
  created_at?: Maybe<Order_By>;
  ended_at?: Maybe<Order_By>;
  requested_by?: Maybe<Order_By>;
  started_at?: Maybe<Order_By>;
  survey_description?: Maybe<Order_By>;
  survey_header?: Maybe<Order_By>;
  survey_name?: Maybe<Order_By>;
  survey_questions_aggregate?: Maybe<Survey_Question_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
  updated_by?: Maybe<Order_By>;
};

/** primary key columns input for table: survey */
export type Survey_Pk_Columns_Input = {
  survey_name: Scalars['String'];
};

/** contains all questions for a survey  */
export type Survey_Question = {
  __typename?: 'survey_question';
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  kind: Survey_Question_Kind_Enum;
  question: Scalars['String'];
  /** An object relationship */
  survey: Survey;
  survey_name: Scalars['String'];
  /** An array relationship */
  survey_question_options: Array<Survey_Question_Options>;
  /** An aggregate relationship */
  survey_question_options_aggregate: Survey_Question_Options_Aggregate;
  updated_at: Scalars['timestamptz'];
};

/** contains all questions for a survey  */
export type Survey_QuestionSurvey_Question_OptionsArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Options_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Options_Order_By>>;
  where?: Maybe<Survey_Question_Options_Bool_Exp>;
};

/** contains all questions for a survey  */
export type Survey_QuestionSurvey_Question_Options_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Options_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Options_Order_By>>;
  where?: Maybe<Survey_Question_Options_Bool_Exp>;
};

/** aggregated selection of "survey_question" */
export type Survey_Question_Aggregate = {
  __typename?: 'survey_question_aggregate';
  aggregate?: Maybe<Survey_Question_Aggregate_Fields>;
  nodes: Array<Survey_Question>;
};

export type Survey_Question_Aggregate_Bool_Exp = {
  count?: Maybe<Survey_Question_Aggregate_Bool_Exp_Count>;
};

export type Survey_Question_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Survey_Question_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Survey_Question_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "survey_question" */
export type Survey_Question_Aggregate_Fields = {
  __typename?: 'survey_question_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Survey_Question_Max_Fields>;
  min?: Maybe<Survey_Question_Min_Fields>;
};

/** aggregate fields of "survey_question" */
export type Survey_Question_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_Question_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "survey_question" */
export type Survey_Question_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Survey_Question_Max_Order_By>;
  min?: Maybe<Survey_Question_Min_Order_By>;
};

/** contains all the answers given by a user for a given question */
export type Survey_Question_Answer_Option = {
  __typename?: 'survey_question_answer_option';
  answer?: Maybe<Scalars['String']>;
  answer_id: Scalars['uuid'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  option_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  survey_question_answer: Survey_Question_Answers;
  /** An object relationship */
  survey_question_option?: Maybe<Survey_Question_Options>;
};

/** aggregated selection of "survey_question_answer_option" */
export type Survey_Question_Answer_Option_Aggregate = {
  __typename?: 'survey_question_answer_option_aggregate';
  aggregate?: Maybe<Survey_Question_Answer_Option_Aggregate_Fields>;
  nodes: Array<Survey_Question_Answer_Option>;
};

export type Survey_Question_Answer_Option_Aggregate_Bool_Exp = {
  count?: Maybe<Survey_Question_Answer_Option_Aggregate_Bool_Exp_Count>;
};

export type Survey_Question_Answer_Option_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Survey_Question_Answer_Option_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Survey_Question_Answer_Option_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "survey_question_answer_option" */
export type Survey_Question_Answer_Option_Aggregate_Fields = {
  __typename?: 'survey_question_answer_option_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Survey_Question_Answer_Option_Max_Fields>;
  min?: Maybe<Survey_Question_Answer_Option_Min_Fields>;
};

/** aggregate fields of "survey_question_answer_option" */
export type Survey_Question_Answer_Option_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_Question_Answer_Option_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "survey_question_answer_option" */
export type Survey_Question_Answer_Option_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Survey_Question_Answer_Option_Max_Order_By>;
  min?: Maybe<Survey_Question_Answer_Option_Min_Order_By>;
};

/** input type for inserting array relation for remote table "survey_question_answer_option" */
export type Survey_Question_Answer_Option_Arr_Rel_Insert_Input = {
  data: Array<Survey_Question_Answer_Option_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Survey_Question_Answer_Option_On_Conflict>;
};

/**
 * Boolean expression to filter rows from the table
 * "survey_question_answer_option". All fields are combined with a logical 'AND'.
 */
export type Survey_Question_Answer_Option_Bool_Exp = {
  _and?: Maybe<Array<Survey_Question_Answer_Option_Bool_Exp>>;
  _not?: Maybe<Survey_Question_Answer_Option_Bool_Exp>;
  _or?: Maybe<Array<Survey_Question_Answer_Option_Bool_Exp>>;
  answer?: Maybe<String_Comparison_Exp>;
  answer_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  option_id?: Maybe<Uuid_Comparison_Exp>;
  survey_question_answer?: Maybe<Survey_Question_Answers_Bool_Exp>;
  survey_question_option?: Maybe<Survey_Question_Options_Bool_Exp>;
};

/** unique or primary key constraints on table "survey_question_answer_option" */
export enum Survey_Question_Answer_Option_Constraint {
  /** unique or primary key constraint on columns "id" */
  SurveyQuestionAnswerOptionPkey = 'survey_question_answer_option_pkey',
}

/** input type for inserting data into table "survey_question_answer_option" */
export type Survey_Question_Answer_Option_Insert_Input = {
  answer?: Maybe<Scalars['String']>;
  answer_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option_id?: Maybe<Scalars['uuid']>;
  survey_question_answer?: Maybe<Survey_Question_Answers_Obj_Rel_Insert_Input>;
  survey_question_option?: Maybe<Survey_Question_Options_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Survey_Question_Answer_Option_Max_Fields = {
  __typename?: 'survey_question_answer_option_max_fields';
  answer?: Maybe<Scalars['String']>;
  answer_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "survey_question_answer_option" */
export type Survey_Question_Answer_Option_Max_Order_By = {
  answer?: Maybe<Order_By>;
  answer_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Survey_Question_Answer_Option_Min_Fields = {
  __typename?: 'survey_question_answer_option_min_fields';
  answer?: Maybe<Scalars['String']>;
  answer_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "survey_question_answer_option" */
export type Survey_Question_Answer_Option_Min_Order_By = {
  answer?: Maybe<Order_By>;
  answer_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "survey_question_answer_option" */
export type Survey_Question_Answer_Option_Mutation_Response = {
  __typename?: 'survey_question_answer_option_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_Question_Answer_Option>;
};

/** on_conflict condition type for table "survey_question_answer_option" */
export type Survey_Question_Answer_Option_On_Conflict = {
  constraint: Survey_Question_Answer_Option_Constraint;
  update_columns?: Array<Survey_Question_Answer_Option_Update_Column>;
  where?: Maybe<Survey_Question_Answer_Option_Bool_Exp>;
};

/** Ordering options when selecting data from "survey_question_answer_option". */
export type Survey_Question_Answer_Option_Order_By = {
  answer?: Maybe<Order_By>;
  answer_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option_id?: Maybe<Order_By>;
  survey_question_answer?: Maybe<Survey_Question_Answers_Order_By>;
  survey_question_option?: Maybe<Survey_Question_Options_Order_By>;
};

/** primary key columns input for table: survey_question_answer_option */
export type Survey_Question_Answer_Option_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "survey_question_answer_option" */
export enum Survey_Question_Answer_Option_Select_Column {
  /** column name */
  Answer = 'answer',
  /** column name */
  AnswerId = 'answer_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  OptionId = 'option_id',
}

/** input type for updating data in table "survey_question_answer_option" */
export type Survey_Question_Answer_Option_Set_Input = {
  answer?: Maybe<Scalars['String']>;
  answer_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "survey_question_answer_option" */
export type Survey_Question_Answer_Option_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_Question_Answer_Option_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_Question_Answer_Option_Stream_Cursor_Value_Input = {
  answer?: Maybe<Scalars['String']>;
  answer_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "survey_question_answer_option" */
export enum Survey_Question_Answer_Option_Update_Column {
  /** column name */
  Answer = 'answer',
  /** column name */
  AnswerId = 'answer_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  OptionId = 'option_id',
}

export type Survey_Question_Answer_Option_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_Question_Answer_Option_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_Question_Answer_Option_Bool_Exp;
};

/** contains information on user\`s answer */
export type Survey_Question_Answers = {
  __typename?: 'survey_question_answers';
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  project_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  survey_question: Survey_Question;
  /** An array relationship */
  survey_question_answer_options: Array<Survey_Question_Answer_Option>;
  /** An aggregate relationship */
  survey_question_answer_options_aggregate: Survey_Question_Answer_Option_Aggregate;
  survey_question_id: Scalars['uuid'];
  user_id: Scalars['uuid'];
};

/** contains information on user\`s answer */
export type Survey_Question_AnswersSurvey_Question_Answer_OptionsArgs = {
  distinct_on?: Maybe<Array<Survey_Question_Answer_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_Question_Answer_Option_Order_By>>;
  where?: Maybe<Survey_Question_Answer_Option_Bool_Exp>;
};

/** contains information on user\`s answer */
export type Survey_Question_AnswersSurvey_Question_Answer_Options_AggregateArgs =
  {
    distinct_on?: Maybe<Array<Survey_Question_Answer_Option_Select_Column>>;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Survey_Question_Answer_Option_Order_By>>;
    where?: Maybe<Survey_Question_Answer_Option_Bool_Exp>;
  };

/** aggregated selection of "survey_question_answers" */
export type Survey_Question_Answers_Aggregate = {
  __typename?: 'survey_question_answers_aggregate';
  aggregate?: Maybe<Survey_Question_Answers_Aggregate_Fields>;
  nodes: Array<Survey_Question_Answers>;
};

/** aggregate fields of "survey_question_answers" */
export type Survey_Question_Answers_Aggregate_Fields = {
  __typename?: 'survey_question_answers_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Survey_Question_Answers_Max_Fields>;
  min?: Maybe<Survey_Question_Answers_Min_Fields>;
};

/** aggregate fields of "survey_question_answers" */
export type Survey_Question_Answers_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_Question_Answers_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "survey_question_answers". All fields are combined with a logical 'AND'. */
export type Survey_Question_Answers_Bool_Exp = {
  _and?: Maybe<Array<Survey_Question_Answers_Bool_Exp>>;
  _not?: Maybe<Survey_Question_Answers_Bool_Exp>;
  _or?: Maybe<Array<Survey_Question_Answers_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  survey_question?: Maybe<Survey_Question_Bool_Exp>;
  survey_question_answer_options?: Maybe<Survey_Question_Answer_Option_Bool_Exp>;
  survey_question_answer_options_aggregate?: Maybe<Survey_Question_Answer_Option_Aggregate_Bool_Exp>;
  survey_question_id?: Maybe<Uuid_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey_question_answers" */
export enum Survey_Question_Answers_Constraint {
  /** unique or primary key constraint on columns "id" */
  SurveyQuestionAnswersPkey = 'survey_question_answers_pkey',
}

/** input type for inserting data into table "survey_question_answers" */
export type Survey_Question_Answers_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  survey_question?: Maybe<Survey_Question_Obj_Rel_Insert_Input>;
  survey_question_answer_options?: Maybe<Survey_Question_Answer_Option_Arr_Rel_Insert_Input>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Survey_Question_Answers_Max_Fields = {
  __typename?: 'survey_question_answers_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Survey_Question_Answers_Min_Fields = {
  __typename?: 'survey_question_answers_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "survey_question_answers" */
export type Survey_Question_Answers_Mutation_Response = {
  __typename?: 'survey_question_answers_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_Question_Answers>;
};

/** input type for inserting object relation for remote table "survey_question_answers" */
export type Survey_Question_Answers_Obj_Rel_Insert_Input = {
  data: Survey_Question_Answers_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Survey_Question_Answers_On_Conflict>;
};

/** on_conflict condition type for table "survey_question_answers" */
export type Survey_Question_Answers_On_Conflict = {
  constraint: Survey_Question_Answers_Constraint;
  update_columns?: Array<Survey_Question_Answers_Update_Column>;
  where?: Maybe<Survey_Question_Answers_Bool_Exp>;
};

/** Ordering options when selecting data from "survey_question_answers". */
export type Survey_Question_Answers_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  survey_question?: Maybe<Survey_Question_Order_By>;
  survey_question_answer_options_aggregate?: Maybe<Survey_Question_Answer_Option_Aggregate_Order_By>;
  survey_question_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: survey_question_answers */
export type Survey_Question_Answers_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "survey_question_answers" */
export enum Survey_Question_Answers_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  SurveyQuestionId = 'survey_question_id',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "survey_question_answers" */
export type Survey_Question_Answers_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "survey_question_answers" */
export type Survey_Question_Answers_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_Question_Answers_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_Question_Answers_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "survey_question_answers" */
export enum Survey_Question_Answers_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  SurveyQuestionId = 'survey_question_id',
  /** column name */
  UserId = 'user_id',
}

export type Survey_Question_Answers_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_Question_Answers_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_Question_Answers_Bool_Exp;
};

/** input type for inserting array relation for remote table "survey_question" */
export type Survey_Question_Arr_Rel_Insert_Input = {
  data: Array<Survey_Question_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Survey_Question_On_Conflict>;
};

/** Boolean expression to filter rows from the table "survey_question". All fields are combined with a logical 'AND'. */
export type Survey_Question_Bool_Exp = {
  _and?: Maybe<Array<Survey_Question_Bool_Exp>>;
  _not?: Maybe<Survey_Question_Bool_Exp>;
  _or?: Maybe<Array<Survey_Question_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  kind?: Maybe<Survey_Question_Kind_Enum_Comparison_Exp>;
  question?: Maybe<String_Comparison_Exp>;
  survey?: Maybe<Survey_Bool_Exp>;
  survey_name?: Maybe<String_Comparison_Exp>;
  survey_question_options?: Maybe<Survey_Question_Options_Bool_Exp>;
  survey_question_options_aggregate?: Maybe<Survey_Question_Options_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey_question" */
export enum Survey_Question_Constraint {
  /** unique or primary key constraint on columns "id" */
  SurveyQuestionPkey = 'survey_question_pkey',
}

/** input type for inserting data into table "survey_question" */
export type Survey_Question_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  kind?: Maybe<Survey_Question_Kind_Enum>;
  question?: Maybe<Scalars['String']>;
  survey?: Maybe<Survey_Obj_Rel_Insert_Input>;
  survey_name?: Maybe<Scalars['String']>;
  survey_question_options?: Maybe<Survey_Question_Options_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** stores the different kind of question options possible for a survey */
export type Survey_Question_Kind = {
  __typename?: 'survey_question_kind';
  kind: Scalars['String'];
  score_range?: Maybe<Scalars['String']>;
};

/** aggregated selection of "survey_question_kind" */
export type Survey_Question_Kind_Aggregate = {
  __typename?: 'survey_question_kind_aggregate';
  aggregate?: Maybe<Survey_Question_Kind_Aggregate_Fields>;
  nodes: Array<Survey_Question_Kind>;
};

/** aggregate fields of "survey_question_kind" */
export type Survey_Question_Kind_Aggregate_Fields = {
  __typename?: 'survey_question_kind_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Survey_Question_Kind_Max_Fields>;
  min?: Maybe<Survey_Question_Kind_Min_Fields>;
};

/** aggregate fields of "survey_question_kind" */
export type Survey_Question_Kind_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_Question_Kind_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "survey_question_kind". All fields are combined with a logical 'AND'. */
export type Survey_Question_Kind_Bool_Exp = {
  _and?: Maybe<Array<Survey_Question_Kind_Bool_Exp>>;
  _not?: Maybe<Survey_Question_Kind_Bool_Exp>;
  _or?: Maybe<Array<Survey_Question_Kind_Bool_Exp>>;
  kind?: Maybe<String_Comparison_Exp>;
  score_range?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey_question_kind" */
export enum Survey_Question_Kind_Constraint {
  /** unique or primary key constraint on columns "kind" */
  SurveyQuestionKindPkey = 'survey_question_kind_pkey',
}

export enum Survey_Question_Kind_Enum {
  Checkbox = 'checkbox',
  Dropdown = 'dropdown',
  Radio = 'radio',
  /** 10 */
  Rating = 'rating',
  Text = 'text',
}

/** Boolean expression to compare columns of type "survey_question_kind_enum". All fields are combined with logical 'AND'. */
export type Survey_Question_Kind_Enum_Comparison_Exp = {
  _eq?: Maybe<Survey_Question_Kind_Enum>;
  _in?: Maybe<Array<Survey_Question_Kind_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Survey_Question_Kind_Enum>;
  _nin?: Maybe<Array<Survey_Question_Kind_Enum>>;
};

/** input type for inserting data into table "survey_question_kind" */
export type Survey_Question_Kind_Insert_Input = {
  kind?: Maybe<Scalars['String']>;
  score_range?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Survey_Question_Kind_Max_Fields = {
  __typename?: 'survey_question_kind_max_fields';
  kind?: Maybe<Scalars['String']>;
  score_range?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Survey_Question_Kind_Min_Fields = {
  __typename?: 'survey_question_kind_min_fields';
  kind?: Maybe<Scalars['String']>;
  score_range?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "survey_question_kind" */
export type Survey_Question_Kind_Mutation_Response = {
  __typename?: 'survey_question_kind_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_Question_Kind>;
};

/** on_conflict condition type for table "survey_question_kind" */
export type Survey_Question_Kind_On_Conflict = {
  constraint: Survey_Question_Kind_Constraint;
  update_columns?: Array<Survey_Question_Kind_Update_Column>;
  where?: Maybe<Survey_Question_Kind_Bool_Exp>;
};

/** Ordering options when selecting data from "survey_question_kind". */
export type Survey_Question_Kind_Order_By = {
  kind?: Maybe<Order_By>;
  score_range?: Maybe<Order_By>;
};

/** primary key columns input for table: survey_question_kind */
export type Survey_Question_Kind_Pk_Columns_Input = {
  kind: Scalars['String'];
};

/** select columns of table "survey_question_kind" */
export enum Survey_Question_Kind_Select_Column {
  /** column name */
  Kind = 'kind',
  /** column name */
  ScoreRange = 'score_range',
}

/** input type for updating data in table "survey_question_kind" */
export type Survey_Question_Kind_Set_Input = {
  kind?: Maybe<Scalars['String']>;
  score_range?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "survey_question_kind" */
export type Survey_Question_Kind_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_Question_Kind_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_Question_Kind_Stream_Cursor_Value_Input = {
  kind?: Maybe<Scalars['String']>;
  score_range?: Maybe<Scalars['String']>;
};

/** update columns of table "survey_question_kind" */
export enum Survey_Question_Kind_Update_Column {
  /** column name */
  Kind = 'kind',
  /** column name */
  ScoreRange = 'score_range',
}

export type Survey_Question_Kind_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_Question_Kind_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_Question_Kind_Bool_Exp;
};

/** aggregate max on columns */
export type Survey_Question_Max_Fields = {
  __typename?: 'survey_question_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  question?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "survey_question" */
export type Survey_Question_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  question?: Maybe<Order_By>;
  survey_name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Survey_Question_Min_Fields = {
  __typename?: 'survey_question_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  question?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "survey_question" */
export type Survey_Question_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  question?: Maybe<Order_By>;
  survey_name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "survey_question" */
export type Survey_Question_Mutation_Response = {
  __typename?: 'survey_question_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_Question>;
};

/** input type for inserting object relation for remote table "survey_question" */
export type Survey_Question_Obj_Rel_Insert_Input = {
  data: Survey_Question_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Survey_Question_On_Conflict>;
};

/** on_conflict condition type for table "survey_question" */
export type Survey_Question_On_Conflict = {
  constraint: Survey_Question_Constraint;
  update_columns?: Array<Survey_Question_Update_Column>;
  where?: Maybe<Survey_Question_Bool_Exp>;
};

/** holds all the options possible for a question in a survey */
export type Survey_Question_Options = {
  __typename?: 'survey_question_options';
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  option: Scalars['String'];
  /** An object relationship */
  survey_question: Survey_Question;
  survey_question_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "survey_question_options" */
export type Survey_Question_Options_Aggregate = {
  __typename?: 'survey_question_options_aggregate';
  aggregate?: Maybe<Survey_Question_Options_Aggregate_Fields>;
  nodes: Array<Survey_Question_Options>;
};

export type Survey_Question_Options_Aggregate_Bool_Exp = {
  count?: Maybe<Survey_Question_Options_Aggregate_Bool_Exp_Count>;
};

export type Survey_Question_Options_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Survey_Question_Options_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Survey_Question_Options_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "survey_question_options" */
export type Survey_Question_Options_Aggregate_Fields = {
  __typename?: 'survey_question_options_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Survey_Question_Options_Max_Fields>;
  min?: Maybe<Survey_Question_Options_Min_Fields>;
};

/** aggregate fields of "survey_question_options" */
export type Survey_Question_Options_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_Question_Options_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "survey_question_options" */
export type Survey_Question_Options_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Survey_Question_Options_Max_Order_By>;
  min?: Maybe<Survey_Question_Options_Min_Order_By>;
};

/** input type for inserting array relation for remote table "survey_question_options" */
export type Survey_Question_Options_Arr_Rel_Insert_Input = {
  data: Array<Survey_Question_Options_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Survey_Question_Options_On_Conflict>;
};

/** Boolean expression to filter rows from the table "survey_question_options". All fields are combined with a logical 'AND'. */
export type Survey_Question_Options_Bool_Exp = {
  _and?: Maybe<Array<Survey_Question_Options_Bool_Exp>>;
  _not?: Maybe<Survey_Question_Options_Bool_Exp>;
  _or?: Maybe<Array<Survey_Question_Options_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  option?: Maybe<String_Comparison_Exp>;
  survey_question?: Maybe<Survey_Question_Bool_Exp>;
  survey_question_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey_question_options" */
export enum Survey_Question_Options_Constraint {
  /** unique or primary key constraint on columns "id" */
  SurveyQuestionOptionsPkey = 'survey_question_options_pkey',
}

/** input type for inserting data into table "survey_question_options" */
export type Survey_Question_Options_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option?: Maybe<Scalars['String']>;
  survey_question?: Maybe<Survey_Question_Obj_Rel_Insert_Input>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Survey_Question_Options_Max_Fields = {
  __typename?: 'survey_question_options_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option?: Maybe<Scalars['String']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "survey_question_options" */
export type Survey_Question_Options_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option?: Maybe<Order_By>;
  survey_question_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Survey_Question_Options_Min_Fields = {
  __typename?: 'survey_question_options_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option?: Maybe<Scalars['String']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "survey_question_options" */
export type Survey_Question_Options_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option?: Maybe<Order_By>;
  survey_question_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "survey_question_options" */
export type Survey_Question_Options_Mutation_Response = {
  __typename?: 'survey_question_options_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_Question_Options>;
};

/** input type for inserting object relation for remote table "survey_question_options" */
export type Survey_Question_Options_Obj_Rel_Insert_Input = {
  data: Survey_Question_Options_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Survey_Question_Options_On_Conflict>;
};

/** on_conflict condition type for table "survey_question_options" */
export type Survey_Question_Options_On_Conflict = {
  constraint: Survey_Question_Options_Constraint;
  update_columns?: Array<Survey_Question_Options_Update_Column>;
  where?: Maybe<Survey_Question_Options_Bool_Exp>;
};

/** Ordering options when selecting data from "survey_question_options". */
export type Survey_Question_Options_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option?: Maybe<Order_By>;
  survey_question?: Maybe<Survey_Question_Order_By>;
  survey_question_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: survey_question_options */
export type Survey_Question_Options_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "survey_question_options" */
export enum Survey_Question_Options_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Option = 'option',
  /** column name */
  SurveyQuestionId = 'survey_question_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "survey_question_options" */
export type Survey_Question_Options_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option?: Maybe<Scalars['String']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "survey_question_options" */
export type Survey_Question_Options_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_Question_Options_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_Question_Options_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option?: Maybe<Scalars['String']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "survey_question_options" */
export enum Survey_Question_Options_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Option = 'option',
  /** column name */
  SurveyQuestionId = 'survey_question_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Survey_Question_Options_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_Question_Options_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_Question_Options_Bool_Exp;
};

/** Ordering options when selecting data from "survey_question". */
export type Survey_Question_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  kind?: Maybe<Order_By>;
  question?: Maybe<Order_By>;
  survey?: Maybe<Survey_Order_By>;
  survey_name?: Maybe<Order_By>;
  survey_question_options_aggregate?: Maybe<Survey_Question_Options_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: survey_question */
export type Survey_Question_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "survey_question" */
export enum Survey_Question_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Kind = 'kind',
  /** column name */
  Question = 'question',
  /** column name */
  SurveyName = 'survey_name',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "survey_question" */
export type Survey_Question_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  kind?: Maybe<Survey_Question_Kind_Enum>;
  question?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "survey_question" */
export type Survey_Question_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_Question_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_Question_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  kind?: Maybe<Survey_Question_Kind_Enum>;
  question?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "survey_question" */
export enum Survey_Question_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Kind = 'kind',
  /** column name */
  Question = 'question',
  /** column name */
  SurveyName = 'survey_name',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Survey_Question_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_Question_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_Question_Bool_Exp;
};

/** select columns of table "survey" */
export enum Survey_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  RequestedBy = 'requested_by',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  SurveyDescription = 'survey_description',
  /** column name */
  SurveyHeader = 'survey_header',
  /** column name */
  SurveyName = 'survey_name',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
}

/** input type for updating data in table "survey" */
export type Survey_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  requested_by?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_description?: Maybe<Scalars['String']>;
  survey_header?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  updated_by?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "survey" */
export type Survey_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  requested_by?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_description?: Maybe<Scalars['String']>;
  survey_header?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  updated_by?: Maybe<Scalars['String']>;
};

/** update columns of table "survey" */
export enum Survey_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  RequestedBy = 'requested_by',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  SurveyDescription = 'survey_description',
  /** column name */
  SurveyHeader = 'survey_header',
  /** column name */
  SurveyName = 'survey_name',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UpdatedBy = 'updated_by',
}

export type Survey_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_Bool_Exp;
};

/** information on a survey being conducted  */
export type Survey_V2 = {
  __typename?: 'survey_v2';
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at: Scalars['timestamptz'];
  ended_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  requested_by: Scalars['String'];
  started_at: Scalars['timestamptz'];
  survey_description?: Maybe<Scalars['String']>;
  survey_name: Scalars['String'];
  /** An array relationship */
  survey_questions: Array<Survey_V2_Question>;
  /** An aggregate relationship */
  survey_questions_aggregate: Survey_V2_Question_Aggregate;
  /** An array relationship */
  survey_responses: Array<Survey_V2_Response>;
  /** An aggregate relationship */
  survey_responses_aggregate: Survey_V2_Response_Aggregate;
  survey_title?: Maybe<Scalars['String']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at: Scalars['timestamptz'];
};

/** information on a survey being conducted  */
export type Survey_V2Additional_InfoArgs = {
  path?: Maybe<Scalars['String']>;
};

/** information on a survey being conducted  */
export type Survey_V2Survey_QuestionsArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Order_By>>;
  where?: Maybe<Survey_V2_Question_Bool_Exp>;
};

/** information on a survey being conducted  */
export type Survey_V2Survey_Questions_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Order_By>>;
  where?: Maybe<Survey_V2_Question_Bool_Exp>;
};

/** information on a survey being conducted  */
export type Survey_V2Survey_ResponsesArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Order_By>>;
  where?: Maybe<Survey_V2_Response_Bool_Exp>;
};

/** information on a survey being conducted  */
export type Survey_V2Survey_Responses_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Order_By>>;
  where?: Maybe<Survey_V2_Response_Bool_Exp>;
};

/** information on a survey being conducted  */
export type Survey_V2Template_ConfigArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "survey_v2" */
export type Survey_V2_Aggregate = {
  __typename?: 'survey_v2_aggregate';
  aggregate?: Maybe<Survey_V2_Aggregate_Fields>;
  nodes: Array<Survey_V2>;
};

/** aggregate fields of "survey_v2" */
export type Survey_V2_Aggregate_Fields = {
  __typename?: 'survey_v2_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Survey_V2_Max_Fields>;
  min?: Maybe<Survey_V2_Min_Fields>;
};

/** aggregate fields of "survey_v2" */
export type Survey_V2_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_V2_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Survey_V2_Append_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "survey_v2". All fields are combined with a logical 'AND'. */
export type Survey_V2_Bool_Exp = {
  _and?: Maybe<Array<Survey_V2_Bool_Exp>>;
  _not?: Maybe<Survey_V2_Bool_Exp>;
  _or?: Maybe<Array<Survey_V2_Bool_Exp>>;
  additional_info?: Maybe<Jsonb_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  ended_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  requested_by?: Maybe<String_Comparison_Exp>;
  started_at?: Maybe<Timestamptz_Comparison_Exp>;
  survey_description?: Maybe<String_Comparison_Exp>;
  survey_name?: Maybe<String_Comparison_Exp>;
  survey_questions?: Maybe<Survey_V2_Question_Bool_Exp>;
  survey_questions_aggregate?: Maybe<Survey_V2_Question_Aggregate_Bool_Exp>;
  survey_responses?: Maybe<Survey_V2_Response_Bool_Exp>;
  survey_responses_aggregate?: Maybe<Survey_V2_Response_Aggregate_Bool_Exp>;
  survey_title?: Maybe<String_Comparison_Exp>;
  template_config?: Maybe<Jsonb_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey_v2" */
export enum Survey_V2_Constraint {
  /** unique or primary key constraint on columns "id" */
  SurveyV2Pkey = 'survey_v2_pkey',
  /** unique or primary key constraint on columns "survey_name" */
  SurveyV2SurveyNameKey = 'survey_v2_survey_name_key',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Survey_V2_Delete_At_Path_Input = {
  additional_info?: Maybe<Array<Scalars['String']>>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Survey_V2_Delete_Elem_Input = {
  additional_info?: Maybe<Scalars['Int']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Survey_V2_Delete_Key_Input = {
  additional_info?: Maybe<Scalars['String']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "survey_v2" */
export type Survey_V2_Insert_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  requested_by?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_description?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  survey_questions?: Maybe<Survey_V2_Question_Arr_Rel_Insert_Input>;
  survey_responses?: Maybe<Survey_V2_Response_Arr_Rel_Insert_Input>;
  survey_title?: Maybe<Scalars['String']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Survey_V2_Max_Fields = {
  __typename?: 'survey_v2_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  requested_by?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_description?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  survey_title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Survey_V2_Min_Fields = {
  __typename?: 'survey_v2_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  requested_by?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_description?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  survey_title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "survey_v2" */
export type Survey_V2_Mutation_Response = {
  __typename?: 'survey_v2_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_V2>;
};

/** input type for inserting object relation for remote table "survey_v2" */
export type Survey_V2_Obj_Rel_Insert_Input = {
  data: Survey_V2_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Survey_V2_On_Conflict>;
};

/** on_conflict condition type for table "survey_v2" */
export type Survey_V2_On_Conflict = {
  constraint: Survey_V2_Constraint;
  update_columns?: Array<Survey_V2_Update_Column>;
  where?: Maybe<Survey_V2_Bool_Exp>;
};

/** Ordering options when selecting data from "survey_v2". */
export type Survey_V2_Order_By = {
  additional_info?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  ended_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  requested_by?: Maybe<Order_By>;
  started_at?: Maybe<Order_By>;
  survey_description?: Maybe<Order_By>;
  survey_name?: Maybe<Order_By>;
  survey_questions_aggregate?: Maybe<Survey_V2_Question_Aggregate_Order_By>;
  survey_responses_aggregate?: Maybe<Survey_V2_Response_Aggregate_Order_By>;
  survey_title?: Maybe<Order_By>;
  template_config?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: survey_v2 */
export type Survey_V2_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Survey_V2_Prepend_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
};

/** contains all questions for a survey  */
export type Survey_V2_Question = {
  __typename?: 'survey_v2_question';
  created_at: Scalars['timestamptz'];
  ended_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  is_mandatory: Scalars['Boolean'];
  kind: Survey_V2_Question_Kind_Enum;
  /** overrides default config provided in survey_question_kind */
  kind_config_override?: Maybe<Scalars['String']>;
  /** this decides in which order to show the questions to user */
  position: Scalars['Int'];
  question: Scalars['String'];
  started_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  survey?: Maybe<Survey_V2>;
  survey_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  survey_question_kind: Survey_V2_Question_Kind;
  /** An array relationship */
  survey_question_options: Array<Survey_V2_Question_Option>;
  /** An aggregate relationship */
  survey_question_options_aggregate: Survey_V2_Question_Option_Aggregate;
  /** An array relationship */
  survey_response_answers: Array<Survey_V2_Response_Answer>;
  /** An aggregate relationship */
  survey_response_answers_aggregate: Survey_V2_Response_Answer_Aggregate;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at: Scalars['timestamptz'];
};

/** contains all questions for a survey  */
export type Survey_V2_QuestionSurvey_Question_OptionsArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Option_Order_By>>;
  where?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
};

/** contains all questions for a survey  */
export type Survey_V2_QuestionSurvey_Question_Options_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Question_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Question_Option_Order_By>>;
  where?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
};

/** contains all questions for a survey  */
export type Survey_V2_QuestionSurvey_Response_AnswersArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
};

/** contains all questions for a survey  */
export type Survey_V2_QuestionSurvey_Response_Answers_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
};

/** contains all questions for a survey  */
export type Survey_V2_QuestionTemplate_ConfigArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "survey_v2_question" */
export type Survey_V2_Question_Aggregate = {
  __typename?: 'survey_v2_question_aggregate';
  aggregate?: Maybe<Survey_V2_Question_Aggregate_Fields>;
  nodes: Array<Survey_V2_Question>;
};

export type Survey_V2_Question_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Survey_V2_Question_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Survey_V2_Question_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Survey_V2_Question_Aggregate_Bool_Exp_Count>;
};

export type Survey_V2_Question_Aggregate_Bool_Exp_Bool_And = {
  arguments: Survey_V2_Question_Select_Column_Survey_V2_Question_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Survey_V2_Question_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Survey_V2_Question_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Survey_V2_Question_Select_Column_Survey_V2_Question_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Survey_V2_Question_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Survey_V2_Question_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Survey_V2_Question_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Survey_V2_Question_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "survey_v2_question" */
export type Survey_V2_Question_Aggregate_Fields = {
  __typename?: 'survey_v2_question_aggregate_fields';
  avg?: Maybe<Survey_V2_Question_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Survey_V2_Question_Max_Fields>;
  min?: Maybe<Survey_V2_Question_Min_Fields>;
  stddev?: Maybe<Survey_V2_Question_Stddev_Fields>;
  stddev_pop?: Maybe<Survey_V2_Question_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Survey_V2_Question_Stddev_Samp_Fields>;
  sum?: Maybe<Survey_V2_Question_Sum_Fields>;
  var_pop?: Maybe<Survey_V2_Question_Var_Pop_Fields>;
  var_samp?: Maybe<Survey_V2_Question_Var_Samp_Fields>;
  variance?: Maybe<Survey_V2_Question_Variance_Fields>;
};

/** aggregate fields of "survey_v2_question" */
export type Survey_V2_Question_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_V2_Question_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "survey_v2_question" */
export type Survey_V2_Question_Aggregate_Order_By = {
  avg?: Maybe<Survey_V2_Question_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Survey_V2_Question_Max_Order_By>;
  min?: Maybe<Survey_V2_Question_Min_Order_By>;
  stddev?: Maybe<Survey_V2_Question_Stddev_Order_By>;
  stddev_pop?: Maybe<Survey_V2_Question_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Survey_V2_Question_Stddev_Samp_Order_By>;
  sum?: Maybe<Survey_V2_Question_Sum_Order_By>;
  var_pop?: Maybe<Survey_V2_Question_Var_Pop_Order_By>;
  var_samp?: Maybe<Survey_V2_Question_Var_Samp_Order_By>;
  variance?: Maybe<Survey_V2_Question_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Survey_V2_Question_Append_Input = {
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "survey_v2_question" */
export type Survey_V2_Question_Arr_Rel_Insert_Input = {
  data: Array<Survey_V2_Question_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Survey_V2_Question_On_Conflict>;
};

/** aggregate avg on columns */
export type Survey_V2_Question_Avg_Fields = {
  __typename?: 'survey_v2_question_avg_fields';
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "survey_v2_question" */
export type Survey_V2_Question_Avg_Order_By = {
  /** this decides in which order to show the questions to user */
  position?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "survey_v2_question". All fields are combined with a logical 'AND'. */
export type Survey_V2_Question_Bool_Exp = {
  _and?: Maybe<Array<Survey_V2_Question_Bool_Exp>>;
  _not?: Maybe<Survey_V2_Question_Bool_Exp>;
  _or?: Maybe<Array<Survey_V2_Question_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  ended_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_mandatory?: Maybe<Boolean_Comparison_Exp>;
  kind?: Maybe<Survey_V2_Question_Kind_Enum_Comparison_Exp>;
  kind_config_override?: Maybe<String_Comparison_Exp>;
  position?: Maybe<Int_Comparison_Exp>;
  question?: Maybe<String_Comparison_Exp>;
  started_at?: Maybe<Timestamptz_Comparison_Exp>;
  survey?: Maybe<Survey_V2_Bool_Exp>;
  survey_id?: Maybe<Uuid_Comparison_Exp>;
  survey_question_kind?: Maybe<Survey_V2_Question_Kind_Bool_Exp>;
  survey_question_options?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
  survey_question_options_aggregate?: Maybe<Survey_V2_Question_Option_Aggregate_Bool_Exp>;
  survey_response_answers?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
  survey_response_answers_aggregate?: Maybe<Survey_V2_Response_Answer_Aggregate_Bool_Exp>;
  template_config?: Maybe<Jsonb_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey_v2_question" */
export enum Survey_V2_Question_Constraint {
  /** unique or primary key constraint on columns "id" */
  SurveyV2QuestionPkey = 'survey_v2_question_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Survey_V2_Question_Delete_At_Path_Input = {
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Survey_V2_Question_Delete_Elem_Input = {
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Survey_V2_Question_Delete_Key_Input = {
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "survey_v2_question" */
export type Survey_V2_Question_Inc_Input = {
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "survey_v2_question" */
export type Survey_V2_Question_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_mandatory?: Maybe<Scalars['Boolean']>;
  kind?: Maybe<Survey_V2_Question_Kind_Enum>;
  /** overrides default config provided in survey_question_kind */
  kind_config_override?: Maybe<Scalars['String']>;
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey?: Maybe<Survey_V2_Obj_Rel_Insert_Input>;
  survey_id?: Maybe<Scalars['uuid']>;
  survey_question_kind?: Maybe<Survey_V2_Question_Kind_Obj_Rel_Insert_Input>;
  survey_question_options?: Maybe<Survey_V2_Question_Option_Arr_Rel_Insert_Input>;
  survey_response_answers?: Maybe<Survey_V2_Response_Answer_Arr_Rel_Insert_Input>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** stores the different kind of question options possible for a survey */
export type Survey_V2_Question_Kind = {
  __typename?: 'survey_v2_question_kind';
  default_config?: Maybe<Scalars['String']>;
  kind: Scalars['String'];
};

/** aggregated selection of "survey_v2_question_kind" */
export type Survey_V2_Question_Kind_Aggregate = {
  __typename?: 'survey_v2_question_kind_aggregate';
  aggregate?: Maybe<Survey_V2_Question_Kind_Aggregate_Fields>;
  nodes: Array<Survey_V2_Question_Kind>;
};

/** aggregate fields of "survey_v2_question_kind" */
export type Survey_V2_Question_Kind_Aggregate_Fields = {
  __typename?: 'survey_v2_question_kind_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Survey_V2_Question_Kind_Max_Fields>;
  min?: Maybe<Survey_V2_Question_Kind_Min_Fields>;
};

/** aggregate fields of "survey_v2_question_kind" */
export type Survey_V2_Question_Kind_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_V2_Question_Kind_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "survey_v2_question_kind". All fields are combined with a logical 'AND'. */
export type Survey_V2_Question_Kind_Bool_Exp = {
  _and?: Maybe<Array<Survey_V2_Question_Kind_Bool_Exp>>;
  _not?: Maybe<Survey_V2_Question_Kind_Bool_Exp>;
  _or?: Maybe<Array<Survey_V2_Question_Kind_Bool_Exp>>;
  default_config?: Maybe<String_Comparison_Exp>;
  kind?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey_v2_question_kind" */
export enum Survey_V2_Question_Kind_Constraint {
  /** unique or primary key constraint on columns "kind" */
  SurveyV2QuestionKindPkey = 'survey_v2_question_kind_pkey',
}

export enum Survey_V2_Question_Kind_Enum {
  Checkbox = 'checkbox',
  Dropdown = 'dropdown',
  Radio = 'radio',
  /** 10 */
  Rating = 'rating',
  Text = 'text',
}

/** Boolean expression to compare columns of type "survey_v2_question_kind_enum". All fields are combined with logical 'AND'. */
export type Survey_V2_Question_Kind_Enum_Comparison_Exp = {
  _eq?: Maybe<Survey_V2_Question_Kind_Enum>;
  _in?: Maybe<Array<Survey_V2_Question_Kind_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Survey_V2_Question_Kind_Enum>;
  _nin?: Maybe<Array<Survey_V2_Question_Kind_Enum>>;
};

/** input type for inserting data into table "survey_v2_question_kind" */
export type Survey_V2_Question_Kind_Insert_Input = {
  default_config?: Maybe<Scalars['String']>;
  kind?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Survey_V2_Question_Kind_Max_Fields = {
  __typename?: 'survey_v2_question_kind_max_fields';
  default_config?: Maybe<Scalars['String']>;
  kind?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Survey_V2_Question_Kind_Min_Fields = {
  __typename?: 'survey_v2_question_kind_min_fields';
  default_config?: Maybe<Scalars['String']>;
  kind?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "survey_v2_question_kind" */
export type Survey_V2_Question_Kind_Mutation_Response = {
  __typename?: 'survey_v2_question_kind_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_V2_Question_Kind>;
};

/** input type for inserting object relation for remote table "survey_v2_question_kind" */
export type Survey_V2_Question_Kind_Obj_Rel_Insert_Input = {
  data: Survey_V2_Question_Kind_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Survey_V2_Question_Kind_On_Conflict>;
};

/** on_conflict condition type for table "survey_v2_question_kind" */
export type Survey_V2_Question_Kind_On_Conflict = {
  constraint: Survey_V2_Question_Kind_Constraint;
  update_columns?: Array<Survey_V2_Question_Kind_Update_Column>;
  where?: Maybe<Survey_V2_Question_Kind_Bool_Exp>;
};

/** Ordering options when selecting data from "survey_v2_question_kind". */
export type Survey_V2_Question_Kind_Order_By = {
  default_config?: Maybe<Order_By>;
  kind?: Maybe<Order_By>;
};

/** primary key columns input for table: survey_v2_question_kind */
export type Survey_V2_Question_Kind_Pk_Columns_Input = {
  kind: Scalars['String'];
};

/** select columns of table "survey_v2_question_kind" */
export enum Survey_V2_Question_Kind_Select_Column {
  /** column name */
  DefaultConfig = 'default_config',
  /** column name */
  Kind = 'kind',
}

/** input type for updating data in table "survey_v2_question_kind" */
export type Survey_V2_Question_Kind_Set_Input = {
  default_config?: Maybe<Scalars['String']>;
  kind?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "survey_v2_question_kind" */
export type Survey_V2_Question_Kind_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_V2_Question_Kind_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_V2_Question_Kind_Stream_Cursor_Value_Input = {
  default_config?: Maybe<Scalars['String']>;
  kind?: Maybe<Scalars['String']>;
};

/** update columns of table "survey_v2_question_kind" */
export enum Survey_V2_Question_Kind_Update_Column {
  /** column name */
  DefaultConfig = 'default_config',
  /** column name */
  Kind = 'kind',
}

export type Survey_V2_Question_Kind_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_V2_Question_Kind_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_V2_Question_Kind_Bool_Exp;
};

/** aggregate max on columns */
export type Survey_V2_Question_Max_Fields = {
  __typename?: 'survey_v2_question_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  /** overrides default config provided in survey_question_kind */
  kind_config_override?: Maybe<Scalars['String']>;
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "survey_v2_question" */
export type Survey_V2_Question_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  ended_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  /** overrides default config provided in survey_question_kind */
  kind_config_override?: Maybe<Order_By>;
  /** this decides in which order to show the questions to user */
  position?: Maybe<Order_By>;
  question?: Maybe<Order_By>;
  started_at?: Maybe<Order_By>;
  survey_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Survey_V2_Question_Min_Fields = {
  __typename?: 'survey_v2_question_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  /** overrides default config provided in survey_question_kind */
  kind_config_override?: Maybe<Scalars['String']>;
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "survey_v2_question" */
export type Survey_V2_Question_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  ended_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  /** overrides default config provided in survey_question_kind */
  kind_config_override?: Maybe<Order_By>;
  /** this decides in which order to show the questions to user */
  position?: Maybe<Order_By>;
  question?: Maybe<Order_By>;
  started_at?: Maybe<Order_By>;
  survey_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "survey_v2_question" */
export type Survey_V2_Question_Mutation_Response = {
  __typename?: 'survey_v2_question_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_V2_Question>;
};

/** input type for inserting object relation for remote table "survey_v2_question" */
export type Survey_V2_Question_Obj_Rel_Insert_Input = {
  data: Survey_V2_Question_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Survey_V2_Question_On_Conflict>;
};

/** on_conflict condition type for table "survey_v2_question" */
export type Survey_V2_Question_On_Conflict = {
  constraint: Survey_V2_Question_Constraint;
  update_columns?: Array<Survey_V2_Question_Update_Column>;
  where?: Maybe<Survey_V2_Question_Bool_Exp>;
};

/** holds all the options possible for a question in a survey */
export type Survey_V2_Question_Option = {
  __typename?: 'survey_v2_question_option';
  /** An object relationship */
  additional_info_config?: Maybe<Survey_V2_Question_Option_Additional_Info_Config>;
  additional_info_config_id?: Maybe<Scalars['uuid']>;
  created_at: Scalars['timestamptz'];
  ended_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  option: Scalars['String'];
  /** this decides in which order to show the options to user */
  position: Scalars['Int'];
  started_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  survey_question: Survey_V2_Question;
  survey_question_id: Scalars['uuid'];
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at: Scalars['timestamptz'];
};

/** holds all the options possible for a question in a survey */
export type Survey_V2_Question_OptionTemplate_ConfigArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "survey_v2_question_option_additional_info_config" */
export type Survey_V2_Question_Option_Additional_Info_Config = {
  __typename?: 'survey_v2_question_option_additional_info_config';
  id: Scalars['uuid'];
  info_description?: Maybe<Scalars['String']>;
  is_mandatory: Scalars['Boolean'];
};

/** aggregated selection of "survey_v2_question_option_additional_info_config" */
export type Survey_V2_Question_Option_Additional_Info_Config_Aggregate = {
  __typename?: 'survey_v2_question_option_additional_info_config_aggregate';
  aggregate?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Aggregate_Fields>;
  nodes: Array<Survey_V2_Question_Option_Additional_Info_Config>;
};

/** aggregate fields of "survey_v2_question_option_additional_info_config" */
export type Survey_V2_Question_Option_Additional_Info_Config_Aggregate_Fields =
  {
    __typename?: 'survey_v2_question_option_additional_info_config_aggregate_fields';
    count: Scalars['Int'];
    max?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Max_Fields>;
    min?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Min_Fields>;
  };

/** aggregate fields of "survey_v2_question_option_additional_info_config" */
export type Survey_V2_Question_Option_Additional_Info_Config_Aggregate_FieldsCountArgs =
  {
    columns?: Maybe<
      Array<Survey_V2_Question_Option_Additional_Info_Config_Select_Column>
    >;
    distinct?: Maybe<Scalars['Boolean']>;
  };

/**
 * Boolean expression to filter rows from the table
 * "survey_v2_question_option_additional_info_config". All fields are combined with
 * a logical 'AND'.
 */
export type Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp = {
  _and?: Maybe<
    Array<Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp>
  >;
  _not?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp>;
  _or?: Maybe<Array<Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp>>;
  id?: Maybe<Uuid_Comparison_Exp>;
  info_description?: Maybe<String_Comparison_Exp>;
  is_mandatory?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey_v2_question_option_additional_info_config" */
export enum Survey_V2_Question_Option_Additional_Info_Config_Constraint {
  /** unique or primary key constraint on columns "id" */
  SurveyV2QuestionOptionAdditionalInfoConfigPkey = 'survey_v2_question_option_additional_info_config_pkey',
}

/** input type for inserting data into table "survey_v2_question_option_additional_info_config" */
export type Survey_V2_Question_Option_Additional_Info_Config_Insert_Input = {
  id?: Maybe<Scalars['uuid']>;
  info_description?: Maybe<Scalars['String']>;
  is_mandatory?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Survey_V2_Question_Option_Additional_Info_Config_Max_Fields = {
  __typename?: 'survey_v2_question_option_additional_info_config_max_fields';
  id?: Maybe<Scalars['uuid']>;
  info_description?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Survey_V2_Question_Option_Additional_Info_Config_Min_Fields = {
  __typename?: 'survey_v2_question_option_additional_info_config_min_fields';
  id?: Maybe<Scalars['uuid']>;
  info_description?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "survey_v2_question_option_additional_info_config" */
export type Survey_V2_Question_Option_Additional_Info_Config_Mutation_Response =
  {
    __typename?: 'survey_v2_question_option_additional_info_config_mutation_response';
    /** number of rows affected by the mutation */
    affected_rows: Scalars['Int'];
    /** data from the rows affected by the mutation */
    returning: Array<Survey_V2_Question_Option_Additional_Info_Config>;
  };

/** input type for inserting object relation for remote table "survey_v2_question_option_additional_info_config" */
export type Survey_V2_Question_Option_Additional_Info_Config_Obj_Rel_Insert_Input =
  {
    data: Survey_V2_Question_Option_Additional_Info_Config_Insert_Input;
    /** upsert condition */
    on_conflict?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_On_Conflict>;
  };

/** on_conflict condition type for table "survey_v2_question_option_additional_info_config" */
export type Survey_V2_Question_Option_Additional_Info_Config_On_Conflict = {
  constraint: Survey_V2_Question_Option_Additional_Info_Config_Constraint;
  update_columns?: Array<Survey_V2_Question_Option_Additional_Info_Config_Update_Column>;
  where?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp>;
};

/** Ordering options when selecting data from "survey_v2_question_option_additional_info_config". */
export type Survey_V2_Question_Option_Additional_Info_Config_Order_By = {
  id?: Maybe<Order_By>;
  info_description?: Maybe<Order_By>;
  is_mandatory?: Maybe<Order_By>;
};

/** primary key columns input for table: survey_v2_question_option_additional_info_config */
export type Survey_V2_Question_Option_Additional_Info_Config_Pk_Columns_Input =
  {
    id: Scalars['uuid'];
  };

/** select columns of table "survey_v2_question_option_additional_info_config" */
export enum Survey_V2_Question_Option_Additional_Info_Config_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  InfoDescription = 'info_description',
  /** column name */
  IsMandatory = 'is_mandatory',
}

/** input type for updating data in table "survey_v2_question_option_additional_info_config" */
export type Survey_V2_Question_Option_Additional_Info_Config_Set_Input = {
  id?: Maybe<Scalars['uuid']>;
  info_description?: Maybe<Scalars['String']>;
  is_mandatory?: Maybe<Scalars['Boolean']>;
};

/** Streaming cursor of the table "survey_v2_question_option_additional_info_config" */
export type Survey_V2_Question_Option_Additional_Info_Config_Stream_Cursor_Input =
  {
    /** Stream column input with initial value */
    initial_value: Survey_V2_Question_Option_Additional_Info_Config_Stream_Cursor_Value_Input;
    /** cursor ordering */
    ordering?: Maybe<Cursor_Ordering>;
  };

/** Initial value of the column from where the streaming should start */
export type Survey_V2_Question_Option_Additional_Info_Config_Stream_Cursor_Value_Input =
  {
    id?: Maybe<Scalars['uuid']>;
    info_description?: Maybe<Scalars['String']>;
    is_mandatory?: Maybe<Scalars['Boolean']>;
  };

/** update columns of table "survey_v2_question_option_additional_info_config" */
export enum Survey_V2_Question_Option_Additional_Info_Config_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  InfoDescription = 'info_description',
  /** column name */
  IsMandatory = 'is_mandatory',
}

export type Survey_V2_Question_Option_Additional_Info_Config_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp;
};

/** aggregated selection of "survey_v2_question_option" */
export type Survey_V2_Question_Option_Aggregate = {
  __typename?: 'survey_v2_question_option_aggregate';
  aggregate?: Maybe<Survey_V2_Question_Option_Aggregate_Fields>;
  nodes: Array<Survey_V2_Question_Option>;
};

export type Survey_V2_Question_Option_Aggregate_Bool_Exp = {
  count?: Maybe<Survey_V2_Question_Option_Aggregate_Bool_Exp_Count>;
};

export type Survey_V2_Question_Option_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Survey_V2_Question_Option_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "survey_v2_question_option" */
export type Survey_V2_Question_Option_Aggregate_Fields = {
  __typename?: 'survey_v2_question_option_aggregate_fields';
  avg?: Maybe<Survey_V2_Question_Option_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Survey_V2_Question_Option_Max_Fields>;
  min?: Maybe<Survey_V2_Question_Option_Min_Fields>;
  stddev?: Maybe<Survey_V2_Question_Option_Stddev_Fields>;
  stddev_pop?: Maybe<Survey_V2_Question_Option_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Survey_V2_Question_Option_Stddev_Samp_Fields>;
  sum?: Maybe<Survey_V2_Question_Option_Sum_Fields>;
  var_pop?: Maybe<Survey_V2_Question_Option_Var_Pop_Fields>;
  var_samp?: Maybe<Survey_V2_Question_Option_Var_Samp_Fields>;
  variance?: Maybe<Survey_V2_Question_Option_Variance_Fields>;
};

/** aggregate fields of "survey_v2_question_option" */
export type Survey_V2_Question_Option_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_V2_Question_Option_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Aggregate_Order_By = {
  avg?: Maybe<Survey_V2_Question_Option_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Survey_V2_Question_Option_Max_Order_By>;
  min?: Maybe<Survey_V2_Question_Option_Min_Order_By>;
  stddev?: Maybe<Survey_V2_Question_Option_Stddev_Order_By>;
  stddev_pop?: Maybe<Survey_V2_Question_Option_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Survey_V2_Question_Option_Stddev_Samp_Order_By>;
  sum?: Maybe<Survey_V2_Question_Option_Sum_Order_By>;
  var_pop?: Maybe<Survey_V2_Question_Option_Var_Pop_Order_By>;
  var_samp?: Maybe<Survey_V2_Question_Option_Var_Samp_Order_By>;
  variance?: Maybe<Survey_V2_Question_Option_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Survey_V2_Question_Option_Append_Input = {
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Arr_Rel_Insert_Input = {
  data: Array<Survey_V2_Question_Option_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Survey_V2_Question_Option_On_Conflict>;
};

/** aggregate avg on columns */
export type Survey_V2_Question_Option_Avg_Fields = {
  __typename?: 'survey_v2_question_option_avg_fields';
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Avg_Order_By = {
  /** this decides in which order to show the options to user */
  position?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "survey_v2_question_option". All fields are combined with a logical 'AND'. */
export type Survey_V2_Question_Option_Bool_Exp = {
  _and?: Maybe<Array<Survey_V2_Question_Option_Bool_Exp>>;
  _not?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
  _or?: Maybe<Array<Survey_V2_Question_Option_Bool_Exp>>;
  additional_info_config?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Bool_Exp>;
  additional_info_config_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  ended_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  option?: Maybe<String_Comparison_Exp>;
  position?: Maybe<Int_Comparison_Exp>;
  started_at?: Maybe<Timestamptz_Comparison_Exp>;
  survey_question?: Maybe<Survey_V2_Question_Bool_Exp>;
  survey_question_id?: Maybe<Uuid_Comparison_Exp>;
  template_config?: Maybe<Jsonb_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey_v2_question_option" */
export enum Survey_V2_Question_Option_Constraint {
  /** unique or primary key constraint on columns "id" */
  SurveyV2QuestionOptionPkey = 'survey_v2_question_option_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Survey_V2_Question_Option_Delete_At_Path_Input = {
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Survey_V2_Question_Option_Delete_Elem_Input = {
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Survey_V2_Question_Option_Delete_Key_Input = {
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Inc_Input = {
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Insert_Input = {
  additional_info_config?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Obj_Rel_Insert_Input>;
  additional_info_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option?: Maybe<Scalars['String']>;
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Int']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_question?: Maybe<Survey_V2_Question_Obj_Rel_Insert_Input>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Survey_V2_Question_Option_Max_Fields = {
  __typename?: 'survey_v2_question_option_max_fields';
  additional_info_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option?: Maybe<Scalars['String']>;
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Int']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Max_Order_By = {
  additional_info_config_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  ended_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option?: Maybe<Order_By>;
  /** this decides in which order to show the options to user */
  position?: Maybe<Order_By>;
  started_at?: Maybe<Order_By>;
  survey_question_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Survey_V2_Question_Option_Min_Fields = {
  __typename?: 'survey_v2_question_option_min_fields';
  additional_info_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option?: Maybe<Scalars['String']>;
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Int']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Min_Order_By = {
  additional_info_config_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  ended_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option?: Maybe<Order_By>;
  /** this decides in which order to show the options to user */
  position?: Maybe<Order_By>;
  started_at?: Maybe<Order_By>;
  survey_question_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Mutation_Response = {
  __typename?: 'survey_v2_question_option_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_V2_Question_Option>;
};

/** input type for inserting object relation for remote table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Obj_Rel_Insert_Input = {
  data: Survey_V2_Question_Option_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Survey_V2_Question_Option_On_Conflict>;
};

/** on_conflict condition type for table "survey_v2_question_option" */
export type Survey_V2_Question_Option_On_Conflict = {
  constraint: Survey_V2_Question_Option_Constraint;
  update_columns?: Array<Survey_V2_Question_Option_Update_Column>;
  where?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
};

/** Ordering options when selecting data from "survey_v2_question_option". */
export type Survey_V2_Question_Option_Order_By = {
  additional_info_config?: Maybe<Survey_V2_Question_Option_Additional_Info_Config_Order_By>;
  additional_info_config_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  ended_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option?: Maybe<Order_By>;
  position?: Maybe<Order_By>;
  started_at?: Maybe<Order_By>;
  survey_question?: Maybe<Survey_V2_Question_Order_By>;
  survey_question_id?: Maybe<Order_By>;
  template_config?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: survey_v2_question_option */
export type Survey_V2_Question_Option_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Survey_V2_Question_Option_Prepend_Input = {
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "survey_v2_question_option" */
export enum Survey_V2_Question_Option_Select_Column {
  /** column name */
  AdditionalInfoConfigId = 'additional_info_config_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  Id = 'id',
  /** column name */
  Option = 'option',
  /** column name */
  Position = 'position',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  SurveyQuestionId = 'survey_question_id',
  /** column name */
  TemplateConfig = 'template_config',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Set_Input = {
  additional_info_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option?: Maybe<Scalars['String']>;
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Int']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Survey_V2_Question_Option_Stddev_Fields = {
  __typename?: 'survey_v2_question_option_stddev_fields';
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Stddev_Order_By = {
  /** this decides in which order to show the options to user */
  position?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Survey_V2_Question_Option_Stddev_Pop_Fields = {
  __typename?: 'survey_v2_question_option_stddev_pop_fields';
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Stddev_Pop_Order_By = {
  /** this decides in which order to show the options to user */
  position?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Survey_V2_Question_Option_Stddev_Samp_Fields = {
  __typename?: 'survey_v2_question_option_stddev_samp_fields';
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Stddev_Samp_Order_By = {
  /** this decides in which order to show the options to user */
  position?: Maybe<Order_By>;
};

/** Streaming cursor of the table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_V2_Question_Option_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_V2_Question_Option_Stream_Cursor_Value_Input = {
  additional_info_config_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option?: Maybe<Scalars['String']>;
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Int']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Survey_V2_Question_Option_Sum_Fields = {
  __typename?: 'survey_v2_question_option_sum_fields';
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Sum_Order_By = {
  /** this decides in which order to show the options to user */
  position?: Maybe<Order_By>;
};

/** update columns of table "survey_v2_question_option" */
export enum Survey_V2_Question_Option_Update_Column {
  /** column name */
  AdditionalInfoConfigId = 'additional_info_config_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  Id = 'id',
  /** column name */
  Option = 'option',
  /** column name */
  Position = 'position',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  SurveyQuestionId = 'survey_question_id',
  /** column name */
  TemplateConfig = 'template_config',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Survey_V2_Question_Option_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Survey_V2_Question_Option_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Survey_V2_Question_Option_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Survey_V2_Question_Option_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Survey_V2_Question_Option_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Survey_V2_Question_Option_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Survey_V2_Question_Option_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_V2_Question_Option_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_V2_Question_Option_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Survey_V2_Question_Option_Var_Pop_Fields = {
  __typename?: 'survey_v2_question_option_var_pop_fields';
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Var_Pop_Order_By = {
  /** this decides in which order to show the options to user */
  position?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Survey_V2_Question_Option_Var_Samp_Fields = {
  __typename?: 'survey_v2_question_option_var_samp_fields';
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Var_Samp_Order_By = {
  /** this decides in which order to show the options to user */
  position?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Survey_V2_Question_Option_Variance_Fields = {
  __typename?: 'survey_v2_question_option_variance_fields';
  /** this decides in which order to show the options to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "survey_v2_question_option" */
export type Survey_V2_Question_Option_Variance_Order_By = {
  /** this decides in which order to show the options to user */
  position?: Maybe<Order_By>;
};

/** Ordering options when selecting data from "survey_v2_question". */
export type Survey_V2_Question_Order_By = {
  created_at?: Maybe<Order_By>;
  ended_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_mandatory?: Maybe<Order_By>;
  kind?: Maybe<Order_By>;
  kind_config_override?: Maybe<Order_By>;
  position?: Maybe<Order_By>;
  question?: Maybe<Order_By>;
  started_at?: Maybe<Order_By>;
  survey?: Maybe<Survey_V2_Order_By>;
  survey_id?: Maybe<Order_By>;
  survey_question_kind?: Maybe<Survey_V2_Question_Kind_Order_By>;
  survey_question_options_aggregate?: Maybe<Survey_V2_Question_Option_Aggregate_Order_By>;
  survey_response_answers_aggregate?: Maybe<Survey_V2_Response_Answer_Aggregate_Order_By>;
  template_config?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: survey_v2_question */
export type Survey_V2_Question_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Survey_V2_Question_Prepend_Input = {
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "survey_v2_question" */
export enum Survey_V2_Question_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsMandatory = 'is_mandatory',
  /** column name */
  Kind = 'kind',
  /** column name */
  KindConfigOverride = 'kind_config_override',
  /** column name */
  Position = 'position',
  /** column name */
  Question = 'question',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  SurveyId = 'survey_id',
  /** column name */
  TemplateConfig = 'template_config',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** select "survey_v2_question_aggregate_bool_exp_bool_and_arguments_columns" columns of table "survey_v2_question" */
export enum Survey_V2_Question_Select_Column_Survey_V2_Question_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsMandatory = 'is_mandatory',
}

/** select "survey_v2_question_aggregate_bool_exp_bool_or_arguments_columns" columns of table "survey_v2_question" */
export enum Survey_V2_Question_Select_Column_Survey_V2_Question_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsMandatory = 'is_mandatory',
}

/** input type for updating data in table "survey_v2_question" */
export type Survey_V2_Question_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_mandatory?: Maybe<Scalars['Boolean']>;
  kind?: Maybe<Survey_V2_Question_Kind_Enum>;
  /** overrides default config provided in survey_question_kind */
  kind_config_override?: Maybe<Scalars['String']>;
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_id?: Maybe<Scalars['uuid']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Survey_V2_Question_Stddev_Fields = {
  __typename?: 'survey_v2_question_stddev_fields';
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "survey_v2_question" */
export type Survey_V2_Question_Stddev_Order_By = {
  /** this decides in which order to show the questions to user */
  position?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Survey_V2_Question_Stddev_Pop_Fields = {
  __typename?: 'survey_v2_question_stddev_pop_fields';
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "survey_v2_question" */
export type Survey_V2_Question_Stddev_Pop_Order_By = {
  /** this decides in which order to show the questions to user */
  position?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Survey_V2_Question_Stddev_Samp_Fields = {
  __typename?: 'survey_v2_question_stddev_samp_fields';
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "survey_v2_question" */
export type Survey_V2_Question_Stddev_Samp_Order_By = {
  /** this decides in which order to show the questions to user */
  position?: Maybe<Order_By>;
};

/** Streaming cursor of the table "survey_v2_question" */
export type Survey_V2_Question_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_V2_Question_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_V2_Question_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  is_mandatory?: Maybe<Scalars['Boolean']>;
  kind?: Maybe<Survey_V2_Question_Kind_Enum>;
  /** overrides default config provided in survey_question_kind */
  kind_config_override?: Maybe<Scalars['String']>;
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Int']>;
  question?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_id?: Maybe<Scalars['uuid']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Survey_V2_Question_Sum_Fields = {
  __typename?: 'survey_v2_question_sum_fields';
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "survey_v2_question" */
export type Survey_V2_Question_Sum_Order_By = {
  /** this decides in which order to show the questions to user */
  position?: Maybe<Order_By>;
};

/** update columns of table "survey_v2_question" */
export enum Survey_V2_Question_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsMandatory = 'is_mandatory',
  /** column name */
  Kind = 'kind',
  /** column name */
  KindConfigOverride = 'kind_config_override',
  /** column name */
  Position = 'position',
  /** column name */
  Question = 'question',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  SurveyId = 'survey_id',
  /** column name */
  TemplateConfig = 'template_config',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Survey_V2_Question_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Survey_V2_Question_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Survey_V2_Question_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Survey_V2_Question_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Survey_V2_Question_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Survey_V2_Question_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Survey_V2_Question_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_V2_Question_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_V2_Question_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Survey_V2_Question_Var_Pop_Fields = {
  __typename?: 'survey_v2_question_var_pop_fields';
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "survey_v2_question" */
export type Survey_V2_Question_Var_Pop_Order_By = {
  /** this decides in which order to show the questions to user */
  position?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Survey_V2_Question_Var_Samp_Fields = {
  __typename?: 'survey_v2_question_var_samp_fields';
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "survey_v2_question" */
export type Survey_V2_Question_Var_Samp_Order_By = {
  /** this decides in which order to show the questions to user */
  position?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Survey_V2_Question_Variance_Fields = {
  __typename?: 'survey_v2_question_variance_fields';
  /** this decides in which order to show the questions to user */
  position?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "survey_v2_question" */
export type Survey_V2_Question_Variance_Order_By = {
  /** this decides in which order to show the questions to user */
  position?: Maybe<Order_By>;
};

/** survey response store the survey filled by the user */
export type Survey_V2_Response = {
  __typename?: 'survey_v2_response';
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  survey: Survey_V2;
  survey_id: Scalars['uuid'];
  /** An array relationship */
  survey_response_answers: Array<Survey_V2_Response_Answer>;
  /** An aggregate relationship */
  survey_response_answers_aggregate: Survey_V2_Response_Answer_Aggregate;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** survey response store the survey filled by the user */
export type Survey_V2_ResponseSurvey_Response_AnswersArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
};

/** survey response store the survey filled by the user */
export type Survey_V2_ResponseSurvey_Response_Answers_AggregateArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
};

/** aggregated selection of "survey_v2_response" */
export type Survey_V2_Response_Aggregate = {
  __typename?: 'survey_v2_response_aggregate';
  aggregate?: Maybe<Survey_V2_Response_Aggregate_Fields>;
  nodes: Array<Survey_V2_Response>;
};

export type Survey_V2_Response_Aggregate_Bool_Exp = {
  count?: Maybe<Survey_V2_Response_Aggregate_Bool_Exp_Count>;
};

export type Survey_V2_Response_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Survey_V2_Response_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Survey_V2_Response_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "survey_v2_response" */
export type Survey_V2_Response_Aggregate_Fields = {
  __typename?: 'survey_v2_response_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Survey_V2_Response_Max_Fields>;
  min?: Maybe<Survey_V2_Response_Min_Fields>;
};

/** aggregate fields of "survey_v2_response" */
export type Survey_V2_Response_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_V2_Response_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "survey_v2_response" */
export type Survey_V2_Response_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Survey_V2_Response_Max_Order_By>;
  min?: Maybe<Survey_V2_Response_Min_Order_By>;
};

/** contains information on user\`s answer */
export type Survey_V2_Response_Answer = {
  __typename?: 'survey_v2_response_answer';
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  survey_question: Survey_V2_Question;
  survey_question_id: Scalars['uuid'];
  /** An object relationship */
  survey_response: Survey_V2_Response;
  /** An array relationship */
  survey_response_answer_options: Array<Survey_V2_Response_Answer_Option>;
  /** An aggregate relationship */
  survey_response_answer_options_aggregate: Survey_V2_Response_Answer_Option_Aggregate;
  survey_response_id: Scalars['uuid'];
};

/** contains information on user\`s answer */
export type Survey_V2_Response_AnswerSurvey_Response_Answer_OptionsArgs = {
  distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Option_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Survey_V2_Response_Answer_Option_Order_By>>;
  where?: Maybe<Survey_V2_Response_Answer_Option_Bool_Exp>;
};

/** contains information on user\`s answer */
export type Survey_V2_Response_AnswerSurvey_Response_Answer_Options_AggregateArgs =
  {
    distinct_on?: Maybe<Array<Survey_V2_Response_Answer_Option_Select_Column>>;
    limit?: Maybe<Scalars['Int']>;
    offset?: Maybe<Scalars['Int']>;
    order_by?: Maybe<Array<Survey_V2_Response_Answer_Option_Order_By>>;
    where?: Maybe<Survey_V2_Response_Answer_Option_Bool_Exp>;
  };

/** aggregated selection of "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Aggregate = {
  __typename?: 'survey_v2_response_answer_aggregate';
  aggregate?: Maybe<Survey_V2_Response_Answer_Aggregate_Fields>;
  nodes: Array<Survey_V2_Response_Answer>;
};

export type Survey_V2_Response_Answer_Aggregate_Bool_Exp = {
  count?: Maybe<Survey_V2_Response_Answer_Aggregate_Bool_Exp_Count>;
};

export type Survey_V2_Response_Answer_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Survey_V2_Response_Answer_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Aggregate_Fields = {
  __typename?: 'survey_v2_response_answer_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Survey_V2_Response_Answer_Max_Fields>;
  min?: Maybe<Survey_V2_Response_Answer_Min_Fields>;
};

/** aggregate fields of "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_V2_Response_Answer_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Survey_V2_Response_Answer_Max_Order_By>;
  min?: Maybe<Survey_V2_Response_Answer_Min_Order_By>;
};

/** input type for inserting array relation for remote table "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Arr_Rel_Insert_Input = {
  data: Array<Survey_V2_Response_Answer_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Survey_V2_Response_Answer_On_Conflict>;
};

/** Boolean expression to filter rows from the table "survey_v2_response_answer". All fields are combined with a logical 'AND'. */
export type Survey_V2_Response_Answer_Bool_Exp = {
  _and?: Maybe<Array<Survey_V2_Response_Answer_Bool_Exp>>;
  _not?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
  _or?: Maybe<Array<Survey_V2_Response_Answer_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  survey_question?: Maybe<Survey_V2_Question_Bool_Exp>;
  survey_question_id?: Maybe<Uuid_Comparison_Exp>;
  survey_response?: Maybe<Survey_V2_Response_Bool_Exp>;
  survey_response_answer_options?: Maybe<Survey_V2_Response_Answer_Option_Bool_Exp>;
  survey_response_answer_options_aggregate?: Maybe<Survey_V2_Response_Answer_Option_Aggregate_Bool_Exp>;
  survey_response_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey_v2_response_answer" */
export enum Survey_V2_Response_Answer_Constraint {
  /** unique or primary key constraint on columns "id" */
  SurveyV2ResponseAnswerPkey = 'survey_v2_response_answer_pkey',
}

/** input type for inserting data into table "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  survey_question?: Maybe<Survey_V2_Question_Obj_Rel_Insert_Input>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  survey_response?: Maybe<Survey_V2_Response_Obj_Rel_Insert_Input>;
  survey_response_answer_options?: Maybe<Survey_V2_Response_Answer_Option_Arr_Rel_Insert_Input>;
  survey_response_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Survey_V2_Response_Answer_Max_Fields = {
  __typename?: 'survey_v2_response_answer_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  survey_response_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  survey_question_id?: Maybe<Order_By>;
  survey_response_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Survey_V2_Response_Answer_Min_Fields = {
  __typename?: 'survey_v2_response_answer_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  survey_response_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  survey_question_id?: Maybe<Order_By>;
  survey_response_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Mutation_Response = {
  __typename?: 'survey_v2_response_answer_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_V2_Response_Answer>;
};

/** input type for inserting object relation for remote table "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Obj_Rel_Insert_Input = {
  data: Survey_V2_Response_Answer_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Survey_V2_Response_Answer_On_Conflict>;
};

/** on_conflict condition type for table "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_On_Conflict = {
  constraint: Survey_V2_Response_Answer_Constraint;
  update_columns?: Array<Survey_V2_Response_Answer_Update_Column>;
  where?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
};

/** contains all the answers given by a user for a given question */
export type Survey_V2_Response_Answer_Option = {
  __typename?: 'survey_v2_response_answer_option';
  /** additional info for the answer if question has `is_additonal_info_required` as true */
  additional_info?: Maybe<Scalars['String']>;
  answer?: Maybe<Scalars['String']>;
  answer_id: Scalars['uuid'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  option_id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  survey_question_answer: Survey_V2_Response_Answer;
  /** An object relationship */
  survey_question_option?: Maybe<Survey_V2_Question_Option>;
};

/** aggregated selection of "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_Aggregate = {
  __typename?: 'survey_v2_response_answer_option_aggregate';
  aggregate?: Maybe<Survey_V2_Response_Answer_Option_Aggregate_Fields>;
  nodes: Array<Survey_V2_Response_Answer_Option>;
};

export type Survey_V2_Response_Answer_Option_Aggregate_Bool_Exp = {
  count?: Maybe<Survey_V2_Response_Answer_Option_Aggregate_Bool_Exp_Count>;
};

export type Survey_V2_Response_Answer_Option_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Survey_V2_Response_Answer_Option_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Survey_V2_Response_Answer_Option_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_Aggregate_Fields = {
  __typename?: 'survey_v2_response_answer_option_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Survey_V2_Response_Answer_Option_Max_Fields>;
  min?: Maybe<Survey_V2_Response_Answer_Option_Min_Fields>;
};

/** aggregate fields of "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Survey_V2_Response_Answer_Option_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Survey_V2_Response_Answer_Option_Max_Order_By>;
  min?: Maybe<Survey_V2_Response_Answer_Option_Min_Order_By>;
};

/** input type for inserting array relation for remote table "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_Arr_Rel_Insert_Input = {
  data: Array<Survey_V2_Response_Answer_Option_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Survey_V2_Response_Answer_Option_On_Conflict>;
};

/**
 * Boolean expression to filter rows from the table
 * "survey_v2_response_answer_option". All fields are combined with a logical 'AND'.
 */
export type Survey_V2_Response_Answer_Option_Bool_Exp = {
  _and?: Maybe<Array<Survey_V2_Response_Answer_Option_Bool_Exp>>;
  _not?: Maybe<Survey_V2_Response_Answer_Option_Bool_Exp>;
  _or?: Maybe<Array<Survey_V2_Response_Answer_Option_Bool_Exp>>;
  additional_info?: Maybe<String_Comparison_Exp>;
  answer?: Maybe<String_Comparison_Exp>;
  answer_id?: Maybe<Uuid_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  option_id?: Maybe<Uuid_Comparison_Exp>;
  survey_question_answer?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
  survey_question_option?: Maybe<Survey_V2_Question_Option_Bool_Exp>;
};

/** unique or primary key constraints on table "survey_v2_response_answer_option" */
export enum Survey_V2_Response_Answer_Option_Constraint {
  /** unique or primary key constraint on columns "id" */
  SurveyV2ResponseAnswerOptionPkey = 'survey_v2_response_answer_option_pkey',
}

/** input type for inserting data into table "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_Insert_Input = {
  /** additional info for the answer if question has `is_additonal_info_required` as true */
  additional_info?: Maybe<Scalars['String']>;
  answer?: Maybe<Scalars['String']>;
  answer_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option_id?: Maybe<Scalars['uuid']>;
  survey_question_answer?: Maybe<Survey_V2_Response_Answer_Obj_Rel_Insert_Input>;
  survey_question_option?: Maybe<Survey_V2_Question_Option_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Survey_V2_Response_Answer_Option_Max_Fields = {
  __typename?: 'survey_v2_response_answer_option_max_fields';
  /** additional info for the answer if question has `is_additonal_info_required` as true */
  additional_info?: Maybe<Scalars['String']>;
  answer?: Maybe<Scalars['String']>;
  answer_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_Max_Order_By = {
  /** additional info for the answer if question has `is_additonal_info_required` as true */
  additional_info?: Maybe<Order_By>;
  answer?: Maybe<Order_By>;
  answer_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Survey_V2_Response_Answer_Option_Min_Fields = {
  __typename?: 'survey_v2_response_answer_option_min_fields';
  /** additional info for the answer if question has `is_additonal_info_required` as true */
  additional_info?: Maybe<Scalars['String']>;
  answer?: Maybe<Scalars['String']>;
  answer_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_Min_Order_By = {
  /** additional info for the answer if question has `is_additonal_info_required` as true */
  additional_info?: Maybe<Order_By>;
  answer?: Maybe<Order_By>;
  answer_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_Mutation_Response = {
  __typename?: 'survey_v2_response_answer_option_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_V2_Response_Answer_Option>;
};

/** on_conflict condition type for table "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_On_Conflict = {
  constraint: Survey_V2_Response_Answer_Option_Constraint;
  update_columns?: Array<Survey_V2_Response_Answer_Option_Update_Column>;
  where?: Maybe<Survey_V2_Response_Answer_Option_Bool_Exp>;
};

/** Ordering options when selecting data from "survey_v2_response_answer_option". */
export type Survey_V2_Response_Answer_Option_Order_By = {
  additional_info?: Maybe<Order_By>;
  answer?: Maybe<Order_By>;
  answer_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  option_id?: Maybe<Order_By>;
  survey_question_answer?: Maybe<Survey_V2_Response_Answer_Order_By>;
  survey_question_option?: Maybe<Survey_V2_Question_Option_Order_By>;
};

/** primary key columns input for table: survey_v2_response_answer_option */
export type Survey_V2_Response_Answer_Option_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "survey_v2_response_answer_option" */
export enum Survey_V2_Response_Answer_Option_Select_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  Answer = 'answer',
  /** column name */
  AnswerId = 'answer_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  OptionId = 'option_id',
}

/** input type for updating data in table "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_Set_Input = {
  /** additional info for the answer if question has `is_additonal_info_required` as true */
  additional_info?: Maybe<Scalars['String']>;
  answer?: Maybe<Scalars['String']>;
  answer_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "survey_v2_response_answer_option" */
export type Survey_V2_Response_Answer_Option_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_V2_Response_Answer_Option_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_V2_Response_Answer_Option_Stream_Cursor_Value_Input = {
  /** additional info for the answer if question has `is_additonal_info_required` as true */
  additional_info?: Maybe<Scalars['String']>;
  answer?: Maybe<Scalars['String']>;
  answer_id?: Maybe<Scalars['uuid']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  option_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "survey_v2_response_answer_option" */
export enum Survey_V2_Response_Answer_Option_Update_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  Answer = 'answer',
  /** column name */
  AnswerId = 'answer_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  OptionId = 'option_id',
}

export type Survey_V2_Response_Answer_Option_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_V2_Response_Answer_Option_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_V2_Response_Answer_Option_Bool_Exp;
};

/** Ordering options when selecting data from "survey_v2_response_answer". */
export type Survey_V2_Response_Answer_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  survey_question?: Maybe<Survey_V2_Question_Order_By>;
  survey_question_id?: Maybe<Order_By>;
  survey_response?: Maybe<Survey_V2_Response_Order_By>;
  survey_response_answer_options_aggregate?: Maybe<Survey_V2_Response_Answer_Option_Aggregate_Order_By>;
  survey_response_id?: Maybe<Order_By>;
};

/** primary key columns input for table: survey_v2_response_answer */
export type Survey_V2_Response_Answer_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "survey_v2_response_answer" */
export enum Survey_V2_Response_Answer_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  SurveyQuestionId = 'survey_question_id',
  /** column name */
  SurveyResponseId = 'survey_response_id',
}

/** input type for updating data in table "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  survey_response_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "survey_v2_response_answer" */
export type Survey_V2_Response_Answer_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_V2_Response_Answer_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_V2_Response_Answer_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  survey_question_id?: Maybe<Scalars['uuid']>;
  survey_response_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "survey_v2_response_answer" */
export enum Survey_V2_Response_Answer_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  SurveyQuestionId = 'survey_question_id',
  /** column name */
  SurveyResponseId = 'survey_response_id',
}

export type Survey_V2_Response_Answer_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_V2_Response_Answer_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_V2_Response_Answer_Bool_Exp;
};

/** input type for inserting array relation for remote table "survey_v2_response" */
export type Survey_V2_Response_Arr_Rel_Insert_Input = {
  data: Array<Survey_V2_Response_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Survey_V2_Response_On_Conflict>;
};

/** Boolean expression to filter rows from the table "survey_v2_response". All fields are combined with a logical 'AND'. */
export type Survey_V2_Response_Bool_Exp = {
  _and?: Maybe<Array<Survey_V2_Response_Bool_Exp>>;
  _not?: Maybe<Survey_V2_Response_Bool_Exp>;
  _or?: Maybe<Array<Survey_V2_Response_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  survey?: Maybe<Survey_V2_Bool_Exp>;
  survey_id?: Maybe<Uuid_Comparison_Exp>;
  survey_response_answers?: Maybe<Survey_V2_Response_Answer_Bool_Exp>;
  survey_response_answers_aggregate?: Maybe<Survey_V2_Response_Answer_Aggregate_Bool_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "survey_v2_response" */
export enum Survey_V2_Response_Constraint {
  /** unique or primary key constraint on columns "id" */
  SurveyV2ResponsePkey = 'survey_v2_response_pkey',
}

/** input type for inserting data into table "survey_v2_response" */
export type Survey_V2_Response_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  survey?: Maybe<Survey_V2_Obj_Rel_Insert_Input>;
  survey_id?: Maybe<Scalars['uuid']>;
  survey_response_answers?: Maybe<Survey_V2_Response_Answer_Arr_Rel_Insert_Input>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Survey_V2_Response_Max_Fields = {
  __typename?: 'survey_v2_response_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  survey_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "survey_v2_response" */
export type Survey_V2_Response_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  survey_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Survey_V2_Response_Min_Fields = {
  __typename?: 'survey_v2_response_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  survey_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "survey_v2_response" */
export type Survey_V2_Response_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  survey_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "survey_v2_response" */
export type Survey_V2_Response_Mutation_Response = {
  __typename?: 'survey_v2_response_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Survey_V2_Response>;
};

/** input type for inserting object relation for remote table "survey_v2_response" */
export type Survey_V2_Response_Obj_Rel_Insert_Input = {
  data: Survey_V2_Response_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Survey_V2_Response_On_Conflict>;
};

/** on_conflict condition type for table "survey_v2_response" */
export type Survey_V2_Response_On_Conflict = {
  constraint: Survey_V2_Response_Constraint;
  update_columns?: Array<Survey_V2_Response_Update_Column>;
  where?: Maybe<Survey_V2_Response_Bool_Exp>;
};

/** Ordering options when selecting data from "survey_v2_response". */
export type Survey_V2_Response_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  survey?: Maybe<Survey_V2_Order_By>;
  survey_id?: Maybe<Order_By>;
  survey_response_answers_aggregate?: Maybe<Survey_V2_Response_Answer_Aggregate_Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: survey_v2_response */
export type Survey_V2_Response_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "survey_v2_response" */
export enum Survey_V2_Response_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  SurveyId = 'survey_id',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "survey_v2_response" */
export type Survey_V2_Response_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  survey_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "survey_v2_response" */
export type Survey_V2_Response_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_V2_Response_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_V2_Response_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  survey_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "survey_v2_response" */
export enum Survey_V2_Response_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  SurveyId = 'survey_id',
  /** column name */
  UserId = 'user_id',
}

export type Survey_V2_Response_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_V2_Response_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_V2_Response_Bool_Exp;
};

/** select columns of table "survey_v2" */
export enum Survey_V2_Select_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  Id = 'id',
  /** column name */
  RequestedBy = 'requested_by',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  SurveyDescription = 'survey_description',
  /** column name */
  SurveyName = 'survey_name',
  /** column name */
  SurveyTitle = 'survey_title',
  /** column name */
  TemplateConfig = 'template_config',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "survey_v2" */
export type Survey_V2_Set_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  requested_by?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_description?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  survey_title?: Maybe<Scalars['String']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "survey_v2" */
export type Survey_V2_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Survey_V2_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Survey_V2_Stream_Cursor_Value_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  ended_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  requested_by?: Maybe<Scalars['String']>;
  started_at?: Maybe<Scalars['timestamptz']>;
  survey_description?: Maybe<Scalars['String']>;
  survey_name?: Maybe<Scalars['String']>;
  survey_title?: Maybe<Scalars['String']>;
  /** jsonb column to store any UI template related configuration */
  template_config?: Maybe<Scalars['jsonb']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "survey_v2" */
export enum Survey_V2_Update_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'ended_at',
  /** column name */
  Id = 'id',
  /** column name */
  RequestedBy = 'requested_by',
  /** column name */
  StartedAt = 'started_at',
  /** column name */
  SurveyDescription = 'survey_description',
  /** column name */
  SurveyName = 'survey_name',
  /** column name */
  SurveyTitle = 'survey_title',
  /** column name */
  TemplateConfig = 'template_config',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Survey_V2_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Survey_V2_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Survey_V2_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Survey_V2_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Survey_V2_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Survey_V2_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Survey_V2_Set_Input>;
  /** filter the rows which have to be updated */
  where: Survey_V2_Bool_Exp;
};

export type SurveyAnswersPayload = {
  projectID?: Maybe<Scalars['uuid']>;
  responses: Array<Maybe<QuestionAnswers>>;
  surveyName: Scalars['String'];
};

export type SurveyResponseV2 = {
  additionalInfo?: Maybe<Scalars['String']>;
  answer?: Maybe<Scalars['String']>;
  optionSelected?: Maybe<Scalars['uuid']>;
  questionId: Scalars['uuid'];
};

/** columns and relationships of "task_event" */
export type Task_Event = {
  __typename?: 'task_event';
  created_at: Scalars['timestamptz'];
  error?: Maybe<Scalars['String']>;
  event_data?: Maybe<Scalars['jsonb']>;
  event_type: Scalars['String'];
  /** gets event detail for events of github_description job type */
  github_detail?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  public_event_data?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  task: Tasks;
  task_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "task_event" */
export type Task_EventEvent_DataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "task_event" */
export type Task_EventPublic_Event_DataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "task_event" */
export type Task_Event_Aggregate = {
  __typename?: 'task_event_aggregate';
  aggregate?: Maybe<Task_Event_Aggregate_Fields>;
  nodes: Array<Task_Event>;
};

export type Task_Event_Aggregate_Bool_Exp = {
  count?: Maybe<Task_Event_Aggregate_Bool_Exp_Count>;
};

export type Task_Event_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Task_Event_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Task_Event_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "task_event" */
export type Task_Event_Aggregate_Fields = {
  __typename?: 'task_event_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Task_Event_Max_Fields>;
  min?: Maybe<Task_Event_Min_Fields>;
};

/** aggregate fields of "task_event" */
export type Task_Event_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Task_Event_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "task_event" */
export type Task_Event_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Task_Event_Max_Order_By>;
  min?: Maybe<Task_Event_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Task_Event_Append_Input = {
  event_data?: Maybe<Scalars['jsonb']>;
  public_event_data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "task_event" */
export type Task_Event_Arr_Rel_Insert_Input = {
  data: Array<Task_Event_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Task_Event_On_Conflict>;
};

/** Boolean expression to filter rows from the table "task_event". All fields are combined with a logical 'AND'. */
export type Task_Event_Bool_Exp = {
  _and?: Maybe<Array<Task_Event_Bool_Exp>>;
  _not?: Maybe<Task_Event_Bool_Exp>;
  _or?: Maybe<Array<Task_Event_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  error?: Maybe<String_Comparison_Exp>;
  event_data?: Maybe<Jsonb_Comparison_Exp>;
  event_type?: Maybe<String_Comparison_Exp>;
  github_detail?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  public_event_data?: Maybe<Jsonb_Comparison_Exp>;
  task?: Maybe<Tasks_Bool_Exp>;
  task_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "task_event" */
export enum Task_Event_Constraint {
  /** unique or primary key constraint on columns "id" */
  TaskEventPkey = 'task_event_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Task_Event_Delete_At_Path_Input = {
  event_data?: Maybe<Array<Scalars['String']>>;
  public_event_data?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Task_Event_Delete_Elem_Input = {
  event_data?: Maybe<Scalars['Int']>;
  public_event_data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Task_Event_Delete_Key_Input = {
  event_data?: Maybe<Scalars['String']>;
  public_event_data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "task_event" */
export type Task_Event_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  event_data?: Maybe<Scalars['jsonb']>;
  event_type?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  public_event_data?: Maybe<Scalars['jsonb']>;
  task?: Maybe<Tasks_Obj_Rel_Insert_Input>;
  task_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Task_Event_Max_Fields = {
  __typename?: 'task_event_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  event_type?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  task_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "task_event" */
export type Task_Event_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  event_type?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  task_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Task_Event_Min_Fields = {
  __typename?: 'task_event_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  event_type?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  task_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "task_event" */
export type Task_Event_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  event_type?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  task_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "task_event" */
export type Task_Event_Mutation_Response = {
  __typename?: 'task_event_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Task_Event>;
};

/** on_conflict condition type for table "task_event" */
export type Task_Event_On_Conflict = {
  constraint: Task_Event_Constraint;
  update_columns?: Array<Task_Event_Update_Column>;
  where?: Maybe<Task_Event_Bool_Exp>;
};

/** Ordering options when selecting data from "task_event". */
export type Task_Event_Order_By = {
  created_at?: Maybe<Order_By>;
  error?: Maybe<Order_By>;
  event_data?: Maybe<Order_By>;
  event_type?: Maybe<Order_By>;
  github_detail?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  public_event_data?: Maybe<Order_By>;
  task?: Maybe<Tasks_Order_By>;
  task_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: task_event */
export type Task_Event_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Task_Event_Prepend_Input = {
  event_data?: Maybe<Scalars['jsonb']>;
  public_event_data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "task_event" */
export enum Task_Event_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventData = 'event_data',
  /** column name */
  EventType = 'event_type',
  /** column name */
  Id = 'id',
  /** column name */
  PublicEventData = 'public_event_data',
  /** column name */
  TaskId = 'task_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "task_event" */
export type Task_Event_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  event_data?: Maybe<Scalars['jsonb']>;
  event_type?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  public_event_data?: Maybe<Scalars['jsonb']>;
  task_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "task_event" */
export type Task_Event_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Task_Event_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Task_Event_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  event_data?: Maybe<Scalars['jsonb']>;
  event_type?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  public_event_data?: Maybe<Scalars['jsonb']>;
  task_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "task_event" */
export enum Task_Event_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventData = 'event_data',
  /** column name */
  EventType = 'event_type',
  /** column name */
  Id = 'id',
  /** column name */
  PublicEventData = 'public_event_data',
  /** column name */
  TaskId = 'task_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Task_Event_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Task_Event_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Task_Event_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Task_Event_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Task_Event_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Task_Event_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Task_Event_Set_Input>;
  /** filter the rows which have to be updated */
  where: Task_Event_Bool_Exp;
};

/** columns and relationships of "taskq_worker_event_latest" */
export type Taskq_Worker_Event_Latest = {
  __typename?: 'taskq_worker_event_latest';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  event_id?: Maybe<Scalars['uuid']>;
  event_type?: Maybe<Scalars['String']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_input?: Maybe<Scalars['jsonb']>;
  job_type?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  /** An object relationship */
  task?: Maybe<Tasks>;
  task_event_data?: Maybe<Scalars['jsonb']>;
  task_id?: Maybe<Scalars['uuid']>;
  task_payload?: Maybe<Scalars['jsonb']>;
  task_type?: Maybe<Scalars['String']>;
};

/** columns and relationships of "taskq_worker_event_latest" */
export type Taskq_Worker_Event_LatestJob_InputArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "taskq_worker_event_latest" */
export type Taskq_Worker_Event_LatestTask_Event_DataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "taskq_worker_event_latest" */
export type Taskq_Worker_Event_LatestTask_PayloadArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "taskq_worker_event_latest" */
export type Taskq_Worker_Event_Latest_Aggregate = {
  __typename?: 'taskq_worker_event_latest_aggregate';
  aggregate?: Maybe<Taskq_Worker_Event_Latest_Aggregate_Fields>;
  nodes: Array<Taskq_Worker_Event_Latest>;
};

/** aggregate fields of "taskq_worker_event_latest" */
export type Taskq_Worker_Event_Latest_Aggregate_Fields = {
  __typename?: 'taskq_worker_event_latest_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Taskq_Worker_Event_Latest_Max_Fields>;
  min?: Maybe<Taskq_Worker_Event_Latest_Min_Fields>;
};

/** aggregate fields of "taskq_worker_event_latest" */
export type Taskq_Worker_Event_Latest_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Taskq_Worker_Event_Latest_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "taskq_worker_event_latest". All fields are combined with a logical 'AND'. */
export type Taskq_Worker_Event_Latest_Bool_Exp = {
  _and?: Maybe<Array<Taskq_Worker_Event_Latest_Bool_Exp>>;
  _not?: Maybe<Taskq_Worker_Event_Latest_Bool_Exp>;
  _or?: Maybe<Array<Taskq_Worker_Event_Latest_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  event_id?: Maybe<Uuid_Comparison_Exp>;
  event_type?: Maybe<String_Comparison_Exp>;
  job_created_at?: Maybe<Timestamptz_Comparison_Exp>;
  job_id?: Maybe<Uuid_Comparison_Exp>;
  job_input?: Maybe<Jsonb_Comparison_Exp>;
  job_type?: Maybe<String_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  task?: Maybe<Tasks_Bool_Exp>;
  task_event_data?: Maybe<Jsonb_Comparison_Exp>;
  task_id?: Maybe<Uuid_Comparison_Exp>;
  task_payload?: Maybe<Jsonb_Comparison_Exp>;
  task_type?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type Taskq_Worker_Event_Latest_Max_Fields = {
  __typename?: 'taskq_worker_event_latest_max_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  event_id?: Maybe<Scalars['uuid']>;
  event_type?: Maybe<Scalars['String']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_type?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  task_id?: Maybe<Scalars['uuid']>;
  task_type?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Taskq_Worker_Event_Latest_Min_Fields = {
  __typename?: 'taskq_worker_event_latest_min_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  event_id?: Maybe<Scalars['uuid']>;
  event_type?: Maybe<Scalars['String']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_type?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  task_id?: Maybe<Scalars['uuid']>;
  task_type?: Maybe<Scalars['String']>;
};

/** Ordering options when selecting data from "taskq_worker_event_latest". */
export type Taskq_Worker_Event_Latest_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  event_id?: Maybe<Order_By>;
  event_type?: Maybe<Order_By>;
  job_created_at?: Maybe<Order_By>;
  job_id?: Maybe<Order_By>;
  job_input?: Maybe<Order_By>;
  job_type?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  task?: Maybe<Tasks_Order_By>;
  task_event_data?: Maybe<Order_By>;
  task_id?: Maybe<Order_By>;
  task_payload?: Maybe<Order_By>;
  task_type?: Maybe<Order_By>;
};

/** select columns of table "taskq_worker_event_latest" */
export enum Taskq_Worker_Event_Latest_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'event_id',
  /** column name */
  EventType = 'event_type',
  /** column name */
  JobCreatedAt = 'job_created_at',
  /** column name */
  JobId = 'job_id',
  /** column name */
  JobInput = 'job_input',
  /** column name */
  JobType = 'job_type',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Region = 'region',
  /** column name */
  TaskEventData = 'task_event_data',
  /** column name */
  TaskId = 'task_id',
  /** column name */
  TaskPayload = 'task_payload',
  /** column name */
  TaskType = 'task_type',
}

/** Streaming cursor of the table "taskq_worker_event_latest" */
export type Taskq_Worker_Event_Latest_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Taskq_Worker_Event_Latest_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Taskq_Worker_Event_Latest_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  event_id?: Maybe<Scalars['uuid']>;
  event_type?: Maybe<Scalars['String']>;
  job_created_at?: Maybe<Scalars['timestamptz']>;
  job_id?: Maybe<Scalars['uuid']>;
  job_input?: Maybe<Scalars['jsonb']>;
  job_type?: Maybe<Scalars['String']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  task_event_data?: Maybe<Scalars['jsonb']>;
  task_id?: Maybe<Scalars['uuid']>;
  task_payload?: Maybe<Scalars['jsonb']>;
  task_type?: Maybe<Scalars['String']>;
};

/** columns and relationships of "tasks" */
export type Tasks = {
  __typename?: 'tasks';
  cloud: Scalars['String'];
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  /** An object relationship */
  job: Jobs;
  job_id: Scalars['uuid'];
  max_retry: Scalars['Int'];
  name: Scalars['String'];
  payload?: Maybe<Scalars['jsonb']>;
  region: Scalars['String'];
  /** An array relationship */
  task_events: Array<Task_Event>;
  /** An aggregate relationship */
  task_events_aggregate: Task_Event_Aggregate;
  updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "tasks" */
export type TasksPayloadArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "tasks" */
export type TasksTask_EventsArgs = {
  distinct_on?: Maybe<Array<Task_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Task_Event_Order_By>>;
  where?: Maybe<Task_Event_Bool_Exp>;
};

/** columns and relationships of "tasks" */
export type TasksTask_Events_AggregateArgs = {
  distinct_on?: Maybe<Array<Task_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Task_Event_Order_By>>;
  where?: Maybe<Task_Event_Bool_Exp>;
};

/** aggregated selection of "tasks" */
export type Tasks_Aggregate = {
  __typename?: 'tasks_aggregate';
  aggregate?: Maybe<Tasks_Aggregate_Fields>;
  nodes: Array<Tasks>;
};

export type Tasks_Aggregate_Bool_Exp = {
  count?: Maybe<Tasks_Aggregate_Bool_Exp_Count>;
};

export type Tasks_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Tasks_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tasks_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "tasks" */
export type Tasks_Aggregate_Fields = {
  __typename?: 'tasks_aggregate_fields';
  avg?: Maybe<Tasks_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Tasks_Max_Fields>;
  min?: Maybe<Tasks_Min_Fields>;
  stddev?: Maybe<Tasks_Stddev_Fields>;
  stddev_pop?: Maybe<Tasks_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Tasks_Stddev_Samp_Fields>;
  sum?: Maybe<Tasks_Sum_Fields>;
  var_pop?: Maybe<Tasks_Var_Pop_Fields>;
  var_samp?: Maybe<Tasks_Var_Samp_Fields>;
  variance?: Maybe<Tasks_Variance_Fields>;
};

/** aggregate fields of "tasks" */
export type Tasks_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Tasks_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "tasks" */
export type Tasks_Aggregate_Order_By = {
  avg?: Maybe<Tasks_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Tasks_Max_Order_By>;
  min?: Maybe<Tasks_Min_Order_By>;
  stddev?: Maybe<Tasks_Stddev_Order_By>;
  stddev_pop?: Maybe<Tasks_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Tasks_Stddev_Samp_Order_By>;
  sum?: Maybe<Tasks_Sum_Order_By>;
  var_pop?: Maybe<Tasks_Var_Pop_Order_By>;
  var_samp?: Maybe<Tasks_Var_Samp_Order_By>;
  variance?: Maybe<Tasks_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Tasks_Append_Input = {
  payload?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "tasks" */
export type Tasks_Arr_Rel_Insert_Input = {
  data: Array<Tasks_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Tasks_On_Conflict>;
};

/** aggregate avg on columns */
export type Tasks_Avg_Fields = {
  __typename?: 'tasks_avg_fields';
  max_retry?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "tasks" */
export type Tasks_Avg_Order_By = {
  max_retry?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "tasks". All fields are combined with a logical 'AND'. */
export type Tasks_Bool_Exp = {
  _and?: Maybe<Array<Tasks_Bool_Exp>>;
  _not?: Maybe<Tasks_Bool_Exp>;
  _or?: Maybe<Array<Tasks_Bool_Exp>>;
  cloud?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  job?: Maybe<Jobs_Bool_Exp>;
  job_id?: Maybe<Uuid_Comparison_Exp>;
  max_retry?: Maybe<Int_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  payload?: Maybe<Jsonb_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  task_events?: Maybe<Task_Event_Bool_Exp>;
  task_events_aggregate?: Maybe<Task_Event_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "tasks" */
export enum Tasks_Constraint {
  /** unique or primary key constraint on columns "name", "job_id" */
  TasksJobIdNameKey = 'tasks_job_id_name_key',
  /** unique or primary key constraint on columns "id" */
  TasksPkey = 'tasks_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Tasks_Delete_At_Path_Input = {
  payload?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Tasks_Delete_Elem_Input = {
  payload?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Tasks_Delete_Key_Input = {
  payload?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "tasks" */
export type Tasks_Inc_Input = {
  max_retry?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "tasks" */
export type Tasks_Insert_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job?: Maybe<Jobs_Obj_Rel_Insert_Input>;
  job_id?: Maybe<Scalars['uuid']>;
  max_retry?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  payload?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  task_events?: Maybe<Task_Event_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Tasks_Max_Fields = {
  __typename?: 'tasks_max_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
  max_retry?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "tasks" */
export type Tasks_Max_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  job_id?: Maybe<Order_By>;
  max_retry?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Tasks_Min_Fields = {
  __typename?: 'tasks_min_fields';
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
  max_retry?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "tasks" */
export type Tasks_Min_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  job_id?: Maybe<Order_By>;
  max_retry?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "tasks" */
export type Tasks_Mutation_Response = {
  __typename?: 'tasks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Tasks>;
};

/** input type for inserting object relation for remote table "tasks" */
export type Tasks_Obj_Rel_Insert_Input = {
  data: Tasks_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Tasks_On_Conflict>;
};

/** on_conflict condition type for table "tasks" */
export type Tasks_On_Conflict = {
  constraint: Tasks_Constraint;
  update_columns?: Array<Tasks_Update_Column>;
  where?: Maybe<Tasks_Bool_Exp>;
};

/** Ordering options when selecting data from "tasks". */
export type Tasks_Order_By = {
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  job?: Maybe<Jobs_Order_By>;
  job_id?: Maybe<Order_By>;
  max_retry?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  payload?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  task_events_aggregate?: Maybe<Task_Event_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: tasks */
export type Tasks_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Tasks_Prepend_Input = {
  payload?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "tasks" */
export enum Tasks_Select_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobId = 'job_id',
  /** column name */
  MaxRetry = 'max_retry',
  /** column name */
  Name = 'name',
  /** column name */
  Payload = 'payload',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "tasks" */
export type Tasks_Set_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
  max_retry?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  payload?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Tasks_Stddev_Fields = {
  __typename?: 'tasks_stddev_fields';
  max_retry?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "tasks" */
export type Tasks_Stddev_Order_By = {
  max_retry?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Tasks_Stddev_Pop_Fields = {
  __typename?: 'tasks_stddev_pop_fields';
  max_retry?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "tasks" */
export type Tasks_Stddev_Pop_Order_By = {
  max_retry?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Tasks_Stddev_Samp_Fields = {
  __typename?: 'tasks_stddev_samp_fields';
  max_retry?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "tasks" */
export type Tasks_Stddev_Samp_Order_By = {
  max_retry?: Maybe<Order_By>;
};

/** Streaming cursor of the table "tasks" */
export type Tasks_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tasks_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tasks_Stream_Cursor_Value_Input = {
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  job_id?: Maybe<Scalars['uuid']>;
  max_retry?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  payload?: Maybe<Scalars['jsonb']>;
  region?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Tasks_Sum_Fields = {
  __typename?: 'tasks_sum_fields';
  max_retry?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "tasks" */
export type Tasks_Sum_Order_By = {
  max_retry?: Maybe<Order_By>;
};

/** update columns of table "tasks" */
export enum Tasks_Update_Column {
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobId = 'job_id',
  /** column name */
  MaxRetry = 'max_retry',
  /** column name */
  Name = 'name',
  /** column name */
  Payload = 'payload',
  /** column name */
  Region = 'region',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Tasks_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Tasks_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Tasks_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Tasks_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Tasks_Delete_Key_Input>;
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Tasks_Inc_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Tasks_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Tasks_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tasks_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Tasks_Var_Pop_Fields = {
  __typename?: 'tasks_var_pop_fields';
  max_retry?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "tasks" */
export type Tasks_Var_Pop_Order_By = {
  max_retry?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Tasks_Var_Samp_Fields = {
  __typename?: 'tasks_var_samp_fields';
  max_retry?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "tasks" */
export type Tasks_Var_Samp_Order_By = {
  max_retry?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Tasks_Variance_Fields = {
  __typename?: 'tasks_variance_fields';
  max_retry?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "tasks" */
export type Tasks_Variance_Order_By = {
  max_retry?: Maybe<Order_By>;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type Tenant = {
  __typename?: 'tenant';
  active: Scalars['Boolean'];
  active_status_reason?: Maybe<Scalars['String']>;
  alias?: Maybe<Scalars['String']>;
  /** An object relationship */
  central_cloud?: Maybe<Central_Cloud>;
  cloud: Scalars['String'];
  cloudflare_proxy_enabled: Scalars['Boolean'];
  /** An object relationship */
  config?: Maybe<Config>;
  created_at: Scalars['timestamptz'];
  /** An array relationship */
  custom_domains: Array<Custom_Domain>;
  /** An aggregate relationship */
  custom_domains_aggregate: Custom_Domain_Aggregate;
  /** An object relationship */
  dedicated_vpc?: Maybe<Dedicated_Vpc>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn: Scalars['String'];
  /** Tenant health status */
  health_status?: Maybe<Scalars['json']>;
  id: Scalars['uuid'];
  maintenance_mode: Scalars['Boolean'];
  major_version: Scalars['Int'];
  /** An object relationship */
  project: Projects;
  project_id: Scalars['uuid'];
  region: Scalars['String'];
  /** An object relationship */
  region_info?: Maybe<Region>;
  slug: Scalars['String'];
  /** An array relationship */
  status: Array<Tenant_Status>;
  /** An aggregate relationship */
  status_aggregate: Tenant_Status_Aggregate;
  /** An array relationship */
  tenant_group_members: Array<Tenant_Group_Member>;
  /** An aggregate relationship */
  tenant_group_members_aggregate: Tenant_Group_Member_Aggregate;
  /** An array relationship */
  tenant_public_status: Array<Tenant_Public_Status>;
  /** An aggregate relationship */
  tenant_public_status_aggregate: Tenant_Public_Status_Aggregate;
  updated_at: Scalars['timestamptz'];
  /** An array relationship */
  workers: Array<Hasura_Worker_Tenants>;
  /** An aggregate relationship */
  workers_aggregate: Hasura_Worker_Tenants_Aggregate;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type TenantCustom_DomainsArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Order_By>>;
  where?: Maybe<Custom_Domain_Bool_Exp>;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type TenantCustom_Domains_AggregateArgs = {
  distinct_on?: Maybe<Array<Custom_Domain_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Custom_Domain_Order_By>>;
  where?: Maybe<Custom_Domain_Bool_Exp>;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type TenantHealth_StatusArgs = {
  path?: Maybe<Scalars['String']>;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type TenantStatusArgs = {
  distinct_on?: Maybe<Array<Tenant_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Status_Order_By>>;
  where?: Maybe<Tenant_Status_Bool_Exp>;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type TenantStatus_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Status_Order_By>>;
  where?: Maybe<Tenant_Status_Bool_Exp>;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type TenantTenant_Group_MembersArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Member_Order_By>>;
  where?: Maybe<Tenant_Group_Member_Bool_Exp>;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type TenantTenant_Group_Members_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Member_Order_By>>;
  where?: Maybe<Tenant_Group_Member_Bool_Exp>;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type TenantTenant_Public_StatusArgs = {
  distinct_on?: Maybe<Array<Tenant_Public_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Public_Status_Order_By>>;
  where?: Maybe<Tenant_Public_Status_Bool_Exp>;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type TenantTenant_Public_Status_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Public_Status_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Public_Status_Order_By>>;
  where?: Maybe<Tenant_Public_Status_Bool_Exp>;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type TenantWorkersArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Tenants_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Tenants_Order_By>>;
  where?: Maybe<Hasura_Worker_Tenants_Bool_Exp>;
};

/** GraphQL API provisioned for a project in a cloud and region */
export type TenantWorkers_AggregateArgs = {
  distinct_on?: Maybe<Array<Hasura_Worker_Tenants_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Hasura_Worker_Tenants_Order_By>>;
  where?: Maybe<Hasura_Worker_Tenants_Bool_Exp>;
};

/** Enum for tenant activation/deactivation reason */
export type Tenant_Active_Status_Reason = {
  __typename?: 'tenant_active_status_reason';
  description: Scalars['String'];
  name: Scalars['String'];
};

/** aggregated selection of "tenant_active_status_reason" */
export type Tenant_Active_Status_Reason_Aggregate = {
  __typename?: 'tenant_active_status_reason_aggregate';
  aggregate?: Maybe<Tenant_Active_Status_Reason_Aggregate_Fields>;
  nodes: Array<Tenant_Active_Status_Reason>;
};

/** aggregate fields of "tenant_active_status_reason" */
export type Tenant_Active_Status_Reason_Aggregate_Fields = {
  __typename?: 'tenant_active_status_reason_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Tenant_Active_Status_Reason_Max_Fields>;
  min?: Maybe<Tenant_Active_Status_Reason_Min_Fields>;
};

/** aggregate fields of "tenant_active_status_reason" */
export type Tenant_Active_Status_Reason_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Tenant_Active_Status_Reason_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/**
 * Boolean expression to filter rows from the table "tenant_active_status_reason".
 * All fields are combined with a logical 'AND'.
 */
export type Tenant_Active_Status_Reason_Bool_Exp = {
  _and?: Maybe<Array<Tenant_Active_Status_Reason_Bool_Exp>>;
  _not?: Maybe<Tenant_Active_Status_Reason_Bool_Exp>;
  _or?: Maybe<Array<Tenant_Active_Status_Reason_Bool_Exp>>;
  description?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "tenant_active_status_reason" */
export enum Tenant_Active_Status_Reason_Constraint {
  /** unique or primary key constraint on columns "name" */
  TenantActiveStatusReasonPkey = 'tenant_active_status_reason_pkey',
}

/** input type for inserting data into table "tenant_active_status_reason" */
export type Tenant_Active_Status_Reason_Insert_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Tenant_Active_Status_Reason_Max_Fields = {
  __typename?: 'tenant_active_status_reason_max_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Tenant_Active_Status_Reason_Min_Fields = {
  __typename?: 'tenant_active_status_reason_min_fields';
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "tenant_active_status_reason" */
export type Tenant_Active_Status_Reason_Mutation_Response = {
  __typename?: 'tenant_active_status_reason_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Tenant_Active_Status_Reason>;
};

/** on_conflict condition type for table "tenant_active_status_reason" */
export type Tenant_Active_Status_Reason_On_Conflict = {
  constraint: Tenant_Active_Status_Reason_Constraint;
  update_columns?: Array<Tenant_Active_Status_Reason_Update_Column>;
  where?: Maybe<Tenant_Active_Status_Reason_Bool_Exp>;
};

/** Ordering options when selecting data from "tenant_active_status_reason". */
export type Tenant_Active_Status_Reason_Order_By = {
  description?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** primary key columns input for table: tenant_active_status_reason */
export type Tenant_Active_Status_Reason_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "tenant_active_status_reason" */
export enum Tenant_Active_Status_Reason_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

/** input type for updating data in table "tenant_active_status_reason" */
export type Tenant_Active_Status_Reason_Set_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "tenant_active_status_reason" */
export type Tenant_Active_Status_Reason_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tenant_Active_Status_Reason_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tenant_Active_Status_Reason_Stream_Cursor_Value_Input = {
  description?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
};

/** update columns of table "tenant_active_status_reason" */
export enum Tenant_Active_Status_Reason_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name',
}

export type Tenant_Active_Status_Reason_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Tenant_Active_Status_Reason_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tenant_Active_Status_Reason_Bool_Exp;
};

/** aggregated selection of "tenant" */
export type Tenant_Aggregate = {
  __typename?: 'tenant_aggregate';
  aggregate?: Maybe<Tenant_Aggregate_Fields>;
  nodes: Array<Tenant>;
};

export type Tenant_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Tenant_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Tenant_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Tenant_Aggregate_Bool_Exp_Count>;
};

export type Tenant_Aggregate_Bool_Exp_Bool_And = {
  arguments: Tenant_Select_Column_Tenant_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Tenant_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Tenant_Select_Column_Tenant_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Tenant_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Tenant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "tenant" */
export type Tenant_Aggregate_Fields = {
  __typename?: 'tenant_aggregate_fields';
  avg?: Maybe<Tenant_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Tenant_Max_Fields>;
  min?: Maybe<Tenant_Min_Fields>;
  stddev?: Maybe<Tenant_Stddev_Fields>;
  stddev_pop?: Maybe<Tenant_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Tenant_Stddev_Samp_Fields>;
  sum?: Maybe<Tenant_Sum_Fields>;
  var_pop?: Maybe<Tenant_Var_Pop_Fields>;
  var_samp?: Maybe<Tenant_Var_Samp_Fields>;
  variance?: Maybe<Tenant_Variance_Fields>;
};

/** aggregate fields of "tenant" */
export type Tenant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Tenant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "tenant" */
export type Tenant_Aggregate_Order_By = {
  avg?: Maybe<Tenant_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Tenant_Max_Order_By>;
  min?: Maybe<Tenant_Min_Order_By>;
  stddev?: Maybe<Tenant_Stddev_Order_By>;
  stddev_pop?: Maybe<Tenant_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Tenant_Stddev_Samp_Order_By>;
  sum?: Maybe<Tenant_Sum_Order_By>;
  var_pop?: Maybe<Tenant_Var_Pop_Order_By>;
  var_samp?: Maybe<Tenant_Var_Samp_Order_By>;
  variance?: Maybe<Tenant_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "tenant" */
export type Tenant_Arr_Rel_Insert_Input = {
  data: Array<Tenant_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Tenant_On_Conflict>;
};

/** aggregate avg on columns */
export type Tenant_Avg_Fields = {
  __typename?: 'tenant_avg_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "tenant" */
export type Tenant_Avg_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "tenant". All fields are combined with a logical 'AND'. */
export type Tenant_Bool_Exp = {
  _and?: Maybe<Array<Tenant_Bool_Exp>>;
  _not?: Maybe<Tenant_Bool_Exp>;
  _or?: Maybe<Array<Tenant_Bool_Exp>>;
  active?: Maybe<Boolean_Comparison_Exp>;
  active_status_reason?: Maybe<String_Comparison_Exp>;
  alias?: Maybe<String_Comparison_Exp>;
  central_cloud?: Maybe<Central_Cloud_Bool_Exp>;
  cloud?: Maybe<String_Comparison_Exp>;
  cloudflare_proxy_enabled?: Maybe<Boolean_Comparison_Exp>;
  config?: Maybe<Config_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  custom_domains?: Maybe<Custom_Domain_Bool_Exp>;
  custom_domains_aggregate?: Maybe<Custom_Domain_Aggregate_Bool_Exp>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Bool_Exp>;
  dedicated_vpc_id?: Maybe<Uuid_Comparison_Exp>;
  fqdn?: Maybe<String_Comparison_Exp>;
  health_status?: Maybe<Json_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  maintenance_mode?: Maybe<Boolean_Comparison_Exp>;
  major_version?: Maybe<Int_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  region_info?: Maybe<Region_Bool_Exp>;
  slug?: Maybe<String_Comparison_Exp>;
  status?: Maybe<Tenant_Status_Bool_Exp>;
  status_aggregate?: Maybe<Tenant_Status_Aggregate_Bool_Exp>;
  tenant_group_members?: Maybe<Tenant_Group_Member_Bool_Exp>;
  tenant_group_members_aggregate?: Maybe<Tenant_Group_Member_Aggregate_Bool_Exp>;
  tenant_public_status?: Maybe<Tenant_Public_Status_Bool_Exp>;
  tenant_public_status_aggregate?: Maybe<Tenant_Public_Status_Aggregate_Bool_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  workers?: Maybe<Hasura_Worker_Tenants_Bool_Exp>;
  workers_aggregate?: Maybe<Hasura_Worker_Tenants_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "tenant" */
export enum Tenant_Constraint {
  /** unique or primary key constraint on columns "fqdn" */
  TenantFqdnKey = 'tenant_fqdn_key',
  /** unique or primary key constraint on columns "id" */
  TenantPkey = 'tenant_pkey',
  /** unique or primary key constraint on columns "project_id" */
  TenantProjectIdKey = 'tenant_project_id_key',
  /** unique or primary key constraint on columns "slug" */
  TenantSlugKey = 'tenant_slug_key',
}

/** Group of tenants, meant for their co-location in a cluster */
export type Tenant_Group = {
  __typename?: 'tenant_group';
  allocation_policy: Scalars['String'];
  cloud: Scalars['String'];
  /** An object relationship */
  cluster?: Maybe<Hasura_Cluster>;
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  dedicated_vpc?: Maybe<Dedicated_Vpc>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  deployment_pools: Array<Cicd_Deployment_Pool_Member>;
  /** An aggregate relationship */
  deployment_pools_aggregate: Cicd_Deployment_Pool_Member_Aggregate;
  id: Scalars['uuid'];
  major_version: Scalars['Int'];
  /** An array relationship */
  members: Array<Tenant_Group_Member>;
  /** An aggregate relationship */
  members_aggregate: Tenant_Group_Member_Aggregate;
  plan_name?: Maybe<Scalars['String']>;
  region: Scalars['String'];
  /** An object relationship */
  region_info?: Maybe<Region>;
  slug: Scalars['String'];
};

/** Group of tenants, meant for their co-location in a cluster */
export type Tenant_GroupDeployment_PoolsArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Member_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
};

/** Group of tenants, meant for their co-location in a cluster */
export type Tenant_GroupDeployment_Pools_AggregateArgs = {
  distinct_on?: Maybe<Array<Cicd_Deployment_Pool_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Cicd_Deployment_Pool_Member_Order_By>>;
  where?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
};

/** Group of tenants, meant for their co-location in a cluster */
export type Tenant_GroupMembersArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Member_Order_By>>;
  where?: Maybe<Tenant_Group_Member_Bool_Exp>;
};

/** Group of tenants, meant for their co-location in a cluster */
export type Tenant_GroupMembers_AggregateArgs = {
  distinct_on?: Maybe<Array<Tenant_Group_Member_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Tenant_Group_Member_Order_By>>;
  where?: Maybe<Tenant_Group_Member_Bool_Exp>;
};

/** aggregated selection of "tenant_group" */
export type Tenant_Group_Aggregate = {
  __typename?: 'tenant_group_aggregate';
  aggregate?: Maybe<Tenant_Group_Aggregate_Fields>;
  nodes: Array<Tenant_Group>;
};

export type Tenant_Group_Aggregate_Bool_Exp = {
  count?: Maybe<Tenant_Group_Aggregate_Bool_Exp_Count>;
};

export type Tenant_Group_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Tenant_Group_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Group_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "tenant_group" */
export type Tenant_Group_Aggregate_Fields = {
  __typename?: 'tenant_group_aggregate_fields';
  avg?: Maybe<Tenant_Group_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Tenant_Group_Max_Fields>;
  min?: Maybe<Tenant_Group_Min_Fields>;
  stddev?: Maybe<Tenant_Group_Stddev_Fields>;
  stddev_pop?: Maybe<Tenant_Group_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Tenant_Group_Stddev_Samp_Fields>;
  sum?: Maybe<Tenant_Group_Sum_Fields>;
  var_pop?: Maybe<Tenant_Group_Var_Pop_Fields>;
  var_samp?: Maybe<Tenant_Group_Var_Samp_Fields>;
  variance?: Maybe<Tenant_Group_Variance_Fields>;
};

/** aggregate fields of "tenant_group" */
export type Tenant_Group_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Tenant_Group_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "tenant_group" */
export type Tenant_Group_Aggregate_Order_By = {
  avg?: Maybe<Tenant_Group_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Tenant_Group_Max_Order_By>;
  min?: Maybe<Tenant_Group_Min_Order_By>;
  stddev?: Maybe<Tenant_Group_Stddev_Order_By>;
  stddev_pop?: Maybe<Tenant_Group_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Tenant_Group_Stddev_Samp_Order_By>;
  sum?: Maybe<Tenant_Group_Sum_Order_By>;
  var_pop?: Maybe<Tenant_Group_Var_Pop_Order_By>;
  var_samp?: Maybe<Tenant_Group_Var_Samp_Order_By>;
  variance?: Maybe<Tenant_Group_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "tenant_group" */
export type Tenant_Group_Arr_Rel_Insert_Input = {
  data: Array<Tenant_Group_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Tenant_Group_On_Conflict>;
};

/** aggregate avg on columns */
export type Tenant_Group_Avg_Fields = {
  __typename?: 'tenant_group_avg_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "tenant_group" */
export type Tenant_Group_Avg_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "tenant_group". All fields are combined with a logical 'AND'. */
export type Tenant_Group_Bool_Exp = {
  _and?: Maybe<Array<Tenant_Group_Bool_Exp>>;
  _not?: Maybe<Tenant_Group_Bool_Exp>;
  _or?: Maybe<Array<Tenant_Group_Bool_Exp>>;
  allocation_policy?: Maybe<String_Comparison_Exp>;
  cloud?: Maybe<String_Comparison_Exp>;
  cluster?: Maybe<Hasura_Cluster_Bool_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Bool_Exp>;
  dedicated_vpc_id?: Maybe<Uuid_Comparison_Exp>;
  deployment_pools?: Maybe<Cicd_Deployment_Pool_Member_Bool_Exp>;
  deployment_pools_aggregate?: Maybe<Cicd_Deployment_Pool_Member_Aggregate_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  major_version?: Maybe<Int_Comparison_Exp>;
  members?: Maybe<Tenant_Group_Member_Bool_Exp>;
  members_aggregate?: Maybe<Tenant_Group_Member_Aggregate_Bool_Exp>;
  plan_name?: Maybe<String_Comparison_Exp>;
  region?: Maybe<String_Comparison_Exp>;
  region_info?: Maybe<Region_Bool_Exp>;
  slug?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "tenant_group" */
export enum Tenant_Group_Constraint {
  /** unique or primary key constraint on columns "id" */
  TenantGroupPkey = 'tenant_group_pkey',
  /** unique or primary key constraint on columns "slug" */
  TenantGroupSlugKey = 'tenant_group_slug_key',
}

/** input type for incrementing numeric columns in table "tenant_group" */
export type Tenant_Group_Inc_Input = {
  major_version?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "tenant_group" */
export type Tenant_Group_Insert_Input = {
  allocation_policy?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cluster?: Maybe<Hasura_Cluster_Obj_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Obj_Rel_Insert_Input>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  deployment_pools?: Maybe<Cicd_Deployment_Pool_Member_Arr_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  major_version?: Maybe<Scalars['Int']>;
  members?: Maybe<Tenant_Group_Member_Arr_Rel_Insert_Input>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  region_info?: Maybe<Region_Obj_Rel_Insert_Input>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Tenant_Group_Max_Fields = {
  __typename?: 'tenant_group_max_fields';
  allocation_policy?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  major_version?: Maybe<Scalars['Int']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "tenant_group" */
export type Tenant_Group_Max_Order_By = {
  allocation_policy?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dedicated_vpc_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  major_version?: Maybe<Order_By>;
  plan_name?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
};

/** Table connecting tenants and tenant groups */
export type Tenant_Group_Member = {
  __typename?: 'tenant_group_member';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  group: Tenant_Group;
  group_id: Scalars['uuid'];
  id: Scalars['uuid'];
  port?: Maybe<Scalars['Int']>;
  send_traffic: Scalars['Boolean'];
  /** An object relationship */
  tenant: Tenant;
  tenant_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "tenant_group_member" */
export type Tenant_Group_Member_Aggregate = {
  __typename?: 'tenant_group_member_aggregate';
  aggregate?: Maybe<Tenant_Group_Member_Aggregate_Fields>;
  nodes: Array<Tenant_Group_Member>;
};

export type Tenant_Group_Member_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Tenant_Group_Member_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Tenant_Group_Member_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Tenant_Group_Member_Aggregate_Bool_Exp_Count>;
};

export type Tenant_Group_Member_Aggregate_Bool_Exp_Bool_And = {
  arguments: Tenant_Group_Member_Select_Column_Tenant_Group_Member_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Group_Member_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Tenant_Group_Member_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Tenant_Group_Member_Select_Column_Tenant_Group_Member_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Group_Member_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Tenant_Group_Member_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Tenant_Group_Member_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Group_Member_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "tenant_group_member" */
export type Tenant_Group_Member_Aggregate_Fields = {
  __typename?: 'tenant_group_member_aggregate_fields';
  avg?: Maybe<Tenant_Group_Member_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Tenant_Group_Member_Max_Fields>;
  min?: Maybe<Tenant_Group_Member_Min_Fields>;
  stddev?: Maybe<Tenant_Group_Member_Stddev_Fields>;
  stddev_pop?: Maybe<Tenant_Group_Member_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Tenant_Group_Member_Stddev_Samp_Fields>;
  sum?: Maybe<Tenant_Group_Member_Sum_Fields>;
  var_pop?: Maybe<Tenant_Group_Member_Var_Pop_Fields>;
  var_samp?: Maybe<Tenant_Group_Member_Var_Samp_Fields>;
  variance?: Maybe<Tenant_Group_Member_Variance_Fields>;
};

/** aggregate fields of "tenant_group_member" */
export type Tenant_Group_Member_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Tenant_Group_Member_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "tenant_group_member" */
export type Tenant_Group_Member_Aggregate_Order_By = {
  avg?: Maybe<Tenant_Group_Member_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Tenant_Group_Member_Max_Order_By>;
  min?: Maybe<Tenant_Group_Member_Min_Order_By>;
  stddev?: Maybe<Tenant_Group_Member_Stddev_Order_By>;
  stddev_pop?: Maybe<Tenant_Group_Member_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Tenant_Group_Member_Stddev_Samp_Order_By>;
  sum?: Maybe<Tenant_Group_Member_Sum_Order_By>;
  var_pop?: Maybe<Tenant_Group_Member_Var_Pop_Order_By>;
  var_samp?: Maybe<Tenant_Group_Member_Var_Samp_Order_By>;
  variance?: Maybe<Tenant_Group_Member_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "tenant_group_member" */
export type Tenant_Group_Member_Arr_Rel_Insert_Input = {
  data: Array<Tenant_Group_Member_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Tenant_Group_Member_On_Conflict>;
};

/** aggregate avg on columns */
export type Tenant_Group_Member_Avg_Fields = {
  __typename?: 'tenant_group_member_avg_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "tenant_group_member" */
export type Tenant_Group_Member_Avg_Order_By = {
  port?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "tenant_group_member". All fields are combined with a logical 'AND'. */
export type Tenant_Group_Member_Bool_Exp = {
  _and?: Maybe<Array<Tenant_Group_Member_Bool_Exp>>;
  _not?: Maybe<Tenant_Group_Member_Bool_Exp>;
  _or?: Maybe<Array<Tenant_Group_Member_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  group?: Maybe<Tenant_Group_Bool_Exp>;
  group_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  port?: Maybe<Int_Comparison_Exp>;
  send_traffic?: Maybe<Boolean_Comparison_Exp>;
  tenant?: Maybe<Tenant_Bool_Exp>;
  tenant_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "tenant_group_member" */
export enum Tenant_Group_Member_Constraint {
  /** unique or primary key constraint on columns "port", "group_id" */
  TenantGroupMemberGroupIdPortKey = 'tenant_group_member_group_id_port_key',
  /** unique or primary key constraint on columns "id" */
  TenantGroupMemberPkey = 'tenant_group_member_pkey',
  /** unique or primary key constraint on columns "tenant_id", "group_id" */
  TenantGroupMemberTenantIdGroupIdKey = 'tenant_group_member_tenant_id_group_id_key',
  /** unique or primary key constraint on columns "port", "group_id" */
  TenantGroupPortUnique = 'tenant_group_port_unique',
}

/** input type for incrementing numeric columns in table "tenant_group_member" */
export type Tenant_Group_Member_Inc_Input = {
  port?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "tenant_group_member" */
export type Tenant_Group_Member_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  group?: Maybe<Tenant_Group_Obj_Rel_Insert_Input>;
  group_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  port?: Maybe<Scalars['Int']>;
  send_traffic?: Maybe<Scalars['Boolean']>;
  tenant?: Maybe<Tenant_Obj_Rel_Insert_Input>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Tenant_Group_Member_Max_Fields = {
  __typename?: 'tenant_group_member_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  group_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  port?: Maybe<Scalars['Int']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "tenant_group_member" */
export type Tenant_Group_Member_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  group_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  port?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Tenant_Group_Member_Min_Fields = {
  __typename?: 'tenant_group_member_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  group_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  port?: Maybe<Scalars['Int']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "tenant_group_member" */
export type Tenant_Group_Member_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  group_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  port?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "tenant_group_member" */
export type Tenant_Group_Member_Mutation_Response = {
  __typename?: 'tenant_group_member_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Tenant_Group_Member>;
};

/** on_conflict condition type for table "tenant_group_member" */
export type Tenant_Group_Member_On_Conflict = {
  constraint: Tenant_Group_Member_Constraint;
  update_columns?: Array<Tenant_Group_Member_Update_Column>;
  where?: Maybe<Tenant_Group_Member_Bool_Exp>;
};

/** Ordering options when selecting data from "tenant_group_member". */
export type Tenant_Group_Member_Order_By = {
  created_at?: Maybe<Order_By>;
  group?: Maybe<Tenant_Group_Order_By>;
  group_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  port?: Maybe<Order_By>;
  send_traffic?: Maybe<Order_By>;
  tenant?: Maybe<Tenant_Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: tenant_group_member */
export type Tenant_Group_Member_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "tenant_group_member" */
export enum Tenant_Group_Member_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  GroupId = 'group_id',
  /** column name */
  Id = 'id',
  /** column name */
  Port = 'port',
  /** column name */
  SendTraffic = 'send_traffic',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** select "tenant_group_member_aggregate_bool_exp_bool_and_arguments_columns" columns of table "tenant_group_member" */
export enum Tenant_Group_Member_Select_Column_Tenant_Group_Member_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  SendTraffic = 'send_traffic',
}

/** select "tenant_group_member_aggregate_bool_exp_bool_or_arguments_columns" columns of table "tenant_group_member" */
export enum Tenant_Group_Member_Select_Column_Tenant_Group_Member_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  SendTraffic = 'send_traffic',
}

/** input type for updating data in table "tenant_group_member" */
export type Tenant_Group_Member_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  group_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  port?: Maybe<Scalars['Int']>;
  send_traffic?: Maybe<Scalars['Boolean']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Tenant_Group_Member_Stddev_Fields = {
  __typename?: 'tenant_group_member_stddev_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "tenant_group_member" */
export type Tenant_Group_Member_Stddev_Order_By = {
  port?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Tenant_Group_Member_Stddev_Pop_Fields = {
  __typename?: 'tenant_group_member_stddev_pop_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "tenant_group_member" */
export type Tenant_Group_Member_Stddev_Pop_Order_By = {
  port?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Tenant_Group_Member_Stddev_Samp_Fields = {
  __typename?: 'tenant_group_member_stddev_samp_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "tenant_group_member" */
export type Tenant_Group_Member_Stddev_Samp_Order_By = {
  port?: Maybe<Order_By>;
};

/** Streaming cursor of the table "tenant_group_member" */
export type Tenant_Group_Member_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tenant_Group_Member_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tenant_Group_Member_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  group_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  port?: Maybe<Scalars['Int']>;
  send_traffic?: Maybe<Scalars['Boolean']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Tenant_Group_Member_Sum_Fields = {
  __typename?: 'tenant_group_member_sum_fields';
  port?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "tenant_group_member" */
export type Tenant_Group_Member_Sum_Order_By = {
  port?: Maybe<Order_By>;
};

/** update columns of table "tenant_group_member" */
export enum Tenant_Group_Member_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  GroupId = 'group_id',
  /** column name */
  Id = 'id',
  /** column name */
  Port = 'port',
  /** column name */
  SendTraffic = 'send_traffic',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Tenant_Group_Member_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Tenant_Group_Member_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Tenant_Group_Member_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tenant_Group_Member_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Tenant_Group_Member_Var_Pop_Fields = {
  __typename?: 'tenant_group_member_var_pop_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "tenant_group_member" */
export type Tenant_Group_Member_Var_Pop_Order_By = {
  port?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Tenant_Group_Member_Var_Samp_Fields = {
  __typename?: 'tenant_group_member_var_samp_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "tenant_group_member" */
export type Tenant_Group_Member_Var_Samp_Order_By = {
  port?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Tenant_Group_Member_Variance_Fields = {
  __typename?: 'tenant_group_member_variance_fields';
  port?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "tenant_group_member" */
export type Tenant_Group_Member_Variance_Order_By = {
  port?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Tenant_Group_Min_Fields = {
  __typename?: 'tenant_group_min_fields';
  allocation_policy?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  major_version?: Maybe<Scalars['Int']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "tenant_group" */
export type Tenant_Group_Min_Order_By = {
  allocation_policy?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dedicated_vpc_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  major_version?: Maybe<Order_By>;
  plan_name?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
};

/** response of any mutation on the table "tenant_group" */
export type Tenant_Group_Mutation_Response = {
  __typename?: 'tenant_group_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Tenant_Group>;
};

/** input type for inserting object relation for remote table "tenant_group" */
export type Tenant_Group_Obj_Rel_Insert_Input = {
  data: Tenant_Group_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Tenant_Group_On_Conflict>;
};

/** on_conflict condition type for table "tenant_group" */
export type Tenant_Group_On_Conflict = {
  constraint: Tenant_Group_Constraint;
  update_columns?: Array<Tenant_Group_Update_Column>;
  where?: Maybe<Tenant_Group_Bool_Exp>;
};

/** Ordering options when selecting data from "tenant_group". */
export type Tenant_Group_Order_By = {
  allocation_policy?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  cluster?: Maybe<Hasura_Cluster_Order_By>;
  created_at?: Maybe<Order_By>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Order_By>;
  dedicated_vpc_id?: Maybe<Order_By>;
  deployment_pools_aggregate?: Maybe<Cicd_Deployment_Pool_Member_Aggregate_Order_By>;
  id?: Maybe<Order_By>;
  major_version?: Maybe<Order_By>;
  members_aggregate?: Maybe<Tenant_Group_Member_Aggregate_Order_By>;
  plan_name?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  region_info?: Maybe<Region_Order_By>;
  slug?: Maybe<Order_By>;
};

/** primary key columns input for table: tenant_group */
export type Tenant_Group_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "tenant_group" */
export enum Tenant_Group_Select_Column {
  /** column name */
  AllocationPolicy = 'allocation_policy',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DedicatedVpcId = 'dedicated_vpc_id',
  /** column name */
  Id = 'id',
  /** column name */
  MajorVersion = 'major_version',
  /** column name */
  PlanName = 'plan_name',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
}

/** input type for updating data in table "tenant_group" */
export type Tenant_Group_Set_Input = {
  allocation_policy?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  major_version?: Maybe<Scalars['Int']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Tenant_Group_Stddev_Fields = {
  __typename?: 'tenant_group_stddev_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "tenant_group" */
export type Tenant_Group_Stddev_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Tenant_Group_Stddev_Pop_Fields = {
  __typename?: 'tenant_group_stddev_pop_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "tenant_group" */
export type Tenant_Group_Stddev_Pop_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Tenant_Group_Stddev_Samp_Fields = {
  __typename?: 'tenant_group_stddev_samp_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "tenant_group" */
export type Tenant_Group_Stddev_Samp_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** Streaming cursor of the table "tenant_group" */
export type Tenant_Group_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tenant_Group_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tenant_Group_Stream_Cursor_Value_Input = {
  allocation_policy?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  major_version?: Maybe<Scalars['Int']>;
  plan_name?: Maybe<Scalars['String']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
};

/** aggregate sum on columns */
export type Tenant_Group_Sum_Fields = {
  __typename?: 'tenant_group_sum_fields';
  major_version?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "tenant_group" */
export type Tenant_Group_Sum_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** update columns of table "tenant_group" */
export enum Tenant_Group_Update_Column {
  /** column name */
  AllocationPolicy = 'allocation_policy',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DedicatedVpcId = 'dedicated_vpc_id',
  /** column name */
  Id = 'id',
  /** column name */
  MajorVersion = 'major_version',
  /** column name */
  PlanName = 'plan_name',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
}

export type Tenant_Group_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Tenant_Group_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Tenant_Group_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tenant_Group_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Tenant_Group_Var_Pop_Fields = {
  __typename?: 'tenant_group_var_pop_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "tenant_group" */
export type Tenant_Group_Var_Pop_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Tenant_Group_Var_Samp_Fields = {
  __typename?: 'tenant_group_var_samp_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "tenant_group" */
export type Tenant_Group_Var_Samp_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Tenant_Group_Variance_Fields = {
  __typename?: 'tenant_group_variance_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "tenant_group" */
export type Tenant_Group_Variance_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** input type for incrementing numeric columns in table "tenant" */
export type Tenant_Inc_Input = {
  major_version?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "tenant" */
export type Tenant_Insert_Input = {
  active?: Maybe<Scalars['Boolean']>;
  active_status_reason?: Maybe<Scalars['String']>;
  alias?: Maybe<Scalars['String']>;
  central_cloud?: Maybe<Central_Cloud_Obj_Rel_Insert_Input>;
  cloud?: Maybe<Scalars['String']>;
  cloudflare_proxy_enabled?: Maybe<Scalars['Boolean']>;
  config?: Maybe<Config_Obj_Rel_Insert_Input>;
  created_at?: Maybe<Scalars['timestamptz']>;
  custom_domains?: Maybe<Custom_Domain_Arr_Rel_Insert_Input>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Obj_Rel_Insert_Input>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  maintenance_mode?: Maybe<Scalars['Boolean']>;
  major_version?: Maybe<Scalars['Int']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  region_info?: Maybe<Region_Obj_Rel_Insert_Input>;
  slug?: Maybe<Scalars['String']>;
  status?: Maybe<Tenant_Status_Arr_Rel_Insert_Input>;
  tenant_group_members?: Maybe<Tenant_Group_Member_Arr_Rel_Insert_Input>;
  tenant_public_status?: Maybe<Tenant_Public_Status_Arr_Rel_Insert_Input>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  workers?: Maybe<Hasura_Worker_Tenants_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Tenant_Max_Fields = {
  __typename?: 'tenant_max_fields';
  active_status_reason?: Maybe<Scalars['String']>;
  alias?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  major_version?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "tenant" */
export type Tenant_Max_Order_By = {
  active_status_reason?: Maybe<Order_By>;
  alias?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dedicated_vpc_id?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  major_version?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Tenant_Min_Fields = {
  __typename?: 'tenant_min_fields';
  active_status_reason?: Maybe<Scalars['String']>;
  alias?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  major_version?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "tenant" */
export type Tenant_Min_Order_By = {
  active_status_reason?: Maybe<Order_By>;
  alias?: Maybe<Order_By>;
  cloud?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dedicated_vpc_id?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  major_version?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  slug?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "tenant" */
export type Tenant_Mutation_Response = {
  __typename?: 'tenant_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Tenant>;
};

/** input type for inserting object relation for remote table "tenant" */
export type Tenant_Obj_Rel_Insert_Input = {
  data: Tenant_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Tenant_On_Conflict>;
};

/** on_conflict condition type for table "tenant" */
export type Tenant_On_Conflict = {
  constraint: Tenant_Constraint;
  update_columns?: Array<Tenant_Update_Column>;
  where?: Maybe<Tenant_Bool_Exp>;
};

/** Ordering options when selecting data from "tenant". */
export type Tenant_Order_By = {
  active?: Maybe<Order_By>;
  active_status_reason?: Maybe<Order_By>;
  alias?: Maybe<Order_By>;
  central_cloud?: Maybe<Central_Cloud_Order_By>;
  cloud?: Maybe<Order_By>;
  cloudflare_proxy_enabled?: Maybe<Order_By>;
  config?: Maybe<Config_Order_By>;
  created_at?: Maybe<Order_By>;
  custom_domains_aggregate?: Maybe<Custom_Domain_Aggregate_Order_By>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Order_By>;
  dedicated_vpc_id?: Maybe<Order_By>;
  fqdn?: Maybe<Order_By>;
  health_status?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  maintenance_mode?: Maybe<Order_By>;
  major_version?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  region?: Maybe<Order_By>;
  region_info?: Maybe<Region_Order_By>;
  slug?: Maybe<Order_By>;
  status_aggregate?: Maybe<Tenant_Status_Aggregate_Order_By>;
  tenant_group_members_aggregate?: Maybe<Tenant_Group_Member_Aggregate_Order_By>;
  tenant_public_status_aggregate?: Maybe<Tenant_Public_Status_Aggregate_Order_By>;
  updated_at?: Maybe<Order_By>;
  workers_aggregate?: Maybe<Hasura_Worker_Tenants_Aggregate_Order_By>;
};

/** primary key columns input for table: tenant */
export type Tenant_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** Tenant status used for public health check */
export type Tenant_Public_Status = {
  __typename?: 'tenant_public_status';
  endpoint: Scalars['String'];
  is_active: Scalars['Boolean'];
  message?: Maybe<Scalars['String']>;
  /** An object relationship */
  tenant: Tenant;
  tenant_id: Scalars['uuid'];
  type: Scalars['String'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "tenant_public_status" */
export type Tenant_Public_Status_Aggregate = {
  __typename?: 'tenant_public_status_aggregate';
  aggregate?: Maybe<Tenant_Public_Status_Aggregate_Fields>;
  nodes: Array<Tenant_Public_Status>;
};

export type Tenant_Public_Status_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Tenant_Public_Status_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Tenant_Public_Status_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Tenant_Public_Status_Aggregate_Bool_Exp_Count>;
};

export type Tenant_Public_Status_Aggregate_Bool_Exp_Bool_And = {
  arguments: Tenant_Public_Status_Select_Column_Tenant_Public_Status_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Public_Status_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Tenant_Public_Status_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Tenant_Public_Status_Select_Column_Tenant_Public_Status_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Public_Status_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Tenant_Public_Status_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Tenant_Public_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Public_Status_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "tenant_public_status" */
export type Tenant_Public_Status_Aggregate_Fields = {
  __typename?: 'tenant_public_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Tenant_Public_Status_Max_Fields>;
  min?: Maybe<Tenant_Public_Status_Min_Fields>;
};

/** aggregate fields of "tenant_public_status" */
export type Tenant_Public_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Tenant_Public_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "tenant_public_status" */
export type Tenant_Public_Status_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Tenant_Public_Status_Max_Order_By>;
  min?: Maybe<Tenant_Public_Status_Min_Order_By>;
};

/** input type for inserting array relation for remote table "tenant_public_status" */
export type Tenant_Public_Status_Arr_Rel_Insert_Input = {
  data: Array<Tenant_Public_Status_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Tenant_Public_Status_On_Conflict>;
};

/** Boolean expression to filter rows from the table "tenant_public_status". All fields are combined with a logical 'AND'. */
export type Tenant_Public_Status_Bool_Exp = {
  _and?: Maybe<Array<Tenant_Public_Status_Bool_Exp>>;
  _not?: Maybe<Tenant_Public_Status_Bool_Exp>;
  _or?: Maybe<Array<Tenant_Public_Status_Bool_Exp>>;
  endpoint?: Maybe<String_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  message?: Maybe<String_Comparison_Exp>;
  tenant?: Maybe<Tenant_Bool_Exp>;
  tenant_id?: Maybe<Uuid_Comparison_Exp>;
  type?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "tenant_public_status" */
export enum Tenant_Public_Status_Constraint {
  /** unique or primary key constraint on columns "tenant_id", "endpoint" */
  TenantPublicStatusPkey = 'tenant_public_status_pkey',
}

/** input type for inserting data into table "tenant_public_status" */
export type Tenant_Public_Status_Insert_Input = {
  endpoint?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  tenant?: Maybe<Tenant_Obj_Rel_Insert_Input>;
  tenant_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Tenant_Public_Status_Max_Fields = {
  __typename?: 'tenant_public_status_max_fields';
  endpoint?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "tenant_public_status" */
export type Tenant_Public_Status_Max_Order_By = {
  endpoint?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Tenant_Public_Status_Min_Fields = {
  __typename?: 'tenant_public_status_min_fields';
  endpoint?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "tenant_public_status" */
export type Tenant_Public_Status_Min_Order_By = {
  endpoint?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "tenant_public_status" */
export type Tenant_Public_Status_Mutation_Response = {
  __typename?: 'tenant_public_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Tenant_Public_Status>;
};

/** on_conflict condition type for table "tenant_public_status" */
export type Tenant_Public_Status_On_Conflict = {
  constraint: Tenant_Public_Status_Constraint;
  update_columns?: Array<Tenant_Public_Status_Update_Column>;
  where?: Maybe<Tenant_Public_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "tenant_public_status". */
export type Tenant_Public_Status_Order_By = {
  endpoint?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  tenant?: Maybe<Tenant_Order_By>;
  tenant_id?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: tenant_public_status */
export type Tenant_Public_Status_Pk_Columns_Input = {
  endpoint: Scalars['String'];
  tenant_id: Scalars['uuid'];
};

/** select columns of table "tenant_public_status" */
export enum Tenant_Public_Status_Select_Column {
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Message = 'message',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** select "tenant_public_status_aggregate_bool_exp_bool_and_arguments_columns" columns of table "tenant_public_status" */
export enum Tenant_Public_Status_Select_Column_Tenant_Public_Status_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsActive = 'is_active',
}

/** select "tenant_public_status_aggregate_bool_exp_bool_or_arguments_columns" columns of table "tenant_public_status" */
export enum Tenant_Public_Status_Select_Column_Tenant_Public_Status_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsActive = 'is_active',
}

/** input type for updating data in table "tenant_public_status" */
export type Tenant_Public_Status_Set_Input = {
  endpoint?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "tenant_public_status" */
export type Tenant_Public_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tenant_Public_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tenant_Public_Status_Stream_Cursor_Value_Input = {
  endpoint?: Maybe<Scalars['String']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  type?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "tenant_public_status" */
export enum Tenant_Public_Status_Update_Column {
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Message = 'message',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Tenant_Public_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Tenant_Public_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tenant_Public_Status_Bool_Exp;
};

/** select columns of table "tenant" */
export enum Tenant_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  ActiveStatusReason = 'active_status_reason',
  /** column name */
  Alias = 'alias',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CloudflareProxyEnabled = 'cloudflare_proxy_enabled',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DedicatedVpcId = 'dedicated_vpc_id',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  MaintenanceMode = 'maintenance_mode',
  /** column name */
  MajorVersion = 'major_version',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** select "tenant_aggregate_bool_exp_bool_and_arguments_columns" columns of table "tenant" */
export enum Tenant_Select_Column_Tenant_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  Active = 'active',
  /** column name */
  CloudflareProxyEnabled = 'cloudflare_proxy_enabled',
  /** column name */
  MaintenanceMode = 'maintenance_mode',
}

/** select "tenant_aggregate_bool_exp_bool_or_arguments_columns" columns of table "tenant" */
export enum Tenant_Select_Column_Tenant_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  Active = 'active',
  /** column name */
  CloudflareProxyEnabled = 'cloudflare_proxy_enabled',
  /** column name */
  MaintenanceMode = 'maintenance_mode',
}

/** input type for updating data in table "tenant" */
export type Tenant_Set_Input = {
  active?: Maybe<Scalars['Boolean']>;
  active_status_reason?: Maybe<Scalars['String']>;
  alias?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cloudflare_proxy_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  maintenance_mode?: Maybe<Scalars['Boolean']>;
  major_version?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Tenant status used for internal health check */
export type Tenant_Status = {
  __typename?: 'tenant_status';
  has_inconsistent_metadata?: Maybe<Scalars['Boolean']>;
  is_active: Scalars['Boolean'];
  message?: Maybe<Scalars['String']>;
  /** An object relationship */
  tenant: Tenant;
  tenant_id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
  worker_id: Scalars['uuid'];
};

/** aggregated selection of "tenant_status" */
export type Tenant_Status_Aggregate = {
  __typename?: 'tenant_status_aggregate';
  aggregate?: Maybe<Tenant_Status_Aggregate_Fields>;
  nodes: Array<Tenant_Status>;
};

export type Tenant_Status_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Tenant_Status_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Tenant_Status_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Tenant_Status_Aggregate_Bool_Exp_Count>;
};

export type Tenant_Status_Aggregate_Bool_Exp_Bool_And = {
  arguments: Tenant_Status_Select_Column_Tenant_Status_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Status_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Tenant_Status_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Tenant_Status_Select_Column_Tenant_Status_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Status_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Tenant_Status_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Tenant_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Tenant_Status_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "tenant_status" */
export type Tenant_Status_Aggregate_Fields = {
  __typename?: 'tenant_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Tenant_Status_Max_Fields>;
  min?: Maybe<Tenant_Status_Min_Fields>;
};

/** aggregate fields of "tenant_status" */
export type Tenant_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Tenant_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "tenant_status" */
export type Tenant_Status_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Tenant_Status_Max_Order_By>;
  min?: Maybe<Tenant_Status_Min_Order_By>;
};

/** input type for inserting array relation for remote table "tenant_status" */
export type Tenant_Status_Arr_Rel_Insert_Input = {
  data: Array<Tenant_Status_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Tenant_Status_On_Conflict>;
};

/** Boolean expression to filter rows from the table "tenant_status". All fields are combined with a logical 'AND'. */
export type Tenant_Status_Bool_Exp = {
  _and?: Maybe<Array<Tenant_Status_Bool_Exp>>;
  _not?: Maybe<Tenant_Status_Bool_Exp>;
  _or?: Maybe<Array<Tenant_Status_Bool_Exp>>;
  has_inconsistent_metadata?: Maybe<Boolean_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  message?: Maybe<String_Comparison_Exp>;
  tenant?: Maybe<Tenant_Bool_Exp>;
  tenant_id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  worker_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "tenant_status" */
export enum Tenant_Status_Constraint {
  /** unique or primary key constraint on columns "tenant_id", "worker_id" */
  TenantStatusPkey = 'tenant_status_pkey',
}

/** input type for inserting data into table "tenant_status" */
export type Tenant_Status_Insert_Input = {
  has_inconsistent_metadata?: Maybe<Scalars['Boolean']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  tenant?: Maybe<Tenant_Obj_Rel_Insert_Input>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Tenant_Status_Max_Fields = {
  __typename?: 'tenant_status_max_fields';
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "tenant_status" */
export type Tenant_Status_Max_Order_By = {
  message?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Tenant_Status_Min_Fields = {
  __typename?: 'tenant_status_min_fields';
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "tenant_status" */
export type Tenant_Status_Min_Order_By = {
  message?: Maybe<Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "tenant_status" */
export type Tenant_Status_Mutation_Response = {
  __typename?: 'tenant_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Tenant_Status>;
};

/** on_conflict condition type for table "tenant_status" */
export type Tenant_Status_On_Conflict = {
  constraint: Tenant_Status_Constraint;
  update_columns?: Array<Tenant_Status_Update_Column>;
  where?: Maybe<Tenant_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "tenant_status". */
export type Tenant_Status_Order_By = {
  has_inconsistent_metadata?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  tenant?: Maybe<Tenant_Order_By>;
  tenant_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  worker_id?: Maybe<Order_By>;
};

/** primary key columns input for table: tenant_status */
export type Tenant_Status_Pk_Columns_Input = {
  tenant_id: Scalars['uuid'];
  worker_id: Scalars['uuid'];
};

/** select columns of table "tenant_status" */
export enum Tenant_Status_Select_Column {
  /** column name */
  HasInconsistentMetadata = 'has_inconsistent_metadata',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Message = 'message',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WorkerId = 'worker_id',
}

/** select "tenant_status_aggregate_bool_exp_bool_and_arguments_columns" columns of table "tenant_status" */
export enum Tenant_Status_Select_Column_Tenant_Status_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  HasInconsistentMetadata = 'has_inconsistent_metadata',
  /** column name */
  IsActive = 'is_active',
}

/** select "tenant_status_aggregate_bool_exp_bool_or_arguments_columns" columns of table "tenant_status" */
export enum Tenant_Status_Select_Column_Tenant_Status_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  HasInconsistentMetadata = 'has_inconsistent_metadata',
  /** column name */
  IsActive = 'is_active',
}

/** input type for updating data in table "tenant_status" */
export type Tenant_Status_Set_Input = {
  has_inconsistent_metadata?: Maybe<Scalars['Boolean']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "tenant_status" */
export type Tenant_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tenant_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tenant_Status_Stream_Cursor_Value_Input = {
  has_inconsistent_metadata?: Maybe<Scalars['Boolean']>;
  is_active?: Maybe<Scalars['Boolean']>;
  message?: Maybe<Scalars['String']>;
  tenant_id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  worker_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "tenant_status" */
export enum Tenant_Status_Update_Column {
  /** column name */
  HasInconsistentMetadata = 'has_inconsistent_metadata',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  Message = 'message',
  /** column name */
  TenantId = 'tenant_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WorkerId = 'worker_id',
}

export type Tenant_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Tenant_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tenant_Status_Bool_Exp;
};

/** aggregate stddev on columns */
export type Tenant_Stddev_Fields = {
  __typename?: 'tenant_stddev_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "tenant" */
export type Tenant_Stddev_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Tenant_Stddev_Pop_Fields = {
  __typename?: 'tenant_stddev_pop_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "tenant" */
export type Tenant_Stddev_Pop_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Tenant_Stddev_Samp_Fields = {
  __typename?: 'tenant_stddev_samp_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "tenant" */
export type Tenant_Stddev_Samp_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** Streaming cursor of the table "tenant" */
export type Tenant_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tenant_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tenant_Stream_Cursor_Value_Input = {
  active?: Maybe<Scalars['Boolean']>;
  active_status_reason?: Maybe<Scalars['String']>;
  alias?: Maybe<Scalars['String']>;
  cloud?: Maybe<Scalars['String']>;
  cloudflare_proxy_enabled?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  fqdn?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  maintenance_mode?: Maybe<Scalars['Boolean']>;
  major_version?: Maybe<Scalars['Int']>;
  project_id?: Maybe<Scalars['uuid']>;
  region?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type Tenant_Sum_Fields = {
  __typename?: 'tenant_sum_fields';
  major_version?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "tenant" */
export type Tenant_Sum_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** update columns of table "tenant" */
export enum Tenant_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  ActiveStatusReason = 'active_status_reason',
  /** column name */
  Alias = 'alias',
  /** column name */
  Cloud = 'cloud',
  /** column name */
  CloudflareProxyEnabled = 'cloudflare_proxy_enabled',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DedicatedVpcId = 'dedicated_vpc_id',
  /** column name */
  Fqdn = 'fqdn',
  /** column name */
  Id = 'id',
  /** column name */
  MaintenanceMode = 'maintenance_mode',
  /** column name */
  MajorVersion = 'major_version',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Region = 'region',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Tenant_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Tenant_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Tenant_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tenant_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Tenant_Var_Pop_Fields = {
  __typename?: 'tenant_var_pop_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "tenant" */
export type Tenant_Var_Pop_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Tenant_Var_Samp_Fields = {
  __typename?: 'tenant_var_samp_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "tenant" */
export type Tenant_Var_Samp_Order_By = {
  major_version?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Tenant_Variance_Fields = {
  __typename?: 'tenant_variance_fields';
  major_version?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "tenant" */
export type Tenant_Variance_Order_By = {
  major_version?: Maybe<Order_By>;
};

export type TenantDeleteResponse = {
  __typename?: 'TenantDeleteResponse';
  status: Scalars['String'];
};

export type TenantEnv = {
  __typename?: 'TenantEnv';
  envVars: Scalars['jsonb'];
  hash: Scalars['String'];
};

export type TenantEnvConfigInfo = {
  __typename?: 'TenantEnvConfigInfo';
  hash: Scalars['String'];
  isAdminSecretSet: Scalars['Boolean'];
  isMetadataAPIEnabled: Scalars['Boolean'];
  userRole: Scalars['String'];
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq?: Maybe<Scalars['timestamp']>;
  _gt?: Maybe<Scalars['timestamp']>;
  _gte?: Maybe<Scalars['timestamp']>;
  _in?: Maybe<Array<Scalars['timestamp']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['timestamp']>;
  _lte?: Maybe<Scalars['timestamp']>;
  _neq?: Maybe<Scalars['timestamp']>;
  _nin?: Maybe<Array<Scalars['timestamp']>>;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: Maybe<Scalars['timestamptz']>;
  _gt?: Maybe<Scalars['timestamptz']>;
  _gte?: Maybe<Scalars['timestamptz']>;
  _in?: Maybe<Array<Scalars['timestamptz']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['timestamptz']>;
  _lte?: Maybe<Scalars['timestamptz']>;
  _neq?: Maybe<Scalars['timestamptz']>;
  _nin?: Maybe<Array<Scalars['timestamptz']>>;
};

/** Boolean expression to compare columns of type "timetz". All fields are combined with logical 'AND'. */
export type Timetz_Comparison_Exp = {
  _eq?: Maybe<Scalars['timetz']>;
  _gt?: Maybe<Scalars['timetz']>;
  _gte?: Maybe<Scalars['timetz']>;
  _in?: Maybe<Array<Scalars['timetz']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['timetz']>;
  _lte?: Maybe<Scalars['timetz']>;
  _neq?: Maybe<Scalars['timetz']>;
  _nin?: Maybe<Array<Scalars['timetz']>>;
};

export type TrackOnboardingSampleDbCohortActivityResponse = {
  __typename?: 'TrackOnboardingSampleDbCohortActivityResponse';
  status: Scalars['String'];
};

export type TransferOwnershipRequest = {
  invitee_email: Scalars['String'];
  project_id: Scalars['uuid'];
};

/** columns and relationships of "trial_leads" */
export type Trial_Leads = {
  __typename?: 'trial_leads';
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at: Scalars['timestamptz'];
  email: Scalars['String'];
  email_verified?: Maybe<Scalars['Boolean']>;
  first?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  job_function?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['String']>;
  organization?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "trial_leads" */
export type Trial_LeadsAdditional_InfoArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "trial_leads" */
export type Trial_Leads_Aggregate = {
  __typename?: 'trial_leads_aggregate';
  aggregate?: Maybe<Trial_Leads_Aggregate_Fields>;
  nodes: Array<Trial_Leads>;
};

/** aggregate fields of "trial_leads" */
export type Trial_Leads_Aggregate_Fields = {
  __typename?: 'trial_leads_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Trial_Leads_Max_Fields>;
  min?: Maybe<Trial_Leads_Min_Fields>;
};

/** aggregate fields of "trial_leads" */
export type Trial_Leads_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Trial_Leads_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Trial_Leads_Append_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "trial_leads". All fields are combined with a logical 'AND'. */
export type Trial_Leads_Bool_Exp = {
  _and?: Maybe<Array<Trial_Leads_Bool_Exp>>;
  _not?: Maybe<Trial_Leads_Bool_Exp>;
  _or?: Maybe<Array<Trial_Leads_Bool_Exp>>;
  additional_info?: Maybe<Jsonb_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  email_verified?: Maybe<Boolean_Comparison_Exp>;
  first?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  job_function?: Maybe<String_Comparison_Exp>;
  last?: Maybe<String_Comparison_Exp>;
  organization?: Maybe<String_Comparison_Exp>;
  phone?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "trial_leads" */
export enum Trial_Leads_Constraint {
  /** unique or primary key constraint on columns "id" */
  TrialLeadsPkey = 'trial_leads_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Trial_Leads_Delete_At_Path_Input = {
  additional_info?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Trial_Leads_Delete_Elem_Input = {
  additional_info?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Trial_Leads_Delete_Key_Input = {
  additional_info?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "trial_leads" */
export type Trial_Leads_Insert_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  email_verified?: Maybe<Scalars['Boolean']>;
  first?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  job_function?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['String']>;
  organization?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Trial_Leads_Max_Fields = {
  __typename?: 'trial_leads_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  job_function?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['String']>;
  organization?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Trial_Leads_Min_Fields = {
  __typename?: 'trial_leads_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  first?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  job_function?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['String']>;
  organization?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "trial_leads" */
export type Trial_Leads_Mutation_Response = {
  __typename?: 'trial_leads_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Trial_Leads>;
};

/** on_conflict condition type for table "trial_leads" */
export type Trial_Leads_On_Conflict = {
  constraint: Trial_Leads_Constraint;
  update_columns?: Array<Trial_Leads_Update_Column>;
  where?: Maybe<Trial_Leads_Bool_Exp>;
};

/** Ordering options when selecting data from "trial_leads". */
export type Trial_Leads_Order_By = {
  additional_info?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  email_verified?: Maybe<Order_By>;
  first?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  job_function?: Maybe<Order_By>;
  last?: Maybe<Order_By>;
  organization?: Maybe<Order_By>;
  phone?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: trial_leads */
export type Trial_Leads_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Trial_Leads_Prepend_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "trial_leads" */
export enum Trial_Leads_Select_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  EmailVerified = 'email_verified',
  /** column name */
  First = 'first',
  /** column name */
  Id = 'id',
  /** column name */
  JobFunction = 'job_function',
  /** column name */
  Last = 'last',
  /** column name */
  Organization = 'organization',
  /** column name */
  Phone = 'phone',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "trial_leads" */
export type Trial_Leads_Set_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  email_verified?: Maybe<Scalars['Boolean']>;
  first?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  job_function?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['String']>;
  organization?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "trial_leads" */
export type Trial_Leads_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Trial_Leads_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Trial_Leads_Stream_Cursor_Value_Input = {
  additional_info?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  email?: Maybe<Scalars['String']>;
  email_verified?: Maybe<Scalars['Boolean']>;
  first?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  job_function?: Maybe<Scalars['String']>;
  last?: Maybe<Scalars['String']>;
  organization?: Maybe<Scalars['String']>;
  phone?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "trial_leads" */
export enum Trial_Leads_Update_Column {
  /** column name */
  AdditionalInfo = 'additional_info',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  EmailVerified = 'email_verified',
  /** column name */
  First = 'first',
  /** column name */
  Id = 'id',
  /** column name */
  JobFunction = 'job_function',
  /** column name */
  Last = 'last',
  /** column name */
  Organization = 'organization',
  /** column name */
  Phone = 'phone',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Trial_Leads_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Trial_Leads_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Trial_Leads_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Trial_Leads_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Trial_Leads_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Trial_Leads_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Trial_Leads_Set_Input>;
  /** filter the rows which have to be updated */
  where: Trial_Leads_Bool_Exp;
};

/** Stores all user assumption session audit logs. */
export type Ua_Audit_Logs = {
  __typename?: 'ua_audit_logs';
  action: Scalars['String'];
  actor_email: Scalars['String'];
  created_at: Scalars['timestamptz'];
  customer_email: Scalars['String'];
  id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "ua_audit_logs" */
export type Ua_Audit_Logs_Aggregate = {
  __typename?: 'ua_audit_logs_aggregate';
  aggregate?: Maybe<Ua_Audit_Logs_Aggregate_Fields>;
  nodes: Array<Ua_Audit_Logs>;
};

/** aggregate fields of "ua_audit_logs" */
export type Ua_Audit_Logs_Aggregate_Fields = {
  __typename?: 'ua_audit_logs_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Ua_Audit_Logs_Max_Fields>;
  min?: Maybe<Ua_Audit_Logs_Min_Fields>;
};

/** aggregate fields of "ua_audit_logs" */
export type Ua_Audit_Logs_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Ua_Audit_Logs_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "ua_audit_logs". All fields are combined with a logical 'AND'. */
export type Ua_Audit_Logs_Bool_Exp = {
  _and?: Maybe<Array<Ua_Audit_Logs_Bool_Exp>>;
  _not?: Maybe<Ua_Audit_Logs_Bool_Exp>;
  _or?: Maybe<Array<Ua_Audit_Logs_Bool_Exp>>;
  action?: Maybe<String_Comparison_Exp>;
  actor_email?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customer_email?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "ua_audit_logs" */
export enum Ua_Audit_Logs_Constraint {
  /** unique or primary key constraint on columns "id" */
  UaAuditLogsPkey = 'ua_audit_logs_pkey',
}

/** input type for inserting data into table "ua_audit_logs" */
export type Ua_Audit_Logs_Insert_Input = {
  action?: Maybe<Scalars['String']>;
  actor_email?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Ua_Audit_Logs_Max_Fields = {
  __typename?: 'ua_audit_logs_max_fields';
  action?: Maybe<Scalars['String']>;
  actor_email?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Ua_Audit_Logs_Min_Fields = {
  __typename?: 'ua_audit_logs_min_fields';
  action?: Maybe<Scalars['String']>;
  actor_email?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "ua_audit_logs" */
export type Ua_Audit_Logs_Mutation_Response = {
  __typename?: 'ua_audit_logs_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ua_Audit_Logs>;
};

/** on_conflict condition type for table "ua_audit_logs" */
export type Ua_Audit_Logs_On_Conflict = {
  constraint: Ua_Audit_Logs_Constraint;
  update_columns?: Array<Ua_Audit_Logs_Update_Column>;
  where?: Maybe<Ua_Audit_Logs_Bool_Exp>;
};

/** Ordering options when selecting data from "ua_audit_logs". */
export type Ua_Audit_Logs_Order_By = {
  action?: Maybe<Order_By>;
  actor_email?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer_email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: ua_audit_logs */
export type Ua_Audit_Logs_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "ua_audit_logs" */
export enum Ua_Audit_Logs_Select_Column {
  /** column name */
  Action = 'action',
  /** column name */
  ActorEmail = 'actor_email',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerEmail = 'customer_email',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "ua_audit_logs" */
export type Ua_Audit_Logs_Set_Input = {
  action?: Maybe<Scalars['String']>;
  actor_email?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "ua_audit_logs" */
export type Ua_Audit_Logs_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Ua_Audit_Logs_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Ua_Audit_Logs_Stream_Cursor_Value_Input = {
  action?: Maybe<Scalars['String']>;
  actor_email?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ua_audit_logs" */
export enum Ua_Audit_Logs_Update_Column {
  /** column name */
  Action = 'action',
  /** column name */
  ActorEmail = 'actor_email',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerEmail = 'customer_email',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Ua_Audit_Logs_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Ua_Audit_Logs_Set_Input>;
  /** filter the rows which have to be updated */
  where: Ua_Audit_Logs_Bool_Exp;
};

export type UpdateBillingManagerResponse = {
  __typename?: 'UpdateBillingManagerResponse';
  status: Scalars['String'];
};

export type UpdateEnvObject = {
  key: Scalars['String'];
  value: Scalars['String'];
};

export type UpdateEnvsObject = {
  key: Scalars['String'];
  value: Scalars['String'];
};

export type UpdateGithubIntegrationInput = {
  branch: Scalars['String'];
  directory?: Maybe<Scalars['String']>;
  email_status: Scalars['String'];
  installation_id: Scalars['Int'];
  integration_id: Scalars['String'];
  mode?: Maybe<ModeEnum>;
  org: Scalars['String'];
  repo: Scalars['String'];
};

export type UpdateGithubIntegrationStatus = {
  __typename?: 'UpdateGithubIntegrationStatus';
  status: Scalars['String'];
};

export type UpdateServerEndpointInput = {
  endpoint: Scalars['String'];
  id: Scalars['uuid'];
};

export type UpdateServerEndpointResponse = {
  __typename?: 'UpdateServerEndpointResponse';
  console_oauth_id: Scalars['String'];
  created_at: Scalars['String'];
  endpoint: Scalars['String'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  owner_id: Scalars['uuid'];
  server_oauth_id: Scalars['String'];
};

export type UpdateTenantNameResponse = {
  __typename?: 'UpdateTenantNameResponse';
  tenant?: Maybe<Tenant>;
  tenant_id: Scalars['uuid'];
};

export type UpdateTenantStatusInputPayload = {
  active: Scalars['Boolean'];
  active_status_reason?: Maybe<Scalars['String']>;
  ids?: Maybe<Array<Maybe<Scalars['uuid']>>>;
  project_ids?: Maybe<Array<Maybe<Scalars['uuid']>>>;
};

export type UpdateTenantStatusResponse = {
  __typename?: 'UpdateTenantStatusResponse';
  affected_rows: Scalars['Int'];
};

/** Boolean expression to compare columns of type "user_action". All fields are combined with logical 'AND'. */
export type User_Action_Comparison_Exp = {
  _eq?: Maybe<Scalars['user_action']>;
  _gt?: Maybe<Scalars['user_action']>;
  _gte?: Maybe<Scalars['user_action']>;
  _in?: Maybe<Array<Scalars['user_action']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['user_action']>;
  _lte?: Maybe<Scalars['user_action']>;
  _neq?: Maybe<Scalars['user_action']>;
  _nin?: Maybe<Array<Scalars['user_action']>>;
};

/** Captures user activity */
export type User_Activity = {
  __typename?: 'user_activity';
  action: Scalars['user_action'];
  id: Scalars['uuid'];
  ip: Scalars['String'];
  metadata?: Maybe<Scalars['jsonb']>;
  timestamp: Scalars['timestamptz'];
  user_id: Scalars['uuid'];
};

/** Captures user activity */
export type User_ActivityMetadataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "user_activity" */
export type User_Activity_Aggregate = {
  __typename?: 'user_activity_aggregate';
  aggregate?: Maybe<User_Activity_Aggregate_Fields>;
  nodes: Array<User_Activity>;
};

/** aggregate fields of "user_activity" */
export type User_Activity_Aggregate_Fields = {
  __typename?: 'user_activity_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<User_Activity_Max_Fields>;
  min?: Maybe<User_Activity_Min_Fields>;
};

/** aggregate fields of "user_activity" */
export type User_Activity_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Activity_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type User_Activity_Append_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "user_activity". All fields are combined with a logical 'AND'. */
export type User_Activity_Bool_Exp = {
  _and?: Maybe<Array<User_Activity_Bool_Exp>>;
  _not?: Maybe<User_Activity_Bool_Exp>;
  _or?: Maybe<Array<User_Activity_Bool_Exp>>;
  action?: Maybe<User_Action_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  ip?: Maybe<String_Comparison_Exp>;
  metadata?: Maybe<Jsonb_Comparison_Exp>;
  timestamp?: Maybe<Timestamptz_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_activity" */
export enum User_Activity_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserActivityPkey = 'user_activity_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type User_Activity_Delete_At_Path_Input = {
  metadata?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type User_Activity_Delete_Elem_Input = {
  metadata?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type User_Activity_Delete_Key_Input = {
  metadata?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "user_activity" */
export type User_Activity_Insert_Input = {
  action?: Maybe<Scalars['user_action']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  metadata?: Maybe<Scalars['jsonb']>;
  timestamp?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type User_Activity_Max_Fields = {
  __typename?: 'user_activity_max_fields';
  action?: Maybe<Scalars['user_action']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type User_Activity_Min_Fields = {
  __typename?: 'user_activity_min_fields';
  action?: Maybe<Scalars['user_action']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  timestamp?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "user_activity" */
export type User_Activity_Mutation_Response = {
  __typename?: 'user_activity_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Activity>;
};

/** on_conflict condition type for table "user_activity" */
export type User_Activity_On_Conflict = {
  constraint: User_Activity_Constraint;
  update_columns?: Array<User_Activity_Update_Column>;
  where?: Maybe<User_Activity_Bool_Exp>;
};

/** Ordering options when selecting data from "user_activity". */
export type User_Activity_Order_By = {
  action?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  ip?: Maybe<Order_By>;
  metadata?: Maybe<Order_By>;
  timestamp?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: user_activity */
export type User_Activity_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type User_Activity_Prepend_Input = {
  metadata?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "user_activity" */
export enum User_Activity_Select_Column {
  /** column name */
  Action = 'action',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "user_activity" */
export type User_Activity_Set_Input = {
  action?: Maybe<Scalars['user_action']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  metadata?: Maybe<Scalars['jsonb']>;
  timestamp?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_activity" */
export type User_Activity_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Activity_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Activity_Stream_Cursor_Value_Input = {
  action?: Maybe<Scalars['user_action']>;
  id?: Maybe<Scalars['uuid']>;
  ip?: Maybe<Scalars['String']>;
  metadata?: Maybe<Scalars['jsonb']>;
  timestamp?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "user_activity" */
export enum User_Activity_Update_Column {
  /** column name */
  Action = 'action',
  /** column name */
  Id = 'id',
  /** column name */
  Ip = 'ip',
  /** column name */
  Metadata = 'metadata',
  /** column name */
  Timestamp = 'timestamp',
  /** column name */
  UserId = 'user_id',
}

export type User_Activity_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<User_Activity_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<User_Activity_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<User_Activity_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<User_Activity_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<User_Activity_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Activity_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Activity_Bool_Exp;
};

/** Coupon to get discount for a specific customer */
export type User_Coupon = {
  __typename?: 'user_coupon';
  amount_off: Scalars['Int'];
  /** An object relationship */
  coupon: Coupon;
  coupon_name: Scalars['String'];
  created_at: Scalars['timestamptz'];
  customer_id: Scalars['String'];
  id: Scalars['uuid'];
  is_applied: Scalars['Boolean'];
  percentage_off?: Maybe<Scalars['numeric']>;
  promotion_code: Scalars['citext'];
  /** An object relationship */
  user?: Maybe<Users>;
};

/** aggregated selection of "user_coupon" */
export type User_Coupon_Aggregate = {
  __typename?: 'user_coupon_aggregate';
  aggregate?: Maybe<User_Coupon_Aggregate_Fields>;
  nodes: Array<User_Coupon>;
};

export type User_Coupon_Aggregate_Bool_Exp = {
  bool_and?: Maybe<User_Coupon_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<User_Coupon_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<User_Coupon_Aggregate_Bool_Exp_Count>;
};

export type User_Coupon_Aggregate_Bool_Exp_Bool_And = {
  arguments: User_Coupon_Select_Column_User_Coupon_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Coupon_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type User_Coupon_Aggregate_Bool_Exp_Bool_Or = {
  arguments: User_Coupon_Select_Column_User_Coupon_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Coupon_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type User_Coupon_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<User_Coupon_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Coupon_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_coupon" */
export type User_Coupon_Aggregate_Fields = {
  __typename?: 'user_coupon_aggregate_fields';
  avg?: Maybe<User_Coupon_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<User_Coupon_Max_Fields>;
  min?: Maybe<User_Coupon_Min_Fields>;
  stddev?: Maybe<User_Coupon_Stddev_Fields>;
  stddev_pop?: Maybe<User_Coupon_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<User_Coupon_Stddev_Samp_Fields>;
  sum?: Maybe<User_Coupon_Sum_Fields>;
  var_pop?: Maybe<User_Coupon_Var_Pop_Fields>;
  var_samp?: Maybe<User_Coupon_Var_Samp_Fields>;
  variance?: Maybe<User_Coupon_Variance_Fields>;
};

/** aggregate fields of "user_coupon" */
export type User_Coupon_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Coupon_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_coupon" */
export type User_Coupon_Aggregate_Order_By = {
  avg?: Maybe<User_Coupon_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<User_Coupon_Max_Order_By>;
  min?: Maybe<User_Coupon_Min_Order_By>;
  stddev?: Maybe<User_Coupon_Stddev_Order_By>;
  stddev_pop?: Maybe<User_Coupon_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<User_Coupon_Stddev_Samp_Order_By>;
  sum?: Maybe<User_Coupon_Sum_Order_By>;
  var_pop?: Maybe<User_Coupon_Var_Pop_Order_By>;
  var_samp?: Maybe<User_Coupon_Var_Samp_Order_By>;
  variance?: Maybe<User_Coupon_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "user_coupon" */
export type User_Coupon_Arr_Rel_Insert_Input = {
  data: Array<User_Coupon_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<User_Coupon_On_Conflict>;
};

/** aggregate avg on columns */
export type User_Coupon_Avg_Fields = {
  __typename?: 'user_coupon_avg_fields';
  amount_off?: Maybe<Scalars['Float']>;
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "user_coupon" */
export type User_Coupon_Avg_Order_By = {
  amount_off?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "user_coupon". All fields are combined with a logical 'AND'. */
export type User_Coupon_Bool_Exp = {
  _and?: Maybe<Array<User_Coupon_Bool_Exp>>;
  _not?: Maybe<User_Coupon_Bool_Exp>;
  _or?: Maybe<Array<User_Coupon_Bool_Exp>>;
  amount_off?: Maybe<Int_Comparison_Exp>;
  coupon?: Maybe<Coupon_Bool_Exp>;
  coupon_name?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customer_id?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_applied?: Maybe<Boolean_Comparison_Exp>;
  percentage_off?: Maybe<Numeric_Comparison_Exp>;
  promotion_code?: Maybe<Citext_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
};

/** unique or primary key constraints on table "user_coupon" */
export enum User_Coupon_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserCouponPkey = 'user_coupon_pkey',
}

/** input type for incrementing numeric columns in table "user_coupon" */
export type User_Coupon_Inc_Input = {
  amount_off?: Maybe<Scalars['Int']>;
  percentage_off?: Maybe<Scalars['numeric']>;
};

/** input type for inserting data into table "user_coupon" */
export type User_Coupon_Insert_Input = {
  amount_off?: Maybe<Scalars['Int']>;
  coupon?: Maybe<Coupon_Obj_Rel_Insert_Input>;
  coupon_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_applied?: Maybe<Scalars['Boolean']>;
  percentage_off?: Maybe<Scalars['numeric']>;
  promotion_code?: Maybe<Scalars['citext']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type User_Coupon_Max_Fields = {
  __typename?: 'user_coupon_max_fields';
  amount_off?: Maybe<Scalars['Int']>;
  coupon_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  percentage_off?: Maybe<Scalars['numeric']>;
  promotion_code?: Maybe<Scalars['citext']>;
};

/** order by max() on columns of table "user_coupon" */
export type User_Coupon_Max_Order_By = {
  amount_off?: Maybe<Order_By>;
  coupon_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
  promotion_code?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type User_Coupon_Min_Fields = {
  __typename?: 'user_coupon_min_fields';
  amount_off?: Maybe<Scalars['Int']>;
  coupon_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  percentage_off?: Maybe<Scalars['numeric']>;
  promotion_code?: Maybe<Scalars['citext']>;
};

/** order by min() on columns of table "user_coupon" */
export type User_Coupon_Min_Order_By = {
  amount_off?: Maybe<Order_By>;
  coupon_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
  promotion_code?: Maybe<Order_By>;
};

/** response of any mutation on the table "user_coupon" */
export type User_Coupon_Mutation_Response = {
  __typename?: 'user_coupon_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Coupon>;
};

/** on_conflict condition type for table "user_coupon" */
export type User_Coupon_On_Conflict = {
  constraint: User_Coupon_Constraint;
  update_columns?: Array<User_Coupon_Update_Column>;
  where?: Maybe<User_Coupon_Bool_Exp>;
};

/** Ordering options when selecting data from "user_coupon". */
export type User_Coupon_Order_By = {
  amount_off?: Maybe<Order_By>;
  coupon?: Maybe<Coupon_Order_By>;
  coupon_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_applied?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
  promotion_code?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
};

/** primary key columns input for table: user_coupon */
export type User_Coupon_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "user_coupon" */
export enum User_Coupon_Select_Column {
  /** column name */
  AmountOff = 'amount_off',
  /** column name */
  CouponName = 'coupon_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  IsApplied = 'is_applied',
  /** column name */
  PercentageOff = 'percentage_off',
  /** column name */
  PromotionCode = 'promotion_code',
}

/** select "user_coupon_aggregate_bool_exp_bool_and_arguments_columns" columns of table "user_coupon" */
export enum User_Coupon_Select_Column_User_Coupon_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsApplied = 'is_applied',
}

/** select "user_coupon_aggregate_bool_exp_bool_or_arguments_columns" columns of table "user_coupon" */
export enum User_Coupon_Select_Column_User_Coupon_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsApplied = 'is_applied',
}

/** input type for updating data in table "user_coupon" */
export type User_Coupon_Set_Input = {
  amount_off?: Maybe<Scalars['Int']>;
  coupon_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_applied?: Maybe<Scalars['Boolean']>;
  percentage_off?: Maybe<Scalars['numeric']>;
  promotion_code?: Maybe<Scalars['citext']>;
};

/** aggregate stddev on columns */
export type User_Coupon_Stddev_Fields = {
  __typename?: 'user_coupon_stddev_fields';
  amount_off?: Maybe<Scalars['Float']>;
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "user_coupon" */
export type User_Coupon_Stddev_Order_By = {
  amount_off?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type User_Coupon_Stddev_Pop_Fields = {
  __typename?: 'user_coupon_stddev_pop_fields';
  amount_off?: Maybe<Scalars['Float']>;
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "user_coupon" */
export type User_Coupon_Stddev_Pop_Order_By = {
  amount_off?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type User_Coupon_Stddev_Samp_Fields = {
  __typename?: 'user_coupon_stddev_samp_fields';
  amount_off?: Maybe<Scalars['Float']>;
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "user_coupon" */
export type User_Coupon_Stddev_Samp_Order_By = {
  amount_off?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
};

/** Streaming cursor of the table "user_coupon" */
export type User_Coupon_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Coupon_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Coupon_Stream_Cursor_Value_Input = {
  amount_off?: Maybe<Scalars['Int']>;
  coupon_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_applied?: Maybe<Scalars['Boolean']>;
  percentage_off?: Maybe<Scalars['numeric']>;
  promotion_code?: Maybe<Scalars['citext']>;
};

/** aggregate sum on columns */
export type User_Coupon_Sum_Fields = {
  __typename?: 'user_coupon_sum_fields';
  amount_off?: Maybe<Scalars['Int']>;
  percentage_off?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "user_coupon" */
export type User_Coupon_Sum_Order_By = {
  amount_off?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
};

/** update columns of table "user_coupon" */
export enum User_Coupon_Update_Column {
  /** column name */
  AmountOff = 'amount_off',
  /** column name */
  CouponName = 'coupon_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Id = 'id',
  /** column name */
  IsApplied = 'is_applied',
  /** column name */
  PercentageOff = 'percentage_off',
  /** column name */
  PromotionCode = 'promotion_code',
}

export type User_Coupon_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<User_Coupon_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Coupon_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Coupon_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Coupon_Var_Pop_Fields = {
  __typename?: 'user_coupon_var_pop_fields';
  amount_off?: Maybe<Scalars['Float']>;
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "user_coupon" */
export type User_Coupon_Var_Pop_Order_By = {
  amount_off?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type User_Coupon_Var_Samp_Fields = {
  __typename?: 'user_coupon_var_samp_fields';
  amount_off?: Maybe<Scalars['Float']>;
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "user_coupon" */
export type User_Coupon_Var_Samp_Order_By = {
  amount_off?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type User_Coupon_Variance_Fields = {
  __typename?: 'user_coupon_variance_fields';
  amount_off?: Maybe<Scalars['Float']>;
  percentage_off?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "user_coupon" */
export type User_Coupon_Variance_Order_By = {
  amount_off?: Maybe<Order_By>;
  percentage_off?: Maybe<Order_By>;
};

/** Each entry in this table represents entitlements a user has access to. */
export type User_Entitlement_Access = {
  __typename?: 'user_entitlement_access';
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  entitlement: User_Entitlement_Catalogue;
  entitlement_id: Scalars['uuid'];
  id: Scalars['uuid'];
  updated_at: Scalars['timestamptz'];
  user_id: Scalars['uuid'];
};

/** aggregated selection of "user_entitlement_access" */
export type User_Entitlement_Access_Aggregate = {
  __typename?: 'user_entitlement_access_aggregate';
  aggregate?: Maybe<User_Entitlement_Access_Aggregate_Fields>;
  nodes: Array<User_Entitlement_Access>;
};

export type User_Entitlement_Access_Aggregate_Bool_Exp = {
  count?: Maybe<User_Entitlement_Access_Aggregate_Bool_Exp_Count>;
};

export type User_Entitlement_Access_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<User_Entitlement_Access_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Entitlement_Access_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_entitlement_access" */
export type User_Entitlement_Access_Aggregate_Fields = {
  __typename?: 'user_entitlement_access_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<User_Entitlement_Access_Max_Fields>;
  min?: Maybe<User_Entitlement_Access_Min_Fields>;
};

/** aggregate fields of "user_entitlement_access" */
export type User_Entitlement_Access_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Entitlement_Access_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_entitlement_access" */
export type User_Entitlement_Access_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<User_Entitlement_Access_Max_Order_By>;
  min?: Maybe<User_Entitlement_Access_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_entitlement_access" */
export type User_Entitlement_Access_Arr_Rel_Insert_Input = {
  data: Array<User_Entitlement_Access_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<User_Entitlement_Access_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_entitlement_access". All fields are combined with a logical 'AND'. */
export type User_Entitlement_Access_Bool_Exp = {
  _and?: Maybe<Array<User_Entitlement_Access_Bool_Exp>>;
  _not?: Maybe<User_Entitlement_Access_Bool_Exp>;
  _or?: Maybe<Array<User_Entitlement_Access_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  entitlement?: Maybe<User_Entitlement_Catalogue_Bool_Exp>;
  entitlement_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_entitlement_access" */
export enum User_Entitlement_Access_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserEntitlementAccessPkey = 'user_entitlement_access_pkey',
}

/** input type for inserting data into table "user_entitlement_access" */
export type User_Entitlement_Access_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  entitlement?: Maybe<User_Entitlement_Catalogue_Obj_Rel_Insert_Input>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type User_Entitlement_Access_Max_Fields = {
  __typename?: 'user_entitlement_access_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_entitlement_access" */
export type User_Entitlement_Access_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type User_Entitlement_Access_Min_Fields = {
  __typename?: 'user_entitlement_access_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_entitlement_access" */
export type User_Entitlement_Access_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "user_entitlement_access" */
export type User_Entitlement_Access_Mutation_Response = {
  __typename?: 'user_entitlement_access_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Entitlement_Access>;
};

/** input type for inserting object relation for remote table "user_entitlement_access" */
export type User_Entitlement_Access_Obj_Rel_Insert_Input = {
  data: User_Entitlement_Access_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<User_Entitlement_Access_On_Conflict>;
};

/** on_conflict condition type for table "user_entitlement_access" */
export type User_Entitlement_Access_On_Conflict = {
  constraint: User_Entitlement_Access_Constraint;
  update_columns?: Array<User_Entitlement_Access_Update_Column>;
  where?: Maybe<User_Entitlement_Access_Bool_Exp>;
};

/** Ordering options when selecting data from "user_entitlement_access". */
export type User_Entitlement_Access_Order_By = {
  created_at?: Maybe<Order_By>;
  entitlement?: Maybe<User_Entitlement_Catalogue_Order_By>;
  entitlement_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: user_entitlement_access */
export type User_Entitlement_Access_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "user_entitlement_access" */
export enum User_Entitlement_Access_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntitlementId = 'entitlement_id',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "user_entitlement_access" */
export type User_Entitlement_Access_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_entitlement_access" */
export type User_Entitlement_Access_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Entitlement_Access_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Entitlement_Access_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  entitlement_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "user_entitlement_access" */
export enum User_Entitlement_Access_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntitlementId = 'entitlement_id',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

export type User_Entitlement_Access_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Entitlement_Access_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Entitlement_Access_Bool_Exp;
};

/** Stores all versions of all types of user entitlements. */
export type User_Entitlement_Catalogue = {
  __typename?: 'user_entitlement_catalogue';
  config_is_enabled: Scalars['Boolean'];
  config_limit?: Maybe<Scalars['Int']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at: Scalars['timestamptz'];
  id: Scalars['uuid'];
  name: Scalars['String'];
  type: User_Entitlement_Types_Enum;
  updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "user_entitlement_catalogue" */
export type User_Entitlement_Catalogue_Aggregate = {
  __typename?: 'user_entitlement_catalogue_aggregate';
  aggregate?: Maybe<User_Entitlement_Catalogue_Aggregate_Fields>;
  nodes: Array<User_Entitlement_Catalogue>;
};

/** aggregate fields of "user_entitlement_catalogue" */
export type User_Entitlement_Catalogue_Aggregate_Fields = {
  __typename?: 'user_entitlement_catalogue_aggregate_fields';
  avg?: Maybe<User_Entitlement_Catalogue_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<User_Entitlement_Catalogue_Max_Fields>;
  min?: Maybe<User_Entitlement_Catalogue_Min_Fields>;
  stddev?: Maybe<User_Entitlement_Catalogue_Stddev_Fields>;
  stddev_pop?: Maybe<User_Entitlement_Catalogue_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<User_Entitlement_Catalogue_Stddev_Samp_Fields>;
  sum?: Maybe<User_Entitlement_Catalogue_Sum_Fields>;
  var_pop?: Maybe<User_Entitlement_Catalogue_Var_Pop_Fields>;
  var_samp?: Maybe<User_Entitlement_Catalogue_Var_Samp_Fields>;
  variance?: Maybe<User_Entitlement_Catalogue_Variance_Fields>;
};

/** aggregate fields of "user_entitlement_catalogue" */
export type User_Entitlement_Catalogue_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Entitlement_Catalogue_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type User_Entitlement_Catalogue_Avg_Fields = {
  __typename?: 'user_entitlement_catalogue_avg_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "user_entitlement_catalogue". All fields are combined with a logical 'AND'. */
export type User_Entitlement_Catalogue_Bool_Exp = {
  _and?: Maybe<Array<User_Entitlement_Catalogue_Bool_Exp>>;
  _not?: Maybe<User_Entitlement_Catalogue_Bool_Exp>;
  _or?: Maybe<Array<User_Entitlement_Catalogue_Bool_Exp>>;
  config_is_enabled?: Maybe<Boolean_Comparison_Exp>;
  config_limit?: Maybe<Int_Comparison_Exp>;
  cost?: Maybe<Bigint_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  type?: Maybe<User_Entitlement_Types_Enum_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_entitlement_catalogue" */
export enum User_Entitlement_Catalogue_Constraint {
  /** unique or primary key constraint on columns "name" */
  UserEntitlementCatalogueNameKey = 'user_entitlement_catalogue_name_key',
  /** unique or primary key constraint on columns "id" */
  UserEntitlementCataloguePkey = 'user_entitlement_catalogue_pkey',
}

/** input type for incrementing numeric columns in table "user_entitlement_catalogue" */
export type User_Entitlement_Catalogue_Inc_Input = {
  config_limit?: Maybe<Scalars['Int']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "user_entitlement_catalogue" */
export type User_Entitlement_Catalogue_Insert_Input = {
  config_is_enabled?: Maybe<Scalars['Boolean']>;
  config_limit?: Maybe<Scalars['Int']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<User_Entitlement_Types_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type User_Entitlement_Catalogue_Max_Fields = {
  __typename?: 'user_entitlement_catalogue_max_fields';
  config_limit?: Maybe<Scalars['Int']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type User_Entitlement_Catalogue_Min_Fields = {
  __typename?: 'user_entitlement_catalogue_min_fields';
  config_limit?: Maybe<Scalars['Int']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "user_entitlement_catalogue" */
export type User_Entitlement_Catalogue_Mutation_Response = {
  __typename?: 'user_entitlement_catalogue_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Entitlement_Catalogue>;
};

/** input type for inserting object relation for remote table "user_entitlement_catalogue" */
export type User_Entitlement_Catalogue_Obj_Rel_Insert_Input = {
  data: User_Entitlement_Catalogue_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<User_Entitlement_Catalogue_On_Conflict>;
};

/** on_conflict condition type for table "user_entitlement_catalogue" */
export type User_Entitlement_Catalogue_On_Conflict = {
  constraint: User_Entitlement_Catalogue_Constraint;
  update_columns?: Array<User_Entitlement_Catalogue_Update_Column>;
  where?: Maybe<User_Entitlement_Catalogue_Bool_Exp>;
};

/** Ordering options when selecting data from "user_entitlement_catalogue". */
export type User_Entitlement_Catalogue_Order_By = {
  config_is_enabled?: Maybe<Order_By>;
  config_limit?: Maybe<Order_By>;
  cost?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  type?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: user_entitlement_catalogue */
export type User_Entitlement_Catalogue_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "user_entitlement_catalogue" */
export enum User_Entitlement_Catalogue_Select_Column {
  /** column name */
  ConfigIsEnabled = 'config_is_enabled',
  /** column name */
  ConfigLimit = 'config_limit',
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** input type for updating data in table "user_entitlement_catalogue" */
export type User_Entitlement_Catalogue_Set_Input = {
  config_is_enabled?: Maybe<Scalars['Boolean']>;
  config_limit?: Maybe<Scalars['Int']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<User_Entitlement_Types_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type User_Entitlement_Catalogue_Stddev_Fields = {
  __typename?: 'user_entitlement_catalogue_stddev_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type User_Entitlement_Catalogue_Stddev_Pop_Fields = {
  __typename?: 'user_entitlement_catalogue_stddev_pop_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type User_Entitlement_Catalogue_Stddev_Samp_Fields = {
  __typename?: 'user_entitlement_catalogue_stddev_samp_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "user_entitlement_catalogue" */
export type User_Entitlement_Catalogue_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Entitlement_Catalogue_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Entitlement_Catalogue_Stream_Cursor_Value_Input = {
  config_is_enabled?: Maybe<Scalars['Boolean']>;
  config_limit?: Maybe<Scalars['Int']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  name?: Maybe<Scalars['String']>;
  type?: Maybe<User_Entitlement_Types_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate sum on columns */
export type User_Entitlement_Catalogue_Sum_Fields = {
  __typename?: 'user_entitlement_catalogue_sum_fields';
  config_limit?: Maybe<Scalars['Int']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['bigint']>;
};

/** update columns of table "user_entitlement_catalogue" */
export enum User_Entitlement_Catalogue_Update_Column {
  /** column name */
  ConfigIsEnabled = 'config_is_enabled',
  /** column name */
  ConfigLimit = 'config_limit',
  /** column name */
  Cost = 'cost',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type User_Entitlement_Catalogue_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<User_Entitlement_Catalogue_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Entitlement_Catalogue_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Entitlement_Catalogue_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Entitlement_Catalogue_Var_Pop_Fields = {
  __typename?: 'user_entitlement_catalogue_var_pop_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type User_Entitlement_Catalogue_Var_Samp_Fields = {
  __typename?: 'user_entitlement_catalogue_var_samp_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type User_Entitlement_Catalogue_Variance_Fields = {
  __typename?: 'user_entitlement_catalogue_variance_fields';
  config_limit?: Maybe<Scalars['Float']>;
  /** Cost of entitlement in microdollars */
  cost?: Maybe<Scalars['Float']>;
};

/** Enums to represent all types of entitlements a user can have. */
export type User_Entitlement_Types = {
  __typename?: 'user_entitlement_types';
  comment: Scalars['String'];
  value: Scalars['String'];
};

/** aggregated selection of "user_entitlement_types" */
export type User_Entitlement_Types_Aggregate = {
  __typename?: 'user_entitlement_types_aggregate';
  aggregate?: Maybe<User_Entitlement_Types_Aggregate_Fields>;
  nodes: Array<User_Entitlement_Types>;
};

/** aggregate fields of "user_entitlement_types" */
export type User_Entitlement_Types_Aggregate_Fields = {
  __typename?: 'user_entitlement_types_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<User_Entitlement_Types_Max_Fields>;
  min?: Maybe<User_Entitlement_Types_Min_Fields>;
};

/** aggregate fields of "user_entitlement_types" */
export type User_Entitlement_Types_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Entitlement_Types_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "user_entitlement_types". All fields are combined with a logical 'AND'. */
export type User_Entitlement_Types_Bool_Exp = {
  _and?: Maybe<Array<User_Entitlement_Types_Bool_Exp>>;
  _not?: Maybe<User_Entitlement_Types_Bool_Exp>;
  _or?: Maybe<Array<User_Entitlement_Types_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  value?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_entitlement_types" */
export enum User_Entitlement_Types_Constraint {
  /** unique or primary key constraint on columns "value" */
  UserEntitlementTypesPkey = 'user_entitlement_types_pkey',
}

export enum User_Entitlement_Types_Enum {
  /** Configure access to plan-wide dedicated_cloud features */
  DedicatedCloudAccess = 'dedicated_cloud_access',
  /** Access and unit cost correpsonding to data passthrough on the Dedicated Cloud Plan. */
  DedicatedCloudDataPassthrough = 'dedicated_cloud_data_passthrough',
  /** Access and unit cost correpsonding no database on the Dedicated Cloud Plan. */
  DedicatedCloudNoDb = 'dedicated_cloud_no_db',
  /** Access and unit cost correpsonding Non Postgres database on the Dedicated Cloud Plan. */
  DedicatedCloudNonPgDb = 'dedicated_cloud_non_pg_db',
  /** Access and unit cost correpsonding Postgres database on the Dedicated Cloud Plan. */
  DedicatedCloudPgDb = 'dedicated_cloud_pg_db',
  /** Configure access to user assumption related features */
  UserAssumptionAccess = 'user_assumption_access',
  /** Hard limit for the number of v3 projects a user can own */
  V3MaxProjectLimit = 'v3_max_project_limit',
  /** Hard limit for the number of v3 tunnels a user can own */
  V3MaxTunnelLimit = 'v3_max_tunnel_limit',
}

/** Boolean expression to compare columns of type "user_entitlement_types_enum". All fields are combined with logical 'AND'. */
export type User_Entitlement_Types_Enum_Comparison_Exp = {
  _eq?: Maybe<User_Entitlement_Types_Enum>;
  _in?: Maybe<Array<User_Entitlement_Types_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<User_Entitlement_Types_Enum>;
  _nin?: Maybe<Array<User_Entitlement_Types_Enum>>;
};

/** input type for inserting data into table "user_entitlement_types" */
export type User_Entitlement_Types_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type User_Entitlement_Types_Max_Fields = {
  __typename?: 'user_entitlement_types_max_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type User_Entitlement_Types_Min_Fields = {
  __typename?: 'user_entitlement_types_min_fields';
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "user_entitlement_types" */
export type User_Entitlement_Types_Mutation_Response = {
  __typename?: 'user_entitlement_types_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Entitlement_Types>;
};

/** on_conflict condition type for table "user_entitlement_types" */
export type User_Entitlement_Types_On_Conflict = {
  constraint: User_Entitlement_Types_Constraint;
  update_columns?: Array<User_Entitlement_Types_Update_Column>;
  where?: Maybe<User_Entitlement_Types_Bool_Exp>;
};

/** Ordering options when selecting data from "user_entitlement_types". */
export type User_Entitlement_Types_Order_By = {
  comment?: Maybe<Order_By>;
  value?: Maybe<Order_By>;
};

/** primary key columns input for table: user_entitlement_types */
export type User_Entitlement_Types_Pk_Columns_Input = {
  value: Scalars['String'];
};

/** select columns of table "user_entitlement_types" */
export enum User_Entitlement_Types_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value',
}

/** input type for updating data in table "user_entitlement_types" */
export type User_Entitlement_Types_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "user_entitlement_types" */
export type User_Entitlement_Types_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Entitlement_Types_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Entitlement_Types_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  value?: Maybe<Scalars['String']>;
};

/** update columns of table "user_entitlement_types" */
export enum User_Entitlement_Types_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Value = 'value',
}

export type User_Entitlement_Types_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Entitlement_Types_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Entitlement_Types_Bool_Exp;
};

/** Captures user onboarding details and progress */
export type User_Onboarding = {
  __typename?: 'user_onboarding';
  activity?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  details?: Maybe<Scalars['String']>;
  is_onboarded: Scalars['Boolean'];
  target: Scalars['String'];
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  user: Users;
  user_id: Scalars['uuid'];
};

/** Captures user onboarding details and progress */
export type User_OnboardingActivityArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "user_onboarding" */
export type User_Onboarding_Aggregate = {
  __typename?: 'user_onboarding_aggregate';
  aggregate?: Maybe<User_Onboarding_Aggregate_Fields>;
  nodes: Array<User_Onboarding>;
};

export type User_Onboarding_Aggregate_Bool_Exp = {
  bool_and?: Maybe<User_Onboarding_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<User_Onboarding_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<User_Onboarding_Aggregate_Bool_Exp_Count>;
};

export type User_Onboarding_Aggregate_Bool_Exp_Bool_And = {
  arguments: User_Onboarding_Select_Column_User_Onboarding_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Onboarding_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type User_Onboarding_Aggregate_Bool_Exp_Bool_Or = {
  arguments: User_Onboarding_Select_Column_User_Onboarding_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Onboarding_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type User_Onboarding_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<User_Onboarding_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Onboarding_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_onboarding" */
export type User_Onboarding_Aggregate_Fields = {
  __typename?: 'user_onboarding_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<User_Onboarding_Max_Fields>;
  min?: Maybe<User_Onboarding_Min_Fields>;
};

/** aggregate fields of "user_onboarding" */
export type User_Onboarding_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Onboarding_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_onboarding" */
export type User_Onboarding_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<User_Onboarding_Max_Order_By>;
  min?: Maybe<User_Onboarding_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type User_Onboarding_Append_Input = {
  activity?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "user_onboarding" */
export type User_Onboarding_Arr_Rel_Insert_Input = {
  data: Array<User_Onboarding_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<User_Onboarding_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_onboarding". All fields are combined with a logical 'AND'. */
export type User_Onboarding_Bool_Exp = {
  _and?: Maybe<Array<User_Onboarding_Bool_Exp>>;
  _not?: Maybe<User_Onboarding_Bool_Exp>;
  _or?: Maybe<Array<User_Onboarding_Bool_Exp>>;
  activity?: Maybe<Jsonb_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  details?: Maybe<String_Comparison_Exp>;
  is_onboarded?: Maybe<Boolean_Comparison_Exp>;
  target?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_onboarding" */
export enum User_Onboarding_Constraint {
  /** unique or primary key constraint on columns "target", "user_id" */
  UserOnboardingPkey = 'user_onboarding_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type User_Onboarding_Delete_At_Path_Input = {
  activity?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type User_Onboarding_Delete_Elem_Input = {
  activity?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type User_Onboarding_Delete_Key_Input = {
  activity?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "user_onboarding" */
export type User_Onboarding_Insert_Input = {
  activity?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  details?: Maybe<Scalars['String']>;
  is_onboarded?: Maybe<Scalars['Boolean']>;
  target?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type User_Onboarding_Max_Fields = {
  __typename?: 'user_onboarding_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  details?: Maybe<Scalars['String']>;
  target?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_onboarding" */
export type User_Onboarding_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  details?: Maybe<Order_By>;
  target?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type User_Onboarding_Min_Fields = {
  __typename?: 'user_onboarding_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  details?: Maybe<Scalars['String']>;
  target?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_onboarding" */
export type User_Onboarding_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  details?: Maybe<Order_By>;
  target?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "user_onboarding" */
export type User_Onboarding_Mutation_Response = {
  __typename?: 'user_onboarding_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Onboarding>;
};

/** on_conflict condition type for table "user_onboarding" */
export type User_Onboarding_On_Conflict = {
  constraint: User_Onboarding_Constraint;
  update_columns?: Array<User_Onboarding_Update_Column>;
  where?: Maybe<User_Onboarding_Bool_Exp>;
};

/** Ordering options when selecting data from "user_onboarding". */
export type User_Onboarding_Order_By = {
  activity?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  details?: Maybe<Order_By>;
  is_onboarded?: Maybe<Order_By>;
  target?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: user_onboarding */
export type User_Onboarding_Pk_Columns_Input = {
  target: Scalars['String'];
  user_id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type User_Onboarding_Prepend_Input = {
  activity?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "user_onboarding" */
export enum User_Onboarding_Select_Column {
  /** column name */
  Activity = 'activity',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Details = 'details',
  /** column name */
  IsOnboarded = 'is_onboarded',
  /** column name */
  Target = 'target',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

/** select "user_onboarding_aggregate_bool_exp_bool_and_arguments_columns" columns of table "user_onboarding" */
export enum User_Onboarding_Select_Column_User_Onboarding_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsOnboarded = 'is_onboarded',
}

/** select "user_onboarding_aggregate_bool_exp_bool_or_arguments_columns" columns of table "user_onboarding" */
export enum User_Onboarding_Select_Column_User_Onboarding_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsOnboarded = 'is_onboarded',
}

/** input type for updating data in table "user_onboarding" */
export type User_Onboarding_Set_Input = {
  activity?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  details?: Maybe<Scalars['String']>;
  is_onboarded?: Maybe<Scalars['Boolean']>;
  target?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_onboarding" */
export type User_Onboarding_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Onboarding_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Onboarding_Stream_Cursor_Value_Input = {
  activity?: Maybe<Scalars['jsonb']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  details?: Maybe<Scalars['String']>;
  is_onboarded?: Maybe<Scalars['Boolean']>;
  target?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "user_onboarding" */
export enum User_Onboarding_Update_Column {
  /** column name */
  Activity = 'activity',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Details = 'details',
  /** column name */
  IsOnboarded = 'is_onboarded',
  /** column name */
  Target = 'target',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

export type User_Onboarding_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<User_Onboarding_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<User_Onboarding_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<User_Onboarding_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<User_Onboarding_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<User_Onboarding_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Onboarding_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Onboarding_Bool_Exp;
};

/** Captures personal access tokens of user to get admin access to a project */
export type User_Personal_Access_Tokens = {
  __typename?: 'user_personal_access_tokens';
  created_at: Scalars['timestamptz'];
  description: Scalars['String'];
  hashed_token: Scalars['String'];
  id: Scalars['uuid'];
  is_active: Scalars['Boolean'];
  last_used?: Maybe<Scalars['timestamptz']>;
  last_used_ip_address?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['uuid'];
};

/** aggregated selection of "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_Aggregate = {
  __typename?: 'user_personal_access_tokens_aggregate';
  aggregate?: Maybe<User_Personal_Access_Tokens_Aggregate_Fields>;
  nodes: Array<User_Personal_Access_Tokens>;
};

export type User_Personal_Access_Tokens_Aggregate_Bool_Exp = {
  bool_and?: Maybe<User_Personal_Access_Tokens_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<User_Personal_Access_Tokens_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<User_Personal_Access_Tokens_Aggregate_Bool_Exp_Count>;
};

export type User_Personal_Access_Tokens_Aggregate_Bool_Exp_Bool_And = {
  arguments: User_Personal_Access_Tokens_Select_Column_User_Personal_Access_Tokens_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type User_Personal_Access_Tokens_Aggregate_Bool_Exp_Bool_Or = {
  arguments: User_Personal_Access_Tokens_Select_Column_User_Personal_Access_Tokens_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type User_Personal_Access_Tokens_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<User_Personal_Access_Tokens_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_Aggregate_Fields = {
  __typename?: 'user_personal_access_tokens_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<User_Personal_Access_Tokens_Max_Fields>;
  min?: Maybe<User_Personal_Access_Tokens_Min_Fields>;
};

/** aggregate fields of "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Personal_Access_Tokens_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<User_Personal_Access_Tokens_Max_Order_By>;
  min?: Maybe<User_Personal_Access_Tokens_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_Arr_Rel_Insert_Input = {
  data: Array<User_Personal_Access_Tokens_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<User_Personal_Access_Tokens_On_Conflict>;
};

/**
 * Boolean expression to filter rows from the table "user_personal_access_tokens".
 * All fields are combined with a logical 'AND'.
 */
export type User_Personal_Access_Tokens_Bool_Exp = {
  _and?: Maybe<Array<User_Personal_Access_Tokens_Bool_Exp>>;
  _not?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
  _or?: Maybe<Array<User_Personal_Access_Tokens_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  description?: Maybe<String_Comparison_Exp>;
  hashed_token?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  is_active?: Maybe<Boolean_Comparison_Exp>;
  last_used?: Maybe<Timestamptz_Comparison_Exp>;
  last_used_ip_address?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_personal_access_tokens" */
export enum User_Personal_Access_Tokens_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserPersonalAccessTokensPkey = 'user_personal_access_tokens_pkey',
}

/** input type for inserting data into table "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  hashed_token?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  last_used?: Maybe<Scalars['timestamptz']>;
  last_used_ip_address?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type User_Personal_Access_Tokens_Max_Fields = {
  __typename?: 'user_personal_access_tokens_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  hashed_token?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_used?: Maybe<Scalars['timestamptz']>;
  last_used_ip_address?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  hashed_token?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last_used?: Maybe<Order_By>;
  last_used_ip_address?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type User_Personal_Access_Tokens_Min_Fields = {
  __typename?: 'user_personal_access_tokens_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  hashed_token?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  last_used?: Maybe<Scalars['timestamptz']>;
  last_used_ip_address?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  hashed_token?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  last_used?: Maybe<Order_By>;
  last_used_ip_address?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_Mutation_Response = {
  __typename?: 'user_personal_access_tokens_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Personal_Access_Tokens>;
};

/** on_conflict condition type for table "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_On_Conflict = {
  constraint: User_Personal_Access_Tokens_Constraint;
  update_columns?: Array<User_Personal_Access_Tokens_Update_Column>;
  where?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
};

/** Ordering options when selecting data from "user_personal_access_tokens". */
export type User_Personal_Access_Tokens_Order_By = {
  created_at?: Maybe<Order_By>;
  description?: Maybe<Order_By>;
  hashed_token?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  is_active?: Maybe<Order_By>;
  last_used?: Maybe<Order_By>;
  last_used_ip_address?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: user_personal_access_tokens */
export type User_Personal_Access_Tokens_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "user_personal_access_tokens" */
export enum User_Personal_Access_Tokens_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  HashedToken = 'hashed_token',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  LastUsed = 'last_used',
  /** column name */
  LastUsedIpAddress = 'last_used_ip_address',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

/**
 * select "user_personal_access_tokens_aggregate_bool_exp_bool_and_arguments_columns"
 * columns of table "user_personal_access_tokens"
 */
export enum User_Personal_Access_Tokens_Select_Column_User_Personal_Access_Tokens_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  IsActive = 'is_active',
}

/**
 * select "user_personal_access_tokens_aggregate_bool_exp_bool_or_arguments_columns"
 * columns of table "user_personal_access_tokens"
 */
export enum User_Personal_Access_Tokens_Select_Column_User_Personal_Access_Tokens_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  IsActive = 'is_active',
}

/** input type for updating data in table "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  hashed_token?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  last_used?: Maybe<Scalars['timestamptz']>;
  last_used_ip_address?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_personal_access_tokens" */
export type User_Personal_Access_Tokens_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Personal_Access_Tokens_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Personal_Access_Tokens_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  description?: Maybe<Scalars['String']>;
  hashed_token?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  is_active?: Maybe<Scalars['Boolean']>;
  last_used?: Maybe<Scalars['timestamptz']>;
  last_used_ip_address?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "user_personal_access_tokens" */
export enum User_Personal_Access_Tokens_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  HashedToken = 'hashed_token',
  /** column name */
  Id = 'id',
  /** column name */
  IsActive = 'is_active',
  /** column name */
  LastUsed = 'last_used',
  /** column name */
  LastUsedIpAddress = 'last_used_ip_address',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

export type User_Personal_Access_Tokens_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Personal_Access_Tokens_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Personal_Access_Tokens_Bool_Exp;
};

/**
 * Contains optional info a user can add when they add a payment method. This info
 * is for use by sales and support and not for any technical purpose.
 */
export type User_Profile = {
  __typename?: 'user_profile';
  /** Self-reported company the user represents. */
  company?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  /** User email. Intended to be a company email. */
  email?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  /** Preferred name to address user */
  name?: Maybe<Scalars['String']>;
  /** Phone number on file */
  phone_number?: Maybe<Scalars['String']>;
  /** User job title / position at their company. Self reported. */
  title?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamptz'];
  /** An object relationship */
  user: Users;
  /** The user to whom this profile info belongs */
  user_id: Scalars['uuid'];
};

/** aggregated selection of "user_profile" */
export type User_Profile_Aggregate = {
  __typename?: 'user_profile_aggregate';
  aggregate?: Maybe<User_Profile_Aggregate_Fields>;
  nodes: Array<User_Profile>;
};

/** aggregate fields of "user_profile" */
export type User_Profile_Aggregate_Fields = {
  __typename?: 'user_profile_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<User_Profile_Max_Fields>;
  min?: Maybe<User_Profile_Min_Fields>;
};

/** aggregate fields of "user_profile" */
export type User_Profile_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Profile_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "user_profile". All fields are combined with a logical 'AND'. */
export type User_Profile_Bool_Exp = {
  _and?: Maybe<Array<User_Profile_Bool_Exp>>;
  _not?: Maybe<User_Profile_Bool_Exp>;
  _or?: Maybe<Array<User_Profile_Bool_Exp>>;
  company?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  phone_number?: Maybe<String_Comparison_Exp>;
  title?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_profile" */
export enum User_Profile_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserProfilePkey = 'user_profile_pkey',
  /** unique or primary key constraint on columns "user_id" */
  UserProfileUserIdKey = 'user_profile_user_id_key',
}

/** input type for inserting data into table "user_profile" */
export type User_Profile_Insert_Input = {
  /** Self-reported company the user represents. */
  company?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** User email. Intended to be a company email. */
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  /** Preferred name to address user */
  name?: Maybe<Scalars['String']>;
  /** Phone number on file */
  phone_number?: Maybe<Scalars['String']>;
  /** User job title / position at their company. Self reported. */
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  /** The user to whom this profile info belongs */
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type User_Profile_Max_Fields = {
  __typename?: 'user_profile_max_fields';
  /** Self-reported company the user represents. */
  company?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** User email. Intended to be a company email. */
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  /** Preferred name to address user */
  name?: Maybe<Scalars['String']>;
  /** Phone number on file */
  phone_number?: Maybe<Scalars['String']>;
  /** User job title / position at their company. Self reported. */
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** The user to whom this profile info belongs */
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type User_Profile_Min_Fields = {
  __typename?: 'user_profile_min_fields';
  /** Self-reported company the user represents. */
  company?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** User email. Intended to be a company email. */
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  /** Preferred name to address user */
  name?: Maybe<Scalars['String']>;
  /** Phone number on file */
  phone_number?: Maybe<Scalars['String']>;
  /** User job title / position at their company. Self reported. */
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** The user to whom this profile info belongs */
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "user_profile" */
export type User_Profile_Mutation_Response = {
  __typename?: 'user_profile_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Profile>;
};

/** input type for inserting object relation for remote table "user_profile" */
export type User_Profile_Obj_Rel_Insert_Input = {
  data: User_Profile_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<User_Profile_On_Conflict>;
};

/** on_conflict condition type for table "user_profile" */
export type User_Profile_On_Conflict = {
  constraint: User_Profile_Constraint;
  update_columns?: Array<User_Profile_Update_Column>;
  where?: Maybe<User_Profile_Bool_Exp>;
};

/** Ordering options when selecting data from "user_profile". */
export type User_Profile_Order_By = {
  company?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  phone_number?: Maybe<Order_By>;
  title?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: user_profile */
export type User_Profile_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "user_profile" */
export enum User_Profile_Select_Column {
  /** column name */
  Company = 'company',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PhoneNumber = 'phone_number',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "user_profile" */
export type User_Profile_Set_Input = {
  /** Self-reported company the user represents. */
  company?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** User email. Intended to be a company email. */
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  /** Preferred name to address user */
  name?: Maybe<Scalars['String']>;
  /** Phone number on file */
  phone_number?: Maybe<Scalars['String']>;
  /** User job title / position at their company. Self reported. */
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** The user to whom this profile info belongs */
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_profile" */
export type User_Profile_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Profile_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Profile_Stream_Cursor_Value_Input = {
  /** Self-reported company the user represents. */
  company?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  /** User email. Intended to be a company email. */
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  /** Preferred name to address user */
  name?: Maybe<Scalars['String']>;
  /** Phone number on file */
  phone_number?: Maybe<Scalars['String']>;
  /** User job title / position at their company. Self reported. */
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** The user to whom this profile info belongs */
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "user_profile" */
export enum User_Profile_Update_Column {
  /** column name */
  Company = 'company',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  PhoneNumber = 'phone_number',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
}

export type User_Profile_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Profile_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Profile_Bool_Exp;
};

/** This view is created to query all the projects a user is associated to. */
export type User_Project_Map = {
  __typename?: 'user_project_map';
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "user_project_map" */
export type User_Project_Map_Aggregate = {
  __typename?: 'user_project_map_aggregate';
  aggregate?: Maybe<User_Project_Map_Aggregate_Fields>;
  nodes: Array<User_Project_Map>;
};

/** aggregate fields of "user_project_map" */
export type User_Project_Map_Aggregate_Fields = {
  __typename?: 'user_project_map_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<User_Project_Map_Max_Fields>;
  min?: Maybe<User_Project_Map_Min_Fields>;
};

/** aggregate fields of "user_project_map" */
export type User_Project_Map_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Project_Map_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "user_project_map". All fields are combined with a logical 'AND'. */
export type User_Project_Map_Bool_Exp = {
  _and?: Maybe<Array<User_Project_Map_Bool_Exp>>;
  _not?: Maybe<User_Project_Map_Bool_Exp>;
  _or?: Maybe<Array<User_Project_Map_Bool_Exp>>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** aggregate max on columns */
export type User_Project_Map_Max_Fields = {
  __typename?: 'user_project_map_max_fields';
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type User_Project_Map_Min_Fields = {
  __typename?: 'user_project_map_min_fields';
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Ordering options when selecting data from "user_project_map". */
export type User_Project_Map_Order_By = {
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** select columns of table "user_project_map" */
export enum User_Project_Map_Select_Column {
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  UserId = 'user_id',
}

/** Streaming cursor of the table "user_project_map" */
export type User_Project_Map_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Project_Map_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Project_Map_Stream_Cursor_Value_Input = {
  project_id?: Maybe<Scalars['uuid']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Users roles */
export type User_Roles = {
  __typename?: 'user_roles';
  comment?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  created_by: Scalars['String'];
  id: Scalars['uuid'];
  role: Scalars['String'];
  user_id: Scalars['uuid'];
};

/** aggregated selection of "user_roles" */
export type User_Roles_Aggregate = {
  __typename?: 'user_roles_aggregate';
  aggregate?: Maybe<User_Roles_Aggregate_Fields>;
  nodes: Array<User_Roles>;
};

export type User_Roles_Aggregate_Bool_Exp = {
  count?: Maybe<User_Roles_Aggregate_Bool_Exp_Count>;
};

export type User_Roles_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<User_Roles_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<User_Roles_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "user_roles" */
export type User_Roles_Aggregate_Fields = {
  __typename?: 'user_roles_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<User_Roles_Max_Fields>;
  min?: Maybe<User_Roles_Min_Fields>;
};

/** aggregate fields of "user_roles" */
export type User_Roles_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Roles_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "user_roles" */
export type User_Roles_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<User_Roles_Max_Order_By>;
  min?: Maybe<User_Roles_Min_Order_By>;
};

/** input type for inserting array relation for remote table "user_roles" */
export type User_Roles_Arr_Rel_Insert_Input = {
  data: Array<User_Roles_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<User_Roles_On_Conflict>;
};

/** Boolean expression to filter rows from the table "user_roles". All fields are combined with a logical 'AND'. */
export type User_Roles_Bool_Exp = {
  _and?: Maybe<Array<User_Roles_Bool_Exp>>;
  _not?: Maybe<User_Roles_Bool_Exp>;
  _or?: Maybe<Array<User_Roles_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  created_by?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  role?: Maybe<String_Comparison_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_roles" */
export enum User_Roles_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserRolesPkey = 'user_roles_pkey',
  /** unique or primary key constraint on columns "user_id", "role" */
  UserRolesUserIdRoleKey = 'user_roles_user_id_role_key',
}

/** input type for inserting data into table "user_roles" */
export type User_Roles_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type User_Roles_Max_Fields = {
  __typename?: 'user_roles_max_fields';
  comment?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "user_roles" */
export type User_Roles_Max_Order_By = {
  comment?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  created_by?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  role?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type User_Roles_Min_Fields = {
  __typename?: 'user_roles_min_fields';
  comment?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "user_roles" */
export type User_Roles_Min_Order_By = {
  comment?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  created_by?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  role?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "user_roles" */
export type User_Roles_Mutation_Response = {
  __typename?: 'user_roles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Roles>;
};

/** on_conflict condition type for table "user_roles" */
export type User_Roles_On_Conflict = {
  constraint: User_Roles_Constraint;
  update_columns?: Array<User_Roles_Update_Column>;
  where?: Maybe<User_Roles_Bool_Exp>;
};

/** Ordering options when selecting data from "user_roles". */
export type User_Roles_Order_By = {
  comment?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  created_by?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  role?: Maybe<Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: user_roles */
export type User_Roles_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "user_roles" */
export enum User_Roles_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Role = 'role',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "user_roles" */
export type User_Roles_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "user_roles" */
export type User_Roles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Roles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Roles_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  created_by?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  role?: Maybe<Scalars['String']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** update columns of table "user_roles" */
export enum User_Roles_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CreatedBy = 'created_by',
  /** column name */
  Id = 'id',
  /** column name */
  Role = 'role',
  /** column name */
  UserId = 'user_id',
}

export type User_Roles_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Roles_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Roles_Bool_Exp;
};

/** Special VPC policies for specific users */
export type User_Vpc_Policy = {
  __typename?: 'user_vpc_policy';
  created_at: Scalars['timestamptz'];
  id: Scalars['Int'];
  updated_at: Scalars['timestamptz'];
  user: Scalars['uuid'];
  vpc_limit: Scalars['Int'];
};

/** aggregated selection of "user_vpc_policy" */
export type User_Vpc_Policy_Aggregate = {
  __typename?: 'user_vpc_policy_aggregate';
  aggregate?: Maybe<User_Vpc_Policy_Aggregate_Fields>;
  nodes: Array<User_Vpc_Policy>;
};

/** aggregate fields of "user_vpc_policy" */
export type User_Vpc_Policy_Aggregate_Fields = {
  __typename?: 'user_vpc_policy_aggregate_fields';
  avg?: Maybe<User_Vpc_Policy_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<User_Vpc_Policy_Max_Fields>;
  min?: Maybe<User_Vpc_Policy_Min_Fields>;
  stddev?: Maybe<User_Vpc_Policy_Stddev_Fields>;
  stddev_pop?: Maybe<User_Vpc_Policy_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<User_Vpc_Policy_Stddev_Samp_Fields>;
  sum?: Maybe<User_Vpc_Policy_Sum_Fields>;
  var_pop?: Maybe<User_Vpc_Policy_Var_Pop_Fields>;
  var_samp?: Maybe<User_Vpc_Policy_Var_Samp_Fields>;
  variance?: Maybe<User_Vpc_Policy_Variance_Fields>;
};

/** aggregate fields of "user_vpc_policy" */
export type User_Vpc_Policy_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<User_Vpc_Policy_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type User_Vpc_Policy_Avg_Fields = {
  __typename?: 'user_vpc_policy_avg_fields';
  id?: Maybe<Scalars['Float']>;
  vpc_limit?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "user_vpc_policy". All fields are combined with a logical 'AND'. */
export type User_Vpc_Policy_Bool_Exp = {
  _and?: Maybe<Array<User_Vpc_Policy_Bool_Exp>>;
  _not?: Maybe<User_Vpc_Policy_Bool_Exp>;
  _or?: Maybe<Array<User_Vpc_Policy_Bool_Exp>>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Int_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Uuid_Comparison_Exp>;
  vpc_limit?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_vpc_policy" */
export enum User_Vpc_Policy_Constraint {
  /** unique or primary key constraint on columns "id" */
  UserVpcPolicyPkey = 'user_vpc_policy_pkey',
}

/** input type for incrementing numeric columns in table "user_vpc_policy" */
export type User_Vpc_Policy_Inc_Input = {
  id?: Maybe<Scalars['Int']>;
  vpc_limit?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "user_vpc_policy" */
export type User_Vpc_Policy_Insert_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Scalars['uuid']>;
  vpc_limit?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type User_Vpc_Policy_Max_Fields = {
  __typename?: 'user_vpc_policy_max_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Scalars['uuid']>;
  vpc_limit?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type User_Vpc_Policy_Min_Fields = {
  __typename?: 'user_vpc_policy_min_fields';
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Scalars['uuid']>;
  vpc_limit?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "user_vpc_policy" */
export type User_Vpc_Policy_Mutation_Response = {
  __typename?: 'user_vpc_policy_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<User_Vpc_Policy>;
};

/** on_conflict condition type for table "user_vpc_policy" */
export type User_Vpc_Policy_On_Conflict = {
  constraint: User_Vpc_Policy_Constraint;
  update_columns?: Array<User_Vpc_Policy_Update_Column>;
  where?: Maybe<User_Vpc_Policy_Bool_Exp>;
};

/** Ordering options when selecting data from "user_vpc_policy". */
export type User_Vpc_Policy_Order_By = {
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Order_By>;
  vpc_limit?: Maybe<Order_By>;
};

/** primary key columns input for table: user_vpc_policy */
export type User_Vpc_Policy_Pk_Columns_Input = {
  id: Scalars['Int'];
};

/** select columns of table "user_vpc_policy" */
export enum User_Vpc_Policy_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  User = 'user',
  /** column name */
  VpcLimit = 'vpc_limit',
}

/** input type for updating data in table "user_vpc_policy" */
export type User_Vpc_Policy_Set_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Scalars['uuid']>;
  vpc_limit?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type User_Vpc_Policy_Stddev_Fields = {
  __typename?: 'user_vpc_policy_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  vpc_limit?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type User_Vpc_Policy_Stddev_Pop_Fields = {
  __typename?: 'user_vpc_policy_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  vpc_limit?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type User_Vpc_Policy_Stddev_Samp_Fields = {
  __typename?: 'user_vpc_policy_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  vpc_limit?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "user_vpc_policy" */
export type User_Vpc_Policy_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: User_Vpc_Policy_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type User_Vpc_Policy_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Scalars['uuid']>;
  vpc_limit?: Maybe<Scalars['Int']>;
};

/** aggregate sum on columns */
export type User_Vpc_Policy_Sum_Fields = {
  __typename?: 'user_vpc_policy_sum_fields';
  id?: Maybe<Scalars['Int']>;
  vpc_limit?: Maybe<Scalars['Int']>;
};

/** update columns of table "user_vpc_policy" */
export enum User_Vpc_Policy_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  User = 'user',
  /** column name */
  VpcLimit = 'vpc_limit',
}

export type User_Vpc_Policy_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<User_Vpc_Policy_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<User_Vpc_Policy_Set_Input>;
  /** filter the rows which have to be updated */
  where: User_Vpc_Policy_Bool_Exp;
};

/** aggregate var_pop on columns */
export type User_Vpc_Policy_Var_Pop_Fields = {
  __typename?: 'user_vpc_policy_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  vpc_limit?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type User_Vpc_Policy_Var_Samp_Fields = {
  __typename?: 'user_vpc_policy_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  vpc_limit?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type User_Vpc_Policy_Variance_Fields = {
  __typename?: 'user_vpc_policy_variance_fields';
  id?: Maybe<Scalars['Float']>;
  vpc_limit?: Maybe<Scalars['Float']>;
};

export type UserInvitation = {
  __typename?: 'UserInvitation';
  id: Scalars['uuid'];
  invitedAt: Scalars['String'];
  invitedBy: Scalars['String'];
  isBillable: Scalars['Boolean'];
  isBillingInvitee: Scalars['Boolean'];
  key: Scalars['String'];
  privileges: Array<Scalars['String']>;
  projectID: Scalars['uuid'];
  projectName: Scalars['String'];
};

/** Captures users on Hasura Cloud */
export type Users = {
  __typename?: 'users';
  attempt_count?: Maybe<Scalars['Int']>;
  /** An object relationship */
  billing_address?: Maybe<Billing_Address>;
  /** An array relationship */
  billing_projects: Array<Projects>;
  /** An aggregate relationship */
  billing_projects_aggregate: Projects_Aggregate;
  /** An array relationship */
  collaborated_projects: Array<Project_Collaborators>;
  /** An aggregate relationship */
  collaborated_projects_aggregate: Project_Collaborators_Aggregate;
  confim_verifier?: Maybe<Scalars['String']>;
  confirm_mail_count?: Maybe<Scalars['Int']>;
  confirm_selector?: Maybe<Scalars['String']>;
  confirmed?: Maybe<Scalars['Boolean']>;
  created_at: Scalars['timestamptz'];
  customer_id?: Maybe<Scalars['String']>;
  email: Scalars['String'];
  /** An object relationship */
  enterprise_users?: Maybe<Enterprise_Users>;
  /** An array relationship */
  entitlements: Array<User_Entitlement_Access>;
  /** An aggregate relationship */
  entitlements_aggregate: User_Entitlement_Access_Aggregate;
  /** An array relationship */
  feature_accesses: Array<Feature_Access>;
  /** An aggregate relationship */
  feature_accesses_aggregate: Feature_Access_Aggregate;
  first_name?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  invoice_receipt_email?: Maybe<Scalars['String']>;
  /** An array relationship */
  invoices: Array<Invoice>;
  /** An aggregate relationship */
  invoices_aggregate: Invoice_Aggregate;
  is_saml_user?: Maybe<Scalars['Boolean']>;
  last_attempt?: Maybe<Scalars['timestamptz']>;
  last_name?: Maybe<Scalars['String']>;
  locked?: Maybe<Scalars['timestamptz']>;
  max_project_limit: Scalars['Int'];
  /** An array relationship */
  onboarding: Array<User_Onboarding>;
  /** An aggregate relationship */
  onboarding_aggregate: User_Onboarding_Aggregate;
  organization?: Maybe<Scalars['String']>;
  password: Scalars['String'];
  /** An array relationship */
  payment_methods: Array<Payment_Method>;
  /** An aggregate relationship */
  payment_methods_aggregate: Payment_Method_Aggregate;
  /** An array relationship */
  personal_access_tokens: Array<User_Personal_Access_Tokens>;
  /** An aggregate relationship */
  personal_access_tokens_aggregate: User_Personal_Access_Tokens_Aggregate;
  /** An array relationship */
  projects: Array<Projects>;
  /** An aggregate relationship */
  projects_aggregate: Projects_Aggregate;
  /** An array relationship */
  providers: Array<Providers>;
  /** An aggregate relationship */
  providers_aggregate: Providers_Aggregate;
  recover_selector?: Maybe<Scalars['String']>;
  recover_token_expiry?: Maybe<Scalars['timestamptz']>;
  recover_verifier?: Maybe<Scalars['String']>;
  recovery_codes?: Maybe<Scalars['String']>;
  /** An array relationship */
  roles: Array<User_Roles>;
  /** An aggregate relationship */
  roles_aggregate: User_Roles_Aggregate;
  totp_secret_key?: Maybe<Scalars['String']>;
  /** A computed field, executes function "is_trial_user" */
  trial_user?: Maybe<Scalars['Boolean']>;
  updated_at: Scalars['timestamptz'];
  /** An array relationship */
  user_coupon_usages: Array<User_Coupon>;
  /** An aggregate relationship */
  user_coupon_usages_aggregate: User_Coupon_Aggregate;
  /** An array relationship */
  user_credit_coupon_usages: Array<Customer_Usage>;
  /** An aggregate relationship */
  user_credit_coupon_usages_aggregate: Customer_Usage_Aggregate;
  /** An object relationship */
  user_profile?: Maybe<User_Profile>;
  zendesk_user_id?: Maybe<Scalars['bigint']>;
};

/** Captures users on Hasura Cloud */
export type UsersBilling_ProjectsArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersBilling_Projects_AggregateArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersCollaborated_ProjectsArgs = {
  distinct_on?: Maybe<Array<Project_Collaborators_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborators_Order_By>>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersCollaborated_Projects_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Collaborators_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborators_Order_By>>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersEntitlementsArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Access_Order_By>>;
  where?: Maybe<User_Entitlement_Access_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersEntitlements_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Entitlement_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Entitlement_Access_Order_By>>;
  where?: Maybe<User_Entitlement_Access_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersFeature_AccessesArgs = {
  distinct_on?: Maybe<Array<Feature_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Access_Order_By>>;
  where?: Maybe<Feature_Access_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersFeature_Accesses_AggregateArgs = {
  distinct_on?: Maybe<Array<Feature_Access_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Feature_Access_Order_By>>;
  where?: Maybe<Feature_Access_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersInvoicesArgs = {
  distinct_on?: Maybe<Array<Invoice_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Order_By>>;
  where?: Maybe<Invoice_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersInvoices_AggregateArgs = {
  distinct_on?: Maybe<Array<Invoice_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Invoice_Order_By>>;
  where?: Maybe<Invoice_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersOnboardingArgs = {
  distinct_on?: Maybe<Array<User_Onboarding_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Onboarding_Order_By>>;
  where?: Maybe<User_Onboarding_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersOnboarding_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Onboarding_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Onboarding_Order_By>>;
  where?: Maybe<User_Onboarding_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersPayment_MethodsArgs = {
  distinct_on?: Maybe<Array<Payment_Method_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payment_Method_Order_By>>;
  where?: Maybe<Payment_Method_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersPayment_Methods_AggregateArgs = {
  distinct_on?: Maybe<Array<Payment_Method_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Payment_Method_Order_By>>;
  where?: Maybe<Payment_Method_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersPersonal_Access_TokensArgs = {
  distinct_on?: Maybe<Array<User_Personal_Access_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Personal_Access_Tokens_Order_By>>;
  where?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersPersonal_Access_Tokens_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Personal_Access_Tokens_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Personal_Access_Tokens_Order_By>>;
  where?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersProjectsArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersProjects_AggregateArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersProvidersArgs = {
  distinct_on?: Maybe<Array<Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Providers_Order_By>>;
  where?: Maybe<Providers_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersProviders_AggregateArgs = {
  distinct_on?: Maybe<Array<Providers_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Providers_Order_By>>;
  where?: Maybe<Providers_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersRolesArgs = {
  distinct_on?: Maybe<Array<User_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Roles_Order_By>>;
  where?: Maybe<User_Roles_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersRoles_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Roles_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Roles_Order_By>>;
  where?: Maybe<User_Roles_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersUser_Coupon_UsagesArgs = {
  distinct_on?: Maybe<Array<User_Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Coupon_Order_By>>;
  where?: Maybe<User_Coupon_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersUser_Coupon_Usages_AggregateArgs = {
  distinct_on?: Maybe<Array<User_Coupon_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<User_Coupon_Order_By>>;
  where?: Maybe<User_Coupon_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersUser_Credit_Coupon_UsagesArgs = {
  distinct_on?: Maybe<Array<Customer_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Usage_Order_By>>;
  where?: Maybe<Customer_Usage_Bool_Exp>;
};

/** Captures users on Hasura Cloud */
export type UsersUser_Credit_Coupon_Usages_AggregateArgs = {
  distinct_on?: Maybe<Array<Customer_Usage_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Customer_Usage_Order_By>>;
  where?: Maybe<Customer_Usage_Bool_Exp>;
};

/** aggregated selection of "users" */
export type Users_Aggregate = {
  __typename?: 'users_aggregate';
  aggregate?: Maybe<Users_Aggregate_Fields>;
  nodes: Array<Users>;
};

/** aggregate fields of "users" */
export type Users_Aggregate_Fields = {
  __typename?: 'users_aggregate_fields';
  avg?: Maybe<Users_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Users_Max_Fields>;
  min?: Maybe<Users_Min_Fields>;
  stddev?: Maybe<Users_Stddev_Fields>;
  stddev_pop?: Maybe<Users_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Users_Stddev_Samp_Fields>;
  sum?: Maybe<Users_Sum_Fields>;
  var_pop?: Maybe<Users_Var_Pop_Fields>;
  var_samp?: Maybe<Users_Var_Samp_Fields>;
  variance?: Maybe<Users_Variance_Fields>;
};

/** aggregate fields of "users" */
export type Users_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Users_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Users_Avg_Fields = {
  __typename?: 'users_avg_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  confirm_mail_count?: Maybe<Scalars['Float']>;
  max_project_limit?: Maybe<Scalars['Float']>;
  zendesk_user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type Users_Bool_Exp = {
  _and?: Maybe<Array<Users_Bool_Exp>>;
  _not?: Maybe<Users_Bool_Exp>;
  _or?: Maybe<Array<Users_Bool_Exp>>;
  attempt_count?: Maybe<Int_Comparison_Exp>;
  billing_address?: Maybe<Billing_Address_Bool_Exp>;
  billing_projects?: Maybe<Projects_Bool_Exp>;
  billing_projects_aggregate?: Maybe<Projects_Aggregate_Bool_Exp>;
  collaborated_projects?: Maybe<Project_Collaborators_Bool_Exp>;
  collaborated_projects_aggregate?: Maybe<Project_Collaborators_Aggregate_Bool_Exp>;
  confim_verifier?: Maybe<String_Comparison_Exp>;
  confirm_mail_count?: Maybe<Int_Comparison_Exp>;
  confirm_selector?: Maybe<String_Comparison_Exp>;
  confirmed?: Maybe<Boolean_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  customer_id?: Maybe<String_Comparison_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  enterprise_users?: Maybe<Enterprise_Users_Bool_Exp>;
  entitlements?: Maybe<User_Entitlement_Access_Bool_Exp>;
  entitlements_aggregate?: Maybe<User_Entitlement_Access_Aggregate_Bool_Exp>;
  feature_accesses?: Maybe<Feature_Access_Bool_Exp>;
  feature_accesses_aggregate?: Maybe<Feature_Access_Aggregate_Bool_Exp>;
  first_name?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  invoice_receipt_email?: Maybe<String_Comparison_Exp>;
  invoices?: Maybe<Invoice_Bool_Exp>;
  invoices_aggregate?: Maybe<Invoice_Aggregate_Bool_Exp>;
  is_saml_user?: Maybe<Boolean_Comparison_Exp>;
  last_attempt?: Maybe<Timestamptz_Comparison_Exp>;
  last_name?: Maybe<String_Comparison_Exp>;
  locked?: Maybe<Timestamptz_Comparison_Exp>;
  max_project_limit?: Maybe<Int_Comparison_Exp>;
  onboarding?: Maybe<User_Onboarding_Bool_Exp>;
  onboarding_aggregate?: Maybe<User_Onboarding_Aggregate_Bool_Exp>;
  organization?: Maybe<String_Comparison_Exp>;
  password?: Maybe<String_Comparison_Exp>;
  payment_methods?: Maybe<Payment_Method_Bool_Exp>;
  payment_methods_aggregate?: Maybe<Payment_Method_Aggregate_Bool_Exp>;
  personal_access_tokens?: Maybe<User_Personal_Access_Tokens_Bool_Exp>;
  personal_access_tokens_aggregate?: Maybe<User_Personal_Access_Tokens_Aggregate_Bool_Exp>;
  projects?: Maybe<Projects_Bool_Exp>;
  projects_aggregate?: Maybe<Projects_Aggregate_Bool_Exp>;
  providers?: Maybe<Providers_Bool_Exp>;
  providers_aggregate?: Maybe<Providers_Aggregate_Bool_Exp>;
  recover_selector?: Maybe<String_Comparison_Exp>;
  recover_token_expiry?: Maybe<Timestamptz_Comparison_Exp>;
  recover_verifier?: Maybe<String_Comparison_Exp>;
  recovery_codes?: Maybe<String_Comparison_Exp>;
  roles?: Maybe<User_Roles_Bool_Exp>;
  roles_aggregate?: Maybe<User_Roles_Aggregate_Bool_Exp>;
  totp_secret_key?: Maybe<String_Comparison_Exp>;
  trial_user?: Maybe<Boolean_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user_coupon_usages?: Maybe<User_Coupon_Bool_Exp>;
  user_coupon_usages_aggregate?: Maybe<User_Coupon_Aggregate_Bool_Exp>;
  user_credit_coupon_usages?: Maybe<Customer_Usage_Bool_Exp>;
  user_credit_coupon_usages_aggregate?: Maybe<Customer_Usage_Aggregate_Bool_Exp>;
  user_profile?: Maybe<User_Profile_Bool_Exp>;
  zendesk_user_id?: Maybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "users" */
export enum Users_Constraint {
  /** unique or primary key constraint on columns "customer_id" */
  UsersCustomerIdKey = 'users_customer_id_key',
  /** unique or primary key constraint on columns "email" */
  UsersEmailKey = 'users_email_key',
  /** unique or primary key constraint on columns "id" */
  UsersPkey = 'users_pkey',
}

/** input type for incrementing numeric columns in table "users" */
export type Users_Inc_Input = {
  attempt_count?: Maybe<Scalars['Int']>;
  confirm_mail_count?: Maybe<Scalars['Int']>;
  max_project_limit?: Maybe<Scalars['Int']>;
  zendesk_user_id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "users" */
export type Users_Insert_Input = {
  attempt_count?: Maybe<Scalars['Int']>;
  billing_address?: Maybe<Billing_Address_Obj_Rel_Insert_Input>;
  billing_projects?: Maybe<Projects_Arr_Rel_Insert_Input>;
  collaborated_projects?: Maybe<Project_Collaborators_Arr_Rel_Insert_Input>;
  confim_verifier?: Maybe<Scalars['String']>;
  confirm_mail_count?: Maybe<Scalars['Int']>;
  confirm_selector?: Maybe<Scalars['String']>;
  confirmed?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  enterprise_users?: Maybe<Enterprise_Users_Obj_Rel_Insert_Input>;
  entitlements?: Maybe<User_Entitlement_Access_Arr_Rel_Insert_Input>;
  feature_accesses?: Maybe<Feature_Access_Arr_Rel_Insert_Input>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_receipt_email?: Maybe<Scalars['String']>;
  invoices?: Maybe<Invoice_Arr_Rel_Insert_Input>;
  is_saml_user?: Maybe<Scalars['Boolean']>;
  last_attempt?: Maybe<Scalars['timestamptz']>;
  last_name?: Maybe<Scalars['String']>;
  locked?: Maybe<Scalars['timestamptz']>;
  max_project_limit?: Maybe<Scalars['Int']>;
  onboarding?: Maybe<User_Onboarding_Arr_Rel_Insert_Input>;
  organization?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  payment_methods?: Maybe<Payment_Method_Arr_Rel_Insert_Input>;
  personal_access_tokens?: Maybe<User_Personal_Access_Tokens_Arr_Rel_Insert_Input>;
  projects?: Maybe<Projects_Arr_Rel_Insert_Input>;
  providers?: Maybe<Providers_Arr_Rel_Insert_Input>;
  recover_selector?: Maybe<Scalars['String']>;
  recover_token_expiry?: Maybe<Scalars['timestamptz']>;
  recover_verifier?: Maybe<Scalars['String']>;
  recovery_codes?: Maybe<Scalars['String']>;
  roles?: Maybe<User_Roles_Arr_Rel_Insert_Input>;
  totp_secret_key?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_coupon_usages?: Maybe<User_Coupon_Arr_Rel_Insert_Input>;
  user_credit_coupon_usages?: Maybe<Customer_Usage_Arr_Rel_Insert_Input>;
  user_profile?: Maybe<User_Profile_Obj_Rel_Insert_Input>;
  zendesk_user_id?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Users_Max_Fields = {
  __typename?: 'users_max_fields';
  attempt_count?: Maybe<Scalars['Int']>;
  confim_verifier?: Maybe<Scalars['String']>;
  confirm_mail_count?: Maybe<Scalars['Int']>;
  confirm_selector?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_receipt_email?: Maybe<Scalars['String']>;
  last_attempt?: Maybe<Scalars['timestamptz']>;
  last_name?: Maybe<Scalars['String']>;
  locked?: Maybe<Scalars['timestamptz']>;
  max_project_limit?: Maybe<Scalars['Int']>;
  organization?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  recover_selector?: Maybe<Scalars['String']>;
  recover_token_expiry?: Maybe<Scalars['timestamptz']>;
  recover_verifier?: Maybe<Scalars['String']>;
  recovery_codes?: Maybe<Scalars['String']>;
  totp_secret_key?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zendesk_user_id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Users_Min_Fields = {
  __typename?: 'users_min_fields';
  attempt_count?: Maybe<Scalars['Int']>;
  confim_verifier?: Maybe<Scalars['String']>;
  confirm_mail_count?: Maybe<Scalars['Int']>;
  confirm_selector?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_receipt_email?: Maybe<Scalars['String']>;
  last_attempt?: Maybe<Scalars['timestamptz']>;
  last_name?: Maybe<Scalars['String']>;
  locked?: Maybe<Scalars['timestamptz']>;
  max_project_limit?: Maybe<Scalars['Int']>;
  organization?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  recover_selector?: Maybe<Scalars['String']>;
  recover_token_expiry?: Maybe<Scalars['timestamptz']>;
  recover_verifier?: Maybe<Scalars['String']>;
  recovery_codes?: Maybe<Scalars['String']>;
  totp_secret_key?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zendesk_user_id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "users" */
export type Users_Mutation_Response = {
  __typename?: 'users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type Users_Obj_Rel_Insert_Input = {
  data: Users_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Users_On_Conflict>;
};

/** on_conflict condition type for table "users" */
export type Users_On_Conflict = {
  constraint: Users_Constraint;
  update_columns?: Array<Users_Update_Column>;
  where?: Maybe<Users_Bool_Exp>;
};

/** Ordering options when selecting data from "users". */
export type Users_Order_By = {
  attempt_count?: Maybe<Order_By>;
  billing_address?: Maybe<Billing_Address_Order_By>;
  billing_projects_aggregate?: Maybe<Projects_Aggregate_Order_By>;
  collaborated_projects_aggregate?: Maybe<Project_Collaborators_Aggregate_Order_By>;
  confim_verifier?: Maybe<Order_By>;
  confirm_mail_count?: Maybe<Order_By>;
  confirm_selector?: Maybe<Order_By>;
  confirmed?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  customer_id?: Maybe<Order_By>;
  email?: Maybe<Order_By>;
  enterprise_users?: Maybe<Enterprise_Users_Order_By>;
  entitlements_aggregate?: Maybe<User_Entitlement_Access_Aggregate_Order_By>;
  feature_accesses_aggregate?: Maybe<Feature_Access_Aggregate_Order_By>;
  first_name?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  invoice_receipt_email?: Maybe<Order_By>;
  invoices_aggregate?: Maybe<Invoice_Aggregate_Order_By>;
  is_saml_user?: Maybe<Order_By>;
  last_attempt?: Maybe<Order_By>;
  last_name?: Maybe<Order_By>;
  locked?: Maybe<Order_By>;
  max_project_limit?: Maybe<Order_By>;
  onboarding_aggregate?: Maybe<User_Onboarding_Aggregate_Order_By>;
  organization?: Maybe<Order_By>;
  password?: Maybe<Order_By>;
  payment_methods_aggregate?: Maybe<Payment_Method_Aggregate_Order_By>;
  personal_access_tokens_aggregate?: Maybe<User_Personal_Access_Tokens_Aggregate_Order_By>;
  projects_aggregate?: Maybe<Projects_Aggregate_Order_By>;
  providers_aggregate?: Maybe<Providers_Aggregate_Order_By>;
  recover_selector?: Maybe<Order_By>;
  recover_token_expiry?: Maybe<Order_By>;
  recover_verifier?: Maybe<Order_By>;
  recovery_codes?: Maybe<Order_By>;
  roles_aggregate?: Maybe<User_Roles_Aggregate_Order_By>;
  totp_secret_key?: Maybe<Order_By>;
  trial_user?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user_coupon_usages_aggregate?: Maybe<User_Coupon_Aggregate_Order_By>;
  user_credit_coupon_usages_aggregate?: Maybe<Customer_Usage_Aggregate_Order_By>;
  user_profile?: Maybe<User_Profile_Order_By>;
  zendesk_user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: users */
export type Users_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** View to capture public user fields */
export type Users_Public = {
  __typename?: 'users_public';
  /** An array relationship */
  billing_projects: Array<Projects>;
  /** An aggregate relationship */
  billing_projects_aggregate: Projects_Aggregate;
  /** An array relationship */
  collaborated_projects: Array<Project_Collaborators>;
  /** An aggregate relationship */
  collaborated_projects_aggregate: Project_Collaborators_Aggregate;
  email?: Maybe<Scalars['String']>;
  /** An object relationship */
  enterprise_user?: Maybe<Enterprise_Users>;
  id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  projects: Array<Projects>;
  /** An aggregate relationship */
  projects_aggregate: Projects_Aggregate;
};

/** View to capture public user fields */
export type Users_PublicBilling_ProjectsArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

/** View to capture public user fields */
export type Users_PublicBilling_Projects_AggregateArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

/** View to capture public user fields */
export type Users_PublicCollaborated_ProjectsArgs = {
  distinct_on?: Maybe<Array<Project_Collaborators_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborators_Order_By>>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

/** View to capture public user fields */
export type Users_PublicCollaborated_Projects_AggregateArgs = {
  distinct_on?: Maybe<Array<Project_Collaborators_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Project_Collaborators_Order_By>>;
  where?: Maybe<Project_Collaborators_Bool_Exp>;
};

/** View to capture public user fields */
export type Users_PublicProjectsArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

/** View to capture public user fields */
export type Users_PublicProjects_AggregateArgs = {
  distinct_on?: Maybe<Array<Projects_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Projects_Order_By>>;
  where?: Maybe<Projects_Bool_Exp>;
};

/** aggregated selection of "users_public" */
export type Users_Public_Aggregate = {
  __typename?: 'users_public_aggregate';
  aggregate?: Maybe<Users_Public_Aggregate_Fields>;
  nodes: Array<Users_Public>;
};

/** aggregate fields of "users_public" */
export type Users_Public_Aggregate_Fields = {
  __typename?: 'users_public_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Users_Public_Max_Fields>;
  min?: Maybe<Users_Public_Min_Fields>;
};

/** aggregate fields of "users_public" */
export type Users_Public_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Users_Public_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "users_public". All fields are combined with a logical 'AND'. */
export type Users_Public_Bool_Exp = {
  _and?: Maybe<Array<Users_Public_Bool_Exp>>;
  _not?: Maybe<Users_Public_Bool_Exp>;
  _or?: Maybe<Array<Users_Public_Bool_Exp>>;
  billing_projects?: Maybe<Projects_Bool_Exp>;
  billing_projects_aggregate?: Maybe<Projects_Aggregate_Bool_Exp>;
  collaborated_projects?: Maybe<Project_Collaborators_Bool_Exp>;
  collaborated_projects_aggregate?: Maybe<Project_Collaborators_Aggregate_Bool_Exp>;
  email?: Maybe<String_Comparison_Exp>;
  enterprise_user?: Maybe<Enterprise_Users_Bool_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  projects?: Maybe<Projects_Bool_Exp>;
  projects_aggregate?: Maybe<Projects_Aggregate_Bool_Exp>;
};

/** input type for inserting data into table "users_public" */
export type Users_Public_Insert_Input = {
  billing_projects?: Maybe<Projects_Arr_Rel_Insert_Input>;
  collaborated_projects?: Maybe<Project_Collaborators_Arr_Rel_Insert_Input>;
  email?: Maybe<Scalars['String']>;
  enterprise_user?: Maybe<Enterprise_Users_Obj_Rel_Insert_Input>;
  id?: Maybe<Scalars['uuid']>;
  projects?: Maybe<Projects_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Users_Public_Max_Fields = {
  __typename?: 'users_public_max_fields';
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Users_Public_Min_Fields = {
  __typename?: 'users_public_min_fields';
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "users_public" */
export type Users_Public_Mutation_Response = {
  __typename?: 'users_public_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Users_Public>;
};

/** input type for inserting object relation for remote table "users_public" */
export type Users_Public_Obj_Rel_Insert_Input = {
  data: Users_Public_Insert_Input;
};

/** Ordering options when selecting data from "users_public". */
export type Users_Public_Order_By = {
  billing_projects_aggregate?: Maybe<Projects_Aggregate_Order_By>;
  collaborated_projects_aggregate?: Maybe<Project_Collaborators_Aggregate_Order_By>;
  email?: Maybe<Order_By>;
  enterprise_user?: Maybe<Enterprise_Users_Order_By>;
  id?: Maybe<Order_By>;
  projects_aggregate?: Maybe<Projects_Aggregate_Order_By>;
};

/** select columns of table "users_public" */
export enum Users_Public_Select_Column {
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
}

/** input type for updating data in table "users_public" */
export type Users_Public_Set_Input = {
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
};

/** Streaming cursor of the table "users_public" */
export type Users_Public_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Users_Public_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Users_Public_Stream_Cursor_Value_Input = {
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
};

export type Users_Public_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Users_Public_Set_Input>;
  /** filter the rows which have to be updated */
  where: Users_Public_Bool_Exp;
};

/** select columns of table "users" */
export enum Users_Select_Column {
  /** column name */
  AttemptCount = 'attempt_count',
  /** column name */
  ConfimVerifier = 'confim_verifier',
  /** column name */
  ConfirmMailCount = 'confirm_mail_count',
  /** column name */
  ConfirmSelector = 'confirm_selector',
  /** column name */
  Confirmed = 'confirmed',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Email = 'email',
  /** column name */
  FirstName = 'first_name',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceReceiptEmail = 'invoice_receipt_email',
  /** column name */
  IsSamlUser = 'is_saml_user',
  /** column name */
  LastAttempt = 'last_attempt',
  /** column name */
  LastName = 'last_name',
  /** column name */
  Locked = 'locked',
  /** column name */
  MaxProjectLimit = 'max_project_limit',
  /** column name */
  Organization = 'organization',
  /** column name */
  Password = 'password',
  /** column name */
  RecoverSelector = 'recover_selector',
  /** column name */
  RecoverTokenExpiry = 'recover_token_expiry',
  /** column name */
  RecoverVerifier = 'recover_verifier',
  /** column name */
  RecoveryCodes = 'recovery_codes',
  /** column name */
  TotpSecretKey = 'totp_secret_key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ZendeskUserId = 'zendesk_user_id',
}

/** input type for updating data in table "users" */
export type Users_Set_Input = {
  attempt_count?: Maybe<Scalars['Int']>;
  confim_verifier?: Maybe<Scalars['String']>;
  confirm_mail_count?: Maybe<Scalars['Int']>;
  confirm_selector?: Maybe<Scalars['String']>;
  confirmed?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_receipt_email?: Maybe<Scalars['String']>;
  is_saml_user?: Maybe<Scalars['Boolean']>;
  last_attempt?: Maybe<Scalars['timestamptz']>;
  last_name?: Maybe<Scalars['String']>;
  locked?: Maybe<Scalars['timestamptz']>;
  max_project_limit?: Maybe<Scalars['Int']>;
  organization?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  recover_selector?: Maybe<Scalars['String']>;
  recover_token_expiry?: Maybe<Scalars['timestamptz']>;
  recover_verifier?: Maybe<Scalars['String']>;
  recovery_codes?: Maybe<Scalars['String']>;
  totp_secret_key?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zendesk_user_id?: Maybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Users_Stddev_Fields = {
  __typename?: 'users_stddev_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  confirm_mail_count?: Maybe<Scalars['Float']>;
  max_project_limit?: Maybe<Scalars['Float']>;
  zendesk_user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Users_Stddev_Pop_Fields = {
  __typename?: 'users_stddev_pop_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  confirm_mail_count?: Maybe<Scalars['Float']>;
  max_project_limit?: Maybe<Scalars['Float']>;
  zendesk_user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Users_Stddev_Samp_Fields = {
  __typename?: 'users_stddev_samp_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  confirm_mail_count?: Maybe<Scalars['Float']>;
  max_project_limit?: Maybe<Scalars['Float']>;
  zendesk_user_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "users" */
export type Users_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Users_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Users_Stream_Cursor_Value_Input = {
  attempt_count?: Maybe<Scalars['Int']>;
  confim_verifier?: Maybe<Scalars['String']>;
  confirm_mail_count?: Maybe<Scalars['Int']>;
  confirm_selector?: Maybe<Scalars['String']>;
  confirmed?: Maybe<Scalars['Boolean']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  customer_id?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  invoice_receipt_email?: Maybe<Scalars['String']>;
  is_saml_user?: Maybe<Scalars['Boolean']>;
  last_attempt?: Maybe<Scalars['timestamptz']>;
  last_name?: Maybe<Scalars['String']>;
  locked?: Maybe<Scalars['timestamptz']>;
  max_project_limit?: Maybe<Scalars['Int']>;
  organization?: Maybe<Scalars['String']>;
  password?: Maybe<Scalars['String']>;
  recover_selector?: Maybe<Scalars['String']>;
  recover_token_expiry?: Maybe<Scalars['timestamptz']>;
  recover_verifier?: Maybe<Scalars['String']>;
  recovery_codes?: Maybe<Scalars['String']>;
  totp_secret_key?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  zendesk_user_id?: Maybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Users_Sum_Fields = {
  __typename?: 'users_sum_fields';
  attempt_count?: Maybe<Scalars['Int']>;
  confirm_mail_count?: Maybe<Scalars['Int']>;
  max_project_limit?: Maybe<Scalars['Int']>;
  zendesk_user_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "users" */
export enum Users_Update_Column {
  /** column name */
  AttemptCount = 'attempt_count',
  /** column name */
  ConfimVerifier = 'confim_verifier',
  /** column name */
  ConfirmMailCount = 'confirm_mail_count',
  /** column name */
  ConfirmSelector = 'confirm_selector',
  /** column name */
  Confirmed = 'confirmed',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CustomerId = 'customer_id',
  /** column name */
  Email = 'email',
  /** column name */
  FirstName = 'first_name',
  /** column name */
  Id = 'id',
  /** column name */
  InvoiceReceiptEmail = 'invoice_receipt_email',
  /** column name */
  IsSamlUser = 'is_saml_user',
  /** column name */
  LastAttempt = 'last_attempt',
  /** column name */
  LastName = 'last_name',
  /** column name */
  Locked = 'locked',
  /** column name */
  MaxProjectLimit = 'max_project_limit',
  /** column name */
  Organization = 'organization',
  /** column name */
  Password = 'password',
  /** column name */
  RecoverSelector = 'recover_selector',
  /** column name */
  RecoverTokenExpiry = 'recover_token_expiry',
  /** column name */
  RecoverVerifier = 'recover_verifier',
  /** column name */
  RecoveryCodes = 'recovery_codes',
  /** column name */
  TotpSecretKey = 'totp_secret_key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ZendeskUserId = 'zendesk_user_id',
}

export type Users_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Users_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Users_Set_Input>;
  /** filter the rows which have to be updated */
  where: Users_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Users_Var_Pop_Fields = {
  __typename?: 'users_var_pop_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  confirm_mail_count?: Maybe<Scalars['Float']>;
  max_project_limit?: Maybe<Scalars['Float']>;
  zendesk_user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Users_Var_Samp_Fields = {
  __typename?: 'users_var_samp_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  confirm_mail_count?: Maybe<Scalars['Float']>;
  max_project_limit?: Maybe<Scalars['Float']>;
  zendesk_user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Users_Variance_Fields = {
  __typename?: 'users_variance_fields';
  attempt_count?: Maybe<Scalars['Float']>;
  confirm_mail_count?: Maybe<Scalars['Float']>;
  max_project_limit?: Maybe<Scalars['Float']>;
  zendesk_user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: Maybe<Scalars['uuid']>;
  _gt?: Maybe<Scalars['uuid']>;
  _gte?: Maybe<Scalars['uuid']>;
  _in?: Maybe<Array<Scalars['uuid']>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _lt?: Maybe<Scalars['uuid']>;
  _lte?: Maybe<Scalars['uuid']>;
  _neq?: Maybe<Scalars['uuid']>;
  _nin?: Maybe<Array<Scalars['uuid']>>;
};

export type ValidTenantNameResponse = {
  __typename?: 'ValidTenantNameResponse';
  message: Scalars['String'];
  valid: Scalars['Boolean'];
};

/**
 * Stores information about Vercel Integrations. Each Vercel user/team creating an
 * integration to Hasura will have a row in this table.
 */
export type Vercel_Integration = {
  __typename?: 'vercel_integration';
  configuration_id: Scalars['String'];
  created_at?: Maybe<Scalars['timestamptz']>;
  environment_variables?: Maybe<Scalars['jsonb']>;
  id: Scalars['uuid'];
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  /** An object relationship */
  user?: Maybe<Users>;
  user_id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  vercel_integration_connections: Array<Vercel_Integration_Connections>;
  /** An aggregate relationship */
  vercel_integration_connections_aggregate: Vercel_Integration_Connections_Aggregate;
  vercel_user_id?: Maybe<Scalars['String']>;
};

/**
 * Stores information about Vercel Integrations. Each Vercel user/team creating an
 * integration to Hasura will have a row in this table.
 */
export type Vercel_IntegrationEnvironment_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/**
 * Stores information about Vercel Integrations. Each Vercel user/team creating an
 * integration to Hasura will have a row in this table.
 */
export type Vercel_IntegrationVercel_Integration_ConnectionsArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Connections_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Connections_Order_By>>;
  where?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
};

/**
 * Stores information about Vercel Integrations. Each Vercel user/team creating an
 * integration to Hasura will have a row in this table.
 */
export type Vercel_IntegrationVercel_Integration_Connections_AggregateArgs = {
  distinct_on?: Maybe<Array<Vercel_Integration_Connections_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<Array<Vercel_Integration_Connections_Order_By>>;
  where?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
};

/** aggregated selection of "vercel_integration" */
export type Vercel_Integration_Aggregate = {
  __typename?: 'vercel_integration_aggregate';
  aggregate?: Maybe<Vercel_Integration_Aggregate_Fields>;
  nodes: Array<Vercel_Integration>;
};

/** aggregate fields of "vercel_integration" */
export type Vercel_Integration_Aggregate_Fields = {
  __typename?: 'vercel_integration_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Vercel_Integration_Max_Fields>;
  min?: Maybe<Vercel_Integration_Min_Fields>;
};

/** aggregate fields of "vercel_integration" */
export type Vercel_Integration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Vercel_Integration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Vercel_Integration_Append_Input = {
  environment_variables?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "vercel_integration". All fields are combined with a logical 'AND'. */
export type Vercel_Integration_Bool_Exp = {
  _and?: Maybe<Array<Vercel_Integration_Bool_Exp>>;
  _not?: Maybe<Vercel_Integration_Bool_Exp>;
  _or?: Maybe<Array<Vercel_Integration_Bool_Exp>>;
  configuration_id?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  environment_variables?: Maybe<Jsonb_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  team_id?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
  vercel_integration_connections?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
  vercel_integration_connections_aggregate?: Maybe<Vercel_Integration_Connections_Aggregate_Bool_Exp>;
  vercel_user_id?: Maybe<String_Comparison_Exp>;
};

/** Stores the mapping information between Vercel Projects and Hasura Cloud projects. */
export type Vercel_Integration_Connections = {
  __typename?: 'vercel_integration_connections';
  created_at: Scalars['timestamp'];
  hasura_cloud_project_id?: Maybe<Scalars['uuid']>;
  id: Scalars['uuid'];
  /** An object relationship */
  project?: Maybe<Projects>;
  status: Scalars['String'];
  updated_at: Scalars['timestamp'];
  /** An object relationship */
  vercel_integration: Vercel_Integration;
  vercel_integration_id: Scalars['uuid'];
  vercel_project_id: Scalars['String'];
};

/** aggregated selection of "vercel_integration_connections" */
export type Vercel_Integration_Connections_Aggregate = {
  __typename?: 'vercel_integration_connections_aggregate';
  aggregate?: Maybe<Vercel_Integration_Connections_Aggregate_Fields>;
  nodes: Array<Vercel_Integration_Connections>;
};

export type Vercel_Integration_Connections_Aggregate_Bool_Exp = {
  count?: Maybe<Vercel_Integration_Connections_Aggregate_Bool_Exp_Count>;
};

export type Vercel_Integration_Connections_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Vercel_Integration_Connections_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "vercel_integration_connections" */
export type Vercel_Integration_Connections_Aggregate_Fields = {
  __typename?: 'vercel_integration_connections_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Vercel_Integration_Connections_Max_Fields>;
  min?: Maybe<Vercel_Integration_Connections_Min_Fields>;
};

/** aggregate fields of "vercel_integration_connections" */
export type Vercel_Integration_Connections_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Vercel_Integration_Connections_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "vercel_integration_connections" */
export type Vercel_Integration_Connections_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Vercel_Integration_Connections_Max_Order_By>;
  min?: Maybe<Vercel_Integration_Connections_Min_Order_By>;
};

/** input type for inserting array relation for remote table "vercel_integration_connections" */
export type Vercel_Integration_Connections_Arr_Rel_Insert_Input = {
  data: Array<Vercel_Integration_Connections_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Vercel_Integration_Connections_On_Conflict>;
};

/**
 * Boolean expression to filter rows from the table
 * "vercel_integration_connections". All fields are combined with a logical 'AND'.
 */
export type Vercel_Integration_Connections_Bool_Exp = {
  _and?: Maybe<Array<Vercel_Integration_Connections_Bool_Exp>>;
  _not?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
  _or?: Maybe<Array<Vercel_Integration_Connections_Bool_Exp>>;
  created_at?: Maybe<Timestamp_Comparison_Exp>;
  hasura_cloud_project_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  status?: Maybe<String_Comparison_Exp>;
  updated_at?: Maybe<Timestamp_Comparison_Exp>;
  vercel_integration?: Maybe<Vercel_Integration_Bool_Exp>;
  vercel_integration_id?: Maybe<Uuid_Comparison_Exp>;
  vercel_project_id?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "vercel_integration_connections" */
export enum Vercel_Integration_Connections_Constraint {
  /** unique or primary key constraint on columns "id" */
  VercelIntegrationConnectionsPkey = 'vercel_integration_connections_pkey',
}

/** input type for inserting data into table "vercel_integration_connections" */
export type Vercel_Integration_Connections_Insert_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  hasura_cloud_project_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  vercel_integration?: Maybe<Vercel_Integration_Obj_Rel_Insert_Input>;
  vercel_integration_id?: Maybe<Scalars['uuid']>;
  vercel_project_id?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Vercel_Integration_Connections_Max_Fields = {
  __typename?: 'vercel_integration_connections_max_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  hasura_cloud_project_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  vercel_integration_id?: Maybe<Scalars['uuid']>;
  vercel_project_id?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "vercel_integration_connections" */
export type Vercel_Integration_Connections_Max_Order_By = {
  created_at?: Maybe<Order_By>;
  hasura_cloud_project_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  vercel_integration_id?: Maybe<Order_By>;
  vercel_project_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Vercel_Integration_Connections_Min_Fields = {
  __typename?: 'vercel_integration_connections_min_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  hasura_cloud_project_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  vercel_integration_id?: Maybe<Scalars['uuid']>;
  vercel_project_id?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "vercel_integration_connections" */
export type Vercel_Integration_Connections_Min_Order_By = {
  created_at?: Maybe<Order_By>;
  hasura_cloud_project_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  vercel_integration_id?: Maybe<Order_By>;
  vercel_project_id?: Maybe<Order_By>;
};

/** response of any mutation on the table "vercel_integration_connections" */
export type Vercel_Integration_Connections_Mutation_Response = {
  __typename?: 'vercel_integration_connections_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Vercel_Integration_Connections>;
};

/** on_conflict condition type for table "vercel_integration_connections" */
export type Vercel_Integration_Connections_On_Conflict = {
  constraint: Vercel_Integration_Connections_Constraint;
  update_columns?: Array<Vercel_Integration_Connections_Update_Column>;
  where?: Maybe<Vercel_Integration_Connections_Bool_Exp>;
};

/** Ordering options when selecting data from "vercel_integration_connections". */
export type Vercel_Integration_Connections_Order_By = {
  created_at?: Maybe<Order_By>;
  hasura_cloud_project_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  vercel_integration?: Maybe<Vercel_Integration_Order_By>;
  vercel_integration_id?: Maybe<Order_By>;
  vercel_project_id?: Maybe<Order_By>;
};

/** primary key columns input for table: vercel_integration_connections */
export type Vercel_Integration_Connections_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "vercel_integration_connections" */
export enum Vercel_Integration_Connections_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HasuraCloudProjectId = 'hasura_cloud_project_id',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VercelIntegrationId = 'vercel_integration_id',
  /** column name */
  VercelProjectId = 'vercel_project_id',
}

/** input type for updating data in table "vercel_integration_connections" */
export type Vercel_Integration_Connections_Set_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  hasura_cloud_project_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  vercel_integration_id?: Maybe<Scalars['uuid']>;
  vercel_project_id?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "vercel_integration_connections" */
export type Vercel_Integration_Connections_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vercel_Integration_Connections_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vercel_Integration_Connections_Stream_Cursor_Value_Input = {
  created_at?: Maybe<Scalars['timestamp']>;
  hasura_cloud_project_id?: Maybe<Scalars['uuid']>;
  id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  vercel_integration_id?: Maybe<Scalars['uuid']>;
  vercel_project_id?: Maybe<Scalars['String']>;
};

/** update columns of table "vercel_integration_connections" */
export enum Vercel_Integration_Connections_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HasuraCloudProjectId = 'hasura_cloud_project_id',
  /** column name */
  Id = 'id',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VercelIntegrationId = 'vercel_integration_id',
  /** column name */
  VercelProjectId = 'vercel_project_id',
}

export type Vercel_Integration_Connections_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Vercel_Integration_Connections_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vercel_Integration_Connections_Bool_Exp;
};

/** unique or primary key constraints on table "vercel_integration" */
export enum Vercel_Integration_Constraint {
  /** unique or primary key constraint on columns "configuration_id" */
  VercelIntegrationConfigurationIdKey = 'vercel_integration_configuration_id_key',
  /** unique or primary key constraint on columns "id" */
  VercelIntegrationPkey = 'vercel_integration_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Vercel_Integration_Delete_At_Path_Input = {
  environment_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Vercel_Integration_Delete_Elem_Input = {
  environment_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Vercel_Integration_Delete_Key_Input = {
  environment_variables?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "vercel_integration" */
export type Vercel_Integration_Insert_Input = {
  configuration_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  environment_variables?: Maybe<Scalars['jsonb']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
  vercel_integration_connections?: Maybe<Vercel_Integration_Connections_Arr_Rel_Insert_Input>;
  vercel_user_id?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Vercel_Integration_Max_Fields = {
  __typename?: 'vercel_integration_max_fields';
  configuration_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  vercel_user_id?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Vercel_Integration_Min_Fields = {
  __typename?: 'vercel_integration_min_fields';
  configuration_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  vercel_user_id?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "vercel_integration" */
export type Vercel_Integration_Mutation_Response = {
  __typename?: 'vercel_integration_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Vercel_Integration>;
};

/** input type for inserting object relation for remote table "vercel_integration" */
export type Vercel_Integration_Obj_Rel_Insert_Input = {
  data: Vercel_Integration_Insert_Input;
  /** upsert condition */
  on_conflict?: Maybe<Vercel_Integration_On_Conflict>;
};

/** on_conflict condition type for table "vercel_integration" */
export type Vercel_Integration_On_Conflict = {
  constraint: Vercel_Integration_Constraint;
  update_columns?: Array<Vercel_Integration_Update_Column>;
  where?: Maybe<Vercel_Integration_Bool_Exp>;
};

/** Ordering options when selecting data from "vercel_integration". */
export type Vercel_Integration_Order_By = {
  configuration_id?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  environment_variables?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project_id?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  team_id?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
  vercel_integration_connections_aggregate?: Maybe<Vercel_Integration_Connections_Aggregate_Order_By>;
  vercel_user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: vercel_integration */
export type Vercel_Integration_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Vercel_Integration_Prepend_Input = {
  environment_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "vercel_integration" */
export enum Vercel_Integration_Select_Column {
  /** column name */
  ConfigurationId = 'configuration_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EnvironmentVariables = 'environment_variables',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
  /** column name */
  VercelUserId = 'vercel_user_id',
}

/** input type for updating data in table "vercel_integration" */
export type Vercel_Integration_Set_Input = {
  configuration_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  environment_variables?: Maybe<Scalars['jsonb']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  vercel_user_id?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "vercel_integration" */
export type Vercel_Integration_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vercel_Integration_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vercel_Integration_Stream_Cursor_Value_Input = {
  configuration_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  environment_variables?: Maybe<Scalars['jsonb']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  status?: Maybe<Scalars['String']>;
  team_id?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
  user_id?: Maybe<Scalars['uuid']>;
  vercel_user_id?: Maybe<Scalars['String']>;
};

/** update columns of table "vercel_integration" */
export enum Vercel_Integration_Update_Column {
  /** column name */
  ConfigurationId = 'configuration_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EnvironmentVariables = 'environment_variables',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  Status = 'status',
  /** column name */
  TeamId = 'team_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id',
  /** column name */
  VercelUserId = 'vercel_user_id',
}

export type Vercel_Integration_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Vercel_Integration_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Vercel_Integration_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Vercel_Integration_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Vercel_Integration_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Vercel_Integration_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Vercel_Integration_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vercel_Integration_Bool_Exp;
};

export type VercelGetProjectsOutput = {
  __typename?: 'VercelGetProjectsOutput';
  vercelProjects: Array<VercelProjectInfo>;
};

export type VercelIntegrationConnectionsInput = {
  hasura_cloud_project_id?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['String']>;
  status?: Maybe<Scalars['String']>;
  vercel_project_id?: Maybe<Scalars['String']>;
};

export type VercelProjectInfo = {
  __typename?: 'VercelProjectInfo';
  projectId: Scalars['String'];
  projectName: Scalars['String'];
};

export type VercelTokenInputPayload = {
  code: Scalars['String'];
  configuration_id: Scalars['String'];
  redirect_uri: Scalars['String'];
  team_id?: Maybe<Scalars['String']>;
};

/** Peering connections for a dedicated VPC */
export type Vpc_Peering = {
  __typename?: 'vpc_peering';
  aws_customer_account_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_additional_cidrs: Scalars['_text'];
  aws_customer_vpc_cidr?: Maybe<Scalars['String']>;
  aws_customer_vpc_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_region?: Maybe<Scalars['String']>;
  azure_input?: Maybe<Scalars['jsonb']>;
  comments?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamptz'];
  /** An object relationship */
  dedicated_vpc: Dedicated_Vpc;
  dedicated_vpc_id: Scalars['uuid'];
  destroy_requested: Scalars['Boolean'];
  direction: Vpc_Peering_Direction_Enum;
  disable_infra_auto_apply: Scalars['Boolean'];
  gcp_project_id?: Maybe<Scalars['String']>;
  gcp_vpc_network?: Maybe<Scalars['String']>;
  id: Scalars['uuid'];
  infra_status?: Maybe<Infra_Status_Enum>;
  message?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  output_variables?: Maybe<Scalars['jsonb']>;
  provisioning: Provisioning_Enum;
  /** update the value manually by referring to the infra status field */
  status: Vpc_Status_Enum;
  updated_at: Scalars['timestamptz'];
};

/** Peering connections for a dedicated VPC */
export type Vpc_PeeringAzure_InputArgs = {
  path?: Maybe<Scalars['String']>;
};

/** Peering connections for a dedicated VPC */
export type Vpc_PeeringOutput_VariablesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "vpc_peering" */
export type Vpc_Peering_Aggregate = {
  __typename?: 'vpc_peering_aggregate';
  aggregate?: Maybe<Vpc_Peering_Aggregate_Fields>;
  nodes: Array<Vpc_Peering>;
};

export type Vpc_Peering_Aggregate_Bool_Exp = {
  bool_and?: Maybe<Vpc_Peering_Aggregate_Bool_Exp_Bool_And>;
  bool_or?: Maybe<Vpc_Peering_Aggregate_Bool_Exp_Bool_Or>;
  count?: Maybe<Vpc_Peering_Aggregate_Bool_Exp_Count>;
};

export type Vpc_Peering_Aggregate_Bool_Exp_Bool_And = {
  arguments: Vpc_Peering_Select_Column_Vpc_Peering_Aggregate_Bool_Exp_Bool_And_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Vpc_Peering_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Vpc_Peering_Aggregate_Bool_Exp_Bool_Or = {
  arguments: Vpc_Peering_Select_Column_Vpc_Peering_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Vpc_Peering_Bool_Exp>;
  predicate: Boolean_Comparison_Exp;
};

export type Vpc_Peering_Aggregate_Bool_Exp_Count = {
  arguments?: Maybe<Array<Vpc_Peering_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
  filter?: Maybe<Vpc_Peering_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "vpc_peering" */
export type Vpc_Peering_Aggregate_Fields = {
  __typename?: 'vpc_peering_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Vpc_Peering_Max_Fields>;
  min?: Maybe<Vpc_Peering_Min_Fields>;
};

/** aggregate fields of "vpc_peering" */
export type Vpc_Peering_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Vpc_Peering_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "vpc_peering" */
export type Vpc_Peering_Aggregate_Order_By = {
  count?: Maybe<Order_By>;
  max?: Maybe<Vpc_Peering_Max_Order_By>;
  min?: Maybe<Vpc_Peering_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Vpc_Peering_Append_Input = {
  azure_input?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "vpc_peering" */
export type Vpc_Peering_Arr_Rel_Insert_Input = {
  data: Array<Vpc_Peering_Insert_Input>;
  /** upsert condition */
  on_conflict?: Maybe<Vpc_Peering_On_Conflict>;
};

/** Boolean expression to filter rows from the table "vpc_peering". All fields are combined with a logical 'AND'. */
export type Vpc_Peering_Bool_Exp = {
  _and?: Maybe<Array<Vpc_Peering_Bool_Exp>>;
  _not?: Maybe<Vpc_Peering_Bool_Exp>;
  _or?: Maybe<Array<Vpc_Peering_Bool_Exp>>;
  aws_customer_account_id?: Maybe<String_Comparison_Exp>;
  aws_customer_vpc_additional_cidrs?: Maybe<_Text_Comparison_Exp>;
  aws_customer_vpc_cidr?: Maybe<String_Comparison_Exp>;
  aws_customer_vpc_id?: Maybe<String_Comparison_Exp>;
  aws_customer_vpc_region?: Maybe<String_Comparison_Exp>;
  azure_input?: Maybe<Jsonb_Comparison_Exp>;
  comments?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Bool_Exp>;
  dedicated_vpc_id?: Maybe<Uuid_Comparison_Exp>;
  destroy_requested?: Maybe<Boolean_Comparison_Exp>;
  direction?: Maybe<Vpc_Peering_Direction_Enum_Comparison_Exp>;
  disable_infra_auto_apply?: Maybe<Boolean_Comparison_Exp>;
  gcp_project_id?: Maybe<String_Comparison_Exp>;
  gcp_vpc_network?: Maybe<String_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  infra_status?: Maybe<Infra_Status_Enum_Comparison_Exp>;
  message?: Maybe<String_Comparison_Exp>;
  name?: Maybe<String_Comparison_Exp>;
  output_variables?: Maybe<Jsonb_Comparison_Exp>;
  provisioning?: Maybe<Provisioning_Enum_Comparison_Exp>;
  status?: Maybe<Vpc_Status_Enum_Comparison_Exp>;
  updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "vpc_peering" */
export enum Vpc_Peering_Constraint {
  /** unique or primary key constraint on columns "id" */
  VpcPeeringPkey = 'vpc_peering_pkey',
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Vpc_Peering_Delete_At_Path_Input = {
  azure_input?: Maybe<Array<Scalars['String']>>;
  output_variables?: Maybe<Array<Scalars['String']>>;
};

/**
 * delete the array element with specified index (negative integers count from the
 * end). throws an error if top level container is not an array
 */
export type Vpc_Peering_Delete_Elem_Input = {
  azure_input?: Maybe<Scalars['Int']>;
  output_variables?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Vpc_Peering_Delete_Key_Input = {
  azure_input?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['String']>;
};

/** Hasura enum capturing the direction of peering connection */
export type Vpc_Peering_Direction = {
  __typename?: 'vpc_peering_direction';
  comment?: Maybe<Scalars['String']>;
  direction: Scalars['String'];
};

/** aggregated selection of "vpc_peering_direction" */
export type Vpc_Peering_Direction_Aggregate = {
  __typename?: 'vpc_peering_direction_aggregate';
  aggregate?: Maybe<Vpc_Peering_Direction_Aggregate_Fields>;
  nodes: Array<Vpc_Peering_Direction>;
};

/** aggregate fields of "vpc_peering_direction" */
export type Vpc_Peering_Direction_Aggregate_Fields = {
  __typename?: 'vpc_peering_direction_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Vpc_Peering_Direction_Max_Fields>;
  min?: Maybe<Vpc_Peering_Direction_Min_Fields>;
};

/** aggregate fields of "vpc_peering_direction" */
export type Vpc_Peering_Direction_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Vpc_Peering_Direction_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "vpc_peering_direction". All fields are combined with a logical 'AND'. */
export type Vpc_Peering_Direction_Bool_Exp = {
  _and?: Maybe<Array<Vpc_Peering_Direction_Bool_Exp>>;
  _not?: Maybe<Vpc_Peering_Direction_Bool_Exp>;
  _or?: Maybe<Array<Vpc_Peering_Direction_Bool_Exp>>;
  comment?: Maybe<String_Comparison_Exp>;
  direction?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "vpc_peering_direction" */
export enum Vpc_Peering_Direction_Constraint {
  /** unique or primary key constraint on columns "direction" */
  VpcPeeringDirectionPkey = 'vpc_peering_direction_pkey',
}

export enum Vpc_Peering_Direction_Enum {
  /** Accept the peering request initiated by the customer */
  CustomerToHasura = 'customer_to_hasura',
  /** Peering request will be created from Hasura account */
  HasuraToCustomer = 'hasura_to_customer',
}

/** Boolean expression to compare columns of type "vpc_peering_direction_enum". All fields are combined with logical 'AND'. */
export type Vpc_Peering_Direction_Enum_Comparison_Exp = {
  _eq?: Maybe<Vpc_Peering_Direction_Enum>;
  _in?: Maybe<Array<Vpc_Peering_Direction_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Vpc_Peering_Direction_Enum>;
  _nin?: Maybe<Array<Vpc_Peering_Direction_Enum>>;
};

/** input type for inserting data into table "vpc_peering_direction" */
export type Vpc_Peering_Direction_Insert_Input = {
  comment?: Maybe<Scalars['String']>;
  direction?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Vpc_Peering_Direction_Max_Fields = {
  __typename?: 'vpc_peering_direction_max_fields';
  comment?: Maybe<Scalars['String']>;
  direction?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Vpc_Peering_Direction_Min_Fields = {
  __typename?: 'vpc_peering_direction_min_fields';
  comment?: Maybe<Scalars['String']>;
  direction?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "vpc_peering_direction" */
export type Vpc_Peering_Direction_Mutation_Response = {
  __typename?: 'vpc_peering_direction_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Vpc_Peering_Direction>;
};

/** on_conflict condition type for table "vpc_peering_direction" */
export type Vpc_Peering_Direction_On_Conflict = {
  constraint: Vpc_Peering_Direction_Constraint;
  update_columns?: Array<Vpc_Peering_Direction_Update_Column>;
  where?: Maybe<Vpc_Peering_Direction_Bool_Exp>;
};

/** Ordering options when selecting data from "vpc_peering_direction". */
export type Vpc_Peering_Direction_Order_By = {
  comment?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
};

/** primary key columns input for table: vpc_peering_direction */
export type Vpc_Peering_Direction_Pk_Columns_Input = {
  direction: Scalars['String'];
};

/** select columns of table "vpc_peering_direction" */
export enum Vpc_Peering_Direction_Select_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Direction = 'direction',
}

/** input type for updating data in table "vpc_peering_direction" */
export type Vpc_Peering_Direction_Set_Input = {
  comment?: Maybe<Scalars['String']>;
  direction?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "vpc_peering_direction" */
export type Vpc_Peering_Direction_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vpc_Peering_Direction_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vpc_Peering_Direction_Stream_Cursor_Value_Input = {
  comment?: Maybe<Scalars['String']>;
  direction?: Maybe<Scalars['String']>;
};

/** update columns of table "vpc_peering_direction" */
export enum Vpc_Peering_Direction_Update_Column {
  /** column name */
  Comment = 'comment',
  /** column name */
  Direction = 'direction',
}

export type Vpc_Peering_Direction_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Vpc_Peering_Direction_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vpc_Peering_Direction_Bool_Exp;
};

/** input type for inserting data into table "vpc_peering" */
export type Vpc_Peering_Insert_Input = {
  aws_customer_account_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_additional_cidrs?: Maybe<Scalars['_text']>;
  aws_customer_vpc_cidr?: Maybe<Scalars['String']>;
  aws_customer_vpc_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_region?: Maybe<Scalars['String']>;
  azure_input?: Maybe<Scalars['jsonb']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Obj_Rel_Insert_Input>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  destroy_requested?: Maybe<Scalars['Boolean']>;
  direction?: Maybe<Vpc_Peering_Direction_Enum>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  gcp_project_id?: Maybe<Scalars['String']>;
  gcp_vpc_network?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  message?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  provisioning?: Maybe<Provisioning_Enum>;
  /** update the value manually by referring to the infra status field */
  status?: Maybe<Vpc_Status_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Vpc_Peering_Max_Fields = {
  __typename?: 'vpc_peering_max_fields';
  aws_customer_account_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_cidr?: Maybe<Scalars['String']>;
  aws_customer_vpc_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_region?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  gcp_project_id?: Maybe<Scalars['String']>;
  gcp_vpc_network?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "vpc_peering" */
export type Vpc_Peering_Max_Order_By = {
  aws_customer_account_id?: Maybe<Order_By>;
  aws_customer_vpc_cidr?: Maybe<Order_By>;
  aws_customer_vpc_id?: Maybe<Order_By>;
  aws_customer_vpc_region?: Maybe<Order_By>;
  comments?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dedicated_vpc_id?: Maybe<Order_By>;
  gcp_project_id?: Maybe<Order_By>;
  gcp_vpc_network?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Vpc_Peering_Min_Fields = {
  __typename?: 'vpc_peering_min_fields';
  aws_customer_account_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_cidr?: Maybe<Scalars['String']>;
  aws_customer_vpc_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_region?: Maybe<Scalars['String']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  gcp_project_id?: Maybe<Scalars['String']>;
  gcp_vpc_network?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  message?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "vpc_peering" */
export type Vpc_Peering_Min_Order_By = {
  aws_customer_account_id?: Maybe<Order_By>;
  aws_customer_vpc_cidr?: Maybe<Order_By>;
  aws_customer_vpc_id?: Maybe<Order_By>;
  aws_customer_vpc_region?: Maybe<Order_By>;
  comments?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dedicated_vpc_id?: Maybe<Order_By>;
  gcp_project_id?: Maybe<Order_By>;
  gcp_vpc_network?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "vpc_peering" */
export type Vpc_Peering_Mutation_Response = {
  __typename?: 'vpc_peering_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Vpc_Peering>;
};

/** on_conflict condition type for table "vpc_peering" */
export type Vpc_Peering_On_Conflict = {
  constraint: Vpc_Peering_Constraint;
  update_columns?: Array<Vpc_Peering_Update_Column>;
  where?: Maybe<Vpc_Peering_Bool_Exp>;
};

/** Ordering options when selecting data from "vpc_peering". */
export type Vpc_Peering_Order_By = {
  aws_customer_account_id?: Maybe<Order_By>;
  aws_customer_vpc_additional_cidrs?: Maybe<Order_By>;
  aws_customer_vpc_cidr?: Maybe<Order_By>;
  aws_customer_vpc_id?: Maybe<Order_By>;
  aws_customer_vpc_region?: Maybe<Order_By>;
  azure_input?: Maybe<Order_By>;
  comments?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  dedicated_vpc?: Maybe<Dedicated_Vpc_Order_By>;
  dedicated_vpc_id?: Maybe<Order_By>;
  destroy_requested?: Maybe<Order_By>;
  direction?: Maybe<Order_By>;
  disable_infra_auto_apply?: Maybe<Order_By>;
  gcp_project_id?: Maybe<Order_By>;
  gcp_vpc_network?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  infra_status?: Maybe<Order_By>;
  message?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  output_variables?: Maybe<Order_By>;
  provisioning?: Maybe<Order_By>;
  status?: Maybe<Order_By>;
  updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: vpc_peering */
export type Vpc_Peering_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Vpc_Peering_Prepend_Input = {
  azure_input?: Maybe<Scalars['jsonb']>;
  output_variables?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "vpc_peering" */
export enum Vpc_Peering_Select_Column {
  /** column name */
  AwsCustomerAccountId = 'aws_customer_account_id',
  /** column name */
  AwsCustomerVpcAdditionalCidrs = 'aws_customer_vpc_additional_cidrs',
  /** column name */
  AwsCustomerVpcCidr = 'aws_customer_vpc_cidr',
  /** column name */
  AwsCustomerVpcId = 'aws_customer_vpc_id',
  /** column name */
  AwsCustomerVpcRegion = 'aws_customer_vpc_region',
  /** column name */
  AzureInput = 'azure_input',
  /** column name */
  Comments = 'comments',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DedicatedVpcId = 'dedicated_vpc_id',
  /** column name */
  DestroyRequested = 'destroy_requested',
  /** column name */
  Direction = 'direction',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  GcpProjectId = 'gcp_project_id',
  /** column name */
  GcpVpcNetwork = 'gcp_vpc_network',
  /** column name */
  Id = 'id',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  Message = 'message',
  /** column name */
  Name = 'name',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  Provisioning = 'provisioning',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

/** select "vpc_peering_aggregate_bool_exp_bool_and_arguments_columns" columns of table "vpc_peering" */
export enum Vpc_Peering_Select_Column_Vpc_Peering_Aggregate_Bool_Exp_Bool_And_Arguments_Columns {
  /** column name */
  DestroyRequested = 'destroy_requested',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
}

/** select "vpc_peering_aggregate_bool_exp_bool_or_arguments_columns" columns of table "vpc_peering" */
export enum Vpc_Peering_Select_Column_Vpc_Peering_Aggregate_Bool_Exp_Bool_Or_Arguments_Columns {
  /** column name */
  DestroyRequested = 'destroy_requested',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
}

/** input type for updating data in table "vpc_peering" */
export type Vpc_Peering_Set_Input = {
  aws_customer_account_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_additional_cidrs?: Maybe<Scalars['_text']>;
  aws_customer_vpc_cidr?: Maybe<Scalars['String']>;
  aws_customer_vpc_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_region?: Maybe<Scalars['String']>;
  azure_input?: Maybe<Scalars['jsonb']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  destroy_requested?: Maybe<Scalars['Boolean']>;
  direction?: Maybe<Vpc_Peering_Direction_Enum>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  gcp_project_id?: Maybe<Scalars['String']>;
  gcp_vpc_network?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  message?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  provisioning?: Maybe<Provisioning_Enum>;
  /** update the value manually by referring to the infra status field */
  status?: Maybe<Vpc_Status_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** Streaming cursor of the table "vpc_peering" */
export type Vpc_Peering_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vpc_Peering_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vpc_Peering_Stream_Cursor_Value_Input = {
  aws_customer_account_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_additional_cidrs?: Maybe<Scalars['_text']>;
  aws_customer_vpc_cidr?: Maybe<Scalars['String']>;
  aws_customer_vpc_id?: Maybe<Scalars['String']>;
  aws_customer_vpc_region?: Maybe<Scalars['String']>;
  azure_input?: Maybe<Scalars['jsonb']>;
  comments?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  dedicated_vpc_id?: Maybe<Scalars['uuid']>;
  destroy_requested?: Maybe<Scalars['Boolean']>;
  direction?: Maybe<Vpc_Peering_Direction_Enum>;
  disable_infra_auto_apply?: Maybe<Scalars['Boolean']>;
  gcp_project_id?: Maybe<Scalars['String']>;
  gcp_vpc_network?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['uuid']>;
  infra_status?: Maybe<Infra_Status_Enum>;
  message?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  output_variables?: Maybe<Scalars['jsonb']>;
  provisioning?: Maybe<Provisioning_Enum>;
  /** update the value manually by referring to the infra status field */
  status?: Maybe<Vpc_Status_Enum>;
  updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "vpc_peering" */
export enum Vpc_Peering_Update_Column {
  /** column name */
  AwsCustomerAccountId = 'aws_customer_account_id',
  /** column name */
  AwsCustomerVpcAdditionalCidrs = 'aws_customer_vpc_additional_cidrs',
  /** column name */
  AwsCustomerVpcCidr = 'aws_customer_vpc_cidr',
  /** column name */
  AwsCustomerVpcId = 'aws_customer_vpc_id',
  /** column name */
  AwsCustomerVpcRegion = 'aws_customer_vpc_region',
  /** column name */
  AzureInput = 'azure_input',
  /** column name */
  Comments = 'comments',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DedicatedVpcId = 'dedicated_vpc_id',
  /** column name */
  DestroyRequested = 'destroy_requested',
  /** column name */
  Direction = 'direction',
  /** column name */
  DisableInfraAutoApply = 'disable_infra_auto_apply',
  /** column name */
  GcpProjectId = 'gcp_project_id',
  /** column name */
  GcpVpcNetwork = 'gcp_vpc_network',
  /** column name */
  Id = 'id',
  /** column name */
  InfraStatus = 'infra_status',
  /** column name */
  Message = 'message',
  /** column name */
  Name = 'name',
  /** column name */
  OutputVariables = 'output_variables',
  /** column name */
  Provisioning = 'provisioning',
  /** column name */
  Status = 'status',
  /** column name */
  UpdatedAt = 'updated_at',
}

export type Vpc_Peering_Updates = {
  /** append existing jsonb value of filtered columns with new jsonb value */
  _append?: Maybe<Vpc_Peering_Append_Input>;
  /** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
  _delete_at_path?: Maybe<Vpc_Peering_Delete_At_Path_Input>;
  /**
   * delete the array element with specified index (negative integers count from
   * the end). throws an error if top level container is not an array
   */
  _delete_elem?: Maybe<Vpc_Peering_Delete_Elem_Input>;
  /** delete key/value pair or string element. key/value pairs are matched based on their key value */
  _delete_key?: Maybe<Vpc_Peering_Delete_Key_Input>;
  /** prepend existing jsonb value of filtered columns with new jsonb value */
  _prepend?: Maybe<Vpc_Peering_Prepend_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Vpc_Peering_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vpc_Peering_Bool_Exp;
};

/** Hasura enum to capture supported status for vpc. This enum is used in dedicated_vpc */
export type Vpc_Status = {
  __typename?: 'vpc_status';
  status: Scalars['String'];
};

/** aggregated selection of "vpc_status" */
export type Vpc_Status_Aggregate = {
  __typename?: 'vpc_status_aggregate';
  aggregate?: Maybe<Vpc_Status_Aggregate_Fields>;
  nodes: Array<Vpc_Status>;
};

/** aggregate fields of "vpc_status" */
export type Vpc_Status_Aggregate_Fields = {
  __typename?: 'vpc_status_aggregate_fields';
  count: Scalars['Int'];
  max?: Maybe<Vpc_Status_Max_Fields>;
  min?: Maybe<Vpc_Status_Min_Fields>;
};

/** aggregate fields of "vpc_status" */
export type Vpc_Status_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Vpc_Status_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "vpc_status". All fields are combined with a logical 'AND'. */
export type Vpc_Status_Bool_Exp = {
  _and?: Maybe<Array<Vpc_Status_Bool_Exp>>;
  _not?: Maybe<Vpc_Status_Bool_Exp>;
  _or?: Maybe<Array<Vpc_Status_Bool_Exp>>;
  status?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "vpc_status" */
export enum Vpc_Status_Constraint {
  /** unique or primary key constraint on columns "status" */
  VpcStatusPkey = 'vpc_status_pkey',
}

export enum Vpc_Status_Enum {
  Active = 'active',
  Destroyed = 'destroyed',
  Failed = 'failed',
  Pending = 'pending',
  PendingAcceptance = 'pending_acceptance',
  PendingDestroy = 'pending_destroy',
  Provisioning = 'provisioning',
}

/** Boolean expression to compare columns of type "vpc_status_enum". All fields are combined with logical 'AND'. */
export type Vpc_Status_Enum_Comparison_Exp = {
  _eq?: Maybe<Vpc_Status_Enum>;
  _in?: Maybe<Array<Vpc_Status_Enum>>;
  _is_null?: Maybe<Scalars['Boolean']>;
  _neq?: Maybe<Vpc_Status_Enum>;
  _nin?: Maybe<Array<Vpc_Status_Enum>>;
};

/** input type for inserting data into table "vpc_status" */
export type Vpc_Status_Insert_Input = {
  status?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Vpc_Status_Max_Fields = {
  __typename?: 'vpc_status_max_fields';
  status?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Vpc_Status_Min_Fields = {
  __typename?: 'vpc_status_min_fields';
  status?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "vpc_status" */
export type Vpc_Status_Mutation_Response = {
  __typename?: 'vpc_status_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Vpc_Status>;
};

/** on_conflict condition type for table "vpc_status" */
export type Vpc_Status_On_Conflict = {
  constraint: Vpc_Status_Constraint;
  update_columns?: Array<Vpc_Status_Update_Column>;
  where?: Maybe<Vpc_Status_Bool_Exp>;
};

/** Ordering options when selecting data from "vpc_status". */
export type Vpc_Status_Order_By = {
  status?: Maybe<Order_By>;
};

/** primary key columns input for table: vpc_status */
export type Vpc_Status_Pk_Columns_Input = {
  status: Scalars['String'];
};

/** select columns of table "vpc_status" */
export enum Vpc_Status_Select_Column {
  /** column name */
  Status = 'status',
}

/** input type for updating data in table "vpc_status" */
export type Vpc_Status_Set_Input = {
  status?: Maybe<Scalars['String']>;
};

/** Streaming cursor of the table "vpc_status" */
export type Vpc_Status_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Vpc_Status_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Vpc_Status_Stream_Cursor_Value_Input = {
  status?: Maybe<Scalars['String']>;
};

/** update columns of table "vpc_status" */
export enum Vpc_Status_Update_Column {
  /** column name */
  Status = 'status',
}

export type Vpc_Status_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Vpc_Status_Set_Input>;
  /** filter the rows which have to be updated */
  where: Vpc_Status_Bool_Exp;
};

export type WebhookRegisterStatus = {
  __typename?: 'WebhookRegisterStatus';
  status: Scalars['String'];
};

export type WebhookUnregisterStatus = {
  __typename?: 'WebhookUnregisterStatus';
  status: Scalars['String'];
};

/** columns and relationships of "zendesk_support_category" */
export type Zendesk_Support_Category = {
  __typename?: 'zendesk_support_category';
  name: Scalars['String'];
  zendesk_group_id: Scalars['bigint'];
};

/** aggregated selection of "zendesk_support_category" */
export type Zendesk_Support_Category_Aggregate = {
  __typename?: 'zendesk_support_category_aggregate';
  aggregate?: Maybe<Zendesk_Support_Category_Aggregate_Fields>;
  nodes: Array<Zendesk_Support_Category>;
};

/** aggregate fields of "zendesk_support_category" */
export type Zendesk_Support_Category_Aggregate_Fields = {
  __typename?: 'zendesk_support_category_aggregate_fields';
  avg?: Maybe<Zendesk_Support_Category_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Zendesk_Support_Category_Max_Fields>;
  min?: Maybe<Zendesk_Support_Category_Min_Fields>;
  stddev?: Maybe<Zendesk_Support_Category_Stddev_Fields>;
  stddev_pop?: Maybe<Zendesk_Support_Category_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Zendesk_Support_Category_Stddev_Samp_Fields>;
  sum?: Maybe<Zendesk_Support_Category_Sum_Fields>;
  var_pop?: Maybe<Zendesk_Support_Category_Var_Pop_Fields>;
  var_samp?: Maybe<Zendesk_Support_Category_Var_Samp_Fields>;
  variance?: Maybe<Zendesk_Support_Category_Variance_Fields>;
};

/** aggregate fields of "zendesk_support_category" */
export type Zendesk_Support_Category_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Zendesk_Support_Category_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Zendesk_Support_Category_Avg_Fields = {
  __typename?: 'zendesk_support_category_avg_fields';
  zendesk_group_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "zendesk_support_category". All fields are combined with a logical 'AND'. */
export type Zendesk_Support_Category_Bool_Exp = {
  _and?: Maybe<Array<Zendesk_Support_Category_Bool_Exp>>;
  _not?: Maybe<Zendesk_Support_Category_Bool_Exp>;
  _or?: Maybe<Array<Zendesk_Support_Category_Bool_Exp>>;
  name?: Maybe<String_Comparison_Exp>;
  zendesk_group_id?: Maybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "zendesk_support_category" */
export enum Zendesk_Support_Category_Constraint {
  /** unique or primary key constraint on columns "name" */
  ZendeskSupportCategoryPkey = 'zendesk_support_category_pkey',
}

/** input type for incrementing numeric columns in table "zendesk_support_category" */
export type Zendesk_Support_Category_Inc_Input = {
  zendesk_group_id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "zendesk_support_category" */
export type Zendesk_Support_Category_Insert_Input = {
  name?: Maybe<Scalars['String']>;
  zendesk_group_id?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Zendesk_Support_Category_Max_Fields = {
  __typename?: 'zendesk_support_category_max_fields';
  name?: Maybe<Scalars['String']>;
  zendesk_group_id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Zendesk_Support_Category_Min_Fields = {
  __typename?: 'zendesk_support_category_min_fields';
  name?: Maybe<Scalars['String']>;
  zendesk_group_id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "zendesk_support_category" */
export type Zendesk_Support_Category_Mutation_Response = {
  __typename?: 'zendesk_support_category_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Zendesk_Support_Category>;
};

/** on_conflict condition type for table "zendesk_support_category" */
export type Zendesk_Support_Category_On_Conflict = {
  constraint: Zendesk_Support_Category_Constraint;
  update_columns?: Array<Zendesk_Support_Category_Update_Column>;
  where?: Maybe<Zendesk_Support_Category_Bool_Exp>;
};

/** Ordering options when selecting data from "zendesk_support_category". */
export type Zendesk_Support_Category_Order_By = {
  name?: Maybe<Order_By>;
  zendesk_group_id?: Maybe<Order_By>;
};

/** primary key columns input for table: zendesk_support_category */
export type Zendesk_Support_Category_Pk_Columns_Input = {
  name: Scalars['String'];
};

/** select columns of table "zendesk_support_category" */
export enum Zendesk_Support_Category_Select_Column {
  /** column name */
  Name = 'name',
  /** column name */
  ZendeskGroupId = 'zendesk_group_id',
}

/** input type for updating data in table "zendesk_support_category" */
export type Zendesk_Support_Category_Set_Input = {
  name?: Maybe<Scalars['String']>;
  zendesk_group_id?: Maybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Zendesk_Support_Category_Stddev_Fields = {
  __typename?: 'zendesk_support_category_stddev_fields';
  zendesk_group_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Zendesk_Support_Category_Stddev_Pop_Fields = {
  __typename?: 'zendesk_support_category_stddev_pop_fields';
  zendesk_group_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Zendesk_Support_Category_Stddev_Samp_Fields = {
  __typename?: 'zendesk_support_category_stddev_samp_fields';
  zendesk_group_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "zendesk_support_category" */
export type Zendesk_Support_Category_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Zendesk_Support_Category_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Zendesk_Support_Category_Stream_Cursor_Value_Input = {
  name?: Maybe<Scalars['String']>;
  zendesk_group_id?: Maybe<Scalars['bigint']>;
};

/** aggregate sum on columns */
export type Zendesk_Support_Category_Sum_Fields = {
  __typename?: 'zendesk_support_category_sum_fields';
  zendesk_group_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "zendesk_support_category" */
export enum Zendesk_Support_Category_Update_Column {
  /** column name */
  Name = 'name',
  /** column name */
  ZendeskGroupId = 'zendesk_group_id',
}

export type Zendesk_Support_Category_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Zendesk_Support_Category_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Zendesk_Support_Category_Set_Input>;
  /** filter the rows which have to be updated */
  where: Zendesk_Support_Category_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Zendesk_Support_Category_Var_Pop_Fields = {
  __typename?: 'zendesk_support_category_var_pop_fields';
  zendesk_group_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Zendesk_Support_Category_Var_Samp_Fields = {
  __typename?: 'zendesk_support_category_var_samp_fields';
  zendesk_group_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Zendesk_Support_Category_Variance_Fields = {
  __typename?: 'zendesk_support_category_variance_fields';
  zendesk_group_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "zendesk_support_tickets" */
export type Zendesk_Support_Tickets = {
  __typename?: 'zendesk_support_tickets';
  category_name: Scalars['String'];
  created_at?: Maybe<Scalars['timestamptz']>;
  id: Scalars['uuid'];
  /** An object relationship */
  project?: Maybe<Projects>;
  project_id?: Maybe<Scalars['uuid']>;
  ticket_id: Scalars['bigint'];
  /** An object relationship */
  user: Users;
  user_id: Scalars['uuid'];
};

/** aggregated selection of "zendesk_support_tickets" */
export type Zendesk_Support_Tickets_Aggregate = {
  __typename?: 'zendesk_support_tickets_aggregate';
  aggregate?: Maybe<Zendesk_Support_Tickets_Aggregate_Fields>;
  nodes: Array<Zendesk_Support_Tickets>;
};

/** aggregate fields of "zendesk_support_tickets" */
export type Zendesk_Support_Tickets_Aggregate_Fields = {
  __typename?: 'zendesk_support_tickets_aggregate_fields';
  avg?: Maybe<Zendesk_Support_Tickets_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Zendesk_Support_Tickets_Max_Fields>;
  min?: Maybe<Zendesk_Support_Tickets_Min_Fields>;
  stddev?: Maybe<Zendesk_Support_Tickets_Stddev_Fields>;
  stddev_pop?: Maybe<Zendesk_Support_Tickets_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Zendesk_Support_Tickets_Stddev_Samp_Fields>;
  sum?: Maybe<Zendesk_Support_Tickets_Sum_Fields>;
  var_pop?: Maybe<Zendesk_Support_Tickets_Var_Pop_Fields>;
  var_samp?: Maybe<Zendesk_Support_Tickets_Var_Samp_Fields>;
  variance?: Maybe<Zendesk_Support_Tickets_Variance_Fields>;
};

/** aggregate fields of "zendesk_support_tickets" */
export type Zendesk_Support_Tickets_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Zendesk_Support_Tickets_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Zendesk_Support_Tickets_Avg_Fields = {
  __typename?: 'zendesk_support_tickets_avg_fields';
  ticket_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "zendesk_support_tickets". All fields are combined with a logical 'AND'. */
export type Zendesk_Support_Tickets_Bool_Exp = {
  _and?: Maybe<Array<Zendesk_Support_Tickets_Bool_Exp>>;
  _not?: Maybe<Zendesk_Support_Tickets_Bool_Exp>;
  _or?: Maybe<Array<Zendesk_Support_Tickets_Bool_Exp>>;
  category_name?: Maybe<String_Comparison_Exp>;
  created_at?: Maybe<Timestamptz_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  project?: Maybe<Projects_Bool_Exp>;
  project_id?: Maybe<Uuid_Comparison_Exp>;
  ticket_id?: Maybe<Bigint_Comparison_Exp>;
  user?: Maybe<Users_Bool_Exp>;
  user_id?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "zendesk_support_tickets" */
export enum Zendesk_Support_Tickets_Constraint {
  /** unique or primary key constraint on columns "id" */
  ZendeskSupportTicketsPkey = 'zendesk_support_tickets_pkey',
}

/** input type for incrementing numeric columns in table "zendesk_support_tickets" */
export type Zendesk_Support_Tickets_Inc_Input = {
  ticket_id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "zendesk_support_tickets" */
export type Zendesk_Support_Tickets_Insert_Input = {
  category_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project?: Maybe<Projects_Obj_Rel_Insert_Input>;
  project_id?: Maybe<Scalars['uuid']>;
  ticket_id?: Maybe<Scalars['bigint']>;
  user?: Maybe<Users_Obj_Rel_Insert_Input>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Zendesk_Support_Tickets_Max_Fields = {
  __typename?: 'zendesk_support_tickets_max_fields';
  category_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  ticket_id?: Maybe<Scalars['bigint']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Zendesk_Support_Tickets_Min_Fields = {
  __typename?: 'zendesk_support_tickets_min_fields';
  category_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  ticket_id?: Maybe<Scalars['bigint']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "zendesk_support_tickets" */
export type Zendesk_Support_Tickets_Mutation_Response = {
  __typename?: 'zendesk_support_tickets_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Zendesk_Support_Tickets>;
};

/** on_conflict condition type for table "zendesk_support_tickets" */
export type Zendesk_Support_Tickets_On_Conflict = {
  constraint: Zendesk_Support_Tickets_Constraint;
  update_columns?: Array<Zendesk_Support_Tickets_Update_Column>;
  where?: Maybe<Zendesk_Support_Tickets_Bool_Exp>;
};

/** Ordering options when selecting data from "zendesk_support_tickets". */
export type Zendesk_Support_Tickets_Order_By = {
  category_name?: Maybe<Order_By>;
  created_at?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  project?: Maybe<Projects_Order_By>;
  project_id?: Maybe<Order_By>;
  ticket_id?: Maybe<Order_By>;
  user?: Maybe<Users_Order_By>;
  user_id?: Maybe<Order_By>;
};

/** primary key columns input for table: zendesk_support_tickets */
export type Zendesk_Support_Tickets_Pk_Columns_Input = {
  id: Scalars['uuid'];
};

/** select columns of table "zendesk_support_tickets" */
export enum Zendesk_Support_Tickets_Select_Column {
  /** column name */
  CategoryName = 'category_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  TicketId = 'ticket_id',
  /** column name */
  UserId = 'user_id',
}

/** input type for updating data in table "zendesk_support_tickets" */
export type Zendesk_Support_Tickets_Set_Input = {
  category_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  ticket_id?: Maybe<Scalars['bigint']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Zendesk_Support_Tickets_Stddev_Fields = {
  __typename?: 'zendesk_support_tickets_stddev_fields';
  ticket_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Zendesk_Support_Tickets_Stddev_Pop_Fields = {
  __typename?: 'zendesk_support_tickets_stddev_pop_fields';
  ticket_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Zendesk_Support_Tickets_Stddev_Samp_Fields = {
  __typename?: 'zendesk_support_tickets_stddev_samp_fields';
  ticket_id?: Maybe<Scalars['Float']>;
};

/** Streaming cursor of the table "zendesk_support_tickets" */
export type Zendesk_Support_Tickets_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Zendesk_Support_Tickets_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: Maybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Zendesk_Support_Tickets_Stream_Cursor_Value_Input = {
  category_name?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamptz']>;
  id?: Maybe<Scalars['uuid']>;
  project_id?: Maybe<Scalars['uuid']>;
  ticket_id?: Maybe<Scalars['bigint']>;
  user_id?: Maybe<Scalars['uuid']>;
};

/** aggregate sum on columns */
export type Zendesk_Support_Tickets_Sum_Fields = {
  __typename?: 'zendesk_support_tickets_sum_fields';
  ticket_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "zendesk_support_tickets" */
export enum Zendesk_Support_Tickets_Update_Column {
  /** column name */
  CategoryName = 'category_name',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ProjectId = 'project_id',
  /** column name */
  TicketId = 'ticket_id',
  /** column name */
  UserId = 'user_id',
}

export type Zendesk_Support_Tickets_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: Maybe<Zendesk_Support_Tickets_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: Maybe<Zendesk_Support_Tickets_Set_Input>;
  /** filter the rows which have to be updated */
  where: Zendesk_Support_Tickets_Bool_Exp;
};

/** aggregate var_pop on columns */
export type Zendesk_Support_Tickets_Var_Pop_Fields = {
  __typename?: 'zendesk_support_tickets_var_pop_fields';
  ticket_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Zendesk_Support_Tickets_Var_Samp_Fields = {
  __typename?: 'zendesk_support_tickets_var_samp_fields';
  ticket_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Zendesk_Support_Tickets_Variance_Fields = {
  __typename?: 'zendesk_support_tickets_variance_fields';
  ticket_id?: Maybe<Scalars['Float']>;
};

export type FetchAllExperimentsDataQueryVariables = Exact<{
  [key: string]: never;
}>;

export type FetchAllExperimentsDataQuery = {
  __typename?: 'query_root';
  experiments_config: Array<{
    __typename?: 'experiments_config';
    experiment: Experiments_Enum;
    metadata?: any | null;
    status: string;
  }>;
  experiments_cohort: Array<{
    __typename?: 'experiments_cohort';
    experiment: Experiments_Enum;
    activity?: any | null;
  }>;
};

export type GetTenantEnvQueryVariables = Exact<{
  tenantId: Scalars['uuid'];
}>;

export type GetTenantEnvQuery = {
  __typename?: 'query_root';
  getTenantEnv?: {
    __typename?: 'TenantEnv';
    hash: string;
    envVars: any;
  } | null;
};

export type Unnamed_1_MutationVariables = Exact<{ [key: string]: never }>;

export type Unnamed_1_Mutation = {
  __typename?: 'mutation_root';
  getHerokuSession?: {
    __typename?: 'HerokuSession';
    access_token: string;
    refresh_token: string;
    expires_in: number;
    token_type: string;
  } | null;
};

export type TrackExperimentsCohortActivityMutationVariables = Exact<{
  projectId: Scalars['uuid'];
  experimentId: Scalars['String'];
  kind: Scalars['String'];
  error_code?: InputMaybe<Scalars['String']>;
}>;

export type TrackExperimentsCohortActivityMutation = {
  __typename?: 'mutation_root';
  trackExperimentsCohortActivity?: {
    __typename?: 'SuccessOrError';
    status: string;
  } | null;
};

export type UpdateTenantMutationVariables = Exact<{
  tenantId: Scalars['uuid'];
  currentHash: Scalars['String'];
  envs: Array<UpdateEnvObject> | UpdateEnvObject;
}>;

export type UpdateTenantMutation = {
  __typename?: 'mutation_root';
  updateTenantEnv?: {
    __typename?: 'TenantEnv';
    hash: string;
    envVars: any;
  } | null;
};

export type NeonCreateDatabaseMutationVariables = Exact<{
  projectId: Scalars['uuid'];
}>;

export type NeonCreateDatabaseMutation = {
  __typename?: 'mutation_root';
  neonCreateDatabase?: {
    __typename?: 'NeonCreateDatabaseResponse';
    databaseUrl?: string | null;
    email?: string | null;
    envVar?: string | null;
    isAuthenticated: boolean;
  } | null;
};

export type NeonTokenExchangeMutationVariables = Exact<{
  code: Scalars['String'];
  state: Scalars['String'];
  projectId: Scalars['uuid'];
}>;

export type NeonTokenExchangeMutation = {
  __typename?: 'mutation_root';
  neonExchangeOAuthToken: {
    __typename?: 'NeonExchangeTokenResponse';
    accessToken: string;
    email: string;
  };
};

export type CheckDbLatencyMutationVariables = Exact<{
  project_id: Scalars['uuid'];
}>;

export type CheckDbLatencyMutation = {
  __typename?: 'mutation_root';
  checkDBLatency?: {
    __typename?: 'CheckDBLatencyOutput';
    db_latency_job_id: any;
  } | null;
};

export type Unnamed_2_QueryVariables = Exact<{
  id: Scalars['uuid'];
}>;

export type Unnamed_2_Query = {
  __typename?: 'query_root';
  jobs_by_pk?: {
    __typename?: 'jobs';
    id: any;
    status: string;
    tasks: Array<{
      __typename?: 'tasks';
      id: any;
      name: string;
      task_events: Array<{
        __typename?: 'task_event';
        id: any;
        event_type: string;
        public_event_data?: any | null;
        error?: string | null;
      }>;
    }>;
  } | null;
};

export type Unnamed_3_MutationVariables = Exact<{
  jobId: Scalars['uuid'];
  projectId: Scalars['uuid'];
  isLatencyDisplayed: Scalars['Boolean'];
  dateDifferenceInMilliseconds: Scalars['Int'];
}>;

export type Unnamed_3_Mutation = {
  __typename?: 'mutation_root';
  insert_db_latency_one?: { __typename?: 'db_latency'; id: any } | null;
};

export type Unnamed_4_MutationVariables = Exact<{
  rowId: Scalars['uuid'];
  isChangeRegionClicked: Scalars['Boolean'];
}>;

export type Unnamed_4_Mutation = {
  __typename?: 'mutation_root';
  update_db_latency?: {
    __typename?: 'db_latency_mutation_response';
    affected_rows: number;
    returning: Array<{
      __typename?: 'db_latency';
      id: any;
      is_change_region_clicked: boolean;
    }>;
  } | null;
};

export type FetchOneClickDeploymentStateLogSubscriptionSubscriptionVariables =
  Exact<{
    id: Scalars['bigint'];
  }>;

export type FetchOneClickDeploymentStateLogSubscriptionSubscription = {
  __typename?: 'subscription_root';
  one_click_deployment_by_pk?: {
    __typename?: 'one_click_deployment';
    id: any;
    one_click_deployment_state_logs: Array<{
      __typename?: 'one_click_deployment_state_log';
      id: any;
      additional_info: any;
      from_state: One_Click_Deployment_States_Enum;
      to_state: One_Click_Deployment_States_Enum;
    }>;
  } | null;
};

export type TriggerOneClickDeploymentMutationVariables = Exact<{
  projectId: Scalars['uuid'];
}>;

export type TriggerOneClickDeploymentMutation = {
  __typename?: 'mutation_root';
  triggerOneClickDeployment?: {
    __typename?: 'OneClickDeployResponse';
    message?: string | null;
    status: string;
  } | null;
};

export type FetchAllSurveysDataQueryVariables = Exact<{
  currentTime: Scalars['timestamptz'];
}>;

export type FetchAllSurveysDataQuery = {
  __typename?: 'query_root';
  survey_v2: Array<{
    __typename?: 'survey_v2';
    survey_name: string;
    survey_title?: string | null;
    survey_description?: string | null;
    template_config?: any | null;
    survey_questions: Array<{
      __typename?: 'survey_v2_question';
      id: any;
      position: number;
      question: string;
      kind: Survey_V2_Question_Kind_Enum;
      is_mandatory: boolean;
      survey_question_options: Array<{
        __typename?: 'survey_v2_question_option';
        id: any;
        position: number;
        option: string;
        template_config?: any | null;
        additional_info_config?: {
          __typename?: 'survey_v2_question_option_additional_info_config';
          info_description?: string | null;
          is_mandatory: boolean;
        } | null;
      }>;
    }>;
    survey_responses: Array<{
      __typename?: 'survey_v2_response';
      survey_response_answers: Array<{
        __typename?: 'survey_v2_response_answer';
        survey_question_id: any;
        survey_response_answer_options: Array<{
          __typename?: 'survey_v2_response_answer_option';
          answer?: string | null;
          additional_info?: string | null;
          option_id?: any | null;
        }>;
      }>;
    }>;
  }>;
};

export type AddSurveyAnswerV2MutationVariables = Exact<{
  responses: Array<InputMaybe<SurveyResponseV2>> | InputMaybe<SurveyResponseV2>;
  surveyName: Scalars['String'];
  projectID?: InputMaybe<Scalars['uuid']>;
}>;

export type AddSurveyAnswerV2Mutation = {
  __typename?: 'mutation_root';
  saveSurveyAnswerV2?: { __typename?: 'SuccessOrError'; status: string } | null;
};

export type AddSchemaRegistryFeatureRequestMutationVariables = Exact<{
  details: Scalars['jsonb'];
}>;

export type AddSchemaRegistryFeatureRequestMutation = {
  __typename?: 'mutation_root';
  addFeatureRequest?: {
    __typename?: 'FeatureRequestResponse';
    status: string;
  } | null;
};

export type FetchConfigStatusSubscriptionVariables = Exact<{
  tenantId: Scalars['uuid'];
}>;

export type FetchConfigStatusSubscription = {
  __typename?: 'subscription_root';
  config_status: Array<{
    __typename?: 'config_status';
    hash: string;
    message?: string | null;
  }>;
};
