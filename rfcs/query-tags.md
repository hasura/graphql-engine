---
authors: Naveenaidu <naveen@hasura.io>
---

# Query Tags:

## Motivation

We need some ability for some users who are using native monitoring tools
(pganalyze, RDS performance insights) to see some "application context" in the
query logs. This is a PRO only feature.

This can be provided by appending some extra information as comments to the 

## Brief Overview

Query Tags are SQL comments which are made up of ``(key=value)`` pairs that
are appended to the SQL statements generated by Hasura for GraphQL operations.
The `(key=value)` pairs will henceforth be called as `attributes`. The main
idea is to convert the attributes as SQL comment and append this to the SQL
statement that is generated when a GraphQL operation is run using Hasura.

For example:

When the following query is sent to Hasura

```graphql

  query GetChild {
    child {
      name
    }
  }
```

Hasura attaches query tags (*unless disabled*) to the generated SQL statement it 
sends to the database.

```sql

SELECT * FROM child /* request_id=487c2ed5-08a4-429a-b0e0-4666a82e3cc6, field_name=child, operation_name=GetChild */
```


## Metadata Specification

Since there is various nitty-gritty with each vendor (who support automatic
visualization) with the query tags format so, in the interest of (future)
customization, we will need to introduce a configuration element to the
metadata.

The `query_tags` will be a part of the `source`. i.e

`source` -> `query_tags`


```yaml
sources:
  name: hge_cloud_db
  configuration :
  query_tags: # Optional Field
    disabled: # Optional Field | Type: Bool | Values: true or false
    format: # Optional Field | Values: standard or sqlcommenter

```

Query Tags is enabled for all sources by default and the default format for the
query tags is standard. That means:

1. The `query_tags` field is optional.
2. If the `query_tags` field is not present for a source in metadata, then it
   means query tags are enabled for the source and the format of the
   `query_tags` is `standard`.
4. To disable query tags, set the value of `disabled` field as `true`.
3. A user would only have to write the `query_tags` field for a source only
   when they want to disable it for a source OR change the format of query
   tags.

## Approach

1. Add query-tags configuration field to `source` field of metadata. This is
   done by adding the query-tags to `SourceMetadata` type, since the
   `configuration` field of metadata is parsed as `SourceConnConfiguration`
   datatype. Different Backends will have different formats of
   `SourceConnConfiguration`, so if you want to configure query-tags for a
   specific backend, make sure to add `query-tags` to the backend specific
   `SourceConnConfiguration`.

2. Query tags configuration is made a part of `SourceInfo b` so that it is
   accessible via `SourceConfigWith`. Ideally, query tags should have been a
   part of `SourceConfig`, but due to the way our incremental schema building
   works, even if only query tags configuration changes due to an incremental
   API - then the entire `SourceConfig` will get built (_see
   `resolveSourceConfigIfNeeded`_) - that means the connection pools also will
   get rebuilt. And that is a heavy cost thus - we decided that it's a saner
   approach to have query tags config as part of `SourceConfigWith`

3. Create a new typeclass `MonadQueryTags` which has a `createQueryTags`
   function. This new typeclass is necessary because query-tags is a
   PRO-specific feature.

4. Add `MonadReader QueryTagsComment` constraint to the `mkDB..Plan` function.
   This constraint helps the backend specific implementation of `mkDB..Plan`
   function to ask for the query tags comment if it wants to, thus reducing
   the friction of the implementors of new backends, because they do not need
   to be concerned about query tags. `QueryTagsComment` fetches the comment to
   append to generated SQL, if a backend decides to do so

5. The QueryTags are generated where the `mkDB..Plan` functions are called
   since all the information necessary to make the QueryTags are available
   there. The Query Tags are converted as SQL comment at the same place and
   passed down the stack where the SQL is generated for the GQL operation. The
   Query Tags are then append to the SQL.


### Note:

The above approach is only the first iteration of query tags. 

We initially planned to have `appendQueryTags` inside the `BackendExecute`
typeclass but that did not work out well as the `appendQueryTags` would then
depend on the `PreparedQuery b` type family which is not used by mutations and
for some backends, it only gets created after pretty-printing. 
