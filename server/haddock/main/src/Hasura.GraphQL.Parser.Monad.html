<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-comment">-- | Monad transformers for GraphQL schema construction and query parsing.</span><span>
</span><span id="line-2"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Hasura.GraphQL.Parser.Monad</span><span>
</span><span id="line-3"></span><span>  </span><span class="hs-special">(</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#SchemaT"><span class="hs-identifier">SchemaT</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-4"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#runSchemaT"><span class="hs-identifier">runSchemaT</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-5"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#Parse"><span class="hs-identifier">Parse</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-6"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#runParse"><span class="hs-identifier">runParse</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-7"></span><span>    </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParseError"><span class="hs-identifier">ParseError</span></a></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span>
</span><span id="line-8"></span><span>  </span><span class="hs-special">)</span><span>
</span><span id="line-9"></span><span class="hs-keyword">where</span><span>
</span><span id="line-10"></span><span>
</span><span id="line-11"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Arrow</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-operator">(&lt;&lt;&lt;)</span></span><span class="hs-special">)</span><span>
</span><span id="line-12"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Except</span></span><span>
</span><span id="line-13"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.Reader</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">MonadReader</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">ReaderT</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">mapReaderT</span></span><span class="hs-special">)</span><span>
</span><span id="line-14"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Control.Monad.State.Strict</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">MonadState</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">StateT</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">evalStateT</span></span><span class="hs-special">)</span><span>
</span><span id="line-15"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Aeson</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">JSONPath</span></span><span class="hs-special">)</span><span>
</span><span id="line-16"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Dependent.Map</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">DMap</span></span><span class="hs-special">)</span><span>
</span><span id="line-17"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Dependent.Map</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">DM</span></span><span>
</span><span id="line-18"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Data.GADT.Compare.Extended.html"><span class="hs-identifier">Data.GADT.Compare.Extended</span></a></span><span>
</span><span id="line-19"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.IORef</span></span><span>
</span><span id="line-20"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Kind</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">K</span></span><span>
</span><span id="line-21"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Proxy</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Proxy</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-22"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Data.Text</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Text</span></span><span class="hs-special">)</span><span>
</span><span id="line-23"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Hasura.Base.Error.html"><span class="hs-identifier">Hasura.Base.Error</span></a></span><span>
</span><span id="line-24"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Class.html"><span class="hs-identifier">Hasura.GraphQL.Parser.Class</span></a></span><span>
</span><span id="line-25"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Language.Haskell.TH</span></span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="annot"><span class="hs-identifier">TH</span></span><span>
</span><span id="line-26"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">System.IO.Unsafe</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">unsafeInterleaveIO</span></span><span class="hs-special">)</span><span>
</span><span id="line-27"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Type.Reflection</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier">Typeable</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier">typeRep</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-operator">(:~:)</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-28"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Prelude</span></span><span>
</span><span id="line-29"></span><span>
</span><span id="line-30"></span><span class="hs-comment">-- Disable custom prelude warnings in preparation for extracting this module into a separate package.</span><span>
</span><span id="line-31"></span><span class="hs-pragma">{-# ANN</span><span> </span><span class="hs-pragma">module</span><span> </span><span class="hs-pragma">(</span><span class="annot"><span class="hs-pragma">&quot;HLint: ignore Use onLeft&quot;</span></span><span> </span><span class="hs-pragma">::</span><span> </span><span class="annot"><span class="hs-pragma hs-type">String</span></span><span class="hs-pragma">)</span><span> </span><span class="hs-pragma">#-}</span><span>
</span><span id="line-32"></span><span>
</span><span id="line-33"></span><span class="hs-comment">-- -------------------------------------------------------------------------------------------------</span><span>
</span><span id="line-34"></span><span class="hs-comment">-- schema construction</span><span>
</span><span id="line-35"></span><span>
</span><span id="line-36"></span><span id="local-6989586621689161812"><span id="local-6989586621689161813"><span class="hs-keyword">newtype</span><span> </span><span id="SchemaT"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#SchemaT"><span class="hs-identifier hs-var">SchemaT</span></a></span></span><span> </span><span id="local-6989586621689161986"><span class="annot"><a href="#local-6989586621689161986"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span id="local-6989586621689161985"><span class="annot"><a href="#local-6989586621689161985"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621689161984"><span class="annot"><a href="#local-6989586621689161984"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="SchemaT"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#SchemaT"><span class="hs-identifier hs-var">SchemaT</span></a></span></span><span>
</span><span id="line-37"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="unSchemaT"><span class="annot"><span class="annottext">SchemaT n m a -&gt; StateT (DMap ParserId (ParserById n)) m a
</span><a href="Hasura.GraphQL.Parser.Monad.html#unSchemaT"><span class="hs-identifier hs-var hs-var">unSchemaT</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">StateT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">DMap</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserById"><span class="hs-identifier hs-type">ParserById</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161986"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="annot"><a href="#local-6989586621689161985"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161984"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-38"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-39"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621689161806"><span id="local-6989586621689161808"><span class="annot"><span class="annottext">a -&gt; SchemaT n m b -&gt; SchemaT n m a
(a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b
(forall a b. (a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b)
-&gt; (forall a b. a -&gt; SchemaT n m b -&gt; SchemaT n m a)
-&gt; Functor (SchemaT n m)
forall a b. a -&gt; SchemaT n m b -&gt; SchemaT n m a
forall a b. (a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Functor m =&gt;
a -&gt; SchemaT n m b -&gt; SchemaT n m a
forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Functor m =&gt;
(a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b
&lt;$ :: a -&gt; SchemaT n m b -&gt; SchemaT n m a
$c&lt;$ :: forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Functor m =&gt;
a -&gt; SchemaT n m b -&gt; SchemaT n m a
fmap :: (a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b
$cfmap :: forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Functor m =&gt;
(a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689161794"><span id="local-6989586621689161796"><span id="local-6989586621689161798"><span id="local-6989586621689161800"><span id="local-6989586621689161802"><span class="annot"><span class="annottext">Functor (SchemaT n m)
a -&gt; SchemaT n m a
Functor (SchemaT n m)
-&gt; (forall a. a -&gt; SchemaT n m a)
-&gt; (forall a b.
    SchemaT n m (a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b)
-&gt; (forall a b c.
    (a -&gt; b -&gt; c) -&gt; SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m c)
-&gt; (forall a b. SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b)
-&gt; (forall a b. SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m a)
-&gt; Applicative (SchemaT n m)
SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b
SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m a
SchemaT n m (a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b
(a -&gt; b -&gt; c) -&gt; SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m c
forall a. a -&gt; SchemaT n m a
forall a b. SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m a
forall a b. SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b
forall a b. SchemaT n m (a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b
forall a b c.
(a -&gt; b -&gt; c) -&gt; SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m c
forall (f :: * -&gt; *).
Functor f
-&gt; (forall a. a -&gt; f a)
-&gt; (forall a b. f (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b c. (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c)
-&gt; (forall a b. f a -&gt; f b -&gt; f b)
-&gt; (forall a b. f a -&gt; f b -&gt; f a)
-&gt; Applicative f
forall (n :: * -&gt; *) (m :: * -&gt; *).
Monad m =&gt;
Functor (SchemaT n m)
forall (n :: * -&gt; *) (m :: * -&gt; *) a. Monad m =&gt; a -&gt; SchemaT n m a
forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Monad m =&gt;
SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m a
forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Monad m =&gt;
SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b
forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Monad m =&gt;
SchemaT n m (a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b
forall (n :: * -&gt; *) (m :: * -&gt; *) a b c.
Monad m =&gt;
(a -&gt; b -&gt; c) -&gt; SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m c
&lt;* :: SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m a
$c&lt;* :: forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Monad m =&gt;
SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m a
*&gt; :: SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b
$c*&gt; :: forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Monad m =&gt;
SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b
liftA2 :: (a -&gt; b -&gt; c) -&gt; SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m c
$cliftA2 :: forall (n :: * -&gt; *) (m :: * -&gt; *) a b c.
Monad m =&gt;
(a -&gt; b -&gt; c) -&gt; SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m c
&lt;*&gt; :: SchemaT n m (a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b
$c&lt;*&gt; :: forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Monad m =&gt;
SchemaT n m (a -&gt; b) -&gt; SchemaT n m a -&gt; SchemaT n m b
pure :: a -&gt; SchemaT n m a
$cpure :: forall (n :: * -&gt; *) (m :: * -&gt; *) a. Monad m =&gt; a -&gt; SchemaT n m a
$cp1Applicative :: forall (n :: * -&gt; *) (m :: * -&gt; *).
Monad m =&gt;
Functor (SchemaT n m)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Applicative</span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689161786"><span id="local-6989586621689161788"><span id="local-6989586621689161790"><span class="annot"><span class="annottext">Applicative (SchemaT n m)
a -&gt; SchemaT n m a
Applicative (SchemaT n m)
-&gt; (forall a b.
    SchemaT n m a -&gt; (a -&gt; SchemaT n m b) -&gt; SchemaT n m b)
-&gt; (forall a b. SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b)
-&gt; (forall a. a -&gt; SchemaT n m a)
-&gt; Monad (SchemaT n m)
SchemaT n m a -&gt; (a -&gt; SchemaT n m b) -&gt; SchemaT n m b
SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b
forall a. a -&gt; SchemaT n m a
forall a b. SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b
forall a b. SchemaT n m a -&gt; (a -&gt; SchemaT n m b) -&gt; SchemaT n m b
forall (m :: * -&gt; *).
Applicative m
-&gt; (forall a b. m a -&gt; (a -&gt; m b) -&gt; m b)
-&gt; (forall a b. m a -&gt; m b -&gt; m b)
-&gt; (forall a. a -&gt; m a)
-&gt; Monad m
forall (n :: * -&gt; *) (m :: * -&gt; *).
Monad m =&gt;
Applicative (SchemaT n m)
forall (n :: * -&gt; *) (m :: * -&gt; *) a. Monad m =&gt; a -&gt; SchemaT n m a
forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Monad m =&gt;
SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b
forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Monad m =&gt;
SchemaT n m a -&gt; (a -&gt; SchemaT n m b) -&gt; SchemaT n m b
return :: a -&gt; SchemaT n m a
$creturn :: forall (n :: * -&gt; *) (m :: * -&gt; *) a. Monad m =&gt; a -&gt; SchemaT n m a
&gt;&gt; :: SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b
$c&gt;&gt; :: forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Monad m =&gt;
SchemaT n m a -&gt; SchemaT n m b -&gt; SchemaT n m b
&gt;&gt;= :: SchemaT n m a -&gt; (a -&gt; SchemaT n m b) -&gt; SchemaT n m b
$c&gt;&gt;= :: forall (n :: * -&gt; *) (m :: * -&gt; *) a b.
Monad m =&gt;
SchemaT n m a -&gt; (a -&gt; SchemaT n m b) -&gt; SchemaT n m b
$cp1Monad :: forall (n :: * -&gt; *) (m :: * -&gt; *).
Monad m =&gt;
Applicative (SchemaT n m)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Monad</span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689161780"><span id="local-6989586621689161782"><span class="annot"><span class="hs-identifier hs-type">MonadError</span></span><span> </span><span class="annot"><a href="#local-6989586621689161813"><span class="hs-identifier hs-type">e</span></a></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689161772"><span id="local-6989586621689161774"><span id="local-6989586621689161776"><span class="annot"><span class="hs-identifier hs-type">MonadReader</span></span><span> </span><span class="annot"><a href="#local-6989586621689161812"><span class="hs-identifier hs-type">r</span></a></span></span></span></span><span class="hs-special">)</span></span></span><span>
</span><span id="line-40"></span><span>
</span><span id="line-41"></span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#runSchemaT"><span class="hs-identifier hs-type">runSchemaT</span></a></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-keyword">forall</span><span> </span><span id="local-6989586621689161770"><span class="annot"><a href="#local-6989586621689161770"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span id="local-6989586621689161769"><span class="annot"><a href="#local-6989586621689161769"><span class="hs-identifier hs-type">n</span></a></span></span><span> </span><span id="local-6989586621689161768"><span class="annot"><a href="#local-6989586621689161768"><span class="hs-identifier hs-type">a</span></a></span></span><span class="hs-operator">.</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Monad</span></span><span> </span><span class="annot"><a href="#local-6989586621689161770"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#SchemaT"><span class="hs-identifier hs-type">SchemaT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161769"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161770"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161768"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621689161770"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161768"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-42"></span><span id="runSchemaT"><span class="annot"><span class="annottext">runSchemaT :: SchemaT n m a -&gt; m a
</span><a href="Hasura.GraphQL.Parser.Monad.html#runSchemaT"><span class="hs-identifier hs-var hs-var">runSchemaT</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(StateT (DMap ParserId (ParserById n)) m a
 -&gt; DMap ParserId (ParserById n) -&gt; m a)
-&gt; DMap ParserId (ParserById n)
-&gt; StateT (DMap ParserId (ParserById n)) m a
-&gt; m a
forall a b c. (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c
</span><span class="hs-identifier hs-var">flip</span></span><span> </span><span class="annot"><span class="annottext">StateT (DMap ParserId (ParserById n)) m a
-&gt; DMap ParserId (ParserById n) -&gt; m a
forall (m :: * -&gt; *) s a. Monad m =&gt; StateT s m a -&gt; s -&gt; m a
</span><span class="hs-identifier hs-var">evalStateT</span></span><span> </span><span class="annot"><span class="annottext">DMap ParserId (ParserById n)
forall a. Monoid a =&gt; a
</span><span class="hs-identifier hs-var">mempty</span></span><span> </span><span class="annot"><span class="annottext">(StateT (DMap ParserId (ParserById n)) m a -&gt; m a)
-&gt; (SchemaT n m a -&gt; StateT (DMap ParserId (ParserById n)) m a)
-&gt; SchemaT n m a
-&gt; m a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">SchemaT n m a -&gt; StateT (DMap ParserId (ParserById n)) m a
forall (n :: * -&gt; *) (m :: * -&gt; *) a.
SchemaT n m a -&gt; StateT (DMap ParserId (ParserById n)) m a
</span><a href="Hasura.GraphQL.Parser.Monad.html#unSchemaT"><span class="hs-identifier hs-var hs-var">unSchemaT</span></a></span><span>
</span><span id="line-43"></span><span>
</span><span id="line-44"></span><span class="hs-comment">-- | see Note [SchemaT requires MonadIO]</span><span>
</span><span id="line-45"></span><span id="local-6989586621689161764"><span id="local-6989586621689161765"><span class="hs-keyword">instance</span><span>
</span><span id="line-46"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">MonadIO</span></span><span> </span><span class="annot"><a href="#local-6989586621689161765"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Class.Parse.html#MonadParse"><span class="hs-identifier hs-type">MonadParse</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161764"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-47"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Class.html#MonadSchema"><span class="hs-identifier hs-type">MonadSchema</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161764"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#SchemaT"><span class="hs-identifier hs-type">SchemaT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161764"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161765"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-48"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-49"></span><span>  </span><span id="local-6989586621689161759"><span class="annot"><span class="annottext">memoizeOn :: Name -&gt; a -&gt; SchemaT n m (p n b) -&gt; SchemaT n m (p n b)
</span><a href="Hasura.GraphQL.Parser.Class.html#memoizeOn"><span class="hs-identifier hs-var hs-var hs-var hs-var">memoizeOn</span></a></span></span><span> </span><span id="local-6989586621689161757"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161757"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621689161756"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689161756"><span class="hs-identifier hs-var">key</span></a></span></span><span> </span><span id="local-6989586621689161755"><span class="annot"><span class="annottext">SchemaT n m (p n b)
</span><a href="#local-6989586621689161755"><span class="hs-identifier hs-var">buildParser</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">StateT (DMap ParserId (ParserById n)) m (p n b)
-&gt; SchemaT n m (p n b)
forall (n :: * -&gt; *) (m :: * -&gt; *) a.
StateT (DMap ParserId (ParserById n)) m a -&gt; SchemaT n m a
</span><a href="Hasura.GraphQL.Parser.Monad.html#SchemaT"><span class="hs-identifier hs-var">SchemaT</span></a></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-50"></span><span>    </span><span class="hs-keyword">let</span><span> </span><span id="local-6989586621689161754"><span class="annot"><span class="annottext">parserId :: ParserId '(p, b)
</span><a href="#local-6989586621689161754"><span class="hs-identifier hs-var hs-var">parserId</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Name -&gt; a -&gt; ParserId '(p, b)
forall a (p :: (* -&gt; *) -&gt; * -&gt; *) b.
(Ord a, Typeable p, Typeable a, Typeable b) =&gt;
Name -&gt; a -&gt; ParserId '(p, b)
</span><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-var">ParserId</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161757"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689161756"><span class="hs-identifier hs-var">key</span></a></span><span>
</span><span id="line-51"></span><span>    </span><span id="local-6989586621689161752"><span class="annot"><span class="annottext">DMap ParserId (ParserById n)
</span><a href="#local-6989586621689161752"><span class="hs-identifier hs-var">parsersById</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">StateT
  (DMap ParserId (ParserById n)) m (DMap ParserId (ParserById n))
forall s (m :: * -&gt; *). MonadState s m =&gt; m s
</span><span class="hs-identifier hs-var">get</span></span><span>
</span><span id="line-52"></span><span>    </span><span class="hs-keyword">case</span><span> </span><span class="annot"><span class="annottext">ParserId '(p, b)
-&gt; DMap ParserId (ParserById n) -&gt; Maybe (ParserById n '(p, b))
forall k1 (k2 :: k1 -&gt; *) (f :: k1 -&gt; *) (v :: k1).
GCompare k2 =&gt;
k2 v -&gt; DMap k2 f -&gt; Maybe (f v)
</span><span class="hs-identifier hs-var">DM.lookup</span></span><span> </span><span class="annot"><span class="annottext">ParserId '(p, b)
</span><a href="#local-6989586621689161754"><span class="hs-identifier hs-var">parserId</span></a></span><span> </span><span class="annot"><span class="annottext">DMap ParserId (ParserById n)
</span><a href="#local-6989586621689161752"><span class="hs-identifier hs-var">parsersById</span></a></span><span> </span><span class="hs-keyword">of</span><span>
</span><span id="line-53"></span><span>      </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserById"><span class="hs-identifier hs-type">ParserById</span></a></span><span> </span><span id="local-6989586621689161748"><span class="annot"><a href="#local-6989586621689161748"><span class="hs-identifier hs-var">parser</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">p n b -&gt; StateT (DMap ParserId (ParserById n)) m (p n b)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">p n b
</span><a href="#local-6989586621689161748"><span class="hs-identifier hs-var">parser</span></a></span><span>
</span><span id="line-54"></span><span>      </span><span class="annot"><span class="annottext">Maybe (ParserById n '(p, b))
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-55"></span><span>        </span><span class="hs-comment">-- We manually do eager blackholing here using a MutVar rather than</span><span>
</span><span id="line-56"></span><span>        </span><span class="hs-comment">-- relying on MonadFix and ordinary thunk blackholing. Why? A few</span><span>
</span><span id="line-57"></span><span>        </span><span class="hs-comment">-- reasons:</span><span>
</span><span id="line-58"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-59"></span><span>        </span><span class="hs-comment">--   1. We have more control. We aren&#8217;t at the whims of whatever</span><span>
</span><span id="line-60"></span><span>        </span><span class="hs-comment">--      MonadFix instance happens to get used.</span><span>
</span><span id="line-61"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-62"></span><span>        </span><span class="hs-comment">--   2. We can be more precise. GHC&#8217;s lazy blackholing doesn&#8217;t always</span><span>
</span><span id="line-63"></span><span>        </span><span class="hs-comment">--      kick in when you&#8217;d expect.</span><span>
</span><span id="line-64"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-65"></span><span>        </span><span class="hs-comment">--   3. We can provide more useful error reporting if things go wrong.</span><span>
</span><span id="line-66"></span><span>        </span><span class="hs-comment">--      Most usefully, we can include a HasCallStack source location.</span><span>
</span><span id="line-67"></span><span>        </span><span id="local-6989586621689161747"><span class="annot"><span class="annottext">IORef (Maybe (p n b))
</span><a href="#local-6989586621689161747"><span class="hs-identifier hs-var">cell</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">IO (IORef (Maybe (p n b)))
-&gt; StateT (DMap ParserId (ParserById n)) m (IORef (Maybe (p n b)))
forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span> </span><span class="annot"><span class="annottext">(IO (IORef (Maybe (p n b)))
 -&gt; StateT (DMap ParserId (ParserById n)) m (IORef (Maybe (p n b))))
-&gt; IO (IORef (Maybe (p n b)))
-&gt; StateT (DMap ParserId (ParserById n)) m (IORef (Maybe (p n b)))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Maybe (p n b) -&gt; IO (IORef (Maybe (p n b)))
forall a. a -&gt; IO (IORef a)
</span><span class="hs-identifier hs-var">newIORef</span></span><span> </span><span class="annot"><span class="annottext">Maybe (p n b)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-68"></span><span>
</span><span id="line-69"></span><span>        </span><span class="hs-comment">-- We use unsafeInterleaveIO here, which sounds scary, but</span><span>
</span><span id="line-70"></span><span>        </span><span class="hs-comment">-- unsafeInterleaveIO is actually far more safe than unsafePerformIO.</span><span>
</span><span id="line-71"></span><span>        </span><span class="hs-comment">-- unsafeInterleaveIO just defers the execution of the action until its</span><span>
</span><span id="line-72"></span><span>        </span><span class="hs-comment">-- result is needed, adding some laziness.</span><span>
</span><span id="line-73"></span><span>        </span><span class="hs-comment">--</span><span>
</span><span id="line-74"></span><span>        </span><span class="hs-comment">-- That laziness can be dangerous if the action has side-effects, since</span><span>
</span><span id="line-75"></span><span>        </span><span class="hs-comment">-- the point at which the effect is performed can be unpredictable. But</span><span>
</span><span id="line-76"></span><span>        </span><span class="hs-comment">-- this action just reads, never writes, so that isn&#8217;t a concern.</span><span>
</span><span id="line-77"></span><span>        </span><span id="local-6989586621689161744"><span class="annot"><span class="annottext">ParserById n '(p, b)
</span><a href="#local-6989586621689161744"><span class="hs-identifier hs-var">parserById</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span>
</span><span id="line-78"></span><span>          </span><span class="annot"><span class="annottext">IO (ParserById n '(p, b))
-&gt; StateT (DMap ParserId (ParserById n)) m (ParserById n '(p, b))
forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span> </span><span class="annot"><span class="annottext">(IO (ParserById n '(p, b))
 -&gt; StateT (DMap ParserId (ParserById n)) m (ParserById n '(p, b)))
-&gt; IO (ParserById n '(p, b))
-&gt; StateT (DMap ParserId (ParserById n)) m (ParserById n '(p, b))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-79"></span><span>            </span><span class="annot"><span class="annottext">IO (ParserById n '(p, b)) -&gt; IO (ParserById n '(p, b))
forall a. IO a -&gt; IO a
</span><span class="hs-identifier hs-var">unsafeInterleaveIO</span></span><span> </span><span class="annot"><span class="annottext">(IO (ParserById n '(p, b)) -&gt; IO (ParserById n '(p, b)))
-&gt; IO (ParserById n '(p, b)) -&gt; IO (ParserById n '(p, b))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-80"></span><span>              </span><span class="annot"><span class="annottext">IORef (Maybe (p n b)) -&gt; IO (Maybe (p n b))
forall a. IORef a -&gt; IO a
</span><span class="hs-identifier hs-var">readIORef</span></span><span> </span><span class="annot"><span class="annottext">IORef (Maybe (p n b))
</span><a href="#local-6989586621689161747"><span class="hs-identifier hs-var">cell</span></a></span><span> </span><span class="annot"><span class="annottext">IO (Maybe (p n b))
-&gt; (Maybe (p n b) -&gt; IO (ParserById n '(p, b)))
-&gt; IO (ParserById n '(p, b))
forall (m :: * -&gt; *) a b. Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
</span><span class="hs-operator hs-var">&gt;&gt;=</span></span><span> </span><span class="hs-glyph">\</span><span class="hs-glyph">case</span><span>
</span><span id="line-81"></span><span>                </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span id="local-6989586621689161742"><span class="annot"><span class="annottext">p n b
</span><a href="#local-6989586621689161742"><span class="hs-identifier hs-var">parser</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ParserById n '(p, b) -&gt; IO (ParserById n '(p, b))
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">(ParserById n '(p, b) -&gt; IO (ParserById n '(p, b)))
-&gt; ParserById n '(p, b) -&gt; IO (ParserById n '(p, b))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">p n b -&gt; ParserById n '(p, b)
forall (m :: * -&gt; *) (p :: (* -&gt; *) -&gt; * -&gt; *) a.
p m a -&gt; ParserById m '(p, a)
</span><a href="Hasura.GraphQL.Parser.Monad.html#ParserById"><span class="hs-identifier hs-var">ParserById</span></a></span><span> </span><span class="annot"><span class="annottext">p n b
</span><a href="#local-6989586621689161742"><span class="hs-identifier hs-var">parser</span></a></span><span>
</span><span id="line-82"></span><span>                </span><span class="annot"><span class="annottext">Maybe (p n b)
</span><span class="hs-identifier hs-var">Nothing</span></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-83"></span><span>                  </span><span class="annot"><span class="annottext">[Char] -&gt; IO (ParserById n '(p, b))
forall a. HasCallStack =&gt; [Char] -&gt; a
</span><span class="hs-identifier hs-var">error</span></span><span> </span><span class="annot"><span class="annottext">([Char] -&gt; IO (ParserById n '(p, b)))
-&gt; [Char] -&gt; IO (ParserById n '(p, b))
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span>
</span><span id="line-84"></span><span>                    </span><span class="annot"><span class="annottext">[[Char]] -&gt; [Char]
</span><span class="hs-identifier hs-var">unlines</span></span><span>
</span><span id="line-85"></span><span>                      </span><span class="hs-special">[</span><span> </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;memoize: parser was forced before being fully constructed&quot;</span></span><span class="hs-special">,</span><span>
</span><span id="line-86"></span><span>                        </span><span class="annot"><span class="annottext">[Char]
</span><span class="hs-string">&quot;  parser constructor: &quot;</span></span><span> </span><span class="annot"><span class="annottext">[Char] -&gt; [Char] -&gt; [Char]
forall a. [a] -&gt; [a] -&gt; [a]
</span><span class="hs-operator hs-var">++</span></span><span> </span><span class="annot"><span class="annottext">Name -&gt; [Char]
forall a. Ppr a =&gt; a -&gt; [Char]
</span><span class="hs-identifier hs-var">TH.pprint</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161757"><span class="hs-identifier hs-var">name</span></a></span><span>
</span><span id="line-87"></span><span>                      </span><span class="hs-special">]</span><span>
</span><span id="line-88"></span><span>        </span><span class="annot"><span class="annottext">DMap ParserId (ParserById n)
-&gt; StateT (DMap ParserId (ParserById n)) m ()
forall s (m :: * -&gt; *). MonadState s m =&gt; s -&gt; m ()
</span><span class="hs-identifier hs-var">put</span></span><span> </span><span class="annot"><span class="annottext">(DMap ParserId (ParserById n)
 -&gt; StateT (DMap ParserId (ParserById n)) m ())
-&gt; DMap ParserId (ParserById n)
-&gt; StateT (DMap ParserId (ParserById n)) m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$!</span></span><span> </span><span class="annot"><span class="annottext">ParserId '(p, b)
-&gt; ParserById n '(p, b)
-&gt; DMap ParserId (ParserById n)
-&gt; DMap ParserId (ParserById n)
forall k1 (k2 :: k1 -&gt; *) (f :: k1 -&gt; *) (v :: k1).
GCompare k2 =&gt;
k2 v -&gt; f v -&gt; DMap k2 f -&gt; DMap k2 f
</span><span class="hs-identifier hs-var">DM.insert</span></span><span> </span><span class="annot"><span class="annottext">ParserId '(p, b)
</span><a href="#local-6989586621689161754"><span class="hs-identifier hs-var">parserId</span></a></span><span> </span><span class="annot"><span class="annottext">ParserById n '(p, b)
</span><a href="#local-6989586621689161744"><span class="hs-identifier hs-var">parserById</span></a></span><span> </span><span class="annot"><span class="annottext">DMap ParserId (ParserById n)
</span><a href="#local-6989586621689161752"><span class="hs-identifier hs-var">parsersById</span></a></span><span>
</span><span id="line-89"></span><span>
</span><span id="line-90"></span><span>        </span><span id="local-6989586621689161735"><span class="annot"><span class="annottext">p n b
</span><a href="#local-6989586621689161735"><span class="hs-identifier hs-var">parser</span></a></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">SchemaT n m (p n b)
-&gt; StateT (DMap ParserId (ParserById n)) m (p n b)
forall (n :: * -&gt; *) (m :: * -&gt; *) a.
SchemaT n m a -&gt; StateT (DMap ParserId (ParserById n)) m a
</span><a href="Hasura.GraphQL.Parser.Monad.html#unSchemaT"><span class="hs-identifier hs-var hs-var">unSchemaT</span></a></span><span> </span><span class="annot"><span class="annottext">SchemaT n m (p n b)
</span><a href="#local-6989586621689161755"><span class="hs-identifier hs-var">buildParser</span></a></span><span>
</span><span id="line-91"></span><span>        </span><span class="annot"><span class="annottext">IO () -&gt; StateT (DMap ParserId (ParserById n)) m ()
forall (m :: * -&gt; *) a. MonadIO m =&gt; IO a -&gt; m a
</span><span class="hs-identifier hs-var">liftIO</span></span><span> </span><span class="annot"><span class="annottext">(IO () -&gt; StateT (DMap ParserId (ParserById n)) m ())
-&gt; IO () -&gt; StateT (DMap ParserId (ParserById n)) m ()
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">IORef (Maybe (p n b)) -&gt; Maybe (p n b) -&gt; IO ()
forall a. IORef a -&gt; a -&gt; IO ()
</span><span class="hs-identifier hs-var">writeIORef</span></span><span> </span><span class="annot"><span class="annottext">IORef (Maybe (p n b))
</span><a href="#local-6989586621689161747"><span class="hs-identifier hs-var">cell</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">p n b -&gt; Maybe (p n b)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">p n b
</span><a href="#local-6989586621689161735"><span class="hs-identifier hs-var">parser</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-92"></span><span>        </span><span class="annot"><span class="annottext">p n b -&gt; StateT (DMap ParserId (ParserById n)) m (p n b)
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="annot"><span class="annottext">p n b
</span><a href="#local-6989586621689161735"><span class="hs-identifier hs-var">parser</span></a></span></span></span><span>
</span><span id="line-93"></span><span>
</span><span id="line-94"></span><span id="local-6989586621689161731"><span id="local-6989586621689161732"><span id="local-6989586621689161733"><span class="hs-keyword">instance</span><span>
</span><span id="line-95"></span><span>  </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">MonadIO</span></span><span> </span><span class="annot"><a href="#local-6989586621689161733"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Class.Parse.html#MonadParse"><span class="hs-identifier hs-type">MonadParse</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161732"><span class="hs-identifier hs-type">n</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-96"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Class.html#MonadSchema"><span class="hs-identifier hs-type">MonadSchema</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161732"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">ReaderT</span></span><span> </span><span class="annot"><a href="#local-6989586621689161731"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#SchemaT"><span class="hs-identifier hs-type">SchemaT</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161732"><span class="hs-identifier hs-type">n</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161733"><span class="hs-identifier hs-type">m</span></a></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-97"></span><span>  </span><span class="hs-keyword">where</span><span>
</span><span id="line-98"></span><span>  </span><span id="local-6989586621689161727"><span class="annot"><span class="annottext">memoizeOn :: Name
-&gt; a
-&gt; ReaderT a (SchemaT n m) (p n b)
-&gt; ReaderT a (SchemaT n m) (p n b)
</span><a href="#local-6989586621689161727"><span class="hs-identifier hs-var hs-var hs-var hs-var">memoizeOn</span></a></span></span><span> </span><span id="local-6989586621689161726"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161726"><span class="hs-identifier hs-var">name</span></a></span></span><span> </span><span id="local-6989586621689161725"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689161725"><span class="hs-identifier hs-var">key</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">(SchemaT n m (p n b) -&gt; SchemaT n m (p n b))
-&gt; ReaderT a (SchemaT n m) (p n b)
-&gt; ReaderT a (SchemaT n m) (p n b)
forall (m :: * -&gt; *) a (n :: * -&gt; *) b r.
(m a -&gt; n b) -&gt; ReaderT r m a -&gt; ReaderT r n b
</span><span class="hs-identifier hs-var">mapReaderT</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; a -&gt; SchemaT n m (p n b) -&gt; SchemaT n m (p n b)
forall (n :: * -&gt; *) (m :: * -&gt; *) (p :: (* -&gt; *) -&gt; * -&gt; *) a b.
(MonadSchema n m, Ord a, Typeable p, Typeable a, Typeable b) =&gt;
Name -&gt; a -&gt; m (p n b) -&gt; m (p n b)
</span><a href="Hasura.GraphQL.Parser.Class.html#memoizeOn"><span class="hs-identifier hs-var">memoizeOn</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161726"><span class="hs-identifier hs-var">name</span></a></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689161725"><span class="hs-identifier hs-var">key</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-99"></span><span>
</span><span id="line-100"></span><span class="hs-comment">{- Note [SchemaT requires MonadIO]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The MonadSchema instance for SchemaT requires MonadIO, which is unsatisfying.
The only reason the constraint is needed is to implement knot-tying via IORefs
(see Note [Tying the knot] in Hasura.GraphQL.Parser.Class), which really only
requires the power of ST. Using ST would be much nicer, since we could discharge
the burden locally, but unfortunately we also want to use MonadUnique, which
is handled by IO in the end.

This means that we need IO at the base of our monad, so to use STRefs, we&#8217;d need
a hypothetical STT transformer (i.e. a monad transformer version of ST). But
such a thing isn&#8217;t safe in general, since reentrant monads like ListT or ContT
would incorrectly share state between the different threads of execution.

In theory, this can be resolved by using something like Vault (from the vault
package) to create &#8220;splittable&#8221; sets of variable references. That would allow
you to create a transformer with an STRef-like interface that works over any
arbitrary monad. However, while the interface would be safe, the implementation
of such an abstraction requires unsafe primitives, and to the best of my
knowledge no such transformer exists in any existing libraries.

So we decide it isn&#8217;t worth the trouble and just use MonadIO. If `eff` ever pans
out, it should be able to support this more naturally, so we can fix it then. -}</span><span>
</span><span id="line-123"></span><span>
</span><span id="line-124"></span><span class="hs-comment">-- | A key used to distinguish calls to 'memoize'd functions. The 'TH.Name'</span><span>
</span><span id="line-125"></span><span class="hs-comment">-- distinguishes calls to completely different parsers, and the @a@ value</span><span>
</span><span id="line-126"></span><span class="hs-comment">-- records the arguments.</span><span>
</span><span id="line-127"></span><span class="hs-keyword">data</span><span> </span><span id="ParserId"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-var">ParserId</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621689161724"><span class="annot"><a href="#local-6989586621689161724"><span class="hs-identifier hs-type">t</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-128"></span><span>  </span><span id="local-6989586621689161721"><span id="local-6989586621689161722"><span id="local-6989586621689161723"><span id="ParserId"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-var">ParserId</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">Ord</span></span><span> </span><span class="annot"><a href="#local-6989586621689161723"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span> </span><span class="annot"><a href="#local-6989586621689161722"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span> </span><span class="annot"><a href="#local-6989586621689161723"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Typeable</span></span><span> </span><span class="annot"><a href="#local-6989586621689161721"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">TH.Name</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="#local-6989586621689161723"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span class="hs-special">'</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621689161722"><span class="hs-identifier hs-type">p</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621689161721"><span class="hs-identifier hs-type">b</span></a></span><span class="hs-special">)</span></span></span></span><span>
</span><span id="line-129"></span><span>
</span><span id="line-130"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">GEq</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-131"></span><span>  </span><span id="local-6989586621689161718"><span class="annot"><span class="annottext">geq :: ParserId a -&gt; ParserId b -&gt; Maybe (a :~: b)
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">geq</span></span></span><span>
</span><span id="line-132"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621689161716"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span id="local-6989586621689161715"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161715"><span class="hs-identifier hs-var">name1</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621689161714"><span id="local-6989586621689161713"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689161713"><span class="hs-identifier hs-var">arg1</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621689161714"><span class="hs-identifier hs-type">a1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161716"><span class="hs-identifier hs-type">t1</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-133"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621689161712"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span id="local-6989586621689161711"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161711"><span class="hs-identifier hs-var">name2</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621689161710"><span id="local-6989586621689161709"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689161709"><span class="hs-identifier hs-var">arg2</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621689161710"><span class="hs-identifier hs-type">a2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161712"><span class="hs-identifier hs-type">t2</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-134"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621689161707"><span id="local-6989586621689161708"><span class="annot"><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Proxy</span></span><span> </span><span class="hs-special">'</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621689161708"><span class="hs-identifier hs-type">p1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621689161707"><span class="hs-identifier hs-type">b1</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Proxy a
forall k (t :: k). Proxy t
</span><span class="hs-identifier hs-var">Proxy</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161716"><span class="hs-identifier hs-type">t1</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-135"></span><span>        </span><span id="local-6989586621689161704"><span id="local-6989586621689161705"><span class="annot"><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Proxy</span></span><span> </span><span class="hs-special">'</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621689161705"><span class="hs-identifier hs-type">p2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621689161704"><span class="hs-identifier hs-type">b2</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Proxy b
forall k (t :: k). Proxy t
</span><span class="hs-identifier hs-var">Proxy</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161712"><span class="hs-identifier hs-type">t2</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-136"></span><span>        </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161715"><span class="hs-identifier hs-var">name1</span></a></span><span> </span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161711"><span class="hs-identifier hs-var">name2</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-137"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">a :~: a
</span><span class="hs-identifier hs-var">Refl</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Typeable a =&gt; TypeRep a
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161714"><span class="hs-identifier hs-type">a1</span></a></span><span> </span><span class="annot"><span class="annottext">TypeRep a -&gt; TypeRep a -&gt; Maybe (a :~: a)
forall k (f :: k -&gt; *) (a :: k) (b :: k).
GEq f =&gt;
f a -&gt; f b -&gt; Maybe (a :~: b)
</span><span class="hs-operator hs-var">`geq`</span></span><span> </span><span class="annot"><span class="annottext">Typeable a =&gt; TypeRep a
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161710"><span class="hs-identifier hs-type">a2</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-138"></span><span>        </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689161713"><span class="hs-identifier hs-var">arg1</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; a -&gt; Bool
forall a. Eq a =&gt; a -&gt; a -&gt; Bool
</span><span class="hs-operator hs-var">==</span></span><span> </span><span class="annot"><span class="annottext">a
a
</span><a href="#local-6989586621689161709"><span class="hs-identifier hs-var">arg2</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-139"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">p :~: p
</span><span class="hs-identifier hs-var">Refl</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Typeable p =&gt; TypeRep p
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161708"><span class="hs-identifier hs-type">p1</span></a></span><span> </span><span class="annot"><span class="annottext">TypeRep p -&gt; TypeRep p -&gt; Maybe (p :~: p)
forall k (f :: k -&gt; *) (a :: k) (b :: k).
GEq f =&gt;
f a -&gt; f b -&gt; Maybe (a :~: b)
</span><span class="hs-operator hs-var">`geq`</span></span><span> </span><span class="annot"><span class="annottext">Typeable p =&gt; TypeRep p
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161705"><span class="hs-identifier hs-type">p2</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-140"></span><span>        </span><span class="annot"><span class="hs-identifier hs-type">Just</span></span><span> </span><span class="annot"><span class="annottext">b :~: b
</span><span class="hs-identifier hs-var">Refl</span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Typeable b =&gt; TypeRep b
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161707"><span class="hs-identifier hs-type">b1</span></a></span><span> </span><span class="annot"><span class="annottext">TypeRep b -&gt; TypeRep b -&gt; Maybe (b :~: b)
forall k (f :: k -&gt; *) (a :: k) (b :: k).
GEq f =&gt;
f a -&gt; f b -&gt; Maybe (a :~: b)
</span><span class="hs-operator hs-var">`geq`</span></span><span> </span><span class="annot"><span class="annottext">Typeable b =&gt; TypeRep b
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161704"><span class="hs-identifier hs-type">b2</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-141"></span><span>        </span><span class="annot"><span class="annottext">(a :~: a) -&gt; Maybe (a :~: a)
forall a. a -&gt; Maybe a
</span><span class="hs-identifier hs-var">Just</span></span><span> </span><span class="annot"><span class="annottext">a :~: a
forall k (a :: k). a :~: a
</span><span class="hs-identifier hs-var">Refl</span></span><span>
</span><span id="line-142"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span class="annot"><span class="annottext">Bool
</span><span class="hs-identifier hs-var">otherwise</span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Maybe (a :~: b)
forall a. Maybe a
</span><span class="hs-identifier hs-var">Nothing</span></span><span>
</span><span id="line-143"></span><span>
</span><span id="line-144"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><span class="hs-identifier hs-type">GCompare</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-145"></span><span>  </span><span id="local-6989586621689161699"><span class="annot"><span class="annottext">gcompare :: ParserId a -&gt; ParserId b -&gt; GOrdering a b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var">gcompare</span></span></span><span>
</span><span id="line-146"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621689161697"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span id="local-6989586621689161696"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161696"><span class="hs-identifier hs-var">name1</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621689161695"><span id="local-6989586621689161694"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689161694"><span class="hs-identifier hs-var">arg1</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621689161695"><span class="hs-identifier hs-type">a1</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161697"><span class="hs-identifier hs-type">t1</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-147"></span><span>    </span><span class="hs-special">(</span><span id="local-6989586621689161693"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span id="local-6989586621689161692"><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161692"><span class="hs-identifier hs-var">name2</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621689161691"><span id="local-6989586621689161690"><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689161690"><span class="hs-identifier hs-var">arg2</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="#local-6989586621689161691"><span class="hs-identifier hs-type">a2</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserId"><span class="hs-identifier hs-type">ParserId</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161693"><span class="hs-identifier hs-type">t2</span></a></span></span><span class="hs-special">)</span><span>
</span><span id="line-148"></span><span>      </span><span class="hs-glyph">|</span><span> </span><span id="local-6989586621689161688"><span id="local-6989586621689161689"><span class="annot"><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Proxy</span></span><span> </span><span class="hs-special">'</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621689161689"><span class="hs-identifier hs-type">p1</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621689161688"><span class="hs-identifier hs-type">b1</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Proxy a
forall k (t :: k). Proxy t
</span><span class="hs-identifier hs-var">Proxy</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161697"><span class="hs-identifier hs-type">t1</span></a></span><span class="hs-special">,</span><span>
</span><span id="line-149"></span><span>        </span><span id="local-6989586621689161686"><span id="local-6989586621689161687"><span class="annot"><span class="hs-identifier">_</span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Proxy</span></span><span> </span><span class="hs-special">'</span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621689161687"><span class="hs-identifier hs-type">p2</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><a href="#local-6989586621689161686"><span class="hs-identifier hs-type">b2</span></a></span><span class="hs-special">)</span></span></span><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="annot"><span class="annottext">Proxy b
forall k (t :: k). Proxy t
</span><span class="hs-identifier hs-var">Proxy</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161693"><span class="hs-identifier hs-type">t2</span></a></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-150"></span><span>        </span><span class="annot"><span class="annottext">Ordering -&gt; GOrdering Any Any
forall k (a :: k). Ordering -&gt; GOrdering a a
</span><a href="Data.GADT.Compare.Extended.html#strengthenOrdering"><span class="hs-identifier hs-var">strengthenOrdering</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Name -&gt; Name -&gt; Ordering
forall a. Ord a =&gt; a -&gt; a -&gt; Ordering
</span><span class="hs-identifier hs-var">compare</span></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161696"><span class="hs-identifier hs-var">name1</span></a></span><span> </span><span class="annot"><span class="annottext">Name
</span><a href="#local-6989586621689161692"><span class="hs-identifier hs-var">name2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-151"></span><span>          </span><span class="annot"><span class="annottext">GOrdering Any Any
-&gt; ((Any ~ Any) =&gt; GOrdering a b) -&gt; GOrdering a b
forall k1 k2 (a :: k1) (b :: k1) (c :: k2) (d :: k2).
GOrdering a b -&gt; ((a ~ b) =&gt; GOrdering c d) -&gt; GOrdering c d
</span><a href="Data.GADT.Compare.Extended.html#extendGOrdering"><span class="hs-operator hs-var">`extendGOrdering`</span></a></span><span> </span><span class="annot"><span class="annottext">TypeRep a -&gt; TypeRep a -&gt; GOrdering a a
forall k (f :: k -&gt; *) (a :: k) (b :: k).
GCompare f =&gt;
f a -&gt; f b -&gt; GOrdering a b
</span><span class="hs-identifier hs-var">gcompare</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Typeable a =&gt; TypeRep a
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161695"><span class="hs-identifier hs-type">a1</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Typeable a =&gt; TypeRep a
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161691"><span class="hs-identifier hs-type">a2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-152"></span><span>          </span><span class="annot"><span class="annottext">GOrdering a a -&gt; ((a ~ a) =&gt; GOrdering a b) -&gt; GOrdering a b
forall k1 k2 (a :: k1) (b :: k1) (c :: k2) (d :: k2).
GOrdering a b -&gt; ((a ~ b) =&gt; GOrdering c d) -&gt; GOrdering c d
</span><a href="Data.GADT.Compare.Extended.html#extendGOrdering"><span class="hs-operator hs-var">`extendGOrdering`</span></a></span><span> </span><span class="annot"><span class="annottext">Ordering -&gt; GOrdering Any Any
forall k (a :: k). Ordering -&gt; GOrdering a a
</span><a href="Data.GADT.Compare.Extended.html#strengthenOrdering"><span class="hs-identifier hs-var">strengthenOrdering</span></a></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">a -&gt; a -&gt; Ordering
forall a. Ord a =&gt; a -&gt; a -&gt; Ordering
</span><span class="hs-identifier hs-var">compare</span></span><span> </span><span class="annot"><span class="annottext">a
</span><a href="#local-6989586621689161694"><span class="hs-identifier hs-var">arg1</span></a></span><span> </span><span class="annot"><span class="annottext">a
a
</span><a href="#local-6989586621689161690"><span class="hs-identifier hs-var">arg2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-153"></span><span>          </span><span class="annot"><span class="annottext">GOrdering Any Any
-&gt; ((Any ~ Any) =&gt; GOrdering a b) -&gt; GOrdering a b
forall k1 k2 (a :: k1) (b :: k1) (c :: k2) (d :: k2).
GOrdering a b -&gt; ((a ~ b) =&gt; GOrdering c d) -&gt; GOrdering c d
</span><a href="Data.GADT.Compare.Extended.html#extendGOrdering"><span class="hs-operator hs-var">`extendGOrdering`</span></a></span><span> </span><span class="annot"><span class="annottext">TypeRep p -&gt; TypeRep p -&gt; GOrdering p p
forall k (f :: k -&gt; *) (a :: k) (b :: k).
GCompare f =&gt;
f a -&gt; f b -&gt; GOrdering a b
</span><span class="hs-identifier hs-var">gcompare</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Typeable p =&gt; TypeRep p
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161689"><span class="hs-identifier hs-type">p1</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Typeable p =&gt; TypeRep p
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161687"><span class="hs-identifier hs-type">p2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-154"></span><span>          </span><span class="annot"><span class="annottext">GOrdering p p -&gt; ((p ~ p) =&gt; GOrdering a b) -&gt; GOrdering a b
forall k1 k2 (a :: k1) (b :: k1) (c :: k2) (d :: k2).
GOrdering a b -&gt; ((a ~ b) =&gt; GOrdering c d) -&gt; GOrdering c d
</span><a href="Data.GADT.Compare.Extended.html#extendGOrdering"><span class="hs-operator hs-var">`extendGOrdering`</span></a></span><span> </span><span class="annot"><span class="annottext">TypeRep b -&gt; TypeRep b -&gt; GOrdering b b
forall k (f :: k -&gt; *) (a :: k) (b :: k).
GCompare f =&gt;
f a -&gt; f b -&gt; GOrdering a b
</span><span class="hs-identifier hs-var">gcompare</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Typeable b =&gt; TypeRep b
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161688"><span class="hs-identifier hs-type">b1</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Typeable b =&gt; TypeRep b
forall k (a :: k). Typeable a =&gt; TypeRep a
</span><span class="hs-identifier hs-var">typeRep</span></span><span> </span><span class="hs-glyph">@</span><span class="annot"><a href="#local-6989586621689161686"><span class="hs-identifier hs-type">b2</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-155"></span><span>          </span><span class="annot"><span class="annottext">GOrdering b b -&gt; ((b ~ b) =&gt; GOrdering a b) -&gt; GOrdering a b
forall k1 k2 (a :: k1) (b :: k1) (c :: k2) (d :: k2).
GOrdering a b -&gt; ((a ~ b) =&gt; GOrdering c d) -&gt; GOrdering c d
</span><a href="Data.GADT.Compare.Extended.html#extendGOrdering"><span class="hs-operator hs-var">`extendGOrdering`</span></a></span><span> </span><span class="annot"><span class="annottext">(b ~ b) =&gt; GOrdering a b
forall k (a :: k). GOrdering a a
</span><span class="hs-identifier hs-var">GEQ</span></span><span>
</span><span id="line-156"></span><span>
</span><span id="line-157"></span><span class="hs-comment">-- | A newtype wrapper around a 'Parser' that rearranges the type parameters</span><span>
</span><span id="line-158"></span><span class="hs-comment">-- so that it can be indexed by a 'ParserId' in a 'DMap'.</span><span>
</span><span id="line-159"></span><span class="hs-comment">--</span><span>
</span><span id="line-160"></span><span class="hs-comment">-- This is really just a single newtype, but it&#8217;s implemented as a data family</span><span>
</span><span id="line-161"></span><span class="hs-comment">-- because GHC doesn&#8217;t allow ordinary datatype declarations to pattern-match on</span><span>
</span><span id="line-162"></span><span class="hs-comment">-- type parameters, and we want to match on the tuple.</span><span>
</span><span id="line-163"></span><span class="hs-keyword">data</span><span> </span><span class="hs-keyword">family</span><span> </span><span id="ParserById"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserById"><span class="hs-identifier hs-var">ParserById</span></a></span></span><span> </span><span class="hs-special">(</span><span id="local-6989586621689161681"><span class="annot"><a href="#local-6989586621689161681"><span class="hs-identifier hs-type">m</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-special">(</span><span id="local-6989586621689161680"><span class="annot"><a href="#local-6989586621689161680"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="hs-identifier hs-type">K.Type</span></span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><span id="line-164"></span><span>
</span><span id="line-165"></span><span class="hs-keyword">newtype</span><span> </span><span class="hs-keyword">instance</span><span> </span><span id="ParserById"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserById"><span class="hs-identifier hs-var">ParserById</span></a></span></span><span> </span><span id="local-6989586621689161948"><span class="annot"><a href="#local-6989586621689161948"><span class="hs-identifier hs-type hs-type">m</span></a></span></span><span> </span><span class="hs-special">'</span><span class="hs-special">(</span><span id="local-6989586621689161949"><span class="annot"><a href="#local-6989586621689161949"><span class="hs-identifier hs-type hs-type">p</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689161947"><span class="annot"><a href="#local-6989586621689161947"><span class="hs-identifier hs-type hs-type">a</span></a></span></span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ParserById"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParserById"><span class="hs-identifier hs-var">ParserById</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="#local-6989586621689161949"><span class="hs-identifier hs-type">p</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161948"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161947"><span class="hs-identifier hs-type">a</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-166"></span><span>
</span><span id="line-167"></span><span class="hs-comment">-- -------------------------------------------------------------------------------------------------</span><span>
</span><span id="line-168"></span><span class="hs-comment">-- query parsing</span><span>
</span><span id="line-169"></span><span>
</span><span id="line-170"></span><span class="hs-keyword">newtype</span><span> </span><span id="Parse"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#Parse"><span class="hs-identifier hs-var">Parse</span></a></span></span><span> </span><span id="local-6989586621689161838"><span class="annot"><a href="#local-6989586621689161838"><span class="hs-identifier hs-type">a</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="Parse"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#Parse"><span class="hs-identifier hs-var">Parse</span></a></span></span><span>
</span><span id="line-171"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="unParse"><span class="annot"><span class="annottext">Parse a -&gt; Except ParseError a
</span><a href="Hasura.GraphQL.Parser.Monad.html#unParse"><span class="hs-identifier hs-var hs-var">unParse</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Except</span></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParseError"><span class="hs-identifier hs-type">ParseError</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161838"><span class="hs-identifier hs-type">a</span></a></span><span>
</span><span id="line-172"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-173"></span><span>  </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-special">(</span><span id="local-6989586621689161674"><span id="local-6989586621689161676"><span class="annot"><span class="annottext">a -&gt; Parse b -&gt; Parse a
(a -&gt; b) -&gt; Parse a -&gt; Parse b
(forall a b. (a -&gt; b) -&gt; Parse a -&gt; Parse b)
-&gt; (forall a b. a -&gt; Parse b -&gt; Parse a) -&gt; Functor Parse
forall a b. a -&gt; Parse b -&gt; Parse a
forall a b. (a -&gt; b) -&gt; Parse a -&gt; Parse b
forall (f :: * -&gt; *).
(forall a b. (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b. a -&gt; f b -&gt; f a) -&gt; Functor f
&lt;$ :: a -&gt; Parse b -&gt; Parse a
$c&lt;$ :: forall a b. a -&gt; Parse b -&gt; Parse a
fmap :: (a -&gt; b) -&gt; Parse a -&gt; Parse b
$cfmap :: forall a b. (a -&gt; b) -&gt; Parse a -&gt; Parse b
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var">Functor</span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689161663"><span id="local-6989586621689161665"><span id="local-6989586621689161667"><span id="local-6989586621689161669"><span id="local-6989586621689161671"><span class="annot"><span class="annottext">Functor Parse
a -&gt; Parse a
Functor Parse
-&gt; (forall a. a -&gt; Parse a)
-&gt; (forall a b. Parse (a -&gt; b) -&gt; Parse a -&gt; Parse b)
-&gt; (forall a b c. (a -&gt; b -&gt; c) -&gt; Parse a -&gt; Parse b -&gt; Parse c)
-&gt; (forall a b. Parse a -&gt; Parse b -&gt; Parse b)
-&gt; (forall a b. Parse a -&gt; Parse b -&gt; Parse a)
-&gt; Applicative Parse
Parse a -&gt; Parse b -&gt; Parse b
Parse a -&gt; Parse b -&gt; Parse a
Parse (a -&gt; b) -&gt; Parse a -&gt; Parse b
(a -&gt; b -&gt; c) -&gt; Parse a -&gt; Parse b -&gt; Parse c
forall a. a -&gt; Parse a
forall a b. Parse a -&gt; Parse b -&gt; Parse a
forall a b. Parse a -&gt; Parse b -&gt; Parse b
forall a b. Parse (a -&gt; b) -&gt; Parse a -&gt; Parse b
forall a b c. (a -&gt; b -&gt; c) -&gt; Parse a -&gt; Parse b -&gt; Parse c
forall (f :: * -&gt; *).
Functor f
-&gt; (forall a. a -&gt; f a)
-&gt; (forall a b. f (a -&gt; b) -&gt; f a -&gt; f b)
-&gt; (forall a b c. (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c)
-&gt; (forall a b. f a -&gt; f b -&gt; f b)
-&gt; (forall a b. f a -&gt; f b -&gt; f a)
-&gt; Applicative f
&lt;* :: Parse a -&gt; Parse b -&gt; Parse a
$c&lt;* :: forall a b. Parse a -&gt; Parse b -&gt; Parse a
*&gt; :: Parse a -&gt; Parse b -&gt; Parse b
$c*&gt; :: forall a b. Parse a -&gt; Parse b -&gt; Parse b
liftA2 :: (a -&gt; b -&gt; c) -&gt; Parse a -&gt; Parse b -&gt; Parse c
$cliftA2 :: forall a b c. (a -&gt; b -&gt; c) -&gt; Parse a -&gt; Parse b -&gt; Parse c
&lt;*&gt; :: Parse (a -&gt; b) -&gt; Parse a -&gt; Parse b
$c&lt;*&gt; :: forall a b. Parse (a -&gt; b) -&gt; Parse a -&gt; Parse b
pure :: a -&gt; Parse a
$cpure :: forall a. a -&gt; Parse a
$cp1Applicative :: Functor Parse
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Applicative</span></span></span></span></span></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689161656"><span id="local-6989586621689161658"><span id="local-6989586621689161660"><span class="annot"><span class="annottext">Applicative Parse
a -&gt; Parse a
Applicative Parse
-&gt; (forall a b. Parse a -&gt; (a -&gt; Parse b) -&gt; Parse b)
-&gt; (forall a b. Parse a -&gt; Parse b -&gt; Parse b)
-&gt; (forall a. a -&gt; Parse a)
-&gt; Monad Parse
Parse a -&gt; (a -&gt; Parse b) -&gt; Parse b
Parse a -&gt; Parse b -&gt; Parse b
forall a. a -&gt; Parse a
forall a b. Parse a -&gt; Parse b -&gt; Parse b
forall a b. Parse a -&gt; (a -&gt; Parse b) -&gt; Parse b
forall (m :: * -&gt; *).
Applicative m
-&gt; (forall a b. m a -&gt; (a -&gt; m b) -&gt; m b)
-&gt; (forall a b. m a -&gt; m b -&gt; m b)
-&gt; (forall a. a -&gt; m a)
-&gt; Monad m
return :: a -&gt; Parse a
$creturn :: forall a. a -&gt; Parse a
&gt;&gt; :: Parse a -&gt; Parse b -&gt; Parse b
$c&gt;&gt; :: forall a b. Parse a -&gt; Parse b -&gt; Parse b
&gt;&gt;= :: Parse a -&gt; (a -&gt; Parse b) -&gt; Parse b
$c&gt;&gt;= :: forall a b. Parse a -&gt; (a -&gt; Parse b) -&gt; Parse b
$cp1Monad :: Applicative Parse
</span><span class="hs-identifier hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var hs-var">Monad</span></span></span></span></span><span class="hs-special">)</span><span>
</span><span id="line-174"></span><span>
</span><span id="line-175"></span><span id="local-6989586621689161654"><span id="local-6989586621689161655"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#runParse"><span class="hs-identifier hs-type">runParse</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-176"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">MonadError</span></span><span> </span><span class="annot"><a href="Hasura.Base.Error.html#QErr"><span class="hs-identifier hs-type">QErr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161655"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-177"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#Parse"><span class="hs-identifier hs-type">Parse</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161654"><span class="hs-identifier hs-type">a</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-178"></span><span>  </span><span class="annot"><a href="#local-6989586621689161655"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161654"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-179"></span><span id="runParse"><span class="annot"><span class="annottext">runParse :: Parse a -&gt; m a
</span><a href="Hasura.GraphQL.Parser.Monad.html#runParse"><span class="hs-identifier hs-var hs-var">runParse</span></a></span></span><span> </span><span id="local-6989586621689161653"><span class="annot"><span class="annottext">Parse a
</span><a href="#local-6989586621689161653"><span class="hs-identifier hs-var">parse</span></a></span></span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-180"></span><span>  </span><span class="annot"><span class="annottext">(ParseError -&gt; m a) -&gt; (a -&gt; m a) -&gt; Either ParseError a -&gt; m a
forall a c b. (a -&gt; c) -&gt; (b -&gt; c) -&gt; Either a b -&gt; c
</span><span class="hs-identifier hs-var">either</span></span><span> </span><span class="annot"><span class="annottext">ParseError -&gt; m a
forall (m :: * -&gt; *) a. MonadError QErr m =&gt; ParseError -&gt; m a
</span><a href="Hasura.GraphQL.Parser.Monad.html#reportParseErrors"><span class="hs-identifier hs-var">reportParseErrors</span></a></span><span> </span><span class="annot"><span class="annottext">a -&gt; m a
forall (f :: * -&gt; *) a. Applicative f =&gt; a -&gt; f a
</span><span class="hs-identifier hs-var">pure</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Except ParseError a -&gt; Either ParseError a
forall e a. Except e a -&gt; Either e a
</span><span class="hs-identifier hs-var">runExcept</span></span><span> </span><span class="annot"><span class="annottext">(Except ParseError a -&gt; Either ParseError a)
-&gt; (Parse a -&gt; Except ParseError a)
-&gt; Parse a
-&gt; Either ParseError a
forall k (cat :: k -&gt; k -&gt; *) (b :: k) (c :: k) (a :: k).
Category cat =&gt;
cat b c -&gt; cat a b -&gt; cat a c
</span><span class="hs-operator hs-var">&lt;&lt;&lt;</span></span><span> </span><span class="annot"><span class="annottext">Parse a -&gt; Except ParseError a
forall a. Parse a -&gt; Except ParseError a
</span><a href="Hasura.GraphQL.Parser.Monad.html#unParse"><span class="hs-identifier hs-var hs-var">unParse</span></a></span><span> </span><span class="annot"><span class="annottext">(Parse a -&gt; Either ParseError a) -&gt; Parse a -&gt; Either ParseError a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">Parse a
</span><a href="#local-6989586621689161653"><span class="hs-identifier hs-var">parse</span></a></span><span class="hs-special">)</span><span>
</span><span id="line-181"></span><span>
</span><span id="line-182"></span><span class="hs-keyword">instance</span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Class.Parse.html#MonadParse"><span class="hs-identifier hs-type">MonadParse</span></a></span><span> </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#Parse"><span class="hs-identifier hs-type">Parse</span></a></span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-183"></span><span>  </span><span id="local-6989586621689161645"><span class="annot"><span class="annottext">withKey :: JSONPathElement -&gt; Parse a -&gt; Parse a
</span><a href="Hasura.GraphQL.Parser.Class.Parse.html#withKey"><span class="hs-identifier hs-var hs-var hs-var hs-var">withKey</span></a></span></span><span> </span><span id="local-6989586621689161643"><span class="annot"><span class="annottext">JSONPathElement
</span><a href="#local-6989586621689161643"><span class="hs-identifier hs-var">key</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Except ParseError a -&gt; Parse a
forall a. Except ParseError a -&gt; Parse a
</span><a href="Hasura.GraphQL.Parser.Monad.html#Parse"><span class="hs-identifier hs-var">Parse</span></a></span><span> </span><span class="annot"><span class="annottext">(Except ParseError a -&gt; Parse a)
-&gt; (Parse a -&gt; Except ParseError a) -&gt; Parse a -&gt; Parse a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">(ParseError -&gt; ParseError)
-&gt; Except ParseError a -&gt; Except ParseError a
forall (m :: * -&gt; *) e e' a.
Functor m =&gt;
(e -&gt; e') -&gt; ExceptT e m a -&gt; ExceptT e' m a
</span><span class="hs-identifier hs-var">withExceptT</span></span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><span id="local-6989586621689161641"><span class="annot"><span class="annottext">ParseError
</span><a href="#local-6989586621689161641"><span class="hs-identifier hs-var">pe</span></a></span></span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="annot"><span class="annottext">ParseError
</span><a href="#local-6989586621689161641"><span class="hs-identifier hs-var">pe</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">pePath :: JSONPath
</span><a href="Hasura.GraphQL.Parser.Monad.html#pePath"><span class="hs-identifier hs-var">pePath</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">JSONPathElement
</span><a href="#local-6989586621689161643"><span class="hs-identifier hs-var">key</span></a></span><span> </span><span class="annot"><span class="annottext">JSONPathElement -&gt; JSONPath -&gt; JSONPath
forall a. a -&gt; [a] -&gt; [a]
</span><span class="hs-glyph hs-var">:</span></span><span> </span><span class="annot"><span class="annottext">ParseError -&gt; JSONPath
</span><a href="Hasura.GraphQL.Parser.Monad.html#pePath"><span class="hs-identifier hs-var hs-var">pePath</span></a></span><span> </span><span class="annot"><span class="annottext">ParseError
</span><a href="#local-6989586621689161641"><span class="hs-identifier hs-var">pe</span></a></span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="annot"><span class="annottext">(Except ParseError a -&gt; Except ParseError a)
-&gt; (Parse a -&gt; Except ParseError a)
-&gt; Parse a
-&gt; Except ParseError a
forall b c a. (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c
</span><span class="hs-operator hs-var">.</span></span><span> </span><span class="annot"><span class="annottext">Parse a -&gt; Except ParseError a
forall a. Parse a -&gt; Except ParseError a
</span><a href="Hasura.GraphQL.Parser.Monad.html#unParse"><span class="hs-identifier hs-var hs-var">unParse</span></a></span><span>
</span><span id="line-184"></span><span>  </span><span id="local-6989586621689161639"><span class="annot"><span class="annottext">parseErrorWith :: Code -&gt; Text -&gt; Parse a
</span><a href="Hasura.GraphQL.Parser.Class.Parse.html#parseErrorWith"><span class="hs-identifier hs-var hs-var hs-var hs-var">parseErrorWith</span></a></span></span><span> </span><span id="local-6989586621689161637"><span class="annot"><span class="annottext">Code
</span><a href="#local-6989586621689161637"><span class="hs-identifier hs-var">code</span></a></span></span><span> </span><span id="local-6989586621689161636"><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621689161636"><span class="hs-identifier hs-var">text</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Except ParseError a -&gt; Parse a
forall a. Except ParseError a -&gt; Parse a
</span><a href="Hasura.GraphQL.Parser.Monad.html#Parse"><span class="hs-identifier hs-var">Parse</span></a></span><span> </span><span class="annot"><span class="annottext">(Except ParseError a -&gt; Parse a) -&gt; Except ParseError a -&gt; Parse a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="hs-keyword">do</span><span>
</span><span id="line-185"></span><span>    </span><span class="annot"><span class="annottext">ParseError -&gt; Except ParseError a
forall e (m :: * -&gt; *) a. MonadError e m =&gt; e -&gt; m a
</span><span class="hs-identifier hs-var">throwError</span></span><span> </span><span class="annot"><span class="annottext">(ParseError -&gt; Except ParseError a)
-&gt; ParseError -&gt; Except ParseError a
forall a b. (a -&gt; b) -&gt; a -&gt; b
</span><span class="hs-operator hs-var">$</span></span><span> </span><span class="annot"><span class="annottext">ParseError :: JSONPath -&gt; Text -&gt; Code -&gt; ParseError
</span><a href="Hasura.GraphQL.Parser.Monad.html#ParseError"><span class="hs-identifier hs-type">ParseError</span></a></span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">peCode :: Code
</span><a href="Hasura.GraphQL.Parser.Monad.html#peCode"><span class="hs-identifier hs-var">peCode</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Code
</span><a href="#local-6989586621689161637"><span class="hs-identifier hs-var">code</span></a></span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">pePath :: JSONPath
</span><a href="Hasura.GraphQL.Parser.Monad.html#pePath"><span class="hs-identifier hs-var">pePath</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">[</span><span class="hs-special">]</span><span class="hs-special">,</span><span> </span><span class="annot"><span class="annottext">peMessage :: Text
</span><a href="Hasura.GraphQL.Parser.Monad.html#peMessage"><span class="hs-identifier hs-var">peMessage</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621689161636"><span class="hs-identifier hs-var">text</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-186"></span><span>
</span><span id="line-187"></span><span class="hs-keyword">data</span><span> </span><span id="ParseError"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParseError"><span class="hs-identifier hs-var">ParseError</span></a></span></span><span> </span><span class="hs-glyph">=</span><span> </span><span id="ParseError"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParseError"><span class="hs-identifier hs-var">ParseError</span></a></span></span><span>
</span><span id="line-188"></span><span>  </span><span class="hs-special">{</span><span> </span><span id="pePath"><span class="annot"><span class="annottext">ParseError -&gt; JSONPath
</span><a href="Hasura.GraphQL.Parser.Monad.html#pePath"><span class="hs-identifier hs-var hs-var">pePath</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">JSONPath</span></span><span class="hs-special">,</span><span>
</span><span id="line-189"></span><span>    </span><span id="peMessage"><span class="annot"><span class="annottext">ParseError -&gt; Text
</span><a href="Hasura.GraphQL.Parser.Monad.html#peMessage"><span class="hs-identifier hs-var hs-var">peMessage</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><span class="hs-identifier hs-type">Text</span></span><span class="hs-special">,</span><span>
</span><span id="line-190"></span><span>    </span><span id="peCode"><span class="annot"><span class="annottext">ParseError -&gt; Code
</span><a href="Hasura.GraphQL.Parser.Monad.html#peCode"><span class="hs-identifier hs-var hs-var">peCode</span></a></span></span><span> </span><span class="hs-glyph">::</span><span> </span><span class="annot"><a href="Hasura.Base.Error.html#Code"><span class="hs-identifier hs-type">Code</span></a></span><span>
</span><span id="line-191"></span><span>  </span><span class="hs-special">}</span><span>
</span><span id="line-192"></span><span>
</span><span id="line-193"></span><span id="local-6989586621689161847"><span id="local-6989586621689161848"><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#reportParseErrors"><span class="hs-identifier hs-type">reportParseErrors</span></a></span><span> </span><span class="hs-glyph">::</span><span>
</span><span id="line-194"></span><span>  </span><span class="annot"><span class="hs-identifier hs-type">MonadError</span></span><span> </span><span class="annot"><a href="Hasura.Base.Error.html#QErr"><span class="hs-identifier hs-type">QErr</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161848"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="hs-glyph">=&gt;</span><span>
</span><span id="line-195"></span><span>  </span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParseError"><span class="hs-identifier hs-type">ParseError</span></a></span><span> </span><span class="hs-glyph">-&gt;</span><span>
</span><span id="line-196"></span><span>  </span><span class="annot"><a href="#local-6989586621689161848"><span class="hs-identifier hs-type">m</span></a></span><span> </span><span class="annot"><a href="#local-6989586621689161847"><span class="hs-identifier hs-type">a</span></a></span></span></span><span>
</span><span id="line-197"></span><span id="reportParseErrors"><span class="annot"><span class="annottext">reportParseErrors :: ParseError -&gt; m a
</span><a href="Hasura.GraphQL.Parser.Monad.html#reportParseErrors"><span class="hs-identifier hs-var hs-var">reportParseErrors</span></a></span></span><span> </span><span class="hs-special">(</span><span class="annot"><a href="Hasura.GraphQL.Parser.Monad.html#ParseError"><span class="hs-identifier hs-type">ParseError</span></a></span><span> </span><span class="hs-special">{</span><span id="local-6989586621689161631"><span class="annot"><span class="annottext">JSONPath
pePath :: JSONPath
pePath :: ParseError -&gt; JSONPath
</span><a href="#local-6989586621689161631"><span class="hs-identifier hs-var hs-var">pePath</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689161630"><span class="annot"><span class="annottext">Text
peMessage :: Text
peMessage :: ParseError -&gt; Text
</span><a href="#local-6989586621689161630"><span class="hs-identifier hs-var hs-var">peMessage</span></a></span></span><span class="hs-special">,</span><span> </span><span id="local-6989586621689161629"><span class="annot"><span class="annottext">Code
peCode :: Code
peCode :: ParseError -&gt; Code
</span><a href="#local-6989586621689161629"><span class="hs-identifier hs-var hs-var">peCode</span></a></span></span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><span id="line-198"></span><span>  </span><span class="annot"><span class="annottext">QErr -&gt; m a
forall e (m :: * -&gt; *) a. MonadError e m =&gt; e -&gt; m a
</span><span class="hs-identifier hs-var">throwError</span></span><span> </span><span class="hs-special">(</span><span class="annot"><span class="annottext">Code -&gt; Text -&gt; QErr
</span><a href="Hasura.Base.Error.html#err400"><span class="hs-identifier hs-var">err400</span></a></span><span> </span><span class="annot"><span class="annottext">Code
</span><a href="#local-6989586621689161629"><span class="hs-identifier hs-var">peCode</span></a></span><span> </span><span class="annot"><span class="annottext">Text
</span><a href="#local-6989586621689161630"><span class="hs-identifier hs-var">peMessage</span></a></span><span class="hs-special">)</span><span> </span><span class="hs-special">{</span><span class="annot"><span class="annottext">qePath :: JSONPath
</span><a href="Hasura.Base.Error.html#qePath"><span class="hs-identifier hs-var">qePath</span></a></span><span> </span><span class="hs-glyph">=</span><span> </span><span class="annot"><span class="annottext">JSONPath
</span><a href="#local-6989586621689161631"><span class="hs-identifier hs-var">pePath</span></a></span><span class="hs-special">}</span><span>
</span><span id="line-199"></span></pre></body></html>